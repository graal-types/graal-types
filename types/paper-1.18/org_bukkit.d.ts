declare module 'org.bukkit.event.hanging' {
import { RemoveCause } from 'org.bukkit.event.hanging.HangingBreakEvent';
import { BlockFace, Block } from 'org.bukkit.block';
import { HandlerList, Cancellable, Event } from 'org.bukkit.event';
import { ItemStack } from 'org.bukkit.inventory';
import { Entity, Player, Hanging } from 'org.bukkit.entity';
/**
 * Triggered when a hanging entity is removed by an entity
*/
export class HangingBreakByEntityEvent extends HangingBreakEvent {
  constructor(hanging: Hanging, remover: Entity | null);
  constructor(hanging: Hanging, remover: Entity | null, cause: RemoveCause);
  /**
   * Gets the entity that removed the hanging entity.
   * May be null, for example when broken by an explosion.
   *
   * @return the entity that removed the hanging entity
  */
  getRemover(): Entity | null;
}
/**
 * Represents a hanging entity-related event.
*/
export class HangingEvent extends Event {
  /**
   * Gets the hanging entity involved in this event.
   *
   * @return the hanging entity
  */
  getEntity(): Hanging;
}
/**
 * Triggered when a hanging entity is removed
*/
export class HangingBreakEvent extends HangingEvent {
  constructor(hanging: Hanging, cause: RemoveCause);
  /**
   * Gets the cause for the hanging entity's removal
   *
   * @return the RemoveCause for the hanging entity's removal
  */
  getCause(): RemoveCause;
  /**
   * Gets the cancellation state of this event. A cancelled event will not
   * be executed in the server, but will still pass to other plugins
   *
   * @return true if this event is cancelled
  */
  isCancelled(): boolean;
  /**
   * Sets the cancellation state of this event. A cancelled event will not
   * be executed in the server, but will still pass to other plugins.
   *
   * @param cancel true if you wish to cancel this event
  */
  setCancelled(cancel: boolean): void;
  getHandlers(): HandlerList;
  static getHandlerList(): HandlerList;
}
export interface HangingBreakEvent extends HangingEvent, Cancellable {}
/**
 * Triggered when a hanging entity is created in the world
*/
export class HangingPlaceEvent extends HangingEvent {
  constructor(hanging: Hanging, player: Player | null, block: Block, blockFace: BlockFace);
  constructor(hanging: Hanging, player: Player | null, block: Block, blockFace: BlockFace, itemStack: ItemStack | null);
  /**
   * Returns the player placing the hanging entity
   *
   * @return the player placing the hanging entity
  */
  getPlayer(): Player | null;
  /**
   * Returns the block that the hanging entity was placed on
   *
   * @return the block that the hanging entity was placed on
  */
  getBlock(): Block;
  /**
   * Returns the face of the block that the hanging entity was placed on
   *
   * @return the face of the block that the hanging entity was placed on
  */
  getBlockFace(): BlockFace;
  /**
   * Gets the item from which the hanging entity originated
   *
   * @return the item from which the hanging entity originated
  */
  getItemStack(): ItemStack | null;
  /**
   * Gets the cancellation state of this event. A cancelled event will not
   * be executed in the server, but will still pass to other plugins
   *
   * @return true if this event is cancelled
  */
  isCancelled(): boolean;
  /**
   * Sets the cancellation state of this event. A cancelled event will not
   * be executed in the server, but will still pass to other plugins.
   *
   * @param cancel true if you wish to cancel this event
  */
  setCancelled(cancel: boolean): void;
  getHandlers(): HandlerList;
  static getHandlerList(): HandlerList;
}
export interface HangingPlaceEvent extends HangingEvent, Cancellable {}

}
declare module 'org.bukkit.boss.DragonBattle' {
import { Enum } from 'java.lang';
/**
 * Represents a phase in the dragon respawn process.
*/
export class RespawnPhase extends Enum<RespawnPhase> {
  /**
   * The crystal beams are directed upwards into the sky.
  */
  static readonly START: RespawnPhase;
  /**
   * The crystal beams remain directed upwards.
  */
  static readonly PREPARING_TO_SUMMON_PILLARS: RespawnPhase;
  /**
   * The crystal beams are directed from pillar to pillar, regenerating
   * their crystals if necessary.
  */
  static readonly SUMMONING_PILLARS: RespawnPhase;
  /**
   * All crystals (including those from the pillars) are aimed towards the
   * sky. Shortly thereafter summoning the dragon and destroying the
   * crystals used to initiate the dragon's respawn.
  */
  static readonly SUMMONING_DRAGON: RespawnPhase;
  /**
   * The end of the respawn sequence. The dragon is actually summoned.
  */
  static readonly END: RespawnPhase;
  /**
   * No respawn is in progress.
  */
  static readonly NONE: RespawnPhase;
  static valueOf(name: string): RespawnPhase;
  static values(): RespawnPhase[];
}

}
declare module 'org.bukkit.block.data.type.PointedDripstone' {
import { Enum } from 'java.lang';
/**
 * Represents the thickness of the dripstone, corresponding to its position
 * within a multi-block dripstone formation.
*/
export class Thickness extends Enum<Thickness> {
  /**
   * Extended tip.
  */
  static readonly TIP_MERGE: Thickness;
  /**
   * Just the tip.
  */
  static readonly TIP: Thickness;
  /**
   * Top section.
  */
  static readonly FRUSTUM: Thickness;
  /**
   * Middle section.
  */
  static readonly MIDDLE: Thickness;
  /**
   * Base.
  */
  static readonly BASE: Thickness;
  static valueOf(name: string): Thickness;
  static values(): Thickness[];
}

}
declare module 'org.bukkit.block.data.type.Bell' {
import { Enum } from 'java.lang';
/**
 * What the bell is attached to.
*/
export class Attachment extends Enum<Attachment> {
  /**
   * Placed on floor.
  */
  static readonly FLOOR: Attachment;
  /**
   * Placed on ceiling.
  */
  static readonly CEILING: Attachment;
  /**
   * Placed on one wall.
  */
  static readonly SINGLE_WALL: Attachment;
  /**
   * Placed between two walls.
  */
  static readonly DOUBLE_WALL: Attachment;
  static valueOf(name: string): Attachment;
  static values(): Attachment[];
}

}
declare module 'org.bukkit.event.Event' {
import { Enum } from 'java.lang';
export class Result extends Enum<Result> {
  /**
   * Deny the event. Depending on the event, the action indicated by the
   * event will either not take place or will be reverted. Some actions
   * may not be denied.
  */
  static readonly DENY: Result;
  /**
   * Neither deny nor allow the event. The server will proceed with its
   * normal handling.
  */
  static readonly DEFAULT: Result;
  /**
   * Allow / Force the event. The action indicated by the event will
   * take place if possible, even if the server would not normally allow
   * the action. Some actions may not be allowed.
  */
  static readonly ALLOW: Result;
  static valueOf(name: string): Result;
  static values(): Result[];
}

}
declare module 'org.bukkit.plugin.PluginAwareness' {
import { Enum } from 'java.lang';
/**
 * Each entry here represents a particular plugin's awareness. These can
 * be checked by using {@link PluginDescriptionFile#getAwareness()}.{@link
 * Set#contains(Object) contains(flag)}.
*/
export class Flags extends Enum<Flags> {
  /**
   * This specifies that all (text) resources stored in a plugin's jar
   * use UTF-8 encoding.
   *
   * @deprecated all plugins are now assumed to be UTF-8 aware.
  */
  static readonly UTF8: Flags;
  static valueOf(name: string): Flags;
  static values(): Flags[];
}

}
declare module 'org.bukkit.entity.Axolotl' {
import { Enum } from 'java.lang';
/**
 * Represents the variant of a axolotl - ie its color.
*/
export class Variant extends Enum<Variant> {
  /**
   * Leucistic (pink) axolotl.
  */
  static readonly LUCY: Variant;
  /**
   * Brown axolotl.
  */
  static readonly WILD: Variant;
  /**
   * Gold axolotl.
  */
  static readonly GOLD: Variant;
  /**
   * Cyan axolotl.
  */
  static readonly CYAN: Variant;
  /**
   * Blue axolotl.
  */
  static readonly BLUE: Variant;
  static valueOf(name: string): Variant;
  static values(): Variant[];
}

}
declare module 'org.bukkit.util.io' {
import { InputStream, OutputStream, ObjectOutputStream, ObjectInputStream } from 'java.io';
/**
 * This class is designed to be used in conjunction with the {@link
 * ConfigurationSerializable} API. It translates objects to an internal
 * implementation for later deserialization using {@link
 * BukkitObjectInputStream}.
 * 
 * Behavior of implementations extending this class is not guaranteed across
 * future versions.
*/
export class BukkitObjectOutputStream extends ObjectOutputStream {
  /**
   * Object output stream decoration constructor.
   *
   * @param out the stream to wrap
   * @throws IOException if an I/O error occurs while writing stream header
   * @see ObjectOutputStream#ObjectOutputStream(OutputStream)
  */
  constructor(out: OutputStream);
}
/**
 * This class is designed to be used in conjunction with the {@link
 * ConfigurationSerializable} API. It translates objects back to their
 * original implementation after being serialized by {@link
 * BukkitObjectInputStream}.
 * 
 * Behavior of implementations extending this class is not guaranteed across
 * future versions.
*/
export class BukkitObjectInputStream extends ObjectInputStream {
  /**
   * Object input stream decoration constructor.
   *
   * @param in the input stream to wrap
   * @throws IOException if an I/O error occurs while reading stream header
   * @see ObjectInputStream#ObjectInputStream(InputStream)
  */
  constructor(in_: InputStream);
}

}
declare module 'org.bukkit.block.data.type.Jigsaw' {
import { Enum } from 'java.lang';
/**
 * The directions the Jigsaw can be oriented.
*/
export class Orientation extends Enum<Orientation> {
  static readonly DOWN_EAST: Orientation;
  static readonly DOWN_NORTH: Orientation;
  static readonly DOWN_SOUTH: Orientation;
  static readonly DOWN_WEST: Orientation;
  static readonly UP_EAST: Orientation;
  static readonly UP_NORTH: Orientation;
  static readonly UP_SOUTH: Orientation;
  static readonly UP_WEST: Orientation;
  static readonly WEST_UP: Orientation;
  static readonly EAST_UP: Orientation;
  static readonly NORTH_UP: Orientation;
  static readonly SOUTH_UP: Orientation;
  static valueOf(name: string): Orientation;
  static values(): Orientation[];
}

}
declare module 'org.bukkit.event.block.CauldronLevelChangeEvent' {
import { Enum } from 'java.lang';
export class ChangeReason extends Enum<ChangeReason> {
  /**
   * Player emptying the cauldron by filling their bucket.
  */
  static readonly BUCKET_FILL: ChangeReason;
  /**
   * Player filling the cauldron by emptying their bucket.
  */
  static readonly BUCKET_EMPTY: ChangeReason;
  /**
   * Player emptying the cauldron by filling their bottle.
  */
  static readonly BOTTLE_FILL: ChangeReason;
  /**
   * Player filling the cauldron by emptying their bottle.
  */
  static readonly BOTTLE_EMPTY: ChangeReason;
  /**
   * Player cleaning their banner.
  */
  static readonly BANNER_WASH: ChangeReason;
  /**
   * Player cleaning their armor.
  */
  static readonly ARMOR_WASH: ChangeReason;
  /**
   * Player cleaning a shulker box.
  */
  static readonly SHULKER_WASH: ChangeReason;
  /**
   * Entity being extinguished.
  */
  static readonly EXTINGUISH: ChangeReason;
  /**
   * Evaporating due to biome dryness.
  */
  static readonly EVAPORATE: ChangeReason;
  /**
   * Filling due to natural fluid sources, eg rain or dripstone.
  */
  static readonly NATURAL_FILL: ChangeReason;
  /**
   * Unknown.
  */
  static readonly UNKNOWN: ChangeReason;
  static valueOf(name: string): ChangeReason;
  static values(): ChangeReason[];
}

}
declare module 'org.bukkit.conversations' {
import { Cloneable } from 'java.lang';
import { List, EventListener, UUID, Map, EventObject } from 'java.util';
import { Pattern } from 'java.util.regex';
import { Plugin } from 'org.bukkit.plugin';
import { ChatColor } from 'org.bukkit';
import { ConversationState } from 'org.bukkit.conversations.Conversation';
/**
 * A Prompt is the main constituent of a {@link Conversation}. Each prompt
 * displays text to the user and optionally waits for a user's response.
 * Prompts are chained together into a directed graph that represents the
 * conversation flow. To halt a conversation, END_OF_CONVERSATION is returned
 * in liu of another Prompt object.
*/
export class Prompt extends Cloneable {
  /**
   * A convenience constant for indicating the end of a conversation.
  */
  static readonly END_OF_CONVERSATION: Prompt;
  /**
   * Gets the text to display to the user when this prompt is first
   * presented.
   *
   * @param context Context information about the conversation.
   * @return The text to display.
  */
  getPromptText(context: ConversationContext): string;
  /**
   * Checks to see if this prompt implementation should wait for user input
   * or immediately display the next prompt.
   *
   * @param context Context information about the conversation.
   * @return If true, the {@link Conversation} will wait for input before
   *     continuing. If false, {@link #acceptInput(ConversationContext, String)} will be called immediately with `null` input.
  */
  blocksForInput(context: ConversationContext): boolean;
  /**
   * Accepts and processes input from the user. Using the input, the next
   * Prompt in the prompt graph is returned.
   *
   * @param context Context information about the conversation.
   * @param input The input text from the user.
   * @return The next Prompt in the prompt graph.
  */
  acceptInput(context: ConversationContext, input: string | null): Prompt | null;
}
/**
 * RegexPrompt is the base class for any prompt that requires an input
 * validated by a regular expression.
*/
export class RegexPrompt extends ValidatingPrompt {
  constructor(regex: string);
  constructor(pattern: Pattern);
}
/**
 * StringPrompt is the base class for any prompt that accepts an arbitrary
 * string from the user.
*/
export class StringPrompt extends Prompt {
  /**
   * Ensures that the prompt waits for the user to provide input.
   *
   * @param context Context information about the conversation.
   * @return True.
  */
  blocksForInput(context: ConversationContext): boolean;
}
/**
 * NullConversationPrefix is a {@link ConversationPrefix} implementation that
 * displays nothing in front of conversation output.
*/
export class NullConversationPrefix extends ConversationPrefix {
  /**
   * Prepends each conversation message with an empty string.
   *
   * @param context Context information about the conversation.
   * @return An empty string.
  */
  getPrefix(context: ConversationContext): string;
}
/**
 * PlayerNamePrompt is the base class for any prompt that requires the player
 * to enter another player's name.
*/
export class PlayerNamePrompt extends ValidatingPrompt {
  constructor(plugin: Plugin);
}
/**
*/
export class ConversationAbandonedListener extends EventListener {
  /**
   * Called whenever a {@link Conversation} is abandoned.
   *
   * @param abandonedEvent Contains details about the abandoned
   *     conversation.
  */
  conversationAbandoned(abandonedEvent: ConversationAbandonedEvent): void;
}
/**
 * The ManuallyAbandonedConversationCanceller is only used as part of a {@link
 * ConversationAbandonedEvent} to indicate that the conversation was manually
 * abandoned by programmatically calling the abandon() method on it.
*/
export class ManuallyAbandonedConversationCanceller extends ConversationCanceller {
  /**
   * Sets the conversation this ConversationCanceller can optionally cancel.
   *
   * @param conversation A conversation.
  */
  setConversation(conversation: Conversation);
  /**
   * Cancels a conversation based on user input.
   *
   * @param context Context information about the conversation.
   * @param input The input text from the user.
   * @return True to cancel the conversation, False otherwise.
  */
  cancelBasedOnInput(context: ConversationContext, input: string): boolean;
  /**
   * Allows the {@link ConversationFactory} to duplicate this
   * ConversationCanceller when creating a new {@link Conversation}.
   * 
   * Implementing this method should reset any internal object state.
   *
   * @return A clone.
  */
  clone(): ConversationCanceller;
}
/**
 * NumericPrompt is the base class for any prompt that requires a {@link
 * Number} response from the user.
*/
export class NumericPrompt extends ValidatingPrompt {
  constructor();
}
/**
 * MessagePrompt is the base class for any prompt that only displays a message
 * to the user and requires no input.
*/
export class MessagePrompt extends Prompt {
  constructor();
  /**
   * Message prompts never wait for user input before continuing.
   *
   * @param context Context information about the conversation.
   * @return Always false.
  */
  blocksForInput(context: ConversationContext): boolean;
  /**
   * Accepts and ignores any user input, returning the next prompt in the
   * prompt graph instead.
   *
   * @param context Context information about the conversation.
   * @param input Ignored.
   * @return The next prompt in the prompt graph.
  */
  acceptInput(context: ConversationContext, input: string | null): Prompt | null;
}
/**
 * A ConversationPrefix implementation prepends all output from the
 * conversation to the player. The ConversationPrefix can be used to display
 * the plugin name or conversation status as the conversation evolves.
*/
export class ConversationPrefix {
  /**
   * Gets the prefix to use before each message to the player.
   *
   * @param context Context information about the conversation.
   * @return The prefix text.
  */
  getPrefix(context: ConversationContext): string;
}
/**
 * The Conversation class is responsible for tracking the current state of a
 * conversation, displaying prompts to the user, and dispatching the user's
 * response to the appropriate place. Conversation objects are not typically
 * instantiated directly. Instead a {@link ConversationFactory} is used to
 * construct identical conversations on demand.
 * 
 * Conversation flow consists of a directed graph of {@link Prompt} objects.
 * Each time a prompt gets input from the user, it must return the next prompt
 * in the graph. Since each Prompt chooses the next Prompt, complex
 * conversation trees can be implemented where the nature of the player's
 * response directs the flow of the conversation.
 * 
 * Each conversation has a {@link ConversationPrefix} that prepends all output
 * from the conversation to the player. The ConversationPrefix can be used to
 * display the plugin name or conversation status as the conversation evolves.
 * 
 * Each conversation has a timeout measured in the number of inactive seconds
 * to wait before abandoning the conversation. If the inactivity timeout is
 * reached, the conversation is abandoned and the user's incoming and outgoing
 * chat is returned to normal.
 * 
 * You should not construct a conversation manually. Instead, use the {@link
 * ConversationFactory} for access to all available options.
*/
export class Conversation {
  /**
   * Initializes a new Conversation.
   *
   * @param plugin The plugin that owns this conversation.
   * @param forWhom The entity for whom this conversation is mediating.
   * @param firstPrompt The first prompt in the conversation graph.
  */
  constructor(plugin: Plugin | null, forWhom: Conversable, firstPrompt: Prompt | null);
  /**
   * Initializes a new Conversation.
   *
   * @param plugin The plugin that owns this conversation.
   * @param forWhom The entity for whom this conversation is mediating.
   * @param firstPrompt The first prompt in the conversation graph.
   * @param initialSessionData Any initial values to put in the conversation
   *     context sessionData map.
  */
  constructor(plugin: Plugin | null, forWhom: Conversable, firstPrompt: Prompt | null, initialSessionData: Map<any, any>);
  /**
   * Gets the entity for whom this conversation is mediating.
   *
   * @return The entity.
  */
  getForWhom(): Conversable;
  /**
   * Gets the modality of this conversation. If a conversation is modal, all
   * messages directed to the player are suppressed for the duration of the
   * conversation.
   *
   * @return The conversation modality.
  */
  isModal(): boolean;
  /**
   * Gets the status of local echo for this conversation. If local echo is
   * enabled, any text submitted to a conversation gets echoed back into the
   * submitter's chat window.
   *
   * @return The status of local echo.
  */
  isLocalEchoEnabled(): boolean;
  /**
   * Sets the status of local echo for this conversation. If local echo is
   * enabled, any text submitted to a conversation gets echoed back into the
   * submitter's chat window.
   *
   * @param localEchoEnabled The status of local echo.
  */
  setLocalEchoEnabled(localEchoEnabled: boolean): void;
  /**
   * Gets the {@link ConversationPrefix} that prepends all output from this
   * conversation.
   *
   * @return The ConversationPrefix in use.
  */
  getPrefix(): ConversationPrefix;
  /**
   * Gets the list of {@link ConversationCanceller}s
   *
   * @return The list.
  */
  getCancellers(): ConversationCanceller[];
  /**
   * Returns the Conversation's {@link ConversationContext}.
   *
   * @return The ConversationContext.
  */
  getContext(): ConversationContext;
  /**
   * Displays the first prompt of this conversation and begins redirecting
   * the user's chat responses.
  */
  begin(): void;
  /**
   * Returns Returns the current state of the conversation.
   *
   * @return The current state of the conversation.
  */
  getState(): ConversationState;
  /**
   * Passes player input into the current prompt. The next prompt (as
   * determined by the current prompt) is then displayed to the user.
   *
   * @param input The user's chat text.
  */
  acceptInput(input: string): void;
  /**
   * Adds a {@link ConversationAbandonedListener}.
   *
   * @param listener The listener to add.
  */
  addConversationAbandonedListener(listener: ConversationAbandonedListener): void;
  /**
   * Removes a {@link ConversationAbandonedListener}.
   *
   * @param listener The listener to remove.
  */
  removeConversationAbandonedListener(listener: ConversationAbandonedListener): void;
  /**
   * Abandons and resets the current conversation. Restores the user's
   * normal chat behavior.
  */
  abandon(): void;
  /**
   * Abandons and resets the current conversation. Restores the user's
   * normal chat behavior.
   *
   * @param details Details about why the conversation was abandoned
  */
  abandon(details: ConversationAbandonedEvent): void;
  /**
   * Displays the next user prompt and abandons the conversation if the next
   * prompt is null.
  */
  outputNextPrompt(): void;
}
/**
 * ConversationAbandonedEvent contains information about an abandoned
 * conversation.
*/
export class ConversationAbandonedEvent extends EventObject {
  constructor(conversation: Conversation);
  constructor(conversation: Conversation, canceller: ConversationCanceller | null);
  /**
   * Gets the object that caused the conversation to be abandoned.
   *
   * @return The object that abandoned the conversation.
  */
  getCanceller(): ConversationCanceller | null;
  /**
   * Gets the abandoned conversation's conversation context.
   *
   * @return The abandoned conversation's conversation context.
  */
  getContext(): ConversationContext;
  /**
   * Indicates how the conversation was abandoned - naturally as part of the
   * prompt chain or prematurely via a {@link ConversationCanceller}.
   *
   * @return True if the conversation is abandoned gracefully by a {@link
   *     Prompt} returning null or the next prompt. False of the
   *     conversations is abandoned prematurely by a ConversationCanceller.
  */
  gracefulExit(): boolean;
}
/**
 * An ExactMatchConversationCanceller cancels a conversation if the user
 * enters an exact input string
*/
export class ExactMatchConversationCanceller extends ConversationCanceller {
  /**
   * Builds an ExactMatchConversationCanceller.
   *
   * @param escapeSequence The string that, if entered by the user, will
   *     cancel the conversation.
  */
  constructor(escapeSequence: string);
  /**
   * Sets the conversation this ConversationCanceller can optionally cancel.
   *
   * @param conversation A conversation.
  */
  setConversation(conversation: Conversation);
  /**
   * Cancels a conversation based on user input.
   *
   * @param context Context information about the conversation.
   * @param input The input text from the user.
   * @return True to cancel the conversation, False otherwise.
  */
  cancelBasedOnInput(context: ConversationContext, input: string): boolean;
  /**
   * Allows the {@link ConversationFactory} to duplicate this
   * ConversationCanceller when creating a new {@link Conversation}.
   * 
   * Implementing this method should reset any internal object state.
   *
   * @return A clone.
  */
  clone(): ConversationCanceller;
}
/**
 * PluginNameConversationPrefix is a {@link ConversationPrefix} implementation
 * that displays the plugin name in front of conversation output.
*/
export class PluginNameConversationPrefix extends ConversationPrefix {
  constructor(plugin: Plugin);
  constructor(plugin: Plugin, separator: string, prefixColor: ChatColor);
  /**
   * Prepends each conversation message with the plugin name.
   *
   * @param context Context information about the conversation.
   * @return An empty string.
  */
  getPrefix(context: ConversationContext): string;
}
/**
 * A ConversationCanceller is a class that cancels an active {@link
 * Conversation}. A Conversation can have more than one ConversationCanceller.
*/
export class ConversationCanceller extends Cloneable {
  /**
   * Sets the conversation this ConversationCanceller can optionally cancel.
   *
   * @param conversation A conversation.
  */
  setConversation(conversation: Conversation);
  /**
   * Cancels a conversation based on user input.
   *
   * @param context Context information about the conversation.
   * @param input The input text from the user.
   * @return True to cancel the conversation, False otherwise.
  */
  cancelBasedOnInput(context: ConversationContext, input: string): boolean;
  /**
   * Allows the {@link ConversationFactory} to duplicate this
   * ConversationCanceller when creating a new {@link Conversation}.
   * 
   * Implementing this method should reset any internal object state.
   *
   * @return A clone.
  */
  clone(): ConversationCanceller;
}
/**
 * The Conversable interface is used to indicate objects that can have
 * conversations.
*/
export class Conversable {
  /**
   * Tests to see of a Conversable object is actively engaged in a
   * conversation.
   *
   * @return True if a conversation is in progress
  */
  isConversing(): boolean;
  /**
   * Accepts input into the active conversation. If no conversation is in
   * progress, this method does nothing.
   *
   * @param input The input message into the conversation
  */
  acceptConversationInput(input: string): void;
  /**
   * Enters into a dialog with a Conversation object.
   *
   * @param conversation The conversation to begin
   * @return True if the conversation should proceed, false if it has been
   *     enqueued
  */
  beginConversation(conversation: Conversation): boolean;
  /**
   * Abandons an active conversation.
   *
   * @param conversation The conversation to abandon
  */
  abandonConversation(conversation: Conversation): void;
  /**
   * Abandons an active conversation.
   *
   * @param conversation The conversation to abandon
   * @param details Details about why the conversation was abandoned
  */
  abandonConversation(conversation: Conversation, details: ConversationAbandonedEvent): void;
  /**
   * Sends this sender a message raw
   *
   * @param message Message to be displayed
  */
  sendRawMessage(message: string): void;
  /**
   * Sends this sender a message raw
   *
   * @param message Message to be displayed
   * @param sender The sender of this message
  */
  sendRawMessage(sender: UUID | null, message: string): void;
}
/**
 * BooleanPrompt is the base class for any prompt that requires a boolean
 * response from the user.
*/
export class BooleanPrompt extends ValidatingPrompt {
  constructor();
}
/**
 * A ConversationFactory is responsible for creating a {@link Conversation}
 * from a predefined template. A ConversationFactory is typically created when
 * a plugin is instantiated and builds a Conversation each time a user
 * initiates a conversation with the plugin. Each Conversation maintains its
 * own state and calls back as needed into the plugin.
 * 
 * The ConversationFactory implements a fluid API, allowing parameters to be
 * set as an extension to the constructor.
*/
export class ConversationFactory {
  /**
   * Constructs a ConversationFactory.
   *
   * @param plugin The plugin that owns the factory.
  */
  constructor(plugin: Plugin);
  /**
   * Sets the modality of all {@link Conversation}s created by this factory.
   * If a conversation is modal, all messages directed to the player are
   * suppressed for the duration of the conversation.
   * 
   * The default is True.
   *
   * @param modal The modality of all conversations to be created.
   * @return This object.
  */
  withModality(modal: boolean): ConversationFactory;
  /**
   * Sets the local echo status for all {@link Conversation}s created by
   * this factory. If local echo is enabled, any text submitted to a
   * conversation gets echoed back into the submitter's chat window.
   *
   * @param localEchoEnabled The status of local echo.
   * @return This object.
  */
  withLocalEcho(localEchoEnabled: boolean): ConversationFactory;
  /**
   * Sets the {@link ConversationPrefix} that prepends all output from all
   * generated conversations.
   * 
   * The default is a {@link NullConversationPrefix};
   *
   * @param prefix The ConversationPrefix to use.
   * @return This object.
  */
  withPrefix(prefix: ConversationPrefix): ConversationFactory;
  /**
   * Sets the number of inactive seconds to wait before automatically
   * abandoning all generated conversations.
   * 
   * The default is 600 seconds (5 minutes).
   *
   * @param timeoutSeconds The number of seconds to wait.
   * @return This object.
  */
  withTimeout(timeoutSeconds: number): ConversationFactory;
  /**
   * Sets the first prompt to use in all generated conversations.
   * 
   * The default is Prompt.END_OF_CONVERSATION.
   *
   * @param firstPrompt The first prompt.
   * @return This object.
  */
  withFirstPrompt(firstPrompt: Prompt | null): ConversationFactory;
  /**
   * Sets any initial data with which to populate the conversation context
   * sessionData map.
   *
   * @param initialSessionData The conversation context's initial
   *     sessionData.
   * @return This object.
  */
  withInitialSessionData(initialSessionData: Map<any, any>): ConversationFactory;
  /**
   * Sets the player input that, when received, will immediately terminate
   * the conversation.
   *
   * @param escapeSequence Input to terminate the conversation.
   * @return This object.
  */
  withEscapeSequence(escapeSequence: string): ConversationFactory;
  /**
   * Adds a {@link ConversationCanceller} to constructed conversations.
   *
   * @param canceller The {@link ConversationCanceller} to add.
   * @return This object.
  */
  withConversationCanceller(canceller: ConversationCanceller): ConversationFactory;
  /**
   * Prevents this factory from creating a conversation for non-player
   * {@link Conversable} objects.
   *
   * @param playerOnlyMessage The message to return to a non-play in lieu of
   *     starting a conversation.
   * @return This object.
  */
  thatExcludesNonPlayersWithMessage(playerOnlyMessage: string | null): ConversationFactory;
  /**
   * Adds a {@link ConversationAbandonedListener} to all conversations
   * constructed by this factory.
   *
   * @param listener The listener to add.
   * @return This object.
  */
  addConversationAbandonedListener(listener: ConversationAbandonedListener): ConversationFactory;
  /**
   * Constructs a {@link Conversation} in accordance with the defaults set
   * for this factory.
   *
   * @param forWhom The entity for whom the new conversation is mediating.
   * @return A new conversation.
  */
  buildConversation(forWhom: Conversable): Conversation;
}
/**
 * A ConversationContext provides continuity between nodes in the prompt graph
 * by giving the developer access to the subject of the conversation and a
 * generic map for storing values that are shared between all {@link Prompt}
 * invocations.
*/
export class ConversationContext {
  /**
   * @param plugin The owning plugin.
   * @param forWhom The subject of the conversation.
   * @param initialSessionData Any initial values to put in the sessionData
   *     map.
  */
  constructor(plugin: Plugin | null, forWhom: Conversable, initialSessionData: Map<any, any>);
  /**
   * Gets the plugin that owns this conversation.
   *
   * @return The owning plugin.
  */
  getPlugin(): Plugin | null;
  /**
   * Gets the subject of the conversation.
   *
   * @return The subject of the conversation.
  */
  getForWhom(): Conversable;
  /**
   * Gets the underlying sessionData map.
   *
   * May be directly modified to manipulate session data.
   *
   * @return The full sessionData map.
  */
  getAllSessionData(): Map<any, any>;
  /**
   * Gets session data shared between all {@link Prompt} invocations. Use
   * this as a way to pass data through each Prompt as the conversation
   * develops.
   *
   * @param key The session data key.
   * @return The requested session data.
  */
  getSessionData(key: any): any | null;
  /**
   * Sets session data shared between all {@link Prompt} invocations. Use
   * this as a way to pass data through each prompt as the conversation
   * develops.
   *
   * @param key The session data key.
   * @param value The session data value.
  */
  setSessionData(key: any, value: any | null): void;
}
/**
 * FixedSetPrompt is the base class for any prompt that requires a fixed set
 * response from the user.
*/
export class FixedSetPrompt extends ValidatingPrompt {
  /**
   * Creates a FixedSetPrompt from a set of strings.
   * 
   * foo = new FixedSetPrompt("bar", "cheese", "panda");
   *
   * @param fixedSet A fixed set of strings, one of which the user must
   *     type.
  */
  constructor(...fixedSet: string[]);
}
/**
 * ValidatingPrompt is the base class for any prompt that requires validation.
 * ValidatingPrompt will keep replaying the prompt text until the user enters
 * a valid response.
*/
export class ValidatingPrompt extends Prompt {
  constructor();
  /**
   * Accepts and processes input from the user and validates it. If
   * validation fails, this prompt is returned for re-execution, otherwise
   * the next Prompt in the prompt graph is returned.
   *
   * @param context Context information about the conversation.
   * @param input The input text from the user.
   * @return This prompt or the next Prompt in the prompt graph.
  */
  acceptInput(context: ConversationContext, input: string | null): Prompt | null;
  /**
   * Ensures that the prompt waits for the user to provide input.
   *
   * @param context Context information about the conversation.
   * @return True.
  */
  blocksForInput(context: ConversationContext): boolean;
}
/**
 * An InactivityConversationCanceller will cancel a {@link Conversation} after
 * a period of inactivity by the user.
*/
export class InactivityConversationCanceller extends ConversationCanceller {
  /**
   * Creates an InactivityConversationCanceller.
   *
   * @param plugin The owning plugin.
   * @param timeoutSeconds The number of seconds of inactivity to wait.
  */
  constructor(plugin: Plugin, timeoutSeconds: number);
  /**
   * Sets the conversation this ConversationCanceller can optionally cancel.
   *
   * @param conversation A conversation.
  */
  setConversation(conversation: Conversation);
  /**
   * Cancels a conversation based on user input.
   *
   * @param context Context information about the conversation.
   * @param input The input text from the user.
   * @return True to cancel the conversation, False otherwise.
  */
  cancelBasedOnInput(context: ConversationContext, input: string): boolean;
  /**
   * Allows the {@link ConversationFactory} to duplicate this
   * ConversationCanceller when creating a new {@link Conversation}.
   * 
   * Implementing this method should reset any internal object state.
   *
   * @return A clone.
  */
  clone(): ConversationCanceller;
}

}
declare module 'org.bukkit.event.player' {
import { Cause as org_bukkit_event_player_PlayerGameModeChangeEvent_Cause } from 'org.bukkit.event.player.PlayerGameModeChangeEvent';
import { Locale, Set, Collection, List, UUID } from 'java.util';
import { EntityUnleashEvent } from 'org.bukkit.event.entity';
import { Result as org_bukkit_event_Event_Result } from 'org.bukkit.event.Event';
import { BedEnterResult } from 'org.bukkit.event.player.PlayerBedEnterEvent';
import { Advancement } from 'org.bukkit.advancement';
import { BookMeta } from 'org.bukkit.inventory.meta';
import { State } from 'org.bukkit.event.player.PlayerFishEvent';
import { RespawnFlag } from 'org.bukkit.event.player.PlayerRespawnEvent';
import { Action } from 'org.bukkit.event.block';
import { EquipmentSlot, MainHand, ItemStack } from 'org.bukkit.inventory';
import { GameMode, Statistic, NamespacedKey, Material, World, Location } from 'org.bukkit';
import { Result as org_bukkit_event_player_AsyncPlayerPreLoginEvent_Result } from 'org.bukkit.event.player.AsyncPlayerPreLoginEvent';
import { BlockFace, Block, Lectern } from 'org.bukkit.block';
import { InetAddress } from 'java.net';
import { HandlerList, Cancellable, Event } from 'org.bukkit.event';
import { PlayerProfile } from 'com.destroystokyo.paper.profile';
import { EntityType, Entity, Item, FishHook, Player, ArmorStand, Egg, Fish, ExperienceOrb, AbstractArrow } from 'org.bukkit.entity';
import { Component } from 'net.kyori.adventure.text';
import { Builder } from 'com.google.common.collect.ImmutableSet';
import { Result as org_bukkit_event_player_PlayerLoginEvent_Result } from 'org.bukkit.event.player.PlayerLoginEvent';
import { Enum } from 'java.lang';
import { Status } from 'org.bukkit.event.player.PlayerResourcePackStatusEvent';
import { TeleportCause } from 'org.bukkit.event.player.PlayerTeleportEvent';
import { Cause } from 'org.bukkit.event.player.PlayerKickEvent';
import { QuitReason } from 'org.bukkit.event.player.PlayerQuitEvent';
import { Vector } from 'org.bukkit.util';
import { Result } from 'org.bukkit.event.player.PlayerPreLoginEvent';
/**
 * This event is called whenever a player captures an entity in a bucket.
*/
export class PlayerBucketEntityEvent extends PlayerEvent {
  constructor(player: Player, entity: Entity, originalBucket: ItemStack, entityBucket: ItemStack);
  /**
   * Gets the {@link Entity} being put into the bucket.
   *
   * @return The {@link Entity} being put into the bucket
  */
  getEntity(): Entity;
  /**
   * Gets the bucket used to capture the {@link Entity}.
   *
   * This refers to the bucket clicked with, eg {@link Material#WATER_BUCKET}.
   *
   * @return The used bucket
  */
  getOriginalBucket(): ItemStack;
  /**
   * Gets the bucket that the {@link Entity} will be put into.
   *
   * This refers to the bucket with the entity, eg
   * {@link Material#PUFFERFISH_BUCKET}.
   *
   * @return The bucket that the {@link Entity} will be put into
  */
  getEntityBucket(): ItemStack;
  /**
   * Gets the cancellation state of this event. A cancelled event will not
   * be executed in the server, but will still pass to other plugins
   *
   * @return true if this event is cancelled
  */
  isCancelled(): boolean;
  /**
   * Sets the cancellation state of this event. A cancelled event will not
   * be executed in the server, but will still pass to other plugins.
   *
   * @param cancel true if you wish to cancel this event
  */
  setCancelled(cancel: boolean): void;
  getHandlers(): HandlerList;
  static getHandlerList(): HandlerList;
}
export interface PlayerBucketEntityEvent extends PlayerEvent, Cancellable {}
/**
 * Called when a player changes their locale in the client settings.
*/
export class PlayerLocaleChangeEvent extends PlayerEvent {
  /**
   * @see Player#getLocale()
   *
   * @return the player's new locale
  */
  locale(): Locale;
  constructor(who: Player, locale: string);
  getHandlers(): HandlerList;
  static getHandlerList(): HandlerList;
}
/**
 * Called when a players level changes
*/
export class PlayerLevelChangeEvent extends PlayerEvent {
  constructor(player: Player, oldLevel: number, newLevel: number);
  /**
   * Gets the old level of the player
   *
   * @return The old level of the player
  */
  getOldLevel(): number;
  /**
   * Gets the new level of the player
   *
   * @return The new (current) level of the player
  */
  getNewLevel(): number;
  getHandlers(): HandlerList;
  static getHandlerList(): HandlerList;
}
/**
 * Called when a player takes action on a resource pack request sent via
 * {@link Player#setResourcePack(java.lang.String)}.
*/
export class PlayerResourcePackStatusEvent extends PlayerEvent {
  constructor(who: Player, resourcePackStatus: Status);
  constructor(who: Player, resourcePackStatus: Status, hash: string);
  getHash(): string;
  /**
   * Gets the status of this pack.
   *
   * @return the current status
  */
  getStatus(): Status;
  getHandlers(): HandlerList;
  static getHandlerList(): HandlerList;
}
/**
 * Different types of player animations
*/
export class PlayerAnimationType extends Enum<PlayerAnimationType> {
  static readonly ARM_SWING: PlayerAnimationType;
  static valueOf(name: string): PlayerAnimationType;
  static values(): PlayerAnimationType[];
}
/**
 * Called when the velocity of a player changes.
*/
export class PlayerVelocityEvent extends PlayerEvent {
  constructor(player: Player, velocity: Vector);
  /**
   * Gets the cancellation state of this event. A cancelled event will not
   * be executed in the server, but will still pass to other plugins
   *
   * @return true if this event is cancelled
  */
  isCancelled(): boolean;
  /**
   * Sets the cancellation state of this event. A cancelled event will not
   * be executed in the server, but will still pass to other plugins.
   *
   * @param cancel true if you wish to cancel this event
  */
  setCancelled(cancel: boolean): void;
  /**
   * Gets the velocity vector that will be sent to the player
   *
   * @return Vector the player will get
  */
  getVelocity(): Vector;
  /**
   * Sets the velocity vector in meters per tick that will be sent to the player
   *
   * @param velocity The velocity vector that will be sent to the player
  */
  setVelocity(velocity: Vector);
  getHandlers(): HandlerList;
  static getHandlerList(): HandlerList;
}
export interface PlayerVelocityEvent extends PlayerEvent, Cancellable {}
/**
 * Called when a player toggles their flying state
*/
export class PlayerToggleFlightEvent extends PlayerEvent {
  constructor(player: Player, isFlying: boolean);
  /**
   * Returns whether the player is trying to start or stop flying.
   *
   * @return flying state
  */
  isFlying(): boolean;
  /**
   * Gets the cancellation state of this event. A cancelled event will not
   * be executed in the server, but will still pass to other plugins
   *
   * @return true if this event is cancelled
  */
  isCancelled(): boolean;
  /**
   * Sets the cancellation state of this event. A cancelled event will not
   * be executed in the server, but will still pass to other plugins.
   *
   * @param cancel true if you wish to cancel this event
  */
  setCancelled(cancel: boolean): void;
  getHandlers(): HandlerList;
  static getHandlerList(): HandlerList;
}
export interface PlayerToggleFlightEvent extends PlayerEvent, Cancellable {}
/**
 * Called when a player respawns.
 * 
 * If changing player state, see {@link com.destroystokyo.paper.event.player.PlayerPostRespawnEvent}
 * because the player is "reset" between this event and that event and some changes won't persist.
*/
export class PlayerRespawnEvent extends PlayerEvent {
  constructor(respawnPlayer: Player, respawnLocation: Location, isBedSpawn: boolean);
  constructor(respawnPlayer: Player, respawnLocation: Location, isBedSpawn: boolean, isAnchorSpawn: boolean);
  constructor(respawnPlayer: Player, respawnLocation: Location, isBedSpawn: boolean, isAnchorSpawn: boolean, respawnFlags: Builder<RespawnFlag>);
  /**
   * Gets the current respawn location
   *
   * @return Location current respawn location
  */
  getRespawnLocation(): Location;
  /**
   * Sets the new respawn location
   *
   * @param respawnLocation new location for the respawn
  */
  setRespawnLocation(respawnLocation: Location);
  /**
   * Gets whether the respawn location is the player's bed.
   *
   * @return true if the respawn location is the player's bed.
  */
  isBedSpawn(): boolean;
  /**
   * Gets whether the respawn location is the player's respawn anchor.
   *
   * @return true if the respawn location is the player's respawn anchor.
  */
  isAnchorSpawn(): boolean;
  getHandlers(): HandlerList;
  static getHandlerList(): HandlerList;
  /**
   * Get the set of flags that apply to this respawn.
   *
   * @return an immutable set of the flags that apply to this respawn
  */
  getRespawnFlags(): Set<RespawnFlag>;
}
/**
 * This event is called whenever a player attempts to put a fish in a bucket.
 *
 * @deprecated Use the more generic {@link PlayerBucketEntityEvent}
*/
export class PlayerBucketFishEvent extends PlayerBucketEntityEvent {
  constructor(player: Player, fish: Fish, waterBucket: ItemStack, fishBucket: ItemStack);
  /**
   * Gets the fish involved with this event.
   *
   * @return The fish involved with this event
  */
  getEntity(): Fish;
  /**
   * Gets the bucket used.
   *
   * This refers to the bucket clicked with, ie {@link Material#WATER_BUCKET}.
   *
   * @return The used bucket
   * @deprecated Use {@link #getOriginalBucket()}
  */
  getWaterBucket(): ItemStack;
  /**
   * Gets the bucket that the fish will be put into.
   *
   * This refers to the bucket with the fish, ie
   * {@link Material#PUFFERFISH_BUCKET}.
   *
   * @return The bucket that the fish will be put into
   * @deprecated Use {@link #getEntityBucket()}
  */
  getFishBucket(): ItemStack;
}
/**
 * Called when a player toggles their sprinting state
*/
export class PlayerToggleSprintEvent extends PlayerEvent {
  constructor(player: Player, isSprinting: boolean);
  /**
   * Gets whether the player is now sprinting or not.
   *
   * @return sprinting state
  */
  isSprinting(): boolean;
  /**
   * Gets the cancellation state of this event. A cancelled event will not
   * be executed in the server, but will still pass to other plugins
   *
   * @return true if this event is cancelled
  */
  isCancelled(): boolean;
  /**
   * Sets the cancellation state of this event. A cancelled event will not
   * be executed in the server, but will still pass to other plugins.
   *
   * @param cancel true if you wish to cancel this event
  */
  setCancelled(cancel: boolean): void;
  getHandlers(): HandlerList;
  static getHandlerList(): HandlerList;
}
export interface PlayerToggleSprintEvent extends PlayerEvent, Cancellable {}
/**
 * Fired when a player's item breaks (such as a shovel or flint and steel).
 * 
 * After this event, the item's amount will be set to `item amount - 1`
 * and its durability will be reset to 0.
*/
export class PlayerItemBreakEvent extends PlayerEvent {
  constructor(player: Player, brokenItem: ItemStack);
  /**
   * Gets the item that broke
   *
   * @return The broken item
  */
  getBrokenItem(): ItemStack;
  getHandlers(): HandlerList;
  static getHandlerList(): HandlerList;
}
/**
 * Thrown when a player is fishing
*/
export class PlayerFishEvent extends PlayerEvent {
  constructor(player: Player, entity: Entity | null, hookEntity: FishHook, state: State);
  /**
   * Gets the entity caught by the player.
   * 
   * If player has fished successfully, the result may be cast to {@link
   * org.bukkit.entity.Item}.
   *
   * @return Entity caught by the player, Entity if fishing, and null if
   *     bobber has gotten stuck in the ground or nothing has been caught
  */
  getCaught(): Entity | null;
  /**
   * Gets the fishing hook.
   *
   * @return the entity representing the fishing hook/bobber.
  */
  getHook(): FishHook;
  /**
   * Gets the cancellation state of this event. A cancelled event will not
   * be executed in the server, but will still pass to other plugins
   *
   * @return true if this event is cancelled
  */
  isCancelled(): boolean;
  /**
   * Sets the cancellation state of this event. A cancelled event will not
   * be executed in the server, but will still pass to other plugins.
   *
   * @param cancel true if you wish to cancel this event
  */
  setCancelled(cancel: boolean): void;
  /**
   * Gets the amount of experience received when fishing.
   * 
   * Note: This value has no default effect unless the event state is {@link
   * State#CAUGHT_FISH}.
   *
   * @return the amount of experience to drop
  */
  getExpToDrop(): number;
  /**
   * Sets the amount of experience received when fishing.
   * 
   * Note: This value has no default effect unless the event state is {@link
   * State#CAUGHT_FISH}.
   *
   * @param amount the amount of experience to drop
  */
  setExpToDrop(expToDrop: number);
  /**
   * Gets the state of the fishing
   *
   * @return A State detailing the state of the fishing
  */
  getState(): State;
  getHandlers(): HandlerList;
  static getHandlerList(): HandlerList;
}
export interface PlayerFishEvent extends PlayerEvent, Cancellable {}
/**
 * Called when an item used by the player takes durability damage as a result of
 * being used.
*/
export class PlayerItemDamageEvent extends PlayerEvent {
  constructor(player: Player, what: ItemStack, damage: number);
  constructor(player: Player, what: ItemStack, damage: number, originalDamage: number);
  /**
   * Gets the item being damaged.
   *
   * @return the item
  */
  getItem(): ItemStack;
  /**
   * Gets the amount of durability damage this item will be taking.
   *
   * @return durability change
  */
  getDamage(): number;
  /**
   * Gets the amount of durability damage this item would have taken before
   * the Unbreaking reduction. If the item has no Unbreaking level then
   * this value will be the same as the {@link #getDamage()} value.
   *
   * @return pre-reduction damage amount
  */
  getOriginalDamage(): number;
  setDamage(damage: number);
  /**
   * Gets the cancellation state of this event. A cancelled event will not
   * be executed in the server, but will still pass to other plugins
   *
   * @return true if this event is cancelled
  */
  isCancelled(): boolean;
  /**
   * Sets the cancellation state of this event. A cancelled event will not
   * be executed in the server, but will still pass to other plugins.
   *
   * @param cancel true if you wish to cancel this event
  */
  setCancelled(cancel: boolean): void;
  getHandlers(): HandlerList;
  static getHandlerList(): HandlerList;
}
export interface PlayerItemDamageEvent extends PlayerEvent, Cancellable {}
/**
 * Called when a player shears an entity
*/
export class PlayerShearEntityEvent extends PlayerEvent {
  constructor(who: Player, what: Entity, item: ItemStack, hand: EquipmentSlot);
  constructor(who: Player, what: Entity);
  /**
   * Gets the cancellation state of this event. A cancelled event will not
   * be executed in the server, but will still pass to other plugins
   *
   * @return true if this event is cancelled
  */
  isCancelled(): boolean;
  /**
   * Sets the cancellation state of this event. A cancelled event will not
   * be executed in the server, but will still pass to other plugins.
   *
   * @param cancel true if you wish to cancel this event
  */
  setCancelled(cancel: boolean): void;
  /**
   * Gets the entity the player is shearing
   *
   * @return the entity the player is shearing
  */
  getEntity(): Entity;
  /**
   * Gets the item used to shear the entity.
   *
   * @return the shears
  */
  getItem(): ItemStack;
  /**
   * Gets the hand used to shear the entity.
   *
   * @return the hand
  */
  getHand(): EquipmentSlot;
  getHandlers(): HandlerList;
  static getHandlerList(): HandlerList;
}
export interface PlayerShearEntityEvent extends PlayerEvent, Cancellable {}
/**
 * Thrown when a player picks up an arrow from the ground.
*/
export class PlayerPickupArrowEvent extends PlayerPickupItemEvent {
  constructor(player: Player, item: Item, arrow: AbstractArrow);
  /**
   * Get the arrow being picked up by the player
   *
   * @return The arrow being picked up
  */
  getArrow(): AbstractArrow;
}
/**
 * Thrown when a player drops an item from their inventory
*/
export class PlayerDropItemEvent extends PlayerEvent {
  constructor(player: Player, drop: Item);
  /**
   * Gets the ItemDrop created by the player
   *
   * @return ItemDrop created by the player
  */
  getItemDrop(): Item;
  /**
   * Gets the cancellation state of this event. A cancelled event will not
   * be executed in the server, but will still pass to other plugins
   *
   * @return true if this event is cancelled
  */
  isCancelled(): boolean;
  /**
   * Sets the cancellation state of this event. A cancelled event will not
   * be executed in the server, but will still pass to other plugins.
   *
   * @param cancel true if you wish to cancel this event
  */
  setCancelled(cancel: boolean): void;
  getHandlers(): HandlerList;
  static getHandlerList(): HandlerList;
}
export interface PlayerDropItemEvent extends PlayerEvent, Cancellable {}
/**
 * Fired when a player changes their currently held item
*/
export class PlayerItemHeldEvent extends PlayerEvent {
  constructor(player: Player, previous: number, current: number);
  /**
   * Gets the previous held slot index
   *
   * @return Previous slot index
  */
  getPreviousSlot(): number;
  /**
   * Gets the new held slot index
   *
   * @return New slot index
  */
  getNewSlot(): number;
  /**
   * Gets the cancellation state of this event. A cancelled event will not
   * be executed in the server, but will still pass to other plugins
   *
   * @return true if this event is cancelled
  */
  isCancelled(): boolean;
  /**
   * Sets the cancellation state of this event. A cancelled event will not
   * be executed in the server, but will still pass to other plugins.
   *
   * @param cancel true if you wish to cancel this event
  */
  setCancelled(cancel: boolean): void;
  getHandlers(): HandlerList;
  static getHandlerList(): HandlerList;
}
export interface PlayerItemHeldEvent extends PlayerEvent, Cancellable {}
/**
 * Called when a player empties a bucket
*/
export class PlayerBucketEmptyEvent extends PlayerBucketEvent {
  constructor(who: Player, blockClicked: Block, blockFace: BlockFace, bucket: Material, itemInHand: ItemStack);
  constructor(who: Player, block: Block, blockClicked: Block, blockFace: BlockFace, bucket: Material, itemInHand: ItemStack);
  constructor(who: Player, blockClicked: Block, blockFace: BlockFace, bucket: Material, itemInHand: ItemStack, hand: EquipmentSlot | null);
  constructor(who: Player, block: Block, blockClicked: Block, blockFace: BlockFace, bucket: Material, itemInHand: ItemStack, hand: EquipmentSlot | null);
  getHandlers(): HandlerList;
  static getHandlerList(): HandlerList;
}
/**
 * Represents an event that is called when a player right clicks an entity that
 * also contains the location where the entity was clicked.
 * 
 * Note that the client may sometimes spuriously send this packet in addition to {@link PlayerInteractEntityEvent}.
 * Users are advised to listen to this (parent) class unless specifically required.
 * 
 * Note that interacting with Armor Stands fires this event only and not its parent and as such users are expressly required
 * to listen to this event for that scenario.
*/
export class PlayerInteractAtEntityEvent extends PlayerInteractEntityEvent {
  constructor(who: Player, clickedEntity: Entity, position: Vector);
  constructor(who: Player, clickedEntity: Entity, position: Vector, hand: EquipmentSlot);
  getClickedPosition(): Vector;
  getHandlers(): HandlerList;
  static getHandlerList(): HandlerList;
}
/**
 * Represents a player related event
*/
export class PlayerEvent extends Event {
  constructor(who: Player);
  constructor(who: Player, async: boolean);
  /**
   * Returns the player involved in this event
   *
   * @return Player who is involved in this event
  */
  getPlayer(): Player;
}
/**
 * Called when a player switches to another world.
*/
export class PlayerChangedWorldEvent extends PlayerEvent {
  constructor(player: Player, from: World);
  /**
   * Gets the world the player is switching from.
   *
   * @return  player's previous world
  */
  getFrom(): World;
  getHandlers(): HandlerList;
  static getHandlerList(): HandlerList;
}
/**
 * Called when a player is about to teleport because it is in contact with a
 * portal which will generate an exit portal.
 * 
 * For other entities see {@link org.bukkit.event.entity.EntityPortalEvent}
*/
export class PlayerPortalEvent extends PlayerTeleportEvent {
  constructor(player: Player, from: Location, to: Location | null);
  constructor(player: Player, from: Location, to: Location | null, cause: TeleportCause);
  constructor(player: Player, from: Location, to: Location | null, cause: TeleportCause, getSearchRadius: number, canCreatePortal: boolean, creationRadius: number);
  /**
   * Set the Block radius to search in for available portals.
   *
   * @param searchRadius the radius in which to search for a portal from the
   * location
  */
  setSearchRadius(searchRadius: number);
  /**
   * Gets the search radius value for finding an available portal.
   *
   * @return the currently set search radius
  */
  getSearchRadius(): number;
  /**
   * Returns whether the server will attempt to create a destination portal or
   * not.
   *
   * @return whether there should create be a destination portal created
  */
  getCanCreatePortal(): boolean;
  /**
   * Sets whether the server should attempt to create a destination portal or
   * not.
   *
   * @param canCreatePortal Sets whether there should be a destination portal
   * created
  */
  setCanCreatePortal(canCreatePortal: boolean): void;
  /**
   * Sets the maximum radius the world is searched for a free space from the
   * given location.
   *
   * If enough free space is found then the portal will be created there, if
   * not it will force create with air-space at the target location.
   *
   * Does not apply to end portal target platforms which will always appear at
   * the target location.
   *
   * @param creationRadius the radius in which to create a portal from the
   * location
  */
  setCreationRadius(creationRadius: number);
  /**
   * Gets the maximum radius the world is searched for a free space from the
   * given location.
   *
   * If enough free space is found then the portal will be created there, if
   * not it will force create with air-space at the target location.
   *
   * Does not apply to end portal target platforms which will always appear at
   * the target location.
   *
   * @return the currently set creation radius
  */
  getCreationRadius(): number;
  getHandlers(): HandlerList;
  static getHandlerList(): HandlerList;
}
/**
 * Holds information for player movement events
*/
export class PlayerMoveEvent extends PlayerEvent {
  constructor(player: Player, from: Location, to: Location | null);
  /**
   * Gets the cancellation state of this event. A cancelled event will not
   * be executed in the server, but will still pass to other plugins
   * 
   * If a move or teleport event is cancelled, the player will be moved or
   * teleported back to the Location as defined by getFrom(). This will not
   * fire an event
   *
   * @return true if this event is cancelled
  */
  isCancelled(): boolean;
  /**
   * Sets the cancellation state of this event. A cancelled event will not
   * be executed in the server, but will still pass to other plugins
   * 
   * If a move or teleport event is cancelled, the player will be moved or
   * teleported back to the Location as defined by getFrom(). This will not
   * fire an event
   *
   * @param cancel true if you wish to cancel this event
  */
  setCancelled(cancel: boolean): void;
  /**
   * Gets the location this player moved from
   *
   * @return Location the player moved from
  */
  getFrom(): Location;
  /**
   * Sets the location to mark as where the player moved from
   *
   * @param from New location to mark as the players previous location
  */
  setFrom(from: Location);
  /**
   * Gets the location this player moved to
   *
   * @return Location the player moved to
  */
  getTo(): Location;
  /**
   * Sets the location that this player will move to
   *
   * @param to New Location this player will move to
  */
  setTo(to: Location);
  /**
   * Check if the player has changed position (even within the same block) in the event
   *
   * @return whether the player has changed position or not
  */
  hasChangedPosition(): boolean;
  /**
   * Check if the player has changed position (even within the same block) in the event, disregarding a possible world change
   *
   * @return whether the player has changed position or not
  */
  hasExplicitlyChangedPosition(): boolean;
  /**
   * Check if the player has moved to a new block in the event
   *
   * @return whether the player has moved to a new block or not
  */
  hasChangedBlock(): boolean;
  /**
   * Check if the player has moved to a new block in the event, disregarding a possible world change
   *
   * @return whether the player has moved to a new block or not
  */
  hasExplicitlyChangedBlock(): boolean;
  /**
   * Check if the player has changed orientation in the event
   *
   * @return whether the player has changed orientation or not
  */
  hasChangedOrientation(): boolean;
  getHandlers(): HandlerList;
  static getHandlerList(): HandlerList;
}
export interface PlayerMoveEvent extends PlayerEvent, Cancellable {}
/**
 * Called when a player toggles their sneaking state
*/
export class PlayerToggleSneakEvent extends PlayerEvent {
  constructor(player: Player, isSneaking: boolean);
  /**
   * Returns whether the player is now sneaking or not.
   *
   * @return sneaking state
  */
  isSneaking(): boolean;
  /**
   * Gets the cancellation state of this event. A cancelled event will not
   * be executed in the server, but will still pass to other plugins
   *
   * @return true if this event is cancelled
  */
  isCancelled(): boolean;
  /**
   * Sets the cancellation state of this event. A cancelled event will not
   * be executed in the server, but will still pass to other plugins.
   *
   * @param cancel true if you wish to cancel this event
  */
  setCancelled(cancel: boolean): void;
  getHandlers(): HandlerList;
  static getHandlerList(): HandlerList;
}
export interface PlayerToggleSneakEvent extends PlayerEvent, Cancellable {}
/**
 * Thrown when a player attempts to pick an item up from the ground
*/
export class PlayerAttemptPickupItemEvent extends PlayerEvent {
  constructor(player: Player, item: Item);
  constructor(player: Player, item: Item, remaining: number);
  /**
   * Gets the Item attempted by the player.
   *
   * @return Item
  */
  getItem(): Item;
  /**
   * Gets the amount that will remain on the ground, if any
   *
   * @return amount that will remain on the ground
  */
  getRemaining(): number;
  /**
   * Set if the item will fly at the player
   * Cancelling the event will set this value to false.
   *
   * @param flyAtPlayer True for item to fly at player
  */
  setFlyAtPlayer(flyAtPlayer: boolean): void;
  /**
   * Gets if the item will fly at the player
   *
   * @return True if the item will fly at the player
  */
  getFlyAtPlayer(): boolean;
  /**
   * Gets the cancellation state of this event. A cancelled event will not
   * be executed in the server, but will still pass to other plugins
   *
   * @return true if this event is cancelled
  */
  isCancelled(): boolean;
  /**
   * Sets the cancellation state of this event. A cancelled event will not
   * be executed in the server, but will still pass to other plugins.
   *
   * @param cancel true if you wish to cancel this event
  */
  setCancelled(cancel: boolean): void;
  getHandlers(): HandlerList;
  static getHandlerList(): HandlerList;
}
export interface PlayerAttemptPickupItemEvent extends PlayerEvent, Cancellable {}
/**
 * Called when a player throws an egg and it might hatch
*/
export class PlayerEggThrowEvent extends PlayerEvent {
  constructor(player: Player, egg: Egg, hatching: boolean, numHatches: number, hatchingType: EntityType);
  /**
   * Gets the egg involved in this event.
   *
   * @return the egg involved in this event
  */
  getEgg(): Egg;
  /**
   * Gets whether the egg is hatching or not. Will be what the server
   * would've done without interaction.
   *
   * @return boolean Whether the egg is going to hatch or not
  */
  isHatching(): boolean;
  /**
   * Sets whether the egg will hatch or not.
   *
   * @param hatching true if you want the egg to hatch, false if you want it
   *     not to
  */
  setHatching(hatching: boolean): void;
  /**
   * Get the type of the mob being hatched (EntityType.CHICKEN by default)
   *
   * @return The type of the mob being hatched by the egg
  */
  getHatchingType(): EntityType;
  /**
   * Change the type of mob being hatched by the egg
   *
   * @param hatchType The type of the mob being hatched by the egg
  */
  setHatchingType(hatchingType: EntityType);
  /**
   * Get the number of mob hatches from the egg. By default the number will
   * be the number the server would've done
   * 
   * 7/8 chance of being 0
   * 31/256 ~= 1/8 chance to be 1
   * 1/256 chance to be 4
   * 
   *
   * @return The number of mobs going to be hatched by the egg
  */
  getNumHatches(): number;
  /**
   * Change the number of mobs coming out of the hatched egg
   * 
   * The boolean hatching will override this number. Ie. If hatching =
   * false, this number will not matter
   *
   * @param numHatches The number of mobs coming out of the egg
  */
  setNumHatches(numHatches: number);
  getHandlers(): HandlerList;
  static getHandlerList(): HandlerList;
}
/**
 * Thrown when a player picks an item up from the ground
 * @deprecated {@link EntityPickupItemEvent}
*/
export class PlayerPickupItemEvent extends PlayerEvent {
  constructor(player: Player, item: Item, remaining: number);
  /**
   * Gets the Item picked up by the player.
   *
   * @return Item
  */
  getItem(): Item;
  /**
   * Gets the amount remaining on the ground, if any
   *
   * @return amount remaining on the ground
  */
  getRemaining(): number;
  /**
   * Set if the item will fly at the player
   * Cancelling the event will set this value to false.
   *
   * @param flyAtPlayer True for item to fly at player
  */
  setFlyAtPlayer(flyAtPlayer: boolean): void;
  /**
   * Gets if the item will fly at the player
   *
   * @return True if the item will fly at the player
  */
  getFlyAtPlayer(): boolean;
  /**
   * Gets the cancellation state of this event. A cancelled event will not
   * be executed in the server, but will still pass to other plugins
   *
   * @return true if this event is cancelled
  */
  isCancelled(): boolean;
  /**
   * Sets the cancellation state of this event. A cancelled event will not
   * be executed in the server, but will still pass to other plugins.
   *
   * @param cancel true if you wish to cancel this event
  */
  setCancelled(cancel: boolean): void;
  getHandlers(): HandlerList;
  static getHandlerList(): HandlerList;
}
export interface PlayerPickupItemEvent extends PlayerEvent, Cancellable {}
/**
 * Stores details for players attempting to log in
 *
 * @deprecated This event causes synchronization from the login thread; {@link
 *     AsyncPlayerPreLoginEvent} is preferred to keep the secondary threads
 *     asynchronous.
*/
export class PlayerPreLoginEvent extends Event {
  constructor(name: string, ipAddress: InetAddress);
  constructor(name: string, ipAddress: InetAddress, uniqueId: UUID);
  /**
   * Gets the current result of the login, as an enum
   *
   * @return Current Result of the login
  */
  getResult(): Result;
  /**
   * Sets the new result of the login, as an enum
   *
   * @param result New result to set
  */
  setResult(result: Result);
  /**
   * Gets the current kick message that will be used if getResult() !=
   * Result.ALLOWED
   *
   * @return Current kick message
  */
  kickMessage(): Component;
  /**
   * Sets the kick message to display if getResult() != Result.ALLOWED
   *
   * @param message New kick message
  */
  kickMessage(message: Component): void;
  /**
   * Disallows the player from logging in, with the given reason
   *
   * @param result New result for disallowing the player
   * @param message Kick message to display to the user
  */
  disallow(result: Result, message: Component): void;
  /**
   * Sets the kick message to display if getResult() != Result.ALLOWED
   *
   * @param message New kick message
   * @deprecated in favour of {@link #kickMessage(net.kyori.adventure.text.Component)}
  */
  setKickMessage(kickMessage: string): void;
  /**
   * Allows the player to log in
  */
  allow(): void;
  /**
   * Disallows the player from logging in, with the given reason
   *
   * @param result New result for disallowing the player
   * @param message Kick message to display to the user
   * @deprecated in favour of {@link #disallow(org.bukkit.event.player.PlayerPreLoginEvent.Result, net.kyori.adventure.text.Component)}
  */
  disallow(result: Result, message: string): void;
  /**
   * Gets the player's name.
   *
   * @return the player's name
  */
  getName(): string;
  /**
   * Gets the player IP address.
   *
   * @return The IP address
  */
  getAddress(): InetAddress;
  getHandlers(): HandlerList;
  /**
   * Gets the player's unique ID.
   *
   * @return The unique ID
  */
  getUniqueId(): UUID;
  static getHandlerList(): HandlerList;
}
/**
 * Called when a player interacts with an armor stand and will either swap, retrieve or place an item.
*/
export class PlayerArmorStandManipulateEvent extends PlayerInteractEntityEvent {
  constructor(who: Player, clickedEntity: ArmorStand, playerItem: ItemStack, armorStandItem: ItemStack, slot: EquipmentSlot);
  /**
   * Returns the item held by the player. If this Item is null and the armor stand Item is also null,
   * there will be no transaction between the player and the armor stand.
   * If the Player's item is null, but the armor stand item is not then the player will obtain the armor stand item.
   * In the case that the Player's item is not null, but the armor stand item is null, the players item will be placed on the armor stand.
   * If both items are not null, the items will be swapped.
   * In the case that the event is cancelled the original items will remain the same.
   * @return the item held by the player.
  */
  getPlayerItem(): ItemStack;
  /**
   * Returns the item held by the armor stand.
   * If this Item is null and the player's Item is also null, there will be no transaction between the player and the armor stand.
   * If the Player's item is null, but the armor stand item is not then the player will obtain the armor stand item.
   * In the case that the Player's item is not null, but the armor stand item is null, the players item will be placed on the armor stand.
   * If both items are not null, the items will be swapped.
   * In the case that the event is cancelled the original items will remain the same.
   * @return the item held by the armor stand.
  */
  getArmorStandItem(): ItemStack;
  /**
   * Returns the raw item slot of the armor stand in this event.
   *
   * @return the index of the item obtained or placed of the armor stand.
  */
  getSlot(): EquipmentSlot;
  getRightClicked(): ArmorStand;
  getHandlers(): HandlerList;
  static getHandlerList(): HandlerList;
}
/**
 * Called when a players experience changes naturally
*/
export class PlayerExpChangeEvent extends PlayerEvent {
  constructor(player: Player, expAmount: number);
  constructor(player: Player, sourceEntity: Entity | null, expAmount: number);
  /**
   * Get the source that provided the experience.
   *
   * @return The source of the experience
  */
  getSource(): Entity | null;
  /**
   * Get the amount of experience the player will receive
   *
   * @return The amount of experience
  */
  getAmount(): number;
  /**
   * Set the amount of experience the player will receive
   *
   * @param amount The amount of experience to set
  */
  setAmount(amount: number);
  getHandlers(): HandlerList;
  static getHandlerList(): HandlerList;
}
/**
 * This event is fired when the player is leaving a bed.
*/
export class PlayerBedLeaveEvent extends PlayerEvent {
  constructor(who: Player, bed: Block, setBedSpawn: boolean);
  /**
   * Returns the bed block involved in this event.
   *
   * @return the bed block involved in this event
  */
  getBed(): Block;
  /**
   * Get if this event should set the new spawn location for the
   * {@link Player}.
   * 
   * This does not remove any existing spawn location, only prevent it from
   * being changed (if true).
   * 
   * To change a {@link Player}'s spawn location, use
   * {@link Player#setBedSpawnLocation(Location)}.
   *
   * @return true if the spawn location will be changed
  */
  shouldSetSpawnLocation(): boolean;
  /**
   * Set if this event should set the new spawn location for the
   * {@link Player}.
   * 
   * This will not remove any existing spawn location, only prevent it from
   * being changed (if true).
   * 
   * To change a {@link Player}'s spawn location, use
   * {@link Player#setBedSpawnLocation(Location)}.
   *
   * @param setBedSpawn true to change the new spawn location
  */
  setSpawnLocation(setBedSpawn: boolean): void;
  /**
   * Gets the cancellation state of this event. A cancelled event will not
   * be executed in the server, but will still pass to other plugins
   *
   * @return true if this event is cancelled
  */
  isCancelled(): boolean;
  /**
   * Sets the cancellation state of this event. A cancelled event will not
   * be executed in the server, but will still pass to other plugins.
   *
   * @param cancel true if you wish to cancel this event
  */
  setCancelled(cancelled: boolean): void;
  getHandlers(): HandlerList;
  static getHandlerList(): HandlerList;
}
export interface PlayerBedLeaveEvent extends PlayerEvent, Cancellable {}
/**
 * Stores details for players attempting to log in.
 * 
 * Note that this event is called early in the player initialization
 * process. It is recommended that most options involving the Player
 * entity be postponed to the {@link PlayerJoinEvent} instead.
*/
export class PlayerLoginEvent extends PlayerEvent {
  /**
   * This constructor defaults message to an empty string, and result to
   * ALLOWED
   *
   * @param player The {@link Player} for this event
   * @param hostname The hostname that was used to connect to the server
   * @param address The address the player used to connect, provided for
   *     timing issues
   * @param realAddress the actual, unspoofed connecting address
  */
  constructor(player: Player, hostname: string, address: InetAddress, realAddress: InetAddress);
  constructor(player: Player, hostname: string, address: InetAddress);
  /**
   * This constructor pre-configures the event with a result and message
   *
   * @param player The {@link Player} for this event
   * @param hostname The hostname that was used to connect to the server
   * @param address The address the player used to connect, provided for
   *     timing issues
   * @param result The result status for this event
   * @param message The message to be displayed if result denies login
   * @param realAddress the actual, unspoofed connecting address
   * @deprecated in favour of {@link #PlayerLoginEvent(Player, String, InetAddress, Result, net.kyori.adventure.text.Component, InetAddress)}
  */
  constructor(player: Player, hostname: string, address: InetAddress, result: org_bukkit_event_player_PlayerLoginEvent_Result, message: string, realAddress: InetAddress);
  /**
   * This constructor pre-configures the event with a result and message
   *
   * @param player The {@link Player} for this event
   * @param hostname The hostname that was used to connect to the server
   * @param address The address the player used to connect, provided for
   *     timing issues
   * @param result The result status for this event
   * @param message The message to be displayed if result denies login
   * @param realAddress the actual, unspoofed connecting address
  */
  constructor(player: Player, hostname: string, address: InetAddress, result: org_bukkit_event_player_PlayerLoginEvent_Result, message: Component, realAddress: InetAddress);
  /**
   * Gets the current kick message that will be used if getResult() !=
   * Result.ALLOWED
   *
   * @return Current kick message
  */
  kickMessage(): Component;
  /**
   * Sets the kick message to display if getResult() != Result.ALLOWED
   *
   * @param message New kick message
  */
  kickMessage(message: Component): void;
  /**
   * Gets the connection address of this player, regardless of whether it has been spoofed or not.
   *
   * @return the player's connection address
  */
  getRealAddress(): InetAddress;
  /**
   * Gets the current result of the login, as an enum
   *
   * @return Current Result of the login
  */
  getResult(): org_bukkit_event_player_PlayerLoginEvent_Result;
  /**
   * Sets the new result of the login, as an enum
   *
   * @param result New result to set
  */
  setResult(result: org_bukkit_event_player_PlayerLoginEvent_Result);
  /**
   * Sets the kick message to display if getResult() != Result.ALLOWED
   *
   * @param message New kick message
   * @deprecated in favour of {@link #kickMessage(net.kyori.adventure.text.Component)}
  */
  setKickMessage(kickMessage: string): void;
  /**
   * Gets the hostname that the player used to connect to the server, or
   * blank if unknown
   *
   * @return The hostname
  */
  getHostname(): string;
  /**
   * Allows the player to log in
  */
  allow(): void;
  /**
   * Disallows the player from logging in, with the given reason
   *
   * @param result New result for disallowing the player
   * @param message Kick message to display to the user
   * @deprecated in favour of {@link #disallow(Result, net.kyori.adventure.text.Component)}
  */
  disallow(result: org_bukkit_event_player_PlayerLoginEvent_Result, message: string): void;
  /**
   * Disallows the player from logging in, with the given reason
   *
   * @param result New result for disallowing the player
   * @param message Kick message to display to the user
  */
  disallow(result: org_bukkit_event_player_PlayerLoginEvent_Result, message: Component): void;
  /**
   * Gets the {@link InetAddress} for the Player associated with this event.
   * This method is provided as a workaround for player.getAddress()
   * returning null during PlayerLoginEvent.
   *
   * @return The address for this player. For legacy compatibility, this may
   *     be null.
  */
  getAddress(): InetAddress;
  getHandlers(): HandlerList;
  static getHandlerList(): HandlerList;
}
/**
 * Called when a player joins a server
*/
export class PlayerJoinEvent extends PlayerEvent {
  constructor(playerJoined: Player, joinMessage: Component | null);
  constructor(playerJoined: Player, joinMessage: string | null);
  /**
   * Gets the join message to send to all online players
   *
   * @return string join message. Can be null
  */
  joinMessage(): Component | null;
  /**
   * Sets the join message to send to all online players
   *
   * @param joinMessage join message. If null, no message will be sent
  */
  joinMessage(joinMessage: Component | null): void;
  /**
   * Sets the join message to send to all online players
   *
   * @param joinMessage join message. If null, no message will be sent
   * @deprecated in favour of {@link #joinMessage(net.kyori.adventure.text.Component)}
  */
  setJoinMessage(joinMessage: string | null): void;
  getHandlers(): HandlerList;
  static getHandlerList(): HandlerList;
}
/**
 * This event is called when the list of available server commands is sent to
 * the player.
 * 
 * Commands may be removed from display using this event, but implementations
 * are not required to securely remove all traces of the command. If secure
 * removal of commands is required, then the command should be assigned a
 * permission which is not granted to the player.
*/
export class PlayerCommandSendEvent extends PlayerEvent {
  constructor(player: Player, commands: Collection<string>);
  /**
   * Returns a mutable collection of all top level commands to be sent.
   * 
   * It is not legal to add entries to this collection, only remove them.
   * Behaviour of adding entries is undefined.
   *
   * @return collection of all commands
  */
  getCommands(): Collection<string>;
  getHandlers(): HandlerList;
  static getHandlerList(): HandlerList;
}
/**
 * Holds information for player teleport events
*/
export class PlayerTeleportEvent extends PlayerMoveEvent {
  constructor(player: Player, from: Location, to: Location | null);
  constructor(player: Player, from: Location, to: Location | null, cause: TeleportCause);
  /**
   * Gets the cause of this teleportation event
   *
   * @return Cause of the event
  */
  getCause(): TeleportCause;
  getHandlers(): HandlerList;
  static getHandlerList(): HandlerList;
}
/**
 * Called when a player discovers a new recipe in the recipe book.
*/
export class PlayerRecipeDiscoverEvent extends PlayerEvent {
  constructor(who: Player, recipe: NamespacedKey);
  /**
   * Get the namespaced key of the discovered recipe.
   *
   * @return the discovered recipe
  */
  getRecipe(): NamespacedKey;
  /**
   * Gets the cancellation state of this event. A cancelled event will not
   * be executed in the server, but will still pass to other plugins
   *
   * @return true if this event is cancelled
  */
  isCancelled(): boolean;
  /**
   * Sets the cancellation state of this event. A cancelled event will not
   * be executed in the server, but will still pass to other plugins.
   *
   * @param cancel true if you wish to cancel this event
  */
  setCancelled(cancel: boolean): void;
  getHandlers(): HandlerList;
  static getHandlerList(): HandlerList;
}
export interface PlayerRecipeDiscoverEvent extends PlayerEvent, Cancellable {}
/**
 * Called when a player statistic is incremented.
 * 
 * This event is not called for some high frequency statistics, e.g. movement
 * based statistics.
 *
*/
export class PlayerStatisticIncrementEvent extends PlayerEvent {
  constructor(player: Player, statistic: Statistic, initialValue: number, newValue: number);
  constructor(player: Player, statistic: Statistic, initialValue: number, newValue: number, entityType: EntityType);
  constructor(player: Player, statistic: Statistic, initialValue: number, newValue: number, material: Material);
  /**
   * Gets the statistic that is being incremented.
   *
   * @return the incremented statistic
  */
  getStatistic(): Statistic;
  /**
   * Gets the previous value of the statistic.
   *
   * @return the previous value of the statistic
  */
  getPreviousValue(): number;
  /**
   * Gets the new value of the statistic.
   *
   * @return the new value of the statistic
  */
  getNewValue(): number;
  /**
   * Gets the EntityType if {@link #getStatistic() getStatistic()} is an
   * entity statistic otherwise returns null.
   *
   * @return the EntityType of the statistic
  */
  getEntityType(): EntityType | null;
  /**
   * Gets the Material if {@link #getStatistic() getStatistic()} is a block
   * or item statistic otherwise returns null.
   *
   * @return the Material of the statistic
  */
  getMaterial(): Material | null;
  /**
   * Gets the cancellation state of this event. A cancelled event will not
   * be executed in the server, but will still pass to other plugins
   *
   * @return true if this event is cancelled
  */
  isCancelled(): boolean;
  /**
   * Sets the cancellation state of this event. A cancelled event will not
   * be executed in the server, but will still pass to other plugins.
   *
   * @param cancel true if you wish to cancel this event
  */
  setCancelled(cancel: boolean): void;
  getHandlers(): HandlerList;
  static getHandlerList(): HandlerList;
}
export interface PlayerStatisticIncrementEvent extends PlayerEvent, Cancellable {}
/**
 * Represents when a player has an item repaired via the Mending enchantment.
 * 
 * This event is fired directly before the {@link PlayerExpChangeEvent}, and the
 * results of this event directly affect the {@link PlayerExpChangeEvent}.
*/
export class PlayerItemMendEvent extends PlayerEvent {
  constructor(who: Player, item: ItemStack, experienceOrb: ExperienceOrb, repairAmount: number);
  /**
   * Get the {@link ItemStack} to be repaired.
   *
   * This is not necessarily the item the player is holding.
   *
   * @return the item to be repaired
  */
  getItem(): ItemStack;
  /**
   * Get the experience orb triggering the event.
   *
   * @return the experience orb
  */
  getExperienceOrb(): ExperienceOrb;
  /**
   * Get the amount the item is to be repaired.
   *
   * The default value is twice the value of the consumed experience orb
   * or the remaining damage left on the item, whichever is smaller.
   *
   * @return how much damage will be repaired by the experience orb
  */
  getRepairAmount(): number;
  /**
   * Set the amount the item will be repaired.
   *
   * Half of this value will be subtracted from the experience orb which initiated this event.
   *
   * @param amount how much damage will be repaired on the item
  */
  setRepairAmount(repairAmount: number);
  /**
   * Gets the cancellation state of this event. A cancelled event will not
   * be executed in the server, but will still pass to other plugins
   *
   * @return true if this event is cancelled
  */
  isCancelled(): boolean;
  /**
   * Sets the cancellation state of this event. A cancelled event will not
   * be executed in the server, but will still pass to other plugins.
   *
   * @param cancel true if you wish to cancel this event
  */
  setCancelled(cancelled: boolean): void;
  getHandlers(): HandlerList;
  static getHandlerList(): HandlerList;
}
export interface PlayerItemMendEvent extends PlayerEvent, Cancellable {}
/**
 * Called when a player attempts to tab-complete a chat message.
 *
 * @deprecated This event is no longer fired due to client changes
*/
export class PlayerChatTabCompleteEvent extends PlayerEvent {
  constructor(who: Player, message: string, completions: Collection<string>);
  /**
   * Gets the chat message being tab-completed.
   *
   * @return the chat message
  */
  getChatMessage(): string;
  /**
   * Gets the last 'token' of the message being tab-completed.
   * 
   * The token is the substring starting with the character after the last
   * space in the message.
   *
   * @return The last token for the chat message
  */
  getLastToken(): string;
  /**
   * This is the collection of completions for this event.
   *
   * @return the current completions
  */
  getTabCompletions(): Collection<string>;
  getHandlers(): HandlerList;
  static getHandlerList(): HandlerList;
}
/**
 * Called when a player leaves a server
*/
export class PlayerQuitEvent extends PlayerEvent {
  constructor(who: Player, quitMessage: string | null);
  constructor(who: Player, quitMessage: string | null, quitReason: QuitReason | null);
  constructor(who: Player, quitMessage: Component | null);
  constructor(who: Player, quitMessage: Component | null, quitReason: QuitReason | null);
  /**
   * Gets the quit message to send to all online players
   *
   * @return string quit message
  */
  quitMessage(): Component | null;
  /**
   * Sets the quit message to send to all online players
   *
   * @param quitMessage quit message
  */
  quitMessage(quitMessage: Component | null): void;
  /**
   * Sets the quit message to send to all online players
   *
   * @param quitMessage quit message
   * @deprecated in favour of {@link #quitMessage(net.kyori.adventure.text.Component)}
  */
  setQuitMessage(quitMessage: string | null): void;
  getHandlers(): HandlerList;
  static getHandlerList(): HandlerList;
  getReason(): QuitReason;
}
/**
 * Called when a player interacts with a Bucket
*/
export class PlayerBucketEvent extends PlayerEvent {
  constructor(who: Player, blockClicked: Block, blockFace: BlockFace, bucket: Material, itemInHand: ItemStack);
  constructor(who: Player, block: Block, blockClicked: Block, blockFace: BlockFace, bucket: Material, itemInHand: ItemStack);
  constructor(who: Player, blockClicked: Block, blockFace: BlockFace, bucket: Material, itemInHand: ItemStack, hand: EquipmentSlot | null);
  constructor(who: Player, block: Block, blockClicked: Block, blockFace: BlockFace, bucket: Material, itemInHand: ItemStack, hand: EquipmentSlot | null);
  /**
   * Returns the bucket used in this event
   *
   * @return the used bucket
  */
  getBucket(): Material;
  /**
   * Get the resulting item in hand after the bucket event
   *
   * @return ItemStack hold in hand after the event.
  */
  getItemStack(): ItemStack | null;
  /**
   * Set the item in hand after the event
   *
   * @param itemStack the new held ItemStack after the bucket event.
  */
  setItemStack(itemStack: ItemStack | null);
  /**
   * Gets the block involved in this event.
   *
   * @return The Block which block is involved in this event
  */
  getBlock(): Block;
  /**
   * Return the block clicked
   *
   * @return the clicked block
  */
  getBlockClicked(): Block;
  /**
   * Get the face on the clicked block
   *
   * @return the clicked face
  */
  getBlockFace(): BlockFace;
  /**
   * The hand used to perform this action.
   *
   * @return the hand used
  */
  getHand(): EquipmentSlot;
  /**
   * Gets the cancellation state of this event. A cancelled event will not
   * be executed in the server, but will still pass to other plugins
   *
   * @return true if this event is cancelled
  */
  isCancelled(): boolean;
  /**
   * Sets the cancellation state of this event. A cancelled event will not
   * be executed in the server, but will still pass to other plugins.
   *
   * @param cancel true if you wish to cancel this event
  */
  setCancelled(cancel: boolean): void;
}
export interface PlayerBucketEvent extends PlayerEvent, Cancellable {}
/**
 * Called when a player gets kicked from the server
*/
export class PlayerKickEvent extends PlayerEvent {
  constructor(playerKicked: Player, kickReason: string, leaveMessage: string);
  constructor(playerKicked: Player, kickReason: Component, leaveMessage: Component);
  constructor(playerKicked: Player, kickReason: Component, leaveMessage: Component, cause: Cause);
  /**
   * Gets the leave message send to all online players
   *
   * @return string kick reason
  */
  leaveMessage(): Component;
  /**
   * Sets the leave message send to all online players
   *
   * @param leaveMessage leave message
  */
  leaveMessage(leaveMessage: Component): void;
  /**
   * Gets the reason why the player is getting kicked
   *
   * @return string kick reason
  */
  reason(): Component;
  /**
   * Sets the reason why the player is getting kicked
   *
   * @param kickReason kick reason
  */
  reason(kickReason: Component): void;
  /**
   * Gets the cancellation state of this event. A cancelled event will not
   * be executed in the server, but will still pass to other plugins
   *
   * @return true if this event is cancelled
  */
  isCancelled(): boolean;
  /**
   * Sets the cancellation state of this event. A cancelled event will not
   * be executed in the server, but will still pass to other plugins.
   *
   * @param cancel true if you wish to cancel this event
  */
  setCancelled(cancel: boolean): void;
  /**
   * Sets the reason why the player is getting kicked
   *
   * @param kickReason kick reason
   * @deprecated in favour of {@link #reason(net.kyori.adventure.text.Component)}
  */
  setReason(reason: string): void;
  /**
   * Sets the leave message send to all online players
   *
   * @param leaveMessage leave message
   * @deprecated in favour of {@link #leaveMessage(net.kyori.adventure.text.Component)}
  */
  setLeaveMessage(leaveMessage: string): void;
  getHandlers(): HandlerList;
  static getHandlerList(): HandlerList;
  /**
   * Gets the cause of this kick
   *
   * @return
  */
  getCause(): Cause;
}
export interface PlayerKickEvent extends PlayerEvent, Cancellable {}
/**
 * Called when a player has completed all criteria in an advancement.
*/
export class PlayerAdvancementDoneEvent extends PlayerEvent {
  constructor(who: Player, advancement: Advancement);
  constructor(who: Player, advancement: Advancement, message: Component | null);
  /**
   * Get the advancement which has been completed.
   *
   * @return completed advancement
  */
  getAdvancement(): Advancement;
  /**
   * Gets the message to send to all online players.
   * 
   * Will be null if the advancement does not announce to chat, for example if
   * it is a recipe unlock or a root advancement.
   *
   * @return The announcement message, or null
  */
  message(): Component | null;
  /**
   * Sets the message to send to all online players.
   * 
   * If set to null the message will not be sent.
   *
   * @param message The new message
  */
  message(message: Component | null): void;
  getHandlers(): HandlerList;
  static getHandlerList(): HandlerList;
}
/**
 * Represents a player animation event
 * Use {@link io.papermc.paper.event.player.PlayerArmSwingEvent} for determining which arm was swung.
*/
export class PlayerAnimationEvent extends PlayerEvent {
  /**
   * Construct a new PlayerAnimation event
   *
   * @param player The player instance
  */
  constructor(player: Player);
  constructor(player: Player, animationType: PlayerAnimationType);
  /**
   * Get the type of this animation event
   *
   * @return the animation type
  */
  getAnimationType(): PlayerAnimationType;
  /**
   * Gets the cancellation state of this event. A cancelled event will not
   * be executed in the server, but will still pass to other plugins
   *
   * @return true if this event is cancelled
  */
  isCancelled(): boolean;
  /**
   * Sets the cancellation state of this event. A cancelled event will not
   * be executed in the server, but will still pass to other plugins.
   *
   * @param cancel true if you wish to cancel this event
  */
  setCancelled(cancel: boolean): void;
  getHandlers(): HandlerList;
  static getHandlerList(): HandlerList;
}
export interface PlayerAnimationEvent extends PlayerEvent, Cancellable {}
/**
 * Called when a visible entity is hidden from a player.
 *
 * This event is only called when the entity's visibility status is actually
 * changed.
 *
 * This event is called regardless of if the entity was within tracking range.
 *
 * @see Player#hideEntity(org.bukkit.plugin.Plugin, org.bukkit.entity.Entity)
*/
export class PlayerHideEntityEvent extends PlayerEvent {
  constructor(who: Player, entity: Entity);
  /**
   * Gets the entity which has been hidden from the player.
   *
   * @return the hidden entity
  */
  getEntity(): Entity;
  getHandlers(): HandlerList;
  static getHandlerList(): HandlerList;
}
/**
 * This event is called when a player clicks the button to take a book of a
 * Lectern. If this event is cancelled the book remains on the lectern.
*/
export class PlayerTakeLecternBookEvent extends PlayerEvent {
  constructor(who: Player, lectern: Lectern);
  /**
   * Gets the lectern involved.
   *
   * @return the Lectern
  */
  getLectern(): Lectern;
  /**
   * Gets the current ItemStack on the lectern.
   *
   * @return the ItemStack on the Lectern
  */
  getBook(): ItemStack | null;
  /**
   * Gets the cancellation state of this event. A cancelled event will not
   * be executed in the server, but will still pass to other plugins
   *
   * @return true if this event is cancelled
  */
  isCancelled(): boolean;
  /**
   * Sets the cancellation state of this event. A cancelled event will not
   * be executed in the server, but will still pass to other plugins.
   *
   * @param cancel true if you wish to cancel this event
  */
  setCancelled(cancel: boolean): void;
  getHandlers(): HandlerList;
  static getHandlerList(): HandlerList;
}
export interface PlayerTakeLecternBookEvent extends PlayerEvent, Cancellable {}
/**
 * Stores details for players attempting to log in.
 * 
 * This event is asynchronous, and not run using main thread.
*/
export class AsyncPlayerPreLoginEvent extends Event {
  constructor(name: string, ipAddress: InetAddress);
  constructor(name: string, ipAddress: InetAddress, uniqueId: UUID);
  /**
   * Gets the PlayerProfile of the player logging in
   * @return The Profile
  */
  getPlayerProfile(): PlayerProfile;
  setPlayerProfile(playerProfile: PlayerProfile);
  /**
   * Gets the raw address of the player logging in
   * @return The address
  */
  getRawAddress(): InetAddress;
  constructor(name: string, ipAddress: InetAddress, uniqueId: UUID, profile: PlayerProfile);
  constructor(name: string, ipAddress: InetAddress, rawAddress: InetAddress, uniqueId: UUID, profile: PlayerProfile);
  constructor(name: string, ipAddress: InetAddress, rawAddress: InetAddress, uniqueId: UUID, profile: PlayerProfile, hostname: string);
  /**
   * Gets the current result of the login, as an enum
   *
   * @return Current Result of the login
  */
  getLoginResult(): org_bukkit_event_player_AsyncPlayerPreLoginEvent_Result;
  /**
   * Gets the current result of the login, as an enum
   *
   * @return Current Result of the login
   * @see #getLoginResult()
   * @deprecated This method uses a deprecated enum from {@link
   *     PlayerPreLoginEvent}
  */
  getResult(): Result;
  /**
   * Sets the new result of the login, as an enum
   *
   * @param result New result to set
  */
  setLoginResult(loginResult: org_bukkit_event_player_AsyncPlayerPreLoginEvent_Result);
  /**
   * Sets the new result of the login, as an enum
   *
   * @param result New result to set
   * @see #setLoginResult(Result)
   * @deprecated This method uses a deprecated enum from {@link
   *     PlayerPreLoginEvent}
  */
  setResult(result: Result);
  /**
   * Gets the current kick message that will be used if getResult() !=
   * Result.ALLOWED
   *
   * @return Current kick message
  */
  kickMessage(): Component;
  /**
   * Sets the kick message to display if getResult() != Result.ALLOWED
   *
   * @param message New kick message
  */
  kickMessage(message: Component): void;
  /**
   * Disallows the player from logging in, with the given reason
   *
   * @param result New result for disallowing the player
   * @param message Kick message to display to the user
  */
  disallow(result: org_bukkit_event_player_AsyncPlayerPreLoginEvent_Result, message: Component): void;
  /**
   * Disallows the player from logging in, with the given reason
   *
   * @param result New result for disallowing the player
   * @param message Kick message to display to the user
   * @deprecated This method uses a deprecated enum from {@link
   *     PlayerPreLoginEvent}
   * @see #disallow(Result, String)
  */
  disallow(result: Result, message: Component): void;
  /**
   * Sets the kick message to display if getResult() != Result.ALLOWED
   *
   * @param message New kick message
   * @deprecated in favour of {@link #kickMessage(net.kyori.adventure.text.Component)}
  */
  setKickMessage(kickMessage: string): void;
  /**
   * Allows the player to log in
  */
  allow(): void;
  /**
   * Disallows the player from logging in, with the given reason
   *
   * @param result New result for disallowing the player
   * @param message Kick message to display to the user
   * @deprecated in favour of {@link #disallow(org.bukkit.event.player.AsyncPlayerPreLoginEvent.Result, net.kyori.adventure.text.Component)}
  */
  disallow(result: org_bukkit_event_player_AsyncPlayerPreLoginEvent_Result, message: string): void;
  /**
   * Disallows the player from logging in, with the given reason
   *
   * @param result New result for disallowing the player
   * @param message Kick message to display to the user
   * @see #disallow(Result, String)
   * @deprecated This method uses a deprecated enum from {@link
   *     PlayerPreLoginEvent}
  */
  disallow(result: Result, message: string): void;
  /**
   * Gets the player's name.
   *
   * @return the player's name
  */
  getName(): string;
  /**
   * Gets the player IP address.
   *
   * @return The IP address
  */
  getAddress(): InetAddress;
  /**
   * Gets the player's unique ID.
   *
   * @return The unique ID
  */
  getUniqueId(): UUID;
  /**
   * Gets the hostname that the player used to connect to the server, or
   * blank if unknown
   *
   * @return The hostname
  */
  getHostname(): string;
  getHandlers(): HandlerList;
  static getHandlerList(): HandlerList;
}
/**
 * Called when a player changes their main hand in the client settings.
*/
export class PlayerChangedMainHandEvent extends PlayerEvent {
  constructor(who: Player, mainHand: MainHand);
  /**
   * Gets the new main hand of the player. The old hand is still momentarily
   * available via {@link Player#getMainHand()}.
   *
   * @return the new {@link MainHand} of the player
  */
  getMainHand(): MainHand;
  getHandlers(): HandlerList;
  static getHandlerList(): HandlerList;
}
/**
 * This is called immediately after a player registers for a plugin channel.
*/
export class PlayerRegisterChannelEvent extends PlayerChannelEvent {
  constructor(player: Player, channel: string);
}
/**
 * Represents an event that is called when a player interacts with an object or
 * air, potentially fired once for each hand. The hand can be determined using
 * {@link #getHand()}.
 * 
 * This event will fire as cancelled if the vanilla behavior is to do nothing
 * (e.g interacting with air). For the purpose of avoiding doubt, this means
 * that the event will only be in the cancelled state if it is fired as a result
 * of some prediction made by the server where no subsequent code will run,
 * rather than when the subsequent interaction activity (e.g. placing a block in
 * an illegal position ({@link BlockCanBuildEvent}) will fail.
*/
export class PlayerInteractEvent extends PlayerEvent {
  constructor(who: Player, action: Action, item: ItemStack | null, clickedBlock: Block | null, clickedFace: BlockFace);
  constructor(who: Player, action: Action, item: ItemStack | null, clickedBlock: Block | null, clickedFace: BlockFace, hand: EquipmentSlot | null);
  constructor(who: Player, action: Action, item: ItemStack | null, clickedBlock: Block | null, clickedFace: BlockFace, hand: EquipmentSlot | null, interactionPoint: Location | null);
  /**
   * Returns the action type
   *
   * @return Action returns the type of interaction
  */
  getAction(): Action;
  /**
   * Gets the cancellation state of this event. Set to true if you want to
   * prevent buckets from placing water and so forth
   *
   * @return boolean cancellation state
   * @deprecated This event has two possible cancellation states, one for
   * {@link #useInteractedBlock()} and one for {@link #useItemInHand()}. It is
   * possible a call might have the former false, but the latter true, eg in
   * the case of using a firework whilst gliding. Callers should check the
   * relevant methods individually.
  */
  isCancelled(): boolean;
  /**
   * Sets the cancellation state of this event. A canceled event will not be
   * executed in the server, but will still pass to other plugins
   * 
   * Canceling this event will prevent use of food (player won't lose the
   * food item), prevent bows/snowballs/eggs from firing, etc. (player won't
   * lose the ammo)
   *
   * @param cancel true if you wish to cancel this event
  */
  setCancelled(cancel: boolean): void;
  /**
   * Returns the item in hand represented by this event
   *
   * @return ItemStack the item used
  */
  getItem(): ItemStack | null;
  /**
   * Convenience method. Returns the material of the item represented by
   * this event
   *
   * @return Material the material of the item used
  */
  getMaterial(): Material;
  /**
   * Check if this event involved a block
   *
   * @return boolean true if it did
  */
  hasBlock(): boolean;
  /**
   * Check if this event involved an item
   *
   * @return boolean true if it did
  */
  hasItem(): boolean;
  /**
   * Convenience method to inform the user whether this was a block
   * placement event.
   *
   * @return boolean true if the item in hand was a block
  */
  isBlockInHand(): boolean;
  /**
   * Returns the clicked block
   *
   * @return Block returns the block clicked with this item.
  */
  getClickedBlock(): Block | null;
  /**
   * Returns the face of the block that was clicked
   *
   * @return BlockFace returns the face of the block that was clicked
  */
  getBlockFace(): BlockFace;
  /**
   * This controls the action to take with the block (if any) that was
   * clicked on. This event gets processed for all blocks, but most don't
   * have a default action
   *
   * @return the action to take with the interacted block
  */
  useInteractedBlock(): org_bukkit_event_Event_Result;
  /**
   * @param useInteractedBlock the action to take with the interacted block
  */
  setUseInteractedBlock(useInteractedBlock: org_bukkit_event_Event_Result): void;
  /**
   * This controls the action to take with the item the player is holding.
   * This includes both blocks and items (such as flint and steel or
   * records). When this is set to default, it will be allowed if no action
   * is taken on the interacted block.
   *
   * @return the action to take with the item in hand
  */
  useItemInHand(): org_bukkit_event_Event_Result;
  /**
   * @param useItemInHand the action to take with the item in hand
  */
  setUseItemInHand(useItemInHand: org_bukkit_event_Event_Result): void;
  /**
   * The hand used to perform this interaction. May be null in the case of
   * {@link Action#PHYSICAL}.
   *
   * @return the hand used to interact. May be null.
  */
  getHand(): EquipmentSlot | null;
  /**
   * The exact point at which the interaction occurred. May be null.
   *
   * @return the exact interaction point. May be null.
  */
  getInteractionPoint(): Location | null;
  getHandlers(): HandlerList;
  static getHandlerList(): HandlerList;
}
export interface PlayerInteractEvent extends PlayerEvent, Cancellable {}
/**
 * This event is fired when the player is almost about to enter the bed.
*/
export class PlayerBedEnterEvent extends PlayerEvent {
  constructor(who: Player, bed: Block, bedEnterResult: BedEnterResult);
  constructor(who: Player, bed: Block);
  /**
   * This describes the default outcome of this event.
   *
   * @return the bed enter result representing the default outcome of this event
  */
  getBedEnterResult(): BedEnterResult;
  /**
   * This controls the action to take with the bed that was clicked on.
   * 
   * In case of {@link org.bukkit.event.Event.Result#DEFAULT}, the default outcome is described by
   * {@link #getBedEnterResult()}.
   *
   * @return the action to take with the interacted bed
   * @see #setUseBed(org.bukkit.event.Event.Result)
  */
  useBed(): org_bukkit_event_Event_Result;
  /**
   * Sets the action to take with the interacted bed.
   * 
   * {@link org.bukkit.event.Event.Result#ALLOW} will result in the player sleeping, regardless of
   * the default outcome described by {@link #getBedEnterResult()}.
   * 
   * {@link org.bukkit.event.Event.Result#DENY} will prevent the player from sleeping. This has the
   * same effect as canceling the event via {@link #setCancelled(boolean)}.
   * 
   * {@link org.bukkit.event.Event.Result#DEFAULT} will result in the outcome described by
   * {@link #getBedEnterResult()}.
   *
   * @param useBed the action to take with the interacted bed
   * @see #useBed()
  */
  setUseBed(useBed: org_bukkit_event_Event_Result): void;
  /**
   * Gets the cancellation state of this event. Set to true if you want to
   * prevent the player from sleeping.
   * 
   * Canceling the event has the same effect as setting {@link #useBed()} to
   * {@link org.bukkit.event.Event.Result#DENY}.
   * 
   * For backwards compatibility reasons this also returns true if
   * {@link #useBed()} is {@link org.bukkit.event.Event.Result#DEFAULT} and the
   * {@link #getBedEnterResult() default action} is to prevent bed entering.
   *
   * @return boolean cancellation state
  */
  isCancelled(): boolean;
  /**
   * Sets the cancellation state of this event. A canceled event will not be
   * executed in the server, but will still pass to other plugins.
   * 
   * Canceling this event will prevent use of the bed.
   *
   * @param cancel true if you wish to cancel this event
  */
  setCancelled(cancel: boolean): void;
  /**
   * Returns the bed block involved in this event.
   *
   * @return the bed block involved in this event
  */
  getBed(): Block;
  getHandlers(): HandlerList;
  static getHandlerList(): HandlerList;
}
export interface PlayerBedEnterEvent extends PlayerEvent, Cancellable {}
/**
 * Called when the GameMode of the player is changed.
 * 
 * NOTE: When {@link #getCause()} is {@link Cause#DEFAULT_GAMEMODE},
 * the Player from {@link #getPlayer()} might not be fully online at
 * the time this event is fired. Plugins should use {@link Player#isOnline()}
 * to check before changing player state.
*/
export class PlayerGameModeChangeEvent extends PlayerEvent {
  constructor(player: Player, newGameMode: GameMode);
  constructor(player: Player, newGameMode: GameMode, cause: org_bukkit_event_player_PlayerGameModeChangeEvent_Cause, cancelMessage: Component | null);
  /**
   * Gets the cancellation state of this event. A cancelled event will not
   * be executed in the server, but will still pass to other plugins
   *
   * @return true if this event is cancelled
  */
  isCancelled(): boolean;
  /**
   * Sets the cancellation state of this event. A cancelled event will not
   * be executed in the server, but will still pass to other plugins.
   *
   * @param cancel true if you wish to cancel this event
  */
  setCancelled(cancel: boolean): void;
  /**
   * Gets the GameMode the player is switched to.
   *
   * @return  player's new GameMode
  */
  getNewGameMode(): GameMode;
  getHandlers(): HandlerList;
  static getHandlerList(): HandlerList;
  /**
   * Gets the cause of this gamemode change.
   *
   * @return the cause
  */
  getCause(): org_bukkit_event_player_PlayerGameModeChangeEvent_Cause;
  /**
   * Only valid if the cause of the gamemode change was directly due to a command..
   * Gets the message shown to the command user if the event is cancelled
   * as a notification that a player's gamemode was not changed.
   * 
   * This returns `null` if the gamemode change was due to a plugin, or a
   * player joining the game with a gamemode not equal to the server default gamemode
   * and `force-gamemode` is set to true.
   *
   * @return the error message shown to the command user, null if not directly caused by a command
  */
  cancelMessage(): Component | null;
  /**
   * Sets the message shown to the command user if the event was cancelled.
   * The message is only shown to cancelled events that are directly called by a command
   * not by a plugin or a player joining with the wrong gamemode.
   *
   * @param message the error message shown to the command user, null to show no message.
  */
  cancelMessage(message: Component | null): void;
}
export interface PlayerGameModeChangeEvent extends PlayerEvent, Cancellable {}
/**
 * This event will fire when a player is finishing consuming an item (food,
 * potion, milk bucket).
 * 
 * If the ItemStack is modified the server will use the effects of the new
 * item and not remove the original one from the player's inventory.
 * 
 * If the event is cancelled the effect will not be applied and the item will
 * not be removed from the player's inventory.
*/
export class PlayerItemConsumeEvent extends PlayerEvent {
  /**
   * @param player the player consuming
   * @param item the ItemStack being consumed
  */
  constructor(player: Player, item: ItemStack);
  /**
   * Gets the item that is being consumed. Modifying the returned item will
   * have no effect, you must use {@link
   * #setItem(org.bukkit.inventory.ItemStack)} instead.
   *
   * @return an ItemStack for the item being consumed
  */
  getItem(): ItemStack;
  /**
   * Set the item being consumed
   *
   * @param item the item being consumed
  */
  setItem(item: ItemStack | null);
  /**
   * Return the custom item stack that will replace the consumed item, or null if no
   * custom replacement has been set (which means the default replacement will be used).
   *
   * @return The custom item stack that will replace the consumed item or null
  */
  getReplacement(): ItemStack | null;
  /**
   * Set a custom item stack to replace the consumed item. Pass null to clear any custom
   * stack that has been set and use the default replacement.
   *
   * @param replacement Replacement item to set, null to clear any custom stack and use default
  */
  setReplacement(replacement: ItemStack | null);
  /**
   * Gets the cancellation state of this event. A cancelled event will not
   * be executed in the server, but will still pass to other plugins
   *
   * @return true if this event is cancelled
  */
  isCancelled(): boolean;
  /**
   * Sets the cancellation state of this event. A cancelled event will not
   * be executed in the server, but will still pass to other plugins.
   *
   * @param cancel true if you wish to cancel this event
  */
  setCancelled(cancel: boolean): void;
  getHandlers(): HandlerList;
  static getHandlerList(): HandlerList;
}
export interface PlayerItemConsumeEvent extends PlayerEvent, Cancellable {}
/**
 * This event is called whenever a player runs a command (by placing a slash
 * at the start of their message). It is called early in the command handling
 * process, and modifications in this event (via {@link #setMessage(String)})
 * will be shown in the behavior.
 * 
 * Many plugins will have no use for this event, and you should
 * attempt to avoid using it if it is not necessary.
 * 
 * Some examples of valid uses for this event are:
 * 
 * Logging executed commands to a separate file
 * Variable substitution. For example, replacing
 *     ${nearbyPlayer} with the name of the nearest other
 *     player, or simulating the @a and @p
 *     decorators used by Command Blocks in plugins that do not handle it.
 * Conditionally blocking commands belonging to other plugins. For
 *     example, blocking the use of the /home command in a
 *     combat arena.
 * Per-sender command aliases. For example, after a player runs the
 *     command /calias cr gamemode creative, the next time they
 *     run /cr, it gets replaced into
 *     /gamemode creative. (Global command aliases should be
 *     done by registering the alias.)
 * 
 * 
 * Examples of incorrect uses are:
 * 
 * Using this event to run command logic
 * 
 * 
 * If the event is cancelled, processing of the command will halt.
 * 
 * The state of whether or not there is a slash (/) at the
 * beginning of the message should be preserved. If a slash is added or
 * removed, unexpected behavior may result.
*/
export class PlayerCommandPreprocessEvent extends PlayerEvent {
  constructor(player: Player, message: string);
  constructor(player: Player, message: string, recipients: Set<Player>);
  /**
   * Gets the cancellation state of this event. A cancelled event will not
   * be executed in the server, but will still pass to other plugins
   *
   * @return true if this event is cancelled
  */
  isCancelled(): boolean;
  /**
   * Sets the cancellation state of this event. A cancelled event will not
   * be executed in the server, but will still pass to other plugins.
   *
   * @param cancel true if you wish to cancel this event
  */
  setCancelled(cancel: boolean): void;
  /**
   * Gets the command that the player is attempting to send.
   * 
   * All commands begin with a special character; implementations do not
   * consider the first character when executing the content.
   *
   * @return Message the player is attempting to send
  */
  getMessage(): string;
  /**
   * Sets the command that the player will send.
   * 
   * All commands begin with a special character; implementations do not
   * consider the first character when executing the content.
   *
   * @param command New message that the player will send
   * @throws IllegalArgumentException if command is null or empty
  */
  setMessage(message: string);
  /**
   * Sets the player that this command will be executed as.
   *
   * @param player New player which this event will execute as
   * @throws IllegalArgumentException if the player provided is null
  */
  setPlayer(player: Player);
  /**
   * Gets a set of recipients that this chat message will be displayed to.
   * 
   * The set returned is not guaranteed to be mutable and may auto-populate
   * on access. Any listener accessing the returned set should be aware that
   * it may reduce performance for a lazy set implementation. Listeners
   * should be aware that modifying the list may throw {@link
   * UnsupportedOperationException} if the event caller provides an
   * unmodifiable set.
   *
   * @return All Players who will see this chat message
   * @deprecated This method is provided for backward compatibility with no
   *     guarantee to the effect of viewing or modifying the set.
  */
  getRecipients(): Set<Player>;
  getHandlers(): HandlerList;
  static getHandlerList(): HandlerList;
  /**
   * Returns the player involved in this event
   *
   * @return Player who is involved in this event
  */
  getPlayer(): Player;
}
export interface PlayerCommandPreprocessEvent extends PlayerEvent, Cancellable {}
/**
 * Called when a player edits or signs a book and quill item. If the event is
 * cancelled, no changes are made to the BookMeta
*/
export class PlayerEditBookEvent extends PlayerEvent {
  constructor(who: Player, slot: number, previousBookMeta: BookMeta, newBookMeta: BookMeta, isSigning: boolean);
  /**
   * Gets the book meta currently on the book.
   * 
   * Note: this is a copy of the book meta. You cannot use this object to
   * change the existing book meta.
   *
   * @return the book meta currently on the book
  */
  getPreviousBookMeta(): BookMeta;
  /**
   * Gets the book meta that the player is attempting to add to the book.
   * 
   * Note: this is a copy of the proposed new book meta. Use {@link
   * #setNewBookMeta(BookMeta)} to change what will actually be added to the
   * book.
   *
   * @return the book meta that the player is attempting to add
  */
  getNewBookMeta(): BookMeta;
  /**
   * Gets the inventory slot number for the book item that triggered this
   * event.
   * 
   * This is a slot number on the player's hotbar in the range 0-8, or -1 for
   * off hand.
   *
   * @return the inventory slot number that the book item occupies
   * @deprecated books may be signed from off hand
  */
  getSlot(): number;
  /**
   * Sets the book meta that will actually be added to the book.
   *
   * @param newBookMeta new book meta
   * @throws IllegalArgumentException if the new book meta is null
  */
  setNewBookMeta(newBookMeta: BookMeta);
  /**
   * Gets whether or not the book is being signed. If a book is signed the
   * Material changes from BOOK_AND_QUILL to WRITTEN_BOOK.
   *
   * @return true if the book is being signed
  */
  isSigning(): boolean;
  /**
   * Sets whether or not the book is being signed. If a book is signed the
   * Material changes from BOOK_AND_QUILL to WRITTEN_BOOK.
   *
   * @param signing whether or not the book is being signed.
  */
  setSigning(signing: boolean): void;
  getHandlers(): HandlerList;
  static getHandlerList(): HandlerList;
  /**
   * Gets the cancellation state of this event. A cancelled event will not
   * be executed in the server, but will still pass to other plugins
   *
   * @return true if this event is cancelled
  */
  isCancelled(): boolean;
  /**
   * Sets the cancellation state of this event. A cancelled event will not
   * be executed in the server, but will still pass to other plugins.
   *
   * @param cancel true if you wish to cancel this event
  */
  setCancelled(cancel: boolean): void;
}
export interface PlayerEditBookEvent extends PlayerEvent, Cancellable {}
/**
 * Called prior to an entity being unleashed due to a player's action.
*/
export class PlayerUnleashEntityEvent extends EntityUnleashEvent {
  constructor(entity: Entity, player: Player);
  constructor(entity: Entity, player: Player, dropLeash: boolean);
  /**
   * Returns the player who is unleashing the entity.
   *
   * @return The player
  */
  getPlayer(): Player;
  /**
   * Gets the cancellation state of this event. A cancelled event will not
   * be executed in the server, but will still pass to other plugins
   *
   * @return true if this event is cancelled
  */
  isCancelled(): boolean;
  /**
   * Sets the cancellation state of this event. A cancelled event will not
   * be executed in the server, but will still pass to other plugins.
   *
   * @param cancel true if you wish to cancel this event
  */
  setCancelled(cancel: boolean): void;
}
export interface PlayerUnleashEntityEvent extends EntityUnleashEvent, Cancellable {}
/**
 * Called when a hidden entity is shown to a player.
 *
 * This event is only called when the entity's visibility status is actually
 * changed.
 *
 * This event is called regardless of whether the entity was within tracking
 * range.
 *
 * @see Player#showEntity(org.bukkit.plugin.Plugin, org.bukkit.entity.Entity)
*/
export class PlayerShowEntityEvent extends PlayerEvent {
  constructor(who: Player, entity: Entity);
  /**
   * Gets the entity which has been shown to the player.
   *
   * @return the shown entity
  */
  getEntity(): Entity;
  getHandlers(): HandlerList;
  static getHandlerList(): HandlerList;
}
/**
 * Called when a player fills a bucket
*/
export class PlayerBucketFillEvent extends PlayerBucketEvent {
  constructor(who: Player, blockClicked: Block, blockFace: BlockFace, bucket: Material, itemInHand: ItemStack);
  constructor(who: Player, block: Block, blockClicked: Block, blockFace: BlockFace, bucket: Material, itemInHand: ItemStack);
  constructor(who: Player, blockClicked: Block, blockFace: BlockFace, bucket: Material, itemInHand: ItemStack, hand: EquipmentSlot | null);
  constructor(who: Player, block: Block, blockClicked: Block, blockFace: BlockFace, bucket: Material, itemInHand: ItemStack, hand: EquipmentSlot | null);
  getHandlers(): HandlerList;
  static getHandlerList(): HandlerList;
}
/**
 * This is called immediately after a player unregisters for a plugin channel.
*/
export class PlayerUnregisterChannelEvent extends PlayerChannelEvent {
  constructor(player: Player, channel: string);
}
/**
 * This event is called whenever a player harvests a block.
 * 
 * A 'harvest' is when a block drops an item (usually some sort of crop) and
 * changes state, but is not broken in order to drop the item.
 * 
 * This event is not called for when a block is broken, to handle that, listen
 * for {@link org.bukkit.event.block.BlockBreakEvent} and
 * {@link org.bukkit.event.block.BlockDropItemEvent}.
*/
export class PlayerHarvestBlockEvent extends PlayerEvent {
  constructor(player: Player, harvestedBlock: Block, itemsHarvested: ItemStack[]);
  /**
   * Gets the block that is being harvested.
   *
   * @return The block that is being harvested
  */
  getHarvestedBlock(): Block;
  /**
   * Gets a list of items that are being harvested from this block.
   *
   * @return A list of items that are being harvested from this block
  */
  getItemsHarvested(): ItemStack[];
  /**
   * Gets the cancellation state of this event. A cancelled event will not
   * be executed in the server, but will still pass to other plugins
   *
   * @return true if this event is cancelled
  */
  isCancelled(): boolean;
  /**
   * Sets the cancellation state of this event. A cancelled event will not
   * be executed in the server, but will still pass to other plugins.
   *
   * @param cancel true if you wish to cancel this event
  */
  setCancelled(cancel: boolean): void;
  getHandlers(): HandlerList;
  static getHandlerList(): HandlerList;
}
export interface PlayerHarvestBlockEvent extends PlayerEvent, Cancellable {}
/**
 * Represents an event that is called when a player right clicks an entity.
*/
export class PlayerInteractEntityEvent extends PlayerEvent {
  constructor(who: Player, clickedEntity: Entity);
  constructor(who: Player, clickedEntity: Entity, hand: EquipmentSlot);
  /**
   * Gets the cancellation state of this event. A cancelled event will not
   * be executed in the server, but will still pass to other plugins
   *
   * @return true if this event is cancelled
  */
  isCancelled(): boolean;
  /**
   * Sets the cancellation state of this event. A cancelled event will not
   * be executed in the server, but will still pass to other plugins.
   *
   * @param cancel true if you wish to cancel this event
  */
  setCancelled(cancel: boolean): void;
  /**
   * Gets the entity that was right-clicked by the player.
   *
   * @return entity right clicked by player
  */
  getRightClicked(): Entity;
  /**
   * The hand used to perform this interaction.
   *
   * @return the hand used to interact
  */
  getHand(): EquipmentSlot;
  getHandlers(): HandlerList;
  static getHandlerList(): HandlerList;
}
export interface PlayerInteractEntityEvent extends PlayerEvent, Cancellable {}
/**
 * Called when a player swap items between main hand and off hand using the
 * hotkey.
*/
export class PlayerSwapHandItemsEvent extends PlayerEvent {
  constructor(player: Player, mainHandItem: ItemStack, offHandItem: ItemStack);
  /**
   * Gets the item switched to the main hand.
   *
   * @return item in the main hand
  */
  getMainHandItem(): ItemStack | null;
  /**
   * Sets the item in the main hand.
   *
   * @param mainHandItem new item in the main hand
  */
  setMainHandItem(mainHandItem: ItemStack | null);
  /**
   * Gets the item switched to the off hand.
   *
   * @return item in the off hand
  */
  getOffHandItem(): ItemStack | null;
  /**
   * Sets the item in the off hand.
   *
   * @param offHandItem new item in the off hand
  */
  setOffHandItem(offHandItem: ItemStack | null);
  /**
   * Gets the cancellation state of this event. A cancelled event will not
   * be executed in the server, but will still pass to other plugins
   *
   * @return true if this event is cancelled
  */
  isCancelled(): boolean;
  /**
   * Sets the cancellation state of this event. A cancelled event will not
   * be executed in the server, but will still pass to other plugins.
   *
   * @param cancel true if you wish to cancel this event
  */
  setCancelled(cancel: boolean): void;
  getHandlers(): HandlerList;
  static getHandlerList(): HandlerList;
}
export interface PlayerSwapHandItemsEvent extends PlayerEvent, Cancellable {}
/**
 * This event will sometimes fire synchronously, depending on how it was
 * triggered.
 * 
 * The constructor provides a boolean to indicate if the event was fired
 * synchronously or asynchronously. When asynchronous, this event can be
 * called from any thread, sans the main thread, and has limited access to the
 * API.
 * 
 * If a player is the direct cause of this event by an incoming packet, this
 * event will be asynchronous. If a plugin triggers this event by compelling a
 * player to chat, this event will be synchronous.
 * 
 * Care should be taken to check {@link #isAsynchronous()} and treat the event
 * appropriately.
 *
 * @deprecated use {@link io.papermc.paper.event.player.AsyncChatEvent} instead
*/
export class AsyncPlayerChatEvent extends PlayerEvent {
  /**
   * @param async This changes the event to a synchronous state.
   * @param who the chat sender
   * @param message the message sent
   * @param players the players to receive the message. This may be a lazy
   *     or unmodifiable collection.
  */
  constructor(async: boolean, who: Player, message: string, players: Set<Player>);
  /**
   * Gets the message that the player is attempting to send. This message
   * will be used with {@link #getFormat()}.
   *
   * @return Message the player is attempting to send
  */
  getMessage(): string;
  /**
   * Sets the message that the player will send. This message will be used
   * with {@link #getFormat()}.
   *
   * @param message New message that the player will send
  */
  setMessage(message: string);
  /**
   * Gets the format to use to display this chat message.
   * 
   * When this event finishes execution, the first format parameter is the
   * {@link Player#getDisplayName()} and the second parameter is {@link
   * #getMessage()}
   *
   * @return {@link String#format(String, Object...)} compatible format
   *     string
  */
  getFormat(): string;
  /**
   * Sets the format to use to display this chat message.
   * 
   * When this event finishes execution, the first format parameter is the
   * {@link Player#getDisplayName()} and the second parameter is {@link
   * #getMessage()}
   *
   * @param format {@link String#format(String, Object...)} compatible
   *     format string
   * @throws IllegalFormatException if the underlying API throws the
   *     exception
   * @throws NullPointerException if format is null
   * @see String#format(String, Object...)
  */
  setFormat(format: string);
  /**
   * Gets a set of recipients that this chat message will be displayed to.
   * 
   * The set returned is not guaranteed to be mutable and may auto-populate
   * on access. Any listener accessing the returned set should be aware that
   * it may reduce performance for a lazy set implementation.
   * 
   * Listeners should be aware that modifying the list may throw {@link
   * UnsupportedOperationException} if the event caller provides an
   * unmodifiable set.
   *
   * @return All Players who will see this chat message
  */
  getRecipients(): Set<Player>;
  /**
   * Gets the cancellation state of this event. A cancelled event will not
   * be executed in the server, but will still pass to other plugins
   *
   * @return true if this event is cancelled
  */
  isCancelled(): boolean;
  /**
   * Sets the cancellation state of this event. A cancelled event will not
   * be executed in the server, but will still pass to other plugins.
   *
   * @param cancel true if you wish to cancel this event
  */
  setCancelled(cancel: boolean): void;
  getHandlers(): HandlerList;
  static getHandlerList(): HandlerList;
}
export interface AsyncPlayerChatEvent extends PlayerEvent, Cancellable {}
/**
 * Holds information for player chat and commands
 *
 * @deprecated This event will fire from the main thread and allows the use of
 *     all of the Bukkit API, unlike the {@link AsyncPlayerChatEvent}.
 *     
 *     Listening to this event forces chat to wait for the main thread which
 *     causes delays for chat. {@link AsyncPlayerChatEvent} is the encouraged
 *     alternative for thread safe implementations.
 * @deprecated use {@link io.papermc.paper.event.player.ChatEvent} instead
*/
export class PlayerChatEvent extends PlayerEvent {
  constructor(player: Player, message: string);
  constructor(player: Player, message: string, format: string, recipients: Set<Player>);
  /**
   * Gets the cancellation state of this event. A cancelled event will not
   * be executed in the server, but will still pass to other plugins
   *
   * @return true if this event is cancelled
  */
  isCancelled(): boolean;
  /**
   * Sets the cancellation state of this event. A cancelled event will not
   * be executed in the server, but will still pass to other plugins.
   *
   * @param cancel true if you wish to cancel this event
  */
  setCancelled(cancel: boolean): void;
  /**
   * Gets the message that the player is attempting to send
   *
   * @return Message the player is attempting to send
  */
  getMessage(): string;
  /**
   * Sets the message that the player will send
   *
   * @param message New message that the player will send
  */
  setMessage(message: string);
  /**
   * Sets the player that this message will display as, or command will be
   * executed as
   *
   * @param player New player which this event will execute as
  */
  setPlayer(player: Player);
  /**
   * Gets the format to use to display this chat message
   *
   * @return String.Format compatible format string
  */
  getFormat(): string;
  /**
   * Sets the format to use to display this chat message
   *
   * @param format String.Format compatible format string
  */
  setFormat(format: string);
  /**
   * Gets a set of recipients that this chat message will be displayed to
   *
   * @return All Players who will see this chat message
  */
  getRecipients(): Set<Player>;
  getHandlers(): HandlerList;
  static getHandlerList(): HandlerList;
  /**
   * Returns the player involved in this event
   *
   * @return Player who is involved in this event
  */
  getPlayer(): Player;
}
export interface PlayerChatEvent extends PlayerEvent, Cancellable {}
/**
 * This event is fired when the player activates the riptide enchantment, using
 * their trident to propel them through the air.
 * 
 * N.B. the riptide action is currently performed client side, so manipulating
 * the player in this event may have undesired effects.
*/
export class PlayerRiptideEvent extends PlayerEvent {
  constructor(who: Player, item: ItemStack);
  /**
   * Gets the item containing the used enchantment.
   *
   * @return held enchanted item
  */
  getItem(): ItemStack;
  getHandlers(): HandlerList;
  static getHandlerList(): HandlerList;
}
/**
 * This event is called after a player registers or unregisters a new plugin
 * channel.
*/
export class PlayerChannelEvent extends PlayerEvent {
  constructor(player: Player, channel: string);
  getChannel(): string;
  getHandlers(): HandlerList;
  static getHandlerList(): HandlerList;
}

}
declare module 'org.bukkit.event.weather.LightningStrikeEvent' {
import { Enum } from 'java.lang';
export class Cause extends Enum<Cause> {
  /**
   * Triggered by the /summon command.
  */
  static readonly COMMAND: Cause;
  /**
   * Triggered by a Plugin.
  */
  static readonly CUSTOM: Cause;
  /**
   * Triggered by a Spawner.
  */
  static readonly SPAWNER: Cause;
  /**
   * Triggered by an enchanted trident.
  */
  static readonly TRIDENT: Cause;
  /**
   * Triggered by a skeleton horse trap.
  */
  static readonly TRAP: Cause;
  /**
   * Triggered by weather.
  */
  static readonly WEATHER: Cause;
  /**
   * Unknown trigger.
  */
  static readonly UNKNOWN: Cause;
  static valueOf(name: string): Cause;
  static values(): Cause[];
}

}
declare module 'org.bukkit.event.entity.EntityExhaustionEvent' {
import { Enum } from 'java.lang';
/**
 * The reason for why a PlayerExhaustionEvent takes place
*/
export class ExhaustionReason extends Enum<ExhaustionReason> {
  /**
   * Player mines a block
  */
  static readonly BLOCK_MINED: ExhaustionReason;
  /**
   * Player has the hunger potion effect
  */
  static readonly HUNGER_EFFECT: ExhaustionReason;
  /**
   * Player takes damage
  */
  static readonly DAMAGED: ExhaustionReason;
  /**
   * Player attacks another entity
  */
  static readonly ATTACK: ExhaustionReason;
  /**
   * Player is sprint jumping
  */
  static readonly JUMP_SPRINT: ExhaustionReason;
  /**
   * Player jumps
  */
  static readonly JUMP: ExhaustionReason;
  /**
   * Player swims one centimeter
  */
  static readonly SWIM: ExhaustionReason;
  /**
   * Player walks underwater one centimeter
  */
  static readonly WALK_UNDERWATER: ExhaustionReason;
  /**
   * Player moves on the surface of water one centimeter
  */
  static readonly WALK_ON_WATER: ExhaustionReason;
  /**
   * Player sprints one centimeter
  */
  static readonly SPRINT: ExhaustionReason;
  /**
   * Player crouches one centimeter (does not effect exhaustion, but fires
   * nonetheless)
  */
  static readonly CROUCH: ExhaustionReason;
  /**
   * Player walks one centimeter (does not effect exhaustion, but fires
   * nonetheless)
  */
  static readonly WALK: ExhaustionReason;
  /**
   * Player regenerated health
  */
  static readonly REGEN: ExhaustionReason;
  /**
   * Unknown exhaustion reason
  */
  static readonly UNKNOWN: ExhaustionReason;
  static valueOf(name: string): ExhaustionReason;
  static values(): ExhaustionReason[];
}

}
declare module 'org.bukkit.entity.Entity' {
import { Spigot as org_bukkit_command_CommandSender_Spigot } from 'org.bukkit.command.CommandSender';
export class Spigot extends org_bukkit_command_CommandSender_Spigot {

}

}
declare module 'org.bukkit.enchantments' {
import { Component } from 'net.kyori.adventure.text';
import { Enum } from 'java.lang';
import { Set, Map } from 'java.util';
import { EnchantmentRarity } from 'io.papermc.paper.enchantments';
import { Translatable } from 'net.kyori.adventure.translation';
import { EquipmentSlot, ItemStack } from 'org.bukkit.inventory';
import { NamespacedKey, Material, Keyed } from 'org.bukkit';
import { EntityCategory } from 'org.bukkit.entity';
/**
 * A class for the available enchantment offers in the enchantment table.
*/
export class EnchantmentOffer {
  constructor(enchantment: Enchantment, enchantmentLevel: number, cost: number);
  /**
   * Get the type of the enchantment.
   *
   * @return type of enchantment
  */
  getEnchantment(): Enchantment;
  /**
   * Sets the type of the enchantment.
   *
   * @param enchantment type of the enchantment
  */
  setEnchantment(enchantment: Enchantment);
  /**
   * Gets the level of the enchantment.
   *
   * @return level of the enchantment
  */
  getEnchantmentLevel(): number;
  /**
   * Sets the level of the enchantment.
   *
   * @param enchantmentLevel level of the enchantment
  */
  setEnchantmentLevel(enchantmentLevel: number);
  /**
   * Gets the cost (minimum level) which is displayed as a number on the right
   * hand side of the enchantment offer.
   *
   * @return cost for this enchantment
  */
  getCost(): number;
  /**
   * Sets the cost (minimum level) which is displayed as a number on the right
   * hand side of the enchantment offer.
   *
   * @param cost cost for this enchantment
  */
  setCost(cost: number);
}
/**
 * The various type of enchantments that may be added to armour or weapons
*/
export class Enchantment extends Keyed {
  /**
   * Provides protection against environmental damage
  */
  static readonly PROTECTION_ENVIRONMENTAL: Enchantment;
  /**
   * Provides protection against fire damage
  */
  static readonly PROTECTION_FIRE: Enchantment;
  /**
   * Provides protection against fall damage
  */
  static readonly PROTECTION_FALL: Enchantment;
  /**
   * Provides protection against explosive damage
  */
  static readonly PROTECTION_EXPLOSIONS: Enchantment;
  /**
   * Provides protection against projectile damage
  */
  static readonly PROTECTION_PROJECTILE: Enchantment;
  /**
   * Decreases the rate of air loss whilst underwater
  */
  static readonly OXYGEN: Enchantment;
  /**
   * Increases the speed at which a player may mine underwater
  */
  static readonly WATER_WORKER: Enchantment;
  /**
   * Damages the attacker
  */
  static readonly THORNS: Enchantment;
  /**
   * Increases walking speed while in water
  */
  static readonly DEPTH_STRIDER: Enchantment;
  /**
   * Freezes any still water adjacent to ice / frost which player is walking on
  */
  static readonly FROST_WALKER: Enchantment;
  /**
   * Item cannot be removed
  */
  static readonly BINDING_CURSE: Enchantment;
  /**
   * Increases damage against all targets
  */
  static readonly DAMAGE_ALL: Enchantment;
  /**
   * Increases damage against undead targets
  */
  static readonly DAMAGE_UNDEAD: Enchantment;
  /**
   * Increases damage against arthropod targets
  */
  static readonly DAMAGE_ARTHROPODS: Enchantment;
  /**
   * All damage to other targets will knock them back when hit
  */
  static readonly KNOCKBACK: Enchantment;
  /**
   * When attacking a target, has a chance to set them on fire
  */
  static readonly FIRE_ASPECT: Enchantment;
  /**
   * Provides a chance of gaining extra loot when killing monsters
  */
  static readonly LOOT_BONUS_MOBS: Enchantment;
  /**
   * Increases damage against targets when using a sweep attack
  */
  static readonly SWEEPING_EDGE: Enchantment;
  /**
   * Increases the rate at which you mine/dig
  */
  static readonly DIG_SPEED: Enchantment;
  /**
   * Allows blocks to drop themselves instead of fragments (for example,
   * stone instead of cobblestone)
  */
  static readonly SILK_TOUCH: Enchantment;
  /**
   * Decreases the rate at which a tool looses durability
  */
  static readonly DURABILITY: Enchantment;
  /**
   * Provides a chance of gaining extra loot when destroying blocks
  */
  static readonly LOOT_BONUS_BLOCKS: Enchantment;
  /**
   * Provides extra damage when shooting arrows from bows
  */
  static readonly ARROW_DAMAGE: Enchantment;
  /**
   * Provides a knockback when an entity is hit by an arrow from a bow
  */
  static readonly ARROW_KNOCKBACK: Enchantment;
  /**
   * Sets entities on fire when hit by arrows shot from a bow
  */
  static readonly ARROW_FIRE: Enchantment;
  /**
   * Provides infinite arrows when shooting a bow
  */
  static readonly ARROW_INFINITE: Enchantment;
  /**
   * Decreases odds of catching worthless junk
  */
  static readonly LUCK: Enchantment;
  /**
   * Increases rate of fish biting your hook
  */
  static readonly LURE: Enchantment;
  /**
   * Causes a thrown trident to return to the player who threw it
  */
  static readonly LOYALTY: Enchantment;
  /**
   * Deals more damage to mobs that live in the ocean
  */
  static readonly IMPALING: Enchantment;
  /**
   * When it is rainy, launches the player in the direction their trident is thrown
  */
  static readonly RIPTIDE: Enchantment;
  /**
   * Strikes lightning when a mob is hit with a trident if conditions are
   * stormy
  */
  static readonly CHANNELING: Enchantment;
  /**
   * Shoot multiple arrows from crossbows
  */
  static readonly MULTISHOT: Enchantment;
  /**
   * Charges crossbows quickly
  */
  static readonly QUICK_CHARGE: Enchantment;
  /**
   * Crossbow projectiles pierce entities
  */
  static readonly PIERCING: Enchantment;
  /**
   * Allows mending the item using experience orbs
  */
  static readonly MENDING: Enchantment;
  /**
   * Item disappears instead of dropping
  */
  static readonly VANISHING_CURSE: Enchantment;
  /**
   * Walk quicker on soul blocks
  */
  static readonly SOUL_SPEED: Enchantment;
  constructor(key: NamespacedKey);
  /**
   * Return the namespaced identifier for this object.
   *
   * @return this object's key
  */
  getKey(): NamespacedKey;
  /**
   * Gets the unique name of this enchantment
   *
   * @return Unique name
   * @deprecated enchantments are badly named, use {@link #getKey()}.
  */
  getName(): string;
  /**
   * Gets the maximum level that this Enchantment may become.
   *
   * @return Maximum level of the Enchantment
  */
  getMaxLevel(): number;
  /**
   * Gets the level that this Enchantment should start at
   *
   * @return Starting level of the Enchantment
  */
  getStartLevel(): number;
  /**
   * Gets the type of {@link ItemStack} that may fit this Enchantment.
   *
   * @return Target type of the Enchantment
  */
  getItemTarget(): EnchantmentTarget;
  /**
   * Checks if this enchantment is a treasure enchantment.
   * 
   * Treasure enchantments can only be received via looting, trading, or
   * fishing.
   *
   * @return true if the enchantment is a treasure enchantment
  */
  isTreasure(): boolean;
  /**
   * Checks if this enchantment is a cursed enchantment
   * 
   * Cursed enchantments are found the same way treasure enchantments are
   *
   * @return true if the enchantment is cursed
  */
  isCursed(): boolean;
  /**
   * Check if this enchantment conflicts with another enchantment.
   *
   * @param other The enchantment to check against
   * @return True if there is a conflict.
  */
  conflictsWith(other: Enchantment): boolean;
  /**
   * Checks if this Enchantment may be applied to the given {@link
   * ItemStack}.
   * 
   * This does not check if it conflicts with any enchantments already
   * applied to the item.
   *
   * @param item Item to test
   * @return True if the enchantment may be applied, otherwise False
  */
  canEnchantItem(item: ItemStack): boolean;
  /**
   * Get the name of the enchantment with its applied level.
   * 
   * If the given `level` is either less than the {@link #getStartLevel()} or greater than the {@link #getMaxLevel()},
   * the level may not be shown in the numeral format one may otherwise expect.
   * 
   *
   * @param level the level of the enchantment to show
   * @return the name of the enchantment with `level` applied
  */
  displayName(level: number): Component;
  /**
   * Checks if this enchantment can be found in villager trades.
   *
   * @return true if the enchantment can be found in trades
  */
  isTradeable(): boolean;
  /**
   * Checks if this enchantment can be found in an enchanting table
   * or use to enchant items generated by loot tables.
   *
   * @return true if the enchantment can be found in a table or by loot tables
  */
  isDiscoverable(): boolean;
  /**
   * Gets the rarity of this enchantment.
   *
   * @return the rarity
  */
  getRarity(): EnchantmentRarity;
  /**
   * Gets the damage increase as a result of the level and entity category specified
   *
   * @param level the level of enchantment
   * @param entityCategory the category of entity
   * @return the damage increase
  */
  getDamageIncrease(level: number, entityCategory: EntityCategory): number;
  /**
   * Gets the equipment slots where this enchantment is considered "active".
   *
   * @return the equipment slots
  */
  getActiveSlots(): Set<EquipmentSlot>;
  equals(obj: any): boolean;
  hashCode(): number;
  toString(): string;
  /**
   * Registers an enchantment with the given ID and object.
   * 
   * Generally not to be used from within a plugin.
   *
   * @param enchantment Enchantment to register
  */
  static registerEnchantment(enchantment: Enchantment): void;
  /**
   * Checks if this is accepting Enchantment registrations.
   *
   * @return True if the server Implementation may add enchantments
  */
  static isAcceptingRegistrations(): boolean;
  /**
   * Stops accepting any enchantment registrations
  */
  static stopAcceptingRegistrations(): void;
  /**
   * Gets the Enchantment at the specified key
   *
   * @param key key to fetch
   * @return Resulting Enchantment, or null if not found
  */
  static getByKey(key: NamespacedKey | null): Enchantment | null;
  /**
   * Gets the Enchantment at the specified name
   *
   * @param name Name to fetch
   * @return Resulting Enchantment, or null if not found
   * @deprecated enchantments are badly named, use {@link #getByKey(org.bukkit.NamespacedKey)}.
  */
  static getByName(name: string | null): Enchantment | null;
  /**
   * Gets an array of all the registered {@link Enchantment}s
   *
   * @return Array of enchantments
  */
  static values(): Enchantment[];
}
export interface Enchantment extends Keyed, Translatable {}
/**
 * Represents the applicable target for a {@link Enchantment}
*/
export class EnchantmentTarget extends Enum<EnchantmentTarget> {
  /**
   * Allows the Enchantment to be placed on all items
   *
   * @deprecated this target no longer exists in Vanilla
  */
  static readonly ALL: EnchantmentTarget;
  /**
   * Allows the Enchantment to be placed on armor
  */
  static readonly ARMOR: EnchantmentTarget;
  /**
   * Allows the Enchantment to be placed on feet slot armor
  */
  static readonly ARMOR_FEET: EnchantmentTarget;
  /**
   * Allows the Enchantment to be placed on leg slot armor
  */
  static readonly ARMOR_LEGS: EnchantmentTarget;
  /**
   * Allows the Enchantment to be placed on torso slot armor
  */
  static readonly ARMOR_TORSO: EnchantmentTarget;
  /**
   * Allows the Enchantment to be placed on head slot armor
  */
  static readonly ARMOR_HEAD: EnchantmentTarget;
  /**
   * Allows the Enchantment to be placed on weapons (swords)
  */
  static readonly WEAPON: EnchantmentTarget;
  /**
   * Allows the Enchantment to be placed on tools (spades, pickaxe, axes)
  */
  static readonly TOOL: EnchantmentTarget;
  /**
   * Allows the Enchantment to be placed on bows.
  */
  static readonly BOW: EnchantmentTarget;
  /**
   * Allows the Enchantment to be placed on fishing rods.
  */
  static readonly FISHING_ROD: EnchantmentTarget;
  /**
   * Allows the enchantment to be placed on items with durability.
  */
  static readonly BREAKABLE: EnchantmentTarget;
  /**
   * Allows the enchantment to be placed on wearable items.
  */
  static readonly WEARABLE: EnchantmentTarget;
  /**
   * Allow the Enchantment to be placed on tridents.
  */
  static readonly TRIDENT: EnchantmentTarget;
  /**
   * Allow the Enchantment to be placed on crossbows.
  */
  static readonly CROSSBOW: EnchantmentTarget;
  /**
   * Allow the Enchantment to be placed on vanishing items.
  */
  static readonly VANISHABLE: EnchantmentTarget;
  static valueOf(name: string): EnchantmentTarget;
  static values(): EnchantmentTarget[];
  /**
   * Check whether this target includes the specified item.
   *
   * @param item The item to check
   * @return True if the target includes the item
  */
  includes(item: Material): boolean;
  /**
   * Check whether this target includes the specified item.
   *
   * @param item The item to check
   * @return True if the target includes the item
  */
  includes(item: ItemStack): boolean;
}
/**
 * A simple wrapper for ease of selecting {@link Enchantment}s
*/
export class EnchantmentWrapper extends Enchantment {
  constructor(name: string);
  /**
   * Gets the enchantment bound to this wrapper
   *
   * @return Enchantment
  */
  getEnchantment(): Enchantment;
  getMaxLevel(): number;
  getStartLevel(): number;
  getItemTarget(): EnchantmentTarget;
  canEnchantItem(item: ItemStack): boolean;
  getName(): string;
  isTreasure(): boolean;
  isCursed(): boolean;
  conflictsWith(other: Enchantment): boolean;
  displayName(level: number): Component;
  translationKey(): string;
  isTradeable(): boolean;
  isDiscoverable(): boolean;
  getRarity(): EnchantmentRarity;
  getDamageIncrease(level: number, entityCategory: EntityCategory): number;
  getActiveSlots(): Set<EquipmentSlot>;
}

}
declare module 'org.bukkit.projectiles' {
import { Class } from 'java.lang';
import { Block } from 'org.bukkit.block';
import { Vector } from 'org.bukkit.util';
/**
 * Represents a valid source of a projectile.
*/
export class ProjectileSource {
  /**
   * Launches a {@link Projectile} from the ProjectileSource.
   *
   * @param  a projectile subclass
   * @param projectile class of the projectile to launch
   * @return the launched projectile
  */
  launchProjectile<T>(projectile: Class<T>): T;
  /**
   * Launches a {@link Projectile} from the ProjectileSource with an
   * initial velocity.
   *
   * @param  a projectile subclass
   * @param projectile class of the projectile to launch
   * @param velocity the velocity with which to launch
   * @return the launched projectile
  */
  launchProjectile<T>(projectile: Class<T>, velocity: Vector | null): T;
}
export class BlockProjectileSource extends ProjectileSource {
  /**
   * Gets the block this projectile source belongs to.
   *
   * @return Block for the projectile source
  */
  getBlock(): Block;
}

}
declare module 'org.bukkit.inventory.InventoryView' {
import { Enum } from 'java.lang';
import { InventoryType } from 'org.bukkit.event.inventory';
/**
 * Represents various extra properties of certain inventory windows.
*/
export class Property extends Enum<Property> {
  /**
   * The progress of the down-pointing arrow in a brewing inventory.
  */
  static readonly BREW_TIME: Property;
  /**
   * The progress of the fuel slot in a brewing inventory.
   *
   * This is a value between 0 and 20, with 0 making the bar empty, and 20
   * making the bar full.
  */
  static readonly FUEL_TIME: Property;
  /**
   * The progress of the flame in a furnace inventory.
  */
  static readonly BURN_TIME: Property;
  /**
   * How many total ticks the current fuel should last.
  */
  static readonly TICKS_FOR_CURRENT_FUEL: Property;
  /**
   * The progress of the right-pointing arrow in a furnace inventory.
  */
  static readonly COOK_TIME: Property;
  /**
   * How many total ticks the current smelting should last.
  */
  static readonly TICKS_FOR_CURRENT_SMELTING: Property;
  /**
   * In an enchanting inventory, the top button's experience level
   * value.
  */
  static readonly ENCHANT_BUTTON1: Property;
  /**
   * In an enchanting inventory, the middle button's experience level
   * value.
  */
  static readonly ENCHANT_BUTTON2: Property;
  /**
   * In an enchanting inventory, the bottom button's experience level
   * value.
  */
  static readonly ENCHANT_BUTTON3: Property;
  /**
   * In an enchanting inventory, the first four bits of the player's xpSeed.
  */
  static readonly ENCHANT_XP_SEED: Property;
  /**
   * In an enchanting inventory, the top button's enchantment's id
  */
  static readonly ENCHANT_ID1: Property;
  /**
   * In an enchanting inventory, the middle button's enchantment's id
  */
  static readonly ENCHANT_ID2: Property;
  /**
   * In an enchanting inventory, the bottom button's enchantment's id
  */
  static readonly ENCHANT_ID3: Property;
  /**
   * In an enchanting inventory, the top button's level value.
  */
  static readonly ENCHANT_LEVEL1: Property;
  /**
   * In an enchanting inventory, the middle button's level value.
  */
  static readonly ENCHANT_LEVEL2: Property;
  /**
   * In an enchanting inventory, the bottom button's level value.
  */
  static readonly ENCHANT_LEVEL3: Property;
  /**
   * In an beacon inventory, the levels of the beacon
  */
  static readonly LEVELS: Property;
  /**
   * In an beacon inventory, the primary potion effect
  */
  static readonly PRIMARY_EFFECT: Property;
  /**
   * In an beacon inventory, the secondary potion effect
  */
  static readonly SECONDARY_EFFECT: Property;
  /**
   * The repair's cost in xp levels
  */
  static readonly REPAIR_COST: Property;
  /**
   * The lectern's current open book page
  */
  static readonly BOOK_PAGE: Property;
  static valueOf(name: string): Property;
  static values(): Property[];
  getType(): InventoryType;
  /**
   * Gets the id of this view.
   *
   * @return the id of this view
   * @deprecated Magic value
  */
  getId(): number;
}

}
declare module 'org.bukkit.entity.Fox' {
import { Enum } from 'java.lang';
/**
 * Represents the various different fox types there are.
*/
export class Type extends Enum<Type> {
  static readonly RED: Type;
  static readonly SNOW: Type;
  static valueOf(name: string): Type;
  static values(): Type[];
}

}
declare module 'org.bukkit.event.player.PlayerQuitEvent' {
import { Enum } from 'java.lang';
export class QuitReason extends Enum<QuitReason> {
  /**
   * The player left on their own behalf.
   * 
   * This does not mean they pressed the disconnect button in their client, but rather that the client severed the
   * connection themselves. This may occur if no keep-alive packet is received on their side, among other things.
  */
  static readonly DISCONNECTED: QuitReason;
  /**
   * The player was kicked from the server.
  */
  static readonly KICKED: QuitReason;
  /**
   * The player has timed out.
  */
  static readonly TIMED_OUT: QuitReason;
  /**
   * The player's connection has entered an erroneous state.
   * 
   * Reasons for this may include invalid packets, invalid data, and uncaught exceptions in the packet handler,
   * among others.
  */
  static readonly ERRONEOUS_STATE: QuitReason;
  static valueOf(name: string): QuitReason;
  static values(): QuitReason[];
}

}
declare module 'org.bukkit.configuration.serialization' {
import { Class } from 'java.lang';
import { Map } from 'java.util';
/**
 * Represents an "alias" that a {@link ConfigurationSerializable} may be
 * stored as.
 * If this is not present on a {@link ConfigurationSerializable} class, it
 * will use the fully qualified name of the class.
 * 
 * This value will be stored in the configuration so that the configuration
 * deserialization can determine what type it is.
 * 
 * Using this annotation on any other class than a {@link
 * ConfigurationSerializable} will have no effect.
 *
 * @see ConfigurationSerialization#registerClass(Class, String)
*/
export class SerializableAs {

}
/**
 * Utility class for storing and retrieving classes for {@link Configuration}.
*/
export class ConfigurationSerialization {
  static readonly SERIALIZED_TYPE_KEY: string;
  deserialize(args: Map<string, any>): ConfigurationSerializable | null;
  /**
   * Attempts to deserialize the given arguments into a new instance of the
   * given class.
   * 
   * The class must implement {@link ConfigurationSerializable}, including
   * the extra methods as specified in the javadoc of
   * ConfigurationSerializable.
   * 
   * If a new instance could not be made, an example being the class not
   * fully implementing the interface, null will be returned.
   *
   * @param args Arguments for deserialization
   * @param clazz Class to deserialize into
   * @return New instance of the specified class
  */
  static deserializeObject(args: Map<string, any>, clazz: Class<ConfigurationSerializable>): ConfigurationSerializable | null;
  /**
   * Attempts to deserialize the given arguments into a new instance of the
   * given class.
   * 
   * The class must implement {@link ConfigurationSerializable}, including
   * the extra methods as specified in the javadoc of
   * ConfigurationSerializable.
   * 
   * If a new instance could not be made, an example being the class not
   * fully implementing the interface, null will be returned.
   *
   * @param args Arguments for deserialization
   * @return New instance of the specified class
  */
  static deserializeObject(args: Map<string, any>): ConfigurationSerializable | null;
  /**
   * Registers the given {@link ConfigurationSerializable} class by its
   * alias
   *
   * @param clazz Class to register
  */
  static registerClass(clazz: Class<ConfigurationSerializable>): void;
  /**
   * Registers the given alias to the specified {@link
   * ConfigurationSerializable} class
   *
   * @param clazz Class to register
   * @param alias Alias to register as
   * @see SerializableAs
  */
  static registerClass(clazz: Class<ConfigurationSerializable>, alias: string): void;
  /**
   * Unregisters the specified alias to a {@link ConfigurationSerializable}
   *
   * @param alias Alias to unregister
  */
  static unregisterClass(alias: string): void;
  /**
   * Unregisters any aliases for the specified {@link
   * ConfigurationSerializable} class
   *
   * @param clazz Class to unregister
  */
  static unregisterClass(clazz: Class<ConfigurationSerializable>): void;
  /**
   * Attempts to get a registered {@link ConfigurationSerializable} class by
   * its alias
   *
   * @param alias Alias of the serializable
   * @return Registered class, or null if not found
  */
  static getClassByAlias(alias: string): Class<ConfigurationSerializable> | null;
  /**
   * Gets the correct alias for the given {@link ConfigurationSerializable}
   * class
   *
   * @param clazz Class to get alias for
   * @return Alias to use for the class
  */
  static getAlias(clazz: Class<ConfigurationSerializable>): string;
}
/**
 * Represents an object that may be serialized.
 * 
 * These objects MUST implement one of the following, in addition to the
 * methods as defined by this interface:
 * 
 * A static method "deserialize" that accepts a single {@link Map}<
 * {@link String}, {@link Object}> and returns the class.
 * A static method "valueOf" that accepts a single {@link Map}<{@link
 * String}, {@link Object}> and returns the class.
 * A constructor that accepts a single {@link Map}<{@link String},
 * {@link Object}>.
 * 
 * In addition to implementing this interface, you must register the class
 * with {@link ConfigurationSerialization#registerClass(Class)}.
 *
 * @see DelegateDeserialization
 * @see SerializableAs
*/
export class ConfigurationSerializable {
  /**
   * Creates a Map representation of this class.
   * 
   * This class must provide a method to restore this class, as defined in
   * the {@link ConfigurationSerializable} interface javadocs.
   *
   * @return Map containing the current state of this class
  */
  serialize(): Map<string, any>;
}
/**
 * Applies to a {@link ConfigurationSerializable} that will delegate all
 * deserialization to another {@link ConfigurationSerializable}.
*/
export class DelegateDeserialization {

}

}
declare module 'org.bukkit.event.vehicle' {
import { Block } from 'org.bukkit.block';
import { HandlerList, Cancellable, Event } from 'org.bukkit.event';
import { Location } from 'org.bukkit';
import { LivingEntity, Vehicle, Entity } from 'org.bukkit.entity';
/**
 * Raised when a vehicle collides with an entity.
*/
export class VehicleEntityCollisionEvent extends VehicleCollisionEvent {
  constructor(vehicle: Vehicle, entity: Entity);
  getEntity(): Entity;
  /**
   * Gets the cancellation state of this event. A cancelled event will not
   * be executed in the server, but will still pass to other plugins
   *
   * @return true if this event is cancelled
  */
  isCancelled(): boolean;
  /**
   * Sets the cancellation state of this event. A cancelled event will not
   * be executed in the server, but will still pass to other plugins.
   *
   * @param cancel true if you wish to cancel this event
  */
  setCancelled(cancel: boolean): void;
  isPickupCancelled(): boolean;
  setPickupCancelled(cancel: boolean): void;
  isCollisionCancelled(): boolean;
  setCollisionCancelled(cancel: boolean): void;
}
export interface VehicleEntityCollisionEvent extends VehicleCollisionEvent, Cancellable {}
/**
 * Raised when a vehicle receives damage.
*/
export class VehicleDamageEvent extends VehicleEvent {
  constructor(vehicle: Vehicle, attacker: Entity | null, damage: number);
  /**
   * Gets the Entity that is attacking the vehicle
   *
   * @return the Entity that is attacking the vehicle
  */
  getAttacker(): Entity | null;
  /**
   * Gets the damage done to the vehicle
   *
   * @return the damage done to the vehicle
  */
  getDamage(): number;
  /**
   * Sets the damage done to the vehicle
   *
   * @param damage The damage
  */
  setDamage(damage: number);
  /**
   * Gets the cancellation state of this event. A cancelled event will not
   * be executed in the server, but will still pass to other plugins
   *
   * @return true if this event is cancelled
  */
  isCancelled(): boolean;
  /**
   * Sets the cancellation state of this event. A cancelled event will not
   * be executed in the server, but will still pass to other plugins.
   *
   * @param cancel true if you wish to cancel this event
  */
  setCancelled(cancel: boolean): void;
  getHandlers(): HandlerList;
  static getHandlerList(): HandlerList;
}
export interface VehicleDamageEvent extends VehicleEvent, Cancellable {}
/**
 * Raised when a vehicle is destroyed, which could be caused by either a
 * player or the environment. This is not raised if the boat is simply
 * 'removed' due to other means.
*/
export class VehicleDestroyEvent extends VehicleEvent {
  constructor(vehicle: Vehicle, attacker: Entity | null);
  /**
   * Gets the Entity that has destroyed the vehicle, potentially null
   *
   * @return the Entity that has destroyed the vehicle, potentially null
  */
  getAttacker(): Entity | null;
  /**
   * Gets the cancellation state of this event. A cancelled event will not
   * be executed in the server, but will still pass to other plugins
   *
   * @return true if this event is cancelled
  */
  isCancelled(): boolean;
  /**
   * Sets the cancellation state of this event. A cancelled event will not
   * be executed in the server, but will still pass to other plugins.
   *
   * @param cancel true if you wish to cancel this event
  */
  setCancelled(cancel: boolean): void;
  getHandlers(): HandlerList;
  static getHandlerList(): HandlerList;
}
export interface VehicleDestroyEvent extends VehicleEvent, Cancellable {}
/**
 * Raised when a vehicle is created.
*/
export class VehicleCreateEvent extends VehicleEvent {
  constructor(vehicle: Vehicle);
  /**
   * Gets the cancellation state of this event. A cancelled event will not
   * be executed in the server, but will still pass to other plugins
   *
   * @return true if this event is cancelled
  */
  isCancelled(): boolean;
  /**
   * Sets the cancellation state of this event. A cancelled event will not
   * be executed in the server, but will still pass to other plugins.
   *
   * @param cancel true if you wish to cancel this event
  */
  setCancelled(cancelled: boolean): void;
  getHandlers(): HandlerList;
  static getHandlerList(): HandlerList;
}
export interface VehicleCreateEvent extends VehicleEvent, Cancellable {}
/**
 * Called when a vehicle updates
*/
export class VehicleUpdateEvent extends VehicleEvent {
  constructor(vehicle: Vehicle);
  getHandlers(): HandlerList;
  static getHandlerList(): HandlerList;
}
/**
 * Raised when a vehicle moves.
*/
export class VehicleMoveEvent extends VehicleEvent {
  constructor(vehicle: Vehicle, from: Location, to: Location);
  /**
   * Get the previous position.
   *
   * @return Old position.
  */
  getFrom(): Location;
  /**
   * Get the next position.
   *
   * @return New position.
  */
  getTo(): Location;
  getHandlers(): HandlerList;
  static getHandlerList(): HandlerList;
}
/**
 * Represents a vehicle-related event.
*/
export class VehicleEvent extends Event {
  constructor(vehicle: Vehicle);
  /**
   * Get the vehicle.
   *
   * @return the vehicle
  */
  getVehicle(): Vehicle;
}
/**
 * Raised when a vehicle collides with a block.
*/
export class VehicleBlockCollisionEvent extends VehicleCollisionEvent {
  constructor(vehicle: Vehicle, block: Block);
  /**
   * Gets the block the vehicle collided with
   *
   * @return the block the vehicle collided with
  */
  getBlock(): Block;
}
/**
 * Raised when a living entity exits a vehicle.
*/
export class VehicleExitEvent extends VehicleEvent {
  constructor(vehicle: Vehicle, exited: LivingEntity, isCancellable: boolean);
  constructor(vehicle: Vehicle, exited: LivingEntity);
  /**
   * Get the living entity that exited the vehicle.
   *
   * @return The entity.
  */
  getExited(): LivingEntity;
  /**
   * Gets the cancellation state of this event. A cancelled event will not
   * be executed in the server, but will still pass to other plugins
   *
   * @return true if this event is cancelled
  */
  isCancelled(): boolean;
  /**
   * Sets the cancellation state of this event. A cancelled event will not
   * be executed in the server, but will still pass to other plugins.
   *
   * @param cancel true if you wish to cancel this event
  */
  setCancelled(cancel: boolean): void;
  isCancellable(): boolean;
  getHandlers(): HandlerList;
  static getHandlerList(): HandlerList;
}
export interface VehicleExitEvent extends VehicleEvent, Cancellable {}
/**
 * Raised when an entity enters a vehicle.
*/
export class VehicleEnterEvent extends VehicleEvent {
  constructor(vehicle: Vehicle, entered: Entity);
  /**
   * Gets the Entity that entered the vehicle.
   *
   * @return the Entity that entered the vehicle
  */
  getEntered(): Entity;
  /**
   * Gets the cancellation state of this event. A cancelled event will not
   * be executed in the server, but will still pass to other plugins
   *
   * @return true if this event is cancelled
  */
  isCancelled(): boolean;
  /**
   * Sets the cancellation state of this event. A cancelled event will not
   * be executed in the server, but will still pass to other plugins.
   *
   * @param cancel true if you wish to cancel this event
  */
  setCancelled(cancel: boolean): void;
  getHandlers(): HandlerList;
  static getHandlerList(): HandlerList;
}
export interface VehicleEnterEvent extends VehicleEvent, Cancellable {}
/**
 * Raised when a vehicle collides.
*/
export class VehicleCollisionEvent extends VehicleEvent {
  constructor(vehicle: Vehicle);
  getHandlers(): HandlerList;
  static getHandlerList(): HandlerList;
}

}
declare module 'org.bukkit.persistence.PersistentDataType' {
import { Class } from 'java.lang';
import { PersistentDataAdapterContext, PersistentDataType } from 'org.bukkit.persistence';
/**
 * A default implementation that simply exists to pass on the retrieved or
 * inserted value to the next layer.
 * 
 * This implementation does not add any kind of logic, but is used to
 * provide default implementations for the primitive types.
 *
 * @param  the generic type of the primitive objects
*/
export class PrimitivePersistentDataType<T> extends PersistentDataType<T, T> {
  /**
   * Returns the primitive data type of this tag.
   *
   * @return the class
  */
  getPrimitiveType(): Class<T>;
  /**
   * Returns the complex object type the primitive value resembles.
   *
   * @return the class type
  */
  getComplexType(): Class<T>;
  /**
   * Returns the primitive data that resembles the complex object passed to
   * this method.
   *
   * @param complex the complex object instance
   * @param context the context this operation is running in
   * @return the primitive value
  */
  toPrimitive(complex: T, context: PersistentDataAdapterContext): T;
  /**
   * Creates a complex object based of the passed primitive value
   *
   * @param primitive the primitive value
   * @param context the context this operation is running in
   * @return the complex object instance
  */
  fromPrimitive(primitive: T, context: PersistentDataAdapterContext): T;
}

}
declare module 'org.bukkit.event.server' {
import { Component } from 'net.kyori.adventure.text';
import { MapView } from 'org.bukkit.map';
import { Set, Iterator, List } from 'java.util';
import { Iterable } from 'java.lang';
import { InetAddress } from 'java.net';
import { CommandSender } from 'org.bukkit.command';
import { LoadType } from 'org.bukkit.event.server.ServerLoadEvent';
import { CachedServerIcon } from 'org.bukkit.util';
import { HandlerList, Cancellable, Event } from 'org.bukkit.event';
import { RegisteredServiceProvider, Plugin } from 'org.bukkit.plugin';
import { Location } from 'org.bukkit';
import { Player } from 'org.bukkit.entity';
/**
 * This event is called when a command is run by a non-player. It is
 * called early in the command handling process, and modifications in this
 * event (via {@link #setCommand(String)}) will be shown in the behavior.
 * 
 * Many plugins will have no use for this event, and you should
 * attempt to avoid using it if it is not necessary.
 * 
 * Some examples of valid uses for this event are:
 * 
 * Logging executed commands to a separate file
 * Variable substitution. For example, replacing ${ip:Steve}
 *     with the connection IP of the player named Steve, or simulating the
 *     @a and @p decorators used by Command Blocks
 *     for plugins that do not handle it.
 * Conditionally blocking commands belonging to other plugins.
 * Per-sender command aliases. For example, after the console runs the
 *     command /calias cr gamemode creative, the next time they
 *     run /cr, it gets replaced into
 *     /gamemode creative. (Global command aliases should be
 *     done by registering the alias.)
 * 
 * 
 * Examples of incorrect uses are:
 * 
 * Using this event to run command logic
 * 
 * 
 * If the event is cancelled, processing of the command will halt.
 * 
 * The state of whether or not there is a slash (/) at the
 * beginning of the message should be preserved. If a slash is added or
 * removed, unexpected behavior may result.
*/
export class ServerCommandEvent extends ServerEvent {
  constructor(sender: CommandSender, command: string);
  /**
   * Gets the command that the user is attempting to execute from the
   * console
   *
   * @return Command the user is attempting to execute
  */
  getCommand(): string;
  /**
   * Sets the command that the server will execute
   *
   * @param message New message that the server will execute
  */
  setCommand(command: string);
  /**
   * Get the command sender.
   *
   * @return The sender
  */
  getSender(): CommandSender;
  getHandlers(): HandlerList;
  static getHandlerList(): HandlerList;
  /**
   * Gets the cancellation state of this event. A cancelled event will not
   * be executed in the server, but will still pass to other plugins
   *
   * @return true if this event is cancelled
  */
  isCancelled(): boolean;
  /**
   * Sets the cancellation state of this event. A cancelled event will not
   * be executed in the server, but will still pass to other plugins.
   *
   * @param cancel true if you wish to cancel this event
  */
  setCancelled(cancel: boolean): void;
}
export interface ServerCommandEvent extends ServerEvent, Cancellable {}
/**
 * Used for plugin enable and disable events
*/
export class PluginEvent extends ServerEvent {
  constructor(plugin: Plugin);
  /**
   * Gets the plugin involved in this event
   *
   * @return Plugin for this event
  */
  getPlugin(): Plugin;
}
/**
 * This event is called when a command is received over RCON. See the javadocs
 * of {@link ServerCommandEvent} for more information.
*/
export class RemoteServerCommandEvent extends ServerCommandEvent {
  constructor(sender: CommandSender, command: string);
  getHandlers(): HandlerList;
  static getHandlerList(): HandlerList;
}
/**
 * Called when a server list ping is coming in. Displayed players can be
 * checked and removed by {@link #iterator() iterating} over this event.
 * 
 * Note: The players in {@link #iterator()} will not be shown in the
 * server info if {@link Bukkit#getHideOnlinePlayers()} is true.
*/
export class ServerListPingEvent extends ServerEvent {
  constructor(address: InetAddress, motd: string, numPlayers: number, maxPlayers: number);
  constructor(address: InetAddress, motd: Component, numPlayers: number, maxPlayers: number);
  /**
   * Get the message of the day message.
   *
   * @return the message of the day
  */
  motd(): Component;
  /**
   * Change the message of the day message.
   *
   * @param motd the message of the day
  */
  motd(motd: Component): void;
  /**
   * Get the address the ping is coming from.
   *
   * @return the address
  */
  getAddress(): InetAddress;
  /**
   * Change the message of the day message.
   *
   * @param motd the message of the day
   * @deprecated in favour of {@link #motd(net.kyori.adventure.text.Component)}
  */
  setMotd(motd: string): void;
  /**
   * Get the number of players sent.
   *
   * @return the number of players
  */
  getNumPlayers(): number;
  /**
   * Get the maximum number of players sent.
   *
   * @return the maximum number of players
  */
  getMaxPlayers(): number;
  /**
   * Set the maximum number of players sent.
   *
   * @param maxPlayers the maximum number of player
  */
  setMaxPlayers(maxPlayers: number);
  /**
   * Sets the server-icon sent to the client.
   *
   * @param icon the icon to send to the client
   * @throws IllegalArgumentException if the {@link CachedServerIcon} is not
   *     created by the caller of this event; null may be accepted for some
   *     implementations
   * @throws UnsupportedOperationException if the caller of this event does
   *     not support setting the server icon
  */
  setServerIcon(serverIcon: CachedServerIcon);
  getHandlers(): HandlerList;
  static getHandlerList(): HandlerList;
  /**
   * {@inheritDoc}
   * 
   * Calling the {@link Iterator#remove()} method will force that particular
   * player to not be displayed on the player list, decrease the size
   * returned by {@link #getNumPlayers()}, and will not be returned again by
   * any new iterator.
   * 
   * Note: The players here will not be shown in the server info if
   * {@link Bukkit#getHideOnlinePlayers()} is true.
   *
   * @throws UnsupportedOperationException if the caller of this event does
   *     not support removing players
  */
  iterator(): Iterator<Player>;
}
export interface ServerListPingEvent extends ServerEvent, Iterable<Player> {}
/**
 * Called when a {@link CommandSender} of any description (ie: player or
 * console) attempts to tab complete.
 * 
 * Note that due to client changes, if the sender is a Player, this event will
 * only begin to fire once command arguments are specified, not commands
 * themselves. Plugins wishing to remove commands from tab completion are
 * advised to ensure the client does not have permission for the relevant
 * commands, or use {@link PlayerCommandSendEvent}.
*/
export class TabCompleteEvent extends Event {
  constructor(sender: CommandSender, buffer: string, completions: string[]);
  constructor(sender: CommandSender, buffer: string, completions: string[], isCommand: boolean, location: Location | null);
  /**
   * Get the sender completing this command.
   *
   * @return the {@link CommandSender} instance
  */
  getSender(): CommandSender;
  /**
   * Return the entire buffer which formed the basis of this completion.
   *
   * @return command buffer, as entered
  */
  getBuffer(): string;
  /**
   * The list of completions which will be offered to the sender, in order.
   * This list is mutable and reflects what will be offered.
   *
   * @return a list of offered completions
  */
  getCompletions(): string[];
  /**
   * @return True if it is a command being tab completed, false if it is a chat message.
  */
  isCommand(): boolean;
  /**
   * @return The position looked at by the sender, or null if none
  */
  getLocation(): Location | null;
  /**
   * Set the completions offered, overriding any already set.
   *
   * The passed collection will be cloned to a new List. You must call {{@link #getCompletions()}} to mutate from here
   *
   * @param completions the new completions
  */
  setCompletions(completions: string[]);
  /**
   * Gets the cancellation state of this event. A cancelled event will not
   * be executed in the server, but will still pass to other plugins
   *
   * @return true if this event is cancelled
  */
  isCancelled(): boolean;
  /**
   * Sets the cancellation state of this event. A cancelled event will not
   * be executed in the server, but will still pass to other plugins.
   *
   * @param cancel true if you wish to cancel this event
  */
  setCancelled(cancelled: boolean): void;
  getHandlers(): HandlerList;
  static getHandlerList(): HandlerList;
}
export interface TabCompleteEvent extends Event, Cancellable {}
/**
 * Called when a plugin is disabled.
*/
export class PluginDisableEvent extends PluginEvent {
  constructor(plugin: Plugin);
  getHandlers(): HandlerList;
  static getHandlerList(): HandlerList;
}
/**
 * An event relating to a registered service. This is called in a {@link
 * org.bukkit.plugin.ServicesManager}
*/
export class ServiceEvent extends ServerEvent {
  constructor(provider: RegisteredServiceProvider<any>);
  getProvider(): RegisteredServiceProvider<any>;
}
/**
 * This event is called when a service is unregistered.
 * 
 * Warning: The order in which register and unregister events are called
 * should not be relied upon.
*/
export class ServiceUnregisterEvent extends ServiceEvent {
  constructor(serviceProvider: RegisteredServiceProvider<any>);
  getHandlers(): HandlerList;
  static getHandlerList(): HandlerList;
}
/**
 * This event is called when a service is registered.
 * 
 * Warning: The order in which register and unregister events are called
 * should not be relied upon.
*/
export class ServiceRegisterEvent extends ServiceEvent {
  constructor(registeredProvider: RegisteredServiceProvider<any>);
  getHandlers(): HandlerList;
  static getHandlerList(): HandlerList;
}
/**
 * This event is called when either the server startup or reload has completed.
*/
export class ServerLoadEvent extends ServerEvent {
  /**
   * Creates a `ServerLoadEvent` with a given loading type.
   *
   * @param type the context in which the server was loaded
  */
  constructor(type: LoadType);
  /**
   * Gets the context in which the server was loaded.
   *
   * @return the context in which the server was loaded
  */
  getType(): LoadType;
  getHandlers(): HandlerList;
  static getHandlerList(): HandlerList;
}
/**
 * Event triggered for server broadcast messages such as from
 * {@link org.bukkit.Server#broadcast(String, String)}.
 *
 * This event behaves similarly to {@link AsyncPlayerChatEvent} in that it
 * should be async if fired from an async thread. Please see that event for
 * further information.
*/
export class BroadcastMessageEvent extends ServerEvent {
  constructor(message: string, recipients: Set<CommandSender>);
  constructor(isAsync: boolean, message: string, recipients: Set<CommandSender>);
  constructor(message: Component, recipients: Set<CommandSender>);
  constructor(isAsync: boolean, message: Component, recipients: Set<CommandSender>);
  /**
   * Get the broadcast message.
   *
   * @return Message to broadcast
  */
  message(): Component;
  /**
   * Set the broadcast message.
   *
   * @param message New message to broadcast
  */
  message(message: Component): void;
  /**
   * Set the message to broadcast.
   *
   * @param message New message to broadcast
   * @deprecated in favour of {@link #message(net.kyori.adventure.text.Component)}
  */
  setMessage(message: string): void;
  /**
   * Gets a set of recipients that this chat message will be displayed to.
   * 
   * The set returned is not guaranteed to be mutable and may auto-populate
   * on access. Any listener accessing the returned set should be aware that
   * it may reduce performance for a lazy set implementation.
   * 
   * Listeners should be aware that modifying the list may throw {@link
   * UnsupportedOperationException} if the event caller provides an
   * unmodifiable set.
   *
   * @return All CommandSenders who will see this chat message
  */
  getRecipients(): Set<CommandSender>;
  /**
   * Gets the cancellation state of this event. A cancelled event will not
   * be executed in the server, but will still pass to other plugins
   *
   * @return true if this event is cancelled
  */
  isCancelled(): boolean;
  /**
   * Sets the cancellation state of this event. A cancelled event will not
   * be executed in the server, but will still pass to other plugins.
   *
   * @param cancel true if you wish to cancel this event
  */
  setCancelled(cancelled: boolean): void;
  getHandlers(): HandlerList;
  static getHandlerList(): HandlerList;
}
export interface BroadcastMessageEvent extends ServerEvent, Cancellable {}
/**
 * Called when a map is initialized.
*/
export class MapInitializeEvent extends ServerEvent {
  constructor(mapView: MapView);
  /**
   * Gets the map initialized in this event.
   *
   * @return Map for this event
  */
  getMap(): MapView;
  getHandlers(): HandlerList;
  static getHandlerList(): HandlerList;
}
/**
 * Called when a plugin is enabled.
*/
export class PluginEnableEvent extends PluginEvent {
  constructor(plugin: Plugin);
  getHandlers(): HandlerList;
  static getHandlerList(): HandlerList;
}
/**
 * Miscellaneous server events
*/
export class ServerEvent extends Event {
  constructor();
  constructor(isAsync: boolean);
}

}
declare module 'org.bukkit.entity.Panda' {
import { Enum } from 'java.lang';
export class Gene extends Enum<Gene> {
  static readonly NORMAL: Gene;
  static readonly LAZY: Gene;
  static readonly WORRIED: Gene;
  static readonly PLAYFUL: Gene;
  static readonly BROWN: Gene;
  static readonly WEAK: Gene;
  static readonly AGGRESSIVE: Gene;
  static valueOf(name: string): Gene;
  static values(): Gene[];
  /**
   * Gets whether this gene is recessive, i.e. required in both parents to
   * propagate to children.
   *
   * @return recessive status
  */
  isRecessive(): boolean;
}

}
declare module 'org.bukkit.plugin.messaging' {
import { Enum, RuntimeException } from 'java.lang';
import { Set, Map } from 'java.util';
import { Plugin } from 'org.bukkit.plugin';
import { Player } from 'org.bukkit.entity';
/**
 * Thrown if a Plugin attempts to send a message on an unregistered channel.
*/
export class ChannelNotRegisteredException extends RuntimeException {
  constructor();
  constructor(channel: string);
}
/**
 * Thrown if a Plugin Channel is too long.
*/
export class ChannelNameTooLongException extends RuntimeException {
  constructor();
  constructor(channel: string);
}
/**
 * A listener for a specific Plugin Channel, which will receive notifications
 * of messages sent from a client.
*/
export class PluginMessageListener {
  /**
   * A method that will be thrown when a PluginMessageSource sends a plugin
   * message on a registered channel.
   *
   * @param channel Channel that the message was sent through.
   * @param player Source of the message.
   * @param message The raw message that was sent.
  */
  onPluginMessageReceived(channel: string, player: Player, message: number[]): void;
}
/**
 * A class responsible for managing the registrations of plugin channels and
 * their listeners.
 *
 * Channel names must contain a colon separator and consist of only [a-z0-9/._-]
 * - i.e. they MUST be valid {@link NamespacedKey}. The "BungeeCord" channel is
 * an exception and may only take this form.
*/
export class Messenger {
  /**
   * Represents the largest size that an individual Plugin Message may be.
  */
  static readonly MAX_MESSAGE_SIZE: number;
  static readonly MAX_CHANNEL_SIZE: number;
  /**
   * Checks if the specified channel is a reserved name.
   * 
   * All channels within the "minecraft" namespace except for
   * "minecraft:brand" are reserved.
   *
   * @param channel Channel name to check.
   * @return True if the channel is reserved, otherwise false.
   * @throws IllegalArgumentException Thrown if channel is null.
  */
  isReservedChannel(channel: string): boolean;
  /**
   * Registers the specific plugin to the requested outgoing plugin channel,
   * allowing it to send messages through that channel to any clients.
   *
   * @param plugin Plugin that wishes to send messages through the channel.
   * @param channel Channel to register.
   * @throws IllegalArgumentException Thrown if plugin or channel is null.
  */
  registerOutgoingPluginChannel(plugin: Plugin, channel: string): void;
  /**
   * Unregisters the specific plugin from the requested outgoing plugin
   * channel, no longer allowing it to send messages through that channel to
   * any clients.
   *
   * @param plugin Plugin that no longer wishes to send messages through the
   *     channel.
   * @param channel Channel to unregister.
   * @throws IllegalArgumentException Thrown if plugin or channel is null.
  */
  unregisterOutgoingPluginChannel(plugin: Plugin, channel: string): void;
  /**
   * Unregisters the specific plugin from all outgoing plugin channels, no
   * longer allowing it to send any plugin messages.
   *
   * @param plugin Plugin that no longer wishes to send plugin messages.
   * @throws IllegalArgumentException Thrown if plugin is null.
  */
  unregisterOutgoingPluginChannel(plugin: Plugin): void;
  /**
   * Registers the specific plugin for listening on the requested incoming
   * plugin channel, allowing it to act upon any plugin messages.
   *
   * @param plugin Plugin that wishes to register to this channel.
   * @param channel Channel to register.
   * @param listener Listener to receive messages on.
   * @return The resulting registration that was made as a result of this
   *     method.
   * @throws IllegalArgumentException Thrown if plugin, channel or listener
   *     is null, or the listener is already registered for this channel.
  */
  registerIncomingPluginChannel(plugin: Plugin, channel: string, listener: PluginMessageListener): PluginMessageListenerRegistration;
  /**
   * Unregisters the specific plugin's listener from listening on the
   * requested incoming plugin channel, no longer allowing it to act upon
   * any plugin messages.
   *
   * @param plugin Plugin that wishes to unregister from this channel.
   * @param channel Channel to unregister.
   * @param listener Listener to stop receiving messages on.
   * @throws IllegalArgumentException Thrown if plugin, channel or listener
   *     is null.
  */
  unregisterIncomingPluginChannel(plugin: Plugin, channel: string, listener: PluginMessageListener): void;
  /**
   * Unregisters the specific plugin from listening on the requested
   * incoming plugin channel, no longer allowing it to act upon any plugin
   * messages.
   *
   * @param plugin Plugin that wishes to unregister from this channel.
   * @param channel Channel to unregister.
   * @throws IllegalArgumentException Thrown if plugin or channel is null.
  */
  unregisterIncomingPluginChannel(plugin: Plugin, channel: string): void;
  /**
   * Unregisters the specific plugin from listening on all plugin channels
   * through all listeners.
   *
   * @param plugin Plugin that wishes to unregister from this channel.
   * @throws IllegalArgumentException Thrown if plugin is null.
  */
  unregisterIncomingPluginChannel(plugin: Plugin): void;
  /**
   * Gets a set containing all the outgoing plugin channels.
   *
   * @return List of all registered outgoing plugin channels.
  */
  getOutgoingChannels(): Set<string>;
  /**
   * Gets a set containing all the outgoing plugin channels that the
   * specified plugin is registered to.
   *
   * @param plugin Plugin to retrieve channels for.
   * @return List of all registered outgoing plugin channels that a plugin
   *     is registered to.
   * @throws IllegalArgumentException Thrown if plugin is null.
  */
  getOutgoingChannels(plugin: Plugin): Set<string>;
  /**
   * Gets a set containing all the incoming plugin channels.
   *
   * @return List of all registered incoming plugin channels.
  */
  getIncomingChannels(): Set<string>;
  /**
   * Gets a set containing all the incoming plugin channels that the
   * specified plugin is registered for.
   *
   * @param plugin Plugin to retrieve channels for.
   * @return List of all registered incoming plugin channels that the plugin
   *     is registered for.
   * @throws IllegalArgumentException Thrown if plugin is null.
  */
  getIncomingChannels(plugin: Plugin): Set<string>;
  /**
   * Gets a set containing all the incoming plugin channel registrations
   * that the specified plugin has.
   *
   * @param plugin Plugin to retrieve registrations for.
   * @return List of all registrations that the plugin has.
   * @throws IllegalArgumentException Thrown if plugin is null.
  */
  getIncomingChannelRegistrations(plugin: Plugin): Set<PluginMessageListenerRegistration>;
  /**
   * Gets a set containing all the incoming plugin channel registrations
   * that are on the requested channel.
   *
   * @param channel Channel to retrieve registrations for.
   * @return List of all registrations that are on the channel.
   * @throws IllegalArgumentException Thrown if channel is null.
  */
  getIncomingChannelRegistrations(channel: string): Set<PluginMessageListenerRegistration>;
  /**
   * Gets a set containing all the incoming plugin channel registrations
   * that the specified plugin has on the requested channel.
   *
   * @param plugin Plugin to retrieve registrations for.
   * @param channel Channel to filter registrations by.
   * @return List of all registrations that the plugin has.
   * @throws IllegalArgumentException Thrown if plugin or channel is null.
  */
  getIncomingChannelRegistrations(plugin: Plugin, channel: string): Set<PluginMessageListenerRegistration>;
  /**
   * Checks if the specified plugin message listener registration is valid.
   * 
   * A registration is considered valid if it has not be unregistered and
   * that the plugin is still enabled.
   *
   * @param registration Registration to check.
   * @return True if the registration is valid, otherwise false.
  */
  isRegistrationValid(registration: PluginMessageListenerRegistration): boolean;
  /**
   * Checks if the specified plugin has registered to receive incoming
   * messages through the requested channel.
   *
   * @param plugin Plugin to check registration for.
   * @param channel Channel to test for.
   * @return True if the channel is registered, else false.
  */
  isIncomingChannelRegistered(plugin: Plugin, channel: string): boolean;
  /**
   * Checks if the specified plugin has registered to send outgoing messages
   * through the requested channel.
   *
   * @param plugin Plugin to check registration for.
   * @param channel Channel to test for.
   * @return True if the channel is registered, else false.
  */
  isOutgoingChannelRegistered(plugin: Plugin, channel: string): boolean;
  /**
   * Dispatches the specified incoming message to any registered listeners.
   *
   * @param source Source of the message.
   * @param channel Channel that the message was sent by.
   * @param message Raw payload of the message.
  */
  dispatchIncomingMessage(source: Player, channel: string, message: number[]): void;
}
/**
 * Represents a possible recipient for a Plugin Message.
*/
export class PluginMessageRecipient {
  /**
   * Sends this recipient a Plugin Message on the specified outgoing
   * channel.
   * 
   * The message may not be larger than {@link Messenger#MAX_MESSAGE_SIZE}
   * bytes, and the plugin must be registered to send messages on the
   * specified channel.
   *
   * @param source The plugin that sent this message.
   * @param channel The channel to send this message on.
   * @param message The raw message to send.
   * @throws IllegalArgumentException Thrown if the source plugin is
   *     disabled.
   * @throws IllegalArgumentException Thrown if source, channel or message
   *     is null.
   * @throws MessageTooLargeException Thrown if the message is too big.
   * @throws ChannelNotRegisteredException Thrown if the channel is not
   *     registered for this plugin.
  */
  sendPluginMessage(source: Plugin, channel: string, message: number[]): void;
  /**
   * Gets a set containing all the Plugin Channels that this client is
   * listening on.
   *
   * @return Set containing all the channels that this client may accept.
  */
  getListeningPluginChannels(): Set<string>;
}
/**
 * Standard implementation to {@link Messenger}
*/
export class StandardMessenger extends Messenger {
  /**
   * Checks if the specified channel is a reserved name.
   * 
   * All channels within the "minecraft" namespace except for
   * "minecraft:brand" are reserved.
   *
   * @param channel Channel name to check.
   * @return True if the channel is reserved, otherwise false.
   * @throws IllegalArgumentException Thrown if channel is null.
  */
  isReservedChannel(channel: string): boolean;
  /**
   * Registers the specific plugin to the requested outgoing plugin channel,
   * allowing it to send messages through that channel to any clients.
   *
   * @param plugin Plugin that wishes to send messages through the channel.
   * @param channel Channel to register.
   * @throws IllegalArgumentException Thrown if plugin or channel is null.
  */
  registerOutgoingPluginChannel(plugin: Plugin, channel: string): void;
  /**
   * Unregisters the specific plugin from the requested outgoing plugin
   * channel, no longer allowing it to send messages through that channel to
   * any clients.
   *
   * @param plugin Plugin that no longer wishes to send messages through the
   *     channel.
   * @param channel Channel to unregister.
   * @throws IllegalArgumentException Thrown if plugin or channel is null.
  */
  unregisterOutgoingPluginChannel(plugin: Plugin, channel: string): void;
  /**
   * Unregisters the specific plugin from the requested outgoing plugin
   * channel, no longer allowing it to send messages through that channel to
   * any clients.
   *
   * @param plugin Plugin that no longer wishes to send messages through the
   *     channel.
   * @param channel Channel to unregister.
   * @throws IllegalArgumentException Thrown if plugin or channel is null.
  */
  unregisterOutgoingPluginChannel(plugin: Plugin): void;
  /**
   * Registers the specific plugin for listening on the requested incoming
   * plugin channel, allowing it to act upon any plugin messages.
   *
   * @param plugin Plugin that wishes to register to this channel.
   * @param channel Channel to register.
   * @param listener Listener to receive messages on.
   * @return The resulting registration that was made as a result of this
   *     method.
   * @throws IllegalArgumentException Thrown if plugin, channel or listener
   *     is null, or the listener is already registered for this channel.
  */
  registerIncomingPluginChannel(plugin: Plugin, channel: string, listener: PluginMessageListener): PluginMessageListenerRegistration;
  /**
   * Unregisters the specific plugin's listener from listening on the
   * requested incoming plugin channel, no longer allowing it to act upon
   * any plugin messages.
   *
   * @param plugin Plugin that wishes to unregister from this channel.
   * @param channel Channel to unregister.
   * @param listener Listener to stop receiving messages on.
   * @throws IllegalArgumentException Thrown if plugin, channel or listener
   *     is null.
  */
  unregisterIncomingPluginChannel(plugin: Plugin, channel: string, listener: PluginMessageListener): void;
  /**
   * Unregisters the specific plugin's listener from listening on the
   * requested incoming plugin channel, no longer allowing it to act upon
   * any plugin messages.
   *
   * @param plugin Plugin that wishes to unregister from this channel.
   * @param channel Channel to unregister.
   * @param listener Listener to stop receiving messages on.
   * @throws IllegalArgumentException Thrown if plugin, channel or listener
   *     is null.
  */
  unregisterIncomingPluginChannel(plugin: Plugin, channel: string): void;
  /**
   * Unregisters the specific plugin's listener from listening on the
   * requested incoming plugin channel, no longer allowing it to act upon
   * any plugin messages.
   *
   * @param plugin Plugin that wishes to unregister from this channel.
   * @param channel Channel to unregister.
   * @param listener Listener to stop receiving messages on.
   * @throws IllegalArgumentException Thrown if plugin, channel or listener
   *     is null.
  */
  unregisterIncomingPluginChannel(plugin: Plugin): void;
  /**
   * Gets a set containing all the outgoing plugin channels.
   *
   * @return List of all registered outgoing plugin channels.
  */
  getOutgoingChannels(): Set<string>;
  /**
   * Gets a set containing all the outgoing plugin channels that the
   * specified plugin is registered to.
   *
   * @param plugin Plugin to retrieve channels for.
   * @return List of all registered outgoing plugin channels that a plugin
   *     is registered to.
   * @throws IllegalArgumentException Thrown if plugin is null.
  */
  getOutgoingChannels(plugin: Plugin): Set<string>;
  /**
   * Gets a set containing all the incoming plugin channels.
   *
   * @return List of all registered incoming plugin channels.
  */
  getIncomingChannels(): Set<string>;
  /**
   * Gets a set containing all the incoming plugin channels that the
   * specified plugin is registered for.
   *
   * @param plugin Plugin to retrieve channels for.
   * @return List of all registered incoming plugin channels that the plugin
   *     is registered for.
   * @throws IllegalArgumentException Thrown if plugin is null.
  */
  getIncomingChannels(plugin: Plugin): Set<string>;
  /**
   * Gets a set containing all the incoming plugin channel registrations
   * that the specified plugin has.
   *
   * @param plugin Plugin to retrieve registrations for.
   * @return List of all registrations that the plugin has.
   * @throws IllegalArgumentException Thrown if plugin is null.
  */
  getIncomingChannelRegistrations(plugin: Plugin): Set<PluginMessageListenerRegistration>;
  /**
   * Gets a set containing all the incoming plugin channel registrations
   * that the specified plugin has.
   *
   * @param plugin Plugin to retrieve registrations for.
   * @return List of all registrations that the plugin has.
   * @throws IllegalArgumentException Thrown if plugin is null.
  */
  getIncomingChannelRegistrations(channel: string): Set<PluginMessageListenerRegistration>;
  /**
   * Gets a set containing all the incoming plugin channel registrations
   * that the specified plugin has.
   *
   * @param plugin Plugin to retrieve registrations for.
   * @return List of all registrations that the plugin has.
   * @throws IllegalArgumentException Thrown if plugin is null.
  */
  getIncomingChannelRegistrations(plugin: Plugin, channel: string): Set<PluginMessageListenerRegistration>;
  /**
   * Checks if the specified plugin message listener registration is valid.
   * 
   * A registration is considered valid if it has not be unregistered and
   * that the plugin is still enabled.
   *
   * @param registration Registration to check.
   * @return True if the registration is valid, otherwise false.
  */
  isRegistrationValid(registration: PluginMessageListenerRegistration): boolean;
  /**
   * Checks if the specified plugin has registered to receive incoming
   * messages through the requested channel.
   *
   * @param plugin Plugin to check registration for.
   * @param channel Channel to test for.
   * @return True if the channel is registered, else false.
  */
  isIncomingChannelRegistered(plugin: Plugin, channel: string): boolean;
  /**
   * Checks if the specified plugin has registered to send outgoing messages
   * through the requested channel.
   *
   * @param plugin Plugin to check registration for.
   * @param channel Channel to test for.
   * @return True if the channel is registered, else false.
  */
  isOutgoingChannelRegistered(plugin: Plugin, channel: string): boolean;
  /**
   * Dispatches the specified incoming message to any registered listeners.
   *
   * @param source Source of the message.
   * @param channel Channel that the message was sent by.
   * @param message Raw payload of the message.
  */
  dispatchIncomingMessage(source: Player, channel: string, message: number[]): void;
  /**
   * Validates a Plugin Channel name.
   *
   * @param channel Channel name to validate.
   * @deprecated not an API method
  */
  static validateChannel(channel: string): void;
  /**
   * Validates and corrects a Plugin Channel name. Method is not reentrant / idempotent.
   *
   * @param channel Channel name to validate.
   * @return corrected channel name
   * @deprecated not an API method
  */
  static validateAndCorrectChannel(channel: string): string;
  /**
   * Validates the input of a Plugin Message, ensuring the arguments are all
   * valid.
   *
   * @param messenger Messenger to use for validation.
   * @param source Source plugin of the Message.
   * @param channel Plugin Channel to send the message by.
   * @param message Raw message payload to send.
   * @throws IllegalArgumentException Thrown if the source plugin is
   *     disabled.
   * @throws IllegalArgumentException Thrown if source, channel or message
   *     is null.
   * @throws MessageTooLargeException Thrown if the message is too big.
   * @throws ChannelNameTooLongException Thrown if the channel name is too
   *     long.
   * @throws ChannelNotRegisteredException Thrown if the channel is not
   *     registered for this plugin.
  */
  static validatePluginMessage(messenger: Messenger, source: Plugin, channel: string, message: number[]): void;
}
/**
 * Thrown if a plugin attempts to register for a reserved channel (such as
 * "REGISTER")
*/
export class ReservedChannelException extends RuntimeException {
  constructor();
  constructor(name: string);
}
/**
 * Thrown if a Plugin Message is sent that is too large to be sent.
*/
export class MessageTooLargeException extends RuntimeException {
  constructor();
  constructor(message: number[]);
  constructor(length: number);
  constructor(msg: string);
}
/**
 * Contains information about a {@link Plugin}s registration to a plugin
 * channel.
*/
export class PluginMessageListenerRegistration {
  constructor(messenger: Messenger, plugin: Plugin, channel: string, listener: PluginMessageListener);
  /**
   * Gets the plugin channel that this registration is about.
   *
   * @return Plugin channel.
  */
  getChannel(): string;
  /**
   * Gets the registered listener described by this registration.
   *
   * @return Registered listener.
  */
  getListener(): PluginMessageListener;
  /**
   * Gets the plugin that this registration is for.
   *
   * @return Registered plugin.
  */
  getPlugin(): Plugin;
  /**
   * Checks if this registration is still valid.
   *
   * @return True if this registration is still valid, otherwise false.
  */
  isValid(): boolean;
  equals(obj: any): boolean;
  hashCode(): number;
}
/**
 * Represents the different directions a plugin channel may go.
*/
export class PluginChannelDirection extends Enum<PluginChannelDirection> {
  /**
   * The plugin channel is being sent to the server from a client.
  */
  static readonly INCOMING: PluginChannelDirection;
  /**
   * The plugin channel is being sent to a client from the server.
  */
  static readonly OUTGOING: PluginChannelDirection;
  static valueOf(name: string): PluginChannelDirection;
  static values(): PluginChannelDirection[];
}

}
declare module 'org.bukkit.entity.Wither' {
import { Enum } from 'java.lang';
/**
 * Represents one of the Wither's heads.
*/
export class Head extends Enum<Head> {
  static readonly CENTER: Head;
  static readonly LEFT: Head;
  static readonly RIGHT: Head;
  static valueOf(name: string): Head;
  static values(): Head[];
}

}
declare module 'org.bukkit.event.world.PortalCreateEvent' {
import { Enum } from 'java.lang';
/**
 * An enum to specify the various reasons for a portal's creation
*/
export class CreateReason extends Enum<CreateReason> {
  /**
   * When the blocks inside a portal are created due to a portal frame
   * being set on fire.
  */
  static readonly FIRE: CreateReason;
  /**
   * When a nether portal frame and portal is created at the exit of an
   * entered nether portal.
  */
  static readonly NETHER_PAIR: CreateReason;
  /**
   * When the target end platform is created as a result of a player
   * entering an end portal.
  */
  static readonly END_PLATFORM: CreateReason;
  static valueOf(name: string): CreateReason;
  static values(): CreateReason[];
}

}
declare module 'org.bukkit.configuration.file' {
import { SafeConstructor } from 'org.yaml.snakeyaml.constructor';
import { List } from 'java.util';
import { LoaderOptions, DumperOptions, Yaml } from 'org.yaml.snakeyaml';
import { Representer } from 'org.yaml.snakeyaml.representer';
import { Reader, File } from 'java.io';
import { MappingNode, Node } from 'org.yaml.snakeyaml.nodes';
import { MemoryConfigurationOptions, Configuration, MemoryConfiguration } from 'org.bukkit.configuration';
/**
 * An implementation of {@link Configuration} which saves all files in Yaml.
 * Note that this implementation is not synchronized.
*/
export class YamlConfiguration extends FileConfiguration {
  constructor();
  saveToString(): string;
  loadFromString(contents: string): void;
  options(): YamlConfigurationOptions;
  /**
   * Creates a new {@link YamlConfiguration}, loading from the given file.
   * 
   * Any errors loading the Configuration will be logged and then ignored.
   * If the specified input is not a valid config, a blank config will be
   * returned.
   * 
   * The encoding used may follow the system dependent default.
   *
   * @param file Input file
   * @return Resulting configuration
   * @throws IllegalArgumentException Thrown if file is null
  */
  static loadConfiguration(file: File): YamlConfiguration;
  /**
   * Creates a new {@link YamlConfiguration}, loading from the given reader.
   * 
   * Any errors loading the Configuration will be logged and then ignored.
   * If the specified input is not a valid config, a blank config will be
   * returned.
   *
   * @param reader input
   * @return resulting configuration
   * @throws IllegalArgumentException Thrown if stream is null
  */
  static loadConfiguration(reader: Reader): YamlConfiguration;
}
/**
 * Various settings for controlling the input and output of a {@link
 * YamlConfiguration}
*/
export class YamlConfigurationOptions extends FileConfigurationOptions {
  configuration(): YamlConfiguration;
  copyDefaults(value: boolean): YamlConfigurationOptions;
  pathSeparator(value: string): YamlConfigurationOptions;
  setHeader(header: string[] | null): void;
  header(value: string | null): YamlConfigurationOptions;
  setFooter(footer: string[] | null);
  parseComments(value: boolean): YamlConfigurationOptions;
  copyHeader(value: boolean): YamlConfigurationOptions;
  /**
   * Gets how much spaces should be used to indent each line.
   * 
   * The minimum value this may be is 2, and the maximum is 9.
   *
   * @return How much to indent by
  */
  indent(): number;
  /**
   * Sets how much spaces should be used to indent each line.
   * 
   * The minimum value this may be is 2, and the maximum is 9.
   *
   * @param value New indent
   * @return This object, for chaining
  */
  indent(value: number): YamlConfigurationOptions;
  /**
   * Gets how long a line can be, before it gets split.
   *
   * @return How the max line width
  */
  width(): number;
  /**
   * Sets how long a line can be, before it gets split.
   *
   * @param value New width
   * @return This object, for chaining
  */
  width(value: number): YamlConfigurationOptions;
  /**
   * Gets the header that will be applied to the top of the saved output.
   * 
   * This header will be commented out and applied directly at the top of
   * the generated output of the {@link FileConfiguration}. It is not
   * required to include a newline at the end of the header as it will
   * automatically be applied, but you may include one if you wish for extra
   * spacing.
   * 
   * If no comments exist, an empty list will be returned. A null entry
   * represents an empty line and an empty String represents an empty comment
   * line.
   *
   * @return Unmodifiable header, every entry represents one line.
  */
  getHeader(): string[];
  /**
   * Gets the footer that will be applied to the bottom of the saved output.
   * 
   * This footer will be commented out and applied directly at the bottom of
   * the generated output of the {@link FileConfiguration}. It is not required
   * to include a newline at the beginning of the footer as it will
   * automatically be applied, but you may include one if you wish for extra
   * spacing.
   * 
   * If no comments exist, an empty list will be returned. A null entry
   * represents an empty line and an empty String represents an empty comment
   * line.
   *
   * @return Unmodifiable footer, every entry represents one line.
  */
  getFooter(): string[];
  /**
   * Gets whether or not comments should be loaded and saved.
   * 
   * Defaults to true.
   *
   * @return Whether or not comments are parsed.
  */
  parseComments(): boolean;
  /**
   * @return Whether or not comments are parsed.
   *
   * @deprecated Call {@link #parseComments()} instead.
  */
  copyHeader(): boolean;
  /**
   * Gets the char that will be used to separate {@link
   * ConfigurationSection}s
   * 
   * This value does not affect how the {@link Configuration} is stored,
   * only in how you access the data. The default value is '.'.
   *
   * @return Path separator
  */
  pathSeparator(): string;
  /**
   * Checks if the {@link Configuration} should copy values from its default
   * {@link Configuration} directly.
   * 
   * If this is true, all values in the default Configuration will be
   * directly copied, making it impossible to distinguish between values
   * that were set and values that are provided by default. As a result,
   * {@link ConfigurationSection#contains(java.lang.String)} will always
   * return the same value as {@link
   * ConfigurationSection#isSet(java.lang.String)}. The default value is
   * false.
   *
   * @return Whether or not defaults are directly copied
  */
  copyDefaults(): boolean;
}
/**
 * Various settings for controlling the input and output of a {@link
 * FileConfiguration}
*/
export class FileConfigurationOptions extends MemoryConfigurationOptions {
  configuration(): FileConfiguration;
  copyDefaults(value: boolean): FileConfigurationOptions;
  pathSeparator(value: string): FileConfigurationOptions;
  /**
   * Gets the header that will be applied to the top of the saved output.
   * 
   * This header will be commented out and applied directly at the top of
   * the generated output of the {@link FileConfiguration}. It is not
   * required to include a newline at the end of the header as it will
   * automatically be applied, but you may include one if you wish for extra
   * spacing.
   * 
   * If no comments exist, an empty list will be returned. A null entry
   * represents an empty line and an empty String represents an empty comment
   * line.
   *
   * @return Unmodifiable header, every entry represents one line.
  */
  getHeader(): string[];
  /**
   * Sets the header that will be applied to the top of the saved output.
   * 
   * This header will be commented out and applied directly at the top of
   * the generated output of the {@link FileConfiguration}. It is not
   * required to include a newline at the end of the header as it will
   * automatically be applied, but you may include one if you wish for extra
   * spacing.
   * 
   * If no comments exist, an empty list will be returned. A null entry
   * represents an empty line and an empty String represents an empty comment
   * line.
   *
   * @param value New header, every entry represents one line.
   * @return This object, for chaining
  */
  setHeader(header: string[] | null): void;
  /**
   * @param value The string header.
   * @return This object, for chaining.
   *
   * @deprecated use setHeader() instead
  */
  header(value: string | null): FileConfigurationOptions;
  /**
   * Gets the footer that will be applied to the bottom of the saved output.
   * 
   * This footer will be commented out and applied directly at the bottom of
   * the generated output of the {@link FileConfiguration}. It is not required
   * to include a newline at the beginning of the footer as it will
   * automatically be applied, but you may include one if you wish for extra
   * spacing.
   * 
   * If no comments exist, an empty list will be returned. A null entry
   * represents an empty line and an empty String represents an empty comment
   * line.
   *
   * @return Unmodifiable footer, every entry represents one line.
  */
  getFooter(): string[];
  /**
   * Sets the footer that will be applied to the bottom of the saved output.
   * 
   * This footer will be commented out and applied directly at the bottom of
   * the generated output of the {@link FileConfiguration}. It is not required
   * to include a newline at the beginning of the footer as it will
   * automatically be applied, but you may include one if you wish for extra
   * spacing.
   * 
   * If no comments exist, an empty list will be returned. A null entry
   * represents an empty line and an empty String represents an empty comment
   * line.
   *
   * @param value New footer, every entry represents one line.
   * @return This object, for chaining
  */
  setFooter(footer: string[] | null);
  /**
   * Gets whether or not comments should be loaded and saved.
   * 
   * Defaults to true.
   *
   * @return Whether or not comments are parsed.
  */
  parseComments(): boolean;
  /**
   * Sets whether or not comments should be loaded and saved.
   * 
   * Defaults to true.
   *
   * @param value Whether or not comments are parsed.
   * @return This object, for chaining
  */
  parseComments(value: boolean): MemoryConfigurationOptions;
  /**
   * @return Whether or not comments are parsed.
   *
   * @deprecated Call {@link #parseComments()} instead.
  */
  copyHeader(): boolean;
  /**
   * @param value Should comments be parsed.
   * @return This object, for chaining
   *
   * @deprecated Call {@link #parseComments(boolean)} instead.
  */
  copyHeader(value: boolean): FileConfigurationOptions;
  /**
   * Gets the char that will be used to separate {@link
   * ConfigurationSection}s
   * 
   * This value does not affect how the {@link Configuration} is stored,
   * only in how you access the data. The default value is '.'.
   *
   * @return Path separator
  */
  pathSeparator(): string;
  /**
   * Checks if the {@link Configuration} should copy values from its default
   * {@link Configuration} directly.
   * 
   * If this is true, all values in the default Configuration will be
   * directly copied, making it impossible to distinguish between values
   * that were set and values that are provided by default. As a result,
   * {@link ConfigurationSection#contains(java.lang.String)} will always
   * return the same value as {@link
   * ConfigurationSection#isSet(java.lang.String)}. The default value is
   * false.
   *
   * @return Whether or not defaults are directly copied
  */
  copyDefaults(): boolean;
}
export class YamlRepresenter extends Representer {
  constructor();
}
export class YamlConstructor extends SafeConstructor {
  constructor();
  flattenMapping(node: MappingNode): void;
  construct(node: Node): any | null;
}
/**
 * This is a base class for all File based implementations of {@link
 * Configuration}
*/
export class FileConfiguration extends MemoryConfiguration {
  /**
   * Creates an empty {@link FileConfiguration} with no default values.
  */
  constructor();
  /**
   * Creates an empty {@link FileConfiguration} using the specified {@link
   * Configuration} as a source for all default values.
   *
   * @param defaults Default value provider
  */
  constructor(defaults: Configuration | null);
  /**
   * Saves this {@link FileConfiguration} to the specified location.
   * 
   * If the file does not exist, it will be created. If already exists, it
   * will be overwritten. If it cannot be overwritten or created, an
   * exception will be thrown.
   * 
   * This method will save using the system default encoding, or possibly
   * using UTF8.
   *
   * @param file File to save to.
   * @throws IOException Thrown when the given file cannot be written to for
   *     any reason.
   * @throws IllegalArgumentException Thrown when file is null.
  */
  save(file: File): void;
  /**
   * Saves this {@link FileConfiguration} to the specified location.
   * 
   * If the file does not exist, it will be created. If already exists, it
   * will be overwritten. If it cannot be overwritten or created, an
   * exception will be thrown.
   * 
   * This method will save using the system default encoding, or possibly
   * using UTF8.
   *
   * @param file File to save to.
   * @throws IOException Thrown when the given file cannot be written to for
   *     any reason.
   * @throws IllegalArgumentException Thrown when file is null.
  */
  save(file: string): void;
  /**
   * Saves this {@link FileConfiguration} to a string, and returns it.
   *
   * @return String containing this configuration.
  */
  saveToString(): string;
  /**
   * Loads this {@link FileConfiguration} from the specified location.
   * 
   * All the values contained within this configuration will be removed,
   * leaving only settings and defaults, and the new values will be loaded
   * from the given file.
   * 
   * If the file cannot be loaded for any reason, an exception will be
   * thrown.
   *
   * @param file File to load from.
   * @throws FileNotFoundException Thrown when the given file cannot be
   *     opened.
   * @throws IOException Thrown when the given file cannot be read.
   * @throws InvalidConfigurationException Thrown when the given file is not
   *     a valid Configuration.
   * @throws IllegalArgumentException Thrown when file is null.
  */
  load(file: File): void;
  /**
   * Loads this {@link FileConfiguration} from the specified reader.
   * 
   * All the values contained within this configuration will be removed,
   * leaving only settings and defaults, and the new values will be loaded
   * from the given stream.
   *
   * @param reader the reader to load from
   * @throws IOException thrown when underlying reader throws an IOException
   * @throws InvalidConfigurationException thrown when the reader does not
   *      represent a valid Configuration
   * @throws IllegalArgumentException thrown when reader is null
  */
  load(reader: Reader): void;
  /**
   * Loads this {@link FileConfiguration} from the specified location.
   * 
   * All the values contained within this configuration will be removed,
   * leaving only settings and defaults, and the new values will be loaded
   * from the given file.
   * 
   * If the file cannot be loaded for any reason, an exception will be
   * thrown.
   *
   * @param file File to load from.
   * @throws FileNotFoundException Thrown when the given file cannot be
   *     opened.
   * @throws IOException Thrown when the given file cannot be read.
   * @throws InvalidConfigurationException Thrown when the given file is not
   *     a valid Configuration.
   * @throws IllegalArgumentException Thrown when file is null.
  */
  load(file: string): void;
  /**
   * Loads this {@link FileConfiguration} from the specified string, as
   * opposed to from file.
   * 
   * All the values contained within this configuration will be removed,
   * leaving only settings and defaults, and the new values will be loaded
   * from the given string.
   * 
   * If the string is invalid in any way, an exception will be thrown.
   *
   * @param contents Contents of a Configuration to load.
   * @throws InvalidConfigurationException Thrown if the specified string is
   *     invalid.
   * @throws IllegalArgumentException Thrown if contents is null.
  */
  loadFromString(contents: string): void;
  options(): FileConfigurationOptions;
}

}
declare module 'org.bukkit.event.entity' {
import { Collection, List, Map } from 'java.util';
import { UnleashReason } from 'org.bukkit.event.entity.EntityUnleashEvent';
import { TargetReason } from 'org.bukkit.event.entity.EntityTargetEvent';
import { PowerCause } from 'org.bukkit.event.entity.CreeperPowerEvent';
import { MerchantRecipe, EquipmentSlot, ItemStack } from 'org.bukkit.inventory';
import { SoundCategory, Material, Sound, DyeColor, PortalType, Location } from 'org.bukkit';
import { PotionEffect, PotionEffectType } from 'org.bukkit.potion';
import { TransformReason } from 'org.bukkit.event.entity.EntityTransformEvent';
import { BlockState, BlockFace, Block, CreatureSpawner } from 'org.bukkit.block';
import { HandlerList, Cancellable, Event } from 'org.bukkit.event';
import { DamageModifier, DamageCause } from 'org.bukkit.event.entity.EntityDamageEvent';
import { Entity, AbstractHorse, Creeper, LivingEntity, Item, Explosive, EnderDragon, Strider, Spellcaster, Pose, Piglin, Villager, HumanEntity, ThrownPotion, AbstractVillager, LightningStrike, Player, Slime, AreaEffectCloud, Projectile, Pig, EntityType, Animals, Bat, Firework, PigZombie, AnimalTamer, Sheep, ThrownExpBottle } from 'org.bukkit.entity';
import { Component } from 'net.kyori.adventure.text';
import { ExhaustionReason } from 'org.bukkit.event.entity.EntityExhaustionEvent';
import { Function } from 'com.google.common.base';
import { SpawnReason } from 'org.bukkit.event.entity.CreatureSpawnEvent';
import { Spell } from 'org.bukkit.entity.Spellcaster';
import { RegainReason } from 'org.bukkit.event.entity.EntityRegainHealthEvent';
import { ChangeReason } from 'org.bukkit.event.entity.VillagerCareerChangeEvent';
import { EntityZapEvent } from 'com.destroystokyo.paper.event.entity';
import { Action, Cause } from 'org.bukkit.event.entity.EntityPotionEffectEvent';
import { EntityDyeEvent } from 'io.papermc.paper.event.entity';
import { Profession } from 'org.bukkit.entity.Villager';
import { Vector } from 'org.bukkit.util';
import { Phase } from 'org.bukkit.entity.EnderDragon';
import { BlockData } from 'org.bukkit.block.data';
/**
 * Called when an entity is spawned into a world.
 * 
 * If an Entity Spawn event is cancelled, the entity will not spawn.
*/
export class EntitySpawnEvent extends EntityEvent {
  constructor(spawnee: Entity);
  /**
   * Gets the cancellation state of this event. A cancelled event will not
   * be executed in the server, but will still pass to other plugins
   *
   * @return true if this event is cancelled
  */
  isCancelled(): boolean;
  /**
   * Sets the cancellation state of this event. A cancelled event will not
   * be executed in the server, but will still pass to other plugins.
   *
   * @param cancel true if you wish to cancel this event
  */
  setCancelled(cancel: boolean): void;
  /**
   * Gets the location at which the entity is spawning.
   *
   * @return The location at which the entity is spawning
  */
  getLocation(): Location;
  getHandlers(): HandlerList;
  static getHandlerList(): HandlerList;
}
export interface EntitySpawnEvent extends EntityEvent, Cancellable {}
/**
 * Thrown when a LivingEntity is tamed
*/
export class EntityTameEvent extends EntityEvent {
  constructor(entity: LivingEntity, owner: AnimalTamer);
  getEntity(): LivingEntity;
  /**
   * Gets the cancellation state of this event. A cancelled event will not
   * be executed in the server, but will still pass to other plugins
   *
   * @return true if this event is cancelled
  */
  isCancelled(): boolean;
  /**
   * Sets the cancellation state of this event. A cancelled event will not
   * be executed in the server, but will still pass to other plugins.
   *
   * @param cancel true if you wish to cancel this event
  */
  setCancelled(cancel: boolean): void;
  /**
   * Gets the owning AnimalTamer
   *
   * @return the owning AnimalTamer
  */
  getOwner(): AnimalTamer;
  getHandlers(): HandlerList;
  static getHandlerList(): HandlerList;
}
export interface EntityTameEvent extends EntityEvent, Cancellable {}
/**
 * Called when an entity has made a decision to explode.
*/
export class ExplosionPrimeEvent extends EntityEvent {
  constructor(what: Entity, radius: number, fire: boolean);
  constructor(explosive: Explosive);
  /**
   * Gets the cancellation state of this event. A cancelled event will not
   * be executed in the server, but will still pass to other plugins
   *
   * @return true if this event is cancelled
  */
  isCancelled(): boolean;
  /**
   * Sets the cancellation state of this event. A cancelled event will not
   * be executed in the server, but will still pass to other plugins.
   *
   * @param cancel true if you wish to cancel this event
  */
  setCancelled(cancel: boolean): void;
  /**
   * Gets the radius of the explosion
   *
   * @return returns the radius of the explosion
  */
  getRadius(): number;
  /**
   * Sets the radius of the explosion
   *
   * @param radius the radius of the explosion
  */
  setRadius(radius: number);
  /**
   * Gets whether this explosion will create fire or not
   *
   * @return true if this explosion will create fire
  */
  getFire(): boolean;
  /**
   * Sets whether this explosion will create fire or not
   *
   * @param fire true if you want this explosion to create fire
  */
  setFire(fire: boolean): void;
  getHandlers(): HandlerList;
  static getHandlerList(): HandlerList;
}
export interface ExplosionPrimeEvent extends EntityEvent, Cancellable {}
/**
 * Called when a block causes an entity to combust.
*/
export class EntityCombustByBlockEvent extends EntityCombustEvent {
  constructor(combuster: Block | null, combustee: Entity, duration: number);
  /**
   * The combuster can be lava or a block that is on fire.
   * 
   * WARNING: block may be null.
   *
   * @return the Block that set the combustee alight.
  */
  getCombuster(): Block | null;
}
/**
 * Called when one Entity breeds with another Entity.
*/
export class EntityBreedEvent extends EntityEvent {
  constructor(child: LivingEntity, mother: LivingEntity, father: LivingEntity, breeder: LivingEntity | null, bredWith: ItemStack | null, experience: number);
  getEntity(): LivingEntity;
  /**
   * Gets the parent creating this entity.
   *
   * @return The "birth" parent
  */
  getMother(): LivingEntity;
  /**
   * Gets the other parent of the newly born entity.
   *
   * @return the other parent
  */
  getFather(): LivingEntity;
  /**
   * Gets the Entity responsible for breeding. Breeder is null for spontaneous
   * conception.
   *
   * @return The Entity who initiated breeding.
  */
  getBreeder(): LivingEntity | null;
  /**
   * The ItemStack that was used to initiate breeding, if present.
   *
   * @return ItemStack used to initiate breeding.
  */
  getBredWith(): ItemStack | null;
  /**
   * Get the amount of experience granted by breeding.
   *
   * @return experience amount
  */
  getExperience(): number;
  /**
   * Set the amount of experience granted by breeding.
   *
   * @param experience experience amount
  */
  setExperience(experience: number);
  /**
   * Gets the cancellation state of this event. A cancelled event will not
   * be executed in the server, but will still pass to other plugins
   *
   * @return true if this event is cancelled
  */
  isCancelled(): boolean;
  /**
   * Sets the cancellation state of this event. A cancelled event will not
   * be executed in the server, but will still pass to other plugins.
   *
   * @param cancel true if you wish to cancel this event
  */
  setCancelled(cancel: boolean): void;
  getHandlers(): HandlerList;
  static getHandlerList(): HandlerList;
}
export interface EntityBreedEvent extends EntityEvent, Cancellable {}
/**
 * Called when a Pig Zombie is angered by another entity.
 * 
 * If the event is cancelled, the pig zombie will not be angered.
*/
export class PigZombieAngerEvent extends EntityEvent {
  constructor(pigZombie: PigZombie, target: Entity | null, newAnger: number);
  /**
   * Gets the entity (if any) which triggered this anger update.
   *
   * @return triggering entity, or null
  */
  getTarget(): Entity | null;
  /**
   * Gets the new anger resulting from this event.
   *
   * @return new anger
   * @see PigZombie#getAnger()
  */
  getNewAnger(): number;
  /**
   * Sets the new anger resulting from this event.
   *
   * @param newAnger the new anger
   * @see PigZombie#setAnger(int)
  */
  setNewAnger(newAnger: number);
  getEntity(): PigZombie;
  /**
   * Gets the cancellation state of this event. A cancelled event will not
   * be executed in the server, but will still pass to other plugins
   *
   * @return true if this event is cancelled
  */
  isCancelled(): boolean;
  /**
   * Sets the cancellation state of this event. A cancelled event will not
   * be executed in the server, but will still pass to other plugins.
   *
   * @param cancel true if you wish to cancel this event
  */
  setCancelled(cancel: boolean): void;
  getHandlers(): HandlerList;
  static getHandlerList(): HandlerList;
}
export interface PigZombieAngerEvent extends EntityEvent, Cancellable {}
/**
 * Called immediately prior to an entity being unleashed.
 * 
 * Cancelling this event when either:
 * 
 *     the leashed entity dies,
 *     the entity changes dimension, or
 *     the client has disconnected the leash
 * 
 * will have no effect.
*/
export class EntityUnleashEvent extends EntityEvent {
  constructor(entity: Entity, reason: UnleashReason);
  constructor(entity: Entity, reason: UnleashReason, dropLeash: boolean);
  /**
   * Returns the reason for the unleashing.
   *
   * @return The reason
  */
  getReason(): UnleashReason;
  /**
   * Returns whether a leash item will be dropped.
   *
   * @return Whether the leash item will be dropped
  */
  isDropLeash(): boolean;
  /**
   * Sets whether a leash item should be dropped.
   *
   * @param dropLeash Whether the leash item should be dropped
  */
  setDropLeash(dropLeash: boolean): void;
  /**
   * Gets the cancellation state of this event. A cancelled event will not
   * be executed in the server, but will still pass to other plugins
   *
   * @return true if this event is cancelled
  */
  isCancelled(): boolean;
  /**
   * Sets the cancellation state of this event. A cancelled event will not
   * be executed in the server, but will still pass to other plugins.
   *
   * @param cancel true if you wish to cancel this event
  */
  setCancelled(cancel: boolean): void;
  getHandlers(): HandlerList;
  static getHandlerList(): HandlerList;
}
export interface EntityUnleashEvent extends EntityEvent, Cancellable {}
/**
 * Called when a Slime splits into smaller Slimes upon death
*/
export class SlimeSplitEvent extends EntityEvent {
  constructor(slime: Slime, count: number);
  /**
   * Gets the cancellation state of this event. A cancelled event will not
   * be executed in the server, but will still pass to other plugins
   *
   * @return true if this event is cancelled
  */
  isCancelled(): boolean;
  /**
   * Sets the cancellation state of this event. A cancelled event will not
   * be executed in the server, but will still pass to other plugins.
   *
   * @param cancel true if you wish to cancel this event
  */
  setCancelled(cancel: boolean): void;
  getEntity(): Slime;
  /**
   * Gets the amount of smaller slimes to spawn
   *
   * @return the amount of slimes to spawn
  */
  getCount(): number;
  /**
   * Sets how many smaller slimes will spawn on the split
   *
   * @param count the amount of slimes to spawn
  */
  setCount(count: number);
  getHandlers(): HandlerList;
  static getHandlerList(): HandlerList;
}
export interface SlimeSplitEvent extends EntityEvent, Cancellable {}
/**
 * Triggered when a entity is created in the world by a player "placing" an item
 * on a block.
 * 
 * Note that this event is currently only fired for four specific placements:
 * armor stands, boats, minecarts, and end crystals.
*/
export class EntityPlaceEvent extends EntityEvent {
  constructor(entity: Entity, player: Player | null, block: Block, blockFace: BlockFace);
  /**
   * Returns the player placing the entity
   *
   * @return the player placing the entity
  */
  getPlayer(): Player | null;
  /**
   * Returns the block that the entity was placed on
   *
   * @return the block that the entity was placed on
  */
  getBlock(): Block;
  /**
   * Returns the face of the block that the entity was placed on
   *
   * @return the face of the block that the entity was placed on
  */
  getBlockFace(): BlockFace;
  /**
   * Gets the cancellation state of this event. A cancelled event will not
   * be executed in the server, but will still pass to other plugins
   *
   * @return true if this event is cancelled
  */
  isCancelled(): boolean;
  /**
   * Sets the cancellation state of this event. A cancelled event will not
   * be executed in the server, but will still pass to other plugins.
   *
   * @param cancel true if you wish to cancel this event
  */
  setCancelled(cancel: boolean): void;
  getHandlers(): HandlerList;
  static getHandlerList(): HandlerList;
}
export interface EntityPlaceEvent extends EntityEvent, Cancellable {}
/**
 * Called when a non-player entity is about to teleport because it is in
 * contact with a portal.
 * 
 * For players see {@link org.bukkit.event.player.PlayerPortalEvent}
*/
export class EntityPortalEvent extends EntityTeleportEvent {
  constructor(entity: Entity, from: Location, to: Location | null);
  constructor(entity: Entity, from: Location, to: Location | null, searchRadius: number);
  /**
   * Set the Block radius to search in for available portals.
   *
   * @param searchRadius the radius in which to search for a portal from the
   * location
  */
  setSearchRadius(searchRadius: number);
  /**
   * Gets the search radius value for finding an available portal.
   *
   * @return the currently set search radius
  */
  getSearchRadius(): number;
  getHandlers(): HandlerList;
  static getHandlerList(): HandlerList;
}
/**
 * Thrown when an entity creates an item drop.
*/
export class EntityDropItemEvent extends EntityEvent {
  constructor(entity: Entity, drop: Item);
  /**
   * Gets the Item created by the entity
   *
   * @return Item created by the entity
  */
  getItemDrop(): Item;
  /**
   * Gets the cancellation state of this event. A cancelled event will not
   * be executed in the server, but will still pass to other plugins
   *
   * @return true if this event is cancelled
  */
  isCancelled(): boolean;
  /**
   * Sets the cancellation state of this event. A cancelled event will not
   * be executed in the server, but will still pass to other plugins.
   *
   * @param cancel true if you wish to cancel this event
  */
  setCancelled(cancel: boolean): void;
  getHandlers(): HandlerList;
  static getHandlerList(): HandlerList;
}
export interface EntityDropItemEvent extends EntityEvent, Cancellable {}
/**
 * Called when an EnderDragon switches controller phase.
*/
export class EnderDragonChangePhaseEvent extends EntityEvent {
  constructor(enderDragon: EnderDragon, currentPhase: Phase | null, newPhase: Phase);
  getEntity(): EnderDragon;
  /**
   * Gets the current phase that the dragon is in. This method will return null
   * when a dragon is first spawned and hasn't yet been assigned a phase.
   *
   * @return the current dragon phase
  */
  getCurrentPhase(): Phase | null;
  /**
   * Gets the new phase that the dragon will switch to.
   *
   * @return the new dragon phase
  */
  getNewPhase(): Phase;
  /**
   * Sets the new phase for the ender dragon.
   *
   * @param newPhase the new dragon phase
  */
  setNewPhase(newPhase: Phase);
  /**
   * Gets the cancellation state of this event. A cancelled event will not
   * be executed in the server, but will still pass to other plugins
   *
   * @return true if this event is cancelled
  */
  isCancelled(): boolean;
  /**
   * Sets the cancellation state of this event. A cancelled event will not
   * be executed in the server, but will still pass to other plugins.
   *
   * @param cancel true if you wish to cancel this event
  */
  setCancelled(cancel: boolean): void;
  getHandlers(): HandlerList;
  static getHandlerList(): HandlerList;
}
export interface EnderDragonChangePhaseEvent extends EntityEvent, Cancellable {}
/**
 * Called when a {@link Strider}'s temperature has changed as a result of
 * entering or exiting blocks it considers warm.
*/
export class StriderTemperatureChangeEvent extends EntityEvent {
  constructor(what: Strider, shivering: boolean);
  getEntity(): Strider;
  /**
   * Get the Strider's new shivering state.
   *
   * @return the new shivering state
  */
  isShivering(): boolean;
  /**
   * Gets the cancellation state of this event. A cancelled event will not
   * be executed in the server, but will still pass to other plugins
   *
   * @return true if this event is cancelled
  */
  isCancelled(): boolean;
  /**
   * Sets the cancellation state of this event. A cancelled event will not
   * be executed in the server, but will still pass to other plugins.
   *
   * @param cancel true if you wish to cancel this event
  */
  setCancelled(cancelled: boolean): void;
  getHandlers(): HandlerList;
  static getHandlerList(): HandlerList;
}
export interface StriderTemperatureChangeEvent extends EntityEvent, Cancellable {}
/**
 * Called when a ThrownExpBottle hits and releases experience.
*/
export class ExpBottleEvent extends ProjectileHitEvent {
  constructor(bottle: ThrownExpBottle, exp: number);
  getEntity(): ThrownExpBottle;
  /**
   * This method indicates if the particle effect should be shown.
   *
   * @return true if the effect will be shown, false otherwise
  */
  getShowEffect(): boolean;
  /**
   * This method sets if the particle effect will be shown.
   * 
   * This does not change the experience created.
   *
   * @param showEffect true indicates the effect will be shown, false
   *     indicates no effect will be shown
  */
  setShowEffect(showEffect: boolean): void;
  /**
   * This method retrieves the amount of experience to be created.
   * 
   * The number indicates a total amount to be divided into orbs.
   *
   * @return the total amount of experience to be created
  */
  getExperience(): number;
  /**
   * This method sets the amount of experience to be created.
   * 
   * The number indicates a total amount to be divided into orbs.
   *
   * @param exp the total amount of experience to be created
  */
  setExperience(experience: number);
  getHandlers(): HandlerList;
  static getHandlerList(): HandlerList;
}
/**
 * Thrown whenever a {@link Player} dies
*/
export class PlayerDeathEvent extends EntityDeathEvent {
  constructor(player: Player, drops: ItemStack[], droppedExp: number, adventure$deathMessage: Component | null);
  constructor(player: Player, drops: ItemStack[], droppedExp: number, newExp: number, adventure$deathMessage: Component | null, deathMessage: string | null);
  constructor(player: Player, drops: ItemStack[], droppedExp: number, newExp: number, newTotalExp: number, newLevel: number, adventure$deathMessage: Component | null, deathMessage: string | null);
  constructor(player: Player, drops: ItemStack[], droppedExp: number, newExp: number, newTotalExp: number, newLevel: number, adventure$deathMessage: Component | null, deathMessage: string | null, doExpDrop: boolean);
  constructor(player: Player, drops: ItemStack[], droppedExp: number, deathMessage: string | null);
  constructor(player: Player, drops: ItemStack[], droppedExp: number, newExp: number, deathMessage: string | null);
  constructor(player: Player, drops: ItemStack[], droppedExp: number, newExp: number, newTotalExp: number, newLevel: number, deathMessage: string | null);
  constructor(player: Player, drops: ItemStack[], droppedExp: number, newExp: number, newTotalExp: number, newLevel: number, deathMessage: string | null, doExpDrop: boolean);
  /**
   * A mutable collection to add items that the player should retain in their inventory on death (Similar to KeepInventory game rule)
   *
   * You MUST remove the item from the .getDrops() collection too or it will duplicate!
   * `     *    {@literal @EventHandler(ignoreCancelled = true)`
   *     public void onPlayerDeath(PlayerDeathEvent event) {
   *         for (Iterator iterator = event.getDrops().iterator(); iterator.hasNext(); ) {
   *             ItemStack drop = iterator.next();
   *             List lore = drop.getLore();
   *             if (lore != null && !lore.isEmpty()) {
   *                 if (lore.get(0).contains("(SOULBOUND)")) {
   *                     iterator.remove();
   *                     event.getItemsToKeep().add(drop);
   *                 }
   *             }
   *         }
   *     }
   * }
   *
   * Adding an item to this list that the player did not previously have will give them the item on death.
   * An example case could be a "Note" that "You died at X/Y/Z coordinates"
   *
   * @return The list to hold items to keep
  */
  getItemsToKeep(): ItemStack[];
  /**
   * @return should experience be dropped from this death
  */
  shouldDropExperience(): boolean;
  /**
   * @param doExpDrop sets if experience should be dropped from this death
  */
  setShouldDropExperience(doExpDrop: boolean): void;
  getEntity(): Player;
  /**
   * Clarity method for getting the player. Not really needed except
   * for reasons of clarity.
   * 
   * @return Player who is involved in this event
  */
  getPlayer(): Player;
  /**
   * Set the death message that will appear to everyone on the server.
   *
   * @param deathMessage Message to appear to other players on the server.
  */
  deathMessage(deathMessage: Component | null): void;
  /**
   * Get the death message that will appear to everyone on the server.
   *
   * @return Message to appear to other players on the server.
  */
  deathMessage(): Component | null;
  /**
   * Set the death message that will appear to everyone on the server.
   *
   * @param deathMessage Message to appear to other players on the server.
   * @deprecated in favour of {@link #deathMessage(net.kyori.adventure.text.Component)}
  */
  setDeathMessage(deathMessage: string | null): void;
  /**
   * Gets how much EXP the Player should have at respawn.
   * 
   * This does not indicate how much EXP should be dropped, please see
   * {@link #getDroppedExp()} for that.
   *
   * @return New EXP of the respawned player
  */
  getNewExp(): number;
  /**
   * Sets how much EXP the Player should have at respawn.
   * 
   * This does not indicate how much EXP should be dropped, please see
   * {@link #setDroppedExp(int)} for that.
   *
   * @param exp New EXP of the respawned player
  */
  setNewExp(newExp: number);
  /**
   * Gets the Level the Player should have at respawn.
   *
   * @return New Level of the respawned player
  */
  getNewLevel(): number;
  /**
   * Sets the Level the Player should have at respawn.
   *
   * @param level New Level of the respawned player
  */
  setNewLevel(newLevel: number);
  /**
   * Gets the Total EXP the Player should have at respawn.
   *
   * @return New Total EXP of the respawned player
  */
  getNewTotalExp(): number;
  /**
   * Sets the Total EXP the Player should have at respawn.
   *
   * @param totalExp New Total EXP of the respawned player
  */
  setNewTotalExp(newTotalExp: number);
  /**
   * Gets if the Player should keep all EXP at respawn.
   * 
   * This flag overrides other EXP settings
   *
   * @return True if Player should keep all pre-death exp
  */
  getKeepLevel(): boolean;
  /**
   * Sets if the Player should keep all EXP at respawn.
   * 
   * This overrides all other EXP settings
   * 
   * This doesn't prevent the EXP from dropping.
   * {@link #setDroppedExp(int)} should be used stop the
   * EXP from dropping.
   *
   * @param keepLevel True to keep all current value levels
  */
  setKeepLevel(keepLevel: boolean): void;
  /**
   * Sets if the Player keeps inventory on death.
   * 
   * This doesn't prevent the items from dropping.
   * `getDrops().clear()` should be used stop the
   * items from dropping.
   *
   * @param keepInventory True to keep the inventory
  */
  setKeepInventory(keepInventory: boolean): void;
  /**
   * Gets if the Player keeps inventory on death.
   *
   * @return True if the player keeps inventory on death
  */
  getKeepInventory(): boolean;
}
/**
 * Thrown when a entity picks an item up from the ground
*/
export class EntityPickupItemEvent extends EntityEvent {
  constructor(entity: LivingEntity, item: Item, remaining: number);
  getEntity(): LivingEntity;
  /**
   * Gets the Item picked up by the entity.
   *
   * @return Item
  */
  getItem(): Item;
  /**
   * Gets the amount remaining on the ground, if any
   *
   * @return amount remaining on the ground
  */
  getRemaining(): number;
  /**
   * Gets the cancellation state of this event. A cancelled event will not
   * be executed in the server, but will still pass to other plugins
   *
   * @return true if this event is cancelled
  */
  isCancelled(): boolean;
  /**
   * Sets the cancellation state of this event. A cancelled event will not
   * be executed in the server, but will still pass to other plugins.
   *
   * @param cancel true if you wish to cancel this event
  */
  setCancelled(cancel: boolean): void;
  getHandlers(): HandlerList;
  static getHandlerList(): HandlerList;
}
export interface EntityPickupItemEvent extends EntityEvent, Cancellable {}
/**
 * Called when a sheep regrows its wool
*/
export class SheepRegrowWoolEvent extends EntityEvent {
  constructor(sheep: Sheep);
  /**
   * Gets the cancellation state of this event. A cancelled event will not
   * be executed in the server, but will still pass to other plugins
   *
   * @return true if this event is cancelled
  */
  isCancelled(): boolean;
  /**
   * Sets the cancellation state of this event. A cancelled event will not
   * be executed in the server, but will still pass to other plugins.
   *
   * @param cancel true if you wish to cancel this event
  */
  setCancelled(cancel: boolean): void;
  getEntity(): Sheep;
  getHandlers(): HandlerList;
  static getHandlerList(): HandlerList;
}
export interface SheepRegrowWoolEvent extends EntityEvent, Cancellable {}
/**
 * Called when a human entity's food level changes
*/
export class FoodLevelChangeEvent extends EntityEvent {
  constructor(what: HumanEntity, level: number);
  constructor(what: HumanEntity, level: number, item: ItemStack | null);
  getEntity(): HumanEntity;
  /**
   * Gets the item that triggered this event, if any.
   *
   * @return an ItemStack for the item being consumed
  */
  getItem(): ItemStack | null;
  /**
   * Gets the resultant food level that the entity involved in this event
   * should be set to.
   * 
   * Where 20 is a full food bar and 0 is an empty one.
   *
   * @return The resultant food level
  */
  getFoodLevel(): number;
  /**
   * Sets the resultant food level that the entity involved in this event
   * should be set to
   *
   * @param level the resultant food level that the entity involved in this
   *     event should be set to
  */
  setFoodLevel(foodLevel: number);
  /**
   * Gets the cancellation state of this event. A cancelled event will not
   * be executed in the server, but will still pass to other plugins
   *
   * @return true if this event is cancelled
  */
  isCancelled(): boolean;
  /**
   * Sets the cancellation state of this event. A cancelled event will not
   * be executed in the server, but will still pass to other plugins.
   *
   * @param cancel true if you wish to cancel this event
  */
  setCancelled(cancel: boolean): void;
  getHandlers(): HandlerList;
  static getHandlerList(): HandlerList;
}
export interface FoodLevelChangeEvent extends EntityEvent, Cancellable {}
/**
 * Called when a human entity experiences exhaustion.
 *
 * An exhaustion level greater than 4.0 causes a decrease in saturation by 1.
*/
export class EntityExhaustionEvent extends EntityEvent {
  constructor(who: HumanEntity, exhaustionReason: ExhaustionReason, exhaustion: number);
  /**
   * Gets the {@link ExhaustionReason} for this event
   *
   * @return the exhaustion reason
  */
  getExhaustionReason(): ExhaustionReason;
  /**
   * Get the amount of exhaustion to add to the player's current exhaustion.
   *
   * @return amount of exhaustion
  */
  getExhaustion(): number;
  /**
   * Set the exhaustion to apply to the player.
   *
   * The maximum exhaustion that a player can have is 40. No error will be
   * thrown if this limit is hit. This value may be negative, but there is
   * unknown behavior for when exhaustion is below 0.
   *
   * @param exhaustion new exhaustion to add
  */
  setExhaustion(exhaustion: number);
  getEntity(): HumanEntity;
  /**
   * Gets the cancellation state of this event. A cancelled event will not
   * be executed in the server, but will still pass to other plugins
   *
   * @return true if this event is cancelled
  */
  isCancelled(): boolean;
  /**
   * Sets the cancellation state of this event. A cancelled event will not
   * be executed in the server, but will still pass to other plugins.
   *
   * @param cancel true if you wish to cancel this event
  */
  setCancelled(cancel: boolean): void;
  getHandlers(): HandlerList;
  static getHandlerList(): HandlerList;
}
export interface EntityExhaustionEvent extends EntityEvent, Cancellable {}
/**
 * Called when a Creeper is struck by lightning.
 * 
 * If a Creeper Power event is cancelled, the Creeper will not be powered.
*/
export class CreeperPowerEvent extends EntityEvent {
  constructor(creeper: Creeper, bolt: LightningStrike, cause: PowerCause);
  constructor(creeper: Creeper, cause: PowerCause);
  /**
   * Gets the cancellation state of this event. A cancelled event will not
   * be executed in the server, but will still pass to other plugins
   *
   * @return true if this event is cancelled
  */
  isCancelled(): boolean;
  /**
   * Sets the cancellation state of this event. A cancelled event will not
   * be executed in the server, but will still pass to other plugins.
   *
   * @param cancel true if you wish to cancel this event
  */
  setCancelled(cancel: boolean): void;
  getEntity(): Creeper;
  /**
   * Gets the lightning bolt which is striking the Creeper.
   *
   * @return The Entity for the lightning bolt which is striking the Creeper
  */
  getLightning(): LightningStrike | null;
  /**
   * Gets the cause of the creeper being (un)powered.
   *
   * @return A PowerCause value detailing the cause of change in power.
  */
  getCause(): PowerCause;
  getHandlers(): HandlerList;
  static getHandlerList(): HandlerList;
}
export interface CreeperPowerEvent extends EntityEvent, Cancellable {}
/**
 * Called when a LivingEntity shoots a bow firing an arrow
*/
export class EntityShootBowEvent extends EntityEvent {
  setConsumeArrow(consumeArrow: boolean): void;
  getConsumeArrow(): boolean;
  getArrowItem(): ItemStack;
  constructor(shooter: LivingEntity, bow: ItemStack | null, projectile: Entity, force: number);
  constructor(shooter: LivingEntity, bow: ItemStack | null, arrowItem: ItemStack, projectile: Entity, force: number);
  constructor(shooter: LivingEntity, bow: ItemStack | null, consumable: ItemStack | null, projectile: Entity, hand: EquipmentSlot, force: number, consumeItem: boolean);
  getEntity(): LivingEntity;
  /**
   * Gets the bow ItemStack used to fire the arrow.
   *
   * @return the bow involved in this event
  */
  getBow(): ItemStack | null;
  /**
   * Get the ItemStack to be consumed in this event (if any).
   *
   * For instance, bows will consume an arrow ItemStack in a player's
   * inventory.
   *
   * @return the consumable item
  */
  getConsumable(): ItemStack | null;
  /**
   * Gets the projectile which will be launched by this event
   *
   * @return the launched projectile
  */
  getProjectile(): Entity;
  /**
   * Replaces the projectile which will be launched
   *
   * @param projectile the new projectile
  */
  setProjectile(projectile: Entity);
  /**
   * Get the hand from which the bow was shot.
   *
   * @return the hand
  */
  getHand(): EquipmentSlot;
  /**
   * Gets the force the arrow was launched with
   *
   * @return bow shooting force, up to 1.0
  */
  getForce(): number;
  /**
   * Set whether or not the consumable item should be consumed in this event.
   *
   * If set to false, it is recommended that a call to
   * {@link Player#updateInventory()} is made as the client may disagree with
   * the server's decision to not consume a consumable item.
   * 
   * This value is ignored for entities where items are not required
   * (skeletons, pillagers, etc.) or with crossbows (as no item is being
   * consumed).
   *
   * @param consumeItem whether or not to consume the item
  */
  setConsumeItem(consumeItem: boolean): void;
  /**
   * Get whether or not the consumable item should be consumed in this event.
   *
   * @return true if consumed, false otherwise
  */
  shouldConsumeItem(): boolean;
  /**
   * Gets the cancellation state of this event. A cancelled event will not
   * be executed in the server, but will still pass to other plugins
   *
   * @return true if this event is cancelled
  */
  isCancelled(): boolean;
  /**
   * Sets the cancellation state of this event. A cancelled event will not
   * be executed in the server, but will still pass to other plugins.
   *
   * @param cancel true if you wish to cancel this event
  */
  setCancelled(cancel: boolean): void;
  getHandlers(): HandlerList;
  static getHandlerList(): HandlerList;
}
export interface EntityShootBowEvent extends EntityEvent, Cancellable {}
/**
 * Called when an entity combusts.
 * 
 * If an Entity Combust event is cancelled, the entity will not combust.
*/
export class EntityCombustEvent extends EntityEvent {
  constructor(combustee: Entity, duration: number);
  /**
   * Gets the cancellation state of this event. A cancelled event will not
   * be executed in the server, but will still pass to other plugins
   *
   * @return true if this event is cancelled
  */
  isCancelled(): boolean;
  /**
   * Sets the cancellation state of this event. A cancelled event will not
   * be executed in the server, but will still pass to other plugins.
   *
   * @param cancel true if you wish to cancel this event
  */
  setCancelled(cancel: boolean): void;
  /**
   * @return the amount of time (in seconds) the combustee should be alight
   *     for
  */
  getDuration(): number;
  /**
   * The number of seconds the combustee should be alight for.
   * 
   * This value will only ever increase the combustion time, not decrease
   * existing combustion times.
   *
   * @param duration the time in seconds to be alight for.
  */
  setDuration(duration: number);
  getHandlers(): HandlerList;
  static getHandlerList(): HandlerList;
}
export interface EntityCombustEvent extends EntityEvent, Cancellable {}
/**
 * Called when a projectile hits an object
*/
export class ProjectileHitEvent extends EntityEvent {
  constructor(projectile: Projectile);
  constructor(projectile: Projectile, hitEntity: Entity | null);
  constructor(projectile: Projectile, hitBlock: Block | null);
  constructor(projectile: Projectile, hitEntity: Entity | null, hitBlock: Block | null);
  constructor(projectile: Projectile, hitEntity: Entity | null, hitBlock: Block | null, hitFace: BlockFace | null);
  getEntity(): Projectile;
  /**
   * Gets the block that was hit, if it was a block that was hit.
   *
   * @return hit block or else null
  */
  getHitBlock(): Block | null;
  /**
   * Gets the block face that was hit, if it was a block that was hit and the
   * face was provided in the vent.
   *
   * @return hit face or else null
  */
  getHitBlockFace(): BlockFace | null;
  /**
   * Gets the entity that was hit, if it was an entity that was hit.
   *
   * @return hit entity or else null
  */
  getHitEntity(): Entity | null;
  /**
   * Gets the cancellation state of this event. A cancelled event will not
   * be executed in the server, but will still pass to other plugins
   *
   * @return true if this event is cancelled
  */
  isCancelled(): boolean;
  /**
   * Whether to cancel the action that occurs when the projectile hits.
   *
   * In the case of an entity, it will not collide (unless it's a firework,
   * then use {@link FireworkExplodeEvent}).
   * 
   * In the case of a block, some blocks (eg target block, bell) will not
   * perform the action associated.
   * 
   * This does NOT prevent block collisions, and explosions will still occur
   * unless their respective events are cancelled.
   *
   * @param cancel true if you wish to cancel this event
  */
  setCancelled(cancel: boolean): void;
  getHandlers(): HandlerList;
  static getHandlerList(): HandlerList;
}
export interface ProjectileHitEvent extends EntityEvent, Cancellable {}
/**
 * Called when an entity explodes
*/
export class EntityExplodeEvent extends EntityEvent {
  constructor(what: Entity, location: Location, blocks: Block[], yield: number);
  /**
   * Gets the cancellation state of this event. A cancelled event will not
   * be executed in the server, but will still pass to other plugins
   *
   * @return true if this event is cancelled
  */
  isCancelled(): boolean;
  /**
   * Sets the cancellation state of this event. A cancelled event will not
   * be executed in the server, but will still pass to other plugins.
   *
   * @param cancel true if you wish to cancel this event
  */
  setCancelled(cancel: boolean): void;
  /**
   * Returns the list of blocks that would have been removed or were removed
   * from the explosion event.
   *
   * @return All blown-up blocks
  */
  blockList(): Block[];
  /**
   * Returns the location where the explosion happened.
   * 
   * It is not possible to get this value from the Entity as the Entity no
   * longer exists in the world.
   *
   * @return The location of the explosion
  */
  getLocation(): Location;
  /**
   * Returns the percentage of blocks to drop from this explosion
   *
   * @return The yield.
  */
  getYield(): number;
  /**
   * Sets the percentage of blocks to drop from this explosion
   *
   * @param yield The new yield percentage
  */
  setYield(yield: number);
  getHandlers(): HandlerList;
  static getHandlerList(): HandlerList;
}
export interface EntityExplodeEvent extends EntityEvent, Cancellable {}
/**
 * Stores all data related to the bartering interaction with a piglin.
 *
 * This event can be triggered by a piglin picking up an item that's on its
 * bartering list.
*/
export class PiglinBarterEvent extends EntityEvent {
  constructor(what: Piglin, input: ItemStack, outcome: ItemStack[]);
  getEntity(): Piglin;
  /**
   * Gets the input of the barter.
   *
   * @return The item that was used to barter with
  */
  getInput(): ItemStack;
  /**
   * Returns a mutable list representing the outcome of the barter.
   *
   * @return A mutable list of the item the player will receive
  */
  getOutcome(): ItemStack[];
  /**
   * Gets the cancellation state of this event. A cancelled event will not
   * be executed in the server, but will still pass to other plugins
   *
   * @return true if this event is cancelled
  */
  isCancelled(): boolean;
  /**
   * Sets the cancellation state of this event. A cancelled event will not
   * be executed in the server, but will still pass to other plugins.
   *
   * @param cancel true if you wish to cancel this event
  */
  setCancelled(cancel: boolean): void;
  getHandlers(): HandlerList;
  static getHandlerList(): HandlerList;
}
export interface PiglinBarterEvent extends EntityEvent, Cancellable {}
/**
 * Called when an entity is damaged by an entity
*/
export class EntityDamageByEntityEvent extends EntityDamageEvent {
  constructor(damager: Entity, damagee: Entity, cause: DamageCause, damage: number);
  constructor(damager: Entity, damagee: Entity, cause: DamageCause, modifiers: Map<DamageModifier, number>, modifierFunctions: Map<DamageModifier, Function<any, number>>);
  constructor(damager: Entity, damagee: Entity, cause: DamageCause, modifiers: Map<DamageModifier, number>, modifierFunctions: Map<DamageModifier, Function<any, number>>, critical: boolean);
  /**
   * Shows this damage instance was critical.
   * The damage instance can be critical if the attacking player met the respective conditions.
   * Furthermore arrows may also cause a critical damage event if the arrow {@link org.bukkit.entity.AbstractArrow#isCritical()}.
   *
   * @return if the hit was critical.
   * @see https://minecraft.fandom.com/wiki/Damage#Critical_hit
  */
  isCritical(): boolean;
  /**
   * Returns the entity that damaged the defender.
   *
   * @return Entity that damaged the defender.
  */
  getDamager(): Entity;
}
/**
 * Called when a creature is spawned into a world.
 * 
 * If a Creature Spawn event is cancelled, the creature will not spawn.
*/
export class CreatureSpawnEvent extends EntitySpawnEvent {
  constructor(spawnee: LivingEntity, spawnReason: SpawnReason);
  getEntity(): LivingEntity;
  /**
   * Gets the reason for why the creature is being spawned.
   *
   * @return A SpawnReason value detailing the reason for the creature being
   *     spawned
  */
  getSpawnReason(): SpawnReason;
}
/**
 * Thrown whenever a LivingEntity dies
*/
export class EntityDeathEvent extends EntityEvent {
  constructor(entity: LivingEntity, drops: ItemStack[]);
  constructor(what: LivingEntity, drops: ItemStack[], droppedExp: number);
  getEntity(): LivingEntity;
  /**
   * Gets how much EXP should be dropped from this death.
   * 
   * This does not indicate how much EXP should be taken from the entity in
   * question, merely how much should be created after its death.
   *
   * @return Amount of EXP to drop.
  */
  getDroppedExp(): number;
  /**
   * Sets how much EXP should be dropped from this death.
   * 
   * This does not indicate how much EXP should be taken from the entity in
   * question, merely how much should be created after its death.
   *
   * @param exp Amount of EXP to drop.
  */
  setDroppedExp(droppedExp: number);
  /**
   * Gets all the items which will drop when the entity dies
   *
   * @return Items to drop when the entity dies
  */
  getDrops(): ItemStack[];
  getHandlers(): HandlerList;
  static getHandlerList(): HandlerList;
  /**
   * Gets the cancellation state of this event. A cancelled event will not
   * be executed in the server, but will still pass to other plugins
   *
   * @return true if this event is cancelled
  */
  isCancelled(): boolean;
  /**
   * Sets the cancellation state of this event. A cancelled event will not
   * be executed in the server, but will still pass to other plugins.
   *
   * @param cancel true if you wish to cancel this event
  */
  setCancelled(cancel: boolean): void;
  /**
   * Get the amount of health that the entity should revive with after cancelling the event.
   * Set to the entity's max health by default.
   *
   * @return The amount of health
  */
  getReviveHealth(): number;
  /**
   * Set the amount of health that the entity should revive with after cancelling the event.
   * Revive health value must be between 0 (exclusive) and the entity's max health (inclusive).
   *
   * @param reviveHealth The amount of health
   * @throws IllegalArgumentException Thrown if the health is {@literal <= 0 or >} max health
  */
  setReviveHealth(reviveHealth: number);
  /**
   * Whether or not the death sound should play when the entity dies. If the event is cancelled it does not play!
   *
   * @return Whether or not the death sound should play. Event is called with this set to false if the entity is silent.
  */
  shouldPlayDeathSound(): boolean;
  /**
   * Set whether or not the death sound should play when the entity dies. If the event is cancelled it does not play!
   *
   * @param playDeathSound Enable or disable the death sound
  */
  setShouldPlayDeathSound(playDeathSound: boolean): void;
  /**
   * Get the sound that the entity makes when dying
   *
   * @return The sound that the entity makes
  */
  getDeathSound(): Sound | null;
  /**
   * Set the sound that the entity makes when dying
   *
   * @param sound The sound that the entity should make when dying
  */
  setDeathSound(deathSound: Sound | null);
  /**
   * Get the sound category that the death sound should play in
   *
   * @return The sound category
  */
  getDeathSoundCategory(): SoundCategory | null;
  /**
   * Set the sound category that the death sound should play in.
   *
   * @param soundCategory The sound category
  */
  setDeathSoundCategory(deathSoundCategory: SoundCategory | null);
  /**
   * Get the volume that the death sound will play at.
   *
   * @return The volume the death sound will play at
  */
  getDeathSoundVolume(): number;
  /**
   * Set the volume the death sound should play at. If the event is cancelled this will not play the sound!
   *
   * @param volume The volume the death sound should play at
  */
  setDeathSoundVolume(deathSoundVolume: number);
  /**
   * Get the pitch that the death sound will play with.
   *
   * @return The pitch the death sound will play with
  */
  getDeathSoundPitch(): number;
  /**
   * GSetet the pitch that the death sound should play with.
   *
   * @param pitch The pitch the death sound should play with
  */
  setDeathSoundPitch(deathSoundPitch: number);
}
export interface EntityDeathEvent extends EntityEvent, Cancellable {}
/**
 * Called when a potion effect is modified on an entity.
 * 
 * If the event is cancelled, no change will be made on the entity.
*/
export class EntityPotionEffectEvent extends EntityEvent {
  constructor(livingEntity: LivingEntity, oldEffect: PotionEffect | null, newEffect: PotionEffect | null, cause: Cause, action: Action, override: boolean);
  /**
   * Gets the old potion effect of the changed type, which will be removed.
   *
   * @return The old potion effect or null if the entity did not have the
   * changed effect type.
  */
  getOldEffect(): PotionEffect | null;
  /**
   * Gets new potion effect of the changed type to be applied.
   *
   * @return The new potion effect or null if the effect of the changed type
   * will be removed.
  */
  getNewEffect(): PotionEffect | null;
  /**
   * Gets the cause why the effect has changed.
   *
   * @return A Cause value why the effect has changed.
  */
  getCause(): Cause;
  /**
   * Gets the action which will be performed on the potion effect type.
   *
   * @return An action to be performed on the potion effect type.
  */
  getAction(): Action;
  /**
   * Gets the modified potion effect type.
   *
   * @return The effect type which will be modified on the entity.
  */
  getModifiedType(): PotionEffectType;
  /**
   * Returns if the new potion effect will override the old potion effect
   * (Only applicable for the CHANGED Action).
   *
   * @return If the new effect will override the old one.
  */
  isOverride(): boolean;
  /**
   * Sets if the new potion effect will override the old potion effect (Only
   * applicable for the CHANGED action).
   *
   * @param override If the new effect will override the old one.
  */
  setOverride(override: boolean): void;
  /**
   * Gets the cancellation state of this event. A cancelled event will not
   * be executed in the server, but will still pass to other plugins
   *
   * @return true if this event is cancelled
  */
  isCancelled(): boolean;
  /**
   * Sets the cancellation state of this event. A cancelled event will not
   * be executed in the server, but will still pass to other plugins.
   *
   * @param cancel true if you wish to cancel this event
  */
  setCancelled(cancel: boolean): void;
  getHandlers(): HandlerList;
  static getHandlerList(): HandlerList;
}
export interface EntityPotionEffectEvent extends EntityEvent, Cancellable {}
/**
 * Called when an {@link Entity} breaks a door
 * 
 * Cancelling the event will cause the event to be delayed
*/
export class EntityBreakDoorEvent extends EntityChangeBlockEvent {
  constructor(entity: LivingEntity, targetBlock: Block);
  getEntity(): LivingEntity;
}
/**
 * Represents an Entity-related event
*/
export class EntityEvent extends Event {
  constructor(what: Entity);
  /**
   * Returns the Entity involved in this event
   *
   * @return Entity who is involved in this event
  */
  getEntity(): Entity;
  /**
   * Gets the EntityType of the Entity involved in this event.
   *
   * @return EntityType of the Entity involved in this event
  */
  getEntityType(): EntityType;
}
/**
 * Called when an entity dies and may have the opportunity to be resurrected.
 * Will be called in a cancelled state if the entity does not have a totem
 * equipped.
*/
export class EntityResurrectEvent extends EntityEvent {
  constructor(what: LivingEntity);
  getEntity(): LivingEntity;
  /**
   * Gets the cancellation state of this event. A cancelled event will not
   * be executed in the server, but will still pass to other plugins
   *
   * @return true if this event is cancelled
  */
  isCancelled(): boolean;
  /**
   * Sets the cancellation state of this event. A cancelled event will not
   * be executed in the server, but will still pass to other plugins.
   *
   * @param cancel true if you wish to cancel this event
  */
  setCancelled(cancelled: boolean): void;
  getHandlers(): HandlerList;
  static getHandlerList(): HandlerList;
}
export interface EntityResurrectEvent extends EntityEvent, Cancellable {}
/**
 * Called when a splash potion hits an area
*/
export class LingeringPotionSplashEvent extends ProjectileHitEvent {
  constructor(potion: ThrownPotion, entity: AreaEffectCloud);
  getEntity(): ThrownPotion;
  /**
   * Gets the AreaEffectCloud spawned
   *
   * @return The spawned AreaEffectCloud
  */
  getAreaEffectCloud(): AreaEffectCloud;
  /**
   * Gets the cancellation state of this event. A cancelled event will not
   * be executed in the server, but will still pass to other plugins
   *
   * @return true if this event is cancelled
  */
  isCancelled(): boolean;
  /**
   * Sets the cancellation state of this event. A cancelled event will not
   * be executed in the server, but will still pass to other plugins.
   *
   * @param cancel true if you wish to cancel this event
  */
  setCancelled(cancel: boolean): void;
  getHandlers(): HandlerList;
  static getHandlerList(): HandlerList;
}
export interface LingeringPotionSplashEvent extends ProjectileHitEvent, Cancellable {}
/**
 * Called when a lingering potion applies it's effects. Happens
 * once every 5 ticks
*/
export class AreaEffectCloudApplyEvent extends EntityEvent {
  constructor(entity: AreaEffectCloud, affectedEntities: LivingEntity[]);
  /**
   * Gets the cancellation state of this event. A cancelled event will not
   * be executed in the server, but will still pass to other plugins
   *
   * @return true if this event is cancelled
  */
  isCancelled(): boolean;
  /**
   * Sets the cancellation state of this event. A cancelled event will not
   * be executed in the server, but will still pass to other plugins.
   *
   * @param cancel true if you wish to cancel this event
  */
  setCancelled(cancel: boolean): void;
  getEntity(): AreaEffectCloud;
  /**
   * Retrieves a mutable list of the effected entities
   * 
   * It is important to note that not every entity in this list
   * is guaranteed to be effected.  The cloud may die during the
   * application of its effects due to the depletion of {@link AreaEffectCloud#getDurationOnUse()}
   * or {@link AreaEffectCloud#getRadiusOnUse()}
   *
   * @return the affected entity list
  */
  getAffectedEntities(): LivingEntity[];
  getHandlers(): HandlerList;
  static getHandlerList(): HandlerList;
}
export interface AreaEffectCloudApplyEvent extends EntityEvent, Cancellable {}
/**
 * Called when a sheep's wool is dyed
*/
export class SheepDyeWoolEvent extends EntityDyeEvent {
  constructor(sheep: Sheep, color: DyeColor);
  constructor(sheep: Sheep, color: DyeColor, player: Player | null);
  getEntity(): Sheep;
}
export interface SheepDyeWoolEvent extends EntityDyeEvent, Cancellable {}
/**
 * Called when an {@link Entity} enters a block and is stored in that block.
 * 
 * This event is called for bees entering a bee hive.
 * 
 * It is not called when a silverfish "enters" a stone block. For that listen to
 * the {@link EntityChangeBlockEvent}.
*/
export class EntityEnterBlockEvent extends EntityEvent {
  constructor(entity: Entity, block: Block);
  /**
   * Get the block the entity will enter.
   *
   * @return the block
  */
  getBlock(): Block;
  /**
   * Gets the cancellation state of this event. A cancelled event will not
   * be executed in the server, but will still pass to other plugins
   *
   * @return true if this event is cancelled
  */
  isCancelled(): boolean;
  /**
   * Sets the cancellation state of this event. A cancelled event will not
   * be executed in the server, but will still pass to other plugins.
   *
   * @param cancel true if you wish to cancel this event
  */
  setCancelled(cancel: boolean): void;
  getHandlers(): HandlerList;
  static getHandlerList(): HandlerList;
}
export interface EntityEnterBlockEvent extends EntityEvent, Cancellable {}
export class ItemMergeEvent extends EntityEvent {
  constructor(item: Item, target: Item);
  /**
   * Gets the cancellation state of this event. A cancelled event will not
   * be executed in the server, but will still pass to other plugins
   *
   * @return true if this event is cancelled
  */
  isCancelled(): boolean;
  /**
   * Sets the cancellation state of this event. A cancelled event will not
   * be executed in the server, but will still pass to other plugins.
   *
   * @param cancel true if you wish to cancel this event
  */
  setCancelled(cancelled: boolean): void;
  getEntity(): Item;
  /**
   * Gets the Item entity the main Item is being merged into.
   *
   * @return The Item being merged with
  */
  getTarget(): Item;
  getHandlers(): HandlerList;
  static getHandlerList(): HandlerList;
}
export interface ItemMergeEvent extends EntityEvent, Cancellable {}
/**
 * Called when an entity is damaged by a block
*/
export class EntityDamageByBlockEvent extends EntityDamageEvent {
  constructor(damager: Block | null, damagee: Entity, cause: DamageCause, damage: number);
  constructor(damager: Block | null, damagee: Entity, cause: DamageCause, modifiers: Map<DamageModifier, number>, modifierFunctions: Map<DamageModifier, Function<any, number>>);
  /**
   * Returns the block that damaged the player.
   *
   * @return Block that damaged the player
  */
  getDamager(): Block | null;
}
/**
 * Called when an entity enters love mode.
 * 
 * This can be cancelled but the item will still be consumed that was used to
 * make the entity enter into love mode.
*/
export class EntityEnterLoveModeEvent extends EntityEvent {
  constructor(animalInLove: Animals, humanEntity: HumanEntity | null, ticksInLove: number);
  /**
   * Gets the animal that is entering love mode.
   *
   * @return The animal that is entering love mode
  */
  getEntity(): Animals;
  /**
   * Gets the Human Entity that caused the animal to enter love mode.
   *
   * @return The Human entity that caused the animal to enter love mode, or
   * null if there wasn't one.
  */
  getHumanEntity(): HumanEntity | null;
  /**
   * Gets the amount of ticks that the animal will fall in love for.
   *
   * @return The amount of ticks that the animal will fall in love for
  */
  getTicksInLove(): number;
  /**
   * Sets the amount of ticks that the animal will fall in love for.
   *
   * @param ticksInLove The amount of ticks that the animal will fall in love
   * for
  */
  setTicksInLove(ticksInLove: number);
  /**
   * Gets the cancellation state of this event. A cancelled event will not
   * be executed in the server, but will still pass to other plugins
   *
   * @return true if this event is cancelled
  */
  isCancelled(): boolean;
  /**
   * Sets the cancellation state of this event. A cancelled event will not
   * be executed in the server, but will still pass to other plugins.
   *
   * @param cancel true if you wish to cancel this event
  */
  setCancelled(cancel: boolean): void;
  getHandlers(): HandlerList;
  static getHandlerList(): HandlerList;
}
export interface EntityEnterLoveModeEvent extends EntityEvent, Cancellable {}
/**
 * Called when an Entity targets a {@link LivingEntity} and can only target
 * LivingEntity's.
*/
export class EntityTargetLivingEntityEvent extends EntityTargetEvent {
  constructor(entity: Entity, target: LivingEntity | null, reason: TargetReason | null);
  getTarget(): LivingEntity | null;
  /**
   * Set the Entity that you want the mob to target.
   * 
   * It is possible to be null, null will cause the entity to be
   * target-less.
   * 
   * Must be a LivingEntity, or null.
   *
   * @param target The entity to target
  */
  setTarget(target: Entity | null);
}
/**
 * This event is called when a {@link org.bukkit.entity.Item} is removed from
 * the world because it has existed for 5 minutes.
 * 
 * Cancelling the event results in the item being allowed to exist for 5 more
 * minutes. This behavior is not guaranteed and may change in future versions.
*/
export class ItemDespawnEvent extends EntityEvent {
  constructor(despawnee: Item, loc: Location);
  /**
   * Gets the cancellation state of this event. A cancelled event will not
   * be executed in the server, but will still pass to other plugins
   *
   * @return true if this event is cancelled
  */
  isCancelled(): boolean;
  /**
   * Sets the cancellation state of this event. A cancelled event will not
   * be executed in the server, but will still pass to other plugins.
   *
   * @param cancel true if you wish to cancel this event
  */
  setCancelled(cancel: boolean): void;
  getEntity(): Item;
  /**
   * Gets the location at which the item is despawning.
   *
   * @return The location at which the item is despawning
  */
  getLocation(): Location;
  getHandlers(): HandlerList;
  static getHandlerList(): HandlerList;
}
export interface ItemDespawnEvent extends EntityEvent, Cancellable {}
/**
 * Called when a {@link Spellcaster} casts a spell.
*/
export class EntitySpellCastEvent extends EntityEvent {
  constructor(what: Spellcaster, spell: Spell);
  getEntity(): Spellcaster;
  /**
   * Get the spell to be cast in this event.
   *
   * This is a convenience method equivalent to
   * {@link Spellcaster#getSpell()}.
   *
   * @return the spell to cast
  */
  getSpell(): Spell;
  /**
   * Sets the cancellation state of this event. A cancelled event will not
   * be executed in the server, but will still pass to other plugins.
   *
   * @param cancel true if you wish to cancel this event
  */
  setCancelled(cancelled: boolean): void;
  /**
   * Gets the cancellation state of this event. A cancelled event will not
   * be executed in the server, but will still pass to other plugins
   *
   * @return true if this event is cancelled
  */
  isCancelled(): boolean;
  getHandlers(): HandlerList;
  static getHandlerList(): HandlerList;
}
export interface EntitySpellCastEvent extends EntityEvent, Cancellable {}
/**
 * Called when a horse jumps.
*/
export class HorseJumpEvent extends EntityEvent {
  constructor(horse: AbstractHorse, power: number);
  /**
   * Gets the cancellation state of this event. A cancelled event will not
   * be executed in the server, but will still pass to other plugins
   *
   * @return true if this event is cancelled
  */
  isCancelled(): boolean;
  /**
   * @deprecated horse jumping was moved client side.
  */
  setCancelled(cancel: boolean): void;
  getEntity(): AbstractHorse;
  /**
   * Gets the power of the jump.
   * 
   * Power is a value that defines how much of the horse's jump strength
   * should be used for the jump. Power is effectively multiplied times
   * the horse's jump strength to determine how high the jump is; 0
   * represents no jump strength while 1 represents full jump strength.
   * Setting power to a value above 1 will use additional jump strength
   * that the horse does not usually have.
   * 
   * Power does not affect how high the horse is capable of jumping, only
   * how much of its jumping capability will be used in this jump. To set
   * the horse's overall jump strength, see {@link
   * AbstractHorse#setJumpStrength(double)}.
   *
   * @return jump strength
  */
  getPower(): number;
  /**
   * Sets the power of the jump.
   * 
   * Jump power can be set to a value above 1.0 which will increase the
   * strength of this jump above the horse's actual jump strength.
   * 
   * Setting the jump power to 0 will result in the jump animation still
   * playing, but the horse not leaving the ground. Only canceling this
   * event will result in no jump animation at all.
   *
   * @param power power of the jump
   * @deprecated horse jumping was moved client side.
  */
  setPower(power: number);
  getHandlers(): HandlerList;
  static getHandlerList(): HandlerList;
}
export interface HorseJumpEvent extends EntityEvent, Cancellable {}
/**
 * Thrown when a Living Entity creates a portal in a world.
 *
 * @deprecated Use {@link PortalCreateEvent}
*/
export class EntityCreatePortalEvent extends EntityEvent {
  constructor(what: LivingEntity, blocks: BlockState[], type: PortalType);
  getEntity(): LivingEntity;
  /**
   * Gets a list of all blocks associated with the portal.
   *
   * @return List of blocks that will be changed.
  */
  getBlocks(): BlockState[];
  /**
   * Gets the cancellation state of this event. A cancelled event will not
   * be executed in the server, but will still pass to other plugins
   *
   * @return true if this event is cancelled
  */
  isCancelled(): boolean;
  /**
   * Sets the cancellation state of this event. A cancelled event will not
   * be executed in the server, but will still pass to other plugins.
   *
   * @param cancel true if you wish to cancel this event
  */
  setCancelled(cancel: boolean): void;
  /**
   * Gets the type of portal that is trying to be created.
   *
   * @return Type of portal.
  */
  getPortalType(): PortalType;
  getHandlers(): HandlerList;
  static getHandlerList(): HandlerList;
}
export interface EntityCreatePortalEvent extends EntityEvent, Cancellable {}
/**
 * Called when a projectile is launched.
*/
export class ProjectileLaunchEvent extends EntitySpawnEvent {
  constructor(what: Entity);
  /**
   * Gets the cancellation state of this event. A cancelled event will not
   * be executed in the server, but will still pass to other plugins
   *
   * @return true if this event is cancelled
  */
  isCancelled(): boolean;
  /**
   * Sets the cancellation state of this event. A cancelled event will not
   * be executed in the server, but will still pass to other plugins.
   *
   * @param cancel true if you wish to cancel this event
  */
  setCancelled(cancel: boolean): void;
  getEntity(): Projectile;
}
export interface ProjectileLaunchEvent extends EntitySpawnEvent, Cancellable {}
/**
 * Called when a splash potion hits an area
*/
export class PotionSplashEvent extends ProjectileHitEvent {
  constructor(potion: ThrownPotion, affectedEntities: Map<LivingEntity, number>);
  getEntity(): ThrownPotion;
  /**
   * Gets the potion which caused this event
   *
   * @return The thrown potion entity
  */
  getPotion(): ThrownPotion;
  /**
   * Retrieves a list of all effected entities
   *
   * @return A fresh copy of the affected entity list
  */
  getAffectedEntities(): Collection<LivingEntity>;
  /**
   * Gets the intensity of the potion's effects for given entity; This
   * depends on the distance to the impact center
   *
   * @param entity Which entity to get intensity for
   * @return intensity relative to maximum effect; 0.0: not affected; 1.0:
   *     fully hit by potion effects
  */
  getIntensity(entity: LivingEntity): number;
  /**
   * Overwrites the intensity for a given entity
   *
   * @param entity For which entity to define a new intensity
   * @param intensity relative to maximum effect
  */
  setIntensity(entity: LivingEntity, intensity: number): void;
  /**
   * Gets the cancellation state of this event. A cancelled event will not
   * be executed in the server, but will still pass to other plugins
   *
   * @return true if this event is cancelled
  */
  isCancelled(): boolean;
  /**
   * Sets the cancellation state of this event. A cancelled event will not
   * be executed in the server, but will still pass to other plugins.
   *
   * @param cancel true if you wish to cancel this event
  */
  setCancelled(cancel: boolean): void;
  getHandlers(): HandlerList;
  static getHandlerList(): HandlerList;
}
export interface PotionSplashEvent extends ProjectileHitEvent, Cancellable {}
/**
 * Called when an entity comes into contact with a portal
*/
export class EntityPortalEnterEvent extends EntityEvent {
  constructor(entity: Entity, location: Location);
  /**
   * Gets the portal block the entity is touching
   *
   * @return The portal block the entity is touching
  */
  getLocation(): Location;
  getHandlers(): HandlerList;
  static getHandlerList(): HandlerList;
}
/**
 * Called when a creature targets or untargets another entity
*/
export class EntityTargetEvent extends EntityEvent {
  constructor(entity: Entity, target: Entity | null, reason: TargetReason);
  /**
   * Gets the cancellation state of this event. A cancelled event will not
   * be executed in the server, but will still pass to other plugins
   *
   * @return true if this event is cancelled
  */
  isCancelled(): boolean;
  /**
   * Sets the cancellation state of this event. A cancelled event will not
   * be executed in the server, but will still pass to other plugins.
   *
   * @param cancel true if you wish to cancel this event
  */
  setCancelled(cancel: boolean): void;
  /**
   * Returns the reason for the targeting
   *
   * @return The reason
  */
  getReason(): TargetReason;
  /**
   * Get the entity that this is targeting.
   * 
   * This will be null in the case that the event is called when the mob
   * forgets its target.
   *
   * @return The entity
  */
  getTarget(): Entity | null;
  /**
   * Set the entity that you want the mob to target instead.
   * 
   * It is possible to be null, null will cause the entity to be
   * target-less.
   * 
   * This is different from cancelling the event. Cancelling the event will
   * cause the entity to keep an original target, while setting to be null
   * will cause the entity to be reset.
   *
   * @param target The entity to target
  */
  setTarget(target: Entity | null);
  getHandlers(): HandlerList;
  static getHandlerList(): HandlerList;
}
export interface EntityTargetEvent extends EntityEvent, Cancellable {}
/**
 * Called when an entity interacts with an object
*/
export class EntityInteractEvent extends EntityEvent {
  constructor(entity: Entity, block: Block);
  /**
   * Gets the cancellation state of this event. A cancelled event will not
   * be executed in the server, but will still pass to other plugins
   *
   * @return true if this event is cancelled
  */
  isCancelled(): boolean;
  /**
   * Sets the cancellation state of this event. A cancelled event will not
   * be executed in the server, but will still pass to other plugins.
   *
   * @param cancel true if you wish to cancel this event
  */
  setCancelled(cancel: boolean): void;
  /**
   * Returns the involved block
   *
   * @return the block clicked with this item.
  */
  getBlock(): Block;
  getHandlers(): HandlerList;
  static getHandlerList(): HandlerList;
}
export interface EntityInteractEvent extends EntityEvent, Cancellable {}
/**
 * Called whenever a villager acquires a new trade.
*/
export class VillagerAcquireTradeEvent extends EntityEvent {
  constructor(what: AbstractVillager, recipe: MerchantRecipe);
  /**
   * Get the recipe to be acquired.
   *
   * @return the new recipe
  */
  getRecipe(): MerchantRecipe;
  /**
   * Set the recipe to be acquired.
   *
   * @param recipe the new recipe
  */
  setRecipe(recipe: MerchantRecipe);
  /**
   * Gets the cancellation state of this event. A cancelled event will not
   * be executed in the server, but will still pass to other plugins
   *
   * @return true if this event is cancelled
  */
  isCancelled(): boolean;
  /**
   * Sets the cancellation state of this event. A cancelled event will not
   * be executed in the server, but will still pass to other plugins.
   *
   * @param cancel true if you wish to cancel this event
  */
  setCancelled(cancel: boolean): void;
  getEntity(): AbstractVillager;
  getHandlers(): HandlerList;
  static getHandlerList(): HandlerList;
}
export interface VillagerAcquireTradeEvent extends EntityEvent, Cancellable {}
/**
 * Called when a {@link Villager} is about to restock one of its trades.
 * 
 * If this event passes, the villager will reset the
 * {@link MerchantRecipe#getUses() uses} of the affected {@link #getRecipe()
 * MerchantRecipe} to 0.
*/
export class VillagerReplenishTradeEvent extends EntityEvent {
  constructor(what: AbstractVillager, recipe: MerchantRecipe);
  /**
   * Get the recipe to replenish.
   *
   * @return the replenished recipe
  */
  getRecipe(): MerchantRecipe;
  /**
   * Set the recipe to replenish.
   *
   * @param recipe the replenished recipe
  */
  setRecipe(recipe: MerchantRecipe);
  /**
   * Get the bonus uses added.
   *
   * @return the extra uses added
   * @deprecated MC 1.14 has changed how villagers restock their trades. Use
   * {@link MerchantRecipe#getUses()}.
  */
  getBonus(): number;
  /**
   * Set the bonus uses added.
   *
   * @param bonus the extra uses added
   * @deprecated MC 1.14 has changed how villagers restock their trades. This
   * has no effect anymore.
  */
  setBonus(bonus: number);
  /**
   * Gets the cancellation state of this event. A cancelled event will not
   * be executed in the server, but will still pass to other plugins
   *
   * @return true if this event is cancelled
  */
  isCancelled(): boolean;
  /**
   * Sets the cancellation state of this event. A cancelled event will not
   * be executed in the server, but will still pass to other plugins.
   *
   * @param cancel true if you wish to cancel this event
  */
  setCancelled(cancel: boolean): void;
  getEntity(): AbstractVillager;
  getHandlers(): HandlerList;
  static getHandlerList(): HandlerList;
}
export interface VillagerReplenishTradeEvent extends EntityEvent, Cancellable {}
/**
 * Called when an item is spawned into a world
*/
export class ItemSpawnEvent extends EntitySpawnEvent {
  constructor(spawnee: Item, loc: Location);
  constructor(spawnee: Item);
  getEntity(): Item;
}
/**
 * Called when a firework explodes.
*/
export class FireworkExplodeEvent extends EntityEvent {
  constructor(what: Firework);
  /**
   * Gets the cancellation state of this event. A cancelled event will not
   * be executed in the server, but will still pass to other plugins
   *
   * @return true if this event is cancelled
  */
  isCancelled(): boolean;
  /**
   * Set the cancelled state of this event. If the firework explosion is
   * cancelled, the firework will still be removed, but no particles will be
   * displayed.
   *
   * @param cancel whether to cancel or not.
  */
  setCancelled(cancel: boolean): void;
  getEntity(): Firework;
  getHandlers(): HandlerList;
  static getHandlerList(): HandlerList;
}
export interface FireworkExplodeEvent extends EntityEvent, Cancellable {}
/**
 * Called when an arrow enters or exists an entity's body.
*/
export class ArrowBodyCountChangeEvent extends EntityEvent {
  constructor(entity: LivingEntity, oldAmount: number, newAmount: number, isReset: boolean);
  /**
   * Whether the event was called because the entity was reset.
   *
   * @return was reset
  */
  isReset(): boolean;
  /**
   * Gets the old amount of arrows in the entity's body.
   *
   * @return amount of arrows
  */
  getOldAmount(): number;
  /**
   * Get the new amount of arrows in the entity's body.
   *
   * @return amount of arrows
  */
  getNewAmount(): number;
  /**
   * Sets the final amount of arrows in the entity's body.
   *
   * @param newAmount amount of arrows
  */
  setNewAmount(newAmount: number);
  getEntity(): LivingEntity;
  /**
   * Gets the cancellation state of this event. A cancelled event will not
   * be executed in the server, but will still pass to other plugins
   *
   * @return true if this event is cancelled
  */
  isCancelled(): boolean;
  /**
   * Sets the cancellation state of this event. A cancelled event will not
   * be executed in the server, but will still pass to other plugins.
   *
   * @param cancel true if you wish to cancel this event
  */
  setCancelled(cancel: boolean): void;
  getHandlers(): HandlerList;
  static getHandlerList(): HandlerList;
}
export interface ArrowBodyCountChangeEvent extends EntityEvent, Cancellable {}
/**
 * Sent when an entity's swimming status is toggled.
*/
export class EntityToggleSwimEvent extends EntityEvent {
  constructor(who: LivingEntity, isSwimming: boolean);
  /**
   * Gets the cancellation state of this event. A cancelled event will not
   * be executed in the server, but will still pass to other plugins
   *
   * @return true if this event is cancelled
  */
  isCancelled(): boolean;
  /**
   * Sets the cancellation state of this event. A cancelled event will not
   * be executed in the server, but will still pass to other plugins.
   *
   * @param cancel true if you wish to cancel this event
  */
  setCancelled(cancel: boolean): void;
  /**
   * Returns true if the entity is now swims or
   * false if the entity stops swimming.
   *
   * @return new swimming state
  */
  isSwimming(): boolean;
  getHandlers(): HandlerList;
  static getHandlerList(): HandlerList;
}
export interface EntityToggleSwimEvent extends EntityEvent, Cancellable {}
/**
 * Called immediately prior to a creature being leashed by a player.
*/
export class PlayerLeashEntityEvent extends Event {
  constructor(what: Entity, leashHolder: Entity, leasher: Player);
  /**
   * Returns the entity that is holding the leash.
   *
   * @return The leash holder
  */
  getLeashHolder(): Entity;
  /**
   * Returns the entity being leashed.
   *
   * @return The entity
  */
  getEntity(): Entity;
  /**
   * Returns the player involved in this event
   *
   * @return Player who is involved in this event
  */
  getPlayer(): Player;
  getHandlers(): HandlerList;
  static getHandlerList(): HandlerList;
  /**
   * Gets the cancellation state of this event. A cancelled event will not
   * be executed in the server, but will still pass to other plugins
   *
   * @return true if this event is cancelled
  */
  isCancelled(): boolean;
  /**
   * Sets the cancellation state of this event. A cancelled event will not
   * be executed in the server, but will still pass to other plugins.
   *
   * @param cancel true if you wish to cancel this event
  */
  setCancelled(cancel: boolean): void;
}
export interface PlayerLeashEntityEvent extends Event, Cancellable {}
/**
 * Called when the amount of air an entity has remaining changes.
*/
export class EntityAirChangeEvent extends EntityEvent {
  constructor(what: Entity, amount: number);
  /**
   * Gets the amount of air the entity has left (measured in ticks).
   *
   * @return amount of air remaining
  */
  getAmount(): number;
  /**
   * Sets the amount of air remaining for the entity (measured in ticks.
   *
   * @param amount amount of air remaining
  */
  setAmount(amount: number);
  /**
   * Gets the cancellation state of this event. A cancelled event will not
   * be executed in the server, but will still pass to other plugins
   *
   * @return true if this event is cancelled
  */
  isCancelled(): boolean;
  /**
   * Sets the cancellation state of this event. A cancelled event will not
   * be executed in the server, but will still pass to other plugins.
   *
   * @param cancel true if you wish to cancel this event
  */
  setCancelled(cancelled: boolean): void;
  getHandlers(): HandlerList;
  static getHandlerList(): HandlerList;
}
export interface EntityAirChangeEvent extends EntityEvent, Cancellable {}
/**
 * Called when an entity is spawned into a world by a spawner.
 * 
 * If a Spawner Spawn event is cancelled, the entity will not spawn.
*/
export class SpawnerSpawnEvent extends EntitySpawnEvent {
  constructor(spawnee: Entity, spawner: CreatureSpawner);
  getSpawner(): CreatureSpawner;
}
/**
 * Called when an entity changes its pose.
 *
 * @see Entity#getPose()
*/
export class EntityPoseChangeEvent extends EntityEvent {
  constructor(who: Entity, pose: Pose);
  /**
   * Gets the entity's new pose.
   *
   * @return the new pose
  */
  getPose(): Pose;
  getHandlers(): HandlerList;
  static getHandlerList(): HandlerList;
}
/**
 * Called before an entity exits a portal.
 * 
 * This event allows you to modify the velocity of the entity after they have
 * successfully exited the portal.
 * 
 * Cancelling this event does not prevent the teleport, but it does prevent
 * any changes to velocity and location from taking place.
*/
export class EntityPortalExitEvent extends EntityTeleportEvent {
  constructor(entity: Entity, from: Location, to: Location, before: Vector, after: Vector);
  /**
   * Gets a copy of the velocity that the entity has before entering the
   * portal.
   *
   * @return velocity of entity before entering the portal
  */
  getBefore(): Vector;
  /**
   * Gets a copy of the velocity that the entity will have after exiting the
   * portal.
   *
   * @return velocity of entity after exiting the portal
  */
  getAfter(): Vector;
  /**
   * Sets the velocity that the entity will have after exiting the portal.
   *
   * @param after the velocity after exiting the portal
  */
  setAfter(after: Vector);
  getHandlers(): HandlerList;
  static getHandlerList(): HandlerList;
}
/**
 * Stores data for pigs being zapped
*/
export class PigZapEvent extends EntityZapEvent {
  constructor(pig: Pig, bolt: LightningStrike, pigzombie: PigZombie);
  /**
   * Gets the cancellation state of this event. A cancelled event will not
   * be executed in the server, but will still pass to other plugins
   *
   * @return true if this event is cancelled
  */
  isCancelled(): boolean;
  /**
   * Sets the cancellation state of this event. A cancelled event will not
   * be executed in the server, but will still pass to other plugins.
   *
   * @param cancel true if you wish to cancel this event
  */
  setCancelled(cancel: boolean): void;
  getEntity(): Pig;
  /**
   * Gets the bolt which is striking the pig.
   *
   * @return lightning entity
  */
  getLightning(): LightningStrike;
  /**
   * Gets the zombie pig that will replace the pig, provided the event is
   * not cancelled first.
   *
   * @return resulting entity
   * @deprecated use {@link EntityTransformEvent#getTransformedEntity()}
  */
  getPigZombie(): PigZombie;
  /**
   * Gets the lightning bolt that is striking the entity.
   * @return The lightning bolt responsible for this event
  */
  getBolt(): LightningStrike;
}
export interface PigZapEvent extends EntityZapEvent, Cancellable {}
export class VillagerCareerChangeEvent extends EntityEvent {
  constructor(what: Villager, profession: Profession, reason: ChangeReason);
  getEntity(): Villager;
  /**
   * Gets the future profession of the villager.
   *
   * @return The profession the villager will change to
  */
  getProfession(): Profession;
  /**
   * Sets the profession the villager will become from this event.
   *
   * @param profession new profession
  */
  setProfession(profession: Profession);
  /**
   * Gets the reason for why the villager's career is changing.
   *
   * @return Reason for villager's profession changing
  */
  getReason(): ChangeReason;
  /**
   * Gets the cancellation state of this event. A cancelled event will not
   * be executed in the server, but will still pass to other plugins
   *
   * @return true if this event is cancelled
  */
  isCancelled(): boolean;
  /**
   * Sets the cancellation state of this event. A cancelled event will not
   * be executed in the server, but will still pass to other plugins.
   *
   * @param cancel true if you wish to cancel this event
  */
  setCancelled(cancel: boolean): void;
  getHandlers(): HandlerList;
  static getHandlerList(): HandlerList;
}
export interface VillagerCareerChangeEvent extends EntityEvent, Cancellable {}
/**
 * Called when a bat attempts to sleep or wake up from its slumber.
 * 
 * If a Bat Toggle Sleep event is cancelled, the Bat will not toggle its sleep
 * state.
*/
export class BatToggleSleepEvent extends EntityEvent {
  constructor(what: Bat, awake: boolean);
  /**
   * Get whether or not the bat is attempting to awaken.
   *
   * @return true if trying to awaken, false otherwise
  */
  isAwake(): boolean;
  /**
   * Sets the cancellation state of this event. A cancelled event will not
   * be executed in the server, but will still pass to other plugins.
   *
   * @param cancel true if you wish to cancel this event
  */
  setCancelled(cancel: boolean): void;
  /**
   * Gets the cancellation state of this event. A cancelled event will not
   * be executed in the server, but will still pass to other plugins
   *
   * @return true if this event is cancelled
  */
  isCancelled(): boolean;
  getHandlers(): HandlerList;
  static getHandlerList(): HandlerList;
}
export interface BatToggleSleepEvent extends EntityEvent, Cancellable {}
/**
 * Sent when an entity's gliding status is toggled with an Elytra.
 * Examples of when this event would be called:
 * 
 *     Player presses the jump key while in midair and using an Elytra
 *     Player lands on ground while they are gliding (with an Elytra)
 * 
 * This can be visually estimated by the animation in which a player turns horizontal.
*/
export class EntityToggleGlideEvent extends EntityEvent {
  constructor(who: LivingEntity, isGliding: boolean);
  /**
   * Gets the cancellation state of this event. A cancelled event will not
   * be executed in the server, but will still pass to other plugins
   *
   * @return true if this event is cancelled
  */
  isCancelled(): boolean;
  /**
   * Sets the cancellation state of this event. A cancelled event will not
   * be executed in the server, but will still pass to other plugins.
   *
   * @param cancel true if you wish to cancel this event
  */
  setCancelled(cancel: boolean): void;
  /**
   * Returns true if the entity is now gliding or
   * false if the entity stops gliding.
   *
   * @return new gliding state
  */
  isGliding(): boolean;
  getHandlers(): HandlerList;
  static getHandlerList(): HandlerList;
}
export interface EntityToggleGlideEvent extends EntityEvent, Cancellable {}
/**
 * Called when any Entity changes a block and a more specific event is not available.
*/
export class EntityChangeBlockEvent extends EntityEvent {
  constructor(what: Entity, block: Block, to: BlockData);
  /**
   * Gets the block the entity is changing
   *
   * @return the block that is changing
  */
  getBlock(): Block;
  /**
   * Gets the cancellation state of this event. A cancelled event will not
   * be executed in the server, but will still pass to other plugins
   *
   * @return true if this event is cancelled
  */
  isCancelled(): boolean;
  /**
   * Sets the cancellation state of this event. A cancelled event will not
   * be executed in the server, but will still pass to other plugins.
   *
   * @param cancel true if you wish to cancel this event
  */
  setCancelled(cancel: boolean): void;
  /**
   * Gets the Material that the block is changing into
   *
   * @return the material that the block is changing into
  */
  getTo(): Material;
  /**
   * Gets the data for the block that would be changed into
   *
   * @return the data for the block that would be changed into
  */
  getBlockData(): BlockData;
  getHandlers(): HandlerList;
  static getHandlerList(): HandlerList;
}
export interface EntityChangeBlockEvent extends EntityEvent, Cancellable {}
/**
 * Thrown when a non-player entity is teleported from one location to another.
 * 
 * This may be as a result of natural causes (Enderman, Shulker), pathfinding
 * (Wolf), or commands (/teleport).
*/
export class EntityTeleportEvent extends EntityEvent {
  constructor(what: Entity, from: Location, to: Location | null);
  /**
   * Gets the cancellation state of this event. A cancelled event will not
   * be executed in the server, but will still pass to other plugins
   *
   * @return true if this event is cancelled
  */
  isCancelled(): boolean;
  /**
   * Sets the cancellation state of this event. A cancelled event will not
   * be executed in the server, but will still pass to other plugins.
   *
   * @param cancel true if you wish to cancel this event
  */
  setCancelled(cancel: boolean): void;
  /**
   * Gets the location that this entity moved from
   *
   * @return Location this entity moved from
  */
  getFrom(): Location;
  /**
   * Sets the location that this entity moved from
   *
   * @param from New location this entity moved from
  */
  setFrom(from: Location);
  /**
   * Gets the location that this entity moved to
   *
   * @return Location the entity moved to
  */
  getTo(): Location | null;
  /**
   * Sets the location that this entity moved to
   *
   * @param to New Location this entity moved to
  */
  setTo(to: Location | null);
  getHandlers(): HandlerList;
  static getHandlerList(): HandlerList;
}
export interface EntityTeleportEvent extends EntityEvent, Cancellable {}
/**
 * Stores data for health-regain events
*/
export class EntityRegainHealthEvent extends EntityEvent {
  constructor(entity: Entity, amount: number, regainReason: RegainReason);
  constructor(entity: Entity, amount: number, regainReason: RegainReason, isFastRegen: boolean);
  /**
   * Is this event a result of the fast regeneration mechanic
   *
   * @return Whether the event is the result of a fast regeneration mechanic
  */
  isFastRegen(): boolean;
  /**
   * Gets the amount of regained health
   *
   * @return The amount of health regained
  */
  getAmount(): number;
  /**
   * Sets the amount of regained health
   *
   * @param amount the amount of health the entity will regain
  */
  setAmount(amount: number);
  /**
   * Gets the cancellation state of this event. A cancelled event will not
   * be executed in the server, but will still pass to other plugins
   *
   * @return true if this event is cancelled
  */
  isCancelled(): boolean;
  /**
   * Sets the cancellation state of this event. A cancelled event will not
   * be executed in the server, but will still pass to other plugins.
   *
   * @param cancel true if you wish to cancel this event
  */
  setCancelled(cancel: boolean): void;
  /**
   * Gets the reason for why the entity is regaining health
   *
   * @return A RegainReason detailing the reason for the entity regaining
   *     health
  */
  getRegainReason(): RegainReason;
  getHandlers(): HandlerList;
  static getHandlerList(): HandlerList;
}
export interface EntityRegainHealthEvent extends EntityEvent, Cancellable {}
/**
 * Called when an entity causes another entity to combust.
*/
export class EntityCombustByEntityEvent extends EntityCombustEvent {
  constructor(combuster: Entity, combustee: Entity, duration: number);
  /**
   * Get the entity that caused the combustion event.
   *
   * @return the Entity that set the combustee alight.
  */
  getCombuster(): Entity;
}
/**
 * Called when an entity is about to be replaced by another entity.
*/
export class EntityTransformEvent extends EntityEvent {
  constructor(original: Entity, convertedList: Entity[], transformReason: TransformReason);
  /**
   * Gets the entity that the original entity was transformed to.
   *
   * This returns the first entity in the transformed entity list.
   *
   * @return The transformed entity.
   * @see #getTransformedEntities()
  */
  getTransformedEntity(): Entity;
  /**
   * Gets the entities that the original entity was transformed to.
   *
   * @return The transformed entities.
  */
  getTransformedEntities(): Entity[];
  /**
   * Gets the reason for the conversion that has occurred.
   *
   * @return The reason for conversion that has occurred.
  */
  getTransformReason(): TransformReason;
  /**
   * Gets the cancellation state of this event. A cancelled event will not
   * be executed in the server, but will still pass to other plugins
   *
   * @return true if this event is cancelled
  */
  isCancelled(): boolean;
  /**
   * Sets the cancellation state of this event. A cancelled event will not
   * be executed in the server, but will still pass to other plugins.
   *
   * @param cancel true if you wish to cancel this event
  */
  setCancelled(cancel: boolean): void;
  getHandlers(): HandlerList;
  static getHandlerList(): HandlerList;
}
export interface EntityTransformEvent extends EntityEvent, Cancellable {}
/**
 * Stores data for damage events
*/
export class EntityDamageEvent extends EntityEvent {
  constructor(damagee: Entity, cause: DamageCause, damage: number);
  constructor(damagee: Entity, cause: DamageCause, modifiers: Map<DamageModifier, number>, modifierFunctions: Map<DamageModifier, Function<any, number>>);
  /**
   * Gets the cancellation state of this event. A cancelled event will not
   * be executed in the server, but will still pass to other plugins
   *
   * @return true if this event is cancelled
  */
  isCancelled(): boolean;
  /**
   * Sets the cancellation state of this event. A cancelled event will not
   * be executed in the server, but will still pass to other plugins.
   *
   * @param cancel true if you wish to cancel this event
  */
  setCancelled(cancel: boolean): void;
  /**
   * Gets the original damage for the specified modifier, as defined at this
   * event's construction.
   *
   * @param type the modifier
   * @return the original damage
   * @throws IllegalArgumentException if type is null
  */
  getOriginalDamage(type: DamageModifier): number;
  /**
   * Sets the damage for the specified modifier.
   *
   * @param type the damage modifier
   * @param damage the scalar value of the damage's modifier
   * @throws IllegalArgumentException if type is null
   * @throws UnsupportedOperationException if the caller does not support
   *     the particular DamageModifier, or to rephrase, when {@link
   *     #isApplicable(DamageModifier)} returns false
   * @see #getFinalDamage()
  */
  setDamage(type: DamageModifier, damage: number): void;
  /**
   * Gets the damage change for some modifier
   *
   * @param type the damage modifier
   * @return The raw amount of damage caused by the event
   * @throws IllegalArgumentException if type is null
   * @see DamageModifier#BASE
  */
  getDamage(type: DamageModifier): number;
  /**
   * This checks to see if a particular modifier is valid for this event's
   * caller, such that, {@link #setDamage(DamageModifier, double)} will not
   * throw an {@link UnsupportedOperationException}.
   * 
   * {@link DamageModifier#BASE} is always applicable.
   *
   * @param type the modifier
   * @return true if the modifier is supported by the caller, false otherwise
   * @throws IllegalArgumentException if type is null
  */
  isApplicable(type: DamageModifier): boolean;
  /**
   * Gets the raw amount of damage caused by the event
   *
   * @return The raw amount of damage caused by the event
   * @see DamageModifier#BASE
  */
  getDamage(): number;
  /**
   * Gets the amount of damage caused by the event after all damage
   * reduction is applied.
   *
   * @return the amount of damage caused by the event
  */
  getFinalDamage(): number;
  /**
   * Sets the raw amount of damage caused by the event.
   * 
   * For compatibility this also recalculates the modifiers and scales
   * them by the difference between the modifier for the previous damage
   * value and the new one.
   *
   * @param damage The raw amount of damage caused by the event
  */
  setDamage(damage: number);
  /**
   * Gets the cause of the damage.
   *
   * @return A DamageCause value detailing the cause of the damage.
  */
  getCause(): DamageCause;
  getHandlers(): HandlerList;
  static getHandlerList(): HandlerList;
}
export interface EntityDamageEvent extends EntityEvent, Cancellable {}

}
declare module 'org.bukkit.event.entity.CreeperPowerEvent' {
import { Enum } from 'java.lang';
/**
 * An enum to specify the cause of the change in power
*/
export class PowerCause extends Enum<PowerCause> {
  /**
   * Power change caused by a lightning bolt
   * 
   * Powered state: true
  */
  static readonly LIGHTNING: PowerCause;
  /**
   * Power change caused by something else (probably a plugin)
   * 
   * Powered state: true
  */
  static readonly SET_ON: PowerCause;
  /**
   * Power change caused by something else (probably a plugin)
   * 
   * Powered state: false
  */
  static readonly SET_OFF: PowerCause;
  static valueOf(name: string): PowerCause;
  static values(): PowerCause[];
}

}
declare module 'org.bukkit.Warning' {
import { Map } from 'java.util';
import { Enum } from 'java.lang';
import { Warning } from 'org.bukkit';
/**
 * This represents the states that server verbose for warnings may be.
*/
export class WarningState extends Enum<WarningState> {
  /**
   * Indicates all warnings should be printed for deprecated items.
  */
  static readonly ON: WarningState;
  /**
   * Indicates no warnings should be printed for deprecated items.
  */
  static readonly OFF: WarningState;
  /**
   * Indicates each warning would default to the configured {@link
   * Warning} annotation, or always if annotation not found.
  */
  static readonly DEFAULT: WarningState;
  static valueOf(name: string): WarningState;
  static values(): WarningState[];
  /**
   * This method checks the provided warning should be printed for this
   * state
   *
   * @param warning The warning annotation added to a deprecated item
   * @return 
   *     ON is always True
   *     OFF is always false
   *     DEFAULT is false if and only if annotation is not null and
   *     specifies false for {@link Warning#value()}, true otherwise.
   *     
  */
  printFor(warning: Warning | null): boolean;
  /**
   * This method returns the corresponding warning state for the given
   * string value.
   *
   * @param value The string value to check
   * @return {@link #DEFAULT} if not found, or the respective
   *     WarningState
  */
  static value(value: string | null): WarningState;
}

}
declare module 'org.bukkit.util.noise' {
import { Random } from 'java.util';
import { World } from 'org.bukkit';
/**
 * Generates noise using the "classic" perlin generator
 *
 * @see SimplexNoiseGenerator "Improved" and faster version with slightly
 *     different results
*/
export class PerlinNoiseGenerator extends NoiseGenerator {
  /**
   * Creates a seeded perlin noise generator for the given world
   *
   * @param world World to construct this generator for
  */
  constructor(world: World);
  /**
   * Creates a seeded perlin noise generator for the given seed
   *
   * @param seed Seed to construct this generator for
  */
  constructor(seed: number);
  /**
   * Creates a seeded perlin noise generator with the given Random
   *
   * @param rand Random to construct with
  */
  constructor(rand: Random);
  /**
   * Computes and returns the 1D unseeded perlin noise for the given
   * coordinates in 1D space
   *
   * @param x X coordinate
   * @return Noise at given location, from range -1 to 1
  */
  static getNoise(x: number): number;
  /**
   * Computes and returns the 2D unseeded perlin noise for the given
   * coordinates in 2D space
   *
   * @param x X coordinate
   * @param y Y coordinate
   * @return Noise at given location, from range -1 to 1
  */
  static getNoise(x: number, y: number): number;
  /**
   * Computes and returns the 3D unseeded perlin noise for the given
   * coordinates in 3D space
   *
   * @param x X coordinate
   * @param y Y coordinate
   * @param z Z coordinate
   * @return Noise at given location, from range -1 to 1
  */
  static getNoise(x: number, y: number, z: number): number;
  /**
   * Gets the singleton unseeded instance of this generator
   *
   * @return Singleton
  */
  static getInstance(): PerlinNoiseGenerator;
  noise(x: number, y: number, z: number): number;
  /**
   * Generates noise for the 1D coordinates using the specified number of
   * octaves and parameters
   *
   * @param x X-coordinate
   * @param octaves Number of octaves to use
   * @param frequency How much to alter the frequency by each octave
   * @param amplitude How much to alter the amplitude by each octave
   * @return Resulting noise
  */
  static getNoise(x: number, octaves: number, frequency: number, amplitude: number): number;
  /**
   * Generates noise for the 2D coordinates using the specified number of
   * octaves and parameters
   *
   * @param x X-coordinate
   * @param y Y-coordinate
   * @param octaves Number of octaves to use
   * @param frequency How much to alter the frequency by each octave
   * @param amplitude How much to alter the amplitude by each octave
   * @return Resulting noise
  */
  static getNoise(x: number, y: number, octaves: number, frequency: number, amplitude: number): number;
  /**
   * Generates noise for the 3D coordinates using the specified number of
   * octaves and parameters
   *
   * @param x X-coordinate
   * @param y Y-coordinate
   * @param z Z-coordinate
   * @param octaves Number of octaves to use
   * @param frequency How much to alter the frequency by each octave
   * @param amplitude How much to alter the amplitude by each octave
   * @return Resulting noise
  */
  static getNoise(x: number, y: number, z: number, octaves: number, frequency: number, amplitude: number): number;
  /**
   * Computes and returns the 1D noise for the given coordinate in 1D space
   *
   * @param x X coordinate
   * @return Noise at given location, from range -1 to 1
  */
  noise(x: number): number;
  /**
   * Computes and returns the 2D noise for the given coordinates in 2D space
   *
   * @param x X coordinate
   * @param y Y coordinate
   * @return Noise at given location, from range -1 to 1
  */
  noise(x: number, y: number): number;
  /**
   * Generates noise for the 1D coordinates using the specified number of
   * octaves and parameters
   *
   * @param x X-coordinate
   * @param octaves Number of octaves to use
   * @param frequency How much to alter the frequency by each octave
   * @param amplitude How much to alter the amplitude by each octave
   * @return Resulting noise
  */
  noise(x: number, octaves: number, frequency: number, amplitude: number): number;
  /**
   * Generates noise for the 1D coordinates using the specified number of
   * octaves and parameters
   *
   * @param x X-coordinate
   * @param octaves Number of octaves to use
   * @param frequency How much to alter the frequency by each octave
   * @param amplitude How much to alter the amplitude by each octave
   * @param normalized If true, normalize the value to [-1, 1]
   * @return Resulting noise
  */
  noise(x: number, octaves: number, frequency: number, amplitude: number, normalized: boolean): number;
  /**
   * Generates noise for the 2D coordinates using the specified number of
   * octaves and parameters
   *
   * @param x X-coordinate
   * @param y Y-coordinate
   * @param octaves Number of octaves to use
   * @param frequency How much to alter the frequency by each octave
   * @param amplitude How much to alter the amplitude by each octave
   * @return Resulting noise
  */
  noise(x: number, y: number, octaves: number, frequency: number, amplitude: number): number;
  /**
   * Generates noise for the 2D coordinates using the specified number of
   * octaves and parameters
   *
   * @param x X-coordinate
   * @param y Y-coordinate
   * @param octaves Number of octaves to use
   * @param frequency How much to alter the frequency by each octave
   * @param amplitude How much to alter the amplitude by each octave
   * @param normalized If true, normalize the value to [-1, 1]
   * @return Resulting noise
  */
  noise(x: number, y: number, octaves: number, frequency: number, amplitude: number, normalized: boolean): number;
  /**
   * Generates noise for the 3D coordinates using the specified number of
   * octaves and parameters
   *
   * @param x X-coordinate
   * @param y Y-coordinate
   * @param z Z-coordinate
   * @param octaves Number of octaves to use
   * @param frequency How much to alter the frequency by each octave
   * @param amplitude How much to alter the amplitude by each octave
   * @return Resulting noise
  */
  noise(x: number, y: number, z: number, octaves: number, frequency: number, amplitude: number): number;
  /**
   * Generates noise for the 3D coordinates using the specified number of
   * octaves and parameters
   *
   * @param x X-coordinate
   * @param y Y-coordinate
   * @param z Z-coordinate
   * @param octaves Number of octaves to use
   * @param frequency How much to alter the frequency by each octave
   * @param amplitude How much to alter the amplitude by each octave
   * @param normalized If true, normalize the value to [-1, 1]
   * @return Resulting noise
  */
  noise(x: number, y: number, z: number, octaves: number, frequency: number, amplitude: number, normalized: boolean): number;
}
/**
 * Creates perlin noise through unbiased octaves
*/
export class PerlinOctaveGenerator extends OctaveGenerator {
  /**
   * Creates a perlin octave generator for the given world
   *
   * @param world World to construct this generator for
   * @param octaves Amount of octaves to create
  */
  constructor(world: World, octaves: number);
  /**
   * Creates a perlin octave generator for the given world
   *
   * @param seed Seed to construct this generator for
   * @param octaves Amount of octaves to create
  */
  constructor(seed: number, octaves: number);
  /**
   * Creates a perlin octave generator for the given {@link Random}
   *
   * @param rand Random object to construct this generator for
   * @param octaves Amount of octaves to create
  */
  constructor(rand: Random, octaves: number);
}
/**
 * Creates noise using unbiased octaves
*/
export class OctaveGenerator {
  /**
   * Sets the scale used for all coordinates passed to this generator.
   * 
   * This is the equivalent to setting each coordinate to the specified
   * value.
   *
   * @param scale New value to scale each coordinate by
  */
  setScale(scale: number);
  /**
   * Gets the scale used for each X-coordinates passed
   *
   * @return X scale
  */
  getXScale(): number;
  /**
   * Sets the scale used for each X-coordinates passed
   *
   * @param scale New X scale
  */
  setXScale(xScale: number);
  /**
   * Gets the scale used for each Y-coordinates passed
   *
   * @return Y scale
  */
  getYScale(): number;
  /**
   * Sets the scale used for each Y-coordinates passed
   *
   * @param scale New Y scale
  */
  setYScale(yScale: number);
  /**
   * Gets the scale used for each Z-coordinates passed
   *
   * @return Z scale
  */
  getZScale(): number;
  /**
   * Sets the scale used for each Z-coordinates passed
   *
   * @param scale New Z scale
  */
  setZScale(zScale: number);
  /**
   * Gets a clone of the individual octaves used within this generator
   *
   * @return Clone of the individual octaves
  */
  getOctaves(): NoiseGenerator[];
  /**
   * Generates noise for the 1D coordinates using the specified number of
   * octaves and parameters
   *
   * @param x X-coordinate
   * @param frequency How much to alter the frequency by each octave
   * @param amplitude How much to alter the amplitude by each octave
   * @return Resulting noise
  */
  noise(x: number, frequency: number, amplitude: number): number;
  /**
   * Generates noise for the 1D coordinates using the specified number of
   * octaves and parameters
   *
   * @param x X-coordinate
   * @param frequency How much to alter the frequency by each octave
   * @param amplitude How much to alter the amplitude by each octave
   * @param normalized If true, normalize the value to [-1, 1]
   * @return Resulting noise
  */
  noise(x: number, frequency: number, amplitude: number, normalized: boolean): number;
  /**
   * Generates noise for the 2D coordinates using the specified number of
   * octaves and parameters
   *
   * @param x X-coordinate
   * @param y Y-coordinate
   * @param frequency How much to alter the frequency by each octave
   * @param amplitude How much to alter the amplitude by each octave
   * @return Resulting noise
  */
  noise(x: number, y: number, frequency: number, amplitude: number): number;
  /**
   * Generates noise for the 2D coordinates using the specified number of
   * octaves and parameters
   *
   * @param x X-coordinate
   * @param y Y-coordinate
   * @param frequency How much to alter the frequency by each octave
   * @param amplitude How much to alter the amplitude by each octave
   * @param normalized If true, normalize the value to [-1, 1]
   * @return Resulting noise
  */
  noise(x: number, y: number, frequency: number, amplitude: number, normalized: boolean): number;
  /**
   * Generates noise for the 3D coordinates using the specified number of
   * octaves and parameters
   *
   * @param x X-coordinate
   * @param y Y-coordinate
   * @param z Z-coordinate
   * @param frequency How much to alter the frequency by each octave
   * @param amplitude How much to alter the amplitude by each octave
   * @return Resulting noise
  */
  noise(x: number, y: number, z: number, frequency: number, amplitude: number): number;
  /**
   * Generates noise for the 3D coordinates using the specified number of
   * octaves and parameters
   *
   * @param x X-coordinate
   * @param y Y-coordinate
   * @param z Z-coordinate
   * @param frequency How much to alter the frequency by each octave
   * @param amplitude How much to alter the amplitude by each octave
   * @param normalized If true, normalize the value to [-1, 1]
   * @return Resulting noise
  */
  noise(x: number, y: number, z: number, frequency: number, amplitude: number, normalized: boolean): number;
}
/**
 * Base class for all noise generators
*/
export class NoiseGenerator {
  /**
   * Speedy floor, faster than (int)Math.floor(x)
   *
   * @param x Value to floor
   * @return Floored value
  */
  static floor(x: number): number;
  /**
   * Computes and returns the 1D noise for the given coordinate in 1D space
   *
   * @param x X coordinate
   * @return Noise at given location, from range -1 to 1
  */
  noise(x: number): number;
  /**
   * Computes and returns the 2D noise for the given coordinates in 2D space
   *
   * @param x X coordinate
   * @param y Y coordinate
   * @return Noise at given location, from range -1 to 1
  */
  noise(x: number, y: number): number;
  /**
   * Computes and returns the 3D noise for the given coordinates in 3D space
   *
   * @param x X coordinate
   * @param y Y coordinate
   * @param z Z coordinate
   * @return Noise at given location, from range -1 to 1
  */
  noise(x: number, y: number, z: number): number;
  /**
   * Generates noise for the 1D coordinates using the specified number of
   * octaves and parameters
   *
   * @param x X-coordinate
   * @param octaves Number of octaves to use
   * @param frequency How much to alter the frequency by each octave
   * @param amplitude How much to alter the amplitude by each octave
   * @return Resulting noise
  */
  noise(x: number, octaves: number, frequency: number, amplitude: number): number;
  /**
   * Generates noise for the 1D coordinates using the specified number of
   * octaves and parameters
   *
   * @param x X-coordinate
   * @param octaves Number of octaves to use
   * @param frequency How much to alter the frequency by each octave
   * @param amplitude How much to alter the amplitude by each octave
   * @param normalized If true, normalize the value to [-1, 1]
   * @return Resulting noise
  */
  noise(x: number, octaves: number, frequency: number, amplitude: number, normalized: boolean): number;
  /**
   * Generates noise for the 2D coordinates using the specified number of
   * octaves and parameters
   *
   * @param x X-coordinate
   * @param y Y-coordinate
   * @param octaves Number of octaves to use
   * @param frequency How much to alter the frequency by each octave
   * @param amplitude How much to alter the amplitude by each octave
   * @return Resulting noise
  */
  noise(x: number, y: number, octaves: number, frequency: number, amplitude: number): number;
  /**
   * Generates noise for the 2D coordinates using the specified number of
   * octaves and parameters
   *
   * @param x X-coordinate
   * @param y Y-coordinate
   * @param octaves Number of octaves to use
   * @param frequency How much to alter the frequency by each octave
   * @param amplitude How much to alter the amplitude by each octave
   * @param normalized If true, normalize the value to [-1, 1]
   * @return Resulting noise
  */
  noise(x: number, y: number, octaves: number, frequency: number, amplitude: number, normalized: boolean): number;
  /**
   * Generates noise for the 3D coordinates using the specified number of
   * octaves and parameters
   *
   * @param x X-coordinate
   * @param y Y-coordinate
   * @param z Z-coordinate
   * @param octaves Number of octaves to use
   * @param frequency How much to alter the frequency by each octave
   * @param amplitude How much to alter the amplitude by each octave
   * @return Resulting noise
  */
  noise(x: number, y: number, z: number, octaves: number, frequency: number, amplitude: number): number;
  /**
   * Generates noise for the 3D coordinates using the specified number of
   * octaves and parameters
   *
   * @param x X-coordinate
   * @param y Y-coordinate
   * @param z Z-coordinate
   * @param octaves Number of octaves to use
   * @param frequency How much to alter the frequency by each octave
   * @param amplitude How much to alter the amplitude by each octave
   * @param normalized If true, normalize the value to [-1, 1]
   * @return Resulting noise
  */
  noise(x: number, y: number, z: number, octaves: number, frequency: number, amplitude: number, normalized: boolean): number;
}
/**
 * Creates simplex noise through unbiased octaves
*/
export class SimplexOctaveGenerator extends OctaveGenerator {
  /**
   * Creates a simplex octave generator for the given world
   *
   * @param world World to construct this generator for
   * @param octaves Amount of octaves to create
  */
  constructor(world: World, octaves: number);
  /**
   * Creates a simplex octave generator for the given world
   *
   * @param seed Seed to construct this generator for
   * @param octaves Amount of octaves to create
  */
  constructor(seed: number, octaves: number);
  /**
   * Creates a simplex octave generator for the given {@link Random}
   *
   * @param rand Random object to construct this generator for
   * @param octaves Amount of octaves to create
  */
  constructor(rand: Random, octaves: number);
  setScale(scale: number);
  /**
   * Gets the scale used for each W-coordinates passed
   *
   * @return W scale
  */
  getWScale(): number;
  /**
   * Sets the scale used for each W-coordinates passed
   *
   * @param scale New W scale
  */
  setWScale(wScale: number);
  /**
   * Generates noise for the 3D coordinates using the specified number of
   * octaves and parameters
   *
   * @param x X-coordinate
   * @param y Y-coordinate
   * @param z Z-coordinate
   * @param w W-coordinate
   * @param frequency How much to alter the frequency by each octave
   * @param amplitude How much to alter the amplitude by each octave
   * @return Resulting noise
  */
  noise(x: number, y: number, z: number, w: number, frequency: number, amplitude: number): number;
  /**
   * Generates noise for the 3D coordinates using the specified number of
   * octaves and parameters
   *
   * @param x X-coordinate
   * @param y Y-coordinate
   * @param z Z-coordinate
   * @param w W-coordinate
   * @param frequency How much to alter the frequency by each octave
   * @param amplitude How much to alter the amplitude by each octave
   * @param normalized If true, normalize the value to [-1, 1]
   * @return Resulting noise
  */
  noise(x: number, y: number, z: number, w: number, frequency: number, amplitude: number, normalized: boolean): number;
  /**
   * Generates noise for the 1D coordinates using the specified number of
   * octaves and parameters
   *
   * @param x X-coordinate
   * @param frequency How much to alter the frequency by each octave
   * @param amplitude How much to alter the amplitude by each octave
   * @return Resulting noise
  */
  noise(x: number, frequency: number, amplitude: number): number;
  /**
   * Generates noise for the 1D coordinates using the specified number of
   * octaves and parameters
   *
   * @param x X-coordinate
   * @param frequency How much to alter the frequency by each octave
   * @param amplitude How much to alter the amplitude by each octave
   * @param normalized If true, normalize the value to [-1, 1]
   * @return Resulting noise
  */
  noise(x: number, frequency: number, amplitude: number, normalized: boolean): number;
  /**
   * Generates noise for the 2D coordinates using the specified number of
   * octaves and parameters
   *
   * @param x X-coordinate
   * @param y Y-coordinate
   * @param frequency How much to alter the frequency by each octave
   * @param amplitude How much to alter the amplitude by each octave
   * @return Resulting noise
  */
  noise(x: number, y: number, frequency: number, amplitude: number): number;
  /**
   * Generates noise for the 2D coordinates using the specified number of
   * octaves and parameters
   *
   * @param x X-coordinate
   * @param y Y-coordinate
   * @param frequency How much to alter the frequency by each octave
   * @param amplitude How much to alter the amplitude by each octave
   * @param normalized If true, normalize the value to [-1, 1]
   * @return Resulting noise
  */
  noise(x: number, y: number, frequency: number, amplitude: number, normalized: boolean): number;
  /**
   * Generates noise for the 3D coordinates using the specified number of
   * octaves and parameters
   *
   * @param x X-coordinate
   * @param y Y-coordinate
   * @param z Z-coordinate
   * @param frequency How much to alter the frequency by each octave
   * @param amplitude How much to alter the amplitude by each octave
   * @return Resulting noise
  */
  noise(x: number, y: number, z: number, frequency: number, amplitude: number): number;
  /**
   * Generates noise for the 3D coordinates using the specified number of
   * octaves and parameters
   *
   * @param x X-coordinate
   * @param y Y-coordinate
   * @param z Z-coordinate
   * @param frequency How much to alter the frequency by each octave
   * @param amplitude How much to alter the amplitude by each octave
   * @param normalized If true, normalize the value to [-1, 1]
   * @return Resulting noise
  */
  noise(x: number, y: number, z: number, frequency: number, amplitude: number, normalized: boolean): number;
}
/**
 * Generates simplex-based noise.
 * 
 * This is a modified version of the freely published version in the paper by
 * Stefan Gustavson at
 * 
 * http://staffwww.itn.liu.se/~stegu/simplexnoise/simplexnoise.pdf
*/
export class SimplexNoiseGenerator extends PerlinNoiseGenerator {
  /**
   * Creates a seeded simplex noise generator for the given world
   *
   * @param world World to construct this generator for
  */
  constructor(world: World);
  /**
   * Creates a seeded simplex noise generator for the given seed
   *
   * @param seed Seed to construct this generator for
  */
  constructor(seed: number);
  /**
   * Creates a seeded simplex noise generator with the given Random
   *
   * @param rand Random to construct with
  */
  constructor(rand: Random);
  /**
   * Computes and returns the 1D unseeded simplex noise for the given
   * coordinates in 1D space
   *
   * @param xin X coordinate
   * @return Noise at given location, from range -1 to 1
  */
  static getNoise(xin: number): number;
  /**
   * Computes and returns the 2D unseeded simplex noise for the given
   * coordinates in 2D space
   *
   * @param xin X coordinate
   * @param yin Y coordinate
   * @return Noise at given location, from range -1 to 1
  */
  static getNoise(xin: number, yin: number): number;
  /**
   * Computes and returns the 3D unseeded simplex noise for the given
   * coordinates in 3D space
   *
   * @param xin X coordinate
   * @param yin Y coordinate
   * @param zin Z coordinate
   * @return Noise at given location, from range -1 to 1
  */
  static getNoise(xin: number, yin: number, zin: number): number;
  /**
   * Computes and returns the 4D simplex noise for the given coordinates in
   * 4D space
   *
   * @param x X coordinate
   * @param y Y coordinate
   * @param z Z coordinate
   * @param w W coordinate
   * @return Noise at given location, from range -1 to 1
  */
  static getNoise(x: number, y: number, z: number, w: number): number;
  noise(xin: number, yin: number, zin: number): number;
  noise(xin: number, yin: number): number;
  /**
   * Computes and returns the 4D simplex noise for the given coordinates in
   * 4D space
   *
   * @param x X coordinate
   * @param y Y coordinate
   * @param z Z coordinate
   * @param w W coordinate
   * @return Noise at given location, from range -1 to 1
  */
  noise(x: number, y: number, z: number, w: number): number;
  /**
   * Gets the singleton unseeded instance of this generator
   *
   * @return Singleton
  */
  static getInstance(): SimplexNoiseGenerator;
  /**
   * Generates noise for the 2D coordinates using the specified number of
   * octaves and parameters
   *
   * @param x X-coordinate
   * @param y Y-coordinate
   * @param octaves Number of octaves to use
   * @param frequency How much to alter the frequency by each octave
   * @param amplitude How much to alter the amplitude by each octave
   * @return Resulting noise
  */
  static getNoise(x: number, y: number, octaves: number, frequency: number, amplitude: number): number;
  /**
   * Generates noise for the 3D coordinates using the specified number of
   * octaves and parameters
   *
   * @param x X-coordinate
   * @param y Y-coordinate
   * @param z Z-coordinate
   * @param octaves Number of octaves to use
   * @param frequency How much to alter the frequency by each octave
   * @param amplitude How much to alter the amplitude by each octave
   * @return Resulting noise
  */
  static getNoise(x: number, y: number, z: number, octaves: number, frequency: number, amplitude: number): number;
  /**
   * Computes and returns the 1D noise for the given coordinate in 1D space
   *
   * @param x X coordinate
   * @return Noise at given location, from range -1 to 1
  */
  noise(x: number): number;
  /**
   * Generates noise for the 1D coordinates using the specified number of
   * octaves and parameters
   *
   * @param x X-coordinate
   * @param octaves Number of octaves to use
   * @param frequency How much to alter the frequency by each octave
   * @param amplitude How much to alter the amplitude by each octave
   * @param normalized If true, normalize the value to [-1, 1]
   * @return Resulting noise
  */
  noise(x: number, octaves: number, frequency: number, amplitude: number, normalized: boolean): number;
  /**
   * Generates noise for the 2D coordinates using the specified number of
   * octaves and parameters
   *
   * @param x X-coordinate
   * @param y Y-coordinate
   * @param octaves Number of octaves to use
   * @param frequency How much to alter the frequency by each octave
   * @param amplitude How much to alter the amplitude by each octave
   * @return Resulting noise
  */
  noise(x: number, y: number, octaves: number, frequency: number, amplitude: number): number;
  /**
   * Generates noise for the 2D coordinates using the specified number of
   * octaves and parameters
   *
   * @param x X-coordinate
   * @param y Y-coordinate
   * @param octaves Number of octaves to use
   * @param frequency How much to alter the frequency by each octave
   * @param amplitude How much to alter the amplitude by each octave
   * @param normalized If true, normalize the value to [-1, 1]
   * @return Resulting noise
  */
  noise(x: number, y: number, octaves: number, frequency: number, amplitude: number, normalized: boolean): number;
  /**
   * Generates noise for the 3D coordinates using the specified number of
   * octaves and parameters
   *
   * @param x X-coordinate
   * @param y Y-coordinate
   * @param z Z-coordinate
   * @param octaves Number of octaves to use
   * @param frequency How much to alter the frequency by each octave
   * @param amplitude How much to alter the amplitude by each octave
   * @return Resulting noise
  */
  noise(x: number, y: number, z: number, octaves: number, frequency: number, amplitude: number): number;
  /**
   * Generates noise for the 3D coordinates using the specified number of
   * octaves and parameters
   *
   * @param x X-coordinate
   * @param y Y-coordinate
   * @param z Z-coordinate
   * @param octaves Number of octaves to use
   * @param frequency How much to alter the frequency by each octave
   * @param amplitude How much to alter the amplitude by each octave
   * @param normalized If true, normalize the value to [-1, 1]
   * @return Resulting noise
  */
  noise(x: number, y: number, z: number, octaves: number, frequency: number, amplitude: number, normalized: boolean): number;
}

}
declare module 'org.bukkit.loot' {
import { Enum } from 'java.lang';
import { Random, Collection } from 'java.util';
import { ItemStack, Inventory } from 'org.bukkit.inventory';
import { NamespacedKey, Keyed, Location } from 'org.bukkit';
import { Entity, HumanEntity } from 'org.bukkit.entity';
/**
 * This enum holds a list of all known {@link LootTable}s offered by Mojang.
 * This list is not guaranteed to be accurate in future versions.
 *
 * See the
 * 
 * Minecraft Wiki for more information on loot tables.
*/
export class LootTables extends Enum<LootTables> {
  static readonly EMPTY: LootTables;
  static readonly ABANDONED_MINESHAFT: LootTables;
  static readonly BURIED_TREASURE: LootTables;
  static readonly DESERT_PYRAMID: LootTables;
  static readonly END_CITY_TREASURE: LootTables;
  static readonly IGLOO_CHEST: LootTables;
  static readonly JUNGLE_TEMPLE: LootTables;
  static readonly JUNGLE_TEMPLE_DISPENSER: LootTables;
  static readonly NETHER_BRIDGE: LootTables;
  static readonly PILLAGER_OUTPOST: LootTables;
  static readonly BASTION_TREASURE: LootTables;
  static readonly BASTION_OTHER: LootTables;
  static readonly BASTION_BRIDGE: LootTables;
  static readonly BASTION_HOGLIN_STABLE: LootTables;
  static readonly RUINED_PORTAL: LootTables;
  static readonly SHIPWRECK_MAP: LootTables;
  static readonly SHIPWRECK_SUPPLY: LootTables;
  static readonly SHIPWRECK_TREASURE: LootTables;
  static readonly SIMPLE_DUNGEON: LootTables;
  static readonly SPAWN_BONUS_CHEST: LootTables;
  static readonly STRONGHOLD_CORRIDOR: LootTables;
  static readonly STRONGHOLD_CROSSING: LootTables;
  static readonly STRONGHOLD_LIBRARY: LootTables;
  static readonly UNDERWATER_RUIN_BIG: LootTables;
  static readonly UNDERWATER_RUIN_SMALL: LootTables;
  static readonly VILLAGE_ARMORER: LootTables;
  static readonly VILLAGE_BUTCHER: LootTables;
  static readonly VILLAGE_CARTOGRAPHER: LootTables;
  static readonly VILLAGE_DESERT_HOUSE: LootTables;
  static readonly VILLAGE_FISHER: LootTables;
  static readonly VILLAGE_FLETCHER: LootTables;
  static readonly VILLAGE_MASON: LootTables;
  static readonly VILLAGE_PLAINS_HOUSE: LootTables;
  static readonly VILLAGE_SAVANNA_HOUSE: LootTables;
  static readonly VILLAGE_SHEPHERD: LootTables;
  static readonly VILLAGE_SNOWY_HOUSE: LootTables;
  static readonly VILLAGE_TAIGA_HOUSE: LootTables;
  static readonly VILLAGE_TANNERY: LootTables;
  static readonly VILLAGE_TEMPLE: LootTables;
  static readonly VILLAGE_TOOLSMITH: LootTables;
  static readonly VILLAGE_WEAPONSMITH: LootTables;
  static readonly WOODLAND_MANSION: LootTables;
  static readonly ARMOR_STAND: LootTables;
  static readonly AXOLOTL: LootTables;
  static readonly BAT: LootTables;
  static readonly BEE: LootTables;
  static readonly BLAZE: LootTables;
  static readonly CAT: LootTables;
  static readonly CAVE_SPIDER: LootTables;
  static readonly CHICKEN: LootTables;
  static readonly COD: LootTables;
  static readonly COW: LootTables;
  static readonly CREEPER: LootTables;
  static readonly DOLPHIN: LootTables;
  static readonly DONKEY: LootTables;
  static readonly DROWNED: LootTables;
  static readonly ELDER_GUARDIAN: LootTables;
  static readonly ENDER_DRAGON: LootTables;
  static readonly ENDERMAN: LootTables;
  static readonly ENDERMITE: LootTables;
  static readonly EVOKER: LootTables;
  static readonly FOX: LootTables;
  static readonly GHAST: LootTables;
  static readonly GIANT: LootTables;
  static readonly GLOW_SQUID: LootTables;
  static readonly GOAT: LootTables;
  static readonly GUARDIAN: LootTables;
  static readonly HOGLIN: LootTables;
  static readonly HORSE: LootTables;
  static readonly HUSK: LootTables;
  static readonly ILLUSIONER: LootTables;
  static readonly IRON_GOLEM: LootTables;
  static readonly LLAMA: LootTables;
  static readonly MAGMA_CUBE: LootTables;
  static readonly MOOSHROOM: LootTables;
  static readonly MULE: LootTables;
  static readonly OCELOT: LootTables;
  static readonly PANDA: LootTables;
  static readonly PARROT: LootTables;
  static readonly PHANTOM: LootTables;
  static readonly PIG: LootTables;
  static readonly PIGLIN: LootTables;
  static readonly PIGLIN_BRUTE: LootTables;
  static readonly PILLAGER: LootTables;
  static readonly PLAYER: LootTables;
  static readonly POLAR_BEAR: LootTables;
  static readonly PUFFERFISH: LootTables;
  static readonly RABBIT: LootTables;
  static readonly RAVAGER: LootTables;
  static readonly SALMON: LootTables;
  static readonly SHULKER: LootTables;
  static readonly SILVERFISH: LootTables;
  static readonly SKELETON: LootTables;
  static readonly SKELETON_HORSE: LootTables;
  static readonly SLIME: LootTables;
  static readonly SNOW_GOLEM: LootTables;
  static readonly SPIDER: LootTables;
  static readonly SQUID: LootTables;
  static readonly STRAY: LootTables;
  static readonly STRIDER: LootTables;
  static readonly TRADER_LLAMA: LootTables;
  static readonly TROPICAL_FISH: LootTables;
  static readonly TURTLE: LootTables;
  static readonly VEX: LootTables;
  static readonly VILLAGER: LootTables;
  static readonly VINDICATOR: LootTables;
  static readonly WANDERING_TRADER: LootTables;
  static readonly WITCH: LootTables;
  static readonly WITHER: LootTables;
  static readonly WITHER_SKELETON: LootTables;
  static readonly WOLF: LootTables;
  static readonly ZOGLIN: LootTables;
  static readonly ZOMBIE: LootTables;
  static readonly ZOMBIE_HORSE: LootTables;
  static readonly ZOMBIE_VILLAGER: LootTables;
  static readonly ZOMBIFIED_PIGLIN: LootTables;
  static readonly ARMORER_GIFT: LootTables;
  static readonly BUTCHER_GIFT: LootTables;
  static readonly CARTOGRAPHER_GIFT: LootTables;
  static readonly CAT_MORNING_GIFT: LootTables;
  static readonly CLERIC_GIFT: LootTables;
  static readonly FARMER_GIFT: LootTables;
  static readonly FISHERMAN_GIFT: LootTables;
  static readonly FISHING: LootTables;
  static readonly FISHING_FISH: LootTables;
  static readonly FISHING_JUNK: LootTables;
  static readonly FISHING_TREASURE: LootTables;
  static readonly FLETCHER_GIFT: LootTables;
  static readonly LEATHERWORKER_GIFT: LootTables;
  static readonly LIBRARIAN_GIFT: LootTables;
  static readonly MASON_GIFT: LootTables;
  static readonly SHEPHERD_GIFT: LootTables;
  static readonly TOOLSMITH_GIFT: LootTables;
  static readonly WEAPONSMITH_GIFT: LootTables;
  static readonly PIGLIN_BARTERING: LootTables;
  static readonly SHEEP: LootTables;
  static readonly SHEEP_BLACK: LootTables;
  static readonly SHEEP_BLUE: LootTables;
  static readonly SHEEP_BROWN: LootTables;
  static readonly SHEEP_CYAN: LootTables;
  static readonly SHEEP_GRAY: LootTables;
  static readonly SHEEP_GREEN: LootTables;
  static readonly SHEEP_LIGHT_BLUE: LootTables;
  static readonly SHEEP_LIGHT_GRAY: LootTables;
  static readonly SHEEP_LIME: LootTables;
  static readonly SHEEP_MAGENTA: LootTables;
  static readonly SHEEP_ORANGE: LootTables;
  static readonly SHEEP_PINK: LootTables;
  static readonly SHEEP_PURPLE: LootTables;
  static readonly SHEEP_RED: LootTables;
  static readonly SHEEP_WHITE: LootTables;
  static readonly SHEEP_YELLOW: LootTables;
  static valueOf(name: string): LootTables;
  static values(): LootTables[];
  getKey(): NamespacedKey;
  /**
   * Get the {@link LootTable} corresponding to this constant. This is
   * equivalent to calling `Bukkit.getLootTable(this.getKey());`.
   *
   * @return the associated LootTable
  */
  getLootTable(): LootTable;
}
/**
 * Represents additional information a {@link LootTable} can use to modify it's
 * generated loot.
*/
export class LootContext {
  static readonly DEFAULT_LOOT_MODIFIER: number;
  /**
   * The {@link Location} to store where the loot will be generated.
   *
   * @return the Location of where the loot will be generated
  */
  getLocation(): Location;
  /**
   * Represents the {@link org.bukkit.potion.PotionEffectType#LUCK} that an
   * entity can have. The higher the value the better chance of receiving more
   * loot.
   *
   * @return luck
  */
  getLuck(): number;
  /**
   * Represents the
   * {@link org.bukkit.enchantments.Enchantment#LOOT_BONUS_MOBS} the
   * {@link #getKiller()} entity has on their equipped item.
   *
   * This value is only set via
   * {@link LootContext.Builder#lootingModifier(int)}. If not set, the
   * {@link #getKiller()} entity's looting level will be used instead.
   *
   * @return the looting level
  */
  getLootingModifier(): number;
  /**
   * Get the {@link Entity} that was killed. Can be null.
   *
   * @return the looted entity or null
  */
  getLootedEntity(): Entity | null;
  /**
   * Get the {@link HumanEntity} who killed the {@link #getLootedEntity()}.
   * Can be null.
   *
   * @return the killer entity, or null.
  */
  getKiller(): HumanEntity | null;
}
/**
 * LootTables are technical files that represent what items should be in
 * naturally generated containers, what items should be dropped when killing a
 * mob, or what items can be fished.
 *
 * See the 
 * Minecraft Wiki for more information.
*/
export class LootTable extends Keyed {
  /**
   * Returns a mutable list of loot generated by this LootTable.
   *
   * @param random the random instance to use to generate loot
   * @param context context within to populate loot
   * @return a list of ItemStacks
  */
  populateLoot(random: Random | null, context: LootContext): Collection<ItemStack>;
  /**
   * Attempt to fill an inventory with this LootTable's loot.
   *
   * @param inventory the inventory to fill
   * @param random the random instance to use to generate loot
   * @param context context within to populate loot
  */
  fillInventory(inventory: Inventory, random: Random | null, context: LootContext): void;
}
/**
 * Represents a {@link org.bukkit.block.Container} or a
 * {@link org.bukkit.entity.Mob} that can have a loot table.
 * 
 * Container loot will only generate upon opening, and only when the container
 * is first opened.
 * 
 * Entities will only generate loot upon death.
*/
export class Lootable {
  /**
   * Set the loot table for a container or entity.
   * 
   * To remove a loot table use null. Do not use {@link LootTables#EMPTY} to
   * clear a LootTable.
   *
   * @param table the Loot Table this {@link org.bukkit.block.Container} or
   * {@link org.bukkit.entity.Mob} will have.
  */
  setLootTable(lootTable: LootTable | null);
  /**
   * Gets the Loot Table attached to this block or entity.
   * 
   *
   * If an block/entity does not have a loot table, this will return null, NOT
   * an empty loot table.
   *
   * @return the Loot Table attached to this block or entity.
  */
  getLootTable(): LootTable | null;
  /**
   * Set the loot table and seed for a container or entity at the same time.
   *
   * @param table the Loot Table this {@link org.bukkit.block.Container} or {@link org.bukkit.entity.Mob} will have.
   * @param seed the seed to used to generate loot. Default is 0.
  */
  setLootTable(table: LootTable | null, seed: number): void;
  /**
   * Returns whether or not this object has a Loot Table
   * @return Has a loot table
  */
  hasLootTable(): boolean;
  /**
   * Clears the associated Loot Table to this object
  */
  clearLootTable(): void;
  /**
   * Set the seed used when this Loot Table generates loot.
   *
   * @param seed the seed to used to generate loot. Default is 0.
  */
  setSeed(seed: number);
  /**
   * Get the Loot Table's seed.
   * 
   * The seed is used when generating loot.
   *
   * @return the seed
  */
  getSeed(): number;
}

}
declare module 'org.bukkit.event.command' {
import { Component } from 'net.kyori.adventure.text';
import { CommandSender } from 'org.bukkit.command';
import { HandlerList, Event } from 'org.bukkit.event';
/**
 * Thrown when a player executes a command that is not defined
*/
export class UnknownCommandEvent extends Event {
  constructor(sender: CommandSender, commandLine: string, message: string | null);
  constructor(sender: CommandSender, commandLine: string, message: Component | null);
  /**
   * Gets the CommandSender or ConsoleCommandSender
   * 
   *
   * @return Sender of the command
  */
  getSender(): CommandSender;
  /**
   * Gets the command that was send
   * 
   *
   * @return Command sent
  */
  getCommandLine(): string;
  /**
   * Gets message that will be returned
   * 
   *
   * @return Unknown command message
   * @deprecated use {@link #message()}
  */
  getMessage(): string | null;
  /**
   * Sets message that will be returned
   * 
   * Set to null to avoid any message being sent
   *
   * @param message the message to be returned, or null
   * @deprecated use {@link #message(Component)}
  */
  setMessage(message: string | null): void;
  /**
   * Sets message that will be returned
   * 
   * Set to null to avoid any message being sent
   *
   * @param message the message to be returned, or null
  */
  message(message: Component | null): void;
  getHandlers(): HandlerList;
  static getHandlerList(): HandlerList;
}

}
declare module 'org.bukkit.event.world' {
import { Collection, List } from 'java.util';
import { BlockState } from 'org.bukkit.block';
import { LootTable, LootContext } from 'org.bukkit.loot';
import { CreateReason } from 'org.bukkit.event.world.PortalCreateEvent';
import { HandlerList, Cancellable, Event } from 'org.bukkit.event';
import { SkipReason } from 'org.bukkit.event.world.TimeSkipEvent';
import { ItemStack, InventoryHolder } from 'org.bukkit.inventory';
import { Entity, Player } from 'org.bukkit.entity';
import { TreeType, GameEvent, World, Chunk, Location } from 'org.bukkit';
/**
 * Called when the time skips in a world.
 * 
 * If the event is cancelled the time will not change.
*/
export class TimeSkipEvent extends WorldEvent {
  constructor(world: World, skipReason: SkipReason, skipAmount: number);
  /**
   * Gets the reason why the time has skipped.
   *
   * @return a SkipReason value detailing why the time has skipped
  */
  getSkipReason(): SkipReason;
  /**
   * Gets the amount of time that was skipped.
   *
   * @return Amount of time skipped
  */
  getSkipAmount(): number;
  /**
   * Sets the amount of time to skip.
   *
   * @param skipAmount Amount of time to skip
  */
  setSkipAmount(skipAmount: number);
  /**
   * Gets the cancellation state of this event. A cancelled event will not
   * be executed in the server, but will still pass to other plugins
   *
   * @return true if this event is cancelled
  */
  isCancelled(): boolean;
  /**
   * Sets the cancellation state of this event. A cancelled event will not
   * be executed in the server, but will still pass to other plugins.
   *
   * @param cancel true if you wish to cancel this event
  */
  setCancelled(cancel: boolean): void;
  getHandlers(): HandlerList;
  static getHandlerList(): HandlerList;
}
export interface TimeSkipEvent extends WorldEvent, Cancellable {}
/**
 * Represents events within a world
*/
export class WorldEvent extends Event {
  constructor(world: World);
  /**
   * Gets the world primarily involved with this event
   *
   * @return World which caused this event
  */
  getWorld(): World;
}
/**
 * Called when a World is saved.
*/
export class WorldSaveEvent extends WorldEvent {
  constructor(world: World);
  getHandlers(): HandlerList;
  static getHandlerList(): HandlerList;
}
/**
 * Event that is called when an organic structure attempts to grow (Sapling {@literal ->}
 * Tree), (Mushroom {@literal ->} Huge Mushroom), naturally or using bonemeal.
*/
export class StructureGrowEvent extends WorldEvent {
  constructor(location: Location, species: TreeType, bonemeal: boolean, player: Player | null, blocks: BlockState[]);
  /**
   * Gets the location of the structure.
   *
   * @return Location of the structure
  */
  getLocation(): Location;
  /**
   * Gets the species type (birch, normal, pine, red mushroom, brown
   * mushroom)
   *
   * @return Structure species
  */
  getSpecies(): TreeType;
  /**
   * Checks if structure was grown using bonemeal.
   *
   * @return True if the structure was grown using bonemeal.
  */
  isFromBonemeal(): boolean;
  /**
   * Gets the player that created the structure.
   *
   * @return Player that created the structure, null if was not created
   *     manually
  */
  getPlayer(): Player | null;
  /**
   * Gets a list of all blocks associated with the structure.
   *
   * @return list of all blocks associated with the structure.
  */
  getBlocks(): BlockState[];
  /**
   * Gets the cancellation state of this event. A cancelled event will not
   * be executed in the server, but will still pass to other plugins
   *
   * @return true if this event is cancelled
  */
  isCancelled(): boolean;
  /**
   * Sets the cancellation state of this event. A cancelled event will not
   * be executed in the server, but will still pass to other plugins.
   *
   * @param cancel true if you wish to cancel this event
  */
  setCancelled(cancel: boolean): void;
  getHandlers(): HandlerList;
  static getHandlerList(): HandlerList;
}
export interface StructureGrowEvent extends WorldEvent, Cancellable {}
/**
 * Called when a World is unloaded
*/
export class WorldUnloadEvent extends WorldEvent {
  constructor(world: World);
  /**
   * Gets the cancellation state of this event. A cancelled event will not
   * be executed in the server, but will still pass to other plugins
   *
   * @return true if this event is cancelled
  */
  isCancelled(): boolean;
  /**
   * Sets the cancellation state of this event. A cancelled event will not
   * be executed in the server, but will still pass to other plugins.
   *
   * @param cancel true if you wish to cancel this event
  */
  setCancelled(cancel: boolean): void;
  getHandlers(): HandlerList;
  static getHandlerList(): HandlerList;
}
export interface WorldUnloadEvent extends WorldEvent, Cancellable {}
/**
 * Represents a Chunk related event
*/
export class ChunkEvent extends WorldEvent {
  /**
   * Gets the chunk being loaded/unloaded
   *
   * @return Chunk that triggered this event
  */
  getChunk(): Chunk;
}
/**
 * Called when a {@link LootTable} is generated in the world for an
 * {@link InventoryHolder}.
 *
 * This event is NOT currently called when an entity's loot table has been
 * generated (use {@link EntityDeathEvent#getDrops()}, but WILL be called by
 * plugins invoking
 * {@link LootTable#fillInventory(org.bukkit.inventory.Inventory, java.util.Random, LootContext)}.
*/
export class LootGenerateEvent extends WorldEvent {
  constructor(world: World, entity: Entity | null, inventoryHolder: InventoryHolder | null, lootTable: LootTable, lootContext: LootContext, items: ItemStack[], plugin: boolean);
  /**
   * Get the entity used as context for loot generation (if applicable).
   *
   * For inventories where entities are not required to generate loot, such as
   * hoppers, null will be returned.
   *
   * This is a convenience method for
   * `getLootContext().getLootedEntity()`.
   *
   * @return the entity
  */
  getEntity(): Entity | null;
  /**
   * Get the inventory holder in which the loot was generated.
   *
   * If the loot was generated as a result of the block being broken, the
   * inventory holder will be null as this event is called post block break.
   *
   * @return the inventory holder
  */
  getInventoryHolder(): InventoryHolder | null;
  /**
   * Get the loot table used to generate loot.
   *
   * @return the loot table
  */
  getLootTable(): LootTable;
  /**
   * Get the loot context used to provide context to the loot table's loot
   * generation.
   *
   * @return the loot context
  */
  getLootContext(): LootContext;
  /**
   * Set the loot to be generated. Null items will be treated as air.
   *
   * Note: the set collection is not the one which will be returned by
   * {@link #getLoot()}.
   *
   * @param loot the loot to generate, null to clear all loot
  */
  setLoot(loot: Collection<ItemStack> | null);
  /**
   * Get a mutable list of all loot to be generated.
   *
   * Any items added or removed from the returned list will be reflected in
   * the loot generation. Null items will be treated as air.
   *
   * @return the loot to generate
  */
  getLoot(): ItemStack[];
  /**
   * Check whether or not this event was called as a result of a plugin
   * invoking
   * {@link LootTable#fillInventory(org.bukkit.inventory.Inventory, java.util.Random, LootContext)}.
   *
   * @return true if plugin caused, false otherwise
  */
  isPlugin(): boolean;
  /**
   * Sets the cancellation state of this event. A cancelled event will not
   * be executed in the server, but will still pass to other plugins.
   *
   * @param cancel true if you wish to cancel this event
  */
  setCancelled(cancel: boolean): void;
  /**
   * Gets the cancellation state of this event. A cancelled event will not
   * be executed in the server, but will still pass to other plugins
   *
   * @return true if this event is cancelled
  */
  isCancelled(): boolean;
  getHandlers(): HandlerList;
  static getHandlerList(): HandlerList;
}
export interface LootGenerateEvent extends WorldEvent, Cancellable {}
/**
 * Thrown when a newly generated chunk has finished being populated.
 * 
 * Note: Do not use this to generated blocks in a newly generated chunk.
 * Use a {@link BlockPopulator} instead.
*/
export class ChunkPopulateEvent extends ChunkEvent {
  constructor(chunk: Chunk);
  getHandlers(): HandlerList;
  static getHandlerList(): HandlerList;
}
/**
 * Called when a chunk is unloaded
*/
export class ChunkUnloadEvent extends ChunkEvent {
  constructor(chunk: Chunk);
  constructor(chunk: Chunk, save: boolean);
  /**
   * Return whether this chunk will be saved to disk.
   *
   * @return chunk save status
  */
  isSaveChunk(): boolean;
  /**
   * Set whether this chunk will be saved to disk.
   *
   * @param saveChunk chunk save status
  */
  setSaveChunk(saveChunk: boolean): void;
  getHandlers(): HandlerList;
  static getHandlerList(): HandlerList;
}
/**
 * Called when a World is initializing.
 * 
 * To get every world it is recommended to add following to the plugin.yml.
 * load: STARTUP
*/
export class WorldInitEvent extends WorldEvent {
  constructor(world: World);
  getHandlers(): HandlerList;
  static getHandlerList(): HandlerList;
}
/**
 * Called when a World is loaded
*/
export class WorldLoadEvent extends WorldEvent {
  constructor(world: World);
  getHandlers(): HandlerList;
  static getHandlerList(): HandlerList;
}
/**
 * Called when a portal is created
*/
export class PortalCreateEvent extends WorldEvent {
  constructor(blocks: BlockState[], world: World, reason: CreateReason);
  constructor(blocks: BlockState[], world: World, entity: Entity | null, reason: CreateReason);
  /**
   * Gets an array list of all the blocks associated with the created portal
   *
   * @return array list of all the blocks associated with the created portal
  */
  getBlocks(): BlockState[];
  /**
   * Returns the Entity that triggered this portal creation (if available)
   *
   * @return Entity involved in this event
  */
  getEntity(): Entity | null;
  /**
   * Gets the cancellation state of this event. A cancelled event will not
   * be executed in the server, but will still pass to other plugins
   *
   * @return true if this event is cancelled
  */
  isCancelled(): boolean;
  /**
   * Sets the cancellation state of this event. A cancelled event will not
   * be executed in the server, but will still pass to other plugins.
   *
   * @param cancel true if you wish to cancel this event
  */
  setCancelled(cancel: boolean): void;
  /**
   * Gets the reason for the portal's creation
   *
   * @return CreateReason for the portal's creation
  */
  getReason(): CreateReason;
  getHandlers(): HandlerList;
  static getHandlerList(): HandlerList;
}
export interface PortalCreateEvent extends WorldEvent, Cancellable {}
/**
 * Called when entities are unloaded.
 *
 * The provided chunk may or may not be loaded.
*/
export class EntitiesUnloadEvent extends ChunkEvent {
  constructor(chunk: Chunk, entities: Entity[]);
  /**
   * Get the entities which are being unloaded.
   *
   * @return unmodifiable list of unloaded entities.
  */
  getEntities(): Entity[];
  getHandlers(): HandlerList;
  static getHandlerList(): HandlerList;
}
/**
 * Called when entities are loaded.
 *
 * The provided chunk may or may not be loaded.
*/
export class EntitiesLoadEvent extends ChunkEvent {
  constructor(chunk: Chunk, entities: Entity[]);
  /**
   * Get the entities which are being loaded.
   *
   * @return unmodifiable list of loaded entities.
  */
  getEntities(): Entity[];
  getHandlers(): HandlerList;
  static getHandlerList(): HandlerList;
}
/**
 * An event that is called when a world's spawn changes. The world's previous
 * spawn location is included.
*/
export class SpawnChangeEvent extends WorldEvent {
  constructor(world: World, previousLocation: Location);
  /**
   * Gets the previous spawn location
   *
   * @return Location that used to be spawn
  */
  getPreviousLocation(): Location;
  getHandlers(): HandlerList;
  static getHandlerList(): HandlerList;
}
/**
 * Represents a generic Mojang game event.
 *
 * Specific Bukkit events should be used where possible, this event is mainly
 * used internally by Sculk sensors.
*/
export class GenericGameEvent extends WorldEvent {
  constructor(event: GameEvent, location: Location, entity: Entity | null, radius: number);
  /**
   * Get the underlying event.
   *
   * @return the event
  */
  getEvent(): GameEvent;
  /**
   * Get the location where the event occurred.
   *
   * @return event location
  */
  getLocation(): Location;
  /**
   * Get the entity which triggered this event, if present.
   *
   * @return triggering entity or null
  */
  getEntity(): Entity | null;
  /**
   * Get the block radius to which this event will be broadcast.
   *
   * @return broadcast radius
  */
  getRadius(): number;
  /**
   * Set the radius to which the event should be broadcast.
   *
   * @param radius radius, must be greater than or equal to 0
  */
  setRadius(radius: number);
  /**
   * Sets the cancellation state of this event. A cancelled event will not
   * be executed in the server, but will still pass to other plugins.
   *
   * @param cancel true if you wish to cancel this event
  */
  setCancelled(cancel: boolean): void;
  /**
   * Gets the cancellation state of this event. A cancelled event will not
   * be executed in the server, but will still pass to other plugins
   *
   * @return true if this event is cancelled
  */
  isCancelled(): boolean;
  getHandlers(): HandlerList;
  static getHandlerList(): HandlerList;
}
export interface GenericGameEvent extends WorldEvent, Cancellable {}
/**
 * Called when a chunk is loaded
*/
export class ChunkLoadEvent extends ChunkEvent {
  constructor(chunk: Chunk, newChunk: boolean);
  /**
   * Gets if this chunk was newly created or not.
   * 
   * Note: Do not use this to generated blocks in a newly generated chunk.
   * Use a {@link BlockPopulator} instead.
   *
   * @return true if the chunk is new, otherwise false
  */
  isNewChunk(): boolean;
  getHandlers(): HandlerList;
  static getHandlerList(): HandlerList;
}

}
declare module 'org.bukkit.entity.Spellcaster' {
import { Enum } from 'java.lang';
/**
 * Represents the current spell the entity is using.
*/
export class Spell extends Enum<Spell> {
  /**
   * No spell is being used..
  */
  static readonly NONE: Spell;
  /**
   * The spell that summons Vexes.
  */
  static readonly SUMMON_VEX: Spell;
  /**
   * The spell that summons Fangs.
  */
  static readonly FANGS: Spell;
  /**
   * The "wololo" spell.
  */
  static readonly WOLOLO: Spell;
  /**
   * The spell that makes the casting entity invisible.
  */
  static readonly DISAPPEAR: Spell;
  /**
   * The spell that makes the target blind.
  */
  static readonly BLINDNESS: Spell;
  static valueOf(name: string): Spell;
  static values(): Spell[];
}

}
declare module 'org.bukkit.profile.PlayerTextures' {
import { Enum } from 'java.lang';
/**
 * The different Minecraft skin models.
*/
export class SkinModel extends Enum<SkinModel> {
  /**
   * The classic Minecraft skin model.
  */
  static readonly CLASSIC: SkinModel;
  /**
   * The slim model has slimmer arms than the classic model.
  */
  static readonly SLIM: SkinModel;
  static valueOf(name: string): SkinModel;
  static values(): SkinModel[];
}

}
declare module 'org.bukkit.event.weather' {
import { Cause as org_bukkit_event_weather_LightningStrikeEvent_Cause } from 'org.bukkit.event.weather.LightningStrikeEvent';
import { Cause as org_bukkit_event_weather_ThunderChangeEvent_Cause } from 'org.bukkit.event.weather.ThunderChangeEvent';
import { HandlerList, Cancellable, Event } from 'org.bukkit.event';
import { Cause } from 'org.bukkit.event.weather.WeatherChangeEvent';
import { World } from 'org.bukkit';
import { LightningStrike } from 'org.bukkit.entity';
/**
 * Stores data for weather changing in a world
*/
export class WeatherChangeEvent extends WeatherEvent {
  constructor(world: World, to: boolean, cause: Cause);
  constructor(world: World, to: boolean);
  /**
   * Gets the cancellation state of this event. A cancelled event will not
   * be executed in the server, but will still pass to other plugins
   *
   * @return true if this event is cancelled
  */
  isCancelled(): boolean;
  /**
   * Sets the cancellation state of this event. A cancelled event will not
   * be executed in the server, but will still pass to other plugins.
   *
   * @param cancel true if you wish to cancel this event
  */
  setCancelled(cancel: boolean): void;
  /**
   * Gets the state of weather that the world is being set to
   *
   * @return true if the weather is being set to raining, false otherwise
  */
  toWeatherState(): boolean;
  getHandlers(): HandlerList;
  static getHandlerList(): HandlerList;
  /**
   * Gets the cause of the weather change.
   *
   * @return the weather change cause
  */
  getCause(): Cause;
}
export interface WeatherChangeEvent extends WeatherEvent, Cancellable {}
/**
 * Stores data for lightning striking
*/
export class LightningStrikeEvent extends WeatherEvent {
  constructor(world: World, bolt: LightningStrike);
  constructor(world: World, bolt: LightningStrike, cause: org_bukkit_event_weather_LightningStrikeEvent_Cause);
  /**
   * Gets the cancellation state of this event. A cancelled event will not
   * be executed in the server, but will still pass to other plugins
   *
   * @return true if this event is cancelled
  */
  isCancelled(): boolean;
  /**
   * Sets the cancellation state of this event. A cancelled event will not
   * be executed in the server, but will still pass to other plugins.
   *
   * @param cancel true if you wish to cancel this event
  */
  setCancelled(cancel: boolean): void;
  /**
   * Gets the bolt which is striking the earth.
   *
   * @return lightning entity
  */
  getLightning(): LightningStrike;
  /**
   * Gets the cause of this lightning strike.
   *
   * @return strike cause
  */
  getCause(): org_bukkit_event_weather_LightningStrikeEvent_Cause;
  getHandlers(): HandlerList;
  static getHandlerList(): HandlerList;
}
export interface LightningStrikeEvent extends WeatherEvent, Cancellable {}
/**
 * Stores data for thunder state changing in a world
*/
export class ThunderChangeEvent extends WeatherEvent {
  constructor(world: World, to: boolean, cause: org_bukkit_event_weather_ThunderChangeEvent_Cause);
  constructor(world: World, to: boolean);
  /**
   * Gets the cancellation state of this event. A cancelled event will not
   * be executed in the server, but will still pass to other plugins
   *
   * @return true if this event is cancelled
  */
  isCancelled(): boolean;
  /**
   * Sets the cancellation state of this event. A cancelled event will not
   * be executed in the server, but will still pass to other plugins.
   *
   * @param cancel true if you wish to cancel this event
  */
  setCancelled(cancel: boolean): void;
  /**
   * Gets the state of thunder that the world is being set to
   *
   * @return true if the weather is being set to thundering, false otherwise
  */
  toThunderState(): boolean;
  getHandlers(): HandlerList;
  static getHandlerList(): HandlerList;
  /**
   * Gets the cause of the weather change.
   *
   * @return the weather change cause
  */
  getCause(): org_bukkit_event_weather_ThunderChangeEvent_Cause;
}
export interface ThunderChangeEvent extends WeatherEvent, Cancellable {}
/**
 * Represents a Weather-related event
*/
export class WeatherEvent extends Event {
  constructor(where: World);
  /**
   * Returns the World where this event is occurring
   *
   * @return World this event is occurring in
  */
  getWorld(): World;
}

}
declare module 'org.bukkit.event.player.PlayerResourcePackStatusEvent' {
import { Enum } from 'java.lang';
/**
 * Status of the resource pack.
*/
export class Status extends Enum<Status> {
  /**
   * The resource pack has been successfully downloaded and applied to the
   * client.
  */
  static readonly SUCCESSFULLY_LOADED: Status;
  /**
   * The client refused to accept the resource pack.
  */
  static readonly DECLINED: Status;
  /**
   * The client accepted the pack, but download failed.
  */
  static readonly FAILED_DOWNLOAD: Status;
  /**
   * The client accepted the pack and is beginning a download of it.
  */
  static readonly ACCEPTED: Status;
  static valueOf(name: string): Status;
  static values(): Status[];
}

}
declare module 'org.bukkit.event.player.PlayerPreLoginEvent' {
import { Enum } from 'java.lang';
/**
 * Basic kick reasons for communicating to plugins
*/
export class Result extends Enum<Result> {
  /**
   * The player is allowed to log in
  */
  static readonly ALLOWED: Result;
  /**
   * The player is not allowed to log in, due to the server being full
  */
  static readonly KICK_FULL: Result;
  /**
   * The player is not allowed to log in, due to them being banned
  */
  static readonly KICK_BANNED: Result;
  /**
   * The player is not allowed to log in, due to them not being on the
   * white list
  */
  static readonly KICK_WHITELIST: Result;
  /**
   * The player is not allowed to log in, for reasons undefined
  */
  static readonly KICK_OTHER: Result;
  static valueOf(name: string): Result;
  static values(): Result[];
}

}
declare module 'org.bukkit.event.raid.RaidStopEvent' {
import { Enum } from 'java.lang';
export class Reason extends Enum<Reason> {
  /**
   * Because the difficulty has been changed to peaceful.
  */
  static readonly PEACE: Reason;
  /**
   * The raid took a long time without a final result.
  */
  static readonly TIMEOUT: Reason;
  /**
   * Finished the raid.
  */
  static readonly FINISHED: Reason;
  /**
   * Couldn't find a suitable place to spawn raiders.
  */
  static readonly UNSPAWNABLE: Reason;
  /**
   * The place where the raid occurs no longer be a village.
  */
  static readonly NOT_IN_VILLAGE: Reason;
  static valueOf(name: string): Reason;
  static values(): Reason[];
}

}
declare module 'org.bukkit.event.enchantment' {
import { Map } from 'java.util';
import { Block } from 'org.bukkit.block';
import { InventoryEvent } from 'org.bukkit.event.inventory';
import { EnchantmentOffer, Enchantment } from 'org.bukkit.enchantments';
import { HandlerList, Cancellable } from 'org.bukkit.event';
import { Player } from 'org.bukkit.entity';
import { InventoryView, ItemStack } from 'org.bukkit.inventory';
/**
 * Called when an ItemStack is successfully enchanted (currently at
 * enchantment table)
*/
export class EnchantItemEvent extends InventoryEvent {
  constructor(enchanter: Player, view: InventoryView, table: Block, item: ItemStack, level: number, enchants: Map<Enchantment, number>, i: number);
  /**
   * Gets the player enchanting the item
   *
   * @return enchanting player
  */
  getEnchanter(): Player;
  /**
   * Gets the block being used to enchant the item
   *
   * @return the block used for enchanting
  */
  getEnchantBlock(): Block;
  /**
   * Gets the item to be enchanted (can be modified)
   *
   * @return ItemStack of item
  */
  getItem(): ItemStack;
  /**
   * Gets the cost (minimum level) which is displayed as a number on the right
   * hand side of the enchantment offer.
   *
   * @return experience level cost
  */
  getExpLevelCost(): number;
  /**
   * Sets the cost (minimum level) which is displayed as a number on the right
   * hand side of the enchantment offer.
   *
   * @param level - cost in levels
  */
  setExpLevelCost(expLevelCost: number);
  /**
   * Get map of enchantment (levels, keyed by type) to be added to item
   * (modify map returned to change values). Note: Any enchantments not
   * allowed for the item will be ignored
   *
   * @return map of enchantment levels, keyed by enchantment
  */
  getEnchantsToAdd(): Map<Enchantment, number>;
  /**
   * Which button was pressed to initiate the enchanting.
   *
   * @return The button index (0, 1, or 2).
  */
  whichButton(): number;
  /**
   * Gets the cancellation state of this event. A cancelled event will not
   * be executed in the server, but will still pass to other plugins
   *
   * @return true if this event is cancelled
  */
  isCancelled(): boolean;
  /**
   * Sets the cancellation state of this event. A cancelled event will not
   * be executed in the server, but will still pass to other plugins.
   *
   * @param cancel true if you wish to cancel this event
  */
  setCancelled(cancel: boolean): void;
  getHandlers(): HandlerList;
  static getHandlerList(): HandlerList;
}
export interface EnchantItemEvent extends InventoryEvent, Cancellable {}
/**
 * Called when an ItemStack is inserted in an enchantment table - can be
 * called multiple times
*/
export class PrepareItemEnchantEvent extends InventoryEvent {
  constructor(enchanter: Player, view: InventoryView, table: Block, item: ItemStack, offers: EnchantmentOffer[] | null, bonus: number);
  /**
   * Gets the player enchanting the item
   *
   * @return enchanting player
  */
  getEnchanter(): Player;
  /**
   * Gets the block being used to enchant the item
   *
   * @return the block used for enchanting
  */
  getEnchantBlock(): Block;
  /**
   * Gets the item to be enchanted.
   *
   * @return ItemStack of item
  */
  getItem(): ItemStack;
  /**
   * Get a list of offered experience level costs of the enchantment.
   *
   * @return experience level costs offered
   * @deprecated Use {@link #getOffers()} instead of this method
  */
  getExpLevelCostsOffered(): number[];
  /**
   * Get a list of available {@link EnchantmentOffer} for the player. You can
   * modify the values to change the available offers for the player. An offer
   * may be null, if there isn't a enchantment offer at a specific slot. There
   * are 3 slots in the enchantment table available to modify.
   *
   * @return list of available enchantment offers
  */
  getOffers(): EnchantmentOffer[] | null;
  /**
   * Get enchantment bonus in effect - corresponds to number of bookshelves
   *
   * @return enchantment bonus
  */
  getEnchantmentBonus(): number;
  /**
   * Gets the cancellation state of this event. A cancelled event will not
   * be executed in the server, but will still pass to other plugins
   *
   * @return true if this event is cancelled
  */
  isCancelled(): boolean;
  /**
   * Sets the cancellation state of this event. A cancelled event will not
   * be executed in the server, but will still pass to other plugins.
   *
   * @param cancel true if you wish to cancel this event
  */
  setCancelled(cancel: boolean): void;
  getHandlers(): HandlerList;
  static getHandlerList(): HandlerList;
}
export interface PrepareItemEnchantEvent extends InventoryEvent, Cancellable {}

}
declare module 'org.bukkit.util.ChatPaginator' {
export class ChatPage {
  constructor(lines: string[], pageNumber: number, totalPages: number);
  getPageNumber(): number;
  getTotalPages(): number;
  getLines(): string[];
}

}
declare module 'org.bukkit.persistence' {
import { Class } from 'java.lang';
import { Set } from 'java.util';
import { NamespacedKey } from 'org.bukkit';
/**
 * This interface represents the context in which the {@link PersistentDataType} can
 * serialize and deserialize the passed values.
*/
export class PersistentDataAdapterContext {
  /**
   * Creates a new and empty meta container instance.
   *
   * @return the fresh container instance
  */
  newPersistentDataContainer(): PersistentDataContainer;
}
/**
 * The {@link PersistentDataHolder} interface defines an object that can store
 * custom persistent meta data on it.
*/
export class PersistentDataHolder {
  /**
   * Returns a custom tag container capable of storing tags on the object.
   *
   * Note that the tags stored on this container are all stored under their
   * own custom namespace therefore modifying default tags using this
   * {@link PersistentDataHolder} is impossible.
   *
   * @return the persistent metadata container
  */
  getPersistentDataContainer(): PersistentDataContainer;
}
/**
 * This interface represents a map like object, capable of storing custom tags
 * in it.
*/
export class PersistentDataContainer {
  /**
   * Stores a metadata value on the {@link PersistentDataHolder} instance.
   * 
   * This API cannot be used to manipulate minecraft data, as the values will
   * be stored using your namespace. This method will override any existing
   * value the {@link PersistentDataHolder} may have stored under the provided
   * key.
   *
   * @param key the key this value will be stored under
   * @param type the type this tag uses
   * @param value the value stored in the tag
   * @param  the generic java type of the tag value
   * @param  the generic type of the object to store
   *
   * @throws NullPointerException if the key is null
   * @throws NullPointerException if the type is null
   * @throws NullPointerException if the value is null. Removing a tag should
   * be done using {@link #remove(NamespacedKey)}
   * @throws IllegalArgumentException if no suitable adapter will be found for
   * the {@link PersistentDataType#getPrimitiveType()}
  */
  set<T, Z>(key: NamespacedKey, type: PersistentDataType<T, Z>, value: Z): void;
  /**
   * Returns if the persistent metadata provider has metadata registered
   * matching the provided parameters.
   * 
   * This method will only return if the found value has the same primitive
   * data type as the provided key.
   * 
   * Storing a value using a custom {@link PersistentDataType} implementation
   * will not store the complex data type. Therefore storing a UUID (by
   * storing a byte[]) will match has("key" ,
   * {@link PersistentDataType#BYTE_ARRAY}). Likewise a stored byte[] will
   * always match your UUID {@link PersistentDataType} even if it is not 16
   * bytes long.
   * 
   * This method is only usable for custom object keys. Overwriting existing
   * tags, like the the display name, will not work as the values are stored
   * using your namespace.
   *
   * @param key the key the value is stored under
   * @param type the type which primitive storage type has to match the value
   * @param  the generic type of the stored primitive
   * @param  the generic type of the eventually created complex object
   *
   * @return if a value
   *
   * @throws NullPointerException if the key to look up is null
   * @throws NullPointerException if the type to cast the found object to is
   * null
  */
  has<T, Z>(key: NamespacedKey, type: PersistentDataType<T, Z>): boolean;
  /**
   * Returns the metadata value that is stored on the
   * {@link PersistentDataHolder} instance.
   *
   * @param key the key to look up in the custom tag map
   * @param type the type the value must have and will be casted to
   * @param  the generic type of the stored primitive
   * @param  the generic type of the eventually created complex object
   *
   * @return the value or `null` if no value was mapped under the given
   * value
   *
   * @throws NullPointerException if the key to look up is null
   * @throws NullPointerException if the type to cast the found object to is
   * null
   * @throws IllegalArgumentException if the value exists under the given key,
   * but cannot be access using the given type
   * @throws IllegalArgumentException if no suitable adapter will be found for
   * the {@link
   * PersistentDataType#getPrimitiveType()}
  */
  get<T, Z>(key: NamespacedKey, type: PersistentDataType<T, Z>): Z | null;
  /**
   * Returns the metadata value that is stored on the
   * {@link PersistentDataHolder} instance. If the value does not exist in the
   * container, the default value provided is returned.
   *
   * @param key the key to look up in the custom tag map
   * @param type the type the value must have and will be casted to
   * @param defaultValue the default value to return if no value was found for
   * the provided key
   * @param  the generic type of the stored primitive
   * @param  the generic type of the eventually created complex object
   *
   * @return the value or the default value if no value was mapped under the
   * given value
   *
   * @throws NullPointerException if the key to look up is null
   * @throws NullPointerException if the type to cast the found object to is
   * null
   * @throws IllegalArgumentException if the value exists under the given key,
   * but cannot be access using the given type
   * @throws IllegalArgumentException if no suitable adapter will be found for
   * the {@link PersistentDataType#getPrimitiveType()}
  */
  getOrDefault<T, Z>(key: NamespacedKey, type: PersistentDataType<T, Z>, defaultValue: Z): Z;
  /**
   * Get a set of keys present on this {@link PersistentDataContainer}
   * instance.
   *
   * Any changes made to the returned set will not be reflected on the
   * instance.
   *
   * @return the key set
  */
  getKeys(): Set<NamespacedKey>;
  /**
   * Removes a custom key from the {@link PersistentDataHolder} instance.
   *
   * @param key the key
   *
   * @throws NullPointerException if the provided key is null
  */
  remove(key: NamespacedKey): void;
  /**
   * Returns if the container instance is empty, therefore has no entries
   * inside it.
   *
   * @return the boolean
  */
  isEmpty(): boolean;
  /**
   * Returns the adapter context this tag container uses.
   *
   * @return the tag context
  */
  getAdapterContext(): PersistentDataAdapterContext;
  /**
   * Returns if the persistent metadata provider has metadata registered
   * matching the provided key.
   * 
   * @param key the key for which existence should be checked.
   * 
   * @return whether the key exists
   * 
   * @throws NullPointerException if the key to look up is null
  */
  has(key: NamespacedKey): boolean;
}
/**
 * This class represents an enum with a generic content type. It defines the
 * types a custom tag can have.
 * 
 * This interface can be used to create your own custom
 * {@link PersistentDataType} with different complex types. This may be useful
 * for the likes of a UUIDTagType:
 *  * {@code
 * public class UUIDTagType implements PersistentDataType {
 *
 *         {@literal @Override}
 *         public Class getPrimitiveType() {
 *             return byte[].class;
 *         }
 *
 *         {@literal @Override}
 *         public Class getComplexType() {
 *             return UUID.class;
 *         }
 *
 *         {@literal @Override}
 *         public byte[] toPrimitive(UUID complex, PersistentDataAdapterContext context) {
 *             ByteBuffer bb = ByteBuffer.wrap(new byte[16]);
 *             bb.putLong(complex.getMostSignificantBits());
 *             bb.putLong(complex.getLeastSignificantBits());
 *             return bb.array();
 *         }
 *
 *         {@literal @Override}
 *         public UUID fromPrimitive(byte[] primitive, PersistentDataAdapterContext context) {
 *             ByteBuffer bb = ByteBuffer.wrap(primitive);
 *             long firstLong = bb.getLong();
 *             long secondLong = bb.getLong();
 *             return new UUID(firstLong, secondLong);
 *         }
 *     }}
 *
 * @param  the primary object type that is stored in the given tag
 * @param  the retrieved object type when applying this tag type
*/
export class PersistentDataType<T, Z> {
  static readonly BYTE: PersistentDataType<number, number>;
  static readonly SHORT: PersistentDataType<number, number>;
  static readonly INTEGER: PersistentDataType<number, number>;
  static readonly LONG: PersistentDataType<number, number>;
  static readonly FLOAT: PersistentDataType<number, number>;
  static readonly DOUBLE: PersistentDataType<number, number>;
  static readonly STRING: PersistentDataType<string, string>;
  static readonly BYTE_ARRAY: PersistentDataType<number[], number[]>;
  static readonly INTEGER_ARRAY: PersistentDataType<number[], number[]>;
  static readonly LONG_ARRAY: PersistentDataType<number[], number[]>;
  static readonly TAG_CONTAINER_ARRAY: PersistentDataType<PersistentDataContainer[], PersistentDataContainer[]>;
  static readonly TAG_CONTAINER: PersistentDataType<PersistentDataContainer, PersistentDataContainer>;
  /**
   * Returns the primitive data type of this tag.
   *
   * @return the class
  */
  getPrimitiveType(): Class<T>;
  /**
   * Returns the complex object type the primitive value resembles.
   *
   * @return the class type
  */
  getComplexType(): Class<Z>;
  /**
   * Returns the primitive data that resembles the complex object passed to
   * this method.
   *
   * @param complex the complex object instance
   * @param context the context this operation is running in
   * @return the primitive value
  */
  toPrimitive(complex: Z, context: PersistentDataAdapterContext): T;
  /**
   * Creates a complex object based of the passed primitive value
   *
   * @param primitive the primitive value
   * @param context the context this operation is running in
   * @return the complex object instance
  */
  fromPrimitive(primitive: T, context: PersistentDataAdapterContext): Z;
}

}
declare module 'org.bukkit.block.data.type.Stairs' {
import { Enum } from 'java.lang';
/**
 * The shape of a stair block - used for constructing corners.
*/
export class Shape extends Enum<Shape> {
  /**
   * Regular stair block.
  */
  static readonly STRAIGHT: Shape;
  /**
   * Inner corner stair block with higher left side.
  */
  static readonly INNER_LEFT: Shape;
  /**
   * Inner corner stair block with higher right side.
  */
  static readonly INNER_RIGHT: Shape;
  /**
   * Outer corner stair block with higher left side.
  */
  static readonly OUTER_LEFT: Shape;
  /**
   * Outer corner stair block with higher right side.
  */
  static readonly OUTER_RIGHT: Shape;
  static valueOf(name: string): Shape;
  static values(): Shape[];
}

}
declare module 'org.bukkit.entity.Evoker' {
import { Enum } from 'java.lang';
/**
 * Represents the current spell the Evoker is using.
 *
 * @deprecated future versions of Minecraft have additional spell casting
 * entities.
*/
export class Spell extends Enum<Spell> {
  /**
   * No spell is being evoked.
  */
  static readonly NONE: Spell;
  /**
   * The spell that summons Vexes.
  */
  static readonly SUMMON: Spell;
  /**
   * The spell that summons Fangs.
  */
  static readonly FANGS: Spell;
  /**
   * The "wololo" spell.
  */
  static readonly WOLOLO: Spell;
  /**
   * The spell that makes the casting entity invisible.
  */
  static readonly DISAPPEAR: Spell;
  /**
   * The spell that makes the target blind.
  */
  static readonly BLINDNESS: Spell;
  static valueOf(name: string): Spell;
  static values(): Spell[];
}

}
declare module 'org.bukkit.boss' {
import { Enum } from 'java.lang';
import { List } from 'java.util';
import { RespawnPhase } from 'org.bukkit.boss.DragonBattle';
import { Keyed, Location } from 'org.bukkit';
import { Player, EnderDragon } from 'org.bukkit.entity';
export class BossBar {
  /**
   * Returns the title of this boss bar
   *
   * @return the title of the bar
  */
  getTitle(): string;
  /**
   * Sets the title of this boss bar
   *
   * @param title the title of the bar
  */
  setTitle(title: string | null);
  /**
   * Returns the color of this boss bar
   *
   * @return the color of the bar
  */
  getColor(): BarColor;
  /**
   * Sets the color of this boss bar.
   *
   * @param color the color of the bar
  */
  setColor(color: BarColor);
  /**
   * Returns the style of this boss bar
   *
   * @return the style of the bar
  */
  getStyle(): BarStyle;
  /**
   * Sets the bar style of this boss bar
   *
   * @param style the style of the bar
  */
  setStyle(style: BarStyle);
  /**
   * Remove an existing flag on this boss bar
   *
   * @param flag the existing flag to remove
  */
  removeFlag(flag: BarFlag): void;
  /**
   * Add an optional flag to this boss bar
   *
   * @param flag an optional flag to set on the boss bar
  */
  addFlag(flag: BarFlag): void;
  /**
   * Returns whether this boss bar as the passed flag set
   *
   * @param flag the flag to check
   * @return whether it has the flag
  */
  hasFlag(flag: BarFlag): boolean;
  /**
   * Sets the progress of the bar. Values should be between 0.0 (empty) and
   * 1.0 (full)
   *
   * @param progress the progress of the bar
  */
  setProgress(progress: number);
  /**
   * Returns the progress of the bar between 0.0 and 1.0
   *
   * @return the progress of the bar
  */
  getProgress(): number;
  /**
   * Adds the player to this boss bar causing it to display on their screen.
   *
   * @param player the player to add
  */
  addPlayer(player: Player): void;
  /**
   * Removes the player from this boss bar causing it to be removed from their
   * screen.
   *
   * @param player the player to remove
  */
  removePlayer(player: Player): void;
  /**
   * Removes all players from this boss bar
   *
   * @see #removePlayer(Player)
  */
  removeAll(): void;
  /**
   * Returns all players viewing this boss bar
   *
   * @return a immutable list of players
  */
  getPlayers(): Player[];
  /**
   * Set if the boss bar is displayed to attached players.
   *
   * @param visible visible status
  */
  setVisible(visible: boolean): void;
  /**
   * Return if the boss bar is displayed to attached players.
   *
   * @return visible status
  */
  isVisible(): boolean;
  /**
   * Shows the previously hidden boss bar to all attached players
   * @deprecated {@link #setVisible(boolean)}
  */
  show(): void;
  /**
   * Hides this boss bar from all attached players
   * @deprecated {@link #setVisible(boolean)}
  */
  hide(): void;
}
export class BarStyle extends Enum<BarStyle> {
  /**
   * Makes the boss bar solid (no segments)
  */
  static readonly SOLID: BarStyle;
  /**
   * Splits the boss bar into 6 segments
  */
  static readonly SEGMENTED_6: BarStyle;
  /**
   * Splits the boss bar into 10 segments
  */
  static readonly SEGMENTED_10: BarStyle;
  /**
   * Splits the boss bar into 12 segments
  */
  static readonly SEGMENTED_12: BarStyle;
  /**
   * Splits the boss bar into 20 segments
  */
  static readonly SEGMENTED_20: BarStyle;
  static valueOf(name: string): BarStyle;
  static values(): BarStyle[];
}
export class BarFlag extends Enum<BarFlag> {
  /**
   * Darkens the sky like during fighting a wither.
  */
  static readonly DARKEN_SKY: BarFlag;
  /**
   * Tells the client to play the Ender Dragon boss music.
  */
  static readonly PLAY_BOSS_MUSIC: BarFlag;
  /**
   * Creates fog around the world.
  */
  static readonly CREATE_FOG: BarFlag;
  static valueOf(name: string): BarFlag;
  static values(): BarFlag[];
}
export class BarColor extends Enum<BarColor> {
  static readonly PINK: BarColor;
  static readonly BLUE: BarColor;
  static readonly RED: BarColor;
  static readonly GREEN: BarColor;
  static readonly YELLOW: BarColor;
  static readonly PURPLE: BarColor;
  static readonly WHITE: BarColor;
  static valueOf(name: string): BarColor;
  static values(): BarColor[];
}
/**
 * Represents a dragon battle state for a world with an end environment.
*/
export class DragonBattle {
  /**
   * Get the {@link EnderDragon} active in this battle.
   *
   * Will return null if the dragon has been slain.
   *
   * @return the ender dragon. null if dead
  */
  getEnderDragon(): EnderDragon | null;
  /**
   * Get the boss bar to be displayed for this dragon battle.
   *
   * @return the boss bar
  */
  getBossBar(): BossBar;
  /**
   * Get the location of the end portal.
   *
   * This location will be at the center of the base (bottom) of the portal.
   *
   * @return the end portal location or null if not generated
  */
  getEndPortalLocation(): Location | null;
  /**
   * Generate the end portal.
   *
   * @param withPortals whether or not end portal blocks should be generated
   *
   * @return true if generated, false if already present
  */
  generateEndPortal(withPortals: boolean): boolean;
  /**
   * Check whether or not the first dragon has been killed already.
   *
   * @return true if killed before, false otherwise
  */
  hasBeenPreviouslyKilled(): boolean;
  /**
   * Initiate a respawn sequence to summon the dragon as though a player has
   * placed 4 end crystals on the portal.
  */
  initiateRespawn(): void;
  /**
   * Get this battle's current respawn phase.
   *
   * @return the current respawn phase.
  */
  getRespawnPhase(): RespawnPhase;
  /**
   * Set the dragon's respawn phase.
   *
   * This method will is unsuccessful if a dragon respawn is not in progress.
   *
   * @param phase the phase to set
   *
   * @return true if successful, false otherwise
   *
   * @see #initiateRespawn()
  */
  setRespawnPhase(respawnPhase: RespawnPhase);
  /**
   * Reset the crystals located on the obsidian pillars (remove their beam
   * targets and invulnerability).
  */
  resetCrystals(): void;
}
/**
 * Represents a custom {@link BossBar} that has a
 * {@link org.bukkit.NamespacedKey}
*/
export class KeyedBossBar extends BossBar {

}
export interface KeyedBossBar extends BossBar, Keyed {}

}
declare module 'org.bukkit.attribute' {
import { Collection, UUID, Map } from 'java.util';
import { Enum } from 'java.lang';
import { Operation } from 'org.bukkit.attribute.AttributeModifier';
import { ConfigurationSerializable } from 'org.bukkit.configuration.serialization';
import { EquipmentSlot } from 'org.bukkit.inventory';
import { NamespacedKey } from 'org.bukkit';
/**
 * Represents an object which may contain attributes.
*/
export class Attributable {
  /**
   * Gets the specified attribute instance from the object. This instance will
   * be backed directly to the object and any changes will be visible at once.
   *
   * @param attribute the attribute to get
   * @return the attribute instance or null if not applicable to this object
  */
  getAttribute(attribute: Attribute): AttributeInstance | null;
  /**
   * Registers a generic attribute to that attributable instance.
   * Allows it to add attributes not registered by default to that entity.
   *
   * @param attribute the generic attribute to register
  */
  registerAttribute(attribute: Attribute): void;
}
/**
 * Types of attributes which may be present on an {@link Attributable}.
*/
export class Attribute extends Enum<Attribute> {
  /**
   * Maximum health of an Entity.
  */
  static readonly GENERIC_MAX_HEALTH: Attribute;
  /**
   * Range at which an Entity will follow others.
  */
  static readonly GENERIC_FOLLOW_RANGE: Attribute;
  /**
   * Resistance of an Entity to knockback.
  */
  static readonly GENERIC_KNOCKBACK_RESISTANCE: Attribute;
  /**
   * Movement speed of an Entity.
  */
  static readonly GENERIC_MOVEMENT_SPEED: Attribute;
  /**
   * Flying speed of an Entity.
  */
  static readonly GENERIC_FLYING_SPEED: Attribute;
  /**
   * Attack damage of an Entity.
  */
  static readonly GENERIC_ATTACK_DAMAGE: Attribute;
  /**
   * Attack knockback of an Entity.
  */
  static readonly GENERIC_ATTACK_KNOCKBACK: Attribute;
  /**
   * Attack speed of an Entity.
  */
  static readonly GENERIC_ATTACK_SPEED: Attribute;
  /**
   * Armor bonus of an Entity.
  */
  static readonly GENERIC_ARMOR: Attribute;
  /**
   * Armor durability bonus of an Entity.
  */
  static readonly GENERIC_ARMOR_TOUGHNESS: Attribute;
  /**
   * Luck bonus of an Entity.
  */
  static readonly GENERIC_LUCK: Attribute;
  /**
   * Strength with which a horse will jump.
  */
  static readonly HORSE_JUMP_STRENGTH: Attribute;
  /**
   * Chance of a zombie to spawn reinforcements.
  */
  static readonly ZOMBIE_SPAWN_REINFORCEMENTS: Attribute;
  static valueOf(name: string): Attribute;
  static values(): Attribute[];
  getKey(): NamespacedKey;
  translationKey(): string;
}
/**
 * Concrete implementation of an attribute modifier.
*/
export class AttributeModifier extends ConfigurationSerializable {
  constructor(name: string, amount: number, operation: Operation);
  constructor(uuid: UUID, name: string, amount: number, operation: Operation);
  constructor(uuid: UUID, name: string, amount: number, operation: Operation, slot: EquipmentSlot | null);
  /**
   * Get the unique ID for this modifier.
   *
   * @return unique id
  */
  getUniqueId(): UUID;
  /**
   * Get the name of this modifier.
   *
   * @return name
  */
  getName(): string;
  /**
   * Get the amount by which this modifier will apply its {@link Operation}.
   *
   * @return modification amount
  */
  getAmount(): number;
  /**
   * Get the operation this modifier will apply.
   *
   * @return operation
  */
  getOperation(): Operation;
  /**
   * Get the {@link EquipmentSlot} this AttributeModifier is active on,
   * or null if this modifier is applicable for any slot.
   *
   * @return the slot
  */
  getSlot(): EquipmentSlot | null;
  /**
   * Creates a Map representation of this class.
   * 
   * This class must provide a method to restore this class, as defined in
   * the {@link ConfigurationSerializable} interface javadocs.
   *
   * @return Map containing the current state of this class
  */
  serialize(): Map<string, any>;
  equals(other: any): boolean;
  hashCode(): number;
  toString(): string;
  static deserialize(args: Map<string, any>): AttributeModifier;
}
/**
 * Represents a mutable instance of an attribute and its associated modifiers
 * and values.
*/
export class AttributeInstance {
  /**
   * The attribute pertaining to this instance.
   *
   * @return the attribute
  */
  getAttribute(): Attribute;
  /**
   * Base value of this instance before modifiers are applied.
   *
   * @return base value
  */
  getBaseValue(): number;
  /**
   * Set the base value of this instance.
   *
   * @param value new base value
  */
  setBaseValue(baseValue: number);
  /**
   * Get all modifiers present on this instance.
   *
   * @return a copied collection of all modifiers
  */
  getModifiers(): Collection<AttributeModifier>;
  /**
   * Add a modifier to this instance.
   *
   * @param modifier to add
  */
  addModifier(modifier: AttributeModifier): void;
  /**
   * Remove a modifier from this instance.
   *
   * @param modifier to remove
  */
  removeModifier(modifier: AttributeModifier): void;
  /**
   * Get the value of this instance after all associated modifiers have been
   * applied.
   *
   * @return the total attribute value
  */
  getValue(): number;
  /**
   * Gets the default value of the Attribute attached to this instance.
   *
   * @return server default value
  */
  getDefaultValue(): number;
}

}
declare module 'org.bukkit.advancement' {
import { Collection, Date } from 'java.util';
import { Enum } from 'java.lang';
import { AdvancementDisplay as io_papermc_paper_advancement_AdvancementDisplay } from 'io.papermc.paper.advancement';
import { ItemStack } from 'org.bukkit.inventory';
import { ChatColor, Keyed } from 'org.bukkit';
/**
 * Holds information about how the advancement is displayed by the game.
 *
 * @deprecated use {@link io.papermc.paper.advancement.AdvancementDisplay}
*/
export class AdvancementDisplay {
  /**
   * Gets the title of the advancement.
   *
   * @return The advancement title without colour codes.
  */
  getTitle(): string;
  /**
   * Gets the visible description of the advancement.
   *
   * @return The advancement description without colour codes.
  */
  getDescription(): string;
  /**
   * The icon that is used for this advancement.
   *
   * @return an ItemStack that represents the advancement.
  */
  getIcon(): ItemStack;
  /**
   * Whether to show a toast to the player when this advancement has been
   * completed.
   *
   * @return true if a toast is shown.
  */
  shouldShowToast(): boolean;
  /**
   * Whether to announce in the chat when this advancement has been completed.
   *
   * @return true if announced in chat.
  */
  shouldAnnounceChat(): boolean;
  /**
   * Whether to hide this advancement and all its children from the
   * advancement screen until this advancement have been completed.
   *
   * Has no effect on root advancements themselves, but still affects all
   * their children.
   *
   * @return true if hidden.
  */
  isHidden(): boolean;
  /**
   * The X position of the advancement in the advancement screen.
   *
   * @return the X coordinate as float
  */
  getX(): number;
  /**
   * The Y position of the advancement in the advancement screen.
   *
   * @return the Y coordinate as float
  */
  getY(): number;
  /**
   * The display type of this advancement.
   *
   * @return an enum representing the type.
  */
  getType(): AdvancementDisplayType;
}
/**
 * Advancements are displayed in different ways depending on their display type.
 *
 * This enum contains information about these types and how they are
 * represented.
*/
export class AdvancementDisplayType extends Enum<AdvancementDisplayType> {
  /**
   * Task or normal icons have a square icon frame.
  */
  static readonly TASK: AdvancementDisplayType;
  /**
   * Challenge icons have a stylised icon frame.
  */
  static readonly CHALLENGE: AdvancementDisplayType;
  /**
   * Goal icons have a rounded icon frame.
  */
  static readonly GOAL: AdvancementDisplayType;
  static valueOf(name: string): AdvancementDisplayType;
  static values(): AdvancementDisplayType[];
  /**
   * The chat color used by Minecraft for this advancement.
   *
   * @return The chat color used by this advancement type.
  */
  getColor(): ChatColor;
}
/**
 * Represents an advancement that may be awarded to a player. This class is not
 * reference safe as the underlying advancement may be reloaded.
*/
export class Advancement extends Keyed {
  /**
   * Get all the criteria present in this advancement.
   *
   * @return a unmodifiable copy of all criteria
  */
  getCriteria(): Collection<string>;
  /**
   * Get the display info of this advancement.
   * 
   * Will be `null` when totally hidden, for example with crafting
   * recipes.
   *
   * @return the display info
  */
  getDisplay(): io_papermc_paper_advancement_AdvancementDisplay | null;
  /**
   * Gets the parent advancement, if any.
   *
   * @return the parent advancement
  */
  getParent(): Advancement | null;
  /**
   * Gets all the direct children advancements.
   *
   * @return the children advancements
  */
  getChildren(): Collection<Advancement>;
  /**
   * Gets the root advancement of the tree this is located in.
   *
   * @return the root advancement
  */
  getRoot(): Advancement;
}
/**
 * The individual status of an advancement for a player. This class is not
 * reference safe as the underlying advancement may be reloaded.
*/
export class AdvancementProgress {
  /**
   * The advancement this progress is concerning.
   *
   * @return the relevant advancement
  */
  getAdvancement(): Advancement;
  /**
   * Check if all criteria for this advancement have been met.
   *
   * @return true if this advancement is done
  */
  isDone(): boolean;
  /**
   * Mark the specified criteria as awarded at the current time.
   *
   * @param criteria the criteria to mark
   * @return true if awarded, false if criteria does not exist or already
   * awarded.
  */
  awardCriteria(criteria: string): boolean;
  /**
   * Mark the specified criteria as uncompleted.
   *
   * @param criteria the criteria to mark
   * @return true if removed, false if criteria does not exist or not awarded
  */
  revokeCriteria(criteria: string): boolean;
  /**
   * Get the date the specified criteria was awarded.
   *
   * @param criteria the criteria to check
   * @return date awarded or null if unawarded or criteria does not exist
  */
  getDateAwarded(criteria: string): Date | null;
  /**
   * Get the criteria which have not been awarded.
   *
   * @return unmodifiable copy of criteria remaining
  */
  getRemainingCriteria(): Collection<string>;
  /**
   * Gets the criteria which have been awarded.
   *
   * @return unmodifiable copy of criteria awarded
  */
  getAwardedCriteria(): Collection<string>;
}

}
declare module 'org.bukkit.entity.Player' {
import { Set } from 'java.util';
import { InetSocketAddress } from 'java.net';
import { Spigot as org_bukkit_entity_Entity_Spigot } from 'org.bukkit.entity.Entity';
import { Player } from 'org.bukkit.entity';
export class Spigot extends org_bukkit_entity_Entity_Spigot {
  /**
   * Gets the connection address of this player, regardless of whether it
   * has been spoofed or not.
   *
   * @return the player's connection address
  */
  getRawAddress(): InetSocketAddress;
  /**
   * Gets whether the player collides with entities
   *
   * @return the player's collision toggle state
   * @deprecated see {@link LivingEntity#isCollidable()}
  */
  getCollidesWithEntities(): boolean;
  /**
   * Sets whether the player collides with entities
   *
   * @param collides whether the player should collide with entities or
   * not.
   * @deprecated {@link LivingEntity#setCollidable(boolean)}
  */
  setCollidesWithEntities(collides: boolean): void;
  /**
   * Respawns the player if dead.
  */
  respawn(): void;
  /**
   * Gets all players hidden with {@link #hidePlayer(org.bukkit.entity.Player)}.
   *
   * @return a Set with all hidden players
  */
  getHiddenPlayers(): Set<Player>;
  getPing(): number;
}

}
declare module 'org.bukkit.command.defaults' {
import { Component } from 'net.kyori.adventure.text';
import { VersionFetcher } from 'com.destroystokyo.paper.util';
import { Set, List } from 'java.util';
import { Command, CommandSender } from 'org.bukkit.command';
import { Location } from 'org.bukkit';
import { ReentrantLock } from 'java.util.concurrent.locks';
export class BukkitCommand extends Command {

}
export class ReloadCommand extends BukkitCommand {
  constructor(name: string);
  execute(sender: CommandSender, currentAlias: string, args: string[]): boolean;
  tabComplete(sender: CommandSender, alias: string, args: string[]): string[];
  /**
   * Executed on tab completion for this command, returning a list of
   * options the player can tab through.
   *
   * @param sender Source object which is executing this command
   * @param alias the alias being used
   * @param args All arguments passed to the command, split via ' '
   * @param location The position looked at by the sender, or null if none
   * @return a list of tab-completions for the specified arguments. This
   *     will never be null. List may be immutable.
   * @throws IllegalArgumentException if sender, alias, or args is null
  */
  tabComplete(sender: CommandSender, alias: string, args: string[], location: Location | null): string[];
}
export class VersionCommand extends BukkitCommand {
  constructor(name: string);
  execute(sender: CommandSender, currentAlias: string, args: string[]): boolean;
  tabComplete(sender: CommandSender, alias: string, args: string[]): string[];
  /**
   * Executed on tab completion for this command, returning a list of
   * options the player can tab through.
   *
   * @param sender Source object which is executing this command
   * @param alias the alias being used
   * @param args All arguments passed to the command, split via ' '
   * @param location The position looked at by the sender, or null if none
   * @return a list of tab-completions for the specified arguments. This
   *     will never be null. List may be immutable.
   * @throws IllegalArgumentException if sender, alias, or args is null
  */
  tabComplete(sender: CommandSender, alias: string, args: string[], location: Location | null): string[];
}
export class PluginsCommand extends BukkitCommand {
  constructor(name: string);
  execute(sender: CommandSender, currentAlias: string, args: string[]): boolean;
  tabComplete(sender: CommandSender, alias: string, args: string[]): string[];
  /**
   * Executed on tab completion for this command, returning a list of
   * options the player can tab through.
   *
   * @param sender Source object which is executing this command
   * @param alias the alias being used
   * @param args All arguments passed to the command, split via ' '
   * @param location The position looked at by the sender, or null if none
   * @return a list of tab-completions for the specified arguments. This
   *     will never be null. List may be immutable.
   * @throws IllegalArgumentException if sender, alias, or args is null
  */
  tabComplete(sender: CommandSender, alias: string, args: string[], location: Location | null): string[];
}
export class HelpCommand extends BukkitCommand {
  constructor();
  execute(sender: CommandSender, currentAlias: string, args: string[]): boolean;
  tabComplete(sender: CommandSender, alias: string, args: string[]): string[];
  /**
   * Executed on tab completion for this command, returning a list of
   * options the player can tab through.
   *
   * @param sender Source object which is executing this command
   * @param alias the alias being used
   * @param args All arguments passed to the command, split via ' '
   * @param location The position looked at by the sender, or null if none
   * @return a list of tab-completions for the specified arguments. This
   *     will never be null. List may be immutable.
   * @throws IllegalArgumentException if sender, alias, or args is null
  */
  tabComplete(sender: CommandSender, alias: string, args: string[], location: Location | null): string[];
}

}
declare module 'org.bukkit.inventory.meta' {
import { Component } from 'net.kyori.adventure.text';
import { MapView } from 'org.bukkit.map';
import { Set, Collection, List, Map } from 'java.util';
import { BookMetaBuilder, Generation, Spigot } from 'org.bukkit.inventory.meta.BookMeta';
import { Enchantment } from 'org.bukkit.enchantments';
import { Attribute, AttributeModifier } from 'org.bukkit.attribute';
import { Pattern as org_bukkit_entity_TropicalFish_Pattern } from 'org.bukkit.entity.TropicalFish';
import { PlayerProfile as org_bukkit_profile_PlayerProfile } from 'org.bukkit.profile';
import { NamespacedKey, Color, OfflinePlayer, Material, DyeColor, FireworkEffect, Location } from 'org.bukkit';
import { EquipmentSlot, ItemFlag, ItemStack } from 'org.bukkit.inventory';
import { PotionData, PotionEffect, PotionEffectType } from 'org.bukkit.potion';
import { Variant } from 'org.bukkit.entity.Axolotl';
import { Book } from 'net.kyori.adventure.inventory';
import { Pattern } from 'org.bukkit.block.banner';
import { Iterable, Cloneable } from 'java.lang';
import { BlockState } from 'org.bukkit.block';
import { CustomItemTagContainer } from 'org.bukkit.inventory.meta.tags';
import { Namespaced } from 'com.destroystokyo.paper';
import { BlockData } from 'org.bukkit.block.data';
import { ConfigurationSerializable } from 'org.bukkit.configuration.serialization';
import { PlayerProfile } from 'com.destroystokyo.paper.profile';
import { Multimap } from 'com.google.common.collect';
import { PersistentDataHolder } from 'org.bukkit.persistence';
import { EntityType } from 'org.bukkit.entity';
export class BannerMeta extends ItemMeta {
  /**
   * Returns the base color for this banner
   *
   * @return the base color
   * @deprecated banner color is now stored as the data value, not meta.
  */
  getBaseColor(): DyeColor | null;
  /**
   * Sets the base color for this banner
   *
   * @param color the base color
   * @deprecated banner color is now stored as the data value, not meta.
  */
  setBaseColor(baseColor: DyeColor | null);
  /**
   * Returns a list of patterns on this banner
   *
   * @return the patterns
  */
  getPatterns(): Pattern[];
  /**
   * Sets the patterns used on this banner
   *
   * @param patterns the new list of patterns
  */
  setPatterns(patterns: Pattern[]);
  /**
   * Adds a new pattern on top of the existing
   * patterns
   *
   * @param pattern the new pattern to add
  */
  addPattern(pattern: Pattern): void;
  /**
   * Returns the pattern at the specified index
   *
   * @param i the index
   * @return the pattern
   * @throws IndexOutOfBoundsException when index is not in [0, numberOfPatterns()) range
  */
  getPattern(i: number): Pattern;
  /**
   * Removes the pattern at the specified index
   *
   * @param i the index
   * @return the removed pattern
   * @throws IndexOutOfBoundsException when index is not in [0, numberOfPatterns()) range
  */
  removePattern(i: number): Pattern;
  /**
   * Sets the pattern at the specified index
   *
   * @param i       the index
   * @param pattern the new pattern
   * @throws IndexOutOfBoundsException when index is not in [0, numberOfPatterns()) range
  */
  setPattern(i: number, pattern: Pattern): void;
  /**
   * Returns the number of patterns on this
   * banner
   *
   * @return the number of patterns
  */
  numberOfPatterns(): number;
}
/**
 * Represents a suspicious stew that can have custom effects.
*/
export class SuspiciousStewMeta extends ItemMeta {
  /**
   * Checks for the presence of custom potion effects.
   *
   * @return true if custom potion effects are applied
  */
  hasCustomEffects(): boolean;
  /**
   * Gets an immutable list containing all custom potion effects applied to
   * this suspicious stew.
   * 
   * Plugins should check that hasCustomEffects() returns true before calling
   * this method.
   *
   * @return the immutable list of custom potion effects
  */
  getCustomEffects(): PotionEffect[];
  /**
   * Adds a custom potion effect to this suspicious stew.
   *
   * @param effect the potion effect to add
   * @param overwrite true if any existing effect of the same type should be
   * overwritten
   * @return true if the suspicious stew meta changed as a result of this call
  */
  addCustomEffect(effect: PotionEffect, overwrite: boolean): boolean;
  /**
   * Removes a custom potion effect from this suspicious stew.
   *
   * @param type the potion effect type to remove
   * @return true if the suspicious stew meta changed as a result of this call
  */
  removeCustomEffect(type: PotionEffectType): boolean;
  /**
   * Checks for a specific custom potion effect type on this suspicious stew.
   *
   * @param type the potion effect type to check for
   * @return true if the suspicious stew has this effect
  */
  hasCustomEffect(type: PotionEffectType): boolean;
  /**
   * Removes all custom potion effects from this suspicious stew.
   *
   * @return true if the suspicious stew meta changed as a result of this call
  */
  clearCustomEffects(): boolean;
  clone(): SuspiciousStewMeta;
}
/**
 * Represents a meta that can store a single FireworkEffect. An example
 * includes {@link Material#FIREWORK_STAR}.
*/
export class FireworkEffectMeta extends ItemMeta {
  /**
   * Sets the firework effect for this meta.
   *
   * @param effect the effect to set, or null to indicate none.
  */
  setEffect(effect: FireworkEffect | null);
  /**
   * Checks if this meta has an effect.
   *
   * @return true if this meta has an effect, false otherwise
  */
  hasEffect(): boolean;
  /**
   * Gets the firework effect for this meta.
   *
   * @return the current effect, or null if none
  */
  getEffect(): FireworkEffect | null;
  clone(): FireworkEffectMeta;
}
export class BlockDataMeta extends ItemMeta {
  /**
   * Returns whether the item has block data currently attached to it.
   *
   * @return whether block data is already attached
  */
  hasBlockData(): boolean;
  /**
   * Returns the currently attached block data for this item or creates a new
   * one if one doesn't exist.
   *
   * The state is a copy, it must be set back (or to another item) with
   * {@link #setBlockData(org.bukkit.block.data.BlockData)}
   *
   * @param material the material we wish to get this data in the context of
   * @return the attached data or new data
  */
  getBlockData(material: Material): BlockData;
  /**
   * Attaches a copy of the passed block data to the item.
   *
   * @param blockData the block data to attach to the block.
   * @throws IllegalArgumentException if the blockData is null or invalid for
   * this item.
  */
  setBlockData(blockData: BlockData);
}
/**
 * Represents a skull that can have an owner.
*/
export class SkullMeta extends ItemMeta {
  /**
   * Gets the owner of the skull.
   *
   * @return the owner if the skull
   * @deprecated see {@link #getOwningPlayer()}.
  */
  getOwner(): string | null;
  /**
   * Checks to see if the skull has an owner.
   *
   * @return true if the skull has an owner
  */
  hasOwner(): boolean;
  /**
   * Sets the owner of the skull.
   *
   * @param owner the new owner of the skull
   * @return true if the owner was successfully set
   * @deprecated see {@link #setOwningPlayer(org.bukkit.OfflinePlayer)}.
  */
  setOwner(owner: string | null);
  /**
   * Sets this skull to use the supplied Player Profile, which can include textures already prefilled.
   * @param profile The profile to set this Skull to use, or null to clear owner
  */
  setPlayerProfile(playerProfile: PlayerProfile | null);
  /**
   * If the skull has an owner, per {@link #hasOwner()}, return the owners {@link com.destroystokyo.paper.profile.PlayerProfile}
   * @return The profile of the owner, if set
  */
  getPlayerProfile(): PlayerProfile | null;
  /**
   * Gets the owner of the skull.
   *
   * @return the owner if the skull
  */
  getOwningPlayer(): OfflinePlayer | null;
  /**
   * Sets the owner of the skull.
   * 
   * Plugins should check that hasOwner() returns true before calling this
   * plugin.
   *
   * @param owner the new owner of the skull
   * @return true if the owner was successfully set
  */
  setOwningPlayer(owningPlayer: OfflinePlayer | null);
  /**
   * Gets the profile of the player who owns the skull. This player profile
   * may appear as the texture depending on skull type.
   *
   * @return the profile of the owning player
  */
  getOwnerProfile(): org_bukkit_profile_PlayerProfile | null;
  /**
   * Sets the profile of the player who owns the skull. This player profile
   * may appear as the texture depending on skull type.
   * 
   * The profile must contain both a unique id and a skin texture. If either
   * of these is missing, the profile must contain a name by which the server
   * will then attempt to look up the unique id and skin texture.
   *
   * @param profile the profile of the owning player
   * @throws IllegalArgumentException if the profile does not contain the
   * necessary information
  */
  setOwnerProfile(ownerProfile: org_bukkit_profile_PlayerProfile | null);
  clone(): SkullMeta;
}
export class CrossbowMeta extends ItemMeta {
  /**
   * Returns whether the item has any charged projectiles.
   *
   * @return whether charged projectiles are present
  */
  hasChargedProjectiles(): boolean;
  /**
   * Returns an immutable list of the projectiles charged on this item.
   *
   * @return charged projectiles
  */
  getChargedProjectiles(): ItemStack[];
  /**
   * Sets the projectiles charged on this item.
   *
   * Removes all projectiles when given null.
   *
   * @param projectiles the projectiles to set
   * @throws IllegalArgumentException if one of the projectiles is not an
   * arrow or firework rocket
  */
  setChargedProjectiles(chargedProjectiles: ItemStack[] | null);
  /**
   * Adds a charged projectile to this item.
   *
   * @param item projectile
   * @throws IllegalArgumentException if the projectile is not an arrow or
   * firework rocket
  */
  addChargedProjectile(item: ItemStack): void;
}
/**
 * Represents a potion or item that can have custom effects.
*/
export class PotionMeta extends ItemMeta {
  /**
   * Sets the underlying potion data
   *
   * @param data PotionData to set the base potion state to
  */
  setBasePotionData(basePotionData: PotionData);
  /**
   * Returns the potion data about the base potion
   *
   * @return a PotionData object
  */
  getBasePotionData(): PotionData;
  /**
   * Checks for the presence of custom potion effects.
   *
   * @return true if custom potion effects are applied
  */
  hasCustomEffects(): boolean;
  /**
   * Gets an immutable list containing all custom potion effects applied to
   * this potion.
   * 
   * Plugins should check that hasCustomEffects() returns true before calling
   * this method.
   *
   * @return the immutable list of custom potion effects
  */
  getCustomEffects(): PotionEffect[];
  /**
   * Adds a custom potion effect to this potion.
   *
   * @param effect the potion effect to add
   * @param overwrite true if any existing effect of the same type should be
   * overwritten
   * @return true if the potion meta changed as a result of this call
  */
  addCustomEffect(effect: PotionEffect, overwrite: boolean): boolean;
  /**
   * Removes a custom potion effect from this potion.
   *
   * @param type the potion effect type to remove
   * @return true if the potion meta changed as a result of this call
  */
  removeCustomEffect(type: PotionEffectType): boolean;
  /**
   * Checks for a specific custom potion effect type on this potion.
   *
   * @param type the potion effect type to check for
   * @return true if the potion has this effect
  */
  hasCustomEffect(type: PotionEffectType): boolean;
  /**
   * Moves a potion effect to the top of the potion effect list.
   * 
   * This causes the client to display the potion effect in the potion's name.
   *
   * @param type the potion effect type to move
   * @return true if the potion meta changed as a result of this call
   * @deprecated use {@link #setBasePotionData(org.bukkit.potion.PotionData)}
  */
  setMainEffect(mainEffect: PotionEffectType);
  /**
   * Removes all custom potion effects from this potion.
   *
   * @return true if the potion meta changed as a result of this call
  */
  clearCustomEffects(): boolean;
  /**
   * Checks for existence of a potion color.
   *
   * @return true if this has a custom potion color
  */
  hasColor(): boolean;
  /**
   * Gets the potion color that is set. A custom potion color will alter the
   * display of the potion in an inventory slot.
   * 
   * Plugins should check that hasColor() returns true before
   * calling this method.
   *
   * @return the potion color that is set
  */
  getColor(): Color | null;
  /**
   * Sets the potion color. A custom potion color will alter the display of
   * the potion in an inventory slot.
   *
   * @param color the color to set
  */
  setColor(color: Color | null);
  clone(): PotionMeta;
}
export class BlockStateMeta extends ItemMeta {
  /**
   * Returns whether the item has a block state currently
   * attached to it.
   *
   * @return whether a block state is already attached
  */
  hasBlockState(): boolean;
  /**
   * Returns the currently attached block state for this
   * item or creates a new one if one doesn't exist.
   *
   * The state is a copy, it must be set back (or to another
   * item) with {@link #setBlockState(org.bukkit.block.BlockState)}
   *
   * @return the attached state or a new state
  */
  getBlockState(): BlockState;
  /**
   * Attaches a copy of the passed block state to the item.
   *
   * @param blockState the block state to attach to the block.
   * @throws IllegalArgumentException if the blockState is null
   *         or invalid for this item.
  */
  setBlockState(blockState: BlockState);
}
export class BundleMeta extends ItemMeta {
  /**
   * Returns whether the item has any items.
   *
   * @return whether items are present
  */
  hasItems(): boolean;
  /**
   * Returns an immutable list of the items stored in this item.
   *
   * @return items
  */
  getItems(): ItemStack[];
  /**
   * Sets the items stored in this item.
   *
   * Removes all items when given null.
   *
   * @param items the items to set
  */
  setItems(items: ItemStack[] | null);
  /**
   * Adds an item to this item.
   *
   * @param item item to add
  */
  addItem(item: ItemStack): void;
}
/**
 * This type represents the storage mechanism for auxiliary item data.
 * 
 * An implementation will handle the creation and application for ItemMeta.
 * This class should not be implemented by a plugin in a live environment.
*/
export class ItemMeta extends Cloneable {
  /**
   * Checks for existence of a display name.
   *
   * @return true if this has a display name
  */
  hasDisplayName(): boolean;
  /**
   * Gets the display name.
   *
   * Plugins should check that {@link #hasDisplayName()} returns true before calling this method.
   *
   * @return the display name
  */
  displayName(): Component | null;
  /**
   * Sets the display name.
   *
   * @param displayName the display name to set
  */
  displayName(displayName: Component | null): void;
  /**
   * Sets the display name.
   *
   * @param name the name to set
   * @deprecated in favour of {@link #displayName(net.kyori.adventure.text.Component)}
  */
  setDisplayName(displayName: string | null): void;
  /**
   * Checks for existence of a localized name.
   *
   * @deprecated Use {@link ItemMeta#displayName()} and check if it is instanceof a {@link net.kyori.adventure.text.TranslatableComponent}.
   * @return true if this has a localized name
  */
  hasLocalizedName(): boolean;
  /**
   * Gets the localized display name that is set.
   * 
   * Plugins should check that hasLocalizedName() returns true
   * before calling this method.
   *
   * @deprecated Use {@link ItemMeta#displayName()} and cast it to a {@link net.kyori.adventure.text.TranslatableComponent}. No longer used by the client.
   * @return the localized name that is set
  */
  getLocalizedName(): string;
  /**
   * Sets the localized name.
   *
   * @deprecated Use {@link ItemMeta#displayName(Component)} with a {@link net.kyori.adventure.text.TranslatableComponent}. No longer used by the client.
   * @param name the name to set
  */
  setLocalizedName(localizedName: string | null);
  /**
   * Checks for existence of lore.
   *
   * @return true if this has lore
  */
  hasLore(): boolean;
  /**
   * Gets the lore.
   *
   * Plugins should check that {@link #hasLore()} returns true before calling this method.
   *
   * @return the display name
  */
  lore(): Component[] | null;
  /**
   * Sets the lore.
   *
   * @param lore the lore to set
  */
  lore(lore: Component[] | null): void;
  /**
   * Checks for existence of custom model data.
   * 
   * CustomModelData is an integer that may be associated client side with a
   * custom item model.
   *
   * @return true if this has custom model data
  */
  hasCustomModelData(): boolean;
  /**
   * Gets the custom model data that is set.
   * 
   * CustomModelData is an integer that may be associated client side with a
   * custom item model.
   * 
   * Plugins should check that hasCustomModelData() returns true
   * before calling this method.
   *
   * @return the custom model data that is set
  */
  getCustomModelData(): number;
  /**
   * Sets the custom model data.
   * 
   * CustomModelData is an integer that may be associated client side with a
   * custom item model.
   *
   * @param data the data to set, or null to clear
  */
  setCustomModelData(customModelData: number | null);
  /**
   * Checks for the existence of any enchantments.
   *
   * @return true if an enchantment exists on this meta
  */
  hasEnchants(): boolean;
  /**
   * Checks for existence of the specified enchantment.
   *
   * @param ench enchantment to check
   * @return true if this enchantment exists for this meta
  */
  hasEnchant(ench: Enchantment): boolean;
  /**
   * Checks for the level of the specified enchantment.
   *
   * @param ench enchantment to check
   * @return The level that the specified enchantment has, or 0 if none
  */
  getEnchantLevel(ench: Enchantment): number;
  /**
   * Returns a copy the enchantments in this ItemMeta. 
   * Returns an empty map if none.
   *
   * @return An immutable copy of the enchantments
  */
  getEnchants(): Map<Enchantment, number>;
  /**
   * Adds the specified enchantment to this item meta.
   *
   * @param ench Enchantment to add
   * @param level Level for the enchantment
   * @param ignoreLevelRestriction this indicates the enchantment should be
   *     applied, ignoring the level limit
   * @return true if the item meta changed as a result of this call, false
   *     otherwise
  */
  addEnchant(ench: Enchantment, level: number, ignoreLevelRestriction: boolean): boolean;
  /**
   * Removes the specified enchantment from this item meta.
   *
   * @param ench Enchantment to remove
   * @return true if the item meta changed as a result of this call, false
   *     otherwise
  */
  removeEnchant(ench: Enchantment): boolean;
  /**
   * Checks if the specified enchantment conflicts with any enchantments in
   * this ItemMeta.
   *
   * @param ench enchantment to test
   * @return true if the enchantment conflicts, false otherwise
  */
  hasConflictingEnchant(ench: Enchantment): boolean;
  /**
   * Set itemflags which should be ignored when rendering a ItemStack in the Client. This Method does silently ignore double set itemFlags.
   *
   * @param itemFlags The hideflags which shouldn't be rendered
  */
  addItemFlags(...itemFlags: ItemFlag[]): void;
  /**
   * Remove specific set of itemFlags. This tells the Client it should render it again. This Method does silently ignore double removed itemFlags.
   *
   * @param itemFlags Hideflags which should be removed
  */
  removeItemFlags(...itemFlags: ItemFlag[]): void;
  /**
   * Get current set itemFlags. The collection returned is unmodifiable.
   *
   * @return A set of all itemFlags set
  */
  getItemFlags(): Set<ItemFlag>;
  /**
   * Check if the specified flag is present on this item.
   *
   * @param flag the flag to check
   * @return if it is present
  */
  hasItemFlag(flag: ItemFlag): boolean;
  /**
   * Return if the unbreakable tag is true. An unbreakable item will not lose
   * durability.
   *
   * @return true if the unbreakable tag is true
  */
  isUnbreakable(): boolean;
  /**
   * Sets the unbreakable tag. An unbreakable item will not lose durability.
   *
   * @param unbreakable true if set unbreakable
  */
  setUnbreakable(unbreakable: boolean): void;
  /**
   * Checks for the existence of any AttributeModifiers.
   *
   * @return true if any AttributeModifiers exist
  */
  hasAttributeModifiers(): boolean;
  /**
   * Return an immutable copy of all Attributes and
   * their modifiers in this ItemMeta.
   * Returns null if none exist.
   *
   * @return an immutable {@link Multimap} of Attributes
   *         and their AttributeModifiers, or null if none exist
  */
  getAttributeModifiers(): Multimap<Attribute, AttributeModifier> | null;
  /**
   * Return an immutable copy of all {@link Attribute}s and their
   * {@link AttributeModifier}s for a given {@link EquipmentSlot}.
   * Any {@link AttributeModifier} that does have have a given
   * {@link EquipmentSlot} will be returned. This is because
   * AttributeModifiers without a slot are active in any slot.
   * If there are no attributes set for the given slot, an empty map
   * will be returned.
   *
   * @param slot the {@link EquipmentSlot} to check
   * @return the immutable {@link Multimap} with the
   *         respective Attributes and modifiers, or an empty map
   *         if no attributes are set.
  */
  getAttributeModifiers(slot: EquipmentSlot): Multimap<Attribute, AttributeModifier>;
  /**
   * Return an immutable copy of all {@link AttributeModifier}s
   * for a given {@link Attribute}
   *
   * @param attribute the {@link Attribute}
   * @return an immutable collection of {@link AttributeModifier}s
   *          or null if no AttributeModifiers exist for the Attribute.
   * @throws NullPointerException if Attribute is null
  */
  getAttributeModifiers(attribute: Attribute): Collection<AttributeModifier> | null;
  /**
   * Add an Attribute and it's Modifier.
   * AttributeModifiers can now support {@link EquipmentSlot}s.
   * If not set, the {@link AttributeModifier} will be active in ALL slots.
   * 
   * Two {@link AttributeModifier}s that have the same {@link java.util.UUID}
   * cannot exist on the same Attribute.
   *
   * @param attribute the {@link Attribute} to modify
   * @param modifier the {@link AttributeModifier} specifying the modification
   * @return true if the Attribute and AttributeModifier were
   *         successfully added
   * @throws NullPointerException if Attribute is null
   * @throws NullPointerException if AttributeModifier is null
   * @throws IllegalArgumentException if AttributeModifier already exists
  */
  addAttributeModifier(attribute: Attribute, modifier: AttributeModifier): boolean;
  /**
   * Set all {@link Attribute}s and their {@link AttributeModifier}s.
   * To clear all currently set Attributes and AttributeModifiers use
   * null or an empty Multimap.
   * If not null nor empty, this will filter all entries that are not-null
   * and add them to the ItemStack.
   *
   * @param attributeModifiers the new Multimap containing the Attributes
   *                           and their AttributeModifiers
  */
  setAttributeModifiers(attributeModifiers: Multimap<Attribute, AttributeModifier> | null);
  /**
   * Remove all {@link AttributeModifier}s associated with the given
   * {@link Attribute}.
   * This will return false if nothing was removed.
   *
   * @param attribute attribute to remove
   * @return  true if all modifiers were removed from a given
   *                  Attribute. Returns false if no attributes were
   *                  removed.
   * @throws NullPointerException if Attribute is null
  */
  removeAttributeModifier(attribute: Attribute): boolean;
  /**
   * Remove all {@link Attribute}s and {@link AttributeModifier}s for a
   * given {@link EquipmentSlot}.
   * If the given {@link EquipmentSlot} is null, this will remove all
   * {@link AttributeModifier}s that do not have an EquipmentSlot set.
   *
   * @param slot the {@link EquipmentSlot} to clear all Attributes and
   *             their modifiers for
   * @return true if all modifiers were removed that match the given
   *         EquipmentSlot.
  */
  removeAttributeModifier(slot: EquipmentSlot): boolean;
  /**
   * Remove a specific {@link Attribute} and {@link AttributeModifier}.
   * AttributeModifiers are matched according to their {@link java.util.UUID}.
   *
   * @param attribute the {@link Attribute} to remove
   * @param modifier the {@link AttributeModifier} to remove
   * @return if any attribute modifiers were remove
   *
   * @throws NullPointerException if the Attribute is null
   * @throws NullPointerException if the AttributeModifier is null
   *
   * @see AttributeModifier#getUniqueId()
  */
  removeAttributeModifier(attribute: Attribute, modifier: AttributeModifier): boolean;
  /**
   * Get this ItemMeta as an NBT string.
   * 
   * This string should not be relied upon as a serializable value. If
   * serialization is desired, the {@link ConfigurationSerializable} API
   * should be used instead.
   *
   * @return the NBT string
  */
  getAsString(): string;
  /**
   * Returns a public custom tag container capable of storing tags on the
   * item.
   *
   * Those tags will be sent to the client with all of their content, so the
   * client is capable of reading them. This will result in the player seeing
   * a NBT Tag notification on the item.
   *
   * These tags can also be modified by the client once in creative mode
   *
   * @return the custom tag container
   * @deprecated this API part has been replaced by the {@link PersistentDataHolder} API.
   * Please use {@link PersistentDataHolder#getPersistentDataContainer()} instead of this.
  */
  getCustomTagContainer(): CustomItemTagContainer;
  /**
   * Internal use only! Do not use under any circumstances!
   *
   * @param version version
   * @deprecated internal use only
  */
  setVersion(version: number);
  clone(): ItemMeta;
  /**
   * Gets set of materials what given item can destroy in {@link org.bukkit.GameMode#ADVENTURE}
   *
   * @return Set of materials
   * @deprecated Minecraft does not limit this to the material enum, Use {@link #getDestroyableKeys()} as a replacement
  */
  getCanDestroy(): Set<Material>;
  /**
   * Sets set of materials what given item can destroy in {@link org.bukkit.GameMode#ADVENTURE}
   *
   * @param canDestroy Set of materials
   * @deprecated Minecraft does not limit this to the material enum, Use {@link #setDestroyableKeys(Collection)} as a replacement
  */
  setCanDestroy(canDestroy: Set<Material>);
  /**
   * Gets set of materials where given item can be placed on in {@link org.bukkit.GameMode#ADVENTURE}
   *
   * @return Set of materials
   * @deprecated Minecraft does not limit this to the material enum, Use {@link #getPlaceableKeys()} as a replacement
  */
  getCanPlaceOn(): Set<Material>;
  /**
   * Sets set of materials where given item can be placed on in {@link org.bukkit.GameMode#ADVENTURE}
   *
   * @param canPlaceOn Set of materials
   * @deprecated Minecraft does not limit this to the material enum, Use {@link #setPlaceableKeys(Collection)} as a replacement
  */
  setCanPlaceOn(canPlaceOn: Set<Material>);
  /**
   * Gets the collection of namespaced keys that the item can destroy in {@link org.bukkit.GameMode#ADVENTURE}
   *
   * @return Set of {@link com.destroystokyo.paper.Namespaced}
  */
  getDestroyableKeys(): Set<Namespaced>;
  /**
   * Sets the collection of namespaced keys that the item can destroy in {@link org.bukkit.GameMode#ADVENTURE}
   *
   * @param canDestroy Collection of {@link com.destroystokyo.paper.Namespaced}
  */
  setDestroyableKeys(destroyableKeys: Collection<Namespaced>);
  /**
   * Gets the collection of namespaced keys that the item can be placed on in {@link org.bukkit.GameMode#ADVENTURE}
   *
   * @return Set of {@link com.destroystokyo.paper.Namespaced}
  */
  getPlaceableKeys(): Set<Namespaced>;
  /**
   * Sets the set of namespaced keys that the item can be placed on in {@link org.bukkit.GameMode#ADVENTURE}
   *
   * @param canPlaceOn Collection of {@link com.destroystokyo.paper.Namespaced}
  */
  setPlaceableKeys(placeableKeys: Collection<Namespaced>);
  /**
   * Checks for the existence of any keys that the item can be placed on
   *
   * @return true if this item has placeable keys
  */
  hasPlaceableKeys(): boolean;
  /**
   * Checks for the existence of any keys that the item can destroy
   *
   * @return true if this item has destroyable keys
  */
  hasDestroyableKeys(): boolean;
}
export interface ItemMeta extends Cloneable, ConfigurationSerializable, PersistentDataHolder {}
/**
 * Represents a {@link Material#FIREWORK_ROCKET} and its effects.
*/
export class FireworkMeta extends ItemMeta {
  /**
   * Add another effect to this firework.
   *
   * @param effect The firework effect to add
   * @throws IllegalArgumentException If effect is null
  */
  addEffect(effect: FireworkEffect): void;
  /**
   * Add several effects to this firework.
   *
   * @param effects The firework effects to add
   * @throws IllegalArgumentException If effects is null
   * @throws IllegalArgumentException If any effect is null (may be thrown
   *     after changes have occurred)
  */
  addEffects(...effects: FireworkEffect[]): void;
  /**
   * Add several firework effects to this firework.
   *
   * @param effects An iterable object whose iterator yields the desired
   *     firework effects
   * @throws IllegalArgumentException If effects is null
   * @throws IllegalArgumentException If any effect is null (may be thrown
   *     after changes have occurred)
  */
  addEffects(effects: Iterable<FireworkEffect>): void;
  /**
   * Get the effects in this firework.
   *
   * @return An immutable list of the firework effects
  */
  getEffects(): FireworkEffect[];
  /**
   * Get the number of effects in this firework.
   *
   * @return The number of effects
  */
  getEffectsSize(): number;
  /**
   * Remove an effect from this firework.
   *
   * @param index The index of the effect to remove
   * @throws IndexOutOfBoundsException If index {@literal < 0 or index >} {@link
   *     #getEffectsSize()}
  */
  removeEffect(index: number): void;
  /**
   * Remove all effects from this firework.
  */
  clearEffects(): void;
  /**
   * Get whether this firework has any effects.
   *
   * @return true if it has effects, false if there are no effects
  */
  hasEffects(): boolean;
  /**
   * Gets the approximate height the firework will fly.
   *
   * @return approximate flight height of the firework.
  */
  getPower(): number;
  /**
   * Sets the approximate power of the firework. Each level of power is half
   * a second of flight time.
   *
   * @param power the power of the firework, from 0-127
   * @throws IllegalArgumentException if {@literal height<0 or height>127}
  */
  setPower(power: number);
  clone(): FireworkMeta;
}
/**
 * Represents leather armor ({@link Material#LEATHER_BOOTS}, {@link
 * Material#LEATHER_CHESTPLATE}, {@link Material#LEATHER_HELMET}, or {@link
 * Material#LEATHER_LEGGINGS}) that can be colored.
*/
export class LeatherArmorMeta extends ItemMeta {
  /**
   * Gets the color of the armor. If it has not been set otherwise, it will
   * be {@link ItemFactory#getDefaultLeatherColor()}.
   *
   * @return the color of the armor, never null
  */
  getColor(): Color;
  /**
   * Sets the color of the armor.
   *
   * @param color the color to set. Setting it to null is equivalent to
   *     setting it to {@link ItemFactory#getDefaultLeatherColor()}.
  */
  setColor(color: Color | null);
  clone(): LeatherArmorMeta;
}
/**
 * Represents a spawn egg and it's spawned type.
*/
export class SpawnEggMeta extends ItemMeta {
  /**
   * Get the type of entity this egg will spawn.
   *
   * @return The entity type. May be null for implementation specific default.
   * @deprecated different types are different items
  */
  getSpawnedType(): EntityType;
  /**
   * Set the type of entity this egg will spawn.
   *
   * @param type The entity type. May be null for implementation specific
   * default.
   * @deprecated different types are different items
  */
  setSpawnedType(spawnedType: EntityType);
  clone(): SpawnEggMeta;
}
/**
 * Represents a map that can be scalable.
*/
export class MapMeta extends ItemMeta {
  /**
   * Checks for existence of a map ID number.
   *
   * @return true if this has a map ID number.
   * @see #hasMapView()
   * @deprecated These methods are poor API: They rely on the caller to pass
   * in an only an integer property, and have poorly defined implementation
   * behavior if that integer is not a valid map (the current implementation
   * for example will generate a new map with a different ID). The xxxMapView
   * family of methods should be used instead.
  */
  hasMapId(): boolean;
  /**
   * Gets the map ID that is set. This is used to determine what map is
   * displayed.
   * 
   * Plugins should check that hasMapId() returns true before
   * calling this method.
   *
   * @return the map ID that is set
   * @see #getMapView()
   * @deprecated These methods are poor API: They rely on the caller to pass
   * in an only an integer property, and have poorly defined implementation
   * behavior if that integer is not a valid map (the current implementation
   * for example will generate a new map with a different ID). The xxxMapView
   * family of methods should be used instead.
  */
  getMapId(): number;
  /**
   * Sets the map ID. This is used to determine what map is displayed.
   *
   * @param id the map id to set
   * @see #setMapView(org.bukkit.map.MapView)
   * @deprecated These methods are poor API: They rely on the caller to pass
   * in an only an integer property, and have poorly defined implementation
   * behavior if that integer is not a valid map (the current implementation
   * for example will generate a new map with a different ID). The xxxMapView
   * family of methods should be used instead.
  */
  setMapId(mapId: number);
  /**
   * Checks for existence of an associated map.
   *
   * @return true if this item has an associated map
  */
  hasMapView(): boolean;
  /**
   * Gets the map view that is associated with this map item.
   *
   * 
   * Plugins should check that hasMapView() returns true before
   * calling this method.
   *
   * @return the map view, or null if the item hasMapView(), but this map does
   * not exist on the server
  */
  getMapView(): MapView | null;
  /**
   * Sets the associated map. This is used to determine what map is displayed.
   *
   * 
   * The implementation may allow null to clear the associated map, but
   * this is not required and is liable to generate a new (undefined) map when
   * the item is first used.
   *
   * @param map the map to set
  */
  setMapView(mapView: MapView);
  /**
   * Checks to see if this map is scaling.
   *
   * @return true if this map is scaling
  */
  isScaling(): boolean;
  /**
   * Sets if this map is scaling or not.
   *
   * @param value true to scale
  */
  setScaling(value: boolean): void;
  /**
   * Checks for existence of a location name.
   *
   * @return true if this has a location name
  */
  hasLocationName(): boolean;
  /**
   * Gets the location name that is set.
   * 
   * Plugins should check that hasLocationName() returns true
   * before calling this method.
   *
   * @return the location name that is set
  */
  getLocationName(): string | null;
  /**
   * Sets the location name. A custom map color will alter the display of the
   * map in an inventory slot.
   *
   * @param name the name to set
  */
  setLocationName(locationName: string | null);
  /**
   * Checks for existence of a map color.
   *
   * @return true if this has a custom map color
  */
  hasColor(): boolean;
  /**
   * Gets the map color that is set. A custom map color will alter the display
   * of the map in an inventory slot.
   * 
   * Plugins should check that hasColor() returns true before
   * calling this method.
   *
   * @return the map color that is set
  */
  getColor(): Color | null;
  /**
   * Sets the map color. A custom map color will alter the display of the map
   * in an inventory slot.
   *
   * @param color the color to set
  */
  setColor(color: Color | null);
  clone(): MapMeta;
}
/**
 * Represents an item that has durability and can take damage.
*/
export class Damageable extends ItemMeta {
  /**
   * Checks to see if this item has damage
   *
   * @return true if this has damage
  */
  hasDamage(): boolean;
  /**
   * Gets the damage
   *
   * @return the damage
  */
  getDamage(): number;
  /**
   * Sets the damage
   *
   * @param damage item damage
  */
  setDamage(damage: number);
  clone(): Damageable;
}
/**
 * Represents an item that can be repaired at an anvil.
*/
export class Repairable extends ItemMeta {
  /**
   * Checks to see if this has a repair penalty
   *
   * @return true if this has a repair penalty
  */
  hasRepairCost(): boolean;
  /**
   * Gets the repair penalty
   *
   * @return the repair penalty
  */
  getRepairCost(): number;
  /**
   * Sets the repair penalty
   *
   * @param cost repair penalty
  */
  setRepairCost(repairCost: number);
  clone(): Repairable;
}
/**
 * Represents a bucket of tropical fish.
*/
export class TropicalFishBucketMeta extends ItemMeta {
  /**
   * Gets the color of the fish's pattern.
   * 
   * Plugins should check that hasVariant() returns true before
   * calling this method.
   *
   * @return pattern color
  */
  getPatternColor(): DyeColor;
  /**
   * Sets the color of the fish's pattern.
   * 
   * Setting this when hasVariant() returns false will initialize
   * all other values to unspecified defaults.
   *
   * @param color pattern color
  */
  setPatternColor(patternColor: DyeColor);
  /**
   * Gets the color of the fish's body.
   * 
   * Plugins should check that hasVariant() returns true before
   * calling this method.
   *
   * @return pattern color
  */
  getBodyColor(): DyeColor;
  /**
   * Sets the color of the fish's body.
   * 
   * Setting this when hasVariant() returns false will initialize
   * all other values to unspecified defaults.
   *
   * @param color body color
  */
  setBodyColor(bodyColor: DyeColor);
  /**
   * Gets the fish's pattern.
   * 
   * Plugins should check that hasVariant() returns true before
   * calling this method.
   *
   * @return pattern
  */
  getPattern(): org_bukkit_entity_TropicalFish_Pattern;
  /**
   * Sets the fish's pattern.
   * 
   * Setting this when hasVariant() returns false will initialize
   * all other values to unspecified defaults.
   *
   * @param pattern new pattern
  */
  setPattern(pattern: org_bukkit_entity_TropicalFish_Pattern);
  /**
   * Checks for existence of a variant tag indicating a specific fish will be
   * spawned.
   *
   * @return if there is a variant
  */
  hasVariant(): boolean;
  clone(): TropicalFishBucketMeta;
}
/**
 * Represents a compass that can track a specific location.
*/
export class CompassMeta extends ItemMeta {
  /**
   * Checks if this compass has been paired to a lodestone.
   *
   * @return paired status
  */
  hasLodestone(): boolean;
  /**
   * Gets the location that this compass will point to.
   *
   * Check {@link #hasLodestone()} first!
   *
   * @return lodestone location
  */
  getLodestone(): Location | null;
  /**
   * Sets the location this lodestone compass will point to.
   *
   * @param lodestone new location or null to clear
  */
  setLodestone(lodestone: Location | null);
  /**
   * Gets if this compass is tracking a specific lodestone.
   *
   * If true the compass will only work if there is a lodestone at the tracked
   * location.
   *
   * @return lodestone tracked
  */
  isLodestoneTracked(): boolean;
  /**
   * Sets if this compass is tracking a specific lodestone.
   *
   * If true the compass will only work if there is a lodestone at the tracked
   * location.
   *
   * @param tracked new tracked status
  */
  setLodestoneTracked(tracked: boolean): void;
  clone(): CompassMeta;
}
/**
 * EnchantmentMeta is specific to items that can store enchantments, as
 * opposed to being enchanted. {@link Material#ENCHANTED_BOOK} is an example
 * of an item with enchantment storage.
*/
export class EnchantmentStorageMeta extends ItemMeta {
  /**
   * Checks for the existence of any stored enchantments.
   *
   * @return true if an enchantment exists on this meta
  */
  hasStoredEnchants(): boolean;
  /**
   * Checks for storage of the specified enchantment.
   *
   * @param ench enchantment to check
   * @return true if this enchantment is stored in this meta
  */
  hasStoredEnchant(ench: Enchantment): boolean;
  /**
   * Checks for the level of the stored enchantment.
   *
   * @param ench enchantment to check
   * @return The level that the specified stored enchantment has, or 0 if
   *     none
  */
  getStoredEnchantLevel(ench: Enchantment): number;
  /**
   * Gets a copy the stored enchantments in this ItemMeta.
   *
   * @return An immutable copy of the stored enchantments
  */
  getStoredEnchants(): Map<Enchantment, number>;
  /**
   * Stores the specified enchantment in this item meta.
   *
   * @param ench Enchantment to store
   * @param level Level for the enchantment
   * @param ignoreLevelRestriction this indicates the enchantment should be
   *     applied, ignoring the level limit
   * @return true if the item meta changed as a result of this call, false
   *     otherwise
   * @throws IllegalArgumentException if enchantment is null
  */
  addStoredEnchant(ench: Enchantment, level: number, ignoreLevelRestriction: boolean): boolean;
  /**
   * Remove the specified stored enchantment from this item meta.
   *
   * @param ench Enchantment to remove
   * @return true if the item meta changed as a result of this call, false
   *     otherwise
   * @throws IllegalArgumentException if enchantment is null
  */
  removeStoredEnchant(ench: Enchantment): boolean;
  /**
   * Checks if the specified enchantment conflicts with any enchantments in
   * this ItemMeta.
   *
   * @param ench enchantment to test
   * @return true if the enchantment conflicts, false otherwise
  */
  hasConflictingStoredEnchant(ench: Enchantment): boolean;
  clone(): EnchantmentStorageMeta;
}
/**
 * Represents a book ({@link Material#WRITABLE_BOOK} or {@link
 * Material#WRITTEN_BOOK}) that can have a title, an author, and pages.
*/
export class BookMeta extends ItemMeta {
  /**
   * Checks for the existence of a title in the book.
   *
   * @return true if the book has a title
  */
  hasTitle(): boolean;
  /**
   * Gets the title of the book.
   * 
   * Plugins should check that hasTitle() returns true before calling this
   * method.
   *
   * @return the title of the book
  */
  getTitle(): string | null;
  /**
   * Sets the title of the book.
   * 
   * Limited to 32 characters. Removes title when given null.
   *
   * @param title the title to set
   * @return true if the title was successfully set
  */
  setTitle(title: string | null): void;
  /**
   * Checks for the existence of an author in the book.
   *
   * @return true if the book has an author
  */
  hasAuthor(): boolean;
  /**
   * Gets the author of the book.
   * 
   * Plugins should check that hasAuthor() returns true before calling this
   * method.
   *
   * @return the author of the book
  */
  getAuthor(): string | null;
  /**
   * Sets the author of the book. Removes author when given null.
   *
   * @param author the author to set
  */
  setAuthor(author: string | null): void;
  /**
   * Checks for the existence of generation level in the book.
   *
   * @return true if the book has a generation level
  */
  hasGeneration(): boolean;
  /**
   * Gets the generation of the book.
   * 
   * Plugins should check that hasGeneration() returns true before calling
   * this method.
   *
   * @return the generation of the book
  */
  getGeneration(): Generation | null;
  /**
   * Sets the generation of the book. Removes generation when given null.
   *
   * @param generation the generation to set
  */
  setGeneration(generation: Generation | null);
  /**
   * Checks for the existence of pages in the book.
   *
   * @return true if the book has pages
  */
  hasPages(): boolean;
  /**
   * Sets the title of the book.
   * 
   * Limited to 32 characters. Removes title when given null.
   *
   * @param title the title to set
   * @return the same {@link BookMeta} instance
  */
  title(title: Component | null): BookMeta;
  /**
   * Sets the author of the book. Removes author when given null.
   *
   * @param author the author to set
   * @return the same {@link BookMeta} instance
  */
  author(author: Component | null): BookMeta;
  /**
   * Gets the specified page in the book. The page must exist.
   * 
   * Pages are 1-indexed.
   *
   * @param page the page number to get, in range [1, getPageCount()]
   * @return the page from the book
  */
  page(page: number): Component;
  /**
   * Sets the specified page in the book. Pages of the book must be
   * contiguous.
   * 
   * The data can be up to 256 characters in length, additional characters
   * are truncated.
   * 
   * Pages are 1-indexed.
   *
   * @param page the page number to set, in range [1, getPageCount()]
   * @param data the data to set for that page
  */
  page(page: number, data: Component): void;
  /**
   * Adds new pages to the end of the book. Up to a maximum of 50 pages with
   * 256 characters per page.
   *
   * @param pages A list of strings, each being a page
  */
  addPages(...pages: Component[]): void;
  toBuilder(): BookMetaBuilder;
  /**
   * Gets the specified page in the book. The given page must exist.
   * 
   * Pages are 1-indexed.
   *
   * @param page the page number to get, in range [1, getPageCount()]
   * @return the page from the book
   * @deprecated in favour of {@link #page(int)}
  */
  getPage(page: number): string;
  /**
   * Sets the specified page in the book. Pages of the book must be
   * contiguous.
   * 
   * The data can be up to 256 characters in length, additional characters
   * are truncated.
   * 
   * Pages are 1-indexed.
   *
   * @param page the page number to set, in range [1, getPageCount()]
   * @param data the data to set for that page
   * @deprecated in favour of {@link #page(int, net.kyori.adventure.text.Component)}
  */
  setPage(page: number, data: string): void;
  /**
   * Gets all the pages in the book.
   *
   * @return list of all the pages in the book
   * @deprecated in favour of {@link #pages()}
  */
  getPages(): string[];
  /**
   * Clears the existing book pages, and sets the book to use the provided
   * pages. Maximum 100 pages with 256 characters per page.
   *
   * @param pages A list of pages to set the book to use
   * @deprecated in favour of {@link #pages(List)}
  */
  setPages(pages: string[]): void;
  /**
   * Clears the existing book pages, and sets the book to use the provided
   * pages. Maximum 50 pages with 256 characters per page.
   *
   * @param pages A list of strings, each being a page
   * @deprecated in favour of {@link #pages(net.kyori.adventure.text.Component...)}
  */
  setPages(pages: string[]): void;
  /**
   * Adds new pages to the end of the book. Up to a maximum of 50 pages with
   * 256 characters per page.
   *
   * @param pages A list of strings, each being a page
   * @deprecated in favour of {@link #addPages(net.kyori.adventure.text.Component...)}
  */
  addPage(...pages: string[]): void;
  /**
   * Gets the number of pages in the book.
   *
   * @return the number of pages in the book
  */
  getPageCount(): number;
  clone(): BookMeta;
  spigot(): Spigot;
  /**
   * Returns an updated book with the provided pages.
   *
   * @param pages the pages to set
   * @return a new book with modifications
   * @since 4.0.0
  */
  pages(...pages: Component[]): Book;
}
export interface BookMeta extends ItemMeta, Book {}
/**
 * Represents a bucket of axolotl.
*/
export class AxolotlBucketMeta extends ItemMeta {
  /**
   * Get the variant of the axolotl in the bucket.
   * 
   * Plugins should check that hasVariant() returns true before
   * calling this method.
   * @return axolotl variant
  */
  getVariant(): Variant;
  /**
   * Set the variant of this axolotl in the bucket.
   *
   * @param variant axolotl variant
  */
  setVariant(variant: Variant);
  /**
   * Checks for existence of a variant tag indicating a specific axolotl will be
   * spawned.
   *
   * @return if there is a variant
  */
  hasVariant(): boolean;
  clone(): AxolotlBucketMeta;
}
export class KnowledgeBookMeta extends ItemMeta {
  /**
   * Checks for the existence of recipes in the book.
   *
   * @return true if the book has recipes
  */
  hasRecipes(): boolean;
  /**
   * Gets all the recipes in the book.
   *
   * @return list of all the recipes in the book
  */
  getRecipes(): NamespacedKey[];
  /**
   * Clears the existing book recipes, and sets the book to use the provided
   * recipes.
   *
   * @param recipes A list of recipes to set the book to use
  */
  setRecipes(recipes: NamespacedKey[]);
  /**
   * Adds new recipe to the end of the book.
   *
   * @param recipes A list of recipe keys
  */
  addRecipe(...recipes: NamespacedKey[]): void;
  clone(): KnowledgeBookMeta;
}

}
declare module 'org.bukkit.generator.ChunkGenerator' {
import { Biome } from 'org.bukkit.block';
import { MaterialData } from 'org.bukkit.material';
import { BlockData } from 'org.bukkit.block.data';
import { Material } from 'org.bukkit';
/**
 * Interface to biome section for chunk to be generated: initialized with
 * default values for world type and seed.
 * 
 * Custom generator is free to access and tailor values during
 * generateBlockSections() or generateExtBlockSections().
 * @deprecated Biomes are now set with {@link BiomeProvider}
*/
export class BiomeGrid {
  /**
   * Get biome at x, z within chunk being generated
   *
   * @param x - 0-15
   * @param z - 0-15
   * @return Biome value
   * @deprecated biomes are now 3-dimensional
  */
  getBiome(x: number, z: number): Biome;
  /**
   * Get biome at x, z within chunk being generated
   *
   * @param x - 0-15
   * @param y - world minHeight (inclusive) - world maxHeight (exclusive)
   * @param z - 0-15
   * @return Biome value
  */
  getBiome(x: number, y: number, z: number): Biome;
  /**
   * Set biome at x, z within chunk being generated
   *
   * @param x - 0-15
   * @param z - 0-15
   * @param bio - Biome value
   * @deprecated biomes are now 3-dimensional
  */
  setBiome(x: number, z: number, bio: Biome): void;
  /**
   * Set biome at x, z within chunk being generated
   *
   * @param x - 0-15
   * @param y - world minHeight (inclusive) - world maxHeight (exclusive)
   * @param z - 0-15
   * @param bio - Biome value
  */
  setBiome(x: number, y: number, z: number, bio: Biome): void;
}
/**
 * Data for a Chunk.
*/
export class ChunkData {
  /**
   * Get the minimum height for this ChunkData.
   * 
   * It is not guaranteed that this method will return the same value as
   * {@link World#getMinHeight()}.
   * 
   * Setting blocks below this height will do nothing.
   *
   * @return the minimum height
  */
  getMinHeight(): number;
  /**
   * Get the maximum height for this ChunkData.
   * 
   * It is not guaranteed that this method will return the same value as
   * {@link World#getMaxHeight()}.
   * 
   * Setting blocks at or above this height will do nothing.
   *
   * @return the maximum height
  */
  getMaxHeight(): number;
  /**
   * Get the biome at x, y, z within chunk being generated
   *
   * @param x the x location in the chunk from 0-15 inclusive
   * @param y the y location in the chunk from minimum (inclusive) -
   * maxHeight (exclusive)
   * @param z the z location in the chunk from 0-15 inclusive
   * @return Biome value
  */
  getBiome(x: number, y: number, z: number): Biome;
  /**
   * Set the block at x,y,z in the chunk data to material.
   *
   * Note: setting blocks outside the chunk's bounds does nothing.
   *
   * @param x the x location in the chunk from 0-15 inclusive
   * @param y the y location in the chunk from minHeight (inclusive) - maxHeight (exclusive)
   * @param z the z location in the chunk from 0-15 inclusive
   * @param material the type to set the block to
  */
  setBlock(x: number, y: number, z: number, material: Material): void;
  /**
   * Set the block at x,y,z in the chunk data to material.
   *
   * Setting blocks outside the chunk's bounds does nothing.
   *
   * @param x the x location in the chunk from 0-15 inclusive
   * @param y the y location in the chunk from minHeight (inclusive) - maxHeight (exclusive)
   * @param z the z location in the chunk from 0-15 inclusive
   * @param material the type to set the block to
   * @deprecated use {@link #setBlock(int, int, int, BlockData)}
  */
  setBlock(x: number, y: number, z: number, material: MaterialData): void;
  /**
   * Set the block at x,y,z in the chunk data to material.
   *
   * Setting blocks outside the chunk's bounds does nothing.
   *
   * @param x the x location in the chunk from 0-15 inclusive
   * @param y the y location in the chunk from minHeight (inclusive) - maxHeight (exclusive)
   * @param z the z location in the chunk from 0-15 inclusive
   * @param blockData the type to set the block to
  */
  setBlock(x: number, y: number, z: number, blockData: BlockData): void;
  /**
   * Set a region of this chunk from xMin, yMin, zMin (inclusive)
   * to xMax, yMax, zMax (exclusive) to material.
   *
   * Setting blocks outside the chunk's bounds does nothing.
   *
   * @param xMin minimum x location (inclusive) in the chunk to set
   * @param yMin minimum y location (inclusive) in the chunk to set
   * @param zMin minimum z location (inclusive) in the chunk to set
   * @param xMax maximum x location (exclusive) in the chunk to set
   * @param yMax maximum y location (exclusive) in the chunk to set
   * @param zMax maximum z location (exclusive) in the chunk to set
   * @param material the type to set the blocks to
  */
  setRegion(xMin: number, yMin: number, zMin: number, xMax: number, yMax: number, zMax: number, material: Material): void;
  /**
   * Set a region of this chunk from xMin, yMin, zMin (inclusive)
   * to xMax, yMax, zMax (exclusive) to material.
   *
   * Setting blocks outside the chunk's bounds does nothing.
   *
   * @param xMin minimum x location (inclusive) in the chunk to set
   * @param yMin minimum y location (inclusive) in the chunk to set
   * @param zMin minimum z location (inclusive) in the chunk to set
   * @param xMax maximum x location (exclusive) in the chunk to set
   * @param yMax maximum y location (exclusive) in the chunk to set
   * @param zMax maximum z location (exclusive) in the chunk to set
   * @param material the type to set the blocks to
   * @deprecated use {@link #setRegion(int, int, int, int, int, int, BlockData)}
  */
  setRegion(xMin: number, yMin: number, zMin: number, xMax: number, yMax: number, zMax: number, material: MaterialData): void;
  /**
   * Set a region of this chunk from xMin, yMin, zMin (inclusive) to xMax,
   * yMax, zMax (exclusive) to material.
   *
   * Setting blocks outside the chunk's bounds does nothing.
   *
   * @param xMin minimum x location (inclusive) in the chunk to set
   * @param yMin minimum y location (inclusive) in the chunk to set
   * @param zMin minimum z location (inclusive) in the chunk to set
   * @param xMax maximum x location (exclusive) in the chunk to set
   * @param yMax maximum y location (exclusive) in the chunk to set
   * @param zMax maximum z location (exclusive) in the chunk to set
   * @param blockData the type to set the blocks to
  */
  setRegion(xMin: number, yMin: number, zMin: number, xMax: number, yMax: number, zMax: number, blockData: BlockData): void;
  /**
   * Get the type of the block at x, y, z.
   *
   * Getting blocks outside the chunk's bounds returns air.
   *
   * @param x the x location in the chunk from 0-15 inclusive
   * @param y the y location in the chunk from minHeight (inclusive) - maxHeight (exclusive)
   * @param z the z location in the chunk from 0-15 inclusive
   * @return the type of the block or Material.AIR if x, y or z are outside the chunk's bounds
  */
  getType(x: number, y: number, z: number): Material;
  /**
   * Get the type and data of the block at x, y, z.
   *
   * Getting blocks outside the chunk's bounds returns air.
   *
   * @param x the x location in the chunk from 0-15 inclusive
   * @param y the y location in the chunk from minHeight (inclusive) - maxHeight (exclusive)
   * @param z the z location in the chunk from 0-15 inclusive
   * @return the type and data of the block or the MaterialData for air if x, y or z are outside the chunk's bounds
   * @deprecated use {@link #getBlockData(int, int, int)}
  */
  getTypeAndData(x: number, y: number, z: number): MaterialData;
  /**
   * Get the type and data of the block at x, y, z.
   *
   * Getting blocks outside the chunk's bounds returns air.
   *
   * @param x the x location in the chunk from 0-15 inclusive
   * @param y the y location in the chunk from minHeight (inclusive) - maxHeight (exclusive)
   * @param z the z location in the chunk from 0-15 inclusive
   * @return the data of the block or the BlockData for air if x, y or z are outside the chunk's bounds
  */
  getBlockData(x: number, y: number, z: number): BlockData;
  /**
   * Get the block data at x,y,z in the chunk data.
   *
   * Getting blocks outside the chunk's bounds returns 0.
   *
   * @param x the x location in the chunk from 0-15 inclusive
   * @param y the y location in the chunk from minHeight (inclusive) - maxHeight (exclusive)
   * @param z the z location in the chunk from 0-15 inclusive
   * @return the block data value or air if x, y or z are outside the chunk's bounds
   * @deprecated Uses magic values
  */
  getData(x: number, y: number, z: number): number;
}

}
declare module 'org.bukkit.event.block' {
import { Component } from 'net.kyori.adventure.text';
import { List } from 'java.util';
import { Enum } from 'java.lang';
import { BlockState, BlockFace, Block } from 'org.bukkit.block';
import { Vector } from 'org.bukkit.util';
import { HandlerList, Cancellable, Event } from 'org.bukkit.event';
import { ChangeReason } from 'org.bukkit.event.block.CauldronLevelChangeEvent';
import { BlockData } from 'org.bukkit.block.data';
import { IgniteCause } from 'org.bukkit.event.block.BlockIgniteEvent';
import { CookingRecipe, EquipmentSlot, ItemStack } from 'org.bukkit.inventory';
import { Note, Instrument, GameEvent, Material, Location } from 'org.bukkit';
import { LivingEntity, Entity, Item, Player } from 'org.bukkit.entity';
/**
 * Called when a block grows naturally in the world.
 * 
 * Examples:
 * 
 * Wheat
 * Sugar Cane
 * Cactus
 * Watermelon
 * Pumpkin
 * Turtle Egg
 * 
 * 
 * If a Block Grow event is cancelled, the block will not grow.
*/
export class BlockGrowEvent extends BlockEvent {
  constructor(block: Block, newState: BlockState);
  /**
   * Gets the state of the block where it will form or spread to.
   *
   * @return The block state for this events block
  */
  getNewState(): BlockState;
  /**
   * Gets the cancellation state of this event. A cancelled event will not
   * be executed in the server, but will still pass to other plugins
   *
   * @return true if this event is cancelled
  */
  isCancelled(): boolean;
  /**
   * Sets the cancellation state of this event. A cancelled event will not
   * be executed in the server, but will still pass to other plugins.
   *
   * @param cancel true if you wish to cancel this event
  */
  setCancelled(cancel: boolean): void;
  getHandlers(): HandlerList;
  static getHandlerList(): HandlerList;
}
export interface BlockGrowEvent extends BlockEvent, Cancellable {}
/**
 * Called when leaves are decaying naturally.
 * 
 * If a Leaves Decay event is cancelled, the leaves will not decay.
*/
export class LeavesDecayEvent extends BlockEvent {
  constructor(block: Block);
  /**
   * Gets the cancellation state of this event. A cancelled event will not
   * be executed in the server, but will still pass to other plugins
   *
   * @return true if this event is cancelled
  */
  isCancelled(): boolean;
  /**
   * Sets the cancellation state of this event. A cancelled event will not
   * be executed in the server, but will still pass to other plugins.
   *
   * @param cancel true if you wish to cancel this event
  */
  setCancelled(cancel: boolean): void;
  getHandlers(): HandlerList;
  static getHandlerList(): HandlerList;
}
export interface LeavesDecayEvent extends BlockEvent, Cancellable {}
/**
 * Called when a block explodes
*/
export class BlockExplodeEvent extends BlockEvent {
  constructor(what: Block, blocks: Block[], yield: number);
  /**
   * Gets the cancellation state of this event. A cancelled event will not
   * be executed in the server, but will still pass to other plugins
   *
   * @return true if this event is cancelled
  */
  isCancelled(): boolean;
  /**
   * Sets the cancellation state of this event. A cancelled event will not
   * be executed in the server, but will still pass to other plugins.
   *
   * @param cancel true if you wish to cancel this event
  */
  setCancelled(cancel: boolean): void;
  /**
   * Returns the list of blocks that would have been removed or were removed
   * from the explosion event.
   *
   * @return All blown-up blocks
  */
  blockList(): Block[];
  /**
   * Returns the percentage of blocks to drop from this explosion
   *
   * @return The yield.
  */
  getYield(): number;
  /**
   * Sets the percentage of blocks to drop from this explosion
   *
   * @param yield The new yield percentage
  */
  setYield(yield: number);
  getHandlers(): HandlerList;
  static getHandlerList(): HandlerList;
}
export interface BlockExplodeEvent extends BlockEvent, Cancellable {}
/**
 * Called when a redstone current changes
*/
export class BlockRedstoneEvent extends BlockEvent {
  constructor(block: Block, oldCurrent: number, newCurrent: number);
  /**
   * Gets the old current of this block
   *
   * @return The previous current
  */
  getOldCurrent(): number;
  /**
   * Gets the new current of this block
   *
   * @return The new current
  */
  getNewCurrent(): number;
  /**
   * Sets the new current of this block
   *
   * @param newCurrent The new current to set
  */
  setNewCurrent(newCurrent: number);
  getHandlers(): HandlerList;
  static getHandlerList(): HandlerList;
}
/**
 * Called when the moisture level of a soil block changes.
*/
export class MoistureChangeEvent extends BlockEvent {
  constructor(block: Block, newState: BlockState);
  /**
   * Gets the new state of the affected block.
   *
   * @return new block state
  */
  getNewState(): BlockState;
  /**
   * Gets the cancellation state of this event. A cancelled event will not
   * be executed in the server, but will still pass to other plugins
   *
   * @return true if this event is cancelled
  */
  isCancelled(): boolean;
  /**
   * Sets the cancellation state of this event. A cancelled event will not
   * be executed in the server, but will still pass to other plugins.
   *
   * @param cancel true if you wish to cancel this event
  */
  setCancelled(cancel: boolean): void;
  getHandlers(): HandlerList;
  static getHandlerList(): HandlerList;
}
export interface MoistureChangeEvent extends BlockEvent, Cancellable {}
/**
 * Called when a block is ignited. If you want to catch when a Player places
 * fire, you need to use {@link BlockPlaceEvent}.
 * 
 * If a Block Ignite event is cancelled, the block will not be ignited.
*/
export class BlockIgniteEvent extends BlockEvent {
  constructor(theBlock: Block, cause: IgniteCause, ignitingEntity: Entity | null);
  constructor(theBlock: Block, cause: IgniteCause, ignitingBlock: Block);
  constructor(theBlock: Block, cause: IgniteCause, ignitingEntity: Entity | null, ignitingBlock: Block | null);
  /**
   * Gets the cancellation state of this event. A cancelled event will not
   * be executed in the server, but will still pass to other plugins
   *
   * @return true if this event is cancelled
  */
  isCancelled(): boolean;
  /**
   * Sets the cancellation state of this event. A cancelled event will not
   * be executed in the server, but will still pass to other plugins.
   *
   * @param cancel true if you wish to cancel this event
  */
  setCancelled(cancel: boolean): void;
  /**
   * Gets the cause of block ignite.
   *
   * @return An IgniteCause value detailing the cause of block ignition
  */
  getCause(): IgniteCause;
  /**
   * Gets the player who ignited this block
   *
   * @return The Player that placed/ignited the fire block, or null if not ignited by a Player.
  */
  getPlayer(): Player | null;
  /**
   * Gets the entity who ignited this block
   *
   * @return The Entity that placed/ignited the fire block, or null if not ignited by a Entity.
  */
  getIgnitingEntity(): Entity | null;
  /**
   * Gets the block which ignited this block
   *
   * @return The Block that placed/ignited the fire block, or null if not ignited by a Block.
  */
  getIgnitingBlock(): Block | null;
  getHandlers(): HandlerList;
  static getHandlerList(): HandlerList;
}
export interface BlockIgniteEvent extends BlockEvent, Cancellable {}
/**
 * Called when a Sculk sensor receives a game event and hence might activate.
 *
 * Will be called cancelled if the block's default behavior is to ignore the
 * event.
*/
export class BlockReceiveGameEvent extends BlockEvent {
  constructor(event: GameEvent, block: Block, entity: Entity | null);
  /**
   * Get the underlying event.
   *
   * @return the event
  */
  getEvent(): GameEvent;
  /**
   * Get the entity which triggered this event, if present.
   *
   * @return triggering entity or null
  */
  getEntity(): Entity | null;
  /**
   * Sets the cancellation state of this event. A cancelled event will not
   * be executed in the server, but will still pass to other plugins.
   *
   * @param cancel true if you wish to cancel this event
  */
  setCancelled(cancel: boolean): void;
  /**
   * Gets the cancellation state of this event. A cancelled event will not
   * be executed in the server, but will still pass to other plugins
   *
   * @return true if this event is cancelled
  */
  isCancelled(): boolean;
  getHandlers(): HandlerList;
  static getHandlerList(): HandlerList;
}
export interface BlockReceiveGameEvent extends BlockEvent, Cancellable {}
/**
 * Called when the fluid level of a block changes due to changes in adjacent
 * blocks.
*/
export class FluidLevelChangeEvent extends BlockEvent {
  constructor(theBlock: Block, newData: BlockData);
  /**
   * Gets the new data of the changed block.
   *
   * @return new data
  */
  getNewData(): BlockData;
  /**
   * Sets the new data of the changed block. Must be of the same Material as
   * the old one.
   *
   * @param newData the new data
  */
  setNewData(newData: BlockData);
  /**
   * Gets the cancellation state of this event. A cancelled event will not
   * be executed in the server, but will still pass to other plugins
   *
   * @return true if this event is cancelled
  */
  isCancelled(): boolean;
  /**
   * Sets the cancellation state of this event. A cancelled event will not
   * be executed in the server, but will still pass to other plugins.
   *
   * @param cancel true if you wish to cancel this event
  */
  setCancelled(cancelled: boolean): void;
  getHandlers(): HandlerList;
  static getHandlerList(): HandlerList;
}
export interface FluidLevelChangeEvent extends BlockEvent, Cancellable {}
/**
 * Called if a block broken by a player drops an item.
 *
 * If the block break is cancelled, this event won't be called.
 *
 * If isDropItems in BlockBreakEvent is set to false, this event won't be
 * called.
 *
 * This event will also be called if the player breaks a multi block structure,
 * for example a torch on top of a stone. Both items will have an event call.
 *
 * The Block is already broken as this event is called, so #getBlock() will be
 * AIR in most cases. Use #getBlockState() for more Information about the broken
 * block.
*/
export class BlockDropItemEvent extends BlockEvent {
  constructor(block: Block, blockState: BlockState, player: Player, items: Item[]);
  /**
   * Gets the Player that is breaking the block involved in this event.
   *
   * @return The Player that is breaking the block involved in this event
  */
  getPlayer(): Player;
  /**
   * Gets the BlockState of the block involved in this event before it was
   * broken.
   *
   * @return The BlockState of the block involved in this event
  */
  getBlockState(): BlockState;
  /**
   * Gets list of the Item drops caused by the block break.
   *
   * This list is mutable - removing an item from it will cause it to not
   * drop. Adding to the list is allowed.
   *
   * @return The Item the block caused to drop
  */
  getItems(): Item[];
  /**
   * Gets the cancellation state of this event. A cancelled event will not
   * be executed in the server, but will still pass to other plugins
   *
   * @return true if this event is cancelled
  */
  isCancelled(): boolean;
  /**
   * Sets the cancellation state of this event. A cancelled event will not
   * be executed in the server, but will still pass to other plugins.
   *
   * @param cancel true if you wish to cancel this event
  */
  setCancelled(cancel: boolean): void;
  getHandlers(): HandlerList;
  static getHandlerList(): HandlerList;
}
export interface BlockDropItemEvent extends BlockEvent, Cancellable {}
/**
 * Called when a block is destroyed as a result of being burnt by fire.
 * 
 * If a Block Burn event is cancelled, the block will not be destroyed as a
 * result of being burnt by fire.
*/
export class BlockBurnEvent extends BlockEvent {
  constructor(block: Block);
  constructor(block: Block, ignitingBlock: Block | null);
  /**
   * Gets the block which ignited this block.
   *
   * @return The Block that ignited and burned this block, or null if no
   * source block exists
  */
  getIgnitingBlock(): Block | null;
  /**
   * Gets the cancellation state of this event. A cancelled event will not
   * be executed in the server, but will still pass to other plugins
   *
   * @return true if this event is cancelled
  */
  isCancelled(): boolean;
  /**
   * Sets the cancellation state of this event. A cancelled event will not
   * be executed in the server, but will still pass to other plugins.
   *
   * @param cancel true if you wish to cancel this event
  */
  setCancelled(cancel: boolean): void;
  getHandlers(): HandlerList;
  static getHandlerList(): HandlerList;
}
export interface BlockBurnEvent extends BlockEvent, Cancellable {}
/**
 * Called when a block is placed by a player.
 * 
 * If a Block Place event is cancelled, the block will not be placed.
*/
export class BlockPlaceEvent extends BlockEvent {
  constructor(placedBlock: Block, replacedBlockState: BlockState, placedAgainst: Block, itemInHand: ItemStack, thePlayer: Player, canBuild: boolean);
  constructor(placedBlock: Block, replacedBlockState: BlockState, placedAgainst: Block, itemInHand: ItemStack, thePlayer: Player, canBuild: boolean, hand: EquipmentSlot);
  /**
   * Gets the cancellation state of this event. A cancelled event will not
   * be executed in the server, but will still pass to other plugins
   *
   * @return true if this event is cancelled
  */
  isCancelled(): boolean;
  /**
   * Sets the cancellation state of this event. A cancelled event will not
   * be executed in the server, but will still pass to other plugins.
   *
   * @param cancel true if you wish to cancel this event
  */
  setCancelled(cancel: boolean): void;
  /**
   * Gets the player who placed the block involved in this event.
   *
   * @return The Player who placed the block involved in this event
  */
  getPlayer(): Player;
  /**
   * Clarity method for getting the placed block. Not really needed except
   * for reasons of clarity.
   *
   * @return The Block that was placed
  */
  getBlockPlaced(): Block;
  /**
   * Gets the BlockState for the block which was replaced. Material type air
   * mostly.
   *
   * @return The BlockState for the block which was replaced.
  */
  getBlockReplacedState(): BlockState;
  /**
   * Gets the block that this block was placed against
   *
   * @return Block the block that the new block was placed against
  */
  getBlockAgainst(): Block;
  /**
   * Gets the item in the player's hand when they placed the block.
   *
   * @return The ItemStack for the item in the player's hand when they
   *     placed the block
  */
  getItemInHand(): ItemStack;
  /**
   * Gets the hand which placed the block
   * @return Main or off-hand, depending on which hand was used to place the block
  */
  getHand(): EquipmentSlot;
  /**
   * Gets the value whether the player would be allowed to build here.
   * Defaults to spawn if the server was going to stop them (such as, the
   * player is in Spawn). Note that this is an entirely different check
   * than BLOCK_CANBUILD, as this refers to a player, not universe-physics
   * rule like cactus on dirt.
   *
   * @return boolean whether the server would allow a player to build here
  */
  canBuild(): boolean;
  /**
   * Sets the canBuild state of this event. Set to true if you want the
   * player to be able to build.
   *
   * @param canBuild true if you want the player to be able to build
  */
  setBuild(canBuild: boolean): void;
  getHandlers(): HandlerList;
  static getHandlerList(): HandlerList;
}
export interface BlockPlaceEvent extends BlockEvent, Cancellable {}
/**
 * Thrown when a block physics check is called.
 * 
 * This event is a high frequency event, it may be called thousands of times per
 * a second on a busy server. Plugins are advised to listen to the event with
 * caution and only perform lightweight checks when using it.
 * 
 * In addition to this, cancelling the event is liable to leave the world in an
 * inconsistent state. For example if you use the event to leave a block
 * floating in mid air when that block has a requirement to be attached to
 * something, there is no guarantee that the floating block will persist across
 * server restarts or map upgrades.
 * 
 * Plugins should also note that where possible this event may only called for
 * the "root" block of physics updates in order to limit event spam. Physics
 * updates that cause other blocks to change their state may not result in an
 * event for each of those blocks (usually adjacent). If you are concerned about
 * monitoring these changes then you should check adjacent blocks yourself.
*/
export class BlockPhysicsEvent extends BlockEvent {
  constructor(block: Block, changed: BlockData, sourceX: number, sourceY: number, sourceZ: number);
  constructor(block: Block, changed: BlockData);
  constructor(block: Block, changed: BlockData, sourceBlock: Block);
  /**
   * Gets the source block that triggered this event.
   *
   * Note: This will default to block if not set.
   *
   * @return The source block
  */
  getSourceBlock(): Block;
  /**
   * Gets the type of block that changed, causing this event.
   * This is the type of {@link #getBlock()} at the time of the event.
   *
   * @return Changed block's type
  */
  getChangedType(): Material;
  /**
   * Gets the BlockData of the block that changed, causing this event.
   * This is the BlockData of {@link #getBlock()} at the time of the event.
   *
   * @return Changed block's BlockData
  */
  getChangedBlockData(): BlockData;
  /**
   * Gets the cancellation state of this event. A cancelled event will not
   * be executed in the server, but will still pass to other plugins
   *
   * @return true if this event is cancelled
  */
  isCancelled(): boolean;
  /**
   * Sets the cancellation state of this event. A cancelled event will not
   * be executed in the server, but will still pass to other plugins.
   *
   * @param cancel true if you wish to cancel this event
  */
  setCancelled(cancel: boolean): void;
  getHandlers(): HandlerList;
  static getHandlerList(): HandlerList;
}
export interface BlockPhysicsEvent extends BlockEvent, Cancellable {}
/**
 * Event fired when a dispenser shears a nearby sheep.
*/
export class BlockShearEntityEvent extends BlockEvent {
  constructor(dispenser: Block, sheared: Entity, tool: ItemStack);
  /**
   * Gets the entity that was sheared.
   *
   * @return the entity that was sheared.
  */
  getEntity(): Entity;
  /**
   * Gets the item used to shear this sheep.
   *
   * @return the item used to shear this sheep.
  */
  getTool(): ItemStack;
  /**
   * Gets the cancellation state of this event. A cancelled event will not
   * be executed in the server, but will still pass to other plugins
   *
   * @return true if this event is cancelled
  */
  isCancelled(): boolean;
  /**
   * Sets the cancellation state of this event. A cancelled event will not
   * be executed in the server, but will still pass to other plugins.
   *
   * @param cancel true if you wish to cancel this event
  */
  setCancelled(cancelled: boolean): void;
  getHandlers(): HandlerList;
  static getHandlerList(): HandlerList;
}
export interface BlockShearEntityEvent extends BlockEvent, Cancellable {}
/**
 * Called when a block is broken by a player.
 * 
 * If you wish to have the block drop experience, you must set the experience
 * value above 0. By default, experience will be set in the event if:
 * 
 * The player is not in creative or adventure mode
 * The player can loot the block (ie: does not destroy it completely, by
 *     using the correct tool)
 * The player does not have silk touch
 * The block drops experience in vanilla Minecraft
 * 
 * 
 * Note:
 * Plugins wanting to simulate a traditional block drop should set the block
 * to air and utilize their own methods for determining what the default drop
 * for the block being broken is and what to do about it, if anything.
 * 
 * If a Block Break event is cancelled, the block will not break and
 * experience will not drop.
*/
export class BlockBreakEvent extends BlockExpEvent {
  constructor(theBlock: Block, player: Player);
  /**
   * Gets the Player that is breaking the block involved in this event.
   *
   * @return The Player that is breaking the block involved in this event
  */
  getPlayer(): Player;
  /**
   * Sets whether or not the block will attempt to drop items as it normally
   * would.
   *
   * If and only if this is false then {@link BlockDropItemEvent} will not be
   * called after this event.
   *
   * @param dropItems Whether or not the block will attempt to drop items
  */
  setDropItems(dropItems: boolean): void;
  /**
   * Gets whether or not the block will attempt to drop items.
   *
   * If and only if this is false then {@link BlockDropItemEvent} will not be
   * called after this event.
   *
   * @return Whether or not the block will attempt to drop items
  */
  isDropItems(): boolean;
  /**
   * Gets the cancellation state of this event. A cancelled event will not
   * be executed in the server, but will still pass to other plugins
   *
   * @return true if this event is cancelled
  */
  isCancelled(): boolean;
  /**
   * Sets the cancellation state of this event. A cancelled event will not
   * be executed in the server, but will still pass to other plugins.
   *
   * @param cancel true if you wish to cancel this event
  */
  setCancelled(cancel: boolean): void;
}
export interface BlockBreakEvent extends BlockExpEvent, Cancellable {}
/**
 * Called when an equippable item is dispensed from a block and equipped on a
 * nearby entity.
 * 
 * If a Block Dispense Armor event is cancelled, the equipment will not be
 * equipped on the target entity.
*/
export class BlockDispenseArmorEvent extends BlockDispenseEvent {
  constructor(block: Block, dispensed: ItemStack, target: LivingEntity);
  /**
   * Get the living entity on which the armor was dispensed.
   *
   * @return the target entity
  */
  getTargetEntity(): LivingEntity;
}
/**
 * Called when a block is formed or spreads based on world conditions.
 * 
 * Use {@link BlockSpreadEvent} to catch blocks that actually spread and don't
 * just "randomly" form.
 * 
 * Examples:
 * 
 * Snow forming due to a snow storm.
 * Ice forming in a snowy Biome like Taiga or Tundra.
 *  Obsidian / Cobblestone forming due to contact with water.
 *  Concrete forming due to mixing of concrete powder and water.
 * 
 * 
 * If a Block Form event is cancelled, the block will not be formed.
 *
 * @see BlockSpreadEvent
*/
export class BlockFormEvent extends BlockGrowEvent {
  constructor(block: Block, newState: BlockState);
  getHandlers(): HandlerList;
  static getHandlerList(): HandlerList;
}
export class CauldronLevelChangeEvent extends BlockEvent {
  constructor(block: Block, entity: Entity | null, reason: ChangeReason, newBlock: BlockState);
  /**
   * Get entity which did this. May be null.
   *
   * @return acting entity
  */
  getEntity(): Entity | null;
  getReason(): ChangeReason;
  /**
   * Gets the new state of the cauldron.
   *
   * @return The block state of the block that will be changed
  */
  getNewState(): BlockState;
  /**
   * Gets the old level of the cauldron.
   *
   * @return old level
   * @see #getBlock()
   * @deprecated not all cauldron contents are Levelled
  */
  getOldLevel(): number;
  /**
   * Gets the new level of the cauldron.
   *
   * @return new level
   * @see #getNewState()
   * @deprecated not all cauldron contents are Levelled
  */
  getNewLevel(): number;
  /**
   * Sets the new level of the cauldron.
   *
   * @param newLevel new level
   * @see #getNewState()
   * @deprecated not all cauldron contents are Levelled
  */
  setNewLevel(newLevel: number);
  /**
   * Gets the cancellation state of this event. A cancelled event will not
   * be executed in the server, but will still pass to other plugins
   *
   * @return true if this event is cancelled
  */
  isCancelled(): boolean;
  /**
   * Sets the cancellation state of this event. A cancelled event will not
   * be executed in the server, but will still pass to other plugins.
   *
   * @param cancel true if you wish to cancel this event
  */
  setCancelled(cancelled: boolean): void;
  getHandlers(): HandlerList;
  static getHandlerList(): HandlerList;
}
export interface CauldronLevelChangeEvent extends BlockEvent, Cancellable {}
/**
 * Called when a block spreads based on world conditions.
 * 
 * Use {@link BlockFormEvent} to catch blocks that "randomly" form instead of
 * actually spread.
 * 
 * Examples:
 * 
 * Mushrooms spreading.
 * Fire spreading.
 * 
 * 
 * If a Block Spread event is cancelled, the block will not spread.
 *
 * @see BlockFormEvent
*/
export class BlockSpreadEvent extends BlockFormEvent {
  constructor(block: Block, source: Block, newState: BlockState);
  /**
   * Gets the source block involved in this event.
   *
   * @return the Block for the source block involved in this event.
  */
  getSource(): Block;
  getHandlers(): HandlerList;
  static getHandlerList(): HandlerList;
}
/**
 * Called when a player stops damaging a Block.
 * @see BlockDamageEvent
*/
export class BlockDamageAbortEvent extends BlockEvent {
  constructor(player: Player, block: Block, itemInHand: ItemStack);
  /**
   * Gets the player that stopped damaging the block involved in this event.
   *
   * @return The player that stopped damaging the block
  */
  getPlayer(): Player;
  /**
   * Gets the ItemStack for the item currently in the player's hand.
   *
   * @return The ItemStack for the item currently in the player's hand
  */
  getItemInHand(): ItemStack;
  getHandlers(): HandlerList;
  static getHandlerList(): HandlerList;
}
/**
 * Called when a piston block is triggered
*/
export class BlockPistonEvent extends BlockEvent {
  constructor(block: Block, direction: BlockFace);
  /**
   * Gets the cancellation state of this event. A cancelled event will not
   * be executed in the server, but will still pass to other plugins
   *
   * @return true if this event is cancelled
  */
  isCancelled(): boolean;
  /**
   * Sets the cancellation state of this event. A cancelled event will not
   * be executed in the server, but will still pass to other plugins.
   *
   * @param cancel true if you wish to cancel this event
  */
  setCancelled(cancelled: boolean): void;
  /**
   * Returns true if the Piston in the event is sticky.
   *
   * @return stickiness of the piston
  */
  isSticky(): boolean;
  /**
   * Return the direction in which the piston will operate.
   *
   * @return direction of the piston
  */
  getDirection(): BlockFace;
}
export interface BlockPistonEvent extends BlockEvent, Cancellable {}
/**
 * An event that's called when a block yields experience.
*/
export class BlockExpEvent extends BlockEvent {
  constructor(block: Block, exp: number);
  /**
   * Get the experience dropped by the block after the event has processed
   *
   * @return The experience to drop
  */
  getExpToDrop(): number;
  /**
   * Set the amount of experience dropped by the block after the event has
   * processed
   *
   * @param exp 1 or higher to drop experience, else nothing will drop
  */
  setExpToDrop(expToDrop: number);
  getHandlers(): HandlerList;
  static getHandlerList(): HandlerList;
}
/**
 * Called when an item is dispensed from a block.
 * 
 * If a Block Dispense event is cancelled, the block will not dispense the
 * item.
*/
export class BlockDispenseEvent extends BlockEvent {
  constructor(block: Block, dispensed: ItemStack, velocity: Vector);
  /**
   * Gets the item that is being dispensed. Modifying the returned item will
   * have no effect, you must use {@link
   * #setItem(org.bukkit.inventory.ItemStack)} instead.
   *
   * @return An ItemStack for the item being dispensed
  */
  getItem(): ItemStack;
  /**
   * Sets the item being dispensed.
   *
   * @param item the item being dispensed
  */
  setItem(item: ItemStack);
  /**
   * Gets the velocity in meters per tick.
   * 
   * Note: Modifying the returned Vector will not change the velocity, you
   * must use {@link #setVelocity(org.bukkit.util.Vector)} instead.
   *
   * @return A Vector for the dispensed item's velocity
  */
  getVelocity(): Vector;
  /**
   * Sets the velocity of the item being dispensed in meters per tick.
   *
   * @param vel the velocity of the item being dispensed
  */
  setVelocity(velocity: Vector);
  /**
   * Gets the cancellation state of this event. A cancelled event will not
   * be executed in the server, but will still pass to other plugins
   *
   * @return true if this event is cancelled
  */
  isCancelled(): boolean;
  /**
   * Sets the cancellation state of this event. A cancelled event will not
   * be executed in the server, but will still pass to other plugins.
   *
   * @param cancel true if you wish to cancel this event
  */
  setCancelled(cancel: boolean): void;
  getHandlers(): HandlerList;
  static getHandlerList(): HandlerList;
}
export interface BlockDispenseEvent extends BlockEvent, Cancellable {}
/**
 * Called when a piston retracts
*/
export class BlockPistonRetractEvent extends BlockPistonEvent {
  constructor(block: Block, blocks: Block[], direction: BlockFace);
  /**
   * Gets the location where the possible moving block might be if the
   * retracting piston is sticky.
   *
   * @return The possible location of the possibly moving block.
  */
  getRetractLocation(): Location;
  /**
   * Get an immutable list of the blocks which will be moved by the
   * extending.
   *
   * @return Immutable list of the moved blocks.
  */
  getBlocks(): Block[];
  getHandlers(): HandlerList;
  static getHandlerList(): HandlerList;
}
/**
 * Fired when a single block placement action of a player triggers the
 * creation of multiple blocks(e.g. placing a bed block). The block returned
 * by {@link #getBlockPlaced()} and its related methods is the block where
 * the placed block would exist if the placement only affected a single
 * block.
*/
export class BlockMultiPlaceEvent extends BlockPlaceEvent {
  constructor(states: BlockState[], clicked: Block, itemInHand: ItemStack, thePlayer: Player, canBuild: boolean);
  constructor(states: BlockState[], clicked: Block, itemInHand: ItemStack, thePlayer: Player, canBuild: boolean, hand: EquipmentSlot);
  /**
   * Gets a list of blockstates for all blocks which were replaced by the
   * placement of the new blocks. Most of these blocks will just have a
   * Material type of AIR.
   *
   * @return immutable list of replaced BlockStates
  */
  getReplacedBlockStates(): BlockState[];
}
/**
 * Called when an ItemStack is successfully cooked in a block.
*/
export class BlockCookEvent extends BlockEvent {
  constructor(block: Block, source: ItemStack, result: ItemStack);
  constructor(block: Block, source: ItemStack, result: ItemStack, recipe: CookingRecipe<any> | null);
  /**
   * Gets the smelted ItemStack for this event
   *
   * @return smelting source ItemStack
  */
  getSource(): ItemStack;
  /**
   * Gets the resultant ItemStack for this event
   *
   * @return smelting result ItemStack
  */
  getResult(): ItemStack;
  /**
   * Sets the resultant ItemStack for this event
   *
   * @param result new result ItemStack
  */
  setResult(result: ItemStack);
  /**
   * Gets the cancellation state of this event. A cancelled event will not
   * be executed in the server, but will still pass to other plugins
   *
   * @return true if this event is cancelled
  */
  isCancelled(): boolean;
  /**
   * Sets the cancellation state of this event. A cancelled event will not
   * be executed in the server, but will still pass to other plugins.
   *
   * @param cancel true if you wish to cancel this event
  */
  setCancelled(cancel: boolean): void;
  /**
   * Gets the cooking recipe associated with this event.
   *
   * @return the recipe
  */
  getRecipe(): CookingRecipe<any> | null;
  getHandlers(): HandlerList;
  static getHandlerList(): HandlerList;
}
export interface BlockCookEvent extends BlockEvent, Cancellable {}
export class Action extends Enum<Action> {
  /**
   * Left-clicking a block
  */
  static readonly LEFT_CLICK_BLOCK: Action;
  /**
   * Right-clicking a block
  */
  static readonly RIGHT_CLICK_BLOCK: Action;
  /**
   * Left-clicking the air
  */
  static readonly LEFT_CLICK_AIR: Action;
  /**
   * Right-clicking the air
  */
  static readonly RIGHT_CLICK_AIR: Action;
  static readonly PHYSICAL: Action;
  static valueOf(name: string): Action;
  static values(): Action[];
  /**
   * Gets whether this action is a result of a left click.
   *
   * @return Whether it's a left click
  */
  isLeftClick(): boolean;
  /**
   * Gets whether this action is a result of a right click.
   *
   * @return Whether it's a right click
  */
  isRightClick(): boolean;
}
/**
 * Called when a block fades, melts or disappears based on world conditions
 * 
 * Examples:
 * 
 * Snow melting due to being near a light source.
 * Ice melting due to being near a light source.
 * Fire burning out after time, without destroying fuel block.
 * Coral fading to dead coral due to lack of water
 * Turtle Egg bursting when a turtle hatches
 * 
 * 
 * If a Block Fade event is cancelled, the block will not fade, melt or
 * disappear.
*/
export class BlockFadeEvent extends BlockEvent {
  constructor(block: Block, newState: BlockState);
  /**
   * Gets the state of the block that will be fading, melting or
   * disappearing.
   *
   * @return The block state of the block that will be fading, melting or
   *     disappearing
  */
  getNewState(): BlockState;
  /**
   * Gets the cancellation state of this event. A cancelled event will not
   * be executed in the server, but will still pass to other plugins
   *
   * @return true if this event is cancelled
  */
  isCancelled(): boolean;
  /**
   * Sets the cancellation state of this event. A cancelled event will not
   * be executed in the server, but will still pass to other plugins.
   *
   * @param cancel true if you wish to cancel this event
  */
  setCancelled(cancel: boolean): void;
  getHandlers(): HandlerList;
  static getHandlerList(): HandlerList;
}
export interface BlockFadeEvent extends BlockEvent, Cancellable {}
/**
 * Called when a piston extends
*/
export class BlockPistonExtendEvent extends BlockPistonEvent {
  constructor(block: Block, length: number, direction: BlockFace);
  constructor(block: Block, blocks: Block[], direction: BlockFace);
  /**
   * Get the amount of blocks which will be moved while extending.
   *
   * @return the amount of moving blocks
   * @deprecated slime blocks make the value of this method
   *          inaccurate due to blocks being pushed at the side
  */
  getLength(): number;
  /**
   * Get an immutable list of the blocks which will be moved by the
   * extending.
   *
   * @return Immutable list of the moved blocks.
  */
  getBlocks(): Block[];
  getHandlers(): HandlerList;
  static getHandlerList(): HandlerList;
}
/**
 * Called when a block is formed by entities.
 * 
 * Examples:
 * 
 * Snow formed by a {@link org.bukkit.entity.Snowman}.
 * Frosted Ice formed by the Frost Walker enchantment.
 * 
*/
export class EntityBlockFormEvent extends BlockFormEvent {
  constructor(entity: Entity, block: Block, blockstate: BlockState);
  /**
   * Get the entity that formed the block.
   *
   * @return Entity involved in event
  */
  getEntity(): Entity;
}
/**
 * Called when we try to place a block, to see if we can build it here or not.
 * 
 * Note:
 * 
 * The Block returned by getBlock() is the block we are trying to place
 *     on, not the block we are trying to place.
 * If you want to figure out what is being placed, use {@link
 *     #getMaterial()} instead.
 * 
*/
export class BlockCanBuildEvent extends BlockEvent {
  constructor(block: Block, type: BlockData, canBuild: boolean);
  /**
   * @param block the block involved in this event
   * @param player the player placing the block
   * @param type the id of the block to place
   * @param canBuild whether we can build
  */
  constructor(block: Block, player: Player | null, type: BlockData, canBuild: boolean);
  /**
   * Gets whether or not the block can be built here.
   * 
   * By default, returns Minecraft's answer on whether the block can be
   * built here or not.
   *
   * @return boolean whether or not the block can be built
  */
  isBuildable(): boolean;
  /**
   * Sets whether the block can be built here or not.
   *
   * @param cancel true if you want to allow the block to be built here
   *     despite Minecraft's default behaviour
  */
  setBuildable(cancel: boolean): void;
  /**
   * Gets the Material that we are trying to place.
   *
   * @return The Material that we are trying to place
  */
  getMaterial(): Material;
  /**
   * Gets the BlockData that we are trying to place.
   *
   * @return The BlockData that we are trying to place
  */
  getBlockData(): BlockData;
  /**
   * Gets the player who placed the block involved in this event.
   * 
   * May be null for legacy calls of the event.
   *
   * @return The Player who placed the block involved in this event
  */
  getPlayer(): Player | null;
  getHandlers(): HandlerList;
  static getHandlerList(): HandlerList;
}
/**
 * Represents events with a source block and a destination block, currently
 * only applies to liquid (lava and water) and teleporting dragon eggs.
 * 
 * If a Block From To event is cancelled, the block will not move (the liquid
 * will not flow).
*/
export class BlockFromToEvent extends BlockEvent {
  constructor(block: Block, face: BlockFace);
  constructor(block: Block, toBlock: Block);
  /**
   * Gets the BlockFace that the block is moving to.
   *
   * @return The BlockFace that the block is moving to
  */
  getFace(): BlockFace;
  /**
   * Convenience method for getting the faced Block.
   *
   * @return The faced Block
  */
  getToBlock(): Block;
  /**
   * Gets the cancellation state of this event. A cancelled event will not
   * be executed in the server, but will still pass to other plugins
   *
   * @return true if this event is cancelled
  */
  isCancelled(): boolean;
  /**
   * Sets the cancellation state of this event. A cancelled event will not
   * be executed in the server, but will still pass to other plugins.
   *
   * @param cancel true if you wish to cancel this event
  */
  setCancelled(cancel: boolean): void;
  getHandlers(): HandlerList;
  static getHandlerList(): HandlerList;
}
export interface BlockFromToEvent extends BlockEvent, Cancellable {}
/**
 * Called when a sign is changed by a player.
 * 
 * If a Sign Change event is cancelled, the sign will not be changed.
*/
export class SignChangeEvent extends BlockEvent {
  constructor(theBlock: Block, player: Player, adventure$lines: Component[]);
  constructor(theBlock: Block, thePlayer: Player, theLines: string[]);
  /**
   * Gets the player changing the sign involved in this event.
   *
   * @return the Player involved in this event
  */
  getPlayer(): Player;
  /**
   * Gets all of the lines of text from the sign involved in this event.
   *
   * @return the String array for the sign's lines new text
  */
  lines(): Component[];
  /**
   * Gets a single line of text from the sign involved in this event.
   *
   * @param index index of the line to get
   * @return the String containing the line of text associated with the
   *     provided index
   * @throws IndexOutOfBoundsException thrown when the provided index is {@literal > 3
   *     or < 0}
  */
  line(index: number): Component | null;
  /**
   * Sets a single line for the sign involved in this event
   *
   * @param index index of the line to set
   * @param line text to set
   * @throws IndexOutOfBoundsException thrown when the provided index is {@literal > 3
   *     or < 0}
  */
  line(index: number, line: Component | null): void;
  /**
   * Gets a single line of text from the sign involved in this event.
   *
   * @param index index of the line to get
   * @return the String containing the line of text associated with the
   *     provided index
   * @throws IndexOutOfBoundsException thrown when the provided index is {@literal > 3
   *     or < 0}
   * @deprecated in favour of {@link #line(int)}
  */
  getLine(index: number): string | null;
  /**
   * Sets a single line for the sign involved in this event
   *
   * @param index index of the line to set
   * @param line text to set
   * @throws IndexOutOfBoundsException thrown when the provided index is {@literal > 3
   *     or < 0}
   * @deprecated in favour of {@link #line(int, net.kyori.adventure.text.Component)}
  */
  setLine(index: number, line: string | null): void;
  /**
   * Gets the cancellation state of this event. A cancelled event will not
   * be executed in the server, but will still pass to other plugins
   *
   * @return true if this event is cancelled
  */
  isCancelled(): boolean;
  /**
   * Sets the cancellation state of this event. A cancelled event will not
   * be executed in the server, but will still pass to other plugins.
   *
   * @param cancel true if you wish to cancel this event
  */
  setCancelled(cancel: boolean): void;
  getHandlers(): HandlerList;
  static getHandlerList(): HandlerList;
}
export interface SignChangeEvent extends BlockEvent, Cancellable {}
/**
 * Represents a block related event.
*/
export class BlockEvent extends Event {
  constructor(theBlock: Block);
  /**
   * Gets the block involved in this event.
   *
   * @return The Block which block is involved in this event
  */
  getBlock(): Block;
}
/**
 * Called when a sponge absorbs water from the world.
 * 
 * The world will be in its previous state, and {@link #getBlocks()} will
 * represent the changes to be made to the world, if the event is not cancelled.
 * 
 * As this is a physics based event it may be called multiple times for "the
 * same" changes.
*/
export class SpongeAbsorbEvent extends BlockEvent {
  constructor(block: Block, waterblocks: BlockState[]);
  /**
   * Get a list of all blocks to be removed by the sponge.
   * 
   * This list is mutable and contains the blocks in their removed state, i.e.
   * having a type of {@link Material#AIR}.
   *
   * @return list of the to be removed blocks.
  */
  getBlocks(): BlockState[];
  /**
   * Gets the cancellation state of this event. A cancelled event will not
   * be executed in the server, but will still pass to other plugins
   *
   * @return true if this event is cancelled
  */
  isCancelled(): boolean;
  /**
   * Sets the cancellation state of this event. A cancelled event will not
   * be executed in the server, but will still pass to other plugins.
   *
   * @param cancel true if you wish to cancel this event
  */
  setCancelled(cancel: boolean): void;
  getHandlers(): HandlerList;
  static getHandlerList(): HandlerList;
}
export interface SpongeAbsorbEvent extends BlockEvent, Cancellable {}
/**
 * Called when a note block is being played through player interaction or a
 * redstone current.
*/
export class NotePlayEvent extends BlockEvent {
  constructor(block: Block, instrument: Instrument, note: Note);
  /**
   * Gets the cancellation state of this event. A cancelled event will not
   * be executed in the server, but will still pass to other plugins
   *
   * @return true if this event is cancelled
  */
  isCancelled(): boolean;
  /**
   * Sets the cancellation state of this event. A cancelled event will not
   * be executed in the server, but will still pass to other plugins.
   *
   * @param cancel true if you wish to cancel this event
  */
  setCancelled(cancel: boolean): void;
  /**
   * Gets the {@link Instrument} to be used.
   *
   * @return the Instrument
  */
  getInstrument(): Instrument;
  /**
   * Gets the {@link Note} to be played.
   *
   * @return the Note
  */
  getNote(): Note;
  /**
   * Overrides the {@link Instrument} to be used.
   *
   * @param instrument the Instrument. Has no effect if null.
  */
  setInstrument(instrument: Instrument);
  /**
   * Overrides the {@link Note} to be played.
   *
   * @param note the Note. Has no effect if null.
  */
  setNote(note: Note);
  getHandlers(): HandlerList;
  static getHandlerList(): HandlerList;
}
export interface NotePlayEvent extends BlockEvent, Cancellable {}
/**
 * Called when a block is damaged by a player.
 * 
 * If a Block Damage event is cancelled, the block will not be damaged.
 * @see BlockDamageAbortEvent
*/
export class BlockDamageEvent extends BlockEvent {
  constructor(player: Player, block: Block, itemInHand: ItemStack, instaBreak: boolean);
  /**
   * Gets the player damaging the block involved in this event.
   *
   * @return The player damaging the block involved in this event
  */
  getPlayer(): Player;
  /**
   * Gets if the block is set to instantly break when damaged by the player.
   *
   * @return true if the block should instantly break when damaged by the
   *     player
  */
  getInstaBreak(): boolean;
  /**
   * Sets if the block should instantly break when damaged by the player.
   *
   * @param bool true if you want the block to instantly break when damaged
   *     by the player
  */
  setInstaBreak(bool: boolean): void;
  /**
   * Gets the ItemStack for the item currently in the player's hand.
   *
   * @return The ItemStack for the item currently in the player's hand
  */
  getItemInHand(): ItemStack;
  /**
   * Gets the cancellation state of this event. A cancelled event will not
   * be executed in the server, but will still pass to other plugins
   *
   * @return true if this event is cancelled
  */
  isCancelled(): boolean;
  /**
   * Sets the cancellation state of this event. A cancelled event will not
   * be executed in the server, but will still pass to other plugins.
   *
   * @param cancel true if you wish to cancel this event
  */
  setCancelled(cancel: boolean): void;
  getHandlers(): HandlerList;
  static getHandlerList(): HandlerList;
}
export interface BlockDamageEvent extends BlockEvent, Cancellable {}
/**
 * Called with the block changes resulting from a player fertilizing a given
 * block with bonemeal. Will be called after the applicable
 * {@link StructureGrowEvent}.
*/
export class BlockFertilizeEvent extends BlockEvent {
  constructor(theBlock: Block, player: Player | null, blocks: BlockState[]);
  /**
   * Gets the player that triggered the fertilization.
   *
   * @return triggering player, or null if not applicable
  */
  getPlayer(): Player | null;
  /**
   * Gets a list of all blocks changed by the fertilization.
   *
   * @return list of all changed blocks
  */
  getBlocks(): BlockState[];
  /**
   * Gets the cancellation state of this event. A cancelled event will not
   * be executed in the server, but will still pass to other plugins
   *
   * @return true if this event is cancelled
  */
  isCancelled(): boolean;
  /**
   * Sets the cancellation state of this event. A cancelled event will not
   * be executed in the server, but will still pass to other plugins.
   *
   * @param cancel true if you wish to cancel this event
  */
  setCancelled(cancelled: boolean): void;
  getHandlers(): HandlerList;
  static getHandlerList(): HandlerList;
}
export interface BlockFertilizeEvent extends BlockEvent, Cancellable {}

}
declare module 'org.bukkit' {
import { BukkitScheduler } from 'org.bukkit.scheduler';
import { BufferedImage } from 'java.awt.image';
import { BarStyle, BarColor, BarFlag, KeyedBossBar, BossBar, DragonBattle } from 'org.bukkit.boss';
import { MoonPhase } from 'io.papermc.paper.world';
import { Attributable, Attribute, AttributeModifier } from 'org.bukkit.attribute';
import { Type as org_bukkit_Statistic_Type } from 'org.bukkit.Statistic';
import { ItemRarity } from 'io.papermc.paper.inventory';
import { Advancement } from 'org.bukkit.advancement';
import { StructureManager } from 'org.bukkit.structure';
import { ChunkData } from 'org.bukkit.generator.ChunkGenerator';
import { ComponentFlattener } from 'net.kyori.adventure.text.flattener';
import { Merchant, Recipe, ItemFactory, CreativeCategory, EquipmentSlot, ItemStack, InventoryHolder, Inventory } from 'org.bukkit.inventory';
import { VersionFetcher } from 'com.destroystokyo.paper.util';
import { Reference } from 'java.lang.ref';
import { Pattern } from 'java.util.regex';
import { Biome, BlockState, Block } from 'org.bukkit.block';
import { Namespaced, HeightmapType, ParticleBuilder } from 'com.destroystokyo.paper';
import { ChunkLoadCallback, Environment, Spigot as org_bukkit_World_Spigot } from 'org.bukkit.World';
import { PluginManager, ServicesManager, PluginDescriptionFile, Plugin } from 'org.bukkit.plugin';
import { PlayerProfile as com_destroystokyo_paper_profile_PlayerProfile } from 'com.destroystokyo.paper.profile';
import { Translatable } from 'net.kyori.adventure.translation';
import { Multimap, ImmutableList } from 'com.google.common.collect';
import { FallingBlock, LivingEntity, EntityType, LightningStrike, Arrow, Entity, Item, Player, Raider, AnimalTamer, SpawnCategory } from 'org.bukkit.entity';
import { Constructor } from 'java.lang.reflect';
import { Namespaced as net_kyori_adventure_key_Namespaced, Key, Keyed as net_kyori_adventure_key_Keyed } from 'net.kyori.adventure.key';
import { Enchantment } from 'org.bukkit.enchantments';
import { SpawnReason } from 'org.bukkit.event.entity.CreatureSpawnEvent';
import { CompletableFuture } from 'java.util.concurrent';
import { Type } from 'org.bukkit.BanList';
import { PlayerProfile } from 'org.bukkit.profile';
import { DatapackManager } from 'io.papermc.paper.datapack';
import { BiomeProvider, BlockPopulator, WorldInfo, ChunkGenerator } from 'org.bukkit.generator';
import { Type as org_bukkit_map_MapCursor_Type } from 'org.bukkit.map.MapCursor';
import { Type as org_bukkit_entity_Villager_Type, Profession } from 'org.bukkit.entity.Villager';
import { Enum, Iterable, Class, Cloneable } from 'java.lang';
import { PlainTextComponentSerializer, PlainComponentSerializer } from 'net.kyori.adventure.text.serializer.plain';
import { Emitter, Source } from 'net.kyori.adventure.sound.Sound';
import { InventoryType } from 'org.bukkit.event.inventory';
import { Destination } from 'org.bukkit.Vibration';
import { LegacyComponentSerializer } from 'net.kyori.adventure.text.serializer.legacy';
import { Consumer, Predicate } from 'java.util.function';
import { ConfigurationSerializable } from 'org.bukkit.configuration.serialization';
import { ScoreboardManager } from 'org.bukkit.scoreboard';
import { HelpMap } from 'org.bukkit.help';
import { Logger } from 'java.util.logging';
import { Set, Random, HashMap, Iterator, Collection, List, UUID, Map, Date } from 'java.util';
import { Type as org_bukkit_FireworkEffect_Type, Builder } from 'org.bukkit.FireworkEffect';
import { Messenger, PluginMessageRecipient } from 'org.bukkit.plugin.messaging';
import { WarningState } from 'org.bukkit.Warning';
import { PotionEffectType, PotionBrewer } from 'org.bukkit.potion';
import { Type as org_bukkit_Effect_Type } from 'org.bukkit.Effect';
import { Logger as org_apache_logging_log4j_Logger } from 'org.apache.logging.log4j';
import { TriState } from 'net.kyori.adventure.util';
import { LootTable, LootTables } from 'org.bukkit.loot';
import { MaterialData } from 'org.bukkit.material';
import { Sound as net_kyori_adventure_sound_Sound } from 'net.kyori.adventure.sound';
import { Spigot } from 'org.bukkit.Server';
import { GsonComponentSerializer } from 'net.kyori.adventure.text.serializer.gson';
import { RaidStatus } from 'org.bukkit.Raid';
import { Component } from 'net.kyori.adventure.text';
import { MapView } from 'org.bukkit.map';
import { CommandSender, ConsoleCommandSender, CommandMap, PluginCommand } from 'org.bukkit.command';
import { Metadatable } from 'org.bukkit.metadata';
import { ConfiguredStructure } from 'io.papermc.paper.world.structure';
import { MemoryKey } from 'org.bukkit.entity.memory';
import { ServerOperator } from 'org.bukkit.permissions';
import { File } from 'java.io';
import { Tone } from 'org.bukkit.Note';
import { Consumer as org_bukkit_util_Consumer, BoundingBox, RayTraceResult, CachedServerIcon, Vector } from 'org.bukkit.util';
import { MobGoals } from 'com.destroystokyo.paper.entity.ai';
import { BlockData } from 'org.bukkit.block.data';
import { Audience, ForwardingAudience } from 'net.kyori.adventure.audience';
import { PersistentDataHolder } from 'org.bukkit.persistence';
/**
 * Represents the different species of trees regardless of size.
*/
export class TreeSpecies extends Enum<TreeSpecies> {
  /**
   * Represents the common tree species.
  */
  static readonly GENERIC: TreeSpecies;
  /**
   * Represents the darker barked/leaved tree species.
  */
  static readonly REDWOOD: TreeSpecies;
  /**
   * Represents birches.
  */
  static readonly BIRCH: TreeSpecies;
  /**
   * Represents jungle trees.
  */
  static readonly JUNGLE: TreeSpecies;
  /**
   * Represents acacia trees.
  */
  static readonly ACACIA: TreeSpecies;
  /**
   * Represents dark oak trees.
  */
  static readonly DARK_OAK: TreeSpecies;
  static valueOf(name: string): TreeSpecies;
  static values(): TreeSpecies[];
  /**
   * Gets the associated data value representing this species
   *
   * @return A byte containing the data value of this tree species
   * @deprecated Magic value
  */
  getData(): number;
  /**
   * Gets the TreeSpecies with the given data value
   *
   * @param data Data value to fetch
   * @return The {@link TreeSpecies} representing the given value, or null
   *     if it doesn't exist
   * @deprecated Magic value
  */
  static getByData(data: number): TreeSpecies | null;
}
/**
 * Represents a 3-dimensional position in a world.
 * 
 * No constraints are placed on any angular values other than that they be
 * specified in degrees. This means that negative angles or angles of greater
 * magnitude than 360 are valid, but may be normalized to any other equivalent
 * representation by the implementation.
*/
export class Location extends Cloneable {
  /**
   * Constructs a new Location with the given coordinates
   *
   * @param world The world in which this location resides
   * @param x The x-coordinate of this new location
   * @param y The y-coordinate of this new location
   * @param z The z-coordinate of this new location
  */
  constructor(world: World, x: number, y: number, z: number);
  /**
   * Constructs a new Location with the given coordinates and direction
   *
   * @param world The world in which this location resides
   * @param x The x-coordinate of this new location
   * @param y The y-coordinate of this new location
   * @param z The z-coordinate of this new location
   * @param yaw The absolute rotation on the x-plane, in degrees
   * @param pitch The absolute rotation on the y-plane, in degrees
  */
  constructor(world: World, x: number, y: number, z: number, yaw: number, pitch: number);
  /**
   * Sets the world that this location resides in
   *
   * @param world New world that this location resides in
  */
  setWorld(world: World | null);
  /**
   * Checks if world in this location is present and loaded.
   *
   * @return true if is loaded, otherwise false
  */
  isWorldLoaded(): boolean;
  /**
   * Gets the world that this location resides in
   *
   * @return World that contains this location, or `null` if it is not set
   * @throws IllegalArgumentException when world is unloaded
   * @see #isWorldLoaded()
  */
  getWorld(): World;
  /**
   * Gets the chunk at the represented location
   *
   * @return Chunk at the represented location
  */
  getChunk(): Chunk;
  /**
   * Gets the block at the represented location
   *
   * @return Block at the represented location
  */
  getBlock(): Block;
  /**
   * Sets the x-coordinate of this location
   *
   * @param x X-coordinate
  */
  setX(x: number);
  /**
   * Gets the x-coordinate of this location
   *
   * @return x-coordinate
  */
  getX(): number;
  /**
   * Gets the floored value of the X component, indicating the block that
   * this location is contained with.
   *
   * @return block X
  */
  getBlockX(): number;
  /**
   * Sets the y-coordinate of this location
   *
   * @param y y-coordinate
  */
  setY(y: number);
  /**
   * Gets the y-coordinate of this location
   *
   * @return y-coordinate
  */
  getY(): number;
  /**
   * Gets the floored value of the Y component, indicating the block that
   * this location is contained with.
   *
   * @return block y
  */
  getBlockY(): number;
  /**
   * Sets the z-coordinate of this location
   *
   * @param z z-coordinate
  */
  setZ(z: number);
  /**
   * Gets the z-coordinate of this location
   *
   * @return z-coordinate
  */
  getZ(): number;
  /**
   * Gets the floored value of the Z component, indicating the block that
   * this location is contained with.
   *
   * @return block z
  */
  getBlockZ(): number;
  /**
   * Sets the yaw of this location, measured in degrees.
   * 
   * A yaw of 0 or 360 represents the positive z direction.
   * A yaw of 180 represents the negative z direction.
   * A yaw of 90 represents the negative x direction.
   * A yaw of 270 represents the positive x direction.
   * 
   * Increasing yaw values are the equivalent of turning to your
   * right-facing, increasing the scale of the next respective axis, and
   * decreasing the scale of the previous axis.
   *
   * @param yaw new rotation's yaw
  */
  setYaw(yaw: number);
  /**
   * Gets the yaw of this location, measured in degrees.
   * 
   * A yaw of 0 or 360 represents the positive z direction.
   * A yaw of 180 represents the negative z direction.
   * A yaw of 90 represents the negative x direction.
   * A yaw of 270 represents the positive x direction.
   * 
   * Increasing yaw values are the equivalent of turning to your
   * right-facing, increasing the scale of the next respective axis, and
   * decreasing the scale of the previous axis.
   *
   * @return the rotation's yaw
  */
  getYaw(): number;
  /**
   * Sets the pitch of this location, measured in degrees.
   * 
   * A pitch of 0 represents level forward facing.
   * A pitch of 90 represents downward facing, or negative y
   *     direction.
   * A pitch of -90 represents upward facing, or positive y direction.
   * 
   * Increasing pitch values the equivalent of looking down.
   *
   * @param pitch new incline's pitch
  */
  setPitch(pitch: number);
  /**
   * Gets the pitch of this location, measured in degrees.
   * 
   * A pitch of 0 represents level forward facing.
   * A pitch of 90 represents downward facing, or negative y
   *     direction.
   * A pitch of -90 represents upward facing, or positive y direction.
   * 
   * Increasing pitch values the equivalent of looking down.
   *
   * @return the incline's pitch
  */
  getPitch(): number;
  /**
   * Gets a unit-vector pointing in the direction that this Location is
   * facing.
   *
   * @return a vector pointing the direction of this location's {@link
   *     #getPitch() pitch} and {@link #getYaw() yaw}
  */
  getDirection(): Vector;
  /**
   * Sets the {@link #getYaw() yaw} and {@link #getPitch() pitch} to point
   * in the direction of the vector.
   *
   * @param vector the direction vector
   * @return the same location
  */
  setDirection(direction: Vector);
  /**
   * Adds the location by another.
   *
   * @param vec The other location
   * @return the same location
   * @throws IllegalArgumentException for differing worlds
   * @see Vector
  */
  add(vec: Location): Location;
  /**
   * Adds the location by a vector.
   *
   * @param vec Vector to use
   * @return the same location
   * @see Vector
  */
  add(vec: Vector): Location;
  /**
   * Adds the location by another. Not world-aware.
   *
   * @param x X coordinate
   * @param y Y coordinate
   * @param z Z coordinate
   * @return the same location
   * @see Vector
  */
  add(x: number, y: number, z: number): Location;
  /**
   * Subtracts the location by another.
   *
   * @param vec The other location
   * @return the same location
   * @throws IllegalArgumentException for differing worlds
   * @see Vector
  */
  subtract(vec: Location): Location;
  /**
   * Subtracts the location by a vector.
   *
   * @param vec The vector to use
   * @return the same location
   * @see Vector
  */
  subtract(vec: Vector): Location;
  /**
   * Subtracts the location by another. Not world-aware and
   * orientation independent.
   *
   * @param x X coordinate
   * @param y Y coordinate
   * @param z Z coordinate
   * @return the same location
   * @see Vector
  */
  subtract(x: number, y: number, z: number): Location;
  /**
   * Gets the magnitude of the location, defined as sqrt(x^2+y^2+z^2). The
   * value of this method is not cached and uses a costly square-root
   * function, so do not repeatedly call this method to get the location's
   * magnitude. NaN will be returned if the inner result of the sqrt()
   * function overflows, which will be caused if the length is too long. Not
   * world-aware and orientation independent.
   *
   * @return the magnitude
   * @see Vector
  */
  length(): number;
  /**
   * Gets the magnitude of the location squared. Not world-aware and
   * orientation independent.
   *
   * @return the magnitude
   * @see Vector
  */
  lengthSquared(): number;
  /**
   * Get the distance between this location and another. The value of this
   * method is not cached and uses a costly square-root function, so do not
   * repeatedly call this method to get the location's magnitude. NaN will
   * be returned if the inner result of the sqrt() function overflows, which
   * will be caused if the distance is too long.
   *
   * @param o The other location
   * @return the distance
   * @throws IllegalArgumentException for differing worlds
   * @see Vector
  */
  distance(o: Location): number;
  /**
   * Get the squared distance between this location and another.
   *
   * @param o The other location
   * @return the distance
   * @throws IllegalArgumentException for differing worlds
   * @see Vector
  */
  distanceSquared(o: Location): number;
  /**
   * Performs scalar multiplication, multiplying all components with a
   * scalar. Not world-aware.
   *
   * @param m The factor
   * @return the same location
   * @see Vector
  */
  multiply(m: number): Location;
  /**
   * Zero this location's components. Not world-aware.
   *
   * @return the same location
   * @see Vector
  */
  zero(): Location;
  isChunkLoaded(): boolean;
  /**
   * Checks if a {@link Chunk} has been generated at this location.
   *
   * @return true if a chunk has been generated at this location
  */
  isGenerated(): boolean;
  /**
   * Sets the position of this Location and returns itself
   *
   * This mutates this object, clone first.
   * @param x X coordinate
   * @param y Y coordinate
   * @param z Z coordinate
   * @return self (not cloned)
  */
  set(x: number, y: number, z: number): Location;
  /**
   * Takes the x/y/z from base and adds the specified x/y/z to it and returns self
   *
   * This mutates this object, clone first.
   * @param base The base coordinate to modify
   * @param x X coordinate to add to base
   * @param y Y coordinate to add to base
   * @param z Z coordinate to add to base
   * @return self (not cloned)
  */
  add(base: Location, x: number, y: number, z: number): Location;
  /**
   * Takes the x/y/z from base and subtracts the specified x/y/z to it and returns self
   *
   * This mutates this object, clone first.
   * @param base The base coordinate to modify
   * @param x X coordinate to subtract from base
   * @param y Y coordinate to subtract from base
   * @param z Z coordinate to subtract from base
   * @return self (not cloned)
  */
  subtract(base: Location, x: number, y: number, z: number): Location;
  /**
   * @return A new location where X/Y/Z are on the Block location (integer value of X/Y/Z)
  */
  toBlockLocation(): Location;
  /**
   * @return The block key for this location's block location.
   * @see Block#getBlockKey(int, int, int)
   * @deprecated only encodes y block ranges from -512 to 511 and represents an already changed implementation detail
  */
  toBlockKey(): number;
  /**
   * @return A new location where X/Y/Z are the center of the block
  */
  toCenterLocation(): Location;
  /**
   * Returns a copy of this location except with y = getWorld().getHighestBlockYAt(this.getBlockX(), this.getBlockZ())
   * @return A copy of this location except with y = getWorld().getHighestBlockYAt(this.getBlockX(), this.getBlockZ())
   * @throws NullPointerException if {{@link #getWorld()}} is `null`
  */
  toHighestLocation(): Location;
  /**
   * Returns a copy of this location except with y = getWorld().getHighestBlockYAt(this.getBlockX(), this.getBlockZ(), heightmap)
   * @param heightmap The heightmap to use for finding the highest y location.
   * @return A copy of this location except with y = getWorld().getHighestBlockYAt(this.getBlockX(), this.getBlockZ(), heightmap)
   * @throws NullPointerException if {{@link #getWorld()}} is `null`
   * @throws UnsupportedOperationException if {@link World#getHighestBlockYAt(int, int, com.destroystokyo.paper.HeightmapType)} does not support the specified heightmap
   * @deprecated Use {@link org.bukkit.Location#toHighestLocation(HeightMap)}
  */
  toHighestLocation(heightmap: HeightmapType): Location;
  /**
   * Returns a copy of this location except with y = getWorld().getHighestBlockYAt(this.getBlockX(), this.getBlockZ(), heightMap)
   * @param heightMap The heightmap to use for finding the highest y location.
   * @return A copy of this location except with y = getWorld().getHighestBlockYAt(this.getBlockX(), this.getBlockZ(), heightMap)
  */
  toHighestLocation(heightMap: HeightMap): Location;
  /**
   * Creates explosion at this location with given power
   *
   * Will break blocks and ignite blocks on fire.
   *
   * @param power The power of explosion, where 4F is TNT
   * @return false if explosion was canceled, otherwise true
  */
  createExplosion(power: number): boolean;
  /**
   * Creates explosion at this location with given power and optionally
   * setting blocks on fire.
   *
   * Will break blocks.
   *
   * @param power The power of explosion, where 4F is TNT
   * @param setFire Whether or not to set blocks on fire
   * @return false if explosion was canceled, otherwise true
  */
  createExplosion(power: number, setFire: boolean): boolean;
  /**
   * Creates explosion at this location with given power and optionally
   * setting blocks on fire.
   *
   * @param power The power of explosion, where 4F is TNT
   * @param setFire Whether or not to set blocks on fire
   * @param breakBlocks Whether or not to have blocks be destroyed
   * @return false if explosion was canceled, otherwise true
  */
  createExplosion(power: number, setFire: boolean, breakBlocks: boolean): boolean;
  /**
   * Creates explosion at this location with given power, with the specified entity as the source.
   *
   * Will break blocks and ignite blocks on fire.
   *
   * @param source The source entity of the explosion
   * @param power The power of explosion, where 4F is TNT
   * @return false if explosion was canceled, otherwise true
  */
  createExplosion(source: Entity | null, power: number): boolean;
  /**
   * Creates explosion at this location with given power and optionally
   * setting blocks on fire, with the specified entity as the source.
   *
   * Will break blocks.
   *
   * @param source The source entity of the explosion
   * @param power The power of explosion, where 4F is TNT
   * @param setFire Whether or not to set blocks on fire
   * @return false if explosion was canceled, otherwise true
  */
  createExplosion(source: Entity | null, power: number, setFire: boolean): boolean;
  /**
   * Creates explosion at this location with given power and optionally
   * setting blocks on fire, with the specified entity as the source.
   *
   * @param source The source entity of the explosion
   * @param power The power of explosion, where 4F is TNT
   * @param setFire Whether or not to set blocks on fire
   * @param breakBlocks Whether or not to have blocks be destroyed
   * @return false if explosion was canceled, otherwise true
  */
  createExplosion(source: Entity, power: number, setFire: boolean, breakBlocks: boolean): boolean;
  /**
   * Returns a list of entities within a bounding box centered around a Location.
   *
   * Some implementations may impose artificial restrictions on the size of the search bounding box.
   *
   * @param x 1/2 the size of the box along x axis
   * @param y 1/2 the size of the box along y axis
   * @param z 1/2 the size of the box along z axis
   * @return the collection of entities near location. This will always be a non-null collection.
  */
  getNearbyEntities(x: number, y: number, z: number): Collection<Entity>;
  /**
   * Gets nearby players within the specified radius (bounding box)
   * @param radius X Radius
   * @return the collection of entities near location. This will always be a non-null collection.
  */
  getNearbyLivingEntities(radius: number): Collection<LivingEntity>;
  /**
   * Gets nearby players within the specified radius (bounding box)
   * @param xzRadius X/Z Radius
   * @param yRadius Y Radius
   * @return the collection of living entities near location. This will always be a non-null collection.
  */
  getNearbyLivingEntities(xzRadius: number, yRadius: number): Collection<LivingEntity>;
  /**
   * Gets nearby players within the specified radius (bounding box)
   * @param xRadius X Radius
   * @param yRadius Y Radius
   * @param zRadius Z radius
   * @return the collection of living entities near location. This will always be a non-null collection.
  */
  getNearbyLivingEntities(xRadius: number, yRadius: number, zRadius: number): Collection<LivingEntity>;
  /**
   * Gets nearby players within the specified radius (bounding box)
   * @param radius Radius
   * @param predicate a predicate used to filter results
   * @return the collection of living entities near location. This will always be a non-null collection.
  */
  getNearbyLivingEntities(radius: number, predicate: Predicate<LivingEntity> | null): Collection<LivingEntity>;
  /**
   * Gets nearby players within the specified radius (bounding box)
   * @param xzRadius X/Z Radius
   * @param yRadius Y Radius
   * @param predicate a predicate used to filter results
   * @return the collection of living entities near location. This will always be a non-null collection.
  */
  getNearbyLivingEntities(xzRadius: number, yRadius: number, predicate: Predicate<LivingEntity> | null): Collection<LivingEntity>;
  /**
   * Gets nearby players within the specified radius (bounding box)
   * @param xRadius X Radius
   * @param yRadius Y Radius
   * @param zRadius Z radius
   * @param predicate a predicate used to filter results
   * @return the collection of living entities near location. This will always be a non-null collection.
  */
  getNearbyLivingEntities(xRadius: number, yRadius: number, zRadius: number, predicate: Predicate<LivingEntity> | null): Collection<LivingEntity>;
  /**
   * Gets nearby players within the specified radius (bounding box)
   * @param radius X/Y/Z Radius
   * @return the collection of players near location. This will always be a non-null collection.
  */
  getNearbyPlayers(radius: number): Collection<Player>;
  /**
   * Gets nearby players within the specified radius (bounding box)
   * @param xzRadius X/Z Radius
   * @param yRadius Y Radius
   * @return the collection of players near location. This will always be a non-null collection.
  */
  getNearbyPlayers(xzRadius: number, yRadius: number): Collection<Player>;
  /**
   * Gets nearby players within the specified radius (bounding box)
   * @param xRadius X Radius
   * @param yRadius Y Radius
   * @param zRadius Z Radius
   * @return the collection of players near location. This will always be a non-null collection.
  */
  getNearbyPlayers(xRadius: number, yRadius: number, zRadius: number): Collection<Player>;
  /**
   * Gets nearby players within the specified radius (bounding box)
   * @param radius X/Y/Z Radius
   * @param predicate a predicate used to filter results
   * @return the collection of players near location. This will always be a non-null collection.
  */
  getNearbyPlayers(radius: number, predicate: Predicate<Player> | null): Collection<Player>;
  /**
   * Gets nearby players within the specified radius (bounding box)
   * @param xzRadius X/Z Radius
   * @param yRadius Y Radius
   * @param predicate a predicate used to filter results
   * @return the collection of players near location. This will always be a non-null collection.
  */
  getNearbyPlayers(xzRadius: number, yRadius: number, predicate: Predicate<Player> | null): Collection<Player>;
  /**
   * Gets nearby players within the specified radius (bounding box)
   * @param xRadius X Radius
   * @param yRadius Y Radius
   * @param zRadius Z Radius
   * @param predicate a predicate used to filter results
   * @return the collection of players near location. This will always be a non-null collection.
  */
  getNearbyPlayers(xRadius: number, yRadius: number, zRadius: number, predicate: Predicate<Player> | null): Collection<Player>;
  /**
   * Gets all nearby entities of the specified type, within the specified radius (bounding box)
   * @param clazz Type to filter by
   * @param radius X/Y/Z radius to search within
   * @param  the entity type
   * @return the collection of entities of type clazz near location. This will always be a non-null collection.
  */
  getNearbyEntitiesByType<T>(clazz: Class<T> | null, radius: number): Collection<T>;
  /**
   * Gets all nearby entities of the specified type, within the specified radius, with x and x radius matching (bounding box)
   * @param clazz Type to filter by
   * @param xzRadius X/Z radius to search within
   * @param yRadius Y radius to search within
   * @param  the entity type
   * @return the collection of entities near location. This will always be a non-null collection.
  */
  getNearbyEntitiesByType<T>(clazz: Class<T> | null, xzRadius: number, yRadius: number): Collection<T>;
  /**
   * Gets all nearby entities of the specified type, within the specified radius (bounding box)
   * @param clazz Type to filter by
   * @param xRadius X Radius
   * @param yRadius Y Radius
   * @param zRadius Z Radius
   * @param  the entity type
   * @return the collection of entities near location. This will always be a non-null collection.
  */
  getNearbyEntitiesByType<T>(clazz: Class<T> | null, xRadius: number, yRadius: number, zRadius: number): Collection<T>;
  /**
   * Gets all nearby entities of the specified type, within the specified radius (bounding box)
   * @param clazz Type to filter by
   * @param radius X/Y/Z radius to search within
   * @param predicate a predicate used to filter results
   * @param  the entity type
   * @return the collection of entities near location. This will always be a non-null collection.
  */
  getNearbyEntitiesByType<T>(clazz: Class<T> | null, radius: number, predicate: Predicate<T> | null): Collection<T>;
  /**
   * Gets all nearby entities of the specified type, within the specified radius, with x and x radius matching (bounding box)
   * @param clazz Type to filter by
   * @param xzRadius X/Z radius to search within
   * @param yRadius Y radius to search within
   * @param predicate a predicate used to filter results
   * @param  the entity type
   * @return the collection of entities near location. This will always be a non-null collection.
  */
  getNearbyEntitiesByType<T>(clazz: Class<T> | null, xzRadius: number, yRadius: number, predicate: Predicate<T> | null): Collection<T>;
  /**
   * Gets all nearby entities of the specified type, within the specified radius (bounding box)
   * @param clazz Type to filter by
   * @param xRadius X Radius
   * @param yRadius Y Radius
   * @param zRadius Z Radius
   * @param predicate a predicate used to filter results
   * @param  the entity type
   * @return the collection of entities near location. This will always be a non-null collection.
  */
  getNearbyEntitiesByType<T>(clazz: Class<Entity> | null, xRadius: number, yRadius: number, zRadius: number, predicate: Predicate<T> | null): Collection<T>;
  equals(obj: any): boolean;
  hashCode(): number;
  toString(): string;
  /**
   * Constructs a new {@link Vector} based on this Location
   *
   * @return New Vector containing the coordinates represented by this
   *     Location
  */
  toVector(): Vector;
  clone(): Location;
  /**
   * Check if each component of this Location is finite.
   *
   * @throws IllegalArgumentException if any component is not finite
  */
  checkFinite(): void;
  /**
   * Safely converts a double (location coordinate) to an int (block
   * coordinate)
   *
   * @param loc Precise coordinate
   * @return Block coordinate
  */
  static locToBlock(loc: number): number;
  /**
   * Creates a Map representation of this class.
   * 
   * This class must provide a method to restore this class, as defined in
   * the {@link ConfigurationSerializable} interface javadocs.
   *
   * @return Map containing the current state of this class
  */
  serialize(): Map<string, any>;
  /**
   * Required method for deserialization
   *
   * @param args map to deserialize
   * @return deserialized location
   * @throws IllegalArgumentException if the world don't exists
   * @see ConfigurationSerializable
  */
  static deserialize(args: Map<string, any>): Location;
  /**
   * Normalizes the given yaw angle to a value between +/-180
   * degrees.
   *
   * @param yaw the yaw in degrees
   * @return the normalized yaw in degrees
   * @see Location#getYaw()
  */
  static normalizeYaw(yaw: number): number;
  /**
   * Normalizes the given pitch angle to a value between +/-90
   * degrees.
   *
   * @param pitch the pitch in degrees
   * @return the normalized pitch in degrees
   * @see Location#getPitch()
  */
  static normalizePitch(pitch: number): number;
}
export interface Location extends Cloneable, ConfigurationSerializable {}
/**
 * This designates the warning state for a specific item.
 * 
 * When the server settings dictate 'default' warnings, warnings are printed
 * if the {@link #value()} is true.
*/
export class Warning {

}
/**
 * A single entry from a ban list. This may represent either a player ban or
 * an IP ban.
 * 
 * Ban entries include the following properties:
 * 
 * Property information
 * 
 *     Property
 *     Description
 * 
 *     Target Name / IP Address
 *     The target name or IP address
 * 
 *     Creation Date
 *     The creation date of the ban
 * 
 *     Source
 *     The source of the ban, such as a player, console, plugin, etc
 * 
 *     Expiration Date
 *     The expiration date of the ban
 * 
 *     Reason
 *     The reason for the ban
 * 
 * 
 * 
 * Unsaved information is not automatically written to the implementation's
 * ban list, instead, the {@link #save()} method must be called to write the
 * changes to the ban list. If this ban entry has expired (such as from an
 * unban) and is no longer found in the list, the {@link #save()} call will
 * re-add it to the list, therefore banning the victim specified.
 * 
 * Likewise, changes to the associated {@link BanList} or other entries may or
 * may not be reflected in this entry.
*/
export class BanEntry {
  /**
   * Gets the target involved. This may be in the form of an IP or a player
   * name.
   *
   * @return the target name or IP address
  */
  getTarget(): string;
  /**
   * Gets the date this ban entry was created.
   *
   * @return the creation date
  */
  getCreated(): Date;
  /**
   * Sets the date this ban entry was created.
   *
   * @param created the new created date, cannot be null
   * @see #save() saving changes
  */
  setCreated(created: Date);
  /**
   * Gets the source of this ban.
   * 
   * Note: A source is considered any String, although this is generally a
   * player name.
   *
   * @return the source of the ban
  */
  getSource(): string;
  /**
   * Sets the source of this ban.
   * 
   * Note: A source is considered any String, although this is generally a
   * player name.
   *
   * @param source the new source where null values become empty strings
   * @see #save() saving changes
  */
  setSource(source: string);
  /**
   * Gets the date this ban expires on, or null for no defined end date.
   *
   * @return the expiration date
  */
  getExpiration(): Date | null;
  /**
   * Sets the date this ban expires on. Null values are considered
   * "infinite" bans.
   *
   * @param expiration the new expiration date, or null to indicate an
   *     eternity
   * @see #save() saving changes
  */
  setExpiration(expiration: Date | null);
  /**
   * Gets the reason for this ban.
   *
   * @return the ban reason, or null if not set
  */
  getReason(): string | null;
  /**
   * Sets the reason for this ban. Reasons must not be null.
   *
   * @param reason the new reason, null values assume the implementation
   *     default
   * @see #save() saving changes
  */
  setReason(reason: string | null);
  /**
   * Saves the ban entry, overwriting any previous data in the ban list.
   * 
   * Saving the ban entry of an unbanned player will cause the player to be
   * banned once again.
  */
  save(): void;
}
/**
 * Represents the two types of coal
*/
export class CoalType extends Enum<CoalType> {
  static readonly COAL: CoalType;
  static readonly CHARCOAL: CoalType;
  static valueOf(name: string): CoalType;
  static values(): CoalType[];
  /**
   * Gets the associated data value representing this type of coal
   *
   * @return A byte containing the data value of this coal type
   * @deprecated Magic value
  */
  getData(): number;
  /**
   * Gets the type of coal with the given data value
   *
   * @param data Data value to fetch
   * @return The {@link CoalType} representing the given value, or null if
   *     it doesn't exist
   * @deprecated Magic value
  */
  static getByData(data: number): CoalType | null;
}
/**
 * Represents the different types of grass.
 * @deprecated use {@link org.bukkit.block.data.BlockData}
*/
export class GrassSpecies extends Enum<GrassSpecies> {
  /**
   * Represents the dead looking grass.
  */
  static readonly DEAD: GrassSpecies;
  /**
   * Represents the normal grass species.
  */
  static readonly NORMAL: GrassSpecies;
  /**
   * Represents the fern-looking grass species.
  */
  static readonly FERN_LIKE: GrassSpecies;
  static valueOf(name: string): GrassSpecies;
  static values(): GrassSpecies[];
  /**
   * Gets the associated data value representing this species
   *
   * @return A byte containing the data value of this grass species
   * @deprecated Magic value
  */
  getData(): number;
  /**
   * Gets the GrassSpecies with the given data value
   *
   * @param data Data value to fetch
   * @return The {@link GrassSpecies} representing the given value, or null
   *     if it doesn't exist
   * @deprecated Magic value
  */
  static getByData(data: number): GrassSpecies | null;
}
/**
 * A ban list, containing bans of some {@link Type}.
*/
export class BanList {
  /**
   * Gets a {@link BanEntry} by target.
   *
   * @param target entry parameter to search for
   * @return the corresponding entry, or null if none found
  */
  getBanEntry(target: string): BanEntry | null;
  /**
   * Adds a ban to the this list. If a previous ban exists, this will
   * update the previous entry.
   *
   * @param target the target of the ban
   * @param reason reason for the ban, null indicates implementation default
   * @param expires date for the ban's expiration (unban), or null to imply
   *     forever
   * @param source source of the ban, null indicates implementation default
   * @return the entry for the newly created ban, or the entry for the
   *     (updated) previous ban
  */
  addBan(target: string, reason: string | null, expires: Date | null, source: string | null): BanEntry | null;
  /**
   * Gets a set containing every {@link BanEntry} in this list.
   *
   * @return an immutable set containing every entry tracked by this list
  */
  getBanEntries(): Set<BanEntry>;
  /**
   * Gets if a {@link BanEntry} exists for the target, indicating an active
   * ban status.
   *
   * @param target the target to find
   * @return true if a {@link BanEntry} exists for the name, indicating an
   *     active ban status, false otherwise
  */
  isBanned(target: string): boolean;
  /**
   * Removes the specified target from this list, therefore indicating a
   * "not banned" status.
   *
   * @param target the target to remove from this list
  */
  pardon(target: string): void;
}
/**
 * Determines the collision behavior when fluids get hit during ray tracing.
*/
export class FluidCollisionMode extends Enum<FluidCollisionMode> {
  /**
   * Ignore fluids.
  */
  static readonly NEVER: FluidCollisionMode;
  /**
   * Only collide with source fluid blocks.
  */
  static readonly SOURCE_ONLY: FluidCollisionMode;
  /**
   * Collide with all fluids.
  */
  static readonly ALWAYS: FluidCollisionMode;
  static valueOf(name: string): FluidCollisionMode;
  static values(): FluidCollisionMode[];
}
export class WorldBorder {
  /**
   * Get the {@link World} in which the border resides.
   *
   * @return the associated world, or null if this world border is not associated
   * with any specific world, such as those created via {@link Server#createWorldBorder()}
  */
  getWorld(): World | null;
  /**
   * Resets the border to default values.
  */
  reset(): void;
  /**
   * Gets the current side length of the border.
   *
   * @return The current side length of the border.
  */
  getSize(): number;
  /**
   * Sets the border to a square region with the specified side length in blocks.
   *
   * @param newSize The new size of the border.
  */
  setSize(size: number);
  /**
   * Sets the border to a square region with the specified side length in blocks.
   *
   * @param newSize The new side length of the border.
   * @param seconds The time in seconds in which the border grows or shrinks from the previous size to that being set.
  */
  setSize(newSize: number, seconds: number): void;
  /**
   * Gets the current border center.
   *
   * @return The current border center.
  */
  getCenter(): Location;
  /**
   * Sets the new border center.
   *
   * @param x The new center x-coordinate.
   * @param z The new center z-coordinate.
  */
  setCenter(x: number, z: number): void;
  /**
   * Sets the new border center.
   *
   * @param location The new location of the border center. (Only x/z used)
  */
  setCenter(center: Location);
  /**
   * Gets the current border damage buffer.
   *
   * @return The current border damage buffer.
  */
  getDamageBuffer(): number;
  /**
   * Sets the amount of blocks a player may safely be outside the border before taking damage.
   *
   * @param blocks The amount of blocks. (The default is 5 blocks.)
  */
  setDamageBuffer(damageBuffer: number);
  /**
   * Gets the current border damage amount.
   *
   * @return The current border damage amount.
  */
  getDamageAmount(): number;
  /**
   * Sets the amount of damage a player takes when outside the border plus the border buffer.
   *
   * @param damage The amount of damage. (The default is 0.2 damage per second per block.)
  */
  setDamageAmount(damageAmount: number);
  /**
   * Gets the current border warning time in seconds.
   *
   * @return The current border warning time in seconds.
  */
  getWarningTime(): number;
  /**
   * Sets the warning time that causes the screen to be tinted red when a contracting border will reach the player within the specified time.
   *
   * @param seconds The amount of time in seconds. (The default is 15 seconds.)
  */
  setWarningTime(warningTime: number);
  /**
   * Gets the current border warning distance.
   *
   * @return The current border warning distance.
  */
  getWarningDistance(): number;
  /**
   * Sets the warning distance that causes the screen to be tinted red when the player is within the specified number of blocks from the border.
   *
   * @param distance The distance in blocks. (The default is 5 blocks.)
  */
  setWarningDistance(warningDistance: number);
  /**
   * Check if the specified location is inside this border.
   *
   * @param location the location to check
   * @return if this location is inside the border or not
  */
  isInside(location: Location): boolean;
  /**
   * Checks if the location is within the boundaries of this border.
   * 
   * @param location specific location to check
   * @return true if the location is within the bounds of this border, false otherwise.
   * @deprecated use {@link #isInside(Location)} for an upstream compatible replacement
  */
  isInBounds(location: Location): boolean;
}
/**
 * An enum of all current weather types
*/
export class WeatherType extends Enum<WeatherType> {
  /**
   * Raining or snowing depending on biome.
  */
  static readonly DOWNFALL: WeatherType;
  /**
   * Clear weather, clouds but no rain.
  */
  static readonly CLEAR: WeatherType;
  static valueOf(name: string): WeatherType;
  static values(): WeatherType[];
}
/**
 * All supported color values for chat
*/
export class ChatColor extends Enum<ChatColor> {
  /**
   * Represents black
  */
  static readonly BLACK: ChatColor;
  /**
   * Represents dark blue
  */
  static readonly DARK_BLUE: ChatColor;
  /**
   * Represents dark green
  */
  static readonly DARK_GREEN: ChatColor;
  /**
   * Represents dark blue (aqua)
  */
  static readonly DARK_AQUA: ChatColor;
  /**
   * Represents dark red
  */
  static readonly DARK_RED: ChatColor;
  /**
   * Represents dark purple
  */
  static readonly DARK_PURPLE: ChatColor;
  /**
   * Represents gold
  */
  static readonly GOLD: ChatColor;
  /**
   * Represents gray
  */
  static readonly GRAY: ChatColor;
  /**
   * Represents dark gray
  */
  static readonly DARK_GRAY: ChatColor;
  /**
   * Represents blue
  */
  static readonly BLUE: ChatColor;
  /**
   * Represents green
  */
  static readonly GREEN: ChatColor;
  /**
   * Represents aqua
  */
  static readonly AQUA: ChatColor;
  /**
   * Represents red
  */
  static readonly RED: ChatColor;
  /**
   * Represents light purple
  */
  static readonly LIGHT_PURPLE: ChatColor;
  /**
   * Represents yellow
  */
  static readonly YELLOW: ChatColor;
  /**
   * Represents white
  */
  static readonly WHITE: ChatColor;
  /**
   * Represents magical characters that change around randomly
  */
  static readonly MAGIC: ChatColor;
  /**
   * Makes the text bold.
  */
  static readonly BOLD: ChatColor;
  /**
   * Makes a line appear through the text.
  */
  static readonly STRIKETHROUGH: ChatColor;
  /**
   * Makes the text appear underlined.
  */
  static readonly UNDERLINE: ChatColor;
  /**
   * Makes the text italic.
  */
  static readonly ITALIC: ChatColor;
  /**
   * Resets all previous chat colors or formats.
  */
  static readonly RESET: ChatColor;
  static valueOf(name: string): ChatColor;
  static values(): ChatColor[];
  /**
   * The special character which prefixes all chat colour codes. Use this if
   * you need to dynamically convert colour codes from your custom format.
  */
  static readonly COLOR_CHAR: string;
  /**
   * Gets the char value associated with this color
   *
   * @return A char value of this color code
  */
  getChar(): string;
  toString(): string;
  /**
   * Checks if this code is a format code as opposed to a color code.
   *
   * @return whether this ChatColor is a format code
  */
  isFormat(): boolean;
  /**
   * Checks if this code is a color code as opposed to a format code.
   *
   * @return whether this ChatColor is a color code
  */
  isColor(): boolean;
  /**
   * Gets the color represented by the specified color code
   *
   * @param code Code to check
   * @return Associative {@link org.bukkit.ChatColor} with the given code,
   *     or null if it doesn't exist
  */
  static getByChar(code: string): ChatColor | null;
  /**
   * Strips the given message of all color codes
   *
   * @param input String to strip of color
   * @return A copy of the input string, without any coloring
  */
  static stripColor(input: string | null): string | null;
  /**
   * Translates a string using an alternate color code character into a
   * string that uses the internal ChatColor.COLOR_CODE color code
   * character. The alternate color code character will only be replaced if
   * it is immediately followed by 0-9, A-F, a-f, K-O, k-o, R or r.
   *
   * @param altColorChar The alternate color code character to replace. Ex: {@literal &}
   * @param textToTranslate Text containing the alternate color code character.
   * @return Text containing the ChatColor.COLOR_CODE color code character.
  */
  static translateAlternateColorCodes(altColorChar: string, textToTranslate: string): string;
  /**
   * Gets the ChatColors used at the end of the given input string.
   *
   * @param input Input string to retrieve the colors from.
   * @return Any remaining ChatColors to pass onto the next line.
  */
  static getLastColors(input: string): string;
}
/**
 * Represents a chunk of blocks
*/
export class Chunk extends PersistentDataHolder {
  /**
   * Gets the X-coordinate of this chunk
   *
   * @return X-coordinate
  */
  getX(): number;
  /**
   * Gets the Z-coordinate of this chunk
   *
   * @return Z-coordinate
  */
  getZ(): number;
  /**
   * @return The Chunks X and Z coordinates packed into a long
  */
  getChunkKey(): number;
  /**
   * @param loc Location to get chunk key
   * @return Location's chunk coordinates packed into a long
  */
  static getChunkKey(loc: Location): number;
  /**
   * @param x X Coordinate
   * @param z Z Coordinate
   * @return Chunk coordinates packed into a long
  */
  static getChunkKey(x: number, z: number): number;
  /**
   * Gets the world containing this chunk
   *
   * @return Parent World
  */
  getWorld(): World;
  /**
   * Gets a block from this chunk
   *
   * @param x 0-15
   * @param y world minHeight (inclusive) - world maxHeight (exclusive)
   * @param z 0-15
   * @return the Block
  */
  getBlock(x: number, y: number, z: number): Block;
  /**
   * Capture thread-safe read-only snapshot of chunk data
   *
   * @return ChunkSnapshot
  */
  getChunkSnapshot(): ChunkSnapshot;
  /**
   * Capture thread-safe read-only snapshot of chunk data
   *
   * @param includeMaxblocky - if true, snapshot includes per-coordinate
   *     maximum Y values
   * @param includeBiome - if true, snapshot includes per-coordinate biome
   *     type
   * @param includeBiomeTempRain - if true, snapshot includes per-coordinate
   *     raw biome temperature and rainfall
   * @return ChunkSnapshot
  */
  getChunkSnapshot(includeMaxblocky: boolean, includeBiome: boolean, includeBiomeTempRain: boolean): ChunkSnapshot;
  /**
   * Checks if entities in this chunk are loaded.
   *
   * @return True if entities are loaded.
  */
  isEntitiesLoaded(): boolean;
  /**
   * Get a list of all entities in the chunk.
   * This will force load any entities, which are not loaded.
   *
   * @return The entities.
  */
  getEntities(): Entity[];
  /**
   * Get a list of all tile entities in the chunk.
   *
   * @return The tile entities.
  */
  getTileEntities(): BlockState[];
  /**
   * Get a list of all tile entities in the chunk.
   *
   * @param useSnapshot Take snapshots or direct references
   * @return The tile entities.
  */
  getTileEntities(useSnapshot: boolean): BlockState[];
  /**
   * Get a list of all tile entities that match a given predicate in the chunk.
   *
   * @param blockPredicate The predicate of blocks to return tile entities for
   * @param useSnapshot Take snapshots or direct references
   * @return The tile entities.
  */
  getTileEntities(blockPredicate: Predicate<Block>, useSnapshot: boolean): Collection<BlockState>;
  /**
   * Checks if the chunk is loaded.
   *
   * @return True if it is loaded.
  */
  isLoaded(): boolean;
  /**
   * Loads the chunk.
   *
   * @param generate Whether or not to generate a chunk if it doesn't
   *     already exist
   * @return true if the chunk has loaded successfully, otherwise false
  */
  load(generate: boolean): boolean;
  /**
   * Loads the chunk.
   *
   * @return true if the chunk has loaded successfully, otherwise false
  */
  load(): boolean;
  /**
   * Unloads and optionally saves the Chunk
   *
   * @param save Controls whether the chunk is saved
   * @return true if the chunk has unloaded successfully, otherwise false
  */
  unload(save: boolean): boolean;
  /**
   * Unloads and optionally saves the Chunk
   *
   * @return true if the chunk has unloaded successfully, otherwise false
  */
  unload(): boolean;
  /**
   * Checks if this chunk can spawn slimes without being a swamp biome.
   *
   * @return true if slimes are able to spawn in this chunk
  */
  isSlimeChunk(): boolean;
  /**
   * Gets whether the chunk at the specified chunk coordinates is force
   * loaded.
   * 
   * A force loaded chunk will not be unloaded due to lack of player activity.
   *
   * @return force load status
   * @see World#isChunkForceLoaded(int, int)
  */
  isForceLoaded(): boolean;
  /**
   * Sets whether the chunk at the specified chunk coordinates is force
   * loaded.
   * 
   * A force loaded chunk will not be unloaded due to lack of player activity.
   *
   * @param forced force load status
   * @see World#setChunkForceLoaded(int, int, boolean)
  */
  setForceLoaded(forced: boolean): void;
  /**
   * Adds a plugin ticket for this chunk, loading this chunk if it is not
   * already loaded.
   * 
   * A plugin ticket will prevent a chunk from unloading until it is
   * explicitly removed. A plugin instance may only have one ticket per chunk,
   * but each chunk can have multiple plugin tickets.
   * 
   *
   * @param plugin Plugin which owns the ticket
   * @return `true` if a plugin ticket was added, `false` if the
   * ticket already exists for the plugin
   * @throws IllegalStateException If the specified plugin is not enabled
   * @see World#addPluginChunkTicket(int, int, Plugin)
  */
  addPluginChunkTicket(plugin: Plugin): boolean;
  /**
   * Removes the specified plugin's ticket for this chunk
   * 
   * A plugin ticket will prevent a chunk from unloading until it is
   * explicitly removed. A plugin instance may only have one ticket per chunk,
   * but each chunk can have multiple plugin tickets.
   * 
   *
   * @param plugin Plugin which owns the ticket
   * @return `true` if the plugin ticket was removed, `false` if
   * there is no plugin ticket for the chunk
   * @see World#removePluginChunkTicket(int, int, Plugin)
  */
  removePluginChunkTicket(plugin: Plugin): boolean;
  /**
   * Retrieves a collection specifying which plugins have tickets for this
   * chunk. This collection is not updated when plugin tickets are added or
   * removed to this chunk.
   * 
   * A plugin ticket will prevent a chunk from unloading until it is
   * explicitly removed. A plugin instance may only have one ticket per chunk,
   * but each chunk can have multiple plugin tickets.
   * 
   *
   * @return unmodifiable collection containing which plugins have tickets for
   * this chunk
   * @see World#getPluginChunkTickets(int, int)
  */
  getPluginChunkTickets(): Collection<Plugin>;
  /**
   * Gets the amount of time in ticks that this chunk has been inhabited.
   *
   * Note that the time is incremented once per tick per player in the chunk.
   *
   * @return inhabited time
  */
  getInhabitedTime(): number;
  /**
   * Sets the amount of time in ticks that this chunk has been inhabited.
   *
   * @param ticks new inhabited time
  */
  setInhabitedTime(inhabitedTime: number);
  /**
   * Tests if this chunk contains the specified block.
   *
   * @param block block to test
   * @return if the block is contained within
  */
  contains(block: BlockData): boolean;
}
/**
 * GameRules dictate certain behavior within Minecraft itself
 * 
 * For more information please visit the
 * Minecraft
 * Wiki
 *
 * @param  type of rule (Boolean or Integer)
*/
export class GameRule<T> extends Translatable {
  /**
   * Toggles the announcing of advancements.
  */
  static readonly ANNOUNCE_ADVANCEMENTS: GameRule<boolean>;
  /**
   * Whether command blocks should notify admins when they perform commands.
  */
  static readonly COMMAND_BLOCK_OUTPUT: GameRule<boolean>;
  /**
   * Whether the server should skip checking player speed when the player is
   * wearing elytra.
  */
  static readonly DISABLE_ELYTRA_MOVEMENT_CHECK: GameRule<boolean>;
  /**
   * Whether time progresses from the current moment.
  */
  static readonly DO_DAYLIGHT_CYCLE: GameRule<boolean>;
  /**
   * Whether entities that are not mobs should have drops.
  */
  static readonly DO_ENTITY_DROPS: GameRule<boolean>;
  /**
   * Whether fire should spread and naturally extinguish.
  */
  static readonly DO_FIRE_TICK: GameRule<boolean>;
  /**
   * Whether players should only be able to craft recipes they've unlocked
   * first.
  */
  static readonly DO_LIMITED_CRAFTING: GameRule<boolean>;
  /**
   * Whether mobs should drop items.
  */
  static readonly DO_MOB_LOOT: GameRule<boolean>;
  /**
   * Whether mobs should naturally spawn.
  */
  static readonly DO_MOB_SPAWNING: GameRule<boolean>;
  /**
   * Whether blocks should have drops.
  */
  static readonly DO_TILE_DROPS: GameRule<boolean>;
  /**
   * Whether the weather will change from the current moment.
  */
  static readonly DO_WEATHER_CYCLE: GameRule<boolean>;
  /**
   * Whether the player should keep items in their inventory after death.
  */
  static readonly KEEP_INVENTORY: GameRule<boolean>;
  /**
   * Whether to log admin commands to server log.
  */
  static readonly LOG_ADMIN_COMMANDS: GameRule<boolean>;
  /**
   * Whether mobs can pick up items or change blocks.
  */
  static readonly MOB_GRIEFING: GameRule<boolean>;
  /**
   * Whether players can regenerate health naturally through their hunger bar.
  */
  static readonly NATURAL_REGENERATION: GameRule<boolean>;
  /**
   * Whether the debug screen shows all or reduced information.
  */
  static readonly REDUCED_DEBUG_INFO: GameRule<boolean>;
  /**
   * Whether the feedback from commands executed by a player should show up in
   * chat. Also affects the default behavior of whether command blocks store
   * their output text.
  */
  static readonly SEND_COMMAND_FEEDBACK: GameRule<boolean>;
  /**
   * Whether a message appears in chat when a player dies.
  */
  static readonly SHOW_DEATH_MESSAGES: GameRule<boolean>;
  /**
   * Whether players in spectator mode can generate chunks.
  */
  static readonly SPECTATORS_GENERATE_CHUNKS: GameRule<boolean>;
  /**
   * Whether pillager raids are enabled or not.
  */
  static readonly DISABLE_RAIDS: GameRule<boolean>;
  /**
   * Whether phantoms will appear without sleeping or not.
  */
  static readonly DO_INSOMNIA: GameRule<boolean>;
  /**
   * Whether clients will respawn immediately after death or not.
  */
  static readonly DO_IMMEDIATE_RESPAWN: GameRule<boolean>;
  /**
   * Whether drowning damage is enabled or not.
  */
  static readonly DROWNING_DAMAGE: GameRule<boolean>;
  /**
   * Whether fall damage is enabled or not.
  */
  static readonly FALL_DAMAGE: GameRule<boolean>;
  /**
   * Whether fire damage is enabled or not.
  */
  static readonly FIRE_DAMAGE: GameRule<boolean>;
  /**
   * Whether freeze damage is enabled or not.
  */
  static readonly FREEZE_DAMAGE: GameRule<boolean>;
  /**
   * Whether patrols should naturally spawn.
  */
  static readonly DO_PATROL_SPAWNING: GameRule<boolean>;
  /**
   * Whether traders should naturally spawn.
  */
  static readonly DO_TRADER_SPAWNING: GameRule<boolean>;
  /**
   * Whether mobs should cease being angry at a player once they die.
  */
  static readonly FORGIVE_DEAD_PLAYERS: GameRule<boolean>;
  /**
   * Whether mobs will target all player entities once angered.
  */
  static readonly UNIVERSAL_ANGER: GameRule<boolean>;
  /**
   * How often a random block tick occurs (such as plant growth, leaf decay,
   * etc.) per chunk section per game tick. 0 will disable random ticks,
   * higher numbers will increase random ticks.
  */
  static readonly RANDOM_TICK_SPEED: GameRule<number>;
  /**
   * The number of blocks outward from the world spawn coordinates that a
   * player will spawn in when first joining a server or when dying without a
   * spawnpoint.
  */
  static readonly SPAWN_RADIUS: GameRule<number>;
  /**
   * The maximum number of other pushable entities a mob or player can push,
   * before taking suffocation damage.
   * 
   * Setting to 0 disables this rule.
  */
  static readonly MAX_ENTITY_CRAMMING: GameRule<number>;
  /**
   * Determines the number at which the chain of command blocks act as a
   * "chain."
   * 
   * This is the maximum amount of command blocks that can be activated in a
   * single tick from a single chain.
  */
  static readonly MAX_COMMAND_CHAIN_LENGTH: GameRule<number>;
  /**
   * The percentage of online players which must be sleeping for the night to
   * advance.
  */
  static readonly PLAYERS_SLEEPING_PERCENTAGE: GameRule<number>;
  /**
   * Get the name of this GameRule.
   *
   * @return the name of this GameRule
  */
  getName(): string;
  /**
   * Get the type of this rule.
   *
   * @return the rule type; Integer or Boolean
  */
  getType(): Class<T>;
  equals(obj: any): boolean;
  toString(): string;
  /**
   * Get a {@link GameRule} by its name.
   *
   * @param rule the name of the GameRule
   * @return the {@link GameRule} or null if no GameRule matches the given
   * name
  */
  static getByName(rule: string): GameRule<any> | null;
  /**
   * Get an immutable collection of {@link GameRule}s.
   *
   * @return an immutable collection containing all registered GameRules.
  */
  static values(): GameRule[];
  /**
   * Gets the translation key.
   *
   * @return the translation key
   * @since 4.8.0
  */
  translationKey(): string;
}
/**
 * Represents a server implementation.
*/
export class Server extends PluginMessageRecipient {
  /**
   * Returns the de facto plugins directory, generally used for storing plugin jars to be loaded,
   * as well as their {@link org.bukkit.plugin.Plugin#getDataFolder() data folders}.
   *
   * Plugins should use {@link org.bukkit.plugin.Plugin#getDataFolder()} rather than traversing this
   * directory manually when determining the location in which to store their data and configuration files.
   *
   * @return plugins directory
  */
  getPluginsFolder(): File;
  /**
   * Used for all administrative messages, such as an operator using a
   * command.
   * 
   * For use in {@link #broadcast(net.kyori.adventure.text.Component, java.lang.String)}.
  */
  static readonly BROADCAST_CHANNEL_ADMINISTRATIVE: string;
  /**
   * Used for all announcement messages, such as informing users that a
   * player has joined.
   * 
   * For use in {@link #broadcast(net.kyori.adventure.text.Component, java.lang.String)}.
  */
  static readonly BROADCAST_CHANNEL_USERS: string;
  /**
   * Gets the name of this server implementation.
   *
   * @return name of this server implementation
  */
  getName(): string;
  /**
   * Gets the version string of this server implementation.
   *
   * @return version of this server implementation
  */
  getVersion(): string;
  /**
   * Gets the Bukkit version that this server is running.
   *
   * @return version of Bukkit
  */
  getBukkitVersion(): string;
  /**
   * Gets the version of game this server implements
   *
   * @return version of game
  */
  getMinecraftVersion(): string;
  /**
   * Gets a view of all currently logged in players. This {@linkplain
   * Collections#unmodifiableCollection(Collection) view} is a reused
   * object, making some operations like {@link Collection#size()}
   * zero-allocation.
   * 
   * The collection is a view backed by the internal representation, such
   * that, changes to the internal state of the server will be reflected
   * immediately. However, the reuse of the returned collection (identity)
   * is not strictly guaranteed for future or all implementations. Casting
   * the collection, or relying on interface implementations (like {@link
   * Serializable} or {@link List}), is deprecated.
   * 
   * Iteration behavior is undefined outside of self-contained main-thread
   * uses. Normal and immediate iterator use without consequences that
   * affect the collection are fully supported. The effects following
   * (non-exhaustive) {@link Entity#teleport(Location) teleportation},
   * {@link Player#setHealth(double) death}, and {@link Player#kickPlayer(
   * String) kicking} are undefined. Any use of this collection from
   * asynchronous threads is unsafe.
   * 
   * For safe consequential iteration or mimicking the old array behavior,
   * using {@link Collection#toArray(Object[])} is recommended. For making
   * snapshots, {@link ImmutableList#copyOf(Collection)} is recommended.
   *
   * @return a view of currently online players.
  */
  getOnlinePlayers(): Collection<Player>;
  /**
   * Get the maximum amount of players which can login to this server.
   *
   * @return the amount of players this server allows
  */
  getMaxPlayers(): number;
  /**
   * Set the maximum amount of players which can login to this server.
   *
   * @param maxPlayers the amount of players this server allows
  */
  setMaxPlayers(maxPlayers: number);
  /**
   * Get the game port that the server runs on.
   *
   * @return the port number of this server
  */
  getPort(): number;
  /**
   * Get the view distance from this server.
   *
   * @return the view distance from this server.
  */
  getViewDistance(): number;
  /**
   * Get the simulation distance from this server.
   *
   * @return the simulation distance from this server.
  */
  getSimulationDistance(): number;
  /**
   * Get the IP that this server is bound to, or empty string if not
   * specified.
   *
   * @return the IP string that this server is bound to, otherwise empty
   *     string
  */
  getIp(): string;
  /**
   * Get world type (level-type setting) for default world.
   *
   * @return the value of level-type (e.g. DEFAULT, FLAT, DEFAULT_1_1)
  */
  getWorldType(): string;
  /**
   * Get generate-structures setting.
   *
   * @return true if structure generation is enabled, false otherwise
  */
  getGenerateStructures(): boolean;
  /**
   * Get max world size.
   *
   * @return the maximum world size as specified for the server
  */
  getMaxWorldSize(): number;
  /**
   * Gets whether this server allows the End or not.
   *
   * @return whether this server allows the End or not
  */
  getAllowEnd(): boolean;
  /**
   * Gets whether this server allows the Nether or not.
   *
   * @return whether this server allows the Nether or not
  */
  getAllowNether(): boolean;
  /**
   * Gets the server resource pack uri, or empty string if not specified.
   *
   * @return the server resource pack uri, otherwise empty string
  */
  getResourcePack(): string;
  /**
   * Gets the SHA-1 digest of the server resource pack, or empty string if
   * not specified.
   *
   * @return the SHA-1 digest of the server resource pack, otherwise empty
   *     string
  */
  getResourcePackHash(): string;
  /**
   * Gets the custom prompt message to be shown when the server resource
   * pack is required, or empty string if not specified.
   *
   * @return the custom prompt message to be shown when the server resource,
   *     otherwise empty string
  */
  getResourcePackPrompt(): string;
  /**
   * Gets whether the server resource pack is enforced.
   *
   * @return whether the server resource pack is enforced
  */
  isResourcePackRequired(): boolean;
  /**
   * Gets whether this server has a whitelist or not.
   *
   * @return whether this server has a whitelist or not
  */
  hasWhitelist(): boolean;
  /**
   * Sets if the server is whitelisted.
   *
   * @param value true for whitelist on, false for off
  */
  setWhitelist(value: boolean): void;
  /**
   * Gets whether the server whitelist is enforced.
   *
   * If the whitelist is enforced, non-whitelisted players will be
   * disconnected when the server whitelist is reloaded.
   *
   * @return whether the server whitelist is enforced
  */
  isWhitelistEnforced(): boolean;
  /**
   * Sets if the server whitelist is enforced.
   *
   * If the whitelist is enforced, non-whitelisted players will be
   * disconnected when the server whitelist is reloaded.
   *
   * @param value true for enforced, false for not
  */
  setWhitelistEnforced(value: boolean): void;
  /**
   * Gets a list of whitelisted players.
   *
   * @return a set containing all whitelisted players
  */
  getWhitelistedPlayers(): Set<OfflinePlayer>;
  /**
   * Reloads the whitelist from disk.
  */
  reloadWhitelist(): void;
  /**
   * Broadcast a message to all players.
   * 
   * This is the same as calling {@link #broadcast(java.lang.String,
   * java.lang.String)} to {@link #BROADCAST_CHANNEL_USERS}
   *
   * @param message the message
   * @return the number of players
   * @deprecated use {@link #broadcast(net.kyori.adventure.text.Component)}
  */
  broadcastMessage(message: string): number;
  /**
   * Gets the name of the update folder. The update folder is used to safely
   * update plugins at the right moment on a plugin load.
   * 
   * The update folder name is relative to the plugins folder.
   *
   * @return the name of the update folder
  */
  getUpdateFolder(): string;
  /**
   * Gets the update folder. The update folder is used to safely update
   * plugins at the right moment on a plugin load.
   *
   * @return the update folder
  */
  getUpdateFolderFile(): File;
  /**
   * Gets the value of the connection throttle setting.
   *
   * @return the value of the connection throttle setting
  */
  getConnectionThrottle(): number;
  /**
   * Gets default ticks per animal spawns value.
   * 
   * Example Usage:
   * 
   * A value of 1 will mean the server will attempt to spawn monsters
   *     every tick.
   * A value of 400 will mean the server will attempt to spawn monsters
   *     every 400th tick.
   * A value below 0 will be reset back to Minecraft's default.
   * 
   * 
   * Note: If set to 0, animal spawning will be disabled. We
   * recommend using spawn-animals to control this instead.
   * 
   * Minecraft default: 400.
   *
   * @return the default ticks per animal spawns value
   * @deprecated Deprecated in favor of {@link #getTicksPerSpawns(SpawnCategory)}
  */
  getTicksPerAnimalSpawns(): number;
  /**
   * Gets the default ticks per monster spawns value.
   * 
   * Example Usage:
   * 
   * A value of 1 will mean the server will attempt to spawn monsters
   *     every tick.
   * A value of 400 will mean the server will attempt to spawn monsters
   *     every 400th tick.
   * A value below 0 will be reset back to Minecraft's default.
   * 
   * 
   * Note: If set to 0, monsters spawning will be disabled. We
   * recommend using spawn-monsters to control this instead.
   * 
   * Minecraft default: 1.
   *
   * @return the default ticks per monsters spawn value
   * @deprecated Deprecated in favor of {@link #getTicksPerSpawns(SpawnCategory)}
  */
  getTicksPerMonsterSpawns(): number;
  /**
   * Gets the default ticks per water mob spawns value.
   * 
   * Example Usage:
   * 
   * A value of 1 will mean the server will attempt to spawn water mobs
   *     every tick.
   * A value of 400 will mean the server will attempt to spawn water mobs
   *     every 400th tick.
   * A value below 0 will be reset back to Minecraft's default.
   * 
   * 
   * Note: If set to 0, water mobs spawning will be disabled.
   * 
   * Minecraft default: 1.
   *
   * @return the default ticks per water mobs spawn value
   * @deprecated Deprecated in favor of {@link #getTicksPerSpawns(SpawnCategory)}
  */
  getTicksPerWaterSpawns(): number;
  /**
   * Gets the default ticks per water ambient mob spawns value.
   * 
   * Example Usage:
   * 
   * A value of 1 will mean the server will attempt to spawn water ambient mobs
   *     every tick.
   * A value of 400 will mean the server will attempt to spawn water ambient mobs
   *     every 400th tick.
   * A value below 0 will be reset back to Minecraft's default.
   * 
   * 
   * Note: If set to 0, ambient mobs spawning will be disabled.
   * 
   * Minecraft default: 1.
   *
   * @return the default ticks per water ambient mobs spawn value
   * @deprecated Deprecated in favor of {@link #getTicksPerSpawns(SpawnCategory)}
  */
  getTicksPerWaterAmbientSpawns(): number;
  /**
   * Gets the default ticks per water underground creature spawns value.
   * 
   * Example Usage:
   * 
   * A value of 1 will mean the server will attempt to spawn water underground creature
   *     every tick.
   * A value of 400 will mean the server will attempt to spawn water underground creature
   *     every 400th tick.
   * A value below 0 will be reset back to Minecraft's default.
   * 
   * 
   * Note: If set to 0, water underground creature spawning will be disabled.
   * 
   * Minecraft default: 1.
   *
   * @return the default ticks per water underground creature spawn value
   * @deprecated Deprecated in favor of {@link #getTicksPerSpawns(SpawnCategory)}
  */
  getTicksPerWaterUndergroundCreatureSpawns(): number;
  /**
   * Gets the default ticks per ambient mob spawns value.
   * 
   * Example Usage:
   * 
   * A value of 1 will mean the server will attempt to spawn ambient mobs
   *     every tick.
   * A value of 400 will mean the server will attempt to spawn ambient mobs
   *     every 400th tick.
   * A value below 0 will be reset back to Minecraft's default.
   * 
   * 
   * Note: If set to 0, ambient mobs spawning will be disabled.
   * 
   * Minecraft default: 1.
   *
   * @return the default ticks per ambient mobs spawn value
   * @deprecated Deprecated in favor of {@link #getTicksPerSpawns(SpawnCategory)}
  */
  getTicksPerAmbientSpawns(): number;
  /**
   * Gets the default ticks per {@link SpawnCategory} spawns value.
   * 
   * Example Usage:
   * 
   * A value of 1 will mean the server will attempt to spawn {@link SpawnCategory} mobs
   *     every tick.
   * A value of 400 will mean the server will attempt to spawn {@link SpawnCategory} mobs
   *     every 400th tick.
   * A value below 0 will be reset back to Minecraft's default.
   * 
   * 
   * Note: If set to 0, {@link SpawnCategory} mobs spawning will be disabled.
   *
   * @param spawnCategory the category of spawn
   * @return the default ticks per {@link SpawnCategory} mobs spawn value
   * @throws IllegalArgumentException if the category is {@link SpawnCategory#MISC}
  */
  getTicksPerSpawns(spawnCategory: SpawnCategory): number;
  /**
   * Gets a player object by the given username.
   * 
   * This method may not return objects for offline players.
   *
   * @param name the name to look up
   * @return a player if one was found, null otherwise
  */
  getPlayer(name: string): Player | null;
  /**
   * Gets the player with the exact given name, case insensitive.
   *
   * @param name Exact name of the player to retrieve
   * @return a player object if one was found, null otherwise
  */
  getPlayerExact(name: string): Player | null;
  /**
   * Attempts to match any players with the given name, and returns a list
   * of all possibly matches.
   * 
   * This list is not sorted in any particular order. If an exact match is
   * found, the returned list will only contain a single result.
   *
   * @param name the (partial) name to match
   * @return list of all possible players
  */
  matchPlayer(name: string): Player[];
  /**
   * Gets the player with the given UUID.
   *
   * @param id UUID of the player to retrieve
   * @return a player object if one was found, null otherwise
  */
  getPlayer(id: UUID): Player | null;
  /**
   * Gets the unique ID of the player currently known as the specified player name
   * In Offline Mode, will return an Offline UUID
   *
   * @param playerName the player name to look up the unique ID for
   * @return A UUID, or null if that player name is not registered with Minecraft and the server is in online mode
  */
  getPlayerUniqueId(playerName: string): UUID | null;
  /**
   * Gets the plugin manager for interfacing with plugins.
   *
   * @return a plugin manager for this Server instance
  */
  getPluginManager(): PluginManager;
  /**
   * Gets the scheduler for managing scheduled events.
   *
   * @return a scheduling service for this server
  */
  getScheduler(): BukkitScheduler;
  /**
   * Gets a services manager.
   *
   * @return s services manager
  */
  getServicesManager(): ServicesManager;
  /**
   * Gets a list of all worlds on this server.
   *
   * @return a list of worlds
  */
  getWorlds(): World[];
  /**
   * Creates or loads a world with the given name using the specified
   * options.
   * 
   * If the world is already loaded, it will just return the equivalent of
   * getWorld(creator.name()).
   *
   * @param creator the options to use when creating the world
   * @return newly created or loaded world
  */
  createWorld(creator: WorldCreator): World | null;
  /**
   * Unloads a world with the given name.
   *
   * @param name Name of the world to unload
   * @param save whether to save the chunks before unloading
   * @return true if successful, false otherwise
  */
  unloadWorld(name: string, save: boolean): boolean;
  /**
   * Unloads the given world.
   *
   * @param world the world to unload
   * @param save whether to save the chunks before unloading
   * @return true if successful, false otherwise
  */
  unloadWorld(world: World, save: boolean): boolean;
  /**
   * Gets the world with the given name.
   *
   * @param name the name of the world to retrieve
   * @return a world with the given name, or null if none exists
  */
  getWorld(name: string): World | null;
  /**
   * Gets the world from the given Unique ID.
   *
   * @param uid a unique-id of the world to retrieve
   * @return a world with the given Unique ID, or null if none exists
  */
  getWorld(uid: UUID): World | null;
  /**
   * Gets the world from the given NamespacedKey
   *
   * @param worldKey the NamespacedKey of the world to retrieve
   * @return a world with the given NamespacedKey, or null if none exists
  */
  getWorld(worldKey: NamespacedKey): World | null;
  /**
   * Create a new virtual {@link WorldBorder}.
   * 
   * Note that world borders created by the server will not respect any world
   * scaling effects (i.e. coordinates are not divided by 8 in the nether).
   *
   * @return the created world border instance
   *
   * @see Player#setWorldBorder(WorldBorder)
  */
  createWorldBorder(): WorldBorder;
  /**
   * Gets the map from the given item ID.
   *
   * @param id the id of the map to get
   * @return a map view if it exists, or null otherwise
   * @deprecated Magic value
  */
  getMap(id: number): MapView | null;
  /**
   * Create a new map with an automatically assigned ID.
   *
   * @param world the world the map will belong to
   * @return a newly created map view
  */
  createMap(world: World): MapView;
  /**
   * Create a new explorer map targeting the closest nearby structure of a
   * given {@link StructureType}.
   * 
   * This method uses implementation default values for radius and
   * findUnexplored (usually 100, true).
   *
   * @param world the world the map will belong to
   * @param location the origin location to find the nearest structure
   * @param structureType the type of structure to find
   * @return a newly created item stack
   *
   * @see World#locateNearestStructure(org.bukkit.Location,
   *      org.bukkit.StructureType, int, boolean)
  */
  createExplorerMap(world: World, location: Location, structureType: StructureType): ItemStack;
  /**
   * Create a new explorer map targeting the closest nearby structure of a
   * given {@link StructureType}.
   * 
   * This method uses implementation default values for radius and
   * findUnexplored (usually 100, true).
   *
   * @param world the world the map will belong to
   * @param location the origin location to find the nearest structure
   * @param structureType the type of structure to find
   * @param radius radius to search, see World#locateNearestStructure for more
   *               information
   * @param findUnexplored whether to find unexplored structures
   * @return the newly created item stack
   *
   * @see World#locateNearestStructure(org.bukkit.Location,
   *      org.bukkit.StructureType, int, boolean)
  */
  createExplorerMap(world: World, location: Location, structureType: StructureType, radius: number, findUnexplored: boolean): ItemStack;
  /**
   * Reloads the server, refreshing settings and plugin information.
  */
  reload(): void;
  /**
   * Reload only the Minecraft data for the server. This includes custom
   * advancements and loot tables.
  */
  reloadData(): void;
  /**
   * Returns the primary logger associated with this server instance.
   *
   * @return Logger associated with this server
  */
  getLogger(): Logger;
  /**
   * Gets a {@link PluginCommand} with the given name or alias.
   *
   * @param name the name of the command to retrieve
   * @return a plugin command if found, null otherwise
  */
  getPluginCommand(name: string): PluginCommand | null;
  /**
   * Writes loaded players to disk.
  */
  savePlayers(): void;
  /**
   * Dispatches a command on this server, and executes it if found.
   *
   * @param sender the apparent sender of the command
   * @param commandLine the command + arguments. Example: test abc
   *     123
   * @return returns false if no target is found
   * @throws CommandException thrown when the executor for the given command
   *     fails with an unhandled exception
  */
  dispatchCommand(sender: CommandSender, commandLine: string): boolean;
  /**
   * Adds a recipe to the crafting manager.
   *
   * @param recipe the recipe to add
   * @return true if the recipe was added, false if it wasn't for some
   *     reason
  */
  addRecipe(recipe: Recipe | null): boolean;
  /**
   * Get a list of all recipes for a given item. The stack size is ignored
   * in comparisons. If the durability is -1, it will match any data value.
   *
   * @param result the item to match against recipe results
   * @return a list of recipes with the given result
  */
  getRecipesFor(result: ItemStack): Recipe[];
  /**
   * Get the {@link Recipe} for the given key.
   *
   * @param recipeKey the key of the recipe to return
   * @return the recipe for the given key or null.
  */
  getRecipe(recipeKey: NamespacedKey): Recipe | null;
  /**
   * Get the {@link Recipe} for the list of ItemStacks provided.
   *
   * The list is formatted as a crafting matrix where the index follow
   * the pattern below:
   *
   *      * [ 0 1 2 ]
   * [ 3 4 5 ]
   * [ 6 7 8 ]
   * 
   *
   * NOTE: This method will not modify the provided ItemStack array, for that, use
   * {@link #craftItem(ItemStack[], World, Player)}.
   *
   * @param craftingMatrix list of items to be crafted from.
   *                       Must not contain more than 9 items.
   * @param world The world the crafting takes place in.
   * @return the {@link Recipe} resulting from the given crafting matrix.
  */
  getCraftingRecipe(craftingMatrix: ItemStack[], world: World): Recipe | null;
  /**
   * Get the crafted item using the list of {@link ItemStack} provided.
   *
   * The list is formatted as a crafting matrix where the index follow
   * the pattern below:
   *
   *      * [ 0 1 2 ]
   * [ 3 4 5 ]
   * [ 6 7 8 ]
   * 
   *
   * The {@link World} and {@link Player} arguments are required to fulfill the Bukkit Crafting
   * events.
   *
   * Calls {@link org.bukkit.event.inventory.PrepareItemCraftEvent} to imitate the {@link Player}
   * initiating the crafting event.
   *
   * @param craftingMatrix list of items to be crafted from.
   *                       Must not contain more than 9 items.
   * @param world The world the crafting takes place in.
   * @param player The player to imitate the crafting event on.
   * @return the {@link ItemStack} resulting from the given crafting matrix, if no recipe is found
   * an ItemStack of {@link Material#AIR} is returned.
  */
  craftItem(craftingMatrix: ItemStack[], world: World, player: Player): ItemStack;
  /**
   * Get an iterator through the list of crafting recipes.
   *
   * @return an iterator
  */
  recipeIterator(): Iterator<Recipe>;
  /**
   * Clears the list of crafting recipes.
  */
  clearRecipes(): void;
  /**
   * Resets the list of crafting recipes to the default.
  */
  resetRecipes(): void;
  /**
   * Remove a recipe from the server.
   *
   * Note that removing a recipe may cause permanent loss of data
   * associated with that recipe (eg whether it has been discovered by
   * players).
   *
   * @param key NamespacedKey of recipe to remove.
   * @return True if recipe was removed
  */
  removeRecipe(key: NamespacedKey): boolean;
  /**
   * Gets a list of command aliases defined in the server properties.
   *
   * @return a map of aliases to command names
  */
  getCommandAliases(): Map<string, string[]>;
  /**
   * Gets the radius, in blocks, around each worlds spawn point to protect.
   *
   * @return spawn radius, or 0 if none
  */
  getSpawnRadius(): number;
  /**
   * Sets the radius, in blocks, around each worlds spawn point to protect.
   *
   * @param value new spawn radius, or 0 if none
  */
  setSpawnRadius(spawnRadius: number);
  /**
   * Gets whether the Server hide online players in server status.
   *
   * @return true if the server hide online players, false otherwise
  */
  getHideOnlinePlayers(): boolean;
  /**
   * Gets whether the Server is in online mode or not.
   *
   * @return true if the server authenticates clients, false otherwise
  */
  getOnlineMode(): boolean;
  /**
   * Gets whether this server allows flying or not.
   *
   * @return true if the server allows flight, false otherwise
  */
  getAllowFlight(): boolean;
  /**
   * Gets whether the server is in hardcore mode or not.
   *
   * @return true if the server mode is hardcore, false otherwise
  */
  isHardcore(): boolean;
  /**
   * Shutdowns the server, stopping everything.
  */
  shutdown(): void;
  /**
   * Broadcasts the specified message to every user with the given
   * permission name.
   *
   * @param message message to broadcast
   * @param permission the required permission {@link Permissible
   *     permissibles} must have to receive the broadcast
   * @return number of message recipients
   * @deprecated in favour of {@link #broadcast(net.kyori.adventure.text.Component, String)}
  */
  broadcast(message: string, permission: string): number;
  /**
   * Broadcast a message to all players.
   * 
   * This is the same as calling {@link #broadcast(net.kyori.adventure.text.Component,
   * java.lang.String)} with the {@link #BROADCAST_CHANNEL_USERS} permission.
   *
   * @param message the message
   * @return the number of players
  */
  broadcast(message: Component): number;
  /**
   * Broadcasts the specified message to every user with the given
   * permission name.
   *
   * @param message message to broadcast
   * @param permission the required permission {@link Permissible
   *     permissibles} must have to receive the broadcast
   * @return number of message recipients
  */
  broadcast(message: Component, permission: string): number;
  getOfflinePlayer(name: string): OfflinePlayer;
  /**
   * Gets the player by the given name, regardless if they are offline or
   * online.
   * 
   * This will not make a web request to get the UUID for the given name,
   * thus this method will not block. However this method will return
   * `null` if the player is not cached.
   * 
   *
   * @param name the name of the player to retrieve
   * @return an offline player if cached, `null` otherwise
   * @see #getOfflinePlayer(String)
   * @see #getOfflinePlayer(java.util.UUID)
  */
  getOfflinePlayerIfCached(name: string): OfflinePlayer | null;
  /**
   * Gets the player by the given UUID, regardless if they are offline or
   * online.
   * 
   * This will return an object even if the player does not exist. To this
   * method, all players will exist.
   *
   * @param id the UUID of the player to retrieve
   * @return an offline player
  */
  getOfflinePlayer(id: UUID): OfflinePlayer;
  /**
   * Creates a new {@link PlayerProfile}.
   *
   * @param uniqueId the unique id
   * @param name the name
   * @return the new PlayerProfile
   * @throws IllegalArgumentException if both the unique id is
   * null and the name is null or blank
   * @deprecated use {@link #createProfile(UUID, String)}
  */
  createPlayerProfile(uniqueId: UUID | null, name: string | null): PlayerProfile;
  /**
   * Creates a new {@link PlayerProfile}.
   *
   * @param uniqueId the unique id
   * @return the new PlayerProfile
   * @throws IllegalArgumentException if the unique id is null
   * @deprecated use {@link #createProfile(UUID)}
  */
  createPlayerProfile(uniqueId: UUID): PlayerProfile;
  /**
   * Creates a new {@link PlayerProfile}.
   *
   * @param name the name
   * @return the new PlayerProfile
   * @throws IllegalArgumentException if the name is null or
   * blank
   * @deprecated use {@link #createProfile(String)}
  */
  createPlayerProfile(name: string): PlayerProfile;
  /**
   * Gets a set containing all current IPs that are banned.
   *
   * @return a set containing banned IP addresses
  */
  getIPBans(): Set<string>;
  /**
   * Bans the specified address from the server.
   *
   * @param address the IP address to ban
  */
  banIP(address: string): void;
  /**
   * Unbans the specified address from the server.
   *
   * @param address the IP address to unban
  */
  unbanIP(address: string): void;
  /**
   * Gets a set containing all banned players.
   *
   * @return a set containing banned players
  */
  getBannedPlayers(): Set<OfflinePlayer>;
  /**
   * Gets a ban list for the supplied type.
   * 
   * Bans by name are no longer supported and this method will return
   * null when trying to request them. The replacement is bans by UUID.
   *
   * @param type the type of list to fetch, cannot be null
   * @return a ban list of the specified type
  */
  getBanList(type: Type): BanList;
  /**
   * Gets a set containing all player operators.
   *
   * @return a set containing player operators
  */
  getOperators(): Set<OfflinePlayer>;
  /**
   * Gets the default {@link GameMode} for new players.
   *
   * @return the default game mode
  */
  getDefaultGameMode(): GameMode;
  /**
   * Sets the default {@link GameMode} for new players.
   *
   * @param mode the new game mode
  */
  setDefaultGameMode(defaultGameMode: GameMode);
  /**
   * Gets a {@link ConsoleCommandSender} that may be used as an input source
   * for this server.
   *
   * @return a console command sender
  */
  getConsoleSender(): ConsoleCommandSender;
  /**
   * Creates a special {@link CommandSender} which redirects command feedback (in the form of chat messages) to the
   * specified listener. The returned sender will have the same effective permissions as {@link #getConsoleSender()}.
   *
   * @param feedback feedback listener
   * @return a command sender
  */
  createCommandSender(feedback: Consumer<any>): CommandSender;
  /**
   * Gets the folder that contains all of the various {@link World}s.
   *
   * @return folder that contains all worlds
  */
  getWorldContainer(): File;
  /**
   * Gets every player that has ever played on this server.
   * 
   * This method can be expensive as it loads all the player data files from the disk.
   *
   * @return an array containing all previous players
  */
  getOfflinePlayers(): OfflinePlayer[];
  /**
   * Gets the {@link Messenger} responsible for this server.
   *
   * @return messenger responsible for this server
  */
  getMessenger(): Messenger;
  /**
   * Gets the {@link HelpMap} providing help topics for this server.
   *
   * @return a help map for this server
  */
  getHelpMap(): HelpMap;
  /**
   * Creates an empty inventory with the specified type. If the type
   * is {@link InventoryType#CHEST}, the new inventory has a size of 27;
   * otherwise the new inventory has the normal size for its type.
   * 
   * {@link InventoryType#WORKBENCH} will not process crafting recipes if
   * created with this method. Use
   * {@link Player#openWorkbench(Location, boolean)} instead.
   * 
   * {@link InventoryType#ENCHANTING} will not process {@link ItemStack}s
   * for possible enchanting results. Use
   * {@link Player#openEnchanting(Location, boolean)} instead.
   *
   * @param owner the holder of the inventory, or null to indicate no holder
   * @param type the type of inventory to create
   * @return a new inventory
   * @throws IllegalArgumentException if the {@link InventoryType} cannot be
   * viewed.
   *
   * @see InventoryType#isCreatable()
  */
  createInventory(owner: InventoryHolder | null, type: InventoryType): Inventory;
  /**
   * Creates an empty inventory with the specified type and title. If the type
   * is {@link InventoryType#CHEST}, the new inventory has a size of 27;
   * otherwise the new inventory has the normal size for its type.
   * It should be noted that some inventory types do not support titles and
   * may not render with said titles on the Minecraft client.
   * 
   * {@link InventoryType#WORKBENCH} will not process crafting recipes if
   * created with this method. Use
   * {@link Player#openWorkbench(Location, boolean)} instead.
   * 
   * {@link InventoryType#ENCHANTING} will not process {@link ItemStack}s
   * for possible enchanting results. Use
   * {@link Player#openEnchanting(Location, boolean)} instead.
   *
   * @param owner The holder of the inventory; can be null if there's no holder.
   * @param type The type of inventory to create.
   * @param title The title of the inventory, to be displayed when it is viewed.
   * @return The new inventory.
   * @throws IllegalArgumentException if the {@link InventoryType} cannot be
   * viewed.
   *
   * @see InventoryType#isCreatable()
  */
  createInventory(owner: InventoryHolder | null, type: InventoryType, title: Component): Inventory;
  /**
   * Creates an empty inventory with the specified type and title. If the type
   * is {@link InventoryType#CHEST}, the new inventory has a size of 27;
   * otherwise the new inventory has the normal size for its type.
   * It should be noted that some inventory types do not support titles and
   * may not render with said titles on the Minecraft client.
   * 
   * {@link InventoryType#WORKBENCH} will not process crafting recipes if
   * created with this method. Use
   * {@link Player#openWorkbench(Location, boolean)} instead.
   * 
   * {@link InventoryType#ENCHANTING} will not process {@link ItemStack}s
   * for possible enchanting results. Use
   * {@link Player#openEnchanting(Location, boolean)} instead.
   *
   * @param owner The holder of the inventory; can be null if there's no holder.
   * @param type The type of inventory to create.
   * @param title The title of the inventory, to be displayed when it is viewed.
   * @return The new inventory.
   * @throws IllegalArgumentException if the {@link InventoryType} cannot be
   * viewed.
   * @deprecated in favour of {@link #createInventory(InventoryHolder, InventoryType, net.kyori.adventure.text.Component)}
   *
   * @see InventoryType#isCreatable()
  */
  createInventory(owner: InventoryHolder | null, type: InventoryType, title: string): Inventory;
  /**
   * Creates an empty inventory of type {@link InventoryType#CHEST} with the
   * specified size.
   *
   * @param owner the holder of the inventory, or null to indicate no holder
   * @param size a multiple of 9 as the size of inventory to create
   * @return a new inventory
   * @throws IllegalArgumentException if the size is not a multiple of 9
  */
  createInventory(owner: InventoryHolder | null, size: number): Inventory;
  /**
   * Creates an empty inventory of type {@link InventoryType#CHEST} with the
   * specified size and title.
   *
   * @param owner the holder of the inventory, or null to indicate no holder
   * @param size a multiple of 9 as the size of inventory to create
   * @param title the title of the inventory, displayed when inventory is
   *     viewed
   * @return a new inventory
   * @throws IllegalArgumentException if the size is not a multiple of 9
  */
  createInventory(owner: InventoryHolder | null, size: number, title: Component): Inventory;
  /**
   * Creates an empty inventory of type {@link InventoryType#CHEST} with the
   * specified size and title.
   *
   * @param owner the holder of the inventory, or null to indicate no holder
   * @param size a multiple of 9 as the size of inventory to create
   * @param title the title of the inventory, displayed when inventory is
   *     viewed
   * @return a new inventory
   * @throws IllegalArgumentException if the size is not a multiple of 9
   * @deprecated in favour of {@link #createInventory(InventoryHolder, int, net.kyori.adventure.text.Component)}
  */
  createInventory(owner: InventoryHolder | null, size: number, title: string): Inventory;
  /**
   * Creates an empty merchant.
   *
   * @param title the title of the corresponding merchant inventory, displayed
   * when the merchant inventory is viewed
   * @return a new merchant
  */
  createMerchant(title: Component | null): Merchant;
  /**
   * Creates an empty merchant.
   *
   * @param title the title of the corresponding merchant inventory, displayed
   * when the merchant inventory is viewed
   * @return a new merchant
   * @deprecated in favour of {@link #createMerchant(net.kyori.adventure.text.Component)}
  */
  createMerchant(title: string | null): Merchant;
  /**
   * Gets user-specified limit for number of monsters that can spawn in a
   * chunk.
   *
   * @return the monster spawn limit
   * @deprecated Deprecated in favor of {@link #getSpawnLimit(SpawnCategory)}
  */
  getMonsterSpawnLimit(): number;
  /**
   * Gets user-specified limit for number of animals that can spawn in a
   * chunk.
   *
   * @return the animal spawn limit
   * @deprecated Deprecated in favor of {@link #getSpawnLimit(SpawnCategory)}
  */
  getAnimalSpawnLimit(): number;
  /**
   * Gets user-specified limit for number of water animals that can spawn in
   * a chunk.
   *
   * @return the water animal spawn limit
   * @deprecated Deprecated in favor of {@link #getSpawnLimit(SpawnCategory)}
  */
  getWaterAnimalSpawnLimit(): number;
  /**
   * Gets user-specified limit for number of water ambient mobs that can spawn
   * in a chunk.
   *
   * @return the water ambient spawn limit
   * @deprecated Deprecated in favor of {@link #getSpawnLimit(SpawnCategory)}
  */
  getWaterAmbientSpawnLimit(): number;
  /**
   * Get user-specified limit for number of water creature underground that can spawn
   * in a chunk.
   * @return the water underground creature limit
   * @deprecated Deprecated in favor of {@link #getSpawnLimit(SpawnCategory)}
  */
  getWaterUndergroundCreatureSpawnLimit(): number;
  /**
   * Gets user-specified limit for number of ambient mobs that can spawn in
   * a chunk.
   *
   * @return the ambient spawn limit
   * @deprecated Deprecated in favor of {@link #getSpawnLimit(SpawnCategory)}
  */
  getAmbientSpawnLimit(): number;
  /**
   * Gets user-specified limit for number of {@link SpawnCategory} mobs that can spawn in
   * a chunk.
   *
   * Note: the {@link SpawnCategory#MISC} are not consider.
   *
   * @param spawnCategory the category spawn
   * @return the {@link SpawnCategory} spawn limit
  */
  getSpawnLimit(spawnCategory: SpawnCategory): number;
  /**
   * Checks the current thread against the expected primary thread for the
   * server.
   * 
   * Note: this method should not be used to indicate the current
   * synchronized state of the runtime. A current thread matching the main
   * thread indicates that it is synchronized, but a mismatch does not
   * preclude the same assumption.
   *
   * @return true if the current thread matches the expected primary thread,
   *     false otherwise
  */
  isPrimaryThread(): boolean;
  /**
   * Gets the message that is displayed on the server list.
   *
   * @return the server's MOTD
  */
  motd(): Component;
  /**
   * Gets the default message that is displayed when the server is stopped.
   *
   * @return the shutdown message
  */
  shutdownMessage(): Component | null;
  /**
   * Gets the current warning state for the server.
   *
   * @return the configured warning state
  */
  getWarningState(): WarningState;
  /**
   * Gets the instance of the item factory (for {@link ItemMeta}).
   *
   * @return the item factory
   * @see ItemFactory
  */
  getItemFactory(): ItemFactory;
  /**
   * Gets the instance of the scoreboard manager.
   * 
   * This will only exist after the first world has loaded.
   *
   * @return the scoreboard manager or null if no worlds are loaded.
  */
  getScoreboardManager(): ScoreboardManager;
  /**
   * Gets an instance of the server's default server-icon.
   *
   * @return the default server-icon; null values may be used by the
   *     implementation to indicate no defined icon, but this behavior is
   *     not guaranteed
  */
  getServerIcon(): CachedServerIcon | null;
  /**
   * Loads an image from a file, and returns a cached image for the specific
   * server-icon.
   * 
   * Size and type are implementation defined. An incompatible file is
   * guaranteed to throw an implementation-defined {@link Exception}.
   *
   * @param file the file to load the from
   * @return a cached server-icon that can be used for a {@link
   *     ServerListPingEvent#setServerIcon(CachedServerIcon)}
   * @throws IllegalArgumentException if image is null
   * @throws Exception if the image does not meet current server server-icon
   *     specifications
  */
  loadServerIcon(file: File): CachedServerIcon;
  /**
   * Creates a cached server-icon for the specific image.
   * 
   * Size and type are implementation defined. An incompatible file is
   * guaranteed to throw an implementation-defined {@link Exception}.
   *
   * @param image the image to use
   * @return a cached server-icon that can be used for a {@link
   *     ServerListPingEvent#setServerIcon(CachedServerIcon)}
   * @throws IllegalArgumentException if image is null
   * @throws Exception if the image does not meet current server
   *     server-icon specifications
  */
  loadServerIcon(image: BufferedImage): CachedServerIcon;
  /**
   * Set the idle kick timeout. Any players idle for the specified amount of
   * time will be automatically kicked.
   * 
   * A value of 0 will disable the idle kick timeout.
   *
   * @param threshold the idle timeout in minutes
  */
  setIdleTimeout(idleTimeout: number);
  /**
   * Gets the idle kick timeout.
   *
   * @return the idle timeout in minutes
  */
  getIdleTimeout(): number;
  /**
   * Create a ChunkData for use in a generator.
   *
   * See {@link ChunkGenerator#generateChunkData(org.bukkit.World, java.util.Random, int, int, org.bukkit.generator.ChunkGenerator.BiomeGrid)}
   *
   * @param world the world to create the ChunkData for
   * @return a new ChunkData for the world
   *
  */
  createChunkData(world: World): ChunkData;
  /**
   * Create a ChunkData for use in a generator, that is populated by the vanilla generator for that world.
   *
   * @param world the world to create the ChunkData for
   * @param x the x coordinate of the chunk
   * @param z the z coordinate of the chunk
   * @return a new ChunkData for the world
   * @deprecated The new multi-stage worldgen API allows a similar effect by overriding all of the "shouldGenerate..." methods to
   * return true, and then modifying the chunkdata in a later stage such as surface or bedrock generation.
  */
  createVanillaChunkData(world: World, x: number, z: number): ChunkData;
  /**
   * Creates a boss bar instance to display to players. The progress
   * defaults to 1.0
   *
   * @param title the title of the boss bar
   * @param color the color of the boss bar
   * @param style the style of the boss bar
   * @param flags an optional list of flags to set on the boss bar
   * @return the created boss bar
  */
  createBossBar(title: string | null, color: BarColor, style: BarStyle, ...flags: BarFlag[]): BossBar;
  /**
   * Creates a boss bar instance to display to players. The progress defaults
   * to 1.0.
   * 
   * This instance is added to the persistent storage of the server and will
   * be editable by commands and restored after restart.
   *
   * @param key the key of the boss bar that is used to access the boss bar
   * @param title the title of the boss bar
   * @param color the color of the boss bar
   * @param style the style of the boss bar
   * @param flags an optional list of flags to set on the boss bar
   * @return the created boss bar
  */
  createBossBar(key: NamespacedKey, title: string | null, color: BarColor, style: BarStyle, ...flags: BarFlag[]): KeyedBossBar;
  /**
   * Gets an unmodifiable iterator through all persistent bossbars.
   * 
   *   not bound to a {@link org.bukkit.entity.Boss}
   *   
   *     not created using
   *     {@link #createBossBar(String, BarColor, BarStyle, BarFlag...)}
   *   
   * 
   *
   * e.g. bossbars created using the bossbar command
   *
   * @return a bossbar iterator
  */
  getBossBars(): Iterator<KeyedBossBar>;
  /**
   * Gets the {@link KeyedBossBar} specified by this key.
   * 
   *   not bound to a {@link org.bukkit.entity.Boss}
   *   
   *     not created using
   *     {@link #createBossBar(String, BarColor, BarStyle, BarFlag...)}
   *   
   * 
   *
   * e.g. bossbars created using the bossbar command
   *
   * @param key unique bossbar key
   * @return bossbar or null if not exists
  */
  getBossBar(key: NamespacedKey): KeyedBossBar | null;
  /**
   * Removes a {@link KeyedBossBar} specified by this key.
   * 
   *   not bound to a {@link org.bukkit.entity.Boss}
   *   
   *     not created using
   *     {@link #createBossBar(String, BarColor, BarStyle, BarFlag...)}
   *   
   * 
   *
   * e.g. bossbars created using the bossbar command
   *
   * @param key unique bossbar key
   * @return true if removal succeeded or false
  */
  removeBossBar(key: NamespacedKey): boolean;
  /**
   * Gets an entity on the server by its UUID
   *
   * @param uuid the UUID of the entity
   * @return the entity with the given UUID, or null if it isn't found
  */
  getEntity(uuid: UUID): Entity | null;
  /**
   * Gets the current server TPS
   *
   * @return current server TPS (1m, 5m, 15m in Paper-Server)
  */
  getTPS(): number[];
  /**
   * Get a sample of the servers last tick times (in nanos)
   *
   * @return A sample of the servers last tick times (in nanos)
  */
  getTickTimes(): number[];
  /**
   * Get the average tick time (in millis)
   *
   * @return Average tick time (in millis)
  */
  getAverageTickTime(): number;
  /**
   * Gets the active {@link org.bukkit.command.CommandMap}
   *
   * @return the active command map
  */
  getCommandMap(): CommandMap;
  /**
   * Get the advancement specified by this key.
   *
   * @param key unique advancement key
   * @return advancement or null if not exists
  */
  getAdvancement(key: NamespacedKey): Advancement | null;
  /**
   * Get an iterator through all advancements. Advancements cannot be removed
   * from this iterator,
   *
   * @return an advancement iterator
  */
  advancementIterator(): Iterator<Advancement>;
  /**
   * Creates a new {@link BlockData} instance for the specified Material, with
   * all properties initialized to unspecified defaults.
   *
   * @param material the material
   * @return new data instance
  */
  createBlockData(material: Material): BlockData;
  /**
   * Creates a new {@link BlockData} instance for the specified Material, with
   * all properties initialized to unspecified defaults.
   *
   * @param material the material
   * @param consumer consumer to run on new instance before returning
   * @return new data instance
  */
  createBlockData(material: Material, consumer: Consumer<BlockData> | null): BlockData;
  /**
   * Creates a new {@link BlockData} instance with material and properties
   * parsed from provided data.
   *
   * @param data data string
   * @return new data instance
   * @throws IllegalArgumentException if the specified data is not valid
  */
  createBlockData(data: string): BlockData;
  /**
   * Creates a new {@link BlockData} instance for the specified Material, with
   * all properties initialized to unspecified defaults, except for those
   * provided in data.
   * 
   * If material is specified, then the data string must not also
   * contain the material.
   *
   * @param material the material
   * @param data data string
   * @return new data instance
   * @throws IllegalArgumentException if the specified data is not valid
  */
  createBlockData(material: Material | null, data: string | null): BlockData;
  /**
   * Gets a tag which has already been defined within the server. Plugins are
   * suggested to use the concrete tags in {@link Tag} rather than this method
   * which makes no guarantees about which tags are available, and may also be
   * less performant due to lack of caching.
   * 
   * Tags will be searched for in an implementation specific manner, but a
   * path consisting of namespace/tags/registry/key is expected.
   * 
   * Server implementations are allowed to handle only the registries
   * indicated in {@link Tag}.
   *
   * @param  type of the tag
   * @param registry the tag registry to look at
   * @param tag the name of the tag
   * @param clazz the class of the tag entries
   * @return the tag or null
  */
  getTag<T>(registry: string, tag: NamespacedKey, clazz: Class<T>): Tag<T> | null;
  /**
   * Gets a all tags which have been defined within the server.
   * 
   * Server implementations are allowed to handle only the registries
   * indicated in {@link Tag}.
   * 
   * No guarantees are made about the mutability of the returned iterator.
   *
   * @param  type of the tag
   * @param registry the tag registry to look at
   * @param clazz the class of the tag entries
   * @return all defined tags
  */
  getTags<T>(registry: string, clazz: Class<T>): Iterable<Tag<T>>;
  /**
   * Gets the specified {@link LootTable}.
   *
   * @param key the name of the LootTable
   * @return the LootTable, or null if no LootTable is found with that name
  */
  getLootTable(key: NamespacedKey): LootTable | null;
  /**
   * Selects entities using the given Vanilla selector.
   * 
   * No guarantees are made about the selector format, other than they match
   * the Vanilla format for the active Minecraft version.
   * 
   * Usually a selector will start with '@', unless selecting a Player in
   * which case it may simply be the Player's name or UUID.
   * 
   * Note that in Vanilla, elevated permissions are usually required to use
   * '@' selectors, but this method should not check such permissions from the
   * sender.
   *
   * @param sender the sender to execute as, must be provided
   * @param selector the selection string
   * @return a list of the selected entities. The list will not be null, but
   * no further guarantees are made.
   * @throws IllegalArgumentException if the selector is malformed in any way
   * or a parameter is null
  */
  selectEntities(sender: CommandSender, selector: string): Entity[];
  /**
   * Gets the structure manager for loading and saving structures.
   *
   * @return the structure manager
  */
  getStructureManager(): StructureManager;
  /**
   * @return the unsafe values instance
   * @see UnsafeValues
  */
  getUnsafe(): UnsafeValues;
  spigot(): Spigot;
  reloadPermissions(): void;
  reloadCommandAliases(): boolean;
  /**
   * Checks if player names should be suggested when a command returns `null` as
   * their tab completion result.
   *
   * @return true if player names should be suggested
  */
  suggestPlayerNamesWhenNullTabCompletions(): boolean;
  /**
   *
   * @return the default no permission message used on the server
  */
  getPermissionMessage(): string;
  /**
   * Creates a PlayerProfile for the specified uuid, with name as null.
   *
   * If a player with the passed uuid exists on the server at the time of creation, the returned player profile will
   * be populated with the properties of said player (including their uuid and name).
   *
   * @param uuid UUID to create profile for
   * @return A PlayerProfile object
  */
  createProfile(uuid: UUID): com_destroystokyo_paper_profile_PlayerProfile;
  /**
   * Creates a PlayerProfile for the specified name, with UUID as null.
   *
   * If a player with the passed name exists on the server at the time of creation, the returned player profile will
   * be populated with the properties of said player (including their uuid and name).
   * 
   * E.g. if the player 'jeb_' is currently playing on the server, calling `createProfile("JEB_")` will
   * yield a profile with the name 'jeb_', their uuid and their textures.
   * To bypass this pre-population on a case-insensitive name match, see {@link #createProfileExact(UUID, String)}.
   * 
   *
   * @param name Name to create profile for
   * @return A PlayerProfile object
  */
  createProfile(name: string): com_destroystokyo_paper_profile_PlayerProfile;
  /**
   * Creates a PlayerProfile for the specified name/uuid
   *
   * Both UUID and Name can not be null at same time. One must be supplied.
   * If a player with the passed uuid or name exists on the server at the time of creation, the returned player
   * profile will be populated with the properties of said player (including their uuid and name).
   * 
   * E.g. if the player 'jeb_' is currently playing on the server, calling `createProfile(null, "JEB_")` will
   * yield a profile with the name 'jeb_', their uuid and their textures.
   * To bypass this pre-population on an case-insensitive name match, see {@link #createProfileExact(UUID, String)}.
   * 
   *
   * The name comparison will compare the {@link String#toLowerCase()} version of both the passed name parameter and
   * a players name to honour the case-insensitive nature of a mojang profile lookup.
   *
   * @param uuid UUID to create profile for
   * @param name Name to create profile for
   * @return A PlayerProfile object
  */
  createProfile(uuid: UUID | null, name: string | null): com_destroystokyo_paper_profile_PlayerProfile;
  /**
   * Creates an exact PlayerProfile for the specified name/uuid
   *
   * Both UUID and Name can not be null at same time. One must be supplied.
   * If a player with the passed uuid or name exists on the server at the time of creation, the returned player
   * profile will be populated with the properties of said player.
   * 
   * Compared to {@link #createProfile(UUID, String)}, this method will never mutate the passed uuid or name.
   * If a player with either the same uuid or a matching name (case-insensitive) is found on the server, their
   * properties, such as textures, will be pre-populated in the profile, however the passed uuid and name stay intact.
   *
   * @param uuid UUID to create profile for
   * @param name Name to create profile for
   * @return A PlayerProfile object
  */
  createProfileExact(uuid: UUID | null, name: string | null): com_destroystokyo_paper_profile_PlayerProfile;
  /**
   * Get the current internal server tick
   *
   * @return Current tick
  */
  getCurrentTick(): number;
  /**
   * Checks if the server is in the process of being shutdown.
   *
   * @return true if server is in the process of being shutdown
  */
  isStopping(): boolean;
  /**
   * Returns the {@link com.destroystokyo.paper.entity.ai.MobGoals} manager
   *
   * @return the mob goals manager
  */
  getMobGoals(): MobGoals;
  /**
   * @return the datapack manager
  */
  getDatapackManager(): DatapackManager;
  /**
   * Gets the potion brewer.
   *
   * @return the potion brewer
  */
  getPotionBrewer(): PotionBrewer;
}
export interface Server extends PluginMessageRecipient, ForwardingAudience {}
/**
 * Represents a raid event.
*/
export class Raid {
  /**
   * Get whether this raid started.
   *
   * @return whether raid is started
  */
  isStarted(): boolean;
  /**
   * Gets the amount of ticks this raid has existed.
   *
   * @return active ticks
  */
  getActiveTicks(): number;
  /**
   * Gets the Bad Omen level of this raid.
   *
   * @return Bad Omen level (between 0 and 5)
  */
  getBadOmenLevel(): number;
  /**
   * Sets the Bad Omen level.
   * 
   * If the level is higher than 1, there will be an additional wave that as
   * strong as the final wave.
   *
   * @param badOmenLevel new Bad Omen level (from 0-5)
   * @throws IllegalArgumentException if invalid Bad Omen level
  */
  setBadOmenLevel(badOmenLevel: number);
  /**
   * Gets the center location where the raid occurs.
   *
   * @return location
  */
  getLocation(): Location;
  /**
   * Gets the current status of the raid.
   * 
   * Do not use this method to check if the raid has been started, call
   * {@link #isStarted()} instead.
   *
   * @return Raids status
  */
  getStatus(): RaidStatus;
  /**
   * Gets the number of raider groups which have spawned.
   *
   * @return total spawned groups
  */
  getSpawnedGroups(): number;
  /**
   * Gets the number of raider groups which would spawn.
   * 
   * This also includes the group which spawns in the additional wave (if
   * present).
   *
   * @return total groups
  */
  getTotalGroups(): number;
  /**
   * Gets the number of waves in this raid (exclude the additional wave).
   *
   * @return number of waves
  */
  getTotalWaves(): number;
  /**
   * Gets the sum of all raider's health.
   *
   * @return total raiders health
  */
  getTotalHealth(): number;
  /**
   * Get the UUID of all heroes in this raid.
   *
   * @return a set of unique ids
  */
  getHeroes(): Set<UUID>;
  /**
   * Gets all remaining {@link Raider} in the present wave.
   *
   * @return a list of current raiders
  */
  getRaiders(): Raider[];
}
export class Nameable {
  /**
   * Gets the custom name.
   *
   * This value has no effect on players, they will always use their real name.
   *
   * @return the custom name
  */
  customName(): Component | null;
  /**
   * Sets the custom name.
   *
   * This name will be used in death messages and can be sent to the client as a nameplate over the mob.
   *
   * Setting the name to `null` will clear it.
   *
   * This value has no effect on players, they will always use their real name.
   *
   * @param customName the custom name to set
  */
  customName(customName: Component | null): void;
  /**
   * Sets a custom name on a mob or block. This name will be used in death
   * messages and can be sent to the client as a nameplate over the mob.
   * 
   * Setting the name to null or an empty string will clear it.
   * 
   * This value has no effect on players, they will always use their real
   * name.
   *
   * @deprecated in favour of {@link #customName(net.kyori.adventure.text.Component)}
   * @param name the name to set
  */
  setCustomName(customName: string | null): void;
}
/**
 * Represents a String based key which consists of two components - a namespace
 * and a key.
 *
 * Namespaces may only contain lowercase alphanumeric characters, periods,
 * underscores, and hyphens.
 * 
 * Keys may only contain lowercase alphanumeric characters, periods,
 * underscores, hyphens, and forward slashes.
 *
*/
export class NamespacedKey extends Key {
  /**
   * The namespace representing all inbuilt keys.
  */
  static readonly MINECRAFT: string;
  /**
   * The namespace representing all keys generated by Bukkit for backwards
   * compatibility measures.
  */
  static readonly BUKKIT: string;
  /**
   * Create a key in a specific namespace.
   * 
   * For most plugin related code, you should prefer using the
   * {@link NamespacedKey#NamespacedKey(Plugin, String)} constructor.
   *
   * @param namespace namespace
   * @param key key
   * @see #NamespacedKey(Plugin, String)
  */
  constructor(namespace: string, key: string);
  /**
   * Create a key in the plugin's namespace.
   * 
   * Namespaces may only contain lowercase alphanumeric characters, periods,
   * underscores, and hyphens.
   * 
   * Keys may only contain lowercase alphanumeric characters, periods,
   * underscores, hyphens, and forward slashes.
   *
   * @param plugin the plugin to use for the namespace
   * @param key the key to create
  */
  constructor(plugin: Plugin, key: string);
  /**
   * Gets the namespace this resource is a part of
   * 
   * This is contractually obligated to only contain lowercase alphanumeric characters,
   * periods, underscores, and hyphens.
   *
   * @return resource namespace
  */
  getNamespace(): string;
  /**
   * Gets the key corresponding to this resource
   * 
   * This is contractually obligated to only contain lowercase alphanumeric characters,
   * periods, underscores, hyphens, and forward slashes.
   *
   * @return resource key
  */
  getKey(): string;
  hashCode(): number;
  equals(obj: any): boolean;
  toString(): string;
  /**
   * Return a new random key in the {@link #BUKKIT} namespace.
   *
   * @return new key
   * @deprecated should never be used by plugins, for internal use only!!
  */
  static randomKey(): NamespacedKey;
  /**
   * Get a key in the Minecraft namespace.
   *
   * @param key the key to use
   * @return new key in the Minecraft namespace
  */
  static minecraft(key: string): NamespacedKey;
  /**
   * Get a NamespacedKey from the supplied string with a default namespace if
   * a namespace is not defined. This is a utility method meant to fetch a
   * NamespacedKey from user input. Please note that casing does matter and
   * any instance of uppercase characters will be considered invalid. The
   * input contract is as follows:
   *      * fromString("foo", plugin) -{@literal >} "plugin:foo"
   * fromString("foo:bar", plugin) -{@literal >} "foo:bar"
   * fromString(":foo", null) -{@literal >} "minecraft:foo"
   * fromString("foo", null) -{@literal >} "minecraft:foo"
   * fromString("Foo", plugin) -{@literal >} null
   * fromString(":Foo", plugin) -{@literal >} null
   * fromString("foo:bar:bazz", plugin) -{@literal >} null
   * fromString("", plugin) -{@literal >} null
   * 
   *
   * @param string the string to convert to a NamespacedKey
   * @param defaultNamespace the default namespace to use if none was
   * supplied. If null, the `minecraft` namespace
   * ({@link #minecraft(String)}) will be used
   * @return the created NamespacedKey. null if invalid key
   * @see #fromString(String)
  */
  static fromString(string: string, defaultNamespace: Plugin | null): NamespacedKey | null;
  /**
   * Get a NamespacedKey from the supplied string.
   *
   * The default namespace will be Minecraft's (i.e.
   * {@link #minecraft(String)}).
   *
   * @param key the key to convert to a NamespacedKey
   * @return the created NamespacedKey. null if invalid
   * @see #fromString(String, Plugin)
  */
  static fromString(key: string): NamespacedKey | null;
  /**
   * Gets the value.
   *
   * @return the value
   * @since 4.0.0
  */
  value(): string;
  /**
   * Returns the string representation of this key.
   *
   * @return the string representation
   * @since 4.0.0
  */
  asString(): string;
  /**
   * Creates a key.
   *
   * This will parse `string` as a key, using `:` as a separator between the namespace and the value.
   *
   * The namespace is optional. If you do not provide one (for example, if you provide just `player` or `:player`
   * as the string) then {@link #MINECRAFT_NAMESPACE} will be used as a namespace and `string` will be used as the value,
   * removing the colon if necessary.
   *
   * @param string the string
   * @return the key
   * @throws InvalidKeyException if the namespace or value contains an invalid character
   * @since 4.0.0
  */
  static key(string: string): Key;
  /**
   * Creates a key.
   *
   * This will parse `string` as a key, using `character` as a separator between the namespace and the value.
   *
   * The namespace is optional. If you do not provide one (for example, if you provide `player` or `character + "player"`
   * as the string) then {@link #MINECRAFT_NAMESPACE} will be used as a namespace and `string` will be used as the value,
   * removing the provided separator character if necessary.
   *
   * @param string the string
   * @param character the character that separates the namespace from the value
   * @return the key
   * @throws InvalidKeyException if the namespace or value contains an invalid character
   * @since 4.0.0
  */
  static key(string: string, character: string): Key;
  /**
   * Creates a key.
   *
   * @param namespaced the namespace source
   * @param value the value
   * @return the key
   * @throws InvalidKeyException if the namespace or value contains an invalid character
   * @since 4.4.0
  */
  static key(namespaced: net_kyori_adventure_key_Namespaced, value: string): Key;
}
export interface NamespacedKey extends Key, Namespaced {}
/**
 * Represents the different types of skulls.
 * @deprecated check {@link Material} instead
*/
export class SkullType extends Enum<SkullType> {
  static readonly SKELETON: SkullType;
  static readonly WITHER: SkullType;
  static readonly ZOMBIE: SkullType;
  static readonly PLAYER: SkullType;
  static readonly CREEPER: SkullType;
  static readonly DRAGON: SkullType;
  static valueOf(name: string): SkullType;
  static values(): SkullType[];
}
export class OfflinePlayer extends ServerOperator {
  /**
   * Checks if this player is currently online
   *
   * @return true if they are online
  */
  isOnline(): boolean;
  /**
   * Returns the name of this player
   * 
   * Names are no longer unique past a single game session. For persistent storage
   * it is recommended that you use {@link #getUniqueId()} instead.
   *
   * @return Player name or null if we have not seen a name for this player yet
  */
  getName(): string | null;
  /**
   * Returns the UUID of this player
   *
   * @return Player UUID
  */
  getUniqueId(): UUID;
  /**
   * Gets a copy of the player's profile.
   * 
   * If the player is online, the returned profile will be complete.
   * Otherwise, only the unique id is guaranteed to be present. You can use
   * {@link PlayerProfile#update()} to complete the returned profile.
   *
   * @return the player's profile
  */
  getPlayerProfile(): PlayerProfile;
  /**
   * Checks if this player is banned or not
   *
   * @return true if banned, otherwise false
  */
  isBanned(): boolean;
  /**
   * Permanently Bans this player from the server
   *
   * @param reason Reason for Ban
   * @return Ban Entry
  */
  banPlayer(reason: string | null): BanEntry;
  /**
   * Permanently Bans this player from the server
   * @param reason Reason for Ban
   * @param source Source of the ban, or null for default
   * @return Ban Entry
  */
  banPlayer(reason: string | null, source: string | null): BanEntry;
  /**
   * Bans this player from the server
   * @param reason Reason for Ban
   * @param expires When to expire the ban
   * @return Ban Entry
  */
  banPlayer(reason: string | null, expires: Date | null): BanEntry;
  /**
   * Bans this player from the server
   * @param reason Reason for Ban
   * @param expires When to expire the ban
   * @param source Source of the ban or null for default
   * @return Ban Entry
  */
  banPlayer(reason: string | null, expires: Date | null, source: string | null): BanEntry;
  banPlayer(reason: string | null, expires: Date | null, source: string | null, kickIfOnline: boolean): BanEntry;
  /**
   * Checks if this player is whitelisted or not
   *
   * @return true if whitelisted
  */
  isWhitelisted(): boolean;
  /**
   * Sets if this player is whitelisted or not
   *
   * @param value true if whitelisted
  */
  setWhitelisted(value: boolean): void;
  /**
   * Gets a {@link Player} object that this represents, if there is one
   * 
   * If the player is online, this will return that player. Otherwise,
   * it will return null.
   *
   * @return Online player
  */
  getPlayer(): Player | null;
  /**
   * Gets the first date and time that this player was witnessed on this
   * server.
   * 
   * If the player has never played before, this will return 0. Otherwise,
   * it will be the amount of milliseconds since midnight, January 1, 1970
   * UTC.
   *
   * @return Date of first log-in for this player, or 0
  */
  getFirstPlayed(): number;
  /**
   * Gets the last date and time that this player was witnessed on this
   * server.
   * 
   * If the player has never played before, this will return 0. Otherwise,
   * it will be the amount of milliseconds since midnight, January 1, 1970
   * UTC.
   *
   * @return Date of last log-in for this player, or 0
   * @deprecated The API contract is ambiguous and the implementation may or may not return the correct value given this API ambiguity. It is instead recommended use {@link #getLastLogin()} or {@link #getLastSeen()} depending on your needs.
  */
  getLastPlayed(): number;
  /**
   * Checks if this player has played on this server before.
   *
   * @return True if the player has played before, otherwise false
  */
  hasPlayedBefore(): boolean;
  /**
   * Gets the Location where the player will spawn at their bed, null if
   * they have not slept in one or their current bed spawn is invalid.
   *
   * @return Bed Spawn Location if bed exists, otherwise null.
  */
  getBedSpawnLocation(): Location | null;
  /**
   * Gets the last date and time that this player logged into the server.
   * 
   * If the player has never played before, this will return 0. Otherwise,
   * it will be the amount of milliseconds since midnight, January 1, 1970
   * UTC.
   *
   * @return last login time
  */
  getLastLogin(): number;
  /**
   * Gets the last date and time that this player was seen on the server.
   * 
   * If the player has never played before, this will return 0. If the
   * player is currently online, this will return the current time.
   * Otherwise it will be the amount of milliseconds since midnight,
   * January 1, 1970 UTC.
   *
   * @return last seen time
  */
  getLastSeen(): number;
  /**
   * Increments the given statistic for this player.
   * 
   * This is equivalent to the following code:
   * incrementStatistic(Statistic, 1)
   *
   * @param statistic Statistic to increment
   * @throws IllegalArgumentException if statistic is null
   * @throws IllegalArgumentException if the statistic requires an
   *     additional parameter
  */
  incrementStatistic(statistic: Statistic): void;
  /**
   * Decrements the given statistic for this player.
   * 
   * This is equivalent to the following code:
   * decrementStatistic(Statistic, 1)
   *
   * @param statistic Statistic to decrement
   * @throws IllegalArgumentException if statistic is null
   * @throws IllegalArgumentException if the statistic requires an
   *     additional parameter
  */
  decrementStatistic(statistic: Statistic): void;
  /**
   * Increments the given statistic for this player.
   *
   * @param statistic Statistic to increment
   * @param amount Amount to increment this statistic by
   * @throws IllegalArgumentException if statistic is null
   * @throws IllegalArgumentException if amount is negative
   * @throws IllegalArgumentException if the statistic requires an
   *     additional parameter
  */
  incrementStatistic(statistic: Statistic, amount: number): void;
  /**
   * Decrements the given statistic for this player.
   *
   * @param statistic Statistic to decrement
   * @param amount Amount to decrement this statistic by
   * @throws IllegalArgumentException if statistic is null
   * @throws IllegalArgumentException if amount is negative
   * @throws IllegalArgumentException if the statistic requires an
   *     additional parameter
  */
  decrementStatistic(statistic: Statistic, amount: number): void;
  /**
   * Sets the given statistic for this player.
   *
   * @param statistic Statistic to set
   * @param newValue The value to set this statistic to
   * @throws IllegalArgumentException if statistic is null
   * @throws IllegalArgumentException if newValue is negative
   * @throws IllegalArgumentException if the statistic requires an
   *     additional parameter
  */
  setStatistic(statistic: Statistic, newValue: number): void;
  /**
   * Gets the value of the given statistic for this player.
   *
   * @param statistic Statistic to check
   * @return the value of the given statistic
   * @throws IllegalArgumentException if statistic is null
   * @throws IllegalArgumentException if the statistic requires an
   *     additional parameter
  */
  getStatistic(statistic: Statistic): number;
  /**
   * Increments the given statistic for this player for the given material.
   * 
   * This is equivalent to the following code:
   * incrementStatistic(Statistic, Material, 1)
   *
   * @param statistic Statistic to increment
   * @param material Material to offset the statistic with
   * @throws IllegalArgumentException if statistic is null
   * @throws IllegalArgumentException if material is null
   * @throws IllegalArgumentException if the given parameter is not valid
   *     for the statistic
  */
  incrementStatistic(statistic: Statistic, material: Material): void;
  /**
   * Decrements the given statistic for this player for the given material.
   * 
   * This is equivalent to the following code:
   * decrementStatistic(Statistic, Material, 1)
   *
   * @param statistic Statistic to decrement
   * @param material Material to offset the statistic with
   * @throws IllegalArgumentException if statistic is null
   * @throws IllegalArgumentException if material is null
   * @throws IllegalArgumentException if the given parameter is not valid
   *     for the statistic
  */
  decrementStatistic(statistic: Statistic, material: Material): void;
  /**
   * Gets the value of the given statistic for this player.
   *
   * @param statistic Statistic to check
   * @param material Material offset of the statistic
   * @return the value of the given statistic
   * @throws IllegalArgumentException if statistic is null
   * @throws IllegalArgumentException if material is null
   * @throws IllegalArgumentException if the given parameter is not valid
   *     for the statistic
  */
  getStatistic(statistic: Statistic, material: Material): number;
  /**
   * Increments the given statistic for this player for the given material.
   *
   * @param statistic Statistic to increment
   * @param material Material to offset the statistic with
   * @param amount Amount to increment this statistic by
   * @throws IllegalArgumentException if statistic is null
   * @throws IllegalArgumentException if material is null
   * @throws IllegalArgumentException if amount is negative
   * @throws IllegalArgumentException if the given parameter is not valid
   *     for the statistic
  */
  incrementStatistic(statistic: Statistic, material: Material, amount: number): void;
  /**
   * Decrements the given statistic for this player for the given material.
   *
   * @param statistic Statistic to decrement
   * @param material Material to offset the statistic with
   * @param amount Amount to decrement this statistic by
   * @throws IllegalArgumentException if statistic is null
   * @throws IllegalArgumentException if material is null
   * @throws IllegalArgumentException if amount is negative
   * @throws IllegalArgumentException if the given parameter is not valid
   *     for the statistic
  */
  decrementStatistic(statistic: Statistic, material: Material, amount: number): void;
  /**
   * Sets the given statistic for this player for the given material.
   *
   * @param statistic Statistic to set
   * @param material Material to offset the statistic with
   * @param newValue The value to set this statistic to
   * @throws IllegalArgumentException if statistic is null
   * @throws IllegalArgumentException if material is null
   * @throws IllegalArgumentException if newValue is negative
   * @throws IllegalArgumentException if the given parameter is not valid
   *     for the statistic
  */
  setStatistic(statistic: Statistic, material: Material, newValue: number): void;
  /**
   * Increments the given statistic for this player for the given entity.
   * 
   * This is equivalent to the following code:
   * incrementStatistic(Statistic, EntityType, 1)
   *
   * @param statistic Statistic to increment
   * @param entityType EntityType to offset the statistic with
   * @throws IllegalArgumentException if statistic is null
   * @throws IllegalArgumentException if entityType is null
   * @throws IllegalArgumentException if the given parameter is not valid
   *     for the statistic
  */
  incrementStatistic(statistic: Statistic, entityType: EntityType): void;
  /**
   * Decrements the given statistic for this player for the given entity.
   * 
   * This is equivalent to the following code:
   * decrementStatistic(Statistic, EntityType, 1)
   *
   * @param statistic Statistic to decrement
   * @param entityType EntityType to offset the statistic with
   * @throws IllegalArgumentException if statistic is null
   * @throws IllegalArgumentException if entityType is null
   * @throws IllegalArgumentException if the given parameter is not valid
   *     for the statistic
  */
  decrementStatistic(statistic: Statistic, entityType: EntityType): void;
  /**
   * Gets the value of the given statistic for this player.
   *
   * @param statistic Statistic to check
   * @param entityType EntityType offset of the statistic
   * @return the value of the given statistic
   * @throws IllegalArgumentException if statistic is null
   * @throws IllegalArgumentException if entityType is null
   * @throws IllegalArgumentException if the given parameter is not valid
   *     for the statistic
  */
  getStatistic(statistic: Statistic, entityType: EntityType): number;
  /**
   * Increments the given statistic for this player for the given entity.
   *
   * @param statistic Statistic to increment
   * @param entityType EntityType to offset the statistic with
   * @param amount Amount to increment this statistic by
   * @throws IllegalArgumentException if statistic is null
   * @throws IllegalArgumentException if entityType is null
   * @throws IllegalArgumentException if amount is negative
   * @throws IllegalArgumentException if the given parameter is not valid
   *     for the statistic
  */
  incrementStatistic(statistic: Statistic, entityType: EntityType, amount: number): void;
  /**
   * Decrements the given statistic for this player for the given entity.
   *
   * @param statistic Statistic to decrement
   * @param entityType EntityType to offset the statistic with
   * @param amount Amount to decrement this statistic by
   * @throws IllegalArgumentException if statistic is null
   * @throws IllegalArgumentException if entityType is null
   * @throws IllegalArgumentException if amount is negative
   * @throws IllegalArgumentException if the given parameter is not valid
   *     for the statistic
  */
  decrementStatistic(statistic: Statistic, entityType: EntityType, amount: number): void;
  /**
   * Sets the given statistic for this player for the given entity.
   *
   * @param statistic Statistic to set
   * @param entityType EntityType to offset the statistic with
   * @param newValue The value to set this statistic to
   * @throws IllegalArgumentException if statistic is null
   * @throws IllegalArgumentException if entityType is null
   * @throws IllegalArgumentException if newValue is negative
   * @throws IllegalArgumentException if the given parameter is not valid
   *     for the statistic
  */
  setStatistic(statistic: Statistic, entityType: EntityType, newValue: number): void;
}
export interface OfflinePlayer extends ServerOperator, AnimalTamer, ConfigurationSerializable {}
/**
 * Further information regarding heightmaps.
 *
 * @see Gamepedia Chunk
 * Format
*/
export class HeightMap extends Enum<HeightMap> {
  /**
   * The highest block that blocks motion or contains a fluid.
  */
  static readonly MOTION_BLOCKING: HeightMap;
  /**
   * The highest block that blocks motion or contains a fluid or is in the
   * {@link Tag#LEAVES}.
  */
  static readonly MOTION_BLOCKING_NO_LEAVES: HeightMap;
  /**
   * The highest non-air block, solid block.
  */
  static readonly OCEAN_FLOOR: HeightMap;
  /**
   * The highest block that is neither air nor contains a fluid, for worldgen.
  */
  static readonly OCEAN_FLOOR_WG: HeightMap;
  /**
   * The highest non-air block.
  */
  static readonly WORLD_SURFACE: HeightMap;
  /**
   * The highest non-air block, for worldgen.
  */
  static readonly WORLD_SURFACE_WG: HeightMap;
  static valueOf(name: string): HeightMap;
  static values(): HeightMap[];
}
/**
 * This interface provides value conversions that may be specific to a
 * runtime, or have arbitrary meaning (read: magic values).
 * 
 * Their existence and behavior is not guaranteed across future versions. They
 * may be poorly named, throw exceptions, have misleading parameters, or any
 * other bad programming practice.
*/
export class UnsafeValues {
  componentFlattener(): ComponentFlattener;
  plainComponentSerializer(): PlainComponentSerializer;
  plainTextSerializer(): PlainTextComponentSerializer;
  gsonComponentSerializer(): GsonComponentSerializer;
  colorDownsamplingGsonComponentSerializer(): GsonComponentSerializer;
  legacyComponentSerializer(): LegacyComponentSerializer;
  reportTimings(): void;
  toLegacy(material: Material): Material;
  fromLegacy(material: Material): Material;
  fromLegacy(material: MaterialData): Material;
  fromLegacy(material: MaterialData, itemPriority: boolean): Material;
  fromLegacy(material: Material, data: number): BlockData;
  getMaterial(material: string, version: number): Material;
  getDataVersion(): number;
  modifyItemStack(stack: ItemStack, arguments: string): ItemStack;
  checkSupported(pdf: PluginDescriptionFile): void;
  processClass(pdf: PluginDescriptionFile, path: string, clazz: number[]): number[];
  /**
   * Load an advancement represented by the specified string into the server.
   * The advancement format is governed by Minecraft and has no specified
   * layout.
   * 
   * It is currently a JSON object, as described by the Minecraft Wiki:
   * http://minecraft.gamepedia.com/Advancements
   * 
   * Loaded advancements will be stored and persisted across server restarts
   * and reloads.
   * 
   * Callers should be prepared for {@link Exception} to be thrown.
   *
   * @param key the unique advancement key
   * @param advancement representation of the advancement
   * @return the loaded advancement or null if an error occurred
  */
  loadAdvancement(key: NamespacedKey, advancement: string): Advancement;
  /**
   * Delete an advancement which was loaded and saved by
   * {@link #loadAdvancement(org.bukkit.NamespacedKey, java.lang.String)}.
   * 
   * This method will only remove advancement from persistent storage. It
   * should be accompanied by a call to {@link Server#reloadData()} in order
   * to fully remove it from the running instance.
   *
   * @param key the unique advancement key
   * @return true if a file matching this key was found and deleted
  */
  removeAdvancement(key: NamespacedKey): boolean;
  getDefaultAttributeModifiers(material: Material, slot: EquipmentSlot): Multimap<Attribute, AttributeModifier>;
  getCreativeCategory(material: Material): CreativeCategory;
  /**
   * Server name to report to timings v2
   * @return name
  */
  getTimingsServerName(): string;
  /**
   * Called once by the version command on first use, then cached.
  */
  getVersionFetcher(): VersionFetcher;
  isSupportedApiVersion(apiVersion: string): boolean;
  static isLegacyPlugin(plugin: Plugin): boolean;
  serializeItem(item: ItemStack): number[];
  deserializeItem(data: number[]): ItemStack;
  serializeEntity(entity: Entity): number[];
  deserializeEntity(data: number[], world: World): Entity;
  deserializeEntity(data: number[], world: World, preserveUUID: boolean): Entity;
  /**
   * Return the translation key for the Material, so the client can translate it into the active
   * locale when using a {@link net.kyori.adventure.text.TranslatableComponent}.
   * @return the translation key
  */
  getTranslationKey(mat: Material): string;
  /**
   * Return the translation key for the Block, so the client can translate it into the active
   * locale when using a {@link net.kyori.adventure.text.TranslatableComponent}.
   * @return the translation key
  */
  getTranslationKey(block: Block): string;
  /**
   * Return the translation key for the EntityType, so the client can translate it into the active
   * locale when using a {@link net.kyori.adventure.text.TranslatableComponent}.
   * This is null, when the EntityType isn't known to NMS (custom entities)
   * @return the translation key
  */
  getTranslationKey(type: EntityType): string;
  /**
   * Return the translation key for the ItemStack, so the client can translate it into the active
   * locale when using a {@link net.kyori.adventure.text.TranslatableComponent}.
   * @return the translation key
  */
  getTranslationKey(itemStack: ItemStack): string;
  /**
   * Creates and returns the next EntityId available.
   * 
   * Use this when sending custom packets, so that there are no collisions on the client or server.
  */
  nextEntityId(): number;
  /**
   * Gets the server-backed registry for a type.
   *
   * @param classOfT type
   * @param  type
   * @return the server-backed registry
   * @throws IllegalArgumentException if there isn't a registry for that type
  */
  registryFor<T>(classOfT: Class<T>): Registry<T>;
  /**
   * Just don't use it.
  */
  getMainLevelName(): string;
  /**
   * Gets the item rarity of a material. The material MUST be an item.
   * Use {@link Material#isItem()} before this.
   *
   * @param material the material to get the rarity of
   * @return the item rarity
  */
  getItemRarity(material: Material): ItemRarity;
  /**
   * Gets the item rarity of the itemstack. The rarity can change based on enchantements.
   *
   * @param itemStack the itemstack to get the rarity of
   * @return the itemstack rarity
  */
  getItemStackRarity(itemStack: ItemStack): ItemRarity;
  /**
   * Checks if an itemstack can be repaired with another itemstack.
   * Returns false if either argument's type is not an item ({@link Material#isItem()}).
   *
   * @param itemToBeRepaired the itemstack to be repaired
   * @param repairMaterial the repair material
   * @return true if valid repair, false if not
  */
  isValidRepairItemStack(itemToBeRepaired: ItemStack, repairMaterial: ItemStack): boolean;
  /**
   * Returns an immutable multimap of attributes for the material and slot.
   * {@link Material#isItem()} must be true for this material.
   *
   * @param material the material
   * @param equipmentSlot the slot to get the attributes for
   * @throws IllegalArgumentException if {@link Material#isItem()} is false
   * @return an immutable multimap of attributes
  */
  getItemAttributes(material: Material, equipmentSlot: EquipmentSlot): Multimap<Attribute, AttributeModifier>;
  /**
   * Returns the server's protocol version.
   *
   * @return the server's protocol version
  */
  getProtocolVersion(): number;
  /**
   * Checks if the entity represented by the namespaced key has default attributes.
   *
   * @param entityKey the entity's key
   * @return true if it has default attributes
  */
  hasDefaultEntityAttributes(entityKey: NamespacedKey): boolean;
  /**
   * Gets the default attributes for the entity represented by the namespaced key.
   *
   * @param entityKey the entity's key
   * @return an unmodifiable instance of Attributable for reading default attributes.
   * @throws IllegalArgumentException if the entity does not exist of have default attributes (use {@link #hasDefaultEntityAttributes(NamespacedKey)} first)
  */
  getDefaultEntityAttributes(entityKey: NamespacedKey): Attributable;
  /**
   * Checks if this material is collidable.
   *
   * @param material the material to check
   * @return true if collidable
   * @throws IllegalArgumentException if {@link Material#isBlock()} is false
  */
  isCollidable(material: Material): boolean;
}
export class Instrument extends Enum<Instrument> {
  /**
   * Piano is the standard instrument for a note block.
  */
  static readonly PIANO: Instrument;
  /**
   * Bass drum is normally played when a note block is on top of a
   * stone-like block.
  */
  static readonly BASS_DRUM: Instrument;
  /**
   * Snare drum is normally played when a note block is on top of a sandy
   * block.
  */
  static readonly SNARE_DRUM: Instrument;
  /**
   * Sticks are normally played when a note block is on top of a glass
   * block.
  */
  static readonly STICKS: Instrument;
  /**
   * Bass guitar is normally played when a note block is on top of a wooden
   * block.
  */
  static readonly BASS_GUITAR: Instrument;
  /**
   * Flute is normally played when a note block is on top of a clay block.
  */
  static readonly FLUTE: Instrument;
  /**
   * Bell is normally played when a note block is on top of a gold block.
  */
  static readonly BELL: Instrument;
  /**
   * Guitar is normally played when a note block is on top of a woolen block.
  */
  static readonly GUITAR: Instrument;
  /**
   * Chime is normally played when a note block is on top of a packed ice
   * block.
  */
  static readonly CHIME: Instrument;
  /**
   * Xylophone is normally played when a note block is on top of a bone block.
  */
  static readonly XYLOPHONE: Instrument;
  /**
   * Iron Xylophone is normally played when a note block is on top of a iron block.
  */
  static readonly IRON_XYLOPHONE: Instrument;
  /**
   * Cow Bell is normally played when a note block is on top of a soul sand block.
  */
  static readonly COW_BELL: Instrument;
  /**
   * Didgeridoo is normally played when a note block is on top of a pumpkin block.
  */
  static readonly DIDGERIDOO: Instrument;
  /**
   * Bit is normally played when a note block is on top of a emerald block.
  */
  static readonly BIT: Instrument;
  /**
   * Banjo is normally played when a note block is on top of a hay block.
  */
  static readonly BANJO: Instrument;
  /**
   * Pling is normally played when a note block is on top of a glowstone block.
  */
  static readonly PLING: Instrument;
  static valueOf(name: string): Instrument;
  static values(): Instrument[];
  /**
   * @return The type ID of this instrument.
   * @deprecated Magic value
  */
  getType(): number;
  /**
   * Get an instrument by its type ID.
   *
   * @param type The type ID
   * @return The instrument
   * @deprecated Magic value
  */
  static getByType(type: number): Instrument | null;
}
/**
 * Represents a vibration from a Skulk sensor.
*/
export class Vibration {
  constructor(origin: Location, destination: Destination, arrivalTime: number);
  /**
   * Get the origin of the vibration.
   *
   * @return origin
  */
  getOrigin(): Location;
  /**
   * Get the vibration destination.
   *
   * @return destination
  */
  getDestination(): Destination;
  /**
   * Get the vibration arrival time in ticks.
   *
   * @return arrival time
  */
  getArrivalTime(): number;
}
/**
 * Represents a single firework effect.
*/
export class FireworkEffect extends ConfigurationSerializable {
  /**
   * Construct a firework effect.
   *
   * @return A utility object for building a firework effect
  */
  static builder(): Builder;
  /**
   * Get whether the firework effect flickers.
   *
   * @return true if it flickers, false if not
  */
  hasFlicker(): boolean;
  /**
   * Get whether the firework effect has a trail.
   *
   * @return true if it has a trail, false if not
  */
  hasTrail(): boolean;
  /**
   * Get the primary colors of the firework effect.
   *
   * @return An immutable list of the primary colors
  */
  getColors(): Color[];
  /**
   * Get the fade colors of the firework effect.
   *
   * @return An immutable list of the fade colors
  */
  getFadeColors(): Color[];
  /**
   * Get the type of the firework effect.
   *
   * @return The effect type
  */
  getType(): org_bukkit_FireworkEffect_Type;
  /**
   * @param map the map to deserialize
   * @return the resulting serializable
   * @see ConfigurationSerializable
  */
  static deserialize(map: Map<string, any>): ConfigurationSerializable;
  /**
   * Creates a Map representation of this class.
   * 
   * This class must provide a method to restore this class, as defined in
   * the {@link ConfigurationSerializable} interface javadocs.
   *
   * @return Map containing the current state of this class
  */
  serialize(): Map<string, any>;
  toString(): string;
  hashCode(): number;
  equals(obj: any): boolean;
}
/**
 * Represents various types of options that may be used to create a world.
*/
export class WorldCreator {
  /**
   * Creates an empty WorldCreationOptions for the given world name
   *
   * @param name Name of the world that will be created
  */
  constructor(name: string);
  /**
   * Creates an empty WorldCreator for the given world name and key
   *
   * @param levelName LevelName of the world that will be created
   * @param worldKey NamespacedKey of the world that will be created
  */
  constructor(levelName: string, worldKey: NamespacedKey);
  /**
   * Creates an empty WorldCreator for the given key.
   * LevelName will be the Key part of the NamespacedKey.
   *
   * @param worldKey NamespacedKey of the world that will be created
  */
  constructor(worldKey: NamespacedKey);
  /**
   * Gets the key for this WorldCreator
   *
   * @return the key
  */
  key(): NamespacedKey;
  /**
   * Creates an empty WorldCreator for the given world name and key
   *
   * @param levelName LevelName of the world that will be created
   * @param worldKey NamespacedKey of the world that will be created
  */
  static ofNameAndKey(levelName: string, worldKey: NamespacedKey): WorldCreator;
  /**
   * Creates an empty WorldCreator for the given key.
   * LevelName will be the Key part of the NamespacedKey.
   *
   * @param worldKey NamespacedKey of the world that will be created
  */
  static ofKey(worldKey: NamespacedKey): WorldCreator;
  /**
   * Copies the options from the specified world
   *
   * @param world World to copy options from
   * @return This object, for chaining
  */
  copy(world: World): WorldCreator;
  /**
   * Copies the options from the specified {@link WorldCreator}
   *
   * @param creator World creator to copy options from
   * @return This object, for chaining
  */
  copy(creator: WorldCreator): WorldCreator;
  /**
   * Gets the name of the world that is to be loaded or created.
   *
   * @return World name
  */
  name(): string;
  /**
   * Gets the seed that will be used to create this world
   *
   * @return World seed
  */
  seed(): number;
  /**
   * Sets the seed that will be used to create this world
   *
   * @param seed World seed
   * @return This object, for chaining
  */
  seed(seed: number): WorldCreator;
  /**
   * Gets the environment that will be used to create or load the world
   *
   * @return World environment
  */
  environment(): Environment;
  /**
   * Sets the environment that will be used to create or load the world
   *
   * @param env World environment
   * @return This object, for chaining
  */
  environment(env: Environment): WorldCreator;
  /**
   * Gets the type of the world that will be created or loaded
   *
   * @return World type
  */
  type(): WorldType;
  /**
   * Sets the type of the world that will be created or loaded
   *
   * @param type World type
   * @return This object, for chaining
  */
  type(type: WorldType): WorldCreator;
  /**
   * Gets the generator that will be used to create or load the world.
   * 
   * This may be null, in which case the "natural" generator for this
   * environment will be used.
   *
   * @return Chunk generator
  */
  generator(): ChunkGenerator | null;
  /**
   * Sets the generator that will be used to create or load the world.
   * 
   * This may be null, in which case the "natural" generator for this
   * environment will be used.
   *
   * @param generator Chunk generator
   * @return This object, for chaining
  */
  generator(generator: ChunkGenerator | null): WorldCreator;
  /**
   * Sets the generator that will be used to create or load the world.
   * 
   * This may be null, in which case the "natural" generator for this
   * environment will be used.
   * 
   * If the generator cannot be found for the given name, the natural
   * environment generator will be used instead and a warning will be
   * printed to the console.
   *
   * @param generator Name of the generator to use, in "plugin:id" notation
   * @return This object, for chaining
  */
  generator(generator: string | null): WorldCreator;
  /**
   * Sets the generator that will be used to create or load the world.
   * 
   * This may be null, in which case the "natural" generator for this
   * environment will be used.
   * 
   * If the generator cannot be found for the given name, the natural
   * environment generator will be used instead and a warning will be
   * printed to the specified output
   *
   * @param generator Name of the generator to use, in "plugin:id" notation
   * @param output {@link CommandSender} that will receive any error
   *     messages
   * @return This object, for chaining
  */
  generator(generator: string | null, output: CommandSender | null): WorldCreator;
  /**
   * Gets the biome provider that will be used to create or load the world.
   * 
   * This may be null, in which case the biome provider from the {@link ChunkGenerator}
   * will be used. If no {@link ChunkGenerator} is specific the "natural" biome provider
   * for this environment will be used.
   *
   * @return Biome provider
  */
  biomeProvider(): BiomeProvider | null;
  /**
   * Sets the biome provider that will be used to create or load the world.
   * 
   * This may be null, in which case the biome provider from the
   * {@link ChunkGenerator} will be used. If no {@link ChunkGenerator} is
   * specific the "natural" biome provider for this environment will be used.
   *
   * @param biomeProvider Biome provider
   * @return This object, for chaining
  */
  biomeProvider(biomeProvider: BiomeProvider | null): WorldCreator;
  /**
   * Sets the biome provider that will be used to create or load the world.
   * 
   * This may be null, in which case the biome provider from the
   * {@link ChunkGenerator} will be used. If no {@link ChunkGenerator} is
   * specific the "natural" biome provider for this environment will be used.
   * 
   * If the biome provider cannot be found for the given name and no
   * {@link ChunkGenerator} is specific, the natural environment biome
   * provider will be used instead and a warning will be printed to the
   * specified output
   *
   * @param biomeProvider Name of the biome provider to use, in "plugin:id"
   * notation
   * @return This object, for chaining
  */
  biomeProvider(biomeProvider: string | null): WorldCreator;
  /**
   * Sets the biome provider that will be used to create or load the world.
   * 
   * This may be null, in which case the biome provider from the
   * {@link ChunkGenerator} will be used. If no {@link ChunkGenerator} is
   * specific the "natural" biome provider for this environment will be used.
   * 
   * If the biome provider cannot be found for the given name and no
   * {@link ChunkGenerator} is specific, the natural environment biome
   * provider will be used instead and a warning will be printed to the
   * specified output
   *
   * @param biomeProvider Name of the biome provider to use, in "plugin:id"
   * notation
   * @param output {@link CommandSender} that will receive any error messages
   * @return This object, for chaining
  */
  biomeProvider(biomeProvider: string | null, output: CommandSender | null): WorldCreator;
  /**
   * Sets the generator settings of the world that will be created or loaded.
   * 
   * Currently only {@link WorldType#FLAT} uses these settings, and expects
   * them to be in JSON format with a valid biome (1.18.2 and
   * above) defined. An example valid configuration is as follows:
   * {"layers": [{"block": "stone", "height": 1}, {"block": "grass_block", "height": 1}], "biome":"plains"}
   *
   * @param generatorSettings The settings that should be used by the
   * generator
   * @return This object, for chaining
   * @see Custom
   * dimension (scroll to "When the generator ID type is
   * minecraft:flat)"
  */
  generatorSettings(generatorSettings: string): WorldCreator;
  /**
   * Gets the generator settings of the world that will be created or loaded.
   *
   * @return The settings that should be used by the generator
   * @see #generatorSettings(java.lang.String)
  */
  generatorSettings(): string;
  /**
   * Sets whether or not worlds created or loaded with this creator will
   * have structures.
   *
   * @param generate Whether to generate structures
   * @return This object, for chaining
  */
  generateStructures(generate: boolean): WorldCreator;
  /**
   * Gets whether or not structures will be generated in the world.
   *
   * @return True if structures will be generated
  */
  generateStructures(): boolean;
  /**
   * Sets whether the world will be hardcore or not.
   *
   * In a hardcore world the difficulty will be locked to hard.
   *
   * @param hardcore Whether the world will be hardcore
   * @return This object, for chaining
  */
  hardcore(hardcore: boolean): WorldCreator;
  /**
   * Gets whether the world will be hardcore or not.
   *
   * In a hardcore world the difficulty will be locked to hard.
   *
   * @return hardcore status
  */
  hardcore(): boolean;
  /**
   * Creates a world with the specified options.
   * 
   * If the world already exists, it will be loaded from disk and some
   * options may be ignored.
   *
   * @return Newly created or loaded world
  */
  createWorld(): World | null;
  /**
   * Creates a new {@link WorldCreator} for the given world name
   *
   * @param name Name of the world to load or create
   * @return Resulting WorldCreator
  */
  static name(name: string): WorldCreator;
  /**
   * Attempts to get the {@link ChunkGenerator} with the given name.
   * 
   * If the generator is not found, null will be returned and a message will
   * be printed to the specified {@link CommandSender} explaining why.
   * 
   * The name must be in the "plugin:id" notation, or optionally just
   * "plugin", where "plugin" is the safe-name of a plugin and "id" is an
   * optional unique identifier for the generator you wish to request from
   * the plugin.
   *
   * @param world Name of the world this will be used for
   * @param name Name of the generator to retrieve
   * @param output Where to output if errors are present
   * @return Resulting generator, or null
  */
  static getGeneratorForName(world: string, name: string | null, output: CommandSender | null): ChunkGenerator | null;
  /**
   * Attempts to get the {@link BiomeProvider} with the given name.
   * 
   * If the biome provider is not found, null will be returned and a message
   * will be printed to the specified {@link CommandSender} explaining why.
   * 
   * The name must be in the "plugin:id" notation, or optionally just
   * "plugin", where "plugin" is the safe-name of a plugin and "id" is an
   * optional unique identifier for the biome provider you wish to request
   * from the plugin.
   *
   * @param world Name of the world this will be used for
   * @param name Name of the biome provider to retrieve
   * @param output Where to output if errors are present
   * @return Resulting biome provider, or null
  */
  static getBiomeProviderForName(world: string, name: string | null, output: CommandSender | null): BiomeProvider | null;
  /**
   * Returns the current intent to keep the world loaded, @see {@link WorldCreator#keepSpawnLoaded(net.kyori.adventure.util.TriState)}
   *
   * @return the current tristate value
  */
  keepSpawnLoaded(): TriState;
  /**
   * Controls if a world should be kept loaded or not, default (NOT_SET) will use the servers standard
   * configuration, otherwise, will act as an override towards this setting
   *
   * @param keepSpawnLoaded the new value
  */
  keepSpawnLoaded(keepSpawnLoaded: TriState): void;
}
export class Particle extends Enum<Particle> {
  static readonly EXPLOSION_NORMAL: Particle;
  static readonly EXPLOSION_LARGE: Particle;
  static readonly EXPLOSION_HUGE: Particle;
  static readonly FIREWORKS_SPARK: Particle;
  static readonly WATER_BUBBLE: Particle;
  static readonly WATER_SPLASH: Particle;
  static readonly WATER_WAKE: Particle;
  static readonly SUSPENDED: Particle;
  static readonly SUSPENDED_DEPTH: Particle;
  static readonly CRIT: Particle;
  static readonly CRIT_MAGIC: Particle;
  static readonly SMOKE_NORMAL: Particle;
  static readonly SMOKE_LARGE: Particle;
  static readonly SPELL: Particle;
  static readonly SPELL_INSTANT: Particle;
  static readonly SPELL_MOB: Particle;
  static readonly SPELL_MOB_AMBIENT: Particle;
  static readonly SPELL_WITCH: Particle;
  static readonly DRIP_WATER: Particle;
  static readonly DRIP_LAVA: Particle;
  static readonly VILLAGER_ANGRY: Particle;
  static readonly VILLAGER_HAPPY: Particle;
  static readonly TOWN_AURA: Particle;
  static readonly NOTE: Particle;
  static readonly PORTAL: Particle;
  static readonly ENCHANTMENT_TABLE: Particle;
  static readonly FLAME: Particle;
  static readonly LAVA: Particle;
  static readonly CLOUD: Particle;
  /**
   * Uses {@link Particle.DustOptions} as DataType
  */
  static readonly REDSTONE: Particle;
  static readonly SNOWBALL: Particle;
  static readonly SNOW_SHOVEL: Particle;
  static readonly SLIME: Particle;
  static readonly HEART: Particle;
  /**
   * Uses {@link ItemStack} as DataType
  */
  static readonly ITEM_CRACK: Particle;
  /**
   * Uses {@link BlockData} as DataType
  */
  static readonly BLOCK_CRACK: Particle;
  /**
   * Uses {@link BlockData} as DataType
  */
  static readonly BLOCK_DUST: Particle;
  static readonly WATER_DROP: Particle;
  static readonly MOB_APPEARANCE: Particle;
  static readonly DRAGON_BREATH: Particle;
  static readonly END_ROD: Particle;
  static readonly DAMAGE_INDICATOR: Particle;
  static readonly SWEEP_ATTACK: Particle;
  /**
   * Uses {@link BlockData} as DataType
  */
  static readonly FALLING_DUST: Particle;
  static readonly TOTEM: Particle;
  static readonly SPIT: Particle;
  static readonly SQUID_INK: Particle;
  static readonly BUBBLE_POP: Particle;
  static readonly CURRENT_DOWN: Particle;
  static readonly BUBBLE_COLUMN_UP: Particle;
  static readonly NAUTILUS: Particle;
  static readonly DOLPHIN: Particle;
  static readonly SNEEZE: Particle;
  static readonly CAMPFIRE_COSY_SMOKE: Particle;
  static readonly CAMPFIRE_SIGNAL_SMOKE: Particle;
  static readonly COMPOSTER: Particle;
  static readonly FLASH: Particle;
  static readonly FALLING_LAVA: Particle;
  static readonly LANDING_LAVA: Particle;
  static readonly FALLING_WATER: Particle;
  static readonly DRIPPING_HONEY: Particle;
  static readonly FALLING_HONEY: Particle;
  static readonly LANDING_HONEY: Particle;
  static readonly FALLING_NECTAR: Particle;
  static readonly SOUL_FIRE_FLAME: Particle;
  static readonly ASH: Particle;
  static readonly CRIMSON_SPORE: Particle;
  static readonly WARPED_SPORE: Particle;
  static readonly SOUL: Particle;
  static readonly DRIPPING_OBSIDIAN_TEAR: Particle;
  static readonly FALLING_OBSIDIAN_TEAR: Particle;
  static readonly LANDING_OBSIDIAN_TEAR: Particle;
  static readonly REVERSE_PORTAL: Particle;
  static readonly WHITE_ASH: Particle;
  /**
   * Uses {@link DustTransition} as DataType
  */
  static readonly DUST_COLOR_TRANSITION: Particle;
  /**
   * Uses {@link Vibration} as DataType
  */
  static readonly VIBRATION: Particle;
  static readonly FALLING_SPORE_BLOSSOM: Particle;
  static readonly SPORE_BLOSSOM_AIR: Particle;
  static readonly SMALL_FLAME: Particle;
  static readonly SNOWFLAKE: Particle;
  static readonly DRIPPING_DRIPSTONE_LAVA: Particle;
  static readonly FALLING_DRIPSTONE_LAVA: Particle;
  static readonly DRIPPING_DRIPSTONE_WATER: Particle;
  static readonly FALLING_DRIPSTONE_WATER: Particle;
  static readonly GLOW_SQUID_INK: Particle;
  static readonly GLOW: Particle;
  static readonly WAX_ON: Particle;
  static readonly WAX_OFF: Particle;
  static readonly ELECTRIC_SPARK: Particle;
  static readonly SCRAPE: Particle;
  /**
   * Uses {@link BlockData} as DataType
  */
  static readonly BLOCK_MARKER: Particle;
  /**
   * Uses {@link MaterialData} as DataType
  */
  static readonly LEGACY_BLOCK_CRACK: Particle;
  /**
   * Uses {@link MaterialData} as DataType
  */
  static readonly LEGACY_BLOCK_DUST: Particle;
  /**
   * Uses {@link MaterialData} as DataType
  */
  static readonly LEGACY_FALLING_DUST: Particle;
  static valueOf(name: string): Particle;
  static values(): Particle[];
  /**
   * Returns the required data type for the particle
   * @return the required data type
  */
  getDataType(): Class<any>;
  /**
   * Creates a {@link com.destroystokyo.paper.ParticleBuilder}
   *
   * @return a {@link com.destroystokyo.paper.ParticleBuilder} for the particle
  */
  builder(): ParticleBuilder;
}
/**
 * Represents a world, which may contain entities, chunks and blocks
*/
export class World extends RegionAccessor {
  /**
   * @return The amount of Entities in this world
  */
  getEntityCount(): number;
  /**
   * @return The amount of Tile Entities in this world
  */
  getTileEntityCount(): number;
  /**
   * @return The amount of Tickable Tile Entities in this world
  */
  getTickableTileEntityCount(): number;
  /**
   * @return The amount of Chunks in this world
  */
  getChunkCount(): number;
  /**
   * @return The amount of Players in this world
  */
  getPlayerCount(): number;
  /**
   * Gets the {@link Block} at the given coordinates
   *
   * @param x X-coordinate of the block
   * @param y Y-coordinate of the block
   * @param z Z-coordinate of the block
   * @return Block at the given coordinates
  */
  getBlockAt(x: number, y: number, z: number): Block;
  /**
   * Gets the {@link Block} at the given {@link Location}
   *
   * @param location Location of the block
   * @return Block at the given location
  */
  getBlockAt(location: Location): Block;
  /**
   * Gets the {@link Block} at the given block key
   *
   * @param key The block key. See {@link Block#getBlockKey()}
   * @return Block at the key
   * @see Block#getBlockKey(int, int, int)
   * @deprecated only encodes y block ranges from -512 to 511 and represents an already changed implementation detail
  */
  getBlockAtKey(key: number): Block;
  /**
   * Gets the {@link Location} at the given block key
   *
   * @param key The block key. See {@link Location#toBlockKey()}
   * @return Location at the key
   * @see Block#getBlockKey(int, int, int)
  */
  getLocationAtKey(key: number): Location;
  /**
   * Gets the highest non-empty (impassable) coordinate at the given
   * coordinates.
   *
   * @param x X-coordinate of the blocks
   * @param z Z-coordinate of the blocks
   * @return Y-coordinate of the highest non-empty block
  */
  getHighestBlockYAt(x: number, z: number): number;
  /**
   * Gets the highest non-empty (impassable) coordinate at the given
   * {@link Location}.
   *
   * @param location Location of the blocks
   * @return Y-coordinate of the highest non-empty block
  */
  getHighestBlockYAt(location: Location): number;
  /**
   * Gets the highest non-empty (impassable) block at the given coordinates.
   *
   * @param x X-coordinate of the block
   * @param z Z-coordinate of the block
   * @return Highest non-empty block
  */
  getHighestBlockAt(x: number, z: number): Block;
  /**
   * Gets the highest non-empty (impassable) block at the given coordinates.
   *
   * @param location Coordinates to get the highest block
   * @return Highest non-empty block
  */
  getHighestBlockAt(location: Location): Block;
  /**
   * Returns the highest block's y-coordinate at the specified block coordinates that match the specified heightmap's conditions.
   * 
   * implNote: Implementations are recommended to use an iterative search as a fallback before resorting to
   * throwing an `UnsupportedOperationException`.
   * 
   *
   * @param x The block's x-coordinate.
   * @param z The block's z-coordinate.
   * @param heightmap The specified heightmap to use. See {@link com.destroystokyo.paper.HeightmapType}
   * @return The highest block's y-coordinate at (x, z) that matches the specified heightmap's conditions.
   * @throws UnsupportedOperationException If the heightmap type is not supported.
   * @deprecated Upstream has added support for this, use {@link World#getHighestBlockYAt(int, int, HeightMap)}
   *
   * @see com.destroystokyo.paper.HeightmapType
  */
  getHighestBlockYAt(x: number, z: number, heightmap: HeightmapType): number;
  /**
   * Returns the highest block's y-coordinate at the specified block coordinates that match the specified heightmap's conditions.
   * Note that the y-coordinate of the specified location is ignored.
   * 
   * implNote: Implementations are recommended to use an iterative search as a fallback before resorting to
   * throwing an `UnsupportedOperationException`.
   * 
   *
   * @param location The specified block coordinates.
   * @param heightmap The specified heightmap to use. See {@link com.destroystokyo.paper.HeightmapType}
   * @return The highest block's y-coordinate at `location` that matches the specified heightmap's conditions.
   * @throws UnsupportedOperationException If the heightmap type is not supported.
   * @deprecated Upstream has added support for this, use {@link World#getHighestBlockYAt(Location, HeightMap)}
   * @see com.destroystokyo.paper.HeightmapType
  */
  getHighestBlockYAt(location: Location, heightmap: HeightmapType): number;
  /**
   * Returns the highest {@link Block} at the specified block coordinates that match the specified heightmap's conditions.
   * 
   * implNote: Implementations are recommended to use an iterative search as a fallback before resorting to
   * throwing an `UnsupportedOperationException`.
   * 
   * @param x The block's x-coordinate.
   * @param z The block's z-coordinate.
   * @param heightmap The specified heightmap to use. See {@link com.destroystokyo.paper.HeightmapType}
   * @return The highest {@link Block} at (x, z) that matches the specified heightmap's conditions.
   * @throws UnsupportedOperationException If the heightmap type is not supported.
   * @deprecated Upstream has added support for this, use {@link World#getHighestBlockAt(int, int, HeightMap)}
   * @see com.destroystokyo.paper.HeightmapType
  */
  getHighestBlockAt(x: number, z: number, heightmap: HeightmapType): Block;
  /**
   * Returns the highest {@link Block} at the specified block coordinates that match the specified heightmap's conditions.
   * Note that the y-coordinate of the specified location is ignored.
   * 
   * implNote: Implementations are recommended to use an iterative search as a fallback before resorting to
   * throwing an `UnsupportedOperationException`.
   * 
   * @param location The specified block coordinates.
   * @param heightmap The specified heightmap to use. See {@link com.destroystokyo.paper.HeightmapType}
   * @return The highest {@link Block} at `location` that matches the specified heightmap's conditions.
   * @throws UnsupportedOperationException If the heightmap type is not supported.
   * @deprecated Upstream has added support for this, use {@link World#getHighestBlockAt(Location, HeightMap)}
   * @see com.destroystokyo.paper.HeightmapType
  */
  getHighestBlockAt(location: Location, heightmap: HeightmapType): Block;
  /**
   * Gets the highest coordinate corresponding to the {@link HeightMap} at the
   * given coordinates.
   *
   * @param x X-coordinate of the blocks
   * @param z Z-coordinate of the blocks
   * @param heightMap the heightMap that is used to determine the highest
   * point
   *
   * @return Y-coordinate of the highest block corresponding to the
   * {@link HeightMap}
  */
  getHighestBlockYAt(x: number, z: number, heightMap: HeightMap): number;
  /**
   * Gets the highest coordinate corresponding to the {@link HeightMap} at the
   * given {@link Location}.
   *
   * @param location Location of the blocks
   * @param heightMap the heightMap that is used to determine the highest
   * point
   * @return Y-coordinate of the highest block corresponding to the
   * {@link HeightMap}
  */
  getHighestBlockYAt(location: Location, heightMap: HeightMap): number;
  /**
   * Gets the highest block corresponding to the {@link HeightMap} at the
   * given coordinates.
   *
   * @param x X-coordinate of the block
   * @param z Z-coordinate of the block
   * @param heightMap the heightMap that is used to determine the highest
   * point
   * @return Highest block corresponding to the {@link HeightMap}
  */
  getHighestBlockAt(x: number, z: number, heightMap: HeightMap): Block;
  /**
   * Gets the highest block corresponding to the {@link HeightMap} at the
   * given coordinates.
   *
   * @param location Coordinates to get the highest block
   * @param heightMap the heightMap that is used to determine the highest
   * point
   * @return Highest block corresponding to the {@link HeightMap}
  */
  getHighestBlockAt(location: Location, heightMap: HeightMap): Block;
  /**
   * Gets the {@link Chunk} at the given coordinates
   *
   * @param x X-coordinate of the chunk
   * @param z Z-coordinate of the chunk
   * @return Chunk at the given coordinates
  */
  getChunkAt(x: number, z: number): Chunk;
  /**
   * Gets the {@link Chunk} at the given {@link Location}
   *
   * @param location Location of the chunk
   * @return Chunk at the given location
  */
  getChunkAt(location: Location): Chunk;
  /**
   * Gets the {@link Chunk} that contains the given {@link Block}
   *
   * @param block Block to get the containing chunk from
   * @return The chunk that contains the given block
  */
  getChunkAt(block: Block): Chunk;
  /**
   * Gets the chunk at the specified chunk key, which is the X and Z packed into a long.
   *
   * See {@link Chunk#getChunkKey()} for easy access to the key, or you may calculate it as:
   * long chunkKey = (long) chunkX & 0xffffffffL | ((long) chunkZ & 0xffffffffL) >> 32;
   *
   * @param chunkKey The Chunk Key to look up the chunk by
   * @return The chunk at the specified key
  */
  getChunkAt(chunkKey: number): Chunk;
  /**
   * Checks if a {@link Chunk} has been generated at the specified chunk key,
   * which is the X and Z packed into a long.
   *
   * @param chunkKey The Chunk Key to look up the chunk by
   * @return true if the chunk has been generated, otherwise false
  */
  isChunkGenerated(chunkKey: number): boolean;
  /**
   * Checks if the specified {@link Chunk} is loaded
   *
   * @param chunk The chunk to check
   * @return true if the chunk is loaded, otherwise false
  */
  isChunkLoaded(chunk: Chunk): boolean;
  /**
   * Gets an array of all loaded {@link Chunk}s
   *
   * @return Chunk[] containing all loaded chunks
  */
  getLoadedChunks(): Chunk[];
  /**
   * Loads the specified {@link Chunk}.
   * 
   * This method will keep the specified chunk loaded until one of the
   * unload methods is manually called. Callers are advised to instead use
   * getChunkAt which will only temporarily load the requested chunk.
   *
   * @param chunk The chunk to load
  */
  loadChunk(chunk: Chunk): void;
  /**
   * Checks if the {@link Chunk} at the specified coordinates is loaded
   *
   * @param x X-coordinate of the chunk
   * @param z Z-coordinate of the chunk
   * @return true if the chunk is loaded, otherwise false
  */
  isChunkLoaded(x: number, z: number): boolean;
  /**
   * Checks if the {@link Chunk} at the specified coordinates is generated
   *
   * @param x X-coordinate of the chunk
   * @param z Z-coordinate of the chunk
   * @return true if the chunk is generated, otherwise false
  */
  isChunkGenerated(x: number, z: number): boolean;
  /**
   * Checks if the {@link Chunk} at the specified coordinates is loaded and
   * in use by one or more players
   *
   * @param x X-coordinate of the chunk
   * @param z Z-coordinate of the chunk
   * @return true if the chunk is loaded and in use by one or more players,
   *     otherwise false
   * @deprecated This method was added to facilitate chunk garbage collection.
   *     As of the current Minecraft version chunks are now strictly managed and
   *     will not be loaded for more than 1 tick unless they are in use.
  */
  isChunkInUse(x: number, z: number): boolean;
  /**
   * Loads the {@link Chunk} at the specified coordinates.
   * 
   * This method will keep the specified chunk loaded until one of the
   * unload methods is manually called. Callers are advised to instead use
   * getChunkAt which will only temporarily load the requested chunk.
   * 
   * If the chunk does not exist, it will be generated.
   * 
   * This method is analogous to {@link #loadChunk(int, int, boolean)} where
   * generate is true.
   *
   * @param x X-coordinate of the chunk
   * @param z Z-coordinate of the chunk
  */
  loadChunk(x: number, z: number): void;
  /**
   * Loads the {@link Chunk} at the specified coordinates.
   * 
   * This method will keep the specified chunk loaded until one of the
   * unload methods is manually called. Callers are advised to instead use
   * getChunkAt which will only temporarily load the requested chunk.
   *
   * @param x X-coordinate of the chunk
   * @param z Z-coordinate of the chunk
   * @param generate Whether or not to generate a chunk if it doesn't
   *     already exist
   * @return true if the chunk has loaded successfully, otherwise false
  */
  loadChunk(x: number, z: number, generate: boolean): boolean;
  /**
   * Safely unloads and saves the {@link Chunk} at the specified coordinates
   * 
   * This method is analogous to {@link #unloadChunk(int, int, boolean)}
   * where save is true.
   *
   * @param chunk the chunk to unload
   * @return true if the chunk has unloaded successfully, otherwise false
  */
  unloadChunk(chunk: Chunk): boolean;
  /**
   * Safely unloads and saves the {@link Chunk} at the specified coordinates
   * 
   * This method is analogous to {@link #unloadChunk(int, int, boolean)}
   * where save is true.
   *
   * @param x X-coordinate of the chunk
   * @param z Z-coordinate of the chunk
   * @return true if the chunk has unloaded successfully, otherwise false
  */
  unloadChunk(x: number, z: number): boolean;
  /**
   * Safely unloads and optionally saves the {@link Chunk} at the specified
   * coordinates.
   *
   * @param x X-coordinate of the chunk
   * @param z Z-coordinate of the chunk
   * @param save Whether or not to save the chunk
   * @return true if the chunk has unloaded successfully, otherwise false
  */
  unloadChunk(x: number, z: number, save: boolean): boolean;
  /**
   * Safely queues the {@link Chunk} at the specified coordinates for
   * unloading.
   *
   * @param x X-coordinate of the chunk
   * @param z Z-coordinate of the chunk
   * @return true is the queue attempt was successful, otherwise false
  */
  unloadChunkRequest(x: number, z: number): boolean;
  /**
   * Regenerates the {@link Chunk} at the specified coordinates
   *
   * @param x X-coordinate of the chunk
   * @param z Z-coordinate of the chunk
   * @return Whether the chunk was actually regenerated
   *
   * @deprecated regenerating a single chunk is not likely to produce the same
   * chunk as before as terrain decoration may be spread across chunks. It may
   * or may not change blocks in the adjacent chunks as well.
  */
  regenerateChunk(x: number, z: number): boolean;
  refreshChunk(x: number, z: number): boolean;
  /**
   * Gets whether the chunk at the specified chunk coordinates is force
   * loaded.
   * 
   * A force loaded chunk will not be unloaded due to lack of player activity.
   *
   * @param x X-coordinate of the chunk
   * @param z Z-coordinate of the chunk
   * @return force load status
  */
  isChunkForceLoaded(x: number, z: number): boolean;
  /**
   * Sets whether the chunk at the specified chunk coordinates is force
   * loaded.
   * 
   * A force loaded chunk will not be unloaded due to lack of player activity.
   *
   * @param x X-coordinate of the chunk
   * @param z Z-coordinate of the chunk
   * @param forced force load status
  */
  setChunkForceLoaded(x: number, z: number, forced: boolean): void;
  /**
   * Returns all force loaded chunks in this world.
   * 
   * A force loaded chunk will not be unloaded due to lack of player activity.
   *
   * @return unmodifiable collection of force loaded chunks
  */
  getForceLoadedChunks(): Collection<Chunk>;
  /**
   * Adds a plugin ticket for the specified chunk, loading the chunk if it is
   * not already loaded.
   * 
   * A plugin ticket will prevent a chunk from unloading until it is
   * explicitly removed. A plugin instance may only have one ticket per chunk,
   * but each chunk can have multiple plugin tickets.
   * 
   *
   * @param x X-coordinate of the chunk
   * @param z Z-coordinate of the chunk
   * @param plugin Plugin which owns the ticket
   * @return `true` if a plugin ticket was added, `false` if the
   * ticket already exists for the plugin
   * @throws IllegalStateException If the specified plugin is not enabled
   * @see #removePluginChunkTicket(int, int, Plugin)
  */
  addPluginChunkTicket(x: number, z: number, plugin: Plugin): boolean;
  /**
   * Removes the specified plugin's ticket for the specified chunk
   * 
   * A plugin ticket will prevent a chunk from unloading until it is
   * explicitly removed. A plugin instance may only have one ticket per chunk,
   * but each chunk can have multiple plugin tickets.
   * 
   *
   * @param x X-coordinate of the chunk
   * @param z Z-coordinate of the chunk
   * @param plugin Plugin which owns the ticket
   * @return `true` if the plugin ticket was removed, `false` if
   * there is no plugin ticket for the chunk
   * @see #addPluginChunkTicket(int, int, Plugin)
  */
  removePluginChunkTicket(x: number, z: number, plugin: Plugin): boolean;
  /**
   * Removes all plugin tickets for the specified plugin
   * 
   * A plugin ticket will prevent a chunk from unloading until it is
   * explicitly removed. A plugin instance may only have one ticket per chunk,
   * but each chunk can have multiple plugin tickets.
   * 
   *
   * @param plugin Specified plugin
   * @see #addPluginChunkTicket(int, int, Plugin)
   * @see #removePluginChunkTicket(int, int, Plugin)
  */
  removePluginChunkTickets(plugin: Plugin): void;
  /**
   * Retrieves a collection specifying which plugins have tickets for the
   * specified chunk. This collection is not updated when plugin tickets are
   * added or removed to the chunk.
   * 
   * A plugin ticket will prevent a chunk from unloading until it is
   * explicitly removed. A plugin instance may only have one ticket per chunk,
   * but each chunk can have multiple plugin tickets.
   * 
   *
   * @param x X-coordinate of the chunk
   * @param z Z-coordinate of the chunk
   * @return unmodifiable collection containing which plugins have tickets for
   * the chunk
   * @see #addPluginChunkTicket(int, int, Plugin)
   * @see #removePluginChunkTicket(int, int, Plugin)
  */
  getPluginChunkTickets(x: number, z: number): Collection<Plugin>;
  /**
   * Returns a map of which plugins have tickets for what chunks. The returned
   * map is not updated when plugin tickets are added or removed to chunks. If
   * a plugin has no tickets, it will be absent from the map.
   * 
   * A plugin ticket will prevent a chunk from unloading until it is
   * explicitly removed. A plugin instance may only have one ticket per chunk,
   * but each chunk can have multiple plugin tickets.
   * 
   *
   * @return unmodifiable map containing which plugins have tickets for what
   * chunks
   * @see #addPluginChunkTicket(int, int, Plugin)
   * @see #removePluginChunkTicket(int, int, Plugin)
  */
  getPluginChunkTickets(): Map<Plugin, Collection<Chunk>>;
  /**
   * Drops an item at the specified {@link Location}
   *
   * @param location Location to drop the item
   * @param item ItemStack to drop
   * @return ItemDrop entity created as a result of this method
  */
  dropItem(location: Location, item: ItemStack): Item;
  /**
   * Drops an item at the specified {@link Location}
   * Note that functions will run before the entity is spawned
   *
   * @param location Location to drop the item
   * @param item ItemStack to drop
   * @param function the function to be run before the entity is spawned.
   * @return ItemDrop entity created as a result of this method
  */
  dropItem(location: Location, item: ItemStack, func: org_bukkit_util_Consumer<Item> | null): Item;
  /**
   * Drops an item at the specified {@link Location} with a random offset
   *
   * @param location Location to drop the item
   * @param item ItemStack to drop
   * @return ItemDrop entity created as a result of this method
  */
  dropItemNaturally(location: Location, item: ItemStack): Item;
  /**
   * Drops an item at the specified {@link Location} with a random offset
   * Note that functions will run before the entity is spawned
   *
   * @param location Location to drop the item
   * @param item ItemStack to drop
   * @param function the function to be run before the entity is spawned.
   * @return ItemDrop entity created as a result of this method
  */
  dropItemNaturally(location: Location, item: ItemStack, func: org_bukkit_util_Consumer<Item> | null): Item;
  /**
   * Creates an {@link Arrow} entity at the given {@link Location}
   *
   * @param location Location to spawn the arrow
   * @param direction Direction to shoot the arrow in
   * @param speed Speed of the arrow. A recommend speed is 0.6
   * @param spread Spread of the arrow. A recommend spread is 12
   * @return Arrow entity spawned as a result of this method
  */
  spawnArrow(location: Location, direction: Vector, speed: number, spread: number): Arrow;
  /**
   * Creates an arrow entity of the given class at the given {@link Location}
   *
   * @param  type of arrow to spawn
   * @param location Location to spawn the arrow
   * @param direction Direction to shoot the arrow in
   * @param speed Speed of the arrow. A recommend speed is 0.6
   * @param spread Spread of the arrow. A recommend spread is 12
   * @param clazz the Entity class for the arrow
   * {@link org.bukkit.entity.SpectralArrow},{@link org.bukkit.entity.Arrow},{@link org.bukkit.entity.TippedArrow}
   * @return Arrow entity spawned as a result of this method
  */
  spawnArrow<T>(location: Location, direction: Vector, speed: number, spread: number, clazz: Class<T>): T;
  /**
   * Creates a tree at the given {@link Location}
   *
   * @param location Location to spawn the tree
   * @param type Type of the tree to create
   * @return true if the tree was created successfully, otherwise false
  */
  generateTree(location: Location, type: TreeType): boolean;
  /**
   * Creates a tree at the given {@link Location}
   *
   * @param loc Location to spawn the tree
   * @param type Type of the tree to create
   * @param delegate A class to call for each block changed as a result of
   *     this method
   * @return true if the tree was created successfully, otherwise false
   * @see #generateTree(org.bukkit.Location, java.util.Random, org.bukkit.TreeType, org.bukkit.util.Consumer)
   * @deprecated this method does not handle tile entities (bee nests)
  */
  generateTree(loc: Location, type: TreeType, delegate: BlockChangeDelegate): boolean;
  /**
   * Strikes lightning at the given {@link Location}
   *
   * @param loc The location to strike lightning
   * @return The lightning entity.
  */
  strikeLightning(loc: Location): LightningStrike;
  /**
   * Strikes lightning at the given {@link Location} without doing damage
   *
   * @param loc The location to strike lightning
   * @return The lightning entity.
  */
  strikeLightningEffect(loc: Location): LightningStrike;
  /**
   * Finds the location of the nearest unobstructed Lightning Rod in a 128-block
   * radius around the given location. Returns `null` if no Lightning Rod is found.
   *
   * Note: To activate a Lightning Rod, the position one block above it must be struck by lightning.
   *
   * @param location {@link Location} to search for Lightning Rod around
   * @return {@link Location} of Lightning Rod or `null`
  */
  findLightningRod(location: Location): Location | null;
  /**
   * Finds a target {@link Location} for lightning to strike.
   * It selects from (in the following order):
   * 
   *  the block above the nearest Lightning Rod, found using {@link World#findLightningRod(Location)}
   *  a random {@link LivingEntity} that can see the sky in a 6x6 cuboid
   *      around input X/Z coordinates. Y ranges from the highest motion-blocking
   *      block at the input X/Z - 3 to the height limit + 3
   * 
   * Returns `null` if no target is found.
   *
   * @param location {@link Location} to search for target around
   * @return lightning target or `null`
  */
  findLightningTarget(location: Location): Location | null;
  /**
   * Get a list of all entities in this World
   *
   * @return A List of all Entities currently residing in this world
  */
  getEntities(): Entity[];
  /**
   * Get a list of all living entities in this World
   *
   * @return A List of all LivingEntities currently residing in this world
  */
  getLivingEntities(): LivingEntity[];
  /**
   * Get a collection of all entities in this World matching the given
   * class/interface
   *
   * @param  an entity subclass
   * @param classes The classes representing the types of entity to match
   * @return A List of all Entities currently residing in this world that
   *     match the given class/interface
  */
  getEntitiesByClass<T>(...classes: Class[]): Collection<T>;
  /**
   * Get a collection of all entities in this World matching the given
   * class/interface
   *
   * @param  an entity subclass
   * @param cls The class representing the type of entity to match
   * @return A List of all Entities currently residing in this world that
   *     match the given class/interface
  */
  getEntitiesByClass<T>(cls: Class<T>): Collection<T>;
  /**
   * Get a collection of all entities in this World matching any of the
   * given classes/interfaces
   *
   * @param classes The classes representing the types of entity to match
   * @return A List of all Entities currently residing in this world that
   *     match one or more of the given classes/interfaces
  */
  getEntitiesByClasses(...classes: Class[]): Collection<Entity>;
  /**
   * Gets nearby LivingEntities within the specified radius (bounding box)
   * @param loc Center location
   * @param radius Radius
   * @return the collection of entities near location. This will always be a non-null collection.
  */
  getNearbyLivingEntities(loc: Location, radius: number): Collection<LivingEntity>;
  /**
   * Gets nearby LivingEntities within the specified radius (bounding box)
   * @param loc Center location
   * @param xzRadius X/Z Radius
   * @param yRadius Y Radius
   * @return the collection of entities near location. This will always be a non-null collection.
  */
  getNearbyLivingEntities(loc: Location, xzRadius: number, yRadius: number): Collection<LivingEntity>;
  /**
   * Gets nearby LivingEntities within the specified radius (bounding box)
   * @param loc Center location
   * @param xRadius X Radius
   * @param yRadius Y Radius
   * @param zRadius Z radius
   * @return the collection of entities near location. This will always be a non-null collection.
  */
  getNearbyLivingEntities(loc: Location, xRadius: number, yRadius: number, zRadius: number): Collection<LivingEntity>;
  /**
   * Gets nearby LivingEntities within the specified radius (bounding box)
   * @param loc Center location
   * @param radius X Radius
   * @param predicate a predicate used to filter results
   * @return the collection of living entities near location. This will always be a non-null collection
  */
  getNearbyLivingEntities(loc: Location, radius: number, predicate: Predicate<LivingEntity> | null): Collection<LivingEntity>;
  /**
   * Gets nearby LivingEntities within the specified radius (bounding box)
   * @param loc Center location
   * @param xzRadius X/Z Radius
   * @param yRadius Y Radius
   * @param predicate a predicate used to filter results
   * @return the collection of living entities near location. This will always be a non-null collection
  */
  getNearbyLivingEntities(loc: Location, xzRadius: number, yRadius: number, predicate: Predicate<LivingEntity> | null): Collection<LivingEntity>;
  /**
   * Gets nearby LivingEntities within the specified radius (bounding box)
   * @param loc Center location
   * @param xRadius X Radius
   * @param yRadius Y Radius
   * @param zRadius Z radius
   * @param predicate a predicate used to filter results
   * @return the collection of living entities near location. This will always be a non-null collection.
  */
  getNearbyLivingEntities(loc: Location, xRadius: number, yRadius: number, zRadius: number, predicate: Predicate<LivingEntity> | null): Collection<LivingEntity>;
  /**
   * Gets nearby players within the specified radius (bounding box)
   * @param loc Center location
   * @param radius X/Y/Z Radius
   * @return the collection of living entities near location. This will always be a non-null collection.
  */
  getNearbyPlayers(loc: Location, radius: number): Collection<Player>;
  /**
   * Gets nearby players within the specified radius (bounding box)
   * @param loc Center location
   * @param xzRadius X/Z Radius
   * @param yRadius Y Radius
   * @return the collection of living entities near location. This will always be a non-null collection.
  */
  getNearbyPlayers(loc: Location, xzRadius: number, yRadius: number): Collection<Player>;
  /**
   * Gets nearby players within the specified radius (bounding box)
   * @param loc Center location
   * @param xRadius X Radius
   * @param yRadius Y Radius
   * @param zRadius Z Radius
   * @return the collection of players near location. This will always be a non-null collection.
  */
  getNearbyPlayers(loc: Location, xRadius: number, yRadius: number, zRadius: number): Collection<Player>;
  /**
   * Gets nearby players within the specified radius (bounding box)
   * @param loc Center location
   * @param radius X/Y/Z Radius
   * @param predicate a predicate used to filter results
   * @return the collection of players near location. This will always be a non-null collection.
  */
  getNearbyPlayers(loc: Location, radius: number, predicate: Predicate<Player> | null): Collection<Player>;
  /**
   * Gets nearby players within the specified radius (bounding box)
   * @param loc Center location
   * @param xzRadius X/Z Radius
   * @param yRadius Y Radius
   * @param predicate a predicate used to filter results
   * @return the collection of players near location. This will always be a non-null collection.
  */
  getNearbyPlayers(loc: Location, xzRadius: number, yRadius: number, predicate: Predicate<Player> | null): Collection<Player>;
  /**
   * Gets nearby players within the specified radius (bounding box)
   * @param loc Center location
   * @param xRadius X Radius
   * @param yRadius Y Radius
   * @param zRadius Z Radius
   * @param predicate a predicate used to filter results
   * @return the collection of players near location. This will always be a non-null collection.
  */
  getNearbyPlayers(loc: Location, xRadius: number, yRadius: number, zRadius: number, predicate: Predicate<Player> | null): Collection<Player>;
  /**
   * Gets all nearby entities of the specified type, within the specified radius (bounding box)
   * @param clazz Type to filter by
   * @param loc Center location
   * @param radius X/Y/Z radius to search within
   * @param  the entity type
   * @return the collection of entities near location. This will always be a non-null collection.
  */
  getNearbyEntitiesByType<T>(clazz: Class<T> | null, loc: Location, radius: number): Collection<T>;
  /**
   * Gets all nearby entities of the specified type, within the specified radius, with x and x radius matching (bounding box)
   * @param clazz Type to filter by
   * @param loc Center location
   * @param xzRadius X/Z radius to search within
   * @param yRadius Y radius to search within
   * @param  the entity type
   * @return the collection of entities near location. This will always be a non-null collection.
  */
  getNearbyEntitiesByType<T>(clazz: Class<T> | null, loc: Location, xzRadius: number, yRadius: number): Collection<T>;
  /**
   * Gets all nearby entities of the specified type, within the specified radius (bounding box)
   * @param clazz Type to filter by
   * @param loc Center location
   * @param xRadius X Radius
   * @param yRadius Y Radius
   * @param zRadius Z Radius
   * @param  the entity type
   * @return the collection of entities near location. This will always be a non-null collection.
  */
  getNearbyEntitiesByType<T>(clazz: Class<T> | null, loc: Location, xRadius: number, yRadius: number, zRadius: number): Collection<T>;
  /**
   * Gets all nearby entities of the specified type, within the specified radius (bounding box)
   * @param clazz Type to filter by
   * @param loc Center location
   * @param radius X/Y/Z radius to search within
   * @param predicate a predicate used to filter results
   * @param  the entity type
   * @return the collection of entities near location. This will always be a non-null collection.
  */
  getNearbyEntitiesByType<T>(clazz: Class<T> | null, loc: Location, radius: number, predicate: Predicate<T> | null): Collection<T>;
  /**
   * Gets all nearby entities of the specified type, within the specified radius, with x and x radius matching (bounding box)
   * @param clazz Type to filter by
   * @param loc Center location
   * @param xzRadius X/Z radius to search within
   * @param yRadius Y radius to search within
   * @param predicate a predicate used to filter results
   * @param  the entity type
   * @return the collection of entities near location. This will always be a non-null collection.
  */
  getNearbyEntitiesByType<T>(clazz: Class<T> | null, loc: Location, xzRadius: number, yRadius: number, predicate: Predicate<T> | null): Collection<T>;
  /**
   * Gets all nearby entities of the specified type, within the specified radius (bounding box)
   * @param clazz Type to filter by
   * @param loc Center location
   * @param xRadius X Radius
   * @param yRadius Y Radius
   * @param zRadius Z Radius
   * @param predicate a predicate used to filter results
   * @param  the entity type
   * @return the collection of entities near location. This will always be a non-null collection.
  */
  getNearbyEntitiesByType<T>(clazz: Class<Entity> | null, loc: Location, xRadius: number, yRadius: number, zRadius: number, predicate: Predicate<T> | null): Collection<T>;
  /**
   * Requests a {@link Chunk} to be loaded at the given coordinates
   *
   * This method makes no guarantee on how fast the chunk will load,
   * and will return the chunk to the callback at a later time.
   *
   * You should use this method if you need a chunk but do not need it
   * immediately, and you wish to let the server control the speed
   * of chunk loads, keeping performance in mind.
   *
   * The {@link ChunkLoadCallback} will always be executed synchronously
   * on the main Server Thread.
   *
   * @deprecated Use either the Future or the Consumer based methods
   * @param x Chunk X-coordinate of the chunk - (world coordinate / 16)
   * @param z Chunk Z-coordinate of the chunk - (world coordinate / 16)
   * @param cb Callback to receive the chunk when it is loaded.
   *           will be executed synchronously
  */
  getChunkAtAsync(x: number, z: number, cb: ChunkLoadCallback): void;
  /**
   * Requests a {@link Chunk} to be loaded at the given {@link Location}
   *
   * This method makes no guarantee on how fast the chunk will load,
   * and will return the chunk to the callback at a later time.
   *
   * You should use this method if you need a chunk but do not need it
   * immediately, and you wish to let the server control the speed
   * of chunk loads, keeping performance in mind.
   *
   * The {@link ChunkLoadCallback} will always be executed synchronously
   * on the main Server Thread.
   *
   * @deprecated Use either the Future or the Consumer based methods
   * @param loc Location of the chunk
   * @param cb Callback to receive the chunk when it is loaded.
   *           will be executed synchronously
  */
  getChunkAtAsync(loc: Location, cb: ChunkLoadCallback): void;
  /**
   * Requests {@link Chunk} to be loaded that contains the given {@link Block}
   *
   * This method makes no guarantee on how fast the chunk will load,
   * and will return the chunk to the callback at a later time.
   *
   * You should use this method if you need a chunk but do not need it
   * immediately, and you wish to let the server control the speed
   * of chunk loads, keeping performance in mind.
   *
   * The {@link ChunkLoadCallback} will always be executed synchronously
   * on the main Server Thread.
   *
   * @deprecated Use either the Future or the Consumer based methods
   * @param block Block to get the containing chunk from
   * @param cb Callback to receive the chunk when it is loaded.
   *           will be executed synchronously
  */
  getChunkAtAsync(block: Block, cb: ChunkLoadCallback): void;
  /**
   * Requests a {@link Chunk} to be loaded at the given coordinates
   *
   * This method makes no guarantee on how fast the chunk will load,
   * and will return the chunk to the callback at a later time.
   *
   * You should use this method if you need a chunk but do not need it
   * immediately, and you wish to let the server control the speed
   * of chunk loads, keeping performance in mind.
   *
   * The {@link java.util.function.Consumer} will always be executed synchronously
   * on the main Server Thread.
   *
   * @param x Chunk X-coordinate of the chunk - (world coordinate / 16)
   * @param z Chunk Z-coordinate of the chunk - (world coordinate / 16)
   * @param cb Callback to receive the chunk when it is loaded.
   *           will be executed synchronously
  */
  getChunkAtAsync(x: number, z: number, cb: Consumer<Chunk>): void;
  /**
   * Requests a {@link Chunk} to be loaded at the given coordinates
   *
   * This method makes no guarantee on how fast the chunk will load,
   * and will return the chunk to the callback at a later time.
   *
   * You should use this method if you need a chunk but do not need it
   * immediately, and you wish to let the server control the speed
   * of chunk loads, keeping performance in mind.
   *
   * The {@link java.util.function.Consumer} will always be executed synchronously
   * on the main Server Thread.
   *
   * @param x Chunk X-coordinate of the chunk - (world coordinate / 16)
   * @param z Chunk Z-coordinate of the chunk - (world coordinate / 16)
   * @param gen Should we generate a chunk if it doesn't exists or not
   * @param cb Callback to receive the chunk when it is loaded.
   *           will be executed synchronously
  */
  getChunkAtAsync(x: number, z: number, gen: boolean, cb: Consumer<Chunk>): void;
  /**
   * Requests a {@link Chunk} to be loaded at the given {@link Location}
   *
   * This method makes no guarantee on how fast the chunk will load,
   * and will return the chunk to the callback at a later time.
   *
   * You should use this method if you need a chunk but do not need it
   * immediately, and you wish to let the server control the speed
   * of chunk loads, keeping performance in mind.
   *
   * The {@link java.util.function.Consumer} will always be executed synchronously
   * on the main Server Thread.
   *
   * @param loc Location of the chunk
   * @param cb Callback to receive the chunk when it is loaded.
   *           will be executed synchronously
  */
  getChunkAtAsync(loc: Location, cb: Consumer<Chunk>): void;
  /**
   * Requests a {@link Chunk} to be loaded at the given {@link Location}
   *
   * This method makes no guarantee on how fast the chunk will load,
   * and will return the chunk to the callback at a later time.
   *
   * You should use this method if you need a chunk but do not need it
   * immediately, and you wish to let the server control the speed
   * of chunk loads, keeping performance in mind.
   *
   * The {@link java.util.function.Consumer} will always be executed synchronously
   * on the main Server Thread.
   *
   * @param loc Location of the chunk
   * @param gen Should the chunk generate
   * @param cb Callback to receive the chunk when it is loaded.
   *           will be executed synchronously
  */
  getChunkAtAsync(loc: Location, gen: boolean, cb: Consumer<Chunk>): void;
  /**
   * Requests {@link Chunk} to be loaded that contains the given {@link Block}
   *
   * This method makes no guarantee on how fast the chunk will load,
   * and will return the chunk to the callback at a later time.
   *
   * You should use this method if you need a chunk but do not need it
   * immediately, and you wish to let the server control the speed
   * of chunk loads, keeping performance in mind.
   *
   * The {@link java.util.function.Consumer} will always be executed synchronously
   * on the main Server Thread.
   *
   * @param block Block to get the containing chunk from
   * @param cb Callback to receive the chunk when it is loaded.
   *           will be executed synchronously
  */
  getChunkAtAsync(block: Block, cb: Consumer<Chunk>): void;
  /**
   * Requests {@link Chunk} to be loaded that contains the given {@link Block}
   *
   * This method makes no guarantee on how fast the chunk will load,
   * and will return the chunk to the callback at a later time.
   *
   * You should use this method if you need a chunk but do not need it
   * immediately, and you wish to let the server control the speed
   * of chunk loads, keeping performance in mind.
   *
   * The {@link java.util.function.Consumer} will always be executed synchronously
   * on the main Server Thread.
   *
   * @param block Block to get the containing chunk from
   * @param gen Should the chunk generate
   * @param cb Callback to receive the chunk when it is loaded.
   *           will be executed synchronously
  */
  getChunkAtAsync(block: Block, gen: boolean, cb: Consumer<Chunk>): void;
  /**
   * Requests a {@link Chunk} to be loaded at the given coordinates
   *
   * This method makes no guarantee on how fast the chunk will load,
   * and will return the chunk to the callback at a later time.
   *
   * You should use this method if you need a chunk but do not need it
   * immediately, and you wish to let the server control the speed
   * of chunk loads, keeping performance in mind.
   *
   * The future will always be executed synchronously
   * on the main Server Thread.
   * @param loc Location to load the corresponding chunk from
   * @return Future that will resolve when the chunk is loaded
  */
  getChunkAtAsync(loc: Location): CompletableFuture<Chunk>;
  /**
   * Requests a {@link Chunk} to be loaded at the given coordinates
   *
   * This method makes no guarantee on how fast the chunk will load,
   * and will return the chunk to the callback at a later time.
   *
   * You should use this method if you need a chunk but do not need it
   * immediately, and you wish to let the server control the speed
   * of chunk loads, keeping performance in mind.
   *
   * The future will always be executed synchronously
   * on the main Server Thread.
   * @param loc Location to load the corresponding chunk from
   * @param gen Should the chunk generate
   * @return Future that will resolve when the chunk is loaded
  */
  getChunkAtAsync(loc: Location, gen: boolean): CompletableFuture<Chunk>;
  /**
   * Requests a {@link Chunk} to be loaded at the given coordinates
   *
   * This method makes no guarantee on how fast the chunk will load,
   * and will return the chunk to the callback at a later time.
   *
   * You should use this method if you need a chunk but do not need it
   * immediately, and you wish to let the server control the speed
   * of chunk loads, keeping performance in mind.
   *
   * The future will always be executed synchronously
   * on the main Server Thread.
   * @param block Block to load the corresponding chunk from
   * @return Future that will resolve when the chunk is loaded
  */
  getChunkAtAsync(block: Block): CompletableFuture<Chunk>;
  /**
   * Requests a {@link Chunk} to be loaded at the given coordinates
   *
   * This method makes no guarantee on how fast the chunk will load,
   * and will return the chunk to the callback at a later time.
   *
   * You should use this method if you need a chunk but do not need it
   * immediately, and you wish to let the server control the speed
   * of chunk loads, keeping performance in mind.
   *
   * The future will always be executed synchronously
   * on the main Server Thread.
   * @param block Block to load the corresponding chunk from
   * @param gen Should the chunk generate
   * @return Future that will resolve when the chunk is loaded
  */
  getChunkAtAsync(block: Block, gen: boolean): CompletableFuture<Chunk>;
  /**
   * Requests a {@link Chunk} to be loaded at the given coordinates
   *
   * This method makes no guarantee on how fast the chunk will load,
   * and will return the chunk to the callback at a later time.
   *
   * You should use this method if you need a chunk but do not need it
   * immediately, and you wish to let the server control the speed
   * of chunk loads, keeping performance in mind.
   *
   * The future will always be executed synchronously
   * on the main Server Thread.
   *
   * @param x X Coord
   * @param z Z Coord
   * @return Future that will resolve when the chunk is loaded
  */
  getChunkAtAsync(x: number, z: number): CompletableFuture<Chunk>;
  /**
   * Requests a {@link Chunk} to be loaded at the given coordinates
   *
   * This method makes no guarantee on how fast the chunk will load,
   * and will return the chunk to the callback at a later time.
   *
   * You should use this method if you need a chunk but do not need it
   * immediately, and you wish to let the server control the speed
   * of chunk loads, keeping performance in mind.
   *
   * The future will always be executed synchronously
   * on the main Server Thread.
   *
   * @param x Chunk X-coordinate of the chunk - (world coordinate / 16)
   * @param z Chunk Z-coordinate of the chunk - (world coordinate / 16)
   * @param gen Should we generate a chunk if it doesn't exists or not
   * @return Future that will resolve when the chunk is loaded
  */
  getChunkAtAsync(x: number, z: number, gen: boolean): CompletableFuture<Chunk>;
  /**
   * Requests a {@link Chunk} to be loaded at the given coordinates
   *
   * This method makes no guarantee on how fast the chunk will load,
   * and will return the chunk to the callback at a later time.
   *
   * You should use this method if you need a chunk but do not need it
   * immediately, and you wish to let the server control the speed
   * of chunk loads, keeping performance in mind.
   *
   * The future will always be executed synchronously
   * on the main Server Thread.
   * @param loc Location to load the corresponding chunk from
   * @return Future that will resolve when the chunk is loaded
  */
  getChunkAtAsyncUrgently(loc: Location): CompletableFuture<Chunk>;
  /**
   * Requests a {@link Chunk} to be loaded at the given coordinates
   *
   * This method makes no guarantee on how fast the chunk will load,
   * and will return the chunk to the callback at a later time.
   *
   * You should use this method if you need a chunk but do not need it
   * immediately, and you wish to let the server control the speed
   * of chunk loads, keeping performance in mind.
   *
   * The future will always be executed synchronously
   * on the main Server Thread.
   * @param loc Location to load the corresponding chunk from
   * @param gen Should the chunk generate
   * @return Future that will resolve when the chunk is loaded
  */
  getChunkAtAsyncUrgently(loc: Location, gen: boolean): CompletableFuture<Chunk>;
  /**
   * Requests a {@link Chunk} to be loaded at the given coordinates
   *
   * This method makes no guarantee on how fast the chunk will load,
   * and will return the chunk to the callback at a later time.
   *
   * You should use this method if you need a chunk but do not need it
   * immediately, and you wish to let the server control the speed
   * of chunk loads, keeping performance in mind.
   *
   * The future will always be executed synchronously
   * on the main Server Thread.
   * @param block Block to load the corresponding chunk from
   * @return Future that will resolve when the chunk is loaded
  */
  getChunkAtAsyncUrgently(block: Block): CompletableFuture<Chunk>;
  /**
   * Requests a {@link Chunk} to be loaded at the given coordinates
   *
   * This method makes no guarantee on how fast the chunk will load,
   * and will return the chunk to the callback at a later time.
   *
   * You should use this method if you need a chunk but do not need it
   * immediately, and you wish to let the server control the speed
   * of chunk loads, keeping performance in mind.
   *
   * The future will always be executed synchronously
   * on the main Server Thread.
   * @param block Block to load the corresponding chunk from
   * @param gen Should the chunk generate
   * @return Future that will resolve when the chunk is loaded
  */
  getChunkAtAsyncUrgently(block: Block, gen: boolean): CompletableFuture<Chunk>;
  /**
   * Requests a {@link Chunk} to be loaded at the given coordinates
   *
   * This method makes no guarantee on how fast the chunk will load,
   * and will return the chunk to the callback at a later time.
   *
   * You should use this method if you need a chunk but do not need it
   * immediately, and you wish to let the server control the speed
   * of chunk loads, keeping performance in mind.
   *
   * The future will always be executed synchronously
   * on the main Server Thread.
   *
   * @param x X Coord
   * @param z Z Coord
   * @return Future that will resolve when the chunk is loaded
  */
  getChunkAtAsyncUrgently(x: number, z: number): CompletableFuture<Chunk>;
  getChunkAtAsync(x: number, z: number, gen: boolean, urgent: boolean): CompletableFuture<Chunk>;
  /**
   * Get a list of all players in this World
   *
   * @return A list of all Players currently residing in this world
  */
  getPlayers(): Player[];
  audiences(): Iterable<Audience>;
  /**
   * Returns a list of entities within a bounding box centered around a
   * Location.
   * 
   * This may not consider entities in currently unloaded chunks. Some
   * implementations may impose artificial restrictions on the size of the
   * search bounding box.
   *
   * @param location The center of the bounding box
   * @param x 1/2 the size of the box along x axis
   * @param y 1/2 the size of the box along y axis
   * @param z 1/2 the size of the box along z axis
   * @return the collection of entities near location. This will always be a
   *      non-null collection.
  */
  getNearbyEntities(location: Location, x: number, y: number, z: number): Collection<Entity>;
  /**
   * Gets an entity in this world by its UUID
   *
   * @param uuid the UUID of the entity
   * @return the entity with the given UUID, or null if it isn't found
  */
  getEntity(uuid: UUID): Entity | null;
  /**
   * Returns a list of entities within a bounding box centered around a
   * Location.
   * 
   * This may not consider entities in currently unloaded chunks. Some
   * implementations may impose artificial restrictions on the size of the
   * search bounding box.
   *
   * @param location The center of the bounding box
   * @param x 1/2 the size of the box along x axis
   * @param y 1/2 the size of the box along y axis
   * @param z 1/2 the size of the box along z axis
   * @param filter only entities that fulfill this predicate are considered,
   *     or null to consider all entities
   * @return the collection of entities near location. This will always be a
   *     non-null collection.
  */
  getNearbyEntities(location: Location, x: number, y: number, z: number, filter: Predicate<Entity> | null): Collection<Entity>;
  /**
   * Returns a list of entities within the given bounding box.
   * 
   * This may not consider entities in currently unloaded chunks. Some
   * implementations may impose artificial restrictions on the size of the
   * search bounding box.
   *
   * @param boundingBox the bounding box
   * @return the collection of entities within the bounding box, will always
   *     be a non-null collection
  */
  getNearbyEntities(boundingBox: BoundingBox): Collection<Entity>;
  /**
   * Returns a list of entities within the given bounding box.
   * 
   * This may not consider entities in currently unloaded chunks. Some
   * implementations may impose artificial restrictions on the size of the
   * search bounding box.
   *
   * @param boundingBox the bounding box
   * @param filter only entities that fulfill this predicate are considered,
   *     or null to consider all entities
   * @return the collection of entities within the bounding box, will always
   *     be a non-null collection
  */
  getNearbyEntities(boundingBox: BoundingBox, filter: Predicate<Entity> | null): Collection<Entity>;
  /**
   * Performs a ray trace that checks for entity collisions.
   * 
   * This may not consider entities in currently unloaded chunks. Some
   * implementations may impose artificial restrictions on the maximum
   * distance.
   *
   * @param start the start position
   * @param direction the ray direction
   * @param maxDistance the maximum distance
   * @return the closest ray trace hit result, or null if there
   *     is no hit
   * @see #rayTraceEntities(Location, Vector, double, double, Predicate)
  */
  rayTraceEntities(start: Location, direction: Vector, maxDistance: number): RayTraceResult | null;
  /**
   * Performs a ray trace that checks for entity collisions.
   * 
   * This may not consider entities in currently unloaded chunks. Some
   * implementations may impose artificial restrictions on the maximum
   * distance.
   *
   * @param start the start position
   * @param direction the ray direction
   * @param maxDistance the maximum distance
   * @param raySize entity bounding boxes will be uniformly expanded (or
   *     shrinked) by this value before doing collision checks
   * @return the closest ray trace hit result, or null if there
   *     is no hit
   * @see #rayTraceEntities(Location, Vector, double, double, Predicate)
  */
  rayTraceEntities(start: Location, direction: Vector, maxDistance: number, raySize: number): RayTraceResult | null;
  /**
   * Performs a ray trace that checks for entity collisions.
   * 
   * This may not consider entities in currently unloaded chunks. Some
   * implementations may impose artificial restrictions on the maximum
   * distance.
   *
   * @param start the start position
   * @param direction the ray direction
   * @param maxDistance the maximum distance
   * @param filter only entities that fulfill this predicate are considered,
   *     or null to consider all entities
   * @return the closest ray trace hit result, or null if there
   *     is no hit
   * @see #rayTraceEntities(Location, Vector, double, double, Predicate)
  */
  rayTraceEntities(start: Location, direction: Vector, maxDistance: number, filter: Predicate<Entity> | null): RayTraceResult | null;
  /**
   * Performs a ray trace that checks for entity collisions.
   * 
   * This may not consider entities in currently unloaded chunks. Some
   * implementations may impose artificial restrictions on the maximum
   * distance.
   *
   * @param start the start position
   * @param direction the ray direction
   * @param maxDistance the maximum distance
   * @param raySize entity bounding boxes will be uniformly expanded (or
   *     shrinked) by this value before doing collision checks
   * @param filter only entities that fulfill this predicate are considered,
   *     or null to consider all entities
   * @return the closest ray trace hit result, or null if there
   *     is no hit
  */
  rayTraceEntities(start: Location, direction: Vector, maxDistance: number, raySize: number, filter: Predicate<Entity> | null): RayTraceResult | null;
  /**
   * Performs a ray trace that checks for block collisions using the blocks'
   * precise collision shapes.
   * 
   * This takes collisions with passable blocks into account, but ignores
   * fluids.
   * 
   * This may cause loading of chunks! Some implementations may impose
   * artificial restrictions on the maximum distance.
   *
   * @param start the start location
   * @param direction the ray direction
   * @param maxDistance the maximum distance
   * @return the ray trace hit result, or null if there is no hit
   * @see #rayTraceBlocks(Location, Vector, double, FluidCollisionMode, boolean)
  */
  rayTraceBlocks(start: Location, direction: Vector, maxDistance: number): RayTraceResult | null;
  /**
   * Performs a ray trace that checks for block collisions using the blocks'
   * precise collision shapes.
   * 
   * This takes collisions with passable blocks into account.
   * 
   * This may cause loading of chunks! Some implementations may impose
   * artificial restrictions on the maximum distance.
   *
   * @param start the start location
   * @param direction the ray direction
   * @param maxDistance the maximum distance
   * @param fluidCollisionMode the fluid collision mode
   * @return the ray trace hit result, or null if there is no hit
   * @see #rayTraceBlocks(Location, Vector, double, FluidCollisionMode, boolean)
  */
  rayTraceBlocks(start: Location, direction: Vector, maxDistance: number, fluidCollisionMode: FluidCollisionMode): RayTraceResult | null;
  /**
   * Performs a ray trace that checks for block collisions using the blocks'
   * precise collision shapes.
   * 
   * If collisions with passable blocks are ignored, fluid collisions are
   * ignored as well regardless of the fluid collision mode.
   * 
   * Portal blocks are only considered passable if the ray starts within
   * them. Apart from that collisions with portal blocks will be considered
   * even if collisions with passable blocks are otherwise ignored.
   * 
   * This may cause loading of chunks! Some implementations may impose
   * artificial restrictions on the maximum distance.
   *
   * @param start the start location
   * @param direction the ray direction
   * @param maxDistance the maximum distance
   * @param fluidCollisionMode the fluid collision mode
   * @param ignorePassableBlocks whether to ignore passable but collidable
   *     blocks (ex. tall grass, signs, fluids, ..)
   * @return the ray trace hit result, or null if there is no hit
  */
  rayTraceBlocks(start: Location, direction: Vector, maxDistance: number, fluidCollisionMode: FluidCollisionMode, ignorePassableBlocks: boolean): RayTraceResult | null;
  /**
   * Performs a ray trace that checks for both block and entity collisions.
   * 
   * Block collisions use the blocks' precise collision shapes. The
   * raySize parameter is only taken into account for entity
   * collision checks.
   * 
   * If collisions with passable blocks are ignored, fluid collisions are
   * ignored as well regardless of the fluid collision mode.
   * 
   * Portal blocks are only considered passable if the ray starts within them.
   * Apart from that collisions with portal blocks will be considered even if
   * collisions with passable blocks are otherwise ignored.
   * 
   * This may cause loading of chunks! Some implementations may impose
   * artificial restrictions on the maximum distance.
   *
   * @param start the start location
   * @param direction the ray direction
   * @param maxDistance the maximum distance
   * @param fluidCollisionMode the fluid collision mode
   * @param ignorePassableBlocks whether to ignore passable but collidable
   *     blocks (ex. tall grass, signs, fluids, ..)
   * @param raySize entity bounding boxes will be uniformly expanded (or
   *     shrinked) by this value before doing collision checks
   * @param filter only entities that fulfill this predicate are considered,
   *     or null to consider all entities
   * @return the closest ray trace hit result with either a block or an
   *     entity, or null if there is no hit
  */
  rayTrace(start: Location, direction: Vector, maxDistance: number, fluidCollisionMode: FluidCollisionMode, ignorePassableBlocks: boolean, raySize: number, filter: Predicate<Entity> | null): RayTraceResult | null;
  /**
   * Gets the default spawn {@link Location} of this world
   *
   * @return The spawn location of this world
  */
  getSpawnLocation(): Location;
  /**
   * Sets the spawn location of the world.
   * 
   * The location provided must be equal to this world.
   *
   * @param location The {@link Location} to set the spawn for this world at.
   * @return True if it was successfully set.
  */
  setSpawnLocation(spawnLocation: Location);
  /**
   * Sets the spawn location of the world
   *
   * @param x X coordinate
   * @param y Y coordinate
   * @param z Z coordinate
   * @param angle the angle
   * @return True if it was successfully set.
  */
  setSpawnLocation(x: number, y: number, z: number, angle: number): boolean;
  /**
   * Sets the spawn location of the world
   *
   * @param x X coordinate
   * @param y Y coordinate
   * @param z Z coordinate
   * @return True if it was successfully set.
  */
  setSpawnLocation(x: number, y: number, z: number): boolean;
  /**
   * Gets the relative in-game time of this world.
   * 
   * The relative time is analogous to hours * 1000
   *
   * @return The current relative time
   * @see #getFullTime() Returns an absolute time of this world
  */
  getTime(): number;
  /**
   * Sets the relative in-game time on the server.
   * 
   * The relative time is analogous to hours * 1000
   * 
   * Note that setting the relative time below the current relative time
   * will actually move the clock forward a day. If you require to rewind
   * time, please see {@link #setFullTime(long)}
   *
   * @param time The new relative time to set the in-game time to (in
   *     hours*1000)
   * @see #setFullTime(long) Sets the absolute time of this world
  */
  setTime(time: number);
  /**
   * Gets the full in-game time on this world
   *
   * @return The current absolute time
   * @see #getTime() Returns a relative time of this world
  */
  getFullTime(): number;
  /**
   * Sets the in-game time on the server
   * 
   * Note that this sets the full time of the world, which may cause adverse
   * effects such as breaking redstone clocks and any scheduled events
   *
   * @param time The new absolute time to set this world to
   * @see #setTime(long) Sets the relative time of this world
  */
  setFullTime(fullTime: number);
  /**
   * Check if it is currently daytime in this world
   *
   * @return True if it is daytime
  */
  isDayTime(): boolean;
  /**
   * Gets the full in-game time on this world since the world generation
   *
   * @return The current absolute time since the world generation
   * @see #getTime() Returns a relative time of this world
   * @see #getFullTime() Returns an absolute time of this world
  */
  getGameTime(): number;
  /**
   * Returns whether the world has an ongoing storm.
   *
   * @return Whether there is an ongoing storm
  */
  hasStorm(): boolean;
  /**
   * Set whether there is a storm. A duration will be set for the new
   * current conditions.
   *
   * This will implicitly call {@link #setClearWeatherDuration(int)} with 0
   * ticks to reset the world's clear weather.
   *
   * @param hasStorm Whether there is rain and snow
  */
  setStorm(hasStorm: boolean): void;
  /**
   * Get the remaining time in ticks of the current conditions.
   *
   * @return Time in ticks
  */
  getWeatherDuration(): number;
  /**
   * Set the remaining time in ticks of the current conditions.
   *
   * @param duration Time in ticks
  */
  setWeatherDuration(weatherDuration: number);
  /**
   * Returns whether there is thunder.
   *
   * @return Whether there is thunder
  */
  isThundering(): boolean;
  /**
   * Set whether it is thundering.
   *
   * This will implicitly call {@link #setClearWeatherDuration(int)} with 0
   * ticks to reset the world's clear weather.
   *
   * @param thundering Whether it is thundering
  */
  setThundering(thundering: boolean): void;
  /**
   * Get the thundering duration.
   *
   * @return Duration in ticks
  */
  getThunderDuration(): number;
  /**
   * Set the thundering duration.
   *
   * @param duration Duration in ticks
  */
  setThunderDuration(thunderDuration: number);
  /**
   * Returns whether the world has clear weather.
   *
   * This will be true such that {@link #isThundering()} and
   * {@link #hasStorm()} are both false.
   *
   * @return true if clear weather
  */
  isClearWeather(): boolean;
  /**
   * Set the clear weather duration.
   *
   * The clear weather ticks determine whether or not the world will be
   * allowed to rain or storm. If clear weather ticks are > 0, the world will
   * not naturally do either until the duration has elapsed.
   *
   * This method is equivalent to calling `/weather clear` with a set
   * amount of ticks.
   *
   * @param duration duration in ticks
  */
  setClearWeatherDuration(clearWeatherDuration: number);
  /**
   * Get the clear weather duration.
   *
   * @return duration in ticks
  */
  getClearWeatherDuration(): number;
  /**
   * Creates explosion at given coordinates with given power
   *
   * @param x X coordinate
   * @param y Y coordinate
   * @param z Z coordinate
   * @param power The power of explosion, where 4F is TNT
   * @return false if explosion was canceled, otherwise true
  */
  createExplosion(x: number, y: number, z: number, power: number): boolean;
  /**
   * Creates explosion at given coordinates with given power and optionally
   * setting blocks on fire.
   *
   * @param x X coordinate
   * @param y Y coordinate
   * @param z Z coordinate
   * @param power The power of explosion, where 4F is TNT
   * @param setFire Whether or not to set blocks on fire
   * @return false if explosion was canceled, otherwise true
  */
  createExplosion(x: number, y: number, z: number, power: number, setFire: boolean): boolean;
  /**
   * Creates explosion at given coordinates with given power and optionally
   * setting blocks on fire or breaking blocks.
   *
   * @param x X coordinate
   * @param y Y coordinate
   * @param z Z coordinate
   * @param power The power of explosion, where 4F is TNT
   * @param setFire Whether or not to set blocks on fire
   * @param breakBlocks Whether or not to have blocks be destroyed
   * @return false if explosion was canceled, otherwise true
  */
  createExplosion(x: number, y: number, z: number, power: number, setFire: boolean, breakBlocks: boolean): boolean;
  /**
   * Creates explosion at given coordinates with given power and optionally
   * setting blocks on fire or breaking blocks.
   *
   * @param x X coordinate
   * @param y Y coordinate
   * @param z Z coordinate
   * @param power The power of explosion, where 4F is TNT
   * @param setFire Whether or not to set blocks on fire
   * @param breakBlocks Whether or not to have blocks be destroyed
   * @param source the source entity, used for tracking damage
   * @return false if explosion was canceled, otherwise true
  */
  createExplosion(x: number, y: number, z: number, power: number, setFire: boolean, breakBlocks: boolean, source: Entity | null): boolean;
  /**
   * Creates explosion at given coordinates with given power
   *
   * @param loc Location to blow up
   * @param power The power of explosion, where 4F is TNT
   * @return false if explosion was canceled, otherwise true
  */
  createExplosion(loc: Location, power: number): boolean;
  /**
   * Creates explosion at given coordinates with given power and optionally
   * setting blocks on fire.
   *
   * @param loc Location to blow up
   * @param power The power of explosion, where 4F is TNT
   * @param setFire Whether or not to set blocks on fire
   * @return false if explosion was canceled, otherwise true
  */
  createExplosion(loc: Location, power: number, setFire: boolean): boolean;
  /**
   * Creates explosion at given location with given power and optionally
   * setting blocks on fire, with the specified entity as the source.
   *
   * @param source The source entity of the explosion
   * @param loc Location to blow up
   * @param power The power of explosion, where 4F is TNT
   * @param setFire Whether or not to set blocks on fire
   * @param breakBlocks Whether or not to have blocks be destroyed
   * @return false if explosion was canceled, otherwise true
  */
  createExplosion(source: Entity | null, loc: Location, power: number, setFire: boolean, breakBlocks: boolean): boolean;
  /**
   * Creates explosion at given location with given power and optionally
   * setting blocks on fire, with the specified entity as the source.
   *
   * Will destroy other blocks
   *
   * @param source The source entity of the explosion
   * @param loc Location to blow up
   * @param power The power of explosion, where 4F is TNT
   * @param setFire Whether or not to set blocks on fire
   * @return false if explosion was canceled, otherwise true
  */
  createExplosion(source: Entity | null, loc: Location, power: number, setFire: boolean): boolean;
  /**
   * Creates explosion at given location with given power, with the specified entity as the source.
   * Will set blocks on fire and destroy blocks.
   *
   * @param source The source entity of the explosion
   * @param loc Location to blow up
   * @param power The power of explosion, where 4F is TNT
   * @return false if explosion was canceled, otherwise true
  */
  createExplosion(source: Entity | null, loc: Location, power: number): boolean;
  /**
   * Creates explosion at given entities location with given power and optionally
   * setting blocks on fire, with the specified entity as the source.
   *
   * @param source The source entity of the explosion
   * @param power The power of explosion, where 4F is TNT
   * @param setFire Whether or not to set blocks on fire
   * @param breakBlocks Whether or not to have blocks be destroyed
   * @return false if explosion was canceled, otherwise true
  */
  createExplosion(source: Entity, power: number, setFire: boolean, breakBlocks: boolean): boolean;
  /**
   * Creates explosion at given entities location with given power and optionally
   * setting blocks on fire, with the specified entity as the source.
   *
   * Will destroy blocks.
   *
   * @param source The source entity of the explosion
   * @param power The power of explosion, where 4F is TNT
   * @param setFire Whether or not to set blocks on fire
   * @return false if explosion was canceled, otherwise true
  */
  createExplosion(source: Entity, power: number, setFire: boolean): boolean;
  /**
   * Creates explosion at given entities location with given power and optionally
   * setting blocks on fire, with the specified entity as the source.
   *
   * @param source The source entity of the explosion
   * @param power The power of explosion, where 4F is TNT
   * @return false if explosion was canceled, otherwise true
  */
  createExplosion(source: Entity, power: number): boolean;
  /**
   * Creates explosion at given coordinates with given power and optionally
   * setting blocks on fire or breaking blocks.
   *
   * @param loc Location to blow up
   * @param power The power of explosion, where 4F is TNT
   * @param setFire Whether or not to set blocks on fire
   * @param breakBlocks Whether or not to have blocks be destroyed
   * @return false if explosion was canceled, otherwise true
  */
  createExplosion(loc: Location, power: number, setFire: boolean, breakBlocks: boolean): boolean;
  /**
   * Creates explosion at given coordinates with given power and optionally
   * setting blocks on fire or breaking blocks.
   *
   * @param loc Location to blow up
   * @param power The power of explosion, where 4F is TNT
   * @param setFire Whether or not to set blocks on fire
   * @param breakBlocks Whether or not to have blocks be destroyed
   * @param source the source entity, used for tracking damage
   * @return false if explosion was canceled, otherwise true
  */
  createExplosion(loc: Location, power: number, setFire: boolean, breakBlocks: boolean, source: Entity | null): boolean;
  /**
   * Gets the current PVP setting for this world.
   *
   * @return True if PVP is enabled
  */
  getPVP(): boolean;
  /**
   * Sets the PVP setting for this world.
   *
   * @param pvp True/False whether PVP should be Enabled.
  */
  setPVP(pvp: boolean): void;
  /**
   * Gets the chunk generator for this world
   *
   * @return ChunkGenerator associated with this world
  */
  getGenerator(): ChunkGenerator | null;
  /**
   * Gets the biome provider for this world
   *
   * @return BiomeProvider associated with this world
  */
  getBiomeProvider(): BiomeProvider | null;
  /**
   * Saves world to disk
  */
  save(): void;
  /**
   * Gets a list of all applied {@link BlockPopulator}s for this World
   *
   * @return List containing any or none BlockPopulators
  */
  getPopulators(): BlockPopulator[];
  /**
   * Spawn a {@link FallingBlock} entity at the given {@link Location} of
   * the specified {@link Material}. The material dictates what is falling.
   * When the FallingBlock hits the ground, it will place that block.
   * 
   * The Material must be a block type, check with {@link Material#isBlock()
   * material.isBlock()}. The Material may not be air.
   *
   * @param location The {@link Location} to spawn the FallingBlock
   * @param data The block data
   * @return The spawned {@link FallingBlock} instance
   * @throws IllegalArgumentException if {@link Location} or {@link
   *     MaterialData} are null or {@link Material} of the {@link MaterialData} is not a block
   * @deprecated use {@link #spawnFallingBlock(Location, BlockData)}
  */
  spawnFallingBlock(location: Location, data: MaterialData): FallingBlock;
  /**
   * Spawn a {@link FallingBlock} entity at the given {@link Location} of
   * the specified {@link Material}. The material dictates what is falling.
   * When the FallingBlock hits the ground, it will place that block.
   * 
   * The Material must be a block type, check with {@link Material#isBlock()
   * material.isBlock()}. The Material may not be air.
   *
   * @param location The {@link Location} to spawn the FallingBlock
   * @param data The block data
   * @return The spawned {@link FallingBlock} instance
   * @throws IllegalArgumentException if {@link Location} or {@link
   *     BlockData} are null
  */
  spawnFallingBlock(location: Location, data: BlockData): FallingBlock;
  /**
   * Spawn a {@link FallingBlock} entity at the given {@link Location} of the
   * specified {@link Material}. The material dictates what is falling.
   * When the FallingBlock hits the ground, it will place that block.
   * 
   * The Material must be a block type, check with {@link Material#isBlock()
   * material.isBlock()}. The Material may not be air.
   *
   * @param location The {@link Location} to spawn the FallingBlock
   * @param material The block {@link Material} type
   * @param data The block data
   * @return The spawned {@link FallingBlock} instance
   * @throws IllegalArgumentException if {@link Location} or {@link
   *     Material} are null or {@link Material} is not a block
   * @deprecated Magic value
  */
  spawnFallingBlock(location: Location, material: Material, data: number): FallingBlock;
  /**
   * Plays an effect to all players within a default radius around a given
   * location.
   *
   * @param location the {@link Location} around which players must be to
   *     hear the sound
   * @param effect the {@link Effect}
   * @param data a data bit needed for some effects
  */
  playEffect(location: Location, effect: Effect, data: number): void;
  /**
   * Plays an effect to all players within a given radius around a location.
   *
   * @param location the {@link Location} around which players must be to
   *     hear the effect
   * @param effect the {@link Effect}
   * @param data a data bit needed for some effects
   * @param radius the radius around the location
  */
  playEffect(location: Location, effect: Effect, data: number, radius: number): void;
  /**
   * Plays an effect to all players within a default radius around a given
   * location.
   *
   * @param  data dependant on the type of effect
   * @param location the {@link Location} around which players must be to
   *     hear the sound
   * @param effect the {@link Effect}
   * @param data a data bit needed for some effects
  */
  playEffect<T>(location: Location, effect: Effect, data: T | null): void;
  /**
   * Plays an effect to all players within a given radius around a location.
   *
   * @param  data dependant on the type of effect
   * @param location the {@link Location} around which players must be to
   *     hear the effect
   * @param effect the {@link Effect}
   * @param data a data bit needed for some effects
   * @param radius the radius around the location
  */
  playEffect<T>(location: Location, effect: Effect, data: T | null, radius: number): void;
  /**
   * Get empty chunk snapshot (equivalent to all air blocks), optionally
   * including valid biome data. Used for representing an ungenerated chunk,
   * or for fetching only biome data without loading a chunk.
   *
   * @param x - chunk x coordinate
   * @param z - chunk z coordinate
   * @param includeBiome - if true, snapshot includes per-coordinate biome
   *     type
   * @param includeBiomeTemp - if true, snapshot includes per-coordinate
   *     raw biome temperature
   * @return The empty snapshot.
  */
  getEmptyChunkSnapshot(x: number, z: number, includeBiome: boolean, includeBiomeTemp: boolean): ChunkSnapshot;
  /**
   * Sets the spawn flags for this.
   *
   * @param allowMonsters - if true, monsters are allowed to spawn in this
   *     world.
   * @param allowAnimals - if true, animals are allowed to spawn in this
   *     world.
  */
  setSpawnFlags(allowMonsters: boolean, allowAnimals: boolean): void;
  /**
   * Gets whether animals can spawn in this world.
   *
   * @return whether animals can spawn in this world.
  */
  getAllowAnimals(): boolean;
  /**
   * Gets whether monsters can spawn in this world.
   *
   * @return whether monsters can spawn in this world.
  */
  getAllowMonsters(): boolean;
  /**
   * Gets the biome for the given block coordinates.
   *
   * @param x X coordinate of the block
   * @param z Z coordinate of the block
   * @return Biome of the requested block
   * @deprecated biomes are now 3-dimensional
  */
  getBiome(x: number, z: number): Biome;
  /**
   * Sets the biome for the given block coordinates
   *
   * @param x X coordinate of the block
   * @param z Z coordinate of the block
   * @param bio new Biome type for this block
   * @deprecated biomes are now 3-dimensional
  */
  setBiome(x: number, z: number, bio: Biome): void;
  /**
   * Gets the temperature for the given block coordinates.
   * 
   * It is safe to run this method when the block does not exist, it will
   * not create the block.
   * 
   * This method will return the raw temperature without adjusting for block
   * height effects.
   *
   * @param x X coordinate of the block
   * @param z Z coordinate of the block
   * @return Temperature of the requested block
   * @deprecated biomes are now 3-dimensional
  */
  getTemperature(x: number, z: number): number;
  /**
   * Gets the temperature for the given block coordinates.
   * 
   * It is safe to run this method when the block does not exist, it will
   * not create the block.
   * 
   * This method will return the raw temperature without adjusting for block
   * height effects.
   *
   * @param x X coordinate of the block
   * @param y Y coordinate of the block
   * @param z Z coordinate of the block
   * @return Temperature of the requested block
  */
  getTemperature(x: number, y: number, z: number): number;
  /**
   * Gets the humidity for the given block coordinates.
   * 
   * It is safe to run this method when the block does not exist, it will
   * not create the block.
   *
   * @param x X coordinate of the block
   * @param z Z coordinate of the block
   * @return Humidity of the requested block
   * @deprecated biomes are now 3-dimensional
  */
  getHumidity(x: number, z: number): number;
  /**
   * Gets the humidity for the given block coordinates.
   * 
   * It is safe to run this method when the block does not exist, it will
   * not create the block.
   *
   * @param x X coordinate of the block
   * @param y Y coordinate of the block
   * @param z Z coordinate of the block
   * @return Humidity of the requested block
  */
  getHumidity(x: number, y: number, z: number): number;
  /**
   * Gets the maximum height to which chorus fruits and nether portals can
   * bring players within this dimension.
   *
   * This excludes portals that were already built above the limit as they
   * still connect normally. May not be greater than {@link #getMaxHeight()}.
   *
   * @return maximum logical height for chorus fruits and nether portals
  */
  getLogicalHeight(): number;
  /**
   * Gets if this world is natural.
   *
   * When false, compasses spin randomly, and using a bed to set the respawn
   * point or sleep, is disabled. When true, nether portals can spawn
   * zombified piglins.
   *
   * @return true if world is natural
  */
  isNatural(): boolean;
  /**
   * Gets if beds work in this world.
   *
   * A non-working bed will blow up when trying to sleep. {@link #isNatural()}
   * defines if a bed can be used to set spawn point.
   *
   * @return true if beds work in this world
  */
  isBedWorks(): boolean;
  /**
   * Gets if this world has skylight access.
   *
   * @return true if this world has skylight access
  */
  hasSkyLight(): boolean;
  /**
   * Gets if this world has a ceiling.
   *
   * @return true if this world has a bedrock ceiling
  */
  hasCeiling(): boolean;
  /**
   * Gets if this world allow to piglins to survive without shaking and
   * transforming to zombified piglins.
   *
   * @return true if piglins will not transform to zombified piglins
  */
  isPiglinSafe(): boolean;
  /**
   * Gets if this world allows players to charge and use respawn anchors.
   *
   * @return true if players can charge and use respawn anchors
  */
  isRespawnAnchorWorks(): boolean;
  /**
   * Gets if players with the bad omen effect in this world will trigger a
   * raid.
   *
   * @return true if raids will be triggered
  */
  hasRaids(): boolean;
  /**
   * Gets if various water/lava mechanics will be triggered in this world, eg:
   * 
   * 
   * Water is evaporated
   * Sponges dry
   * Lava spreads faster and further
   * 
   *
   * @return true if this world has the above mechanics
  */
  isUltraWarm(): boolean;
  /**
   * Gets the sea level for this world.
   * 
   * This is often half of {@link #getMaxHeight()}
   *
   * @return Sea level
  */
  getSeaLevel(): number;
  /**
   * Gets whether the world's spawn area should be kept loaded into memory
   * or not.
   *
   * @return true if the world's spawn area will be kept loaded into memory.
  */
  getKeepSpawnInMemory(): boolean;
  /**
   * Sets whether the world's spawn area should be kept loaded into memory
   * or not.
   *
   * @param keepLoaded if true then the world's spawn area will be kept
   *     loaded into memory.
  */
  setKeepSpawnInMemory(keepLoaded: boolean): void;
  /**
   * Gets whether or not the world will automatically save
   *
   * @return true if the world will automatically save, otherwise false
  */
  isAutoSave(): boolean;
  /**
   * Sets whether or not the world will automatically save
   *
   * @param value true if the world should automatically save, otherwise
   *     false
  */
  setAutoSave(value: boolean): void;
  /**
   * Sets the Difficulty of the world.
   *
   * @param difficulty the new difficulty you want to set the world to
  */
  setDifficulty(difficulty: Difficulty);
  /**
   * Gets the Difficulty of the world.
   *
   * @return The difficulty of the world.
  */
  getDifficulty(): Difficulty;
  /**
   * Gets the folder of this world on disk.
   *
   * @return The folder of this world.
  */
  getWorldFolder(): File;
  /**
   * Gets the type of this world.
   *
   * @return Type of this world.
   * @deprecated world type is only used to select the default word generation
   * settings and is not stored in Vanilla worlds, making it impossible for
   * this method to always return the correct value.
  */
  getWorldType(): WorldType | null;
  /**
   * Gets whether or not structures are being generated.
   *
   * @return True if structures are being generated.
  */
  canGenerateStructures(): boolean;
  /**
   * Gets whether the world is hardcore or not.
   *
   * In a hardcore world the difficulty is locked to hard.
   *
   * @return hardcore status
  */
  isHardcore(): boolean;
  /**
   * Sets whether the world is hardcore or not.
   *
   * In a hardcore world the difficulty is locked to hard.
   *
   * @param hardcore Whether the world is hardcore
  */
  setHardcore(hardcore: boolean): void;
  /**
   * Gets the world's ticks per animal spawns value
   * 
   * This value determines how many ticks there are between attempts to
   * spawn animals.
   * 
   * Example Usage:
   * 
   * A value of 1 will mean the server will attempt to spawn animals in
   *     this world every tick.
   * A value of 400 will mean the server will attempt to spawn animals
   *     in this world every 400th tick.
   * A value below 0 will be reset back to Minecraft's default.
   * 
   * 
   * Note:
   * If set to 0, animal spawning will be disabled for this world. We
   * recommend using {@link #setSpawnFlags(boolean, boolean)} to control
   * this instead.
   * 
   * Minecraft default: 400.
   *
   * @return The world's ticks per animal spawns value
   * @deprecated Deprecated in favor of {@link #getTicksPerSpawns(SpawnCategory)}
  */
  getTicksPerAnimalSpawns(): number;
  /**
   * Sets the world's ticks per animal spawns value
   * 
   * This value determines how many ticks there are between attempts to
   * spawn animals.
   * 
   * Example Usage:
   * 
   * A value of 1 will mean the server will attempt to spawn animals in
   *     this world every tick.
   * A value of 400 will mean the server will attempt to spawn animals
   *     in this world every 400th tick.
   * A value below 0 will be reset back to Minecraft's default.
   * 
   * 
   * Note:
   * If set to 0, animal spawning will be disabled for this world. We
   * recommend using {@link #setSpawnFlags(boolean, boolean)} to control
   * this instead.
   * 
   * Minecraft default: 400.
   *
   * @param ticksPerAnimalSpawns the ticks per animal spawns value you want
   *     to set the world to
   * @deprecated Deprecated in favor of {@link #setTicksPerSpawns(SpawnCategory, int)}
  */
  setTicksPerAnimalSpawns(ticksPerAnimalSpawns: number);
  /**
   * Gets the world's ticks per monster spawns value
   * 
   * This value determines how many ticks there are between attempts to
   * spawn monsters.
   * 
   * Example Usage:
   * 
   * A value of 1 will mean the server will attempt to spawn monsters in
   *     this world every tick.
   * A value of 400 will mean the server will attempt to spawn monsters
   *     in this world every 400th tick.
   * A value below 0 will be reset back to Minecraft's default.
   * 
   * 
   * Note:
   * If set to 0, monsters spawning will be disabled for this world. We
   * recommend using {@link #setSpawnFlags(boolean, boolean)} to control
   * this instead.
   * 
   * Minecraft default: 1.
   *
   * @return The world's ticks per monster spawns value
   * @deprecated Deprecated in favor of {@link #getTicksPerSpawns(SpawnCategory)}
  */
  getTicksPerMonsterSpawns(): number;
  /**
   * Sets the world's ticks per monster spawns value
   * 
   * This value determines how many ticks there are between attempts to
   * spawn monsters.
   * 
   * Example Usage:
   * 
   * A value of 1 will mean the server will attempt to spawn monsters in
   *     this world on every tick.
   * A value of 400 will mean the server will attempt to spawn monsters
   *     in this world every 400th tick.
   * A value below 0 will be reset back to Minecraft's default.
   * 
   * 
   * Note:
   * If set to 0, monsters spawning will be disabled for this world. We
   * recommend using {@link #setSpawnFlags(boolean, boolean)} to control
   * this instead.
   * 
   * Minecraft default: 1.
   *
   * @param ticksPerMonsterSpawns the ticks per monster spawns value you
   *     want to set the world to
   * @deprecated Deprecated in favor of {@link #setTicksPerSpawns(SpawnCategory, int)}
  */
  setTicksPerMonsterSpawns(ticksPerMonsterSpawns: number);
  /**
   * Gets the world's ticks per water mob spawns value
   * 
   * This value determines how many ticks there are between attempts to
   * spawn water mobs.
   * 
   * Example Usage:
   * 
   * A value of 1 will mean the server will attempt to spawn water mobs in
   *     this world every tick.
   * A value of 400 will mean the server will attempt to spawn water mobs
   *     in this world every 400th tick.
   * A value below 0 will be reset back to Minecraft's default.
   * 
   * 
   * Note:
   * If set to 0, water mobs spawning will be disabled for this world.
   * 
   * Minecraft default: 1.
   *
   * @return The world's ticks per water mob spawns value
   * @deprecated Deprecated in favor of {@link #getTicksPerSpawns(SpawnCategory)}
  */
  getTicksPerWaterSpawns(): number;
  /**
   * Sets the world's ticks per water mob spawns value
   * 
   * This value determines how many ticks there are between attempts to
   * spawn water mobs.
   * 
   * Example Usage:
   * 
   * A value of 1 will mean the server will attempt to spawn water mobs in
   *     this world on every tick.
   * A value of 400 will mean the server will attempt to spawn water mobs
   *     in this world every 400th tick.
   * A value below 0 will be reset back to Minecraft's default.
   * 
   * 
   * Note:
   * If set to 0, water mobs spawning will be disabled for this world.
   * 
   * Minecraft default: 1.
   *
   * @param ticksPerWaterSpawns the ticks per water mob spawns value you
   *     want to set the world to
   * @deprecated Deprecated in favor of {@link #setTicksPerSpawns(SpawnCategory, int)}
  */
  setTicksPerWaterSpawns(ticksPerWaterSpawns: number);
  /**
   * Gets the default ticks per water ambient mob spawns value.
   * 
   * Example Usage:
   * 
   * A value of 1 will mean the server will attempt to spawn water ambient mobs
   *     every tick.
   * A value of 400 will mean the server will attempt to spawn water ambient mobs
   *     every 400th tick.
   * A value below 0 will be reset back to Minecraft's default.
   * 
   * 
   * Note: If set to 0, ambient mobs spawning will be disabled.
   * 
   * Minecraft default: 1.
   *
   * @return the default ticks per water ambient mobs spawn value
   * @deprecated Deprecated in favor of {@link #getTicksPerSpawns(SpawnCategory)}
  */
  getTicksPerWaterAmbientSpawns(): number;
  /**
   * Sets the world's ticks per water ambient mob spawns value
   * 
   * This value determines how many ticks there are between attempts to
   * spawn water ambient mobs.
   * 
   * Example Usage:
   * 
   * A value of 1 will mean the server will attempt to spawn water ambient mobs in
   *     this world on every tick.
   * A value of 400 will mean the server will attempt to spawn weater ambient mobs
   *     in this world every 400th tick.
   * A value below 0 will be reset back to Minecraft's default.
   * 
   * 
   * Note:
   * If set to 0, water ambient mobs spawning will be disabled for this world.
   * 
   * Minecraft default: 1.
   *
   * @param ticksPerAmbientSpawns the ticks per water ambient mob spawns value you
   *     want to set the world to
   * @deprecated Deprecated in favor of {@link #setTicksPerSpawns(SpawnCategory, int)}
  */
  setTicksPerWaterAmbientSpawns(ticksPerWaterAmbientSpawns: number);
  /**
   * Gets the default ticks per water underground creature spawns value.
   * 
   * Example Usage:
   * 
   * A value of 1 will mean the server will attempt to spawn water underground creature
   *     every tick.
   * A value of 400 will mean the server will attempt to spawn water underground creature
   *     every 400th tick.
   * A value below 0 will be reset back to Minecraft's default.
   * 
   * 
   * Note: If set to 0, water underground creature spawning will be disabled.
   * 
   * Minecraft default: 1.
   *
   * @return the default ticks per water underground creature spawn value
   * @deprecated Deprecated in favor of {@link #getTicksPerSpawns(SpawnCategory)}
  */
  getTicksPerWaterUndergroundCreatureSpawns(): number;
  /**
   * Sets the world's ticks per water underground creature spawns value
   * 
   * This value determines how many ticks there are between attempts to
   * spawn water underground creature.
   * 
   * Example Usage:
   * 
   * A value of 1 will mean the server will attempt to spawn water underground creature in
   *     this world on every tick.
   * A value of 400 will mean the server will attempt to spawn water underground creature
   *     in this world every 400th tick.
   * A value below 0 will be reset back to Minecraft's default.
   * 
   * 
   * Note:
   * If set to 0, water underground creature spawning will be disabled for this world.
   * 
   * Minecraft default: 1.
   *
   * @param ticksPerWaterUndergroundCreatureSpawns the ticks per water underground creature spawns value you
   *     want to set the world to
   * @deprecated Deprecated in favor of {@link #setTicksPerSpawns(SpawnCategory, int)}
  */
  setTicksPerWaterUndergroundCreatureSpawns(ticksPerWaterUndergroundCreatureSpawns: number);
  /**
   * Gets the world's ticks per ambient mob spawns value
   * 
   * This value determines how many ticks there are between attempts to
   * spawn ambient mobs.
   * 
   * Example Usage:
   * 
   * A value of 1 will mean the server will attempt to spawn ambient mobs in
   *     this world every tick.
   * A value of 400 will mean the server will attempt to spawn ambient mobs
   *     in this world every 400th tick.
   * A value below 0 will be reset back to Minecraft's default.
   * 
   * 
   * Note:
   * If set to 0, ambient mobs spawning will be disabled for this world.
   * 
   * Minecraft default: 1.
   *
   * @return the default ticks per ambient mobs spawn value
   * @deprecated Deprecated in favor of {@link #getTicksPerSpawns(SpawnCategory)}
  */
  getTicksPerAmbientSpawns(): number;
  /**
   * Sets the world's ticks per ambient mob spawns value
   * 
   * This value determines how many ticks there are between attempts to
   * spawn ambient mobs.
   * 
   * Example Usage:
   * 
   * A value of 1 will mean the server will attempt to spawn ambient mobs in
   *     this world on every tick.
   * A value of 400 will mean the server will attempt to spawn ambient mobs
   *     in this world every 400th tick.
   * A value below 0 will be reset back to Minecraft's default.
   * 
   * 
   * Note:
   * If set to 0, ambient mobs spawning will be disabled for this world.
   * 
   * Minecraft default: 1.
   *
   * @param ticksPerAmbientSpawns the ticks per ambient mob spawns value you
   *     want to set the world to
   * @deprecated Deprecated in favor of {@link #setTicksPerSpawns(SpawnCategory, int)}
  */
  setTicksPerAmbientSpawns(ticksPerAmbientSpawns: number);
  /**
   * Gets the world's ticks per {@link SpawnCategory} mob spawns value
   * 
   * This value determines how many ticks there are between attempts to
   * spawn {@link SpawnCategory} mobs.
   * 
   * Example Usage:
   * 
   * A value of 1 will mean the server will attempt to spawn {@link SpawnCategory} mobs in
   *     this world every tick.
   * A value of 400 will mean the server will attempt to spawn {@link SpawnCategory} mobs
   *     in this world every 400th tick.
   * A value below 0 will be reset back to Minecraft's default.
   * 
   * 
   * Note:
   * If set to 0, {@link SpawnCategory} mobs spawning will be disabled for this world.
   * 
   * Minecraft default: 1.
   *
   * @param spawnCategory the category spawn
   * @return The world's ticks per {@link SpawnCategory} mob spawns value
  */
  getTicksPerSpawns(spawnCategory: SpawnCategory): number;
  /**
   * Sets the world's ticks per {@link SpawnCategory} mob spawns value
   * 
   * This value determines how many ticks there are between attempts to
   * spawn {@link SpawnCategory} mobs.
   * 
   * Example Usage:
   * 
   * A value of 1 will mean the server will attempt to spawn {@link SpawnCategory} mobs in
   *     this world on every tick.
   * A value of 400 will mean the server will attempt to spawn {@link SpawnCategory} mobs
   *     in this world every 400th tick.
   * A value below 0 will be reset back to Minecraft's default.
   * 
   * 
   * Note:
   * If set to 0, {@link SpawnCategory} mobs spawning will be disabled for this world.
   * 
   * Minecraft default: 1.
   *
   * @param spawnCategory the category spawn
   * @param ticksPerCategorySpawn the ticks per {@link SpawnCategory} mob spawns value you
   *     want to set the world to
  */
  setTicksPerSpawns(spawnCategory: SpawnCategory, ticksPerCategorySpawn: number): void;
  /**
   * Gets limit for number of monsters that can spawn in a chunk in this
   * world
   *
   * @return The monster spawn limit
   * @deprecated Deprecated in favor of {@link #getSpawnLimit(SpawnCategory)}
  */
  getMonsterSpawnLimit(): number;
  /**
   * Sets the limit for number of monsters that can spawn in a chunk in this
   * world
   * 
   * Note: If set to a negative number the world will use the
   * server-wide spawn limit instead.
   *
   * @param limit the new mob limit
   * @deprecated Deprecated in favor of {@link #setSpawnLimit(SpawnCategory, int)}
  */
  setMonsterSpawnLimit(monsterSpawnLimit: number);
  /**
   * Gets the limit for number of animals that can spawn in a chunk in this
   * world
   *
   * @return The animal spawn limit
   * @deprecated Deprecated in favor of {@link #getSpawnLimit(SpawnCategory)}
  */
  getAnimalSpawnLimit(): number;
  /**
   * Sets the limit for number of animals that can spawn in a chunk in this
   * world
   * 
   * Note: If set to a negative number the world will use the
   * server-wide spawn limit instead.
   *
   * @param limit the new mob limit
   * @deprecated Deprecated in favor of {@link #getSpawnLimit(SpawnCategory)}
  */
  setAnimalSpawnLimit(animalSpawnLimit: number);
  /**
   * Gets the limit for number of water animals that can spawn in a chunk in
   * this world
   *
   * @return The water animal spawn limit
   * @deprecated Deprecated in favor of {@link #getSpawnLimit(SpawnCategory)}
  */
  getWaterAnimalSpawnLimit(): number;
  /**
   * Sets the limit for number of water animals that can spawn in a chunk in
   * this world
   * 
   * Note: If set to a negative number the world will use the
   * server-wide spawn limit instead.
   *
   * @param limit the new mob limit
   * @deprecated Deprecated in favor of {@link #setSpawnLimit(SpawnCategory, int)}
  */
  setWaterAnimalSpawnLimit(waterAnimalSpawnLimit: number);
  /**
   * Gets the limit for number of water underground creature that can spawn in a chunk in
   * this world
   *
   * @return The water underground creature spawn limit
   * @deprecated Deprecated in favor of {@link #getSpawnLimit(SpawnCategory)}
  */
  getWaterUndergroundCreatureSpawnLimit(): number;
  /**
   * Sets the limit for number of water underground creature that can spawn in a chunk in
   * this world
   * 
   * Note: If set to a negative number the world will use the
   * server-wide spawn limit instead.
   *
   * @param limit the new mob limit
   * @deprecated Deprecated in favor of {@link #setSpawnLimit(SpawnCategory, int)}
  */
  setWaterUndergroundCreatureSpawnLimit(waterUndergroundCreatureSpawnLimit: number);
  /**
   * Gets user-specified limit for number of water ambient mobs that can spawn
   * in a chunk.
   *
   * @return the water ambient spawn limit
   * @deprecated Deprecated in favor of {@link #getSpawnLimit(SpawnCategory)}
  */
  getWaterAmbientSpawnLimit(): number;
  /**
   * Sets the limit for number of water ambient mobs that can spawn in a chunk
   * in this world
   * 
   * Note: If set to a negative number the world will use the
   * server-wide spawn limit instead.
   *
   * @param limit the new mob limit
   * @deprecated Deprecated in favor of {@link #setSpawnLimit(SpawnCategory, int)}
  */
  setWaterAmbientSpawnLimit(waterAmbientSpawnLimit: number);
  /**
   * Gets the limit for number of ambient mobs that can spawn in a chunk in
   * this world
   *
   * @return The ambient spawn limit
   * @deprecated Deprecated in favor of {@link #getSpawnLimit(SpawnCategory)}
  */
  getAmbientSpawnLimit(): number;
  /**
   * Sets the limit for number of ambient mobs that can spawn in a chunk in
   * this world
   * 
   * Note: If set to a negative number the world will use the
   * server-wide spawn limit instead.
   *
   * @param limit the new mob limit
   * @deprecated Deprecated in favor of {@link #setSpawnLimit(SpawnCategory, int)}
  */
  setAmbientSpawnLimit(ambientSpawnLimit: number);
  /**
   * Gets the limit for number of {@link SpawnCategory} entities that can spawn in a chunk in
   * this world
   *
   * @param spawnCategory the entity category
   * @return The ambient spawn limit
  */
  getSpawnLimit(spawnCategory: SpawnCategory): number;
  /**
   * Sets the limit for number of {@link SpawnCategory} entities that can spawn in a chunk in
   * this world
   * 
   * Note: If set to a negative number the world will use the
   * server-wide spawn limit instead.
   *
   * @param spawnCategory the entity category
   * @param limit the new mob limit
  */
  setSpawnLimit(spawnCategory: SpawnCategory, limit: number): void;
  /**
   * Play a Sound at the provided Location in the World.
   * 
   * This function will fail silently if Location or Sound are null.
   *
   * @param location The location to play the sound
   * @param sound The sound to play
   * @param volume The volume of the sound
   * @param pitch The pitch of the sound
  */
  playSound(location: Location, sound: Sound, volume: number, pitch: number): void;
  /**
   * Play a Sound at the provided Location in the World.
   * 
   * This function will fail silently if Location or Sound are null. No
   * sound will be heard by the players if their clients do not have the
   * respective sound for the value passed.
   *
   * @param location the location to play the sound
   * @param sound the internal sound name to play
   * @param volume the volume of the sound
   * @param pitch the pitch of the sound
  */
  playSound(location: Location, sound: string, volume: number, pitch: number): void;
  /**
   * Play a Sound at the provided Location in the World.
   * 
   * This function will fail silently if Location or Sound are null.
   *
   * @param location The location to play the sound
   * @param sound The sound to play
   * @param category the category of the sound
   * @param volume The volume of the sound
   * @param pitch The pitch of the sound
  */
  playSound(location: Location, sound: Sound, category: SoundCategory, volume: number, pitch: number): void;
  /**
   * Play a Sound at the provided Location in the World.
   * 
   * This function will fail silently if Location or Sound are null. No sound
   * will be heard by the players if their clients do not have the respective
   * sound for the value passed.
   *
   * @param location the location to play the sound
   * @param sound the internal sound name to play
   * @param category the category of the sound
   * @param volume the volume of the sound
   * @param pitch the pitch of the sound
  */
  playSound(location: Location, sound: string, category: SoundCategory, volume: number, pitch: number): void;
  /**
   * Play a Sound at the location of the provided entity in the World.
   * 
   * This function will fail silently if Entity or Sound are null.
   *
   * @param entity The entity to play the sound
   * @param sound The sound to play
   * @param volume The volume of the sound
   * @param pitch The pitch of the sound
  */
  playSound(entity: Entity, sound: Sound, volume: number, pitch: number): void;
  /**
   * Play a Sound at the location of the provided entity in the World.
   * 
   * This function will fail silently if Entity or Sound are null.
   *
   * @param entity The entity to play the sound
   * @param sound The sound to play
   * @param category the category of the sound
   * @param volume The volume of the sound
   * @param pitch The pitch of the sound
  */
  playSound(entity: Entity, sound: Sound, category: SoundCategory, volume: number, pitch: number): void;
  /**
   * Get an array containing the names of all the {@link GameRule}s.
   *
   * @return An array of {@link GameRule} names.
  */
  getGameRules(): string[];
  /**
   * Gets the current state of the specified rule
   * 
   * Will return null if rule passed is null
   *
   * @param rule Rule to look up value of
   * @return String value of rule
   * @deprecated use {@link #getGameRuleValue(GameRule)} instead
  */
  getGameRuleValue(rule: string | null): string | null;
  /**
   * Set the specified gamerule to specified value.
   * 
   * The rule may attempt to validate the value passed, will return true if
   * value was set.
   * 
   * If rule is null, the function will return false.
   *
   * @param rule Rule to set
   * @param value Value to set rule to
   * @return True if rule was set
   * @deprecated use {@link #setGameRule(GameRule, Object)} instead.
  */
  setGameRuleValue(rule: string, value: string): boolean;
  /**
   * Checks if string is a valid game rule
   *
   * @param rule Rule to check
   * @return True if rule exists
  */
  isGameRule(rule: string): boolean;
  /**
   * Get the current value for a given {@link GameRule}.
   *
   * @param rule the GameRule to check
   * @param  the GameRule's type
   * @return the current value
  */
  getGameRuleValue<T>(rule: GameRule<T>): T | null;
  /**
   * Get the default value for a given {@link GameRule}. This value is not
   * guaranteed to match the current value.
   *
   * @param rule the rule to return a default value for
   * @param  the type of GameRule
   * @return the default value
  */
  getGameRuleDefault<T>(rule: GameRule<T>): T | null;
  /**
   * Set the given {@link GameRule}'s new value.
   *
   * @param rule the GameRule to update
   * @param newValue the new value
   * @param  the value type of the GameRule
   * @return true if the value was successfully set
  */
  setGameRule<T>(rule: GameRule<T>, newValue: T): boolean;
  /**
   * Gets the world border for this world.
   *
   * @return The world border for this world.
  */
  getWorldBorder(): WorldBorder;
  /**
   * Spawns the particle (the number of times specified by count)
   * at the target location.
   *
   * @param particle the particle to spawn
   * @param location the location to spawn at
   * @param count the number of particles
  */
  spawnParticle(particle: Particle, location: Location, count: number): void;
  /**
   * Spawns the particle (the number of times specified by count)
   * at the target location.
   *
   * @param particle the particle to spawn
   * @param x the position on the x axis to spawn at
   * @param y the position on the y axis to spawn at
   * @param z the position on the z axis to spawn at
   * @param count the number of particles
  */
  spawnParticle(particle: Particle, x: number, y: number, z: number, count: number): void;
  /**
   * Spawns the particle (the number of times specified by count)
   * at the target location.
   *
   * @param  type of particle data (see {@link Particle#getDataType()}
   * @param particle the particle to spawn
   * @param location the location to spawn at
   * @param count the number of particles
   * @param data the data to use for the particle or null,
   *             the type of this depends on {@link Particle#getDataType()}
  */
  spawnParticle<T>(particle: Particle, location: Location, count: number, data: T | null): void;
  /**
   * Spawns the particle (the number of times specified by count)
   * at the target location.
   *
   * @param  type of particle data (see {@link Particle#getDataType()}
   * @param particle the particle to spawn
   * @param x the position on the x axis to spawn at
   * @param y the position on the y axis to spawn at
   * @param z the position on the z axis to spawn at
   * @param count the number of particles
   * @param data the data to use for the particle or null,
   *             the type of this depends on {@link Particle#getDataType()}
  */
  spawnParticle<T>(particle: Particle, x: number, y: number, z: number, count: number, data: T | null): void;
  /**
   * Spawns the particle (the number of times specified by count)
   * at the target location. The position of each particle will be
   * randomized positively and negatively by the offset parameters
   * on each axis.
   *
   * @param particle the particle to spawn
   * @param location the location to spawn at
   * @param count the number of particles
   * @param offsetX the maximum random offset on the X axis
   * @param offsetY the maximum random offset on the Y axis
   * @param offsetZ the maximum random offset on the Z axis
  */
  spawnParticle(particle: Particle, location: Location, count: number, offsetX: number, offsetY: number, offsetZ: number): void;
  /**
   * Spawns the particle (the number of times specified by count)
   * at the target location. The position of each particle will be
   * randomized positively and negatively by the offset parameters
   * on each axis.
   *
   * @param particle the particle to spawn
   * @param x the position on the x axis to spawn at
   * @param y the position on the y axis to spawn at
   * @param z the position on the z axis to spawn at
   * @param count the number of particles
   * @param offsetX the maximum random offset on the X axis
   * @param offsetY the maximum random offset on the Y axis
   * @param offsetZ the maximum random offset on the Z axis
  */
  spawnParticle(particle: Particle, x: number, y: number, z: number, count: number, offsetX: number, offsetY: number, offsetZ: number): void;
  /**
   * Spawns the particle (the number of times specified by count)
   * at the target location. The position of each particle will be
   * randomized positively and negatively by the offset parameters
   * on each axis.
   *
   * @param  type of particle data (see {@link Particle#getDataType()}
   * @param particle the particle to spawn
   * @param location the location to spawn at
   * @param count the number of particles
   * @param offsetX the maximum random offset on the X axis
   * @param offsetY the maximum random offset on the Y axis
   * @param offsetZ the maximum random offset on the Z axis
   * @param data the data to use for the particle or null,
   *             the type of this depends on {@link Particle#getDataType()}
  */
  spawnParticle<T>(particle: Particle, location: Location, count: number, offsetX: number, offsetY: number, offsetZ: number, data: T | null): void;
  /**
   * Spawns the particle (the number of times specified by count)
   * at the target location. The position of each particle will be
   * randomized positively and negatively by the offset parameters
   * on each axis.
   *
   * @param  type of particle data (see {@link Particle#getDataType()}
   * @param particle the particle to spawn
   * @param x the position on the x axis to spawn at
   * @param y the position on the y axis to spawn at
   * @param z the position on the z axis to spawn at
   * @param count the number of particles
   * @param offsetX the maximum random offset on the X axis
   * @param offsetY the maximum random offset on the Y axis
   * @param offsetZ the maximum random offset on the Z axis
   * @param data the data to use for the particle or null,
   *             the type of this depends on {@link Particle#getDataType()}
  */
  spawnParticle<T>(particle: Particle, x: number, y: number, z: number, count: number, offsetX: number, offsetY: number, offsetZ: number, data: T | null): void;
  /**
   * Spawns the particle (the number of times specified by count)
   * at the target location. The position of each particle will be
   * randomized positively and negatively by the offset parameters
   * on each axis.
   *
   * @param particle the particle to spawn
   * @param location the location to spawn at
   * @param count the number of particles
   * @param offsetX the maximum random offset on the X axis
   * @param offsetY the maximum random offset on the Y axis
   * @param offsetZ the maximum random offset on the Z axis
   * @param extra the extra data for this particle, depends on the
   *              particle used (normally speed)
  */
  spawnParticle(particle: Particle, location: Location, count: number, offsetX: number, offsetY: number, offsetZ: number, extra: number): void;
  /**
   * Spawns the particle (the number of times specified by count)
   * at the target location. The position of each particle will be
   * randomized positively and negatively by the offset parameters
   * on each axis.
   *
   * @param particle the particle to spawn
   * @param x the position on the x axis to spawn at
   * @param y the position on the y axis to spawn at
   * @param z the position on the z axis to spawn at
   * @param count the number of particles
   * @param offsetX the maximum random offset on the X axis
   * @param offsetY the maximum random offset on the Y axis
   * @param offsetZ the maximum random offset on the Z axis
   * @param extra the extra data for this particle, depends on the
   *              particle used (normally speed)
  */
  spawnParticle(particle: Particle, x: number, y: number, z: number, count: number, offsetX: number, offsetY: number, offsetZ: number, extra: number): void;
  /**
   * Spawns the particle (the number of times specified by count)
   * at the target location. The position of each particle will be
   * randomized positively and negatively by the offset parameters
   * on each axis.
   *
   * @param  type of particle data (see {@link Particle#getDataType()}
   * @param particle the particle to spawn
   * @param location the location to spawn at
   * @param count the number of particles
   * @param offsetX the maximum random offset on the X axis
   * @param offsetY the maximum random offset on the Y axis
   * @param offsetZ the maximum random offset on the Z axis
   * @param extra the extra data for this particle, depends on the
   *              particle used (normally speed)
   * @param data the data to use for the particle or null,
   *             the type of this depends on {@link Particle#getDataType()}
  */
  spawnParticle<T>(particle: Particle, location: Location, count: number, offsetX: number, offsetY: number, offsetZ: number, extra: number, data: T | null): void;
  spawnParticle<T>(particle: Particle, x: number, y: number, z: number, count: number, offsetX: number, offsetY: number, offsetZ: number, extra: number, data: T | null): void;
  /**
   * Spawns the particle (the number of times specified by count)
   * at the target location. The position of each particle will be
   * randomized positively and negatively by the offset parameters
   * on each axis.
   *
   * @param particle the particle to spawn
   * @param receivers List of players to receive the particles, or null for all in world
   * @param source Source of the particles to be used in visibility checks, or null if no player source
   * @param x the position on the x axis to spawn at
   * @param y the position on the y axis to spawn at
   * @param z the position on the z axis to spawn at
   * @param count the number of particles
   * @param offsetX the maximum random offset on the X axis
   * @param offsetY the maximum random offset on the Y axis
   * @param offsetZ the maximum random offset on the Z axis
   * @param extra the extra data for this particle, depends on the
   *              particle used (normally speed)
   * @param data the data to use for the particle or null,
   *             the type of this depends on {@link Particle#getDataType()}
   * @param  Type
  */
  spawnParticle<T>(particle: Particle, receivers: Player[] | null, source: Player, x: number, y: number, z: number, count: number, offsetX: number, offsetY: number, offsetZ: number, extra: number, data: T | null): void;
  /**
   * Spawns the particle (the number of times specified by count)
   * at the target location. The position of each particle will be
   * randomized positively and negatively by the offset parameters
   * on each axis.
   *
   * @param particle the particle to spawn
   * @param receivers List of players to receive the particles, or null for all in world
   * @param source Source of the particles to be used in visibility checks, or null if no player source
   * @param x the position on the x axis to spawn at
   * @param y the position on the y axis to spawn at
   * @param z the position on the z axis to spawn at
   * @param count the number of particles
   * @param offsetX the maximum random offset on the X axis
   * @param offsetY the maximum random offset on the Y axis
   * @param offsetZ the maximum random offset on the Z axis
   * @param extra the extra data for this particle, depends on the
   *              particle used (normally speed)
   * @param data the data to use for the particle or null,
   *             the type of this depends on {@link Particle#getDataType()}
   * @param  Type
   * @param force allows the particle to be seen further away from the player
   *              and shows to players using any vanilla client particle settings
  */
  spawnParticle<T>(particle: Particle, receivers: Player[] | null, source: Player | null, x: number, y: number, z: number, count: number, offsetX: number, offsetY: number, offsetZ: number, extra: number, data: T | null, force: boolean): void;
  /**
   * Spawns the particle (the number of times specified by count)
   * at the target location. The position of each particle will be
   * randomized positively and negatively by the offset parameters
   * on each axis.
   *
   * @param  type of particle data (see {@link Particle#getDataType()}
   * @param particle the particle to spawn
   * @param location the location to spawn at
   * @param count the number of particles
   * @param offsetX the maximum random offset on the X axis
   * @param offsetY the maximum random offset on the Y axis
   * @param offsetZ the maximum random offset on the Z axis
   * @param extra the extra data for this particle, depends on the
   *              particle used (normally speed)
   * @param data the data to use for the particle or null,
   *             the type of this depends on {@link Particle#getDataType()}
   * @param force whether to send the particle to players within an extended
   *              range and encourage their client to render it regardless of
   *              settings
  */
  spawnParticle<T>(particle: Particle, location: Location, count: number, offsetX: number, offsetY: number, offsetZ: number, extra: number, data: T | null, force: boolean): void;
  /**
   * Spawns the particle (the number of times specified by count)
   * at the target location. The position of each particle will be
   * randomized positively and negatively by the offset parameters
   * on each axis.
   *
   * @param  type of particle data (see {@link Particle#getDataType()}
   * @param particle the particle to spawn
   * @param x the position on the x axis to spawn at
   * @param y the position on the y axis to spawn at
   * @param z the position on the z axis to spawn at
   * @param count the number of particles
   * @param offsetX the maximum random offset on the X axis
   * @param offsetY the maximum random offset on the Y axis
   * @param offsetZ the maximum random offset on the Z axis
   * @param extra the extra data for this particle, depends on the
   *              particle used (normally speed)
   * @param data the data to use for the particle or null,
   *             the type of this depends on {@link Particle#getDataType()}
   * @param force whether to send the particle to players within an extended
   *              range and encourage their client to render it regardless of
   *              settings
  */
  spawnParticle<T>(particle: Particle, x: number, y: number, z: number, count: number, offsetX: number, offsetY: number, offsetZ: number, extra: number, data: T | null, force: boolean): void;
  /**
   * Find the closest nearby structure of a given {@link StructureType}.
   * Finding unexplored structures can, and will, block if the world is
   * looking in chunks that gave not generated yet. This can lead to the world
   * temporarily freezing while locating an unexplored structure.
   * 
   * The `radius` is not a rigid square radius. Each structure may alter
   * how many chunks to check for each iteration. Do not assume that only a
   * radius x radius chunk area will be checked. For example,
   * {@link StructureType#WOODLAND_MANSION} can potentially check up to 20,000
   * blocks away (or more) regardless of the radius used.
   * 
   * This will not load or generate chunks. This can also lead to
   * instances where the server can hang if you are only looking for
   * unexplored structures. This is because it will keep looking further and
   * further out in order to find the structure.
   *
   * @param origin where to start looking for a structure
   * @param structureType the type of structure to find
   * @param radius the radius, in chunks, around which to search
   * @param findUnexplored true to only find unexplored structures
   * @return the closest {@link Location}, or null if no structure of the
   * specified type exists.
  */
  locateNearestStructure(origin: Location, structureType: StructureType, radius: number, findUnexplored: boolean): Location | null;
  /**
   * Locates the nearest biome based on an origin, biome type, and radius to search.
   * Step defaults to `8`.
   *
   * @param origin Origin location
   * @param biome Biome to find
   * @param radius radius to search
   * @return Location of biome or null if not found in specified radius
  */
  locateNearestBiome(origin: Location, biome: Biome, radius: number): Location | null;
  /**
   * Locates the nearest biome based on an origin, biome type, and radius to search
   * and step
   *
   * @param origin Origin location
   * @param biome Biome to find
   * @param radius radius to search
   * @param step Search step 1 would mean checking every block, 8 would be every 8th block
   * @return Location of biome or null if not found in specified radius
  */
  locateNearestBiome(origin: Location, biome: Biome, radius: number, step: number): Location | null;
  /**
   * Checks if the world:
   * 
   *     evaporates water
   *     dries sponges
   *     has lava spread faster and further
   * 
   *
   * @return true if ultrawarm, false if not
   * @deprecated use {@link #isUltraWarm()}
  */
  isUltrawarm(): boolean;
  /**
   * Gets the coordinate scaling of this world.
   *
   * @return the coordinate scale
  */
  getCoordinateScale(): number;
  /**
   * Checks if the world has skylight access
   *
   * @return whether there is skylight
   * @deprecated use {@link #hasSkyLight()}
  */
  hasSkylight(): boolean;
  /**
   * Checks if the world has a bedrock ceiling
   *
   * @return whether the world has a bedrock ceiling
   * @deprecated use {@link #hasCeiling()}
  */
  hasBedrockCeiling(): boolean;
  /**
   * Checks if beds work
   *
   * @return whether beds work
   * @deprecated use {@link #isBedWorks()}
  */
  doesBedWork(): boolean;
  /**
   * Checks if respawn anchors work
   *
   * @return whether respawn anchors work
   * @deprecated use {@link #isRespawnAnchorWorks()}
  */
  doesRespawnAnchorWork(): boolean;
  /**
   * Checks if this world has a fixed time
   *
   * @return whether this world has fixed time
  */
  isFixedTime(): boolean;
  /**
   * Gets the collection of materials that burn infinitely in this world.
   *
   * @return the materials that will forever stay lit by fire
  */
  getInfiniburn(): Collection<Material>;
  /**
   * Posts a specified game event at a location
   *
   * @param sourceEntity optional source entity
   * @param gameEvent the game event to post
   * @param position the position in the world where to post the event to listeners
  */
  sendGameEvent(sourceEntity: Entity | null, gameEvent: GameEvent, position: Vector): void;
  /**
   * Returns the view distance used for this world.
   *
   * @return the view distance used for this world
  */
  getViewDistance(): number;
  /**
   * Returns the simulation distance used for this world.
   *
   * @return the simulation distance used for this world
  */
  getSimulationDistance(): number;
  /**
   * Sets the view distance for this world.
   * @param viewDistance view distance in [2, 32]
  */
  setViewDistance(viewDistance: number);
  /**
   * Sets the simulation distance for this world.
   * @param simulationDistance simulation distance in [2, 32]
  */
  setSimulationDistance(simulationDistance: number);
  /**
   * Returns the no-tick view distance for this world.
   * 
   * No-tick view distance is the view distance where chunks will load, however the chunks and their entities will not
   * be set to tick.
   * 
   * @return The no-tick view distance for this world.
   * @deprecated Use {@link #getViewDistance()}
  */
  getNoTickViewDistance(): number;
  /**
   * Sets the no-tick view distance for this world.
   * 
   * No-tick view distance is the view distance where chunks will load, however the chunks and their entities will not
   * be set to tick.
   * 
   * @param viewDistance view distance in [2, 32]
   * @deprecated Use {@link #setViewDistance(int)}
  */
  setNoTickViewDistance(noTickViewDistance: number);
  /**
   * Gets the sending view distance for this world.
   * 
   * Sending view distance is the view distance where chunks will load in for players in this world.
   * 
   * @return The sending view distance for this world.
  */
  getSendViewDistance(): number;
  /**
   * Sets the sending view distance for this world.
   * 
   * Sending view distance is the view distance where chunks will load in for players in this world.
   * 
   * @param viewDistance view distance in [2, 32] or -1
  */
  setSendViewDistance(sendViewDistance: number);
  spigot(): org_bukkit_World_Spigot;
  /**
   * Finds the nearest raid close to the given location.
   *
   * @param location the origin location
   * @param radius the radius
   * @return the closest {@link Raid}, or null if no raids were found
  */
  locateNearestRaid(location: Location, radius: number): Raid | null;
  /**
   * Gets all raids that are going on over this world.
   *
   * @return the list of all active raids
  */
  getRaids(): Raid[];
  /**
   * Get the {@link DragonBattle} associated with this world.
   *
   * If this world's environment is not {@link Environment#THE_END}, null will
   * be returned.
   * 
   * If an end world, a dragon battle instance will be returned regardless of
   * whether or not a dragon is present in the world or a fight sequence has
   * been activated. The dragon battle instance acts as a state holder.
   *
   * @return the dragon battle instance
  */
  getEnderDragonBattle(): DragonBattle | null;
  /**
   * Gets the {@link Biome} at the given {@link Location}.
   *
   * @param location the location of the biome
   * @return Biome at the given location
   * @see #getComputedBiome(int, int, int)
  */
  getBiome(location: Location): Biome;
  /**
   * Gets the {@link Biome} at the given coordinates.
   *
   * @param x X-coordinate of the block
   * @param y Y-coordinate of the block
   * @param z Z-coordinate of the block
   * @return Biome at the given coordinates
   * @see #getComputedBiome(int, int, int)
  */
  getBiome(x: number, y: number, z: number): Biome;
  /**
   * Sets the {@link Biome} at the given {@link Location}.
   *
   * @param location the location of the biome
   * @param biome New Biome type for this block
  */
  setBiome(location: Location, biome: Biome): void;
  /**
   * Sets the {@link Biome} for the given block coordinates
   *
   * @param x X-coordinate of the block
   * @param y Y-coordinate of the block
   * @param z Z-coordinate of the block
   * @param biome New Biome type for this block
  */
  setBiome(x: number, y: number, z: number, biome: Biome): void;
  /**
   * Creates a tree at the given {@link Location}
   *
   * @param location Location to spawn the tree
   * @param random Random to use to generated the tree
   * @param type Type of the tree to create
   * @return true if the tree was created successfully, otherwise false
  */
  generateTree(location: Location, random: Random, type: TreeType): boolean;
  /**
   * Creates a tree at the given {@link Location}
   * 
   * The provided consumer gets called for every block which gets changed
   * as a result of the tree generation. When the consumer gets called no
   * modifications to the world are done yet. Which means, that calling
   * {@link #getBlockState(Location)} in the consumer while return the state
   * of the block before the generation.
   * 
   * Modifications done to the {@link BlockState} in the consumer are respected,
   * which means that it is not necessary to call {@link BlockState#update()}
   *
   * @param location Location to spawn the tree
   * @param random Random to use to generated the tree
   * @param type Type of the tree to create
   * @param stateConsumer The consumer which should get called for every block which gets changed
   * @return true if the tree was created successfully, otherwise false
  */
  generateTree(location: Location, random: Random, type: TreeType, stateConsumer: org_bukkit_util_Consumer<BlockState> | null): boolean;
  /**
   * Creates a tree at the given {@link Location}
   * 
   * The provided predicate gets called for every block which gets changed
   * as a result of the tree generation. When the predicate gets called no
   * modifications to the world are done yet. Which means, that calling
   * {@link #getBlockState(Location)} in the predicate will return the state
   * of the block before the generation.
   * 
   * If the predicate returns `true` the block gets set in the world.
   * If it returns `false` the block won't get set in the world.
   *
   * @param location Location to spawn the tree
   * @param random Random to use to generated the tree
   * @param type Type of the tree to create
   * @param statePredicate The predicate which should get used to test if a block should be set or not.
   * @return true if the tree was created successfully, otherwise false
  */
  generateTree(location: Location, random: Random, type: TreeType, statePredicate: Predicate<BlockState> | null): boolean;
  playSound(sound: net_kyori_adventure_sound_Sound): void;
  playSound(sound: net_kyori_adventure_sound_Sound, x: number, y: number, z: number): void;
  playSound(sound: net_kyori_adventure_sound_Sound, emitter: Emitter): void;
}
export interface World extends RegionAccessor, WorldInfo, PluginMessageRecipient, Metadatable, PersistentDataHolder, Keyed, ForwardingAudience {}
/**
 * An enum of all material IDs accepted by the official server and client
*/
export class Material extends Enum<Material> {
  static readonly AIR: Material;
  static readonly STONE: Material;
  static readonly GRANITE: Material;
  static readonly POLISHED_GRANITE: Material;
  static readonly DIORITE: Material;
  static readonly POLISHED_DIORITE: Material;
  static readonly ANDESITE: Material;
  static readonly POLISHED_ANDESITE: Material;
  /**
   * BlockData: {@link Orientable}
  */
  static readonly DEEPSLATE: Material;
  static readonly COBBLED_DEEPSLATE: Material;
  static readonly POLISHED_DEEPSLATE: Material;
  static readonly CALCITE: Material;
  static readonly TUFF: Material;
  static readonly DRIPSTONE_BLOCK: Material;
  /**
   * BlockData: {@link Snowable}
  */
  static readonly GRASS_BLOCK: Material;
  static readonly DIRT: Material;
  static readonly COARSE_DIRT: Material;
  /**
   * BlockData: {@link Snowable}
  */
  static readonly PODZOL: Material;
  static readonly ROOTED_DIRT: Material;
  static readonly CRIMSON_NYLIUM: Material;
  static readonly WARPED_NYLIUM: Material;
  static readonly COBBLESTONE: Material;
  static readonly OAK_PLANKS: Material;
  static readonly SPRUCE_PLANKS: Material;
  static readonly BIRCH_PLANKS: Material;
  static readonly JUNGLE_PLANKS: Material;
  static readonly ACACIA_PLANKS: Material;
  static readonly DARK_OAK_PLANKS: Material;
  static readonly CRIMSON_PLANKS: Material;
  static readonly WARPED_PLANKS: Material;
  /**
   * BlockData: {@link Sapling}
  */
  static readonly OAK_SAPLING: Material;
  /**
   * BlockData: {@link Sapling}
  */
  static readonly SPRUCE_SAPLING: Material;
  /**
   * BlockData: {@link Sapling}
  */
  static readonly BIRCH_SAPLING: Material;
  /**
   * BlockData: {@link Sapling}
  */
  static readonly JUNGLE_SAPLING: Material;
  /**
   * BlockData: {@link Sapling}
  */
  static readonly ACACIA_SAPLING: Material;
  /**
   * BlockData: {@link Sapling}
  */
  static readonly DARK_OAK_SAPLING: Material;
  static readonly BEDROCK: Material;
  static readonly SAND: Material;
  static readonly RED_SAND: Material;
  static readonly GRAVEL: Material;
  static readonly COAL_ORE: Material;
  static readonly DEEPSLATE_COAL_ORE: Material;
  static readonly IRON_ORE: Material;
  static readonly DEEPSLATE_IRON_ORE: Material;
  static readonly COPPER_ORE: Material;
  static readonly DEEPSLATE_COPPER_ORE: Material;
  static readonly GOLD_ORE: Material;
  static readonly DEEPSLATE_GOLD_ORE: Material;
  /**
   * BlockData: {@link Lightable}
  */
  static readonly REDSTONE_ORE: Material;
  /**
   * BlockData: {@link Lightable}
  */
  static readonly DEEPSLATE_REDSTONE_ORE: Material;
  static readonly EMERALD_ORE: Material;
  static readonly DEEPSLATE_EMERALD_ORE: Material;
  static readonly LAPIS_ORE: Material;
  static readonly DEEPSLATE_LAPIS_ORE: Material;
  static readonly DIAMOND_ORE: Material;
  static readonly DEEPSLATE_DIAMOND_ORE: Material;
  static readonly NETHER_GOLD_ORE: Material;
  static readonly NETHER_QUARTZ_ORE: Material;
  static readonly ANCIENT_DEBRIS: Material;
  static readonly COAL_BLOCK: Material;
  static readonly RAW_IRON_BLOCK: Material;
  static readonly RAW_COPPER_BLOCK: Material;
  static readonly RAW_GOLD_BLOCK: Material;
  static readonly AMETHYST_BLOCK: Material;
  static readonly BUDDING_AMETHYST: Material;
  static readonly IRON_BLOCK: Material;
  static readonly COPPER_BLOCK: Material;
  static readonly GOLD_BLOCK: Material;
  static readonly DIAMOND_BLOCK: Material;
  static readonly NETHERITE_BLOCK: Material;
  static readonly EXPOSED_COPPER: Material;
  static readonly WEATHERED_COPPER: Material;
  static readonly OXIDIZED_COPPER: Material;
  static readonly CUT_COPPER: Material;
  static readonly EXPOSED_CUT_COPPER: Material;
  static readonly WEATHERED_CUT_COPPER: Material;
  static readonly OXIDIZED_CUT_COPPER: Material;
  /**
   * BlockData: {@link Stairs}
  */
  static readonly CUT_COPPER_STAIRS: Material;
  /**
   * BlockData: {@link Stairs}
  */
  static readonly EXPOSED_CUT_COPPER_STAIRS: Material;
  /**
   * BlockData: {@link Stairs}
  */
  static readonly WEATHERED_CUT_COPPER_STAIRS: Material;
  /**
   * BlockData: {@link Stairs}
  */
  static readonly OXIDIZED_CUT_COPPER_STAIRS: Material;
  /**
   * BlockData: {@link Slab}
  */
  static readonly CUT_COPPER_SLAB: Material;
  /**
   * BlockData: {@link Slab}
  */
  static readonly EXPOSED_CUT_COPPER_SLAB: Material;
  /**
   * BlockData: {@link Slab}
  */
  static readonly WEATHERED_CUT_COPPER_SLAB: Material;
  /**
   * BlockData: {@link Slab}
  */
  static readonly OXIDIZED_CUT_COPPER_SLAB: Material;
  static readonly WAXED_COPPER_BLOCK: Material;
  static readonly WAXED_EXPOSED_COPPER: Material;
  static readonly WAXED_WEATHERED_COPPER: Material;
  static readonly WAXED_OXIDIZED_COPPER: Material;
  static readonly WAXED_CUT_COPPER: Material;
  static readonly WAXED_EXPOSED_CUT_COPPER: Material;
  static readonly WAXED_WEATHERED_CUT_COPPER: Material;
  static readonly WAXED_OXIDIZED_CUT_COPPER: Material;
  /**
   * BlockData: {@link Stairs}
  */
  static readonly WAXED_CUT_COPPER_STAIRS: Material;
  /**
   * BlockData: {@link Stairs}
  */
  static readonly WAXED_EXPOSED_CUT_COPPER_STAIRS: Material;
  /**
   * BlockData: {@link Stairs}
  */
  static readonly WAXED_WEATHERED_CUT_COPPER_STAIRS: Material;
  /**
   * BlockData: {@link Stairs}
  */
  static readonly WAXED_OXIDIZED_CUT_COPPER_STAIRS: Material;
  /**
   * BlockData: {@link Slab}
  */
  static readonly WAXED_CUT_COPPER_SLAB: Material;
  /**
   * BlockData: {@link Slab}
  */
  static readonly WAXED_EXPOSED_CUT_COPPER_SLAB: Material;
  /**
   * BlockData: {@link Slab}
  */
  static readonly WAXED_WEATHERED_CUT_COPPER_SLAB: Material;
  /**
   * BlockData: {@link Slab}
  */
  static readonly WAXED_OXIDIZED_CUT_COPPER_SLAB: Material;
  /**
   * BlockData: {@link Orientable}
  */
  static readonly OAK_LOG: Material;
  /**
   * BlockData: {@link Orientable}
  */
  static readonly SPRUCE_LOG: Material;
  /**
   * BlockData: {@link Orientable}
  */
  static readonly BIRCH_LOG: Material;
  /**
   * BlockData: {@link Orientable}
  */
  static readonly JUNGLE_LOG: Material;
  /**
   * BlockData: {@link Orientable}
  */
  static readonly ACACIA_LOG: Material;
  /**
   * BlockData: {@link Orientable}
  */
  static readonly DARK_OAK_LOG: Material;
  /**
   * BlockData: {@link Orientable}
  */
  static readonly CRIMSON_STEM: Material;
  /**
   * BlockData: {@link Orientable}
  */
  static readonly WARPED_STEM: Material;
  /**
   * BlockData: {@link Orientable}
  */
  static readonly STRIPPED_OAK_LOG: Material;
  /**
   * BlockData: {@link Orientable}
  */
  static readonly STRIPPED_SPRUCE_LOG: Material;
  /**
   * BlockData: {@link Orientable}
  */
  static readonly STRIPPED_BIRCH_LOG: Material;
  /**
   * BlockData: {@link Orientable}
  */
  static readonly STRIPPED_JUNGLE_LOG: Material;
  /**
   * BlockData: {@link Orientable}
  */
  static readonly STRIPPED_ACACIA_LOG: Material;
  /**
   * BlockData: {@link Orientable}
  */
  static readonly STRIPPED_DARK_OAK_LOG: Material;
  /**
   * BlockData: {@link Orientable}
  */
  static readonly STRIPPED_CRIMSON_STEM: Material;
  /**
   * BlockData: {@link Orientable}
  */
  static readonly STRIPPED_WARPED_STEM: Material;
  /**
   * BlockData: {@link Orientable}
  */
  static readonly STRIPPED_OAK_WOOD: Material;
  /**
   * BlockData: {@link Orientable}
  */
  static readonly STRIPPED_SPRUCE_WOOD: Material;
  /**
   * BlockData: {@link Orientable}
  */
  static readonly STRIPPED_BIRCH_WOOD: Material;
  /**
   * BlockData: {@link Orientable}
  */
  static readonly STRIPPED_JUNGLE_WOOD: Material;
  /**
   * BlockData: {@link Orientable}
  */
  static readonly STRIPPED_ACACIA_WOOD: Material;
  /**
   * BlockData: {@link Orientable}
  */
  static readonly STRIPPED_DARK_OAK_WOOD: Material;
  /**
   * BlockData: {@link Orientable}
  */
  static readonly STRIPPED_CRIMSON_HYPHAE: Material;
  /**
   * BlockData: {@link Orientable}
  */
  static readonly STRIPPED_WARPED_HYPHAE: Material;
  /**
   * BlockData: {@link Orientable}
  */
  static readonly OAK_WOOD: Material;
  /**
   * BlockData: {@link Orientable}
  */
  static readonly SPRUCE_WOOD: Material;
  /**
   * BlockData: {@link Orientable}
  */
  static readonly BIRCH_WOOD: Material;
  /**
   * BlockData: {@link Orientable}
  */
  static readonly JUNGLE_WOOD: Material;
  /**
   * BlockData: {@link Orientable}
  */
  static readonly ACACIA_WOOD: Material;
  /**
   * BlockData: {@link Orientable}
  */
  static readonly DARK_OAK_WOOD: Material;
  /**
   * BlockData: {@link Orientable}
  */
  static readonly CRIMSON_HYPHAE: Material;
  /**
   * BlockData: {@link Orientable}
  */
  static readonly WARPED_HYPHAE: Material;
  /**
   * BlockData: {@link Leaves}
  */
  static readonly OAK_LEAVES: Material;
  /**
   * BlockData: {@link Leaves}
  */
  static readonly SPRUCE_LEAVES: Material;
  /**
   * BlockData: {@link Leaves}
  */
  static readonly BIRCH_LEAVES: Material;
  /**
   * BlockData: {@link Leaves}
  */
  static readonly JUNGLE_LEAVES: Material;
  /**
   * BlockData: {@link Leaves}
  */
  static readonly ACACIA_LEAVES: Material;
  /**
   * BlockData: {@link Leaves}
  */
  static readonly DARK_OAK_LEAVES: Material;
  /**
   * BlockData: {@link Leaves}
  */
  static readonly AZALEA_LEAVES: Material;
  /**
   * BlockData: {@link Leaves}
  */
  static readonly FLOWERING_AZALEA_LEAVES: Material;
  static readonly SPONGE: Material;
  static readonly WET_SPONGE: Material;
  static readonly GLASS: Material;
  static readonly TINTED_GLASS: Material;
  static readonly LAPIS_BLOCK: Material;
  static readonly SANDSTONE: Material;
  static readonly CHISELED_SANDSTONE: Material;
  static readonly CUT_SANDSTONE: Material;
  static readonly COBWEB: Material;
  static readonly GRASS: Material;
  static readonly FERN: Material;
  static readonly AZALEA: Material;
  static readonly FLOWERING_AZALEA: Material;
  static readonly DEAD_BUSH: Material;
  static readonly SEAGRASS: Material;
  /**
   * BlockData: {@link SeaPickle}
  */
  static readonly SEA_PICKLE: Material;
  static readonly WHITE_WOOL: Material;
  static readonly ORANGE_WOOL: Material;
  static readonly MAGENTA_WOOL: Material;
  static readonly LIGHT_BLUE_WOOL: Material;
  static readonly YELLOW_WOOL: Material;
  static readonly LIME_WOOL: Material;
  static readonly PINK_WOOL: Material;
  static readonly GRAY_WOOL: Material;
  static readonly LIGHT_GRAY_WOOL: Material;
  static readonly CYAN_WOOL: Material;
  static readonly PURPLE_WOOL: Material;
  static readonly BLUE_WOOL: Material;
  static readonly BROWN_WOOL: Material;
  static readonly GREEN_WOOL: Material;
  static readonly RED_WOOL: Material;
  static readonly BLACK_WOOL: Material;
  static readonly DANDELION: Material;
  static readonly POPPY: Material;
  static readonly BLUE_ORCHID: Material;
  static readonly ALLIUM: Material;
  static readonly AZURE_BLUET: Material;
  static readonly RED_TULIP: Material;
  static readonly ORANGE_TULIP: Material;
  static readonly WHITE_TULIP: Material;
  static readonly PINK_TULIP: Material;
  static readonly OXEYE_DAISY: Material;
  static readonly CORNFLOWER: Material;
  static readonly LILY_OF_THE_VALLEY: Material;
  static readonly WITHER_ROSE: Material;
  static readonly SPORE_BLOSSOM: Material;
  static readonly BROWN_MUSHROOM: Material;
  static readonly RED_MUSHROOM: Material;
  static readonly CRIMSON_FUNGUS: Material;
  static readonly WARPED_FUNGUS: Material;
  static readonly CRIMSON_ROOTS: Material;
  static readonly WARPED_ROOTS: Material;
  static readonly NETHER_SPROUTS: Material;
  /**
   * BlockData: {@link Ageable}
  */
  static readonly WEEPING_VINES: Material;
  /**
   * BlockData: {@link Ageable}
  */
  static readonly TWISTING_VINES: Material;
  /**
   * BlockData: {@link Ageable}
  */
  static readonly SUGAR_CANE: Material;
  /**
   * BlockData: {@link Ageable}
  */
  static readonly KELP: Material;
  static readonly MOSS_CARPET: Material;
  static readonly MOSS_BLOCK: Material;
  /**
   * BlockData: {@link Waterlogged}
  */
  static readonly HANGING_ROOTS: Material;
  /**
   * BlockData: {@link BigDripleaf}
  */
  static readonly BIG_DRIPLEAF: Material;
  /**
   * BlockData: {@link SmallDripleaf}
  */
  static readonly SMALL_DRIPLEAF: Material;
  /**
   * BlockData: {@link Bamboo}
  */
  static readonly BAMBOO: Material;
  /**
   * BlockData: {@link Slab}
  */
  static readonly OAK_SLAB: Material;
  /**
   * BlockData: {@link Slab}
  */
  static readonly SPRUCE_SLAB: Material;
  /**
   * BlockData: {@link Slab}
  */
  static readonly BIRCH_SLAB: Material;
  /**
   * BlockData: {@link Slab}
  */
  static readonly JUNGLE_SLAB: Material;
  /**
   * BlockData: {@link Slab}
  */
  static readonly ACACIA_SLAB: Material;
  /**
   * BlockData: {@link Slab}
  */
  static readonly DARK_OAK_SLAB: Material;
  /**
   * BlockData: {@link Slab}
  */
  static readonly CRIMSON_SLAB: Material;
  /**
   * BlockData: {@link Slab}
  */
  static readonly WARPED_SLAB: Material;
  /**
   * BlockData: {@link Slab}
  */
  static readonly STONE_SLAB: Material;
  /**
   * BlockData: {@link Slab}
  */
  static readonly SMOOTH_STONE_SLAB: Material;
  /**
   * BlockData: {@link Slab}
  */
  static readonly SANDSTONE_SLAB: Material;
  /**
   * BlockData: {@link Slab}
  */
  static readonly CUT_SANDSTONE_SLAB: Material;
  /**
   * BlockData: {@link Slab}
  */
  static readonly PETRIFIED_OAK_SLAB: Material;
  /**
   * BlockData: {@link Slab}
  */
  static readonly COBBLESTONE_SLAB: Material;
  /**
   * BlockData: {@link Slab}
  */
  static readonly BRICK_SLAB: Material;
  /**
   * BlockData: {@link Slab}
  */
  static readonly STONE_BRICK_SLAB: Material;
  /**
   * BlockData: {@link Slab}
  */
  static readonly NETHER_BRICK_SLAB: Material;
  /**
   * BlockData: {@link Slab}
  */
  static readonly QUARTZ_SLAB: Material;
  /**
   * BlockData: {@link Slab}
  */
  static readonly RED_SANDSTONE_SLAB: Material;
  /**
   * BlockData: {@link Slab}
  */
  static readonly CUT_RED_SANDSTONE_SLAB: Material;
  /**
   * BlockData: {@link Slab}
  */
  static readonly PURPUR_SLAB: Material;
  /**
   * BlockData: {@link Slab}
  */
  static readonly PRISMARINE_SLAB: Material;
  /**
   * BlockData: {@link Slab}
  */
  static readonly PRISMARINE_BRICK_SLAB: Material;
  /**
   * BlockData: {@link Slab}
  */
  static readonly DARK_PRISMARINE_SLAB: Material;
  static readonly SMOOTH_QUARTZ: Material;
  static readonly SMOOTH_RED_SANDSTONE: Material;
  static readonly SMOOTH_SANDSTONE: Material;
  static readonly SMOOTH_STONE: Material;
  static readonly BRICKS: Material;
  static readonly BOOKSHELF: Material;
  static readonly MOSSY_COBBLESTONE: Material;
  static readonly OBSIDIAN: Material;
  static readonly TORCH: Material;
  /**
   * BlockData: {@link Directional}
  */
  static readonly END_ROD: Material;
  /**
   * BlockData: {@link MultipleFacing}
  */
  static readonly CHORUS_PLANT: Material;
  /**
   * BlockData: {@link Ageable}
  */
  static readonly CHORUS_FLOWER: Material;
  static readonly PURPUR_BLOCK: Material;
  /**
   * BlockData: {@link Orientable}
  */
  static readonly PURPUR_PILLAR: Material;
  /**
   * BlockData: {@link Stairs}
  */
  static readonly PURPUR_STAIRS: Material;
  static readonly SPAWNER: Material;
  /**
   * BlockData: {@link Stairs}
  */
  static readonly OAK_STAIRS: Material;
  /**
   * BlockData: {@link Chest}
  */
  static readonly CHEST: Material;
  static readonly CRAFTING_TABLE: Material;
  /**
   * BlockData: {@link Farmland}
  */
  static readonly FARMLAND: Material;
  /**
   * BlockData: {@link Furnace}
  */
  static readonly FURNACE: Material;
  /**
   * BlockData: {@link Ladder}
  */
  static readonly LADDER: Material;
  /**
   * BlockData: {@link Stairs}
  */
  static readonly COBBLESTONE_STAIRS: Material;
  /**
   * BlockData: {@link Snow}
  */
  static readonly SNOW: Material;
  static readonly ICE: Material;
  static readonly SNOW_BLOCK: Material;
  /**
   * BlockData: {@link Ageable}
  */
  static readonly CACTUS: Material;
  static readonly CLAY: Material;
  /**
   * BlockData: {@link Jukebox}
  */
  static readonly JUKEBOX: Material;
  /**
   * BlockData: {@link Fence}
  */
  static readonly OAK_FENCE: Material;
  /**
   * BlockData: {@link Fence}
  */
  static readonly SPRUCE_FENCE: Material;
  /**
   * BlockData: {@link Fence}
  */
  static readonly BIRCH_FENCE: Material;
  /**
   * BlockData: {@link Fence}
  */
  static readonly JUNGLE_FENCE: Material;
  /**
   * BlockData: {@link Fence}
  */
  static readonly ACACIA_FENCE: Material;
  /**
   * BlockData: {@link Fence}
  */
  static readonly DARK_OAK_FENCE: Material;
  /**
   * BlockData: {@link Fence}
  */
  static readonly CRIMSON_FENCE: Material;
  /**
   * BlockData: {@link Fence}
  */
  static readonly WARPED_FENCE: Material;
  static readonly PUMPKIN: Material;
  /**
   * BlockData: {@link Directional}
  */
  static readonly CARVED_PUMPKIN: Material;
  /**
   * BlockData: {@link Directional}
  */
  static readonly JACK_O_LANTERN: Material;
  static readonly NETHERRACK: Material;
  static readonly SOUL_SAND: Material;
  static readonly SOUL_SOIL: Material;
  /**
   * BlockData: {@link Orientable}
  */
  static readonly BASALT: Material;
  /**
   * BlockData: {@link Orientable}
  */
  static readonly POLISHED_BASALT: Material;
  static readonly SMOOTH_BASALT: Material;
  static readonly SOUL_TORCH: Material;
  static readonly GLOWSTONE: Material;
  static readonly INFESTED_STONE: Material;
  static readonly INFESTED_COBBLESTONE: Material;
  static readonly INFESTED_STONE_BRICKS: Material;
  static readonly INFESTED_MOSSY_STONE_BRICKS: Material;
  static readonly INFESTED_CRACKED_STONE_BRICKS: Material;
  static readonly INFESTED_CHISELED_STONE_BRICKS: Material;
  /**
   * BlockData: {@link Orientable}
  */
  static readonly INFESTED_DEEPSLATE: Material;
  static readonly STONE_BRICKS: Material;
  static readonly MOSSY_STONE_BRICKS: Material;
  static readonly CRACKED_STONE_BRICKS: Material;
  static readonly CHISELED_STONE_BRICKS: Material;
  static readonly DEEPSLATE_BRICKS: Material;
  static readonly CRACKED_DEEPSLATE_BRICKS: Material;
  static readonly DEEPSLATE_TILES: Material;
  static readonly CRACKED_DEEPSLATE_TILES: Material;
  static readonly CHISELED_DEEPSLATE: Material;
  /**
   * BlockData: {@link MultipleFacing}
  */
  static readonly BROWN_MUSHROOM_BLOCK: Material;
  /**
   * BlockData: {@link MultipleFacing}
  */
  static readonly RED_MUSHROOM_BLOCK: Material;
  /**
   * BlockData: {@link MultipleFacing}
  */
  static readonly MUSHROOM_STEM: Material;
  /**
   * BlockData: {@link Fence}
  */
  static readonly IRON_BARS: Material;
  /**
   * BlockData: {@link Chain}
  */
  static readonly CHAIN: Material;
  /**
   * BlockData: {@link Fence}
  */
  static readonly GLASS_PANE: Material;
  static readonly MELON: Material;
  /**
   * BlockData: {@link MultipleFacing}
  */
  static readonly VINE: Material;
  /**
   * BlockData: {@link GlowLichen}
  */
  static readonly GLOW_LICHEN: Material;
  /**
   * BlockData: {@link Stairs}
  */
  static readonly BRICK_STAIRS: Material;
  /**
   * BlockData: {@link Stairs}
  */
  static readonly STONE_BRICK_STAIRS: Material;
  /**
   * BlockData: {@link Snowable}
  */
  static readonly MYCELIUM: Material;
  static readonly LILY_PAD: Material;
  static readonly NETHER_BRICKS: Material;
  static readonly CRACKED_NETHER_BRICKS: Material;
  static readonly CHISELED_NETHER_BRICKS: Material;
  /**
   * BlockData: {@link Fence}
  */
  static readonly NETHER_BRICK_FENCE: Material;
  /**
   * BlockData: {@link Stairs}
  */
  static readonly NETHER_BRICK_STAIRS: Material;
  static readonly ENCHANTING_TABLE: Material;
  /**
   * BlockData: {@link EndPortalFrame}
  */
  static readonly END_PORTAL_FRAME: Material;
  static readonly END_STONE: Material;
  static readonly END_STONE_BRICKS: Material;
  static readonly DRAGON_EGG: Material;
  /**
   * BlockData: {@link Stairs}
  */
  static readonly SANDSTONE_STAIRS: Material;
  /**
   * BlockData: {@link EnderChest}
  */
  static readonly ENDER_CHEST: Material;
  static readonly EMERALD_BLOCK: Material;
  /**
   * BlockData: {@link Stairs}
  */
  static readonly SPRUCE_STAIRS: Material;
  /**
   * BlockData: {@link Stairs}
  */
  static readonly BIRCH_STAIRS: Material;
  /**
   * BlockData: {@link Stairs}
  */
  static readonly JUNGLE_STAIRS: Material;
  /**
   * BlockData: {@link Stairs}
  */
  static readonly CRIMSON_STAIRS: Material;
  /**
   * BlockData: {@link Stairs}
  */
  static readonly WARPED_STAIRS: Material;
  /**
   * BlockData: {@link CommandBlock}
  */
  static readonly COMMAND_BLOCK: Material;
  static readonly BEACON: Material;
  /**
   * BlockData: {@link Wall}
  */
  static readonly COBBLESTONE_WALL: Material;
  /**
   * BlockData: {@link Wall}
  */
  static readonly MOSSY_COBBLESTONE_WALL: Material;
  /**
   * BlockData: {@link Wall}
  */
  static readonly BRICK_WALL: Material;
  /**
   * BlockData: {@link Wall}
  */
  static readonly PRISMARINE_WALL: Material;
  /**
   * BlockData: {@link Wall}
  */
  static readonly RED_SANDSTONE_WALL: Material;
  /**
   * BlockData: {@link Wall}
  */
  static readonly MOSSY_STONE_BRICK_WALL: Material;
  /**
   * BlockData: {@link Wall}
  */
  static readonly GRANITE_WALL: Material;
  /**
   * BlockData: {@link Wall}
  */
  static readonly STONE_BRICK_WALL: Material;
  /**
   * BlockData: {@link Wall}
  */
  static readonly NETHER_BRICK_WALL: Material;
  /**
   * BlockData: {@link Wall}
  */
  static readonly ANDESITE_WALL: Material;
  /**
   * BlockData: {@link Wall}
  */
  static readonly RED_NETHER_BRICK_WALL: Material;
  /**
   * BlockData: {@link Wall}
  */
  static readonly SANDSTONE_WALL: Material;
  /**
   * BlockData: {@link Wall}
  */
  static readonly END_STONE_BRICK_WALL: Material;
  /**
   * BlockData: {@link Wall}
  */
  static readonly DIORITE_WALL: Material;
  /**
   * BlockData: {@link Wall}
  */
  static readonly BLACKSTONE_WALL: Material;
  /**
   * BlockData: {@link Wall}
  */
  static readonly POLISHED_BLACKSTONE_WALL: Material;
  /**
   * BlockData: {@link Wall}
  */
  static readonly POLISHED_BLACKSTONE_BRICK_WALL: Material;
  /**
   * BlockData: {@link Wall}
  */
  static readonly COBBLED_DEEPSLATE_WALL: Material;
  /**
   * BlockData: {@link Wall}
  */
  static readonly POLISHED_DEEPSLATE_WALL: Material;
  /**
   * BlockData: {@link Wall}
  */
  static readonly DEEPSLATE_BRICK_WALL: Material;
  /**
   * BlockData: {@link Wall}
  */
  static readonly DEEPSLATE_TILE_WALL: Material;
  /**
   * BlockData: {@link Directional}
  */
  static readonly ANVIL: Material;
  /**
   * BlockData: {@link Directional}
  */
  static readonly CHIPPED_ANVIL: Material;
  /**
   * BlockData: {@link Directional}
  */
  static readonly DAMAGED_ANVIL: Material;
  static readonly CHISELED_QUARTZ_BLOCK: Material;
  static readonly QUARTZ_BLOCK: Material;
  static readonly QUARTZ_BRICKS: Material;
  /**
   * BlockData: {@link Orientable}
  */
  static readonly QUARTZ_PILLAR: Material;
  /**
   * BlockData: {@link Stairs}
  */
  static readonly QUARTZ_STAIRS: Material;
  static readonly WHITE_TERRACOTTA: Material;
  static readonly ORANGE_TERRACOTTA: Material;
  static readonly MAGENTA_TERRACOTTA: Material;
  static readonly LIGHT_BLUE_TERRACOTTA: Material;
  static readonly YELLOW_TERRACOTTA: Material;
  static readonly LIME_TERRACOTTA: Material;
  static readonly PINK_TERRACOTTA: Material;
  static readonly GRAY_TERRACOTTA: Material;
  static readonly LIGHT_GRAY_TERRACOTTA: Material;
  static readonly CYAN_TERRACOTTA: Material;
  static readonly PURPLE_TERRACOTTA: Material;
  static readonly BLUE_TERRACOTTA: Material;
  static readonly BROWN_TERRACOTTA: Material;
  static readonly GREEN_TERRACOTTA: Material;
  static readonly RED_TERRACOTTA: Material;
  static readonly BLACK_TERRACOTTA: Material;
  static readonly BARRIER: Material;
  /**
   * BlockData: {@link Light}
  */
  static readonly LIGHT: Material;
  /**
   * BlockData: {@link Orientable}
  */
  static readonly HAY_BLOCK: Material;
  static readonly WHITE_CARPET: Material;
  static readonly ORANGE_CARPET: Material;
  static readonly MAGENTA_CARPET: Material;
  static readonly LIGHT_BLUE_CARPET: Material;
  static readonly YELLOW_CARPET: Material;
  static readonly LIME_CARPET: Material;
  static readonly PINK_CARPET: Material;
  static readonly GRAY_CARPET: Material;
  static readonly LIGHT_GRAY_CARPET: Material;
  static readonly CYAN_CARPET: Material;
  static readonly PURPLE_CARPET: Material;
  static readonly BLUE_CARPET: Material;
  static readonly BROWN_CARPET: Material;
  static readonly GREEN_CARPET: Material;
  static readonly RED_CARPET: Material;
  static readonly BLACK_CARPET: Material;
  static readonly TERRACOTTA: Material;
  static readonly PACKED_ICE: Material;
  /**
   * BlockData: {@link Stairs}
  */
  static readonly ACACIA_STAIRS: Material;
  /**
   * BlockData: {@link Stairs}
  */
  static readonly DARK_OAK_STAIRS: Material;
  static readonly DIRT_PATH: Material;
  /**
   * BlockData: {@link Bisected}
  */
  static readonly SUNFLOWER: Material;
  /**
   * BlockData: {@link Bisected}
  */
  static readonly LILAC: Material;
  /**
   * BlockData: {@link Bisected}
  */
  static readonly ROSE_BUSH: Material;
  /**
   * BlockData: {@link Bisected}
  */
  static readonly PEONY: Material;
  /**
   * BlockData: {@link Bisected}
  */
  static readonly TALL_GRASS: Material;
  /**
   * BlockData: {@link Bisected}
  */
  static readonly LARGE_FERN: Material;
  static readonly WHITE_STAINED_GLASS: Material;
  static readonly ORANGE_STAINED_GLASS: Material;
  static readonly MAGENTA_STAINED_GLASS: Material;
  static readonly LIGHT_BLUE_STAINED_GLASS: Material;
  static readonly YELLOW_STAINED_GLASS: Material;
  static readonly LIME_STAINED_GLASS: Material;
  static readonly PINK_STAINED_GLASS: Material;
  static readonly GRAY_STAINED_GLASS: Material;
  static readonly LIGHT_GRAY_STAINED_GLASS: Material;
  static readonly CYAN_STAINED_GLASS: Material;
  static readonly PURPLE_STAINED_GLASS: Material;
  static readonly BLUE_STAINED_GLASS: Material;
  static readonly BROWN_STAINED_GLASS: Material;
  static readonly GREEN_STAINED_GLASS: Material;
  static readonly RED_STAINED_GLASS: Material;
  static readonly BLACK_STAINED_GLASS: Material;
  /**
   * BlockData: {@link GlassPane}
  */
  static readonly WHITE_STAINED_GLASS_PANE: Material;
  /**
   * BlockData: {@link GlassPane}
  */
  static readonly ORANGE_STAINED_GLASS_PANE: Material;
  /**
   * BlockData: {@link GlassPane}
  */
  static readonly MAGENTA_STAINED_GLASS_PANE: Material;
  /**
   * BlockData: {@link GlassPane}
  */
  static readonly LIGHT_BLUE_STAINED_GLASS_PANE: Material;
  /**
   * BlockData: {@link GlassPane}
  */
  static readonly YELLOW_STAINED_GLASS_PANE: Material;
  /**
   * BlockData: {@link GlassPane}
  */
  static readonly LIME_STAINED_GLASS_PANE: Material;
  /**
   * BlockData: {@link GlassPane}
  */
  static readonly PINK_STAINED_GLASS_PANE: Material;
  /**
   * BlockData: {@link GlassPane}
  */
  static readonly GRAY_STAINED_GLASS_PANE: Material;
  /**
   * BlockData: {@link GlassPane}
  */
  static readonly LIGHT_GRAY_STAINED_GLASS_PANE: Material;
  /**
   * BlockData: {@link GlassPane}
  */
  static readonly CYAN_STAINED_GLASS_PANE: Material;
  /**
   * BlockData: {@link GlassPane}
  */
  static readonly PURPLE_STAINED_GLASS_PANE: Material;
  /**
   * BlockData: {@link GlassPane}
  */
  static readonly BLUE_STAINED_GLASS_PANE: Material;
  /**
   * BlockData: {@link GlassPane}
  */
  static readonly BROWN_STAINED_GLASS_PANE: Material;
  /**
   * BlockData: {@link GlassPane}
  */
  static readonly GREEN_STAINED_GLASS_PANE: Material;
  /**
   * BlockData: {@link GlassPane}
  */
  static readonly RED_STAINED_GLASS_PANE: Material;
  /**
   * BlockData: {@link GlassPane}
  */
  static readonly BLACK_STAINED_GLASS_PANE: Material;
  static readonly PRISMARINE: Material;
  static readonly PRISMARINE_BRICKS: Material;
  static readonly DARK_PRISMARINE: Material;
  /**
   * BlockData: {@link Stairs}
  */
  static readonly PRISMARINE_STAIRS: Material;
  /**
   * BlockData: {@link Stairs}
  */
  static readonly PRISMARINE_BRICK_STAIRS: Material;
  /**
   * BlockData: {@link Stairs}
  */
  static readonly DARK_PRISMARINE_STAIRS: Material;
  static readonly SEA_LANTERN: Material;
  static readonly RED_SANDSTONE: Material;
  static readonly CHISELED_RED_SANDSTONE: Material;
  static readonly CUT_RED_SANDSTONE: Material;
  /**
   * BlockData: {@link Stairs}
  */
  static readonly RED_SANDSTONE_STAIRS: Material;
  /**
   * BlockData: {@link CommandBlock}
  */
  static readonly REPEATING_COMMAND_BLOCK: Material;
  /**
   * BlockData: {@link CommandBlock}
  */
  static readonly CHAIN_COMMAND_BLOCK: Material;
  static readonly MAGMA_BLOCK: Material;
  static readonly NETHER_WART_BLOCK: Material;
  static readonly WARPED_WART_BLOCK: Material;
  static readonly RED_NETHER_BRICKS: Material;
  /**
   * BlockData: {@link Orientable}
  */
  static readonly BONE_BLOCK: Material;
  static readonly STRUCTURE_VOID: Material;
  /**
   * BlockData: {@link Directional}
  */
  static readonly SHULKER_BOX: Material;
  /**
   * BlockData: {@link Directional}
  */
  static readonly WHITE_SHULKER_BOX: Material;
  /**
   * BlockData: {@link Directional}
  */
  static readonly ORANGE_SHULKER_BOX: Material;
  /**
   * BlockData: {@link Directional}
  */
  static readonly MAGENTA_SHULKER_BOX: Material;
  /**
   * BlockData: {@link Directional}
  */
  static readonly LIGHT_BLUE_SHULKER_BOX: Material;
  /**
   * BlockData: {@link Directional}
  */
  static readonly YELLOW_SHULKER_BOX: Material;
  /**
   * BlockData: {@link Directional}
  */
  static readonly LIME_SHULKER_BOX: Material;
  /**
   * BlockData: {@link Directional}
  */
  static readonly PINK_SHULKER_BOX: Material;
  /**
   * BlockData: {@link Directional}
  */
  static readonly GRAY_SHULKER_BOX: Material;
  /**
   * BlockData: {@link Directional}
  */
  static readonly LIGHT_GRAY_SHULKER_BOX: Material;
  /**
   * BlockData: {@link Directional}
  */
  static readonly CYAN_SHULKER_BOX: Material;
  /**
   * BlockData: {@link Directional}
  */
  static readonly PURPLE_SHULKER_BOX: Material;
  /**
   * BlockData: {@link Directional}
  */
  static readonly BLUE_SHULKER_BOX: Material;
  /**
   * BlockData: {@link Directional}
  */
  static readonly BROWN_SHULKER_BOX: Material;
  /**
   * BlockData: {@link Directional}
  */
  static readonly GREEN_SHULKER_BOX: Material;
  /**
   * BlockData: {@link Directional}
  */
  static readonly RED_SHULKER_BOX: Material;
  /**
   * BlockData: {@link Directional}
  */
  static readonly BLACK_SHULKER_BOX: Material;
  /**
   * BlockData: {@link Directional}
  */
  static readonly WHITE_GLAZED_TERRACOTTA: Material;
  /**
   * BlockData: {@link Directional}
  */
  static readonly ORANGE_GLAZED_TERRACOTTA: Material;
  /**
   * BlockData: {@link Directional}
  */
  static readonly MAGENTA_GLAZED_TERRACOTTA: Material;
  /**
   * BlockData: {@link Directional}
  */
  static readonly LIGHT_BLUE_GLAZED_TERRACOTTA: Material;
  /**
   * BlockData: {@link Directional}
  */
  static readonly YELLOW_GLAZED_TERRACOTTA: Material;
  /**
   * BlockData: {@link Directional}
  */
  static readonly LIME_GLAZED_TERRACOTTA: Material;
  /**
   * BlockData: {@link Directional}
  */
  static readonly PINK_GLAZED_TERRACOTTA: Material;
  /**
   * BlockData: {@link Directional}
  */
  static readonly GRAY_GLAZED_TERRACOTTA: Material;
  /**
   * BlockData: {@link Directional}
  */
  static readonly LIGHT_GRAY_GLAZED_TERRACOTTA: Material;
  /**
   * BlockData: {@link Directional}
  */
  static readonly CYAN_GLAZED_TERRACOTTA: Material;
  /**
   * BlockData: {@link Directional}
  */
  static readonly PURPLE_GLAZED_TERRACOTTA: Material;
  /**
   * BlockData: {@link Directional}
  */
  static readonly BLUE_GLAZED_TERRACOTTA: Material;
  /**
   * BlockData: {@link Directional}
  */
  static readonly BROWN_GLAZED_TERRACOTTA: Material;
  /**
   * BlockData: {@link Directional}
  */
  static readonly GREEN_GLAZED_TERRACOTTA: Material;
  /**
   * BlockData: {@link Directional}
  */
  static readonly RED_GLAZED_TERRACOTTA: Material;
  /**
   * BlockData: {@link Directional}
  */
  static readonly BLACK_GLAZED_TERRACOTTA: Material;
  static readonly WHITE_CONCRETE: Material;
  static readonly ORANGE_CONCRETE: Material;
  static readonly MAGENTA_CONCRETE: Material;
  static readonly LIGHT_BLUE_CONCRETE: Material;
  static readonly YELLOW_CONCRETE: Material;
  static readonly LIME_CONCRETE: Material;
  static readonly PINK_CONCRETE: Material;
  static readonly GRAY_CONCRETE: Material;
  static readonly LIGHT_GRAY_CONCRETE: Material;
  static readonly CYAN_CONCRETE: Material;
  static readonly PURPLE_CONCRETE: Material;
  static readonly BLUE_CONCRETE: Material;
  static readonly BROWN_CONCRETE: Material;
  static readonly GREEN_CONCRETE: Material;
  static readonly RED_CONCRETE: Material;
  static readonly BLACK_CONCRETE: Material;
  static readonly WHITE_CONCRETE_POWDER: Material;
  static readonly ORANGE_CONCRETE_POWDER: Material;
  static readonly MAGENTA_CONCRETE_POWDER: Material;
  static readonly LIGHT_BLUE_CONCRETE_POWDER: Material;
  static readonly YELLOW_CONCRETE_POWDER: Material;
  static readonly LIME_CONCRETE_POWDER: Material;
  static readonly PINK_CONCRETE_POWDER: Material;
  static readonly GRAY_CONCRETE_POWDER: Material;
  static readonly LIGHT_GRAY_CONCRETE_POWDER: Material;
  static readonly CYAN_CONCRETE_POWDER: Material;
  static readonly PURPLE_CONCRETE_POWDER: Material;
  static readonly BLUE_CONCRETE_POWDER: Material;
  static readonly BROWN_CONCRETE_POWDER: Material;
  static readonly GREEN_CONCRETE_POWDER: Material;
  static readonly RED_CONCRETE_POWDER: Material;
  static readonly BLACK_CONCRETE_POWDER: Material;
  /**
   * BlockData: {@link TurtleEgg}
  */
  static readonly TURTLE_EGG: Material;
  static readonly DEAD_TUBE_CORAL_BLOCK: Material;
  static readonly DEAD_BRAIN_CORAL_BLOCK: Material;
  static readonly DEAD_BUBBLE_CORAL_BLOCK: Material;
  static readonly DEAD_FIRE_CORAL_BLOCK: Material;
  static readonly DEAD_HORN_CORAL_BLOCK: Material;
  static readonly TUBE_CORAL_BLOCK: Material;
  static readonly BRAIN_CORAL_BLOCK: Material;
  static readonly BUBBLE_CORAL_BLOCK: Material;
  static readonly FIRE_CORAL_BLOCK: Material;
  static readonly HORN_CORAL_BLOCK: Material;
  /**
   * BlockData: {@link Waterlogged}
  */
  static readonly TUBE_CORAL: Material;
  /**
   * BlockData: {@link Waterlogged}
  */
  static readonly BRAIN_CORAL: Material;
  /**
   * BlockData: {@link Waterlogged}
  */
  static readonly BUBBLE_CORAL: Material;
  /**
   * BlockData: {@link Waterlogged}
  */
  static readonly FIRE_CORAL: Material;
  /**
   * BlockData: {@link Waterlogged}
  */
  static readonly HORN_CORAL: Material;
  /**
   * BlockData: {@link Waterlogged}
  */
  static readonly DEAD_BRAIN_CORAL: Material;
  /**
   * BlockData: {@link Waterlogged}
  */
  static readonly DEAD_BUBBLE_CORAL: Material;
  /**
   * BlockData: {@link Waterlogged}
  */
  static readonly DEAD_FIRE_CORAL: Material;
  /**
   * BlockData: {@link Waterlogged}
  */
  static readonly DEAD_HORN_CORAL: Material;
  /**
   * BlockData: {@link Waterlogged}
  */
  static readonly DEAD_TUBE_CORAL: Material;
  /**
   * BlockData: {@link Waterlogged}
  */
  static readonly TUBE_CORAL_FAN: Material;
  /**
   * BlockData: {@link Waterlogged}
  */
  static readonly BRAIN_CORAL_FAN: Material;
  /**
   * BlockData: {@link Waterlogged}
  */
  static readonly BUBBLE_CORAL_FAN: Material;
  /**
   * BlockData: {@link Waterlogged}
  */
  static readonly FIRE_CORAL_FAN: Material;
  /**
   * BlockData: {@link Waterlogged}
  */
  static readonly HORN_CORAL_FAN: Material;
  /**
   * BlockData: {@link Waterlogged}
  */
  static readonly DEAD_TUBE_CORAL_FAN: Material;
  /**
   * BlockData: {@link Waterlogged}
  */
  static readonly DEAD_BRAIN_CORAL_FAN: Material;
  /**
   * BlockData: {@link Waterlogged}
  */
  static readonly DEAD_BUBBLE_CORAL_FAN: Material;
  /**
   * BlockData: {@link Waterlogged}
  */
  static readonly DEAD_FIRE_CORAL_FAN: Material;
  /**
   * BlockData: {@link Waterlogged}
  */
  static readonly DEAD_HORN_CORAL_FAN: Material;
  static readonly BLUE_ICE: Material;
  /**
   * BlockData: {@link Waterlogged}
  */
  static readonly CONDUIT: Material;
  /**
   * BlockData: {@link Stairs}
  */
  static readonly POLISHED_GRANITE_STAIRS: Material;
  /**
   * BlockData: {@link Stairs}
  */
  static readonly SMOOTH_RED_SANDSTONE_STAIRS: Material;
  /**
   * BlockData: {@link Stairs}
  */
  static readonly MOSSY_STONE_BRICK_STAIRS: Material;
  /**
   * BlockData: {@link Stairs}
  */
  static readonly POLISHED_DIORITE_STAIRS: Material;
  /**
   * BlockData: {@link Stairs}
  */
  static readonly MOSSY_COBBLESTONE_STAIRS: Material;
  /**
   * BlockData: {@link Stairs}
  */
  static readonly END_STONE_BRICK_STAIRS: Material;
  /**
   * BlockData: {@link Stairs}
  */
  static readonly STONE_STAIRS: Material;
  /**
   * BlockData: {@link Stairs}
  */
  static readonly SMOOTH_SANDSTONE_STAIRS: Material;
  /**
   * BlockData: {@link Stairs}
  */
  static readonly SMOOTH_QUARTZ_STAIRS: Material;
  /**
   * BlockData: {@link Stairs}
  */
  static readonly GRANITE_STAIRS: Material;
  /**
   * BlockData: {@link Stairs}
  */
  static readonly ANDESITE_STAIRS: Material;
  /**
   * BlockData: {@link Stairs}
  */
  static readonly RED_NETHER_BRICK_STAIRS: Material;
  /**
   * BlockData: {@link Stairs}
  */
  static readonly POLISHED_ANDESITE_STAIRS: Material;
  /**
   * BlockData: {@link Stairs}
  */
  static readonly DIORITE_STAIRS: Material;
  /**
   * BlockData: {@link Stairs}
  */
  static readonly COBBLED_DEEPSLATE_STAIRS: Material;
  /**
   * BlockData: {@link Stairs}
  */
  static readonly POLISHED_DEEPSLATE_STAIRS: Material;
  /**
   * BlockData: {@link Stairs}
  */
  static readonly DEEPSLATE_BRICK_STAIRS: Material;
  /**
   * BlockData: {@link Stairs}
  */
  static readonly DEEPSLATE_TILE_STAIRS: Material;
  /**
   * BlockData: {@link Slab}
  */
  static readonly POLISHED_GRANITE_SLAB: Material;
  /**
   * BlockData: {@link Slab}
  */
  static readonly SMOOTH_RED_SANDSTONE_SLAB: Material;
  /**
   * BlockData: {@link Slab}
  */
  static readonly MOSSY_STONE_BRICK_SLAB: Material;
  /**
   * BlockData: {@link Slab}
  */
  static readonly POLISHED_DIORITE_SLAB: Material;
  /**
   * BlockData: {@link Slab}
  */
  static readonly MOSSY_COBBLESTONE_SLAB: Material;
  /**
   * BlockData: {@link Slab}
  */
  static readonly END_STONE_BRICK_SLAB: Material;
  /**
   * BlockData: {@link Slab}
  */
  static readonly SMOOTH_SANDSTONE_SLAB: Material;
  /**
   * BlockData: {@link Slab}
  */
  static readonly SMOOTH_QUARTZ_SLAB: Material;
  /**
   * BlockData: {@link Slab}
  */
  static readonly GRANITE_SLAB: Material;
  /**
   * BlockData: {@link Slab}
  */
  static readonly ANDESITE_SLAB: Material;
  /**
   * BlockData: {@link Slab}
  */
  static readonly RED_NETHER_BRICK_SLAB: Material;
  /**
   * BlockData: {@link Slab}
  */
  static readonly POLISHED_ANDESITE_SLAB: Material;
  /**
   * BlockData: {@link Slab}
  */
  static readonly DIORITE_SLAB: Material;
  /**
   * BlockData: {@link Slab}
  */
  static readonly COBBLED_DEEPSLATE_SLAB: Material;
  /**
   * BlockData: {@link Slab}
  */
  static readonly POLISHED_DEEPSLATE_SLAB: Material;
  /**
   * BlockData: {@link Slab}
  */
  static readonly DEEPSLATE_BRICK_SLAB: Material;
  /**
   * BlockData: {@link Slab}
  */
  static readonly DEEPSLATE_TILE_SLAB: Material;
  /**
   * BlockData: {@link Scaffolding}
  */
  static readonly SCAFFOLDING: Material;
  static readonly REDSTONE: Material;
  /**
   * BlockData: {@link Lightable}
  */
  static readonly REDSTONE_TORCH: Material;
  static readonly REDSTONE_BLOCK: Material;
  /**
   * BlockData: {@link Repeater}
  */
  static readonly REPEATER: Material;
  /**
   * BlockData: {@link Comparator}
  */
  static readonly COMPARATOR: Material;
  /**
   * BlockData: {@link Piston}
  */
  static readonly PISTON: Material;
  /**
   * BlockData: {@link Piston}
  */
  static readonly STICKY_PISTON: Material;
  static readonly SLIME_BLOCK: Material;
  static readonly HONEY_BLOCK: Material;
  /**
   * BlockData: {@link Observer}
  */
  static readonly OBSERVER: Material;
  /**
   * BlockData: {@link Hopper}
  */
  static readonly HOPPER: Material;
  /**
   * BlockData: {@link Dispenser}
  */
  static readonly DISPENSER: Material;
  /**
   * BlockData: {@link Dispenser}
  */
  static readonly DROPPER: Material;
  /**
   * BlockData: {@link Lectern}
  */
  static readonly LECTERN: Material;
  /**
   * BlockData: {@link AnaloguePowerable}
  */
  static readonly TARGET: Material;
  /**
   * BlockData: {@link Switch}
  */
  static readonly LEVER: Material;
  /**
   * BlockData: {@link LightningRod}
  */
  static readonly LIGHTNING_ROD: Material;
  /**
   * BlockData: {@link DaylightDetector}
  */
  static readonly DAYLIGHT_DETECTOR: Material;
  /**
   * BlockData: {@link SculkSensor}
  */
  static readonly SCULK_SENSOR: Material;
  /**
   * BlockData: {@link TripwireHook}
  */
  static readonly TRIPWIRE_HOOK: Material;
  /**
   * BlockData: {@link Chest}
  */
  static readonly TRAPPED_CHEST: Material;
  /**
   * BlockData: {@link TNT}
  */
  static readonly TNT: Material;
  /**
   * BlockData: {@link Lightable}
  */
  static readonly REDSTONE_LAMP: Material;
  /**
   * BlockData: {@link NoteBlock}
  */
  static readonly NOTE_BLOCK: Material;
  /**
   * BlockData: {@link Switch}
  */
  static readonly STONE_BUTTON: Material;
  /**
   * BlockData: {@link Switch}
  */
  static readonly POLISHED_BLACKSTONE_BUTTON: Material;
  /**
   * BlockData: {@link Switch}
  */
  static readonly OAK_BUTTON: Material;
  /**
   * BlockData: {@link Switch}
  */
  static readonly SPRUCE_BUTTON: Material;
  /**
   * BlockData: {@link Switch}
  */
  static readonly BIRCH_BUTTON: Material;
  /**
   * BlockData: {@link Switch}
  */
  static readonly JUNGLE_BUTTON: Material;
  /**
   * BlockData: {@link Switch}
  */
  static readonly ACACIA_BUTTON: Material;
  /**
   * BlockData: {@link Switch}
  */
  static readonly DARK_OAK_BUTTON: Material;
  /**
   * BlockData: {@link Switch}
  */
  static readonly CRIMSON_BUTTON: Material;
  /**
   * BlockData: {@link Switch}
  */
  static readonly WARPED_BUTTON: Material;
  /**
   * BlockData: {@link Powerable}
  */
  static readonly STONE_PRESSURE_PLATE: Material;
  /**
   * BlockData: {@link Powerable}
  */
  static readonly POLISHED_BLACKSTONE_PRESSURE_PLATE: Material;
  /**
   * BlockData: {@link AnaloguePowerable}
  */
  static readonly LIGHT_WEIGHTED_PRESSURE_PLATE: Material;
  /**
   * BlockData: {@link AnaloguePowerable}
  */
  static readonly HEAVY_WEIGHTED_PRESSURE_PLATE: Material;
  /**
   * BlockData: {@link Powerable}
  */
  static readonly OAK_PRESSURE_PLATE: Material;
  /**
   * BlockData: {@link Powerable}
  */
  static readonly SPRUCE_PRESSURE_PLATE: Material;
  /**
   * BlockData: {@link Powerable}
  */
  static readonly BIRCH_PRESSURE_PLATE: Material;
  /**
   * BlockData: {@link Powerable}
  */
  static readonly JUNGLE_PRESSURE_PLATE: Material;
  /**
   * BlockData: {@link Powerable}
  */
  static readonly ACACIA_PRESSURE_PLATE: Material;
  /**
   * BlockData: {@link Powerable}
  */
  static readonly DARK_OAK_PRESSURE_PLATE: Material;
  /**
   * BlockData: {@link Powerable}
  */
  static readonly CRIMSON_PRESSURE_PLATE: Material;
  /**
   * BlockData: {@link Powerable}
  */
  static readonly WARPED_PRESSURE_PLATE: Material;
  /**
   * BlockData: {@link Door}
  */
  static readonly IRON_DOOR: Material;
  /**
   * BlockData: {@link Door}
  */
  static readonly OAK_DOOR: Material;
  /**
   * BlockData: {@link Door}
  */
  static readonly SPRUCE_DOOR: Material;
  /**
   * BlockData: {@link Door}
  */
  static readonly BIRCH_DOOR: Material;
  /**
   * BlockData: {@link Door}
  */
  static readonly JUNGLE_DOOR: Material;
  /**
   * BlockData: {@link Door}
  */
  static readonly ACACIA_DOOR: Material;
  /**
   * BlockData: {@link Door}
  */
  static readonly DARK_OAK_DOOR: Material;
  /**
   * BlockData: {@link Door}
  */
  static readonly CRIMSON_DOOR: Material;
  /**
   * BlockData: {@link Door}
  */
  static readonly WARPED_DOOR: Material;
  /**
   * BlockData: {@link TrapDoor}
  */
  static readonly IRON_TRAPDOOR: Material;
  /**
   * BlockData: {@link TrapDoor}
  */
  static readonly OAK_TRAPDOOR: Material;
  /**
   * BlockData: {@link TrapDoor}
  */
  static readonly SPRUCE_TRAPDOOR: Material;
  /**
   * BlockData: {@link TrapDoor}
  */
  static readonly BIRCH_TRAPDOOR: Material;
  /**
   * BlockData: {@link TrapDoor}
  */
  static readonly JUNGLE_TRAPDOOR: Material;
  /**
   * BlockData: {@link TrapDoor}
  */
  static readonly ACACIA_TRAPDOOR: Material;
  /**
   * BlockData: {@link TrapDoor}
  */
  static readonly DARK_OAK_TRAPDOOR: Material;
  /**
   * BlockData: {@link TrapDoor}
  */
  static readonly CRIMSON_TRAPDOOR: Material;
  /**
   * BlockData: {@link TrapDoor}
  */
  static readonly WARPED_TRAPDOOR: Material;
  /**
   * BlockData: {@link Gate}
  */
  static readonly OAK_FENCE_GATE: Material;
  /**
   * BlockData: {@link Gate}
  */
  static readonly SPRUCE_FENCE_GATE: Material;
  /**
   * BlockData: {@link Gate}
  */
  static readonly BIRCH_FENCE_GATE: Material;
  /**
   * BlockData: {@link Gate}
  */
  static readonly JUNGLE_FENCE_GATE: Material;
  /**
   * BlockData: {@link Gate}
  */
  static readonly ACACIA_FENCE_GATE: Material;
  /**
   * BlockData: {@link Gate}
  */
  static readonly DARK_OAK_FENCE_GATE: Material;
  /**
   * BlockData: {@link Gate}
  */
  static readonly CRIMSON_FENCE_GATE: Material;
  /**
   * BlockData: {@link Gate}
  */
  static readonly WARPED_FENCE_GATE: Material;
  /**
   * BlockData: {@link RedstoneRail}
  */
  static readonly POWERED_RAIL: Material;
  /**
   * BlockData: {@link RedstoneRail}
  */
  static readonly DETECTOR_RAIL: Material;
  /**
   * BlockData: {@link Rail}
  */
  static readonly RAIL: Material;
  /**
   * BlockData: {@link RedstoneRail}
  */
  static readonly ACTIVATOR_RAIL: Material;
  static readonly SADDLE: Material;
  static readonly MINECART: Material;
  static readonly CHEST_MINECART: Material;
  static readonly FURNACE_MINECART: Material;
  static readonly TNT_MINECART: Material;
  static readonly HOPPER_MINECART: Material;
  static readonly CARROT_ON_A_STICK: Material;
  static readonly WARPED_FUNGUS_ON_A_STICK: Material;
  static readonly ELYTRA: Material;
  static readonly OAK_BOAT: Material;
  static readonly SPRUCE_BOAT: Material;
  static readonly BIRCH_BOAT: Material;
  static readonly JUNGLE_BOAT: Material;
  static readonly ACACIA_BOAT: Material;
  static readonly DARK_OAK_BOAT: Material;
  /**
   * BlockData: {@link StructureBlock}
  */
  static readonly STRUCTURE_BLOCK: Material;
  /**
   * BlockData: {@link Jigsaw}
  */
  static readonly JIGSAW: Material;
  static readonly TURTLE_HELMET: Material;
  static readonly SCUTE: Material;
  static readonly FLINT_AND_STEEL: Material;
  static readonly APPLE: Material;
  static readonly BOW: Material;
  static readonly ARROW: Material;
  static readonly COAL: Material;
  static readonly CHARCOAL: Material;
  static readonly DIAMOND: Material;
  static readonly EMERALD: Material;
  static readonly LAPIS_LAZULI: Material;
  static readonly QUARTZ: Material;
  static readonly AMETHYST_SHARD: Material;
  static readonly RAW_IRON: Material;
  static readonly IRON_INGOT: Material;
  static readonly RAW_COPPER: Material;
  static readonly COPPER_INGOT: Material;
  static readonly RAW_GOLD: Material;
  static readonly GOLD_INGOT: Material;
  static readonly NETHERITE_INGOT: Material;
  static readonly NETHERITE_SCRAP: Material;
  static readonly WOODEN_SWORD: Material;
  static readonly WOODEN_SHOVEL: Material;
  static readonly WOODEN_PICKAXE: Material;
  static readonly WOODEN_AXE: Material;
  static readonly WOODEN_HOE: Material;
  static readonly STONE_SWORD: Material;
  static readonly STONE_SHOVEL: Material;
  static readonly STONE_PICKAXE: Material;
  static readonly STONE_AXE: Material;
  static readonly STONE_HOE: Material;
  static readonly GOLDEN_SWORD: Material;
  static readonly GOLDEN_SHOVEL: Material;
  static readonly GOLDEN_PICKAXE: Material;
  static readonly GOLDEN_AXE: Material;
  static readonly GOLDEN_HOE: Material;
  static readonly IRON_SWORD: Material;
  static readonly IRON_SHOVEL: Material;
  static readonly IRON_PICKAXE: Material;
  static readonly IRON_AXE: Material;
  static readonly IRON_HOE: Material;
  static readonly DIAMOND_SWORD: Material;
  static readonly DIAMOND_SHOVEL: Material;
  static readonly DIAMOND_PICKAXE: Material;
  static readonly DIAMOND_AXE: Material;
  static readonly DIAMOND_HOE: Material;
  static readonly NETHERITE_SWORD: Material;
  static readonly NETHERITE_SHOVEL: Material;
  static readonly NETHERITE_PICKAXE: Material;
  static readonly NETHERITE_AXE: Material;
  static readonly NETHERITE_HOE: Material;
  static readonly STICK: Material;
  static readonly BOWL: Material;
  static readonly MUSHROOM_STEW: Material;
  static readonly STRING: Material;
  static readonly FEATHER: Material;
  static readonly GUNPOWDER: Material;
  static readonly WHEAT_SEEDS: Material;
  /**
   * BlockData: {@link Ageable}
  */
  static readonly WHEAT: Material;
  static readonly BREAD: Material;
  static readonly LEATHER_HELMET: Material;
  static readonly LEATHER_CHESTPLATE: Material;
  static readonly LEATHER_LEGGINGS: Material;
  static readonly LEATHER_BOOTS: Material;
  static readonly CHAINMAIL_HELMET: Material;
  static readonly CHAINMAIL_CHESTPLATE: Material;
  static readonly CHAINMAIL_LEGGINGS: Material;
  static readonly CHAINMAIL_BOOTS: Material;
  static readonly IRON_HELMET: Material;
  static readonly IRON_CHESTPLATE: Material;
  static readonly IRON_LEGGINGS: Material;
  static readonly IRON_BOOTS: Material;
  static readonly DIAMOND_HELMET: Material;
  static readonly DIAMOND_CHESTPLATE: Material;
  static readonly DIAMOND_LEGGINGS: Material;
  static readonly DIAMOND_BOOTS: Material;
  static readonly GOLDEN_HELMET: Material;
  static readonly GOLDEN_CHESTPLATE: Material;
  static readonly GOLDEN_LEGGINGS: Material;
  static readonly GOLDEN_BOOTS: Material;
  static readonly NETHERITE_HELMET: Material;
  static readonly NETHERITE_CHESTPLATE: Material;
  static readonly NETHERITE_LEGGINGS: Material;
  static readonly NETHERITE_BOOTS: Material;
  static readonly FLINT: Material;
  static readonly PORKCHOP: Material;
  static readonly COOKED_PORKCHOP: Material;
  static readonly PAINTING: Material;
  static readonly GOLDEN_APPLE: Material;
  static readonly ENCHANTED_GOLDEN_APPLE: Material;
  /**
   * BlockData: {@link Sign}
  */
  static readonly OAK_SIGN: Material;
  /**
   * BlockData: {@link Sign}
  */
  static readonly SPRUCE_SIGN: Material;
  /**
   * BlockData: {@link Sign}
  */
  static readonly BIRCH_SIGN: Material;
  /**
   * BlockData: {@link Sign}
  */
  static readonly JUNGLE_SIGN: Material;
  /**
   * BlockData: {@link Sign}
  */
  static readonly ACACIA_SIGN: Material;
  /**
   * BlockData: {@link Sign}
  */
  static readonly DARK_OAK_SIGN: Material;
  /**
   * BlockData: {@link Sign}
  */
  static readonly CRIMSON_SIGN: Material;
  /**
   * BlockData: {@link Sign}
  */
  static readonly WARPED_SIGN: Material;
  static readonly BUCKET: Material;
  static readonly WATER_BUCKET: Material;
  static readonly LAVA_BUCKET: Material;
  static readonly POWDER_SNOW_BUCKET: Material;
  static readonly SNOWBALL: Material;
  static readonly LEATHER: Material;
  static readonly MILK_BUCKET: Material;
  static readonly PUFFERFISH_BUCKET: Material;
  static readonly SALMON_BUCKET: Material;
  static readonly COD_BUCKET: Material;
  static readonly TROPICAL_FISH_BUCKET: Material;
  static readonly AXOLOTL_BUCKET: Material;
  static readonly BRICK: Material;
  static readonly CLAY_BALL: Material;
  static readonly DRIED_KELP_BLOCK: Material;
  static readonly PAPER: Material;
  static readonly BOOK: Material;
  static readonly SLIME_BALL: Material;
  static readonly EGG: Material;
  static readonly COMPASS: Material;
  static readonly BUNDLE: Material;
  static readonly FISHING_ROD: Material;
  static readonly CLOCK: Material;
  static readonly SPYGLASS: Material;
  static readonly GLOWSTONE_DUST: Material;
  static readonly COD: Material;
  static readonly SALMON: Material;
  static readonly TROPICAL_FISH: Material;
  static readonly PUFFERFISH: Material;
  static readonly COOKED_COD: Material;
  static readonly COOKED_SALMON: Material;
  static readonly INK_SAC: Material;
  static readonly GLOW_INK_SAC: Material;
  static readonly COCOA_BEANS: Material;
  static readonly WHITE_DYE: Material;
  static readonly ORANGE_DYE: Material;
  static readonly MAGENTA_DYE: Material;
  static readonly LIGHT_BLUE_DYE: Material;
  static readonly YELLOW_DYE: Material;
  static readonly LIME_DYE: Material;
  static readonly PINK_DYE: Material;
  static readonly GRAY_DYE: Material;
  static readonly LIGHT_GRAY_DYE: Material;
  static readonly CYAN_DYE: Material;
  static readonly PURPLE_DYE: Material;
  static readonly BLUE_DYE: Material;
  static readonly BROWN_DYE: Material;
  static readonly GREEN_DYE: Material;
  static readonly RED_DYE: Material;
  static readonly BLACK_DYE: Material;
  static readonly BONE_MEAL: Material;
  static readonly BONE: Material;
  static readonly SUGAR: Material;
  /**
   * BlockData: {@link Cake}
  */
  static readonly CAKE: Material;
  /**
   * BlockData: {@link Bed}
  */
  static readonly WHITE_BED: Material;
  /**
   * BlockData: {@link Bed}
  */
  static readonly ORANGE_BED: Material;
  /**
   * BlockData: {@link Bed}
  */
  static readonly MAGENTA_BED: Material;
  /**
   * BlockData: {@link Bed}
  */
  static readonly LIGHT_BLUE_BED: Material;
  /**
   * BlockData: {@link Bed}
  */
  static readonly YELLOW_BED: Material;
  /**
   * BlockData: {@link Bed}
  */
  static readonly LIME_BED: Material;
  /**
   * BlockData: {@link Bed}
  */
  static readonly PINK_BED: Material;
  /**
   * BlockData: {@link Bed}
  */
  static readonly GRAY_BED: Material;
  /**
   * BlockData: {@link Bed}
  */
  static readonly LIGHT_GRAY_BED: Material;
  /**
   * BlockData: {@link Bed}
  */
  static readonly CYAN_BED: Material;
  /**
   * BlockData: {@link Bed}
  */
  static readonly PURPLE_BED: Material;
  /**
   * BlockData: {@link Bed}
  */
  static readonly BLUE_BED: Material;
  /**
   * BlockData: {@link Bed}
  */
  static readonly BROWN_BED: Material;
  /**
   * BlockData: {@link Bed}
  */
  static readonly GREEN_BED: Material;
  /**
   * BlockData: {@link Bed}
  */
  static readonly RED_BED: Material;
  /**
   * BlockData: {@link Bed}
  */
  static readonly BLACK_BED: Material;
  static readonly COOKIE: Material;
  static readonly FILLED_MAP: Material;
  static readonly SHEARS: Material;
  static readonly MELON_SLICE: Material;
  static readonly DRIED_KELP: Material;
  static readonly PUMPKIN_SEEDS: Material;
  static readonly MELON_SEEDS: Material;
  static readonly BEEF: Material;
  static readonly COOKED_BEEF: Material;
  static readonly CHICKEN: Material;
  static readonly COOKED_CHICKEN: Material;
  static readonly ROTTEN_FLESH: Material;
  static readonly ENDER_PEARL: Material;
  static readonly BLAZE_ROD: Material;
  static readonly GHAST_TEAR: Material;
  static readonly GOLD_NUGGET: Material;
  /**
   * BlockData: {@link Ageable}
  */
  static readonly NETHER_WART: Material;
  static readonly POTION: Material;
  static readonly GLASS_BOTTLE: Material;
  static readonly SPIDER_EYE: Material;
  static readonly FERMENTED_SPIDER_EYE: Material;
  static readonly BLAZE_POWDER: Material;
  static readonly MAGMA_CREAM: Material;
  /**
   * BlockData: {@link BrewingStand}
  */
  static readonly BREWING_STAND: Material;
  static readonly CAULDRON: Material;
  static readonly ENDER_EYE: Material;
  static readonly GLISTERING_MELON_SLICE: Material;
  static readonly AXOLOTL_SPAWN_EGG: Material;
  static readonly BAT_SPAWN_EGG: Material;
  static readonly BEE_SPAWN_EGG: Material;
  static readonly BLAZE_SPAWN_EGG: Material;
  static readonly CAT_SPAWN_EGG: Material;
  static readonly CAVE_SPIDER_SPAWN_EGG: Material;
  static readonly CHICKEN_SPAWN_EGG: Material;
  static readonly COD_SPAWN_EGG: Material;
  static readonly COW_SPAWN_EGG: Material;
  static readonly CREEPER_SPAWN_EGG: Material;
  static readonly DOLPHIN_SPAWN_EGG: Material;
  static readonly DONKEY_SPAWN_EGG: Material;
  static readonly DROWNED_SPAWN_EGG: Material;
  static readonly ELDER_GUARDIAN_SPAWN_EGG: Material;
  static readonly ENDERMAN_SPAWN_EGG: Material;
  static readonly ENDERMITE_SPAWN_EGG: Material;
  static readonly EVOKER_SPAWN_EGG: Material;
  static readonly FOX_SPAWN_EGG: Material;
  static readonly GHAST_SPAWN_EGG: Material;
  static readonly GLOW_SQUID_SPAWN_EGG: Material;
  static readonly GOAT_SPAWN_EGG: Material;
  static readonly GUARDIAN_SPAWN_EGG: Material;
  static readonly HOGLIN_SPAWN_EGG: Material;
  static readonly HORSE_SPAWN_EGG: Material;
  static readonly HUSK_SPAWN_EGG: Material;
  static readonly LLAMA_SPAWN_EGG: Material;
  static readonly MAGMA_CUBE_SPAWN_EGG: Material;
  static readonly MOOSHROOM_SPAWN_EGG: Material;
  static readonly MULE_SPAWN_EGG: Material;
  static readonly OCELOT_SPAWN_EGG: Material;
  static readonly PANDA_SPAWN_EGG: Material;
  static readonly PARROT_SPAWN_EGG: Material;
  static readonly PHANTOM_SPAWN_EGG: Material;
  static readonly PIG_SPAWN_EGG: Material;
  static readonly PIGLIN_SPAWN_EGG: Material;
  static readonly PIGLIN_BRUTE_SPAWN_EGG: Material;
  static readonly PILLAGER_SPAWN_EGG: Material;
  static readonly POLAR_BEAR_SPAWN_EGG: Material;
  static readonly PUFFERFISH_SPAWN_EGG: Material;
  static readonly RABBIT_SPAWN_EGG: Material;
  static readonly RAVAGER_SPAWN_EGG: Material;
  static readonly SALMON_SPAWN_EGG: Material;
  static readonly SHEEP_SPAWN_EGG: Material;
  static readonly SHULKER_SPAWN_EGG: Material;
  static readonly SILVERFISH_SPAWN_EGG: Material;
  static readonly SKELETON_SPAWN_EGG: Material;
  static readonly SKELETON_HORSE_SPAWN_EGG: Material;
  static readonly SLIME_SPAWN_EGG: Material;
  static readonly SPIDER_SPAWN_EGG: Material;
  static readonly SQUID_SPAWN_EGG: Material;
  static readonly STRAY_SPAWN_EGG: Material;
  static readonly STRIDER_SPAWN_EGG: Material;
  static readonly TRADER_LLAMA_SPAWN_EGG: Material;
  static readonly TROPICAL_FISH_SPAWN_EGG: Material;
  static readonly TURTLE_SPAWN_EGG: Material;
  static readonly VEX_SPAWN_EGG: Material;
  static readonly VILLAGER_SPAWN_EGG: Material;
  static readonly VINDICATOR_SPAWN_EGG: Material;
  static readonly WANDERING_TRADER_SPAWN_EGG: Material;
  static readonly WITCH_SPAWN_EGG: Material;
  static readonly WITHER_SKELETON_SPAWN_EGG: Material;
  static readonly WOLF_SPAWN_EGG: Material;
  static readonly ZOGLIN_SPAWN_EGG: Material;
  static readonly ZOMBIE_SPAWN_EGG: Material;
  static readonly ZOMBIE_HORSE_SPAWN_EGG: Material;
  static readonly ZOMBIE_VILLAGER_SPAWN_EGG: Material;
  static readonly ZOMBIFIED_PIGLIN_SPAWN_EGG: Material;
  static readonly EXPERIENCE_BOTTLE: Material;
  static readonly FIRE_CHARGE: Material;
  static readonly WRITABLE_BOOK: Material;
  static readonly WRITTEN_BOOK: Material;
  static readonly ITEM_FRAME: Material;
  static readonly GLOW_ITEM_FRAME: Material;
  static readonly FLOWER_POT: Material;
  static readonly CARROT: Material;
  static readonly POTATO: Material;
  static readonly BAKED_POTATO: Material;
  static readonly POISONOUS_POTATO: Material;
  static readonly MAP: Material;
  static readonly GOLDEN_CARROT: Material;
  /**
   * BlockData: {@link Rotatable}
  */
  static readonly SKELETON_SKULL: Material;
  /**
   * BlockData: {@link Rotatable}
  */
  static readonly WITHER_SKELETON_SKULL: Material;
  /**
   * BlockData: {@link Rotatable}
  */
  static readonly PLAYER_HEAD: Material;
  /**
   * BlockData: {@link Rotatable}
  */
  static readonly ZOMBIE_HEAD: Material;
  /**
   * BlockData: {@link Rotatable}
  */
  static readonly CREEPER_HEAD: Material;
  /**
   * BlockData: {@link Rotatable}
  */
  static readonly DRAGON_HEAD: Material;
  static readonly NETHER_STAR: Material;
  static readonly PUMPKIN_PIE: Material;
  static readonly FIREWORK_ROCKET: Material;
  static readonly FIREWORK_STAR: Material;
  static readonly ENCHANTED_BOOK: Material;
  static readonly NETHER_BRICK: Material;
  static readonly PRISMARINE_SHARD: Material;
  static readonly PRISMARINE_CRYSTALS: Material;
  static readonly RABBIT: Material;
  static readonly COOKED_RABBIT: Material;
  static readonly RABBIT_STEW: Material;
  static readonly RABBIT_FOOT: Material;
  static readonly RABBIT_HIDE: Material;
  static readonly ARMOR_STAND: Material;
  static readonly IRON_HORSE_ARMOR: Material;
  static readonly GOLDEN_HORSE_ARMOR: Material;
  static readonly DIAMOND_HORSE_ARMOR: Material;
  static readonly LEATHER_HORSE_ARMOR: Material;
  static readonly LEAD: Material;
  static readonly NAME_TAG: Material;
  static readonly COMMAND_BLOCK_MINECART: Material;
  static readonly MUTTON: Material;
  static readonly COOKED_MUTTON: Material;
  /**
   * BlockData: {@link Rotatable}
  */
  static readonly WHITE_BANNER: Material;
  /**
   * BlockData: {@link Rotatable}
  */
  static readonly ORANGE_BANNER: Material;
  /**
   * BlockData: {@link Rotatable}
  */
  static readonly MAGENTA_BANNER: Material;
  /**
   * BlockData: {@link Rotatable}
  */
  static readonly LIGHT_BLUE_BANNER: Material;
  /**
   * BlockData: {@link Rotatable}
  */
  static readonly YELLOW_BANNER: Material;
  /**
   * BlockData: {@link Rotatable}
  */
  static readonly LIME_BANNER: Material;
  /**
   * BlockData: {@link Rotatable}
  */
  static readonly PINK_BANNER: Material;
  /**
   * BlockData: {@link Rotatable}
  */
  static readonly GRAY_BANNER: Material;
  /**
   * BlockData: {@link Rotatable}
  */
  static readonly LIGHT_GRAY_BANNER: Material;
  /**
   * BlockData: {@link Rotatable}
  */
  static readonly CYAN_BANNER: Material;
  /**
   * BlockData: {@link Rotatable}
  */
  static readonly PURPLE_BANNER: Material;
  /**
   * BlockData: {@link Rotatable}
  */
  static readonly BLUE_BANNER: Material;
  /**
   * BlockData: {@link Rotatable}
  */
  static readonly BROWN_BANNER: Material;
  /**
   * BlockData: {@link Rotatable}
  */
  static readonly GREEN_BANNER: Material;
  /**
   * BlockData: {@link Rotatable}
  */
  static readonly RED_BANNER: Material;
  /**
   * BlockData: {@link Rotatable}
  */
  static readonly BLACK_BANNER: Material;
  static readonly END_CRYSTAL: Material;
  static readonly CHORUS_FRUIT: Material;
  static readonly POPPED_CHORUS_FRUIT: Material;
  static readonly BEETROOT: Material;
  static readonly BEETROOT_SEEDS: Material;
  static readonly BEETROOT_SOUP: Material;
  static readonly DRAGON_BREATH: Material;
  static readonly SPLASH_POTION: Material;
  static readonly SPECTRAL_ARROW: Material;
  static readonly TIPPED_ARROW: Material;
  static readonly LINGERING_POTION: Material;
  static readonly SHIELD: Material;
  static readonly TOTEM_OF_UNDYING: Material;
  static readonly SHULKER_SHELL: Material;
  static readonly IRON_NUGGET: Material;
  static readonly KNOWLEDGE_BOOK: Material;
  static readonly DEBUG_STICK: Material;
  static readonly MUSIC_DISC_13: Material;
  static readonly MUSIC_DISC_CAT: Material;
  static readonly MUSIC_DISC_BLOCKS: Material;
  static readonly MUSIC_DISC_CHIRP: Material;
  static readonly MUSIC_DISC_FAR: Material;
  static readonly MUSIC_DISC_MALL: Material;
  static readonly MUSIC_DISC_MELLOHI: Material;
  static readonly MUSIC_DISC_STAL: Material;
  static readonly MUSIC_DISC_STRAD: Material;
  static readonly MUSIC_DISC_WARD: Material;
  static readonly MUSIC_DISC_11: Material;
  static readonly MUSIC_DISC_WAIT: Material;
  static readonly MUSIC_DISC_OTHERSIDE: Material;
  static readonly MUSIC_DISC_PIGSTEP: Material;
  static readonly TRIDENT: Material;
  static readonly PHANTOM_MEMBRANE: Material;
  static readonly NAUTILUS_SHELL: Material;
  static readonly HEART_OF_THE_SEA: Material;
  static readonly CROSSBOW: Material;
  static readonly SUSPICIOUS_STEW: Material;
  /**
   * BlockData: {@link Directional}
  */
  static readonly LOOM: Material;
  static readonly FLOWER_BANNER_PATTERN: Material;
  static readonly CREEPER_BANNER_PATTERN: Material;
  static readonly SKULL_BANNER_PATTERN: Material;
  static readonly MOJANG_BANNER_PATTERN: Material;
  static readonly GLOBE_BANNER_PATTERN: Material;
  static readonly PIGLIN_BANNER_PATTERN: Material;
  /**
   * BlockData: {@link Levelled}
  */
  static readonly COMPOSTER: Material;
  /**
   * BlockData: {@link Directional}
  */
  static readonly BARREL: Material;
  /**
   * BlockData: {@link Furnace}
  */
  static readonly SMOKER: Material;
  /**
   * BlockData: {@link Furnace}
  */
  static readonly BLAST_FURNACE: Material;
  static readonly CARTOGRAPHY_TABLE: Material;
  static readonly FLETCHING_TABLE: Material;
  /**
   * BlockData: {@link Grindstone}
  */
  static readonly GRINDSTONE: Material;
  static readonly SMITHING_TABLE: Material;
  /**
   * BlockData: {@link Directional}
  */
  static readonly STONECUTTER: Material;
  /**
   * BlockData: {@link Bell}
  */
  static readonly BELL: Material;
  /**
   * BlockData: {@link Lantern}
  */
  static readonly LANTERN: Material;
  /**
   * BlockData: {@link Lantern}
  */
  static readonly SOUL_LANTERN: Material;
  static readonly SWEET_BERRIES: Material;
  static readonly GLOW_BERRIES: Material;
  /**
   * BlockData: {@link Campfire}
  */
  static readonly CAMPFIRE: Material;
  /**
   * BlockData: {@link Campfire}
  */
  static readonly SOUL_CAMPFIRE: Material;
  static readonly SHROOMLIGHT: Material;
  static readonly HONEYCOMB: Material;
  /**
   * BlockData: {@link Beehive}
  */
  static readonly BEE_NEST: Material;
  /**
   * BlockData: {@link Beehive}
  */
  static readonly BEEHIVE: Material;
  static readonly HONEY_BOTTLE: Material;
  static readonly HONEYCOMB_BLOCK: Material;
  static readonly LODESTONE: Material;
  static readonly CRYING_OBSIDIAN: Material;
  static readonly BLACKSTONE: Material;
  /**
   * BlockData: {@link Slab}
  */
  static readonly BLACKSTONE_SLAB: Material;
  /**
   * BlockData: {@link Stairs}
  */
  static readonly BLACKSTONE_STAIRS: Material;
  static readonly GILDED_BLACKSTONE: Material;
  static readonly POLISHED_BLACKSTONE: Material;
  /**
   * BlockData: {@link Slab}
  */
  static readonly POLISHED_BLACKSTONE_SLAB: Material;
  /**
   * BlockData: {@link Stairs}
  */
  static readonly POLISHED_BLACKSTONE_STAIRS: Material;
  static readonly CHISELED_POLISHED_BLACKSTONE: Material;
  static readonly POLISHED_BLACKSTONE_BRICKS: Material;
  /**
   * BlockData: {@link Slab}
  */
  static readonly POLISHED_BLACKSTONE_BRICK_SLAB: Material;
  /**
   * BlockData: {@link Stairs}
  */
  static readonly POLISHED_BLACKSTONE_BRICK_STAIRS: Material;
  static readonly CRACKED_POLISHED_BLACKSTONE_BRICKS: Material;
  /**
   * BlockData: {@link RespawnAnchor}
  */
  static readonly RESPAWN_ANCHOR: Material;
  /**
   * BlockData: {@link Candle}
  */
  static readonly CANDLE: Material;
  /**
   * BlockData: {@link Candle}
  */
  static readonly WHITE_CANDLE: Material;
  /**
   * BlockData: {@link Candle}
  */
  static readonly ORANGE_CANDLE: Material;
  /**
   * BlockData: {@link Candle}
  */
  static readonly MAGENTA_CANDLE: Material;
  /**
   * BlockData: {@link Candle}
  */
  static readonly LIGHT_BLUE_CANDLE: Material;
  /**
   * BlockData: {@link Candle}
  */
  static readonly YELLOW_CANDLE: Material;
  /**
   * BlockData: {@link Candle}
  */
  static readonly LIME_CANDLE: Material;
  /**
   * BlockData: {@link Candle}
  */
  static readonly PINK_CANDLE: Material;
  /**
   * BlockData: {@link Candle}
  */
  static readonly GRAY_CANDLE: Material;
  /**
   * BlockData: {@link Candle}
  */
  static readonly LIGHT_GRAY_CANDLE: Material;
  /**
   * BlockData: {@link Candle}
  */
  static readonly CYAN_CANDLE: Material;
  /**
   * BlockData: {@link Candle}
  */
  static readonly PURPLE_CANDLE: Material;
  /**
   * BlockData: {@link Candle}
  */
  static readonly BLUE_CANDLE: Material;
  /**
   * BlockData: {@link Candle}
  */
  static readonly BROWN_CANDLE: Material;
  /**
   * BlockData: {@link Candle}
  */
  static readonly GREEN_CANDLE: Material;
  /**
   * BlockData: {@link Candle}
  */
  static readonly RED_CANDLE: Material;
  /**
   * BlockData: {@link Candle}
  */
  static readonly BLACK_CANDLE: Material;
  /**
   * BlockData: {@link AmethystCluster}
  */
  static readonly SMALL_AMETHYST_BUD: Material;
  /**
   * BlockData: {@link AmethystCluster}
  */
  static readonly MEDIUM_AMETHYST_BUD: Material;
  /**
   * BlockData: {@link AmethystCluster}
  */
  static readonly LARGE_AMETHYST_BUD: Material;
  /**
   * BlockData: {@link AmethystCluster}
  */
  static readonly AMETHYST_CLUSTER: Material;
  /**
   * BlockData: {@link PointedDripstone}
  */
  static readonly POINTED_DRIPSTONE: Material;
  /**
   * BlockData: {@link Levelled}
  */
  static readonly WATER: Material;
  /**
   * BlockData: {@link Levelled}
  */
  static readonly LAVA: Material;
  /**
   * BlockData: {@link Bisected}
  */
  static readonly TALL_SEAGRASS: Material;
  /**
   * BlockData: {@link PistonHead}
  */
  static readonly PISTON_HEAD: Material;
  /**
   * BlockData: {@link TechnicalPiston}
  */
  static readonly MOVING_PISTON: Material;
  /**
   * BlockData: {@link Directional}
  */
  static readonly WALL_TORCH: Material;
  /**
   * BlockData: {@link Fire}
  */
  static readonly FIRE: Material;
  static readonly SOUL_FIRE: Material;
  /**
   * BlockData: {@link RedstoneWire}
  */
  static readonly REDSTONE_WIRE: Material;
  /**
   * BlockData: {@link WallSign}
  */
  static readonly OAK_WALL_SIGN: Material;
  /**
   * BlockData: {@link WallSign}
  */
  static readonly SPRUCE_WALL_SIGN: Material;
  /**
   * BlockData: {@link WallSign}
  */
  static readonly BIRCH_WALL_SIGN: Material;
  /**
   * BlockData: {@link WallSign}
  */
  static readonly ACACIA_WALL_SIGN: Material;
  /**
   * BlockData: {@link WallSign}
  */
  static readonly JUNGLE_WALL_SIGN: Material;
  /**
   * BlockData: {@link WallSign}
  */
  static readonly DARK_OAK_WALL_SIGN: Material;
  /**
   * BlockData: {@link RedstoneWallTorch}
  */
  static readonly REDSTONE_WALL_TORCH: Material;
  /**
   * BlockData: {@link Directional}
  */
  static readonly SOUL_WALL_TORCH: Material;
  /**
   * BlockData: {@link Orientable}
  */
  static readonly NETHER_PORTAL: Material;
  /**
   * BlockData: {@link Directional}
  */
  static readonly ATTACHED_PUMPKIN_STEM: Material;
  /**
   * BlockData: {@link Directional}
  */
  static readonly ATTACHED_MELON_STEM: Material;
  /**
   * BlockData: {@link Ageable}
  */
  static readonly PUMPKIN_STEM: Material;
  /**
   * BlockData: {@link Ageable}
  */
  static readonly MELON_STEM: Material;
  /**
   * BlockData: {@link Levelled}
  */
  static readonly WATER_CAULDRON: Material;
  static readonly LAVA_CAULDRON: Material;
  /**
   * BlockData: {@link Levelled}
  */
  static readonly POWDER_SNOW_CAULDRON: Material;
  static readonly END_PORTAL: Material;
  /**
   * BlockData: {@link Cocoa}
  */
  static readonly COCOA: Material;
  /**
   * BlockData: {@link Tripwire}
  */
  static readonly TRIPWIRE: Material;
  static readonly POTTED_OAK_SAPLING: Material;
  static readonly POTTED_SPRUCE_SAPLING: Material;
  static readonly POTTED_BIRCH_SAPLING: Material;
  static readonly POTTED_JUNGLE_SAPLING: Material;
  static readonly POTTED_ACACIA_SAPLING: Material;
  static readonly POTTED_DARK_OAK_SAPLING: Material;
  static readonly POTTED_FERN: Material;
  static readonly POTTED_DANDELION: Material;
  static readonly POTTED_POPPY: Material;
  static readonly POTTED_BLUE_ORCHID: Material;
  static readonly POTTED_ALLIUM: Material;
  static readonly POTTED_AZURE_BLUET: Material;
  static readonly POTTED_RED_TULIP: Material;
  static readonly POTTED_ORANGE_TULIP: Material;
  static readonly POTTED_WHITE_TULIP: Material;
  static readonly POTTED_PINK_TULIP: Material;
  static readonly POTTED_OXEYE_DAISY: Material;
  static readonly POTTED_CORNFLOWER: Material;
  static readonly POTTED_LILY_OF_THE_VALLEY: Material;
  static readonly POTTED_WITHER_ROSE: Material;
  static readonly POTTED_RED_MUSHROOM: Material;
  static readonly POTTED_BROWN_MUSHROOM: Material;
  static readonly POTTED_DEAD_BUSH: Material;
  static readonly POTTED_CACTUS: Material;
  /**
   * BlockData: {@link Ageable}
  */
  static readonly CARROTS: Material;
  /**
   * BlockData: {@link Ageable}
  */
  static readonly POTATOES: Material;
  /**
   * BlockData: {@link Directional}
  */
  static readonly SKELETON_WALL_SKULL: Material;
  /**
   * BlockData: {@link Directional}
  */
  static readonly WITHER_SKELETON_WALL_SKULL: Material;
  /**
   * BlockData: {@link Directional}
  */
  static readonly ZOMBIE_WALL_HEAD: Material;
  /**
   * BlockData: {@link Directional}
  */
  static readonly PLAYER_WALL_HEAD: Material;
  /**
   * BlockData: {@link Directional}
  */
  static readonly CREEPER_WALL_HEAD: Material;
  /**
   * BlockData: {@link Directional}
  */
  static readonly DRAGON_WALL_HEAD: Material;
  /**
   * BlockData: {@link Directional}
  */
  static readonly WHITE_WALL_BANNER: Material;
  /**
   * BlockData: {@link Directional}
  */
  static readonly ORANGE_WALL_BANNER: Material;
  /**
   * BlockData: {@link Directional}
  */
  static readonly MAGENTA_WALL_BANNER: Material;
  /**
   * BlockData: {@link Directional}
  */
  static readonly LIGHT_BLUE_WALL_BANNER: Material;
  /**
   * BlockData: {@link Directional}
  */
  static readonly YELLOW_WALL_BANNER: Material;
  /**
   * BlockData: {@link Directional}
  */
  static readonly LIME_WALL_BANNER: Material;
  /**
   * BlockData: {@link Directional}
  */
  static readonly PINK_WALL_BANNER: Material;
  /**
   * BlockData: {@link Directional}
  */
  static readonly GRAY_WALL_BANNER: Material;
  /**
   * BlockData: {@link Directional}
  */
  static readonly LIGHT_GRAY_WALL_BANNER: Material;
  /**
   * BlockData: {@link Directional}
  */
  static readonly CYAN_WALL_BANNER: Material;
  /**
   * BlockData: {@link Directional}
  */
  static readonly PURPLE_WALL_BANNER: Material;
  /**
   * BlockData: {@link Directional}
  */
  static readonly BLUE_WALL_BANNER: Material;
  /**
   * BlockData: {@link Directional}
  */
  static readonly BROWN_WALL_BANNER: Material;
  /**
   * BlockData: {@link Directional}
  */
  static readonly GREEN_WALL_BANNER: Material;
  /**
   * BlockData: {@link Directional}
  */
  static readonly RED_WALL_BANNER: Material;
  /**
   * BlockData: {@link Directional}
  */
  static readonly BLACK_WALL_BANNER: Material;
  /**
   * BlockData: {@link Ageable}
  */
  static readonly BEETROOTS: Material;
  static readonly END_GATEWAY: Material;
  /**
   * BlockData: {@link Ageable}
  */
  static readonly FROSTED_ICE: Material;
  static readonly KELP_PLANT: Material;
  /**
   * BlockData: {@link CoralWallFan}
  */
  static readonly DEAD_TUBE_CORAL_WALL_FAN: Material;
  /**
   * BlockData: {@link CoralWallFan}
  */
  static readonly DEAD_BRAIN_CORAL_WALL_FAN: Material;
  /**
   * BlockData: {@link CoralWallFan}
  */
  static readonly DEAD_BUBBLE_CORAL_WALL_FAN: Material;
  /**
   * BlockData: {@link CoralWallFan}
  */
  static readonly DEAD_FIRE_CORAL_WALL_FAN: Material;
  /**
   * BlockData: {@link CoralWallFan}
  */
  static readonly DEAD_HORN_CORAL_WALL_FAN: Material;
  /**
   * BlockData: {@link CoralWallFan}
  */
  static readonly TUBE_CORAL_WALL_FAN: Material;
  /**
   * BlockData: {@link CoralWallFan}
  */
  static readonly BRAIN_CORAL_WALL_FAN: Material;
  /**
   * BlockData: {@link CoralWallFan}
  */
  static readonly BUBBLE_CORAL_WALL_FAN: Material;
  /**
   * BlockData: {@link CoralWallFan}
  */
  static readonly FIRE_CORAL_WALL_FAN: Material;
  /**
   * BlockData: {@link CoralWallFan}
  */
  static readonly HORN_CORAL_WALL_FAN: Material;
  static readonly BAMBOO_SAPLING: Material;
  static readonly POTTED_BAMBOO: Material;
  static readonly VOID_AIR: Material;
  static readonly CAVE_AIR: Material;
  /**
   * BlockData: {@link BubbleColumn}
  */
  static readonly BUBBLE_COLUMN: Material;
  /**
   * BlockData: {@link Ageable}
  */
  static readonly SWEET_BERRY_BUSH: Material;
  static readonly WEEPING_VINES_PLANT: Material;
  static readonly TWISTING_VINES_PLANT: Material;
  /**
   * BlockData: {@link WallSign}
  */
  static readonly CRIMSON_WALL_SIGN: Material;
  /**
   * BlockData: {@link WallSign}
  */
  static readonly WARPED_WALL_SIGN: Material;
  static readonly POTTED_CRIMSON_FUNGUS: Material;
  static readonly POTTED_WARPED_FUNGUS: Material;
  static readonly POTTED_CRIMSON_ROOTS: Material;
  static readonly POTTED_WARPED_ROOTS: Material;
  /**
   * BlockData: {@link Lightable}
  */
  static readonly CANDLE_CAKE: Material;
  /**
   * BlockData: {@link Lightable}
  */
  static readonly WHITE_CANDLE_CAKE: Material;
  /**
   * BlockData: {@link Lightable}
  */
  static readonly ORANGE_CANDLE_CAKE: Material;
  /**
   * BlockData: {@link Lightable}
  */
  static readonly MAGENTA_CANDLE_CAKE: Material;
  /**
   * BlockData: {@link Lightable}
  */
  static readonly LIGHT_BLUE_CANDLE_CAKE: Material;
  /**
   * BlockData: {@link Lightable}
  */
  static readonly YELLOW_CANDLE_CAKE: Material;
  /**
   * BlockData: {@link Lightable}
  */
  static readonly LIME_CANDLE_CAKE: Material;
  /**
   * BlockData: {@link Lightable}
  */
  static readonly PINK_CANDLE_CAKE: Material;
  /**
   * BlockData: {@link Lightable}
  */
  static readonly GRAY_CANDLE_CAKE: Material;
  /**
   * BlockData: {@link Lightable}
  */
  static readonly LIGHT_GRAY_CANDLE_CAKE: Material;
  /**
   * BlockData: {@link Lightable}
  */
  static readonly CYAN_CANDLE_CAKE: Material;
  /**
   * BlockData: {@link Lightable}
  */
  static readonly PURPLE_CANDLE_CAKE: Material;
  /**
   * BlockData: {@link Lightable}
  */
  static readonly BLUE_CANDLE_CAKE: Material;
  /**
   * BlockData: {@link Lightable}
  */
  static readonly BROWN_CANDLE_CAKE: Material;
  /**
   * BlockData: {@link Lightable}
  */
  static readonly GREEN_CANDLE_CAKE: Material;
  /**
   * BlockData: {@link Lightable}
  */
  static readonly RED_CANDLE_CAKE: Material;
  /**
   * BlockData: {@link Lightable}
  */
  static readonly BLACK_CANDLE_CAKE: Material;
  static readonly POWDER_SNOW: Material;
  /**
   * BlockData: {@link CaveVines}
  */
  static readonly CAVE_VINES: Material;
  /**
   * BlockData: {@link CaveVinesPlant}
  */
  static readonly CAVE_VINES_PLANT: Material;
  /**
   * BlockData: {@link Dripleaf}
  */
  static readonly BIG_DRIPLEAF_STEM: Material;
  static readonly POTTED_AZALEA_BUSH: Material;
  static readonly POTTED_FLOWERING_AZALEA_BUSH: Material;
  static readonly LEGACY_AIR: Material;
  static readonly LEGACY_STONE: Material;
  static readonly LEGACY_GRASS: Material;
  static readonly LEGACY_DIRT: Material;
  static readonly LEGACY_COBBLESTONE: Material;
  static readonly LEGACY_WOOD: Material;
  static readonly LEGACY_SAPLING: Material;
  static readonly LEGACY_BEDROCK: Material;
  static readonly LEGACY_WATER: Material;
  static readonly LEGACY_STATIONARY_WATER: Material;
  static readonly LEGACY_LAVA: Material;
  static readonly LEGACY_STATIONARY_LAVA: Material;
  static readonly LEGACY_SAND: Material;
  static readonly LEGACY_GRAVEL: Material;
  static readonly LEGACY_GOLD_ORE: Material;
  static readonly LEGACY_IRON_ORE: Material;
  static readonly LEGACY_COAL_ORE: Material;
  static readonly LEGACY_LOG: Material;
  static readonly LEGACY_LEAVES: Material;
  static readonly LEGACY_SPONGE: Material;
  static readonly LEGACY_GLASS: Material;
  static readonly LEGACY_LAPIS_ORE: Material;
  static readonly LEGACY_LAPIS_BLOCK: Material;
  static readonly LEGACY_DISPENSER: Material;
  static readonly LEGACY_SANDSTONE: Material;
  static readonly LEGACY_NOTE_BLOCK: Material;
  static readonly LEGACY_BED_BLOCK: Material;
  static readonly LEGACY_POWERED_RAIL: Material;
  static readonly LEGACY_DETECTOR_RAIL: Material;
  static readonly LEGACY_PISTON_STICKY_BASE: Material;
  static readonly LEGACY_WEB: Material;
  static readonly LEGACY_LONG_GRASS: Material;
  static readonly LEGACY_DEAD_BUSH: Material;
  static readonly LEGACY_PISTON_BASE: Material;
  static readonly LEGACY_PISTON_EXTENSION: Material;
  static readonly LEGACY_WOOL: Material;
  static readonly LEGACY_PISTON_MOVING_PIECE: Material;
  static readonly LEGACY_YELLOW_FLOWER: Material;
  static readonly LEGACY_RED_ROSE: Material;
  static readonly LEGACY_BROWN_MUSHROOM: Material;
  static readonly LEGACY_RED_MUSHROOM: Material;
  static readonly LEGACY_GOLD_BLOCK: Material;
  static readonly LEGACY_IRON_BLOCK: Material;
  static readonly LEGACY_DOUBLE_STEP: Material;
  static readonly LEGACY_STEP: Material;
  static readonly LEGACY_BRICK: Material;
  static readonly LEGACY_TNT: Material;
  static readonly LEGACY_BOOKSHELF: Material;
  static readonly LEGACY_MOSSY_COBBLESTONE: Material;
  static readonly LEGACY_OBSIDIAN: Material;
  static readonly LEGACY_TORCH: Material;
  static readonly LEGACY_FIRE: Material;
  static readonly LEGACY_MOB_SPAWNER: Material;
  static readonly LEGACY_WOOD_STAIRS: Material;
  static readonly LEGACY_CHEST: Material;
  static readonly LEGACY_REDSTONE_WIRE: Material;
  static readonly LEGACY_DIAMOND_ORE: Material;
  static readonly LEGACY_DIAMOND_BLOCK: Material;
  static readonly LEGACY_WORKBENCH: Material;
  static readonly LEGACY_CROPS: Material;
  static readonly LEGACY_SOIL: Material;
  static readonly LEGACY_FURNACE: Material;
  static readonly LEGACY_BURNING_FURNACE: Material;
  static readonly LEGACY_SIGN_POST: Material;
  static readonly LEGACY_WOODEN_DOOR: Material;
  static readonly LEGACY_LADDER: Material;
  static readonly LEGACY_RAILS: Material;
  static readonly LEGACY_COBBLESTONE_STAIRS: Material;
  static readonly LEGACY_WALL_SIGN: Material;
  static readonly LEGACY_LEVER: Material;
  static readonly LEGACY_STONE_PLATE: Material;
  static readonly LEGACY_IRON_DOOR_BLOCK: Material;
  static readonly LEGACY_WOOD_PLATE: Material;
  static readonly LEGACY_REDSTONE_ORE: Material;
  static readonly LEGACY_GLOWING_REDSTONE_ORE: Material;
  static readonly LEGACY_REDSTONE_TORCH_OFF: Material;
  static readonly LEGACY_REDSTONE_TORCH_ON: Material;
  static readonly LEGACY_STONE_BUTTON: Material;
  static readonly LEGACY_SNOW: Material;
  static readonly LEGACY_ICE: Material;
  static readonly LEGACY_SNOW_BLOCK: Material;
  static readonly LEGACY_CACTUS: Material;
  static readonly LEGACY_CLAY: Material;
  static readonly LEGACY_SUGAR_CANE_BLOCK: Material;
  static readonly LEGACY_JUKEBOX: Material;
  static readonly LEGACY_FENCE: Material;
  static readonly LEGACY_PUMPKIN: Material;
  static readonly LEGACY_NETHERRACK: Material;
  static readonly LEGACY_SOUL_SAND: Material;
  static readonly LEGACY_GLOWSTONE: Material;
  static readonly LEGACY_PORTAL: Material;
  static readonly LEGACY_JACK_O_LANTERN: Material;
  static readonly LEGACY_CAKE_BLOCK: Material;
  static readonly LEGACY_DIODE_BLOCK_OFF: Material;
  static readonly LEGACY_DIODE_BLOCK_ON: Material;
  static readonly LEGACY_STAINED_GLASS: Material;
  static readonly LEGACY_TRAP_DOOR: Material;
  static readonly LEGACY_MONSTER_EGGS: Material;
  static readonly LEGACY_SMOOTH_BRICK: Material;
  static readonly LEGACY_HUGE_MUSHROOM_1: Material;
  static readonly LEGACY_HUGE_MUSHROOM_2: Material;
  static readonly LEGACY_IRON_FENCE: Material;
  static readonly LEGACY_THIN_GLASS: Material;
  static readonly LEGACY_MELON_BLOCK: Material;
  static readonly LEGACY_PUMPKIN_STEM: Material;
  static readonly LEGACY_MELON_STEM: Material;
  static readonly LEGACY_VINE: Material;
  static readonly LEGACY_FENCE_GATE: Material;
  static readonly LEGACY_BRICK_STAIRS: Material;
  static readonly LEGACY_SMOOTH_STAIRS: Material;
  static readonly LEGACY_MYCEL: Material;
  static readonly LEGACY_WATER_LILY: Material;
  static readonly LEGACY_NETHER_BRICK: Material;
  static readonly LEGACY_NETHER_FENCE: Material;
  static readonly LEGACY_NETHER_BRICK_STAIRS: Material;
  static readonly LEGACY_NETHER_WARTS: Material;
  static readonly LEGACY_ENCHANTMENT_TABLE: Material;
  static readonly LEGACY_BREWING_STAND: Material;
  static readonly LEGACY_CAULDRON: Material;
  static readonly LEGACY_ENDER_PORTAL: Material;
  static readonly LEGACY_ENDER_PORTAL_FRAME: Material;
  static readonly LEGACY_ENDER_STONE: Material;
  static readonly LEGACY_DRAGON_EGG: Material;
  static readonly LEGACY_REDSTONE_LAMP_OFF: Material;
  static readonly LEGACY_REDSTONE_LAMP_ON: Material;
  static readonly LEGACY_WOOD_DOUBLE_STEP: Material;
  static readonly LEGACY_WOOD_STEP: Material;
  static readonly LEGACY_COCOA: Material;
  static readonly LEGACY_SANDSTONE_STAIRS: Material;
  static readonly LEGACY_EMERALD_ORE: Material;
  static readonly LEGACY_ENDER_CHEST: Material;
  static readonly LEGACY_TRIPWIRE_HOOK: Material;
  static readonly LEGACY_TRIPWIRE: Material;
  static readonly LEGACY_EMERALD_BLOCK: Material;
  static readonly LEGACY_SPRUCE_WOOD_STAIRS: Material;
  static readonly LEGACY_BIRCH_WOOD_STAIRS: Material;
  static readonly LEGACY_JUNGLE_WOOD_STAIRS: Material;
  static readonly LEGACY_COMMAND: Material;
  static readonly LEGACY_BEACON: Material;
  static readonly LEGACY_COBBLE_WALL: Material;
  static readonly LEGACY_FLOWER_POT: Material;
  static readonly LEGACY_CARROT: Material;
  static readonly LEGACY_POTATO: Material;
  static readonly LEGACY_WOOD_BUTTON: Material;
  static readonly LEGACY_SKULL: Material;
  static readonly LEGACY_ANVIL: Material;
  static readonly LEGACY_TRAPPED_CHEST: Material;
  static readonly LEGACY_GOLD_PLATE: Material;
  static readonly LEGACY_IRON_PLATE: Material;
  static readonly LEGACY_REDSTONE_COMPARATOR_OFF: Material;
  static readonly LEGACY_REDSTONE_COMPARATOR_ON: Material;
  static readonly LEGACY_DAYLIGHT_DETECTOR: Material;
  static readonly LEGACY_REDSTONE_BLOCK: Material;
  static readonly LEGACY_QUARTZ_ORE: Material;
  static readonly LEGACY_HOPPER: Material;
  static readonly LEGACY_QUARTZ_BLOCK: Material;
  static readonly LEGACY_QUARTZ_STAIRS: Material;
  static readonly LEGACY_ACTIVATOR_RAIL: Material;
  static readonly LEGACY_DROPPER: Material;
  static readonly LEGACY_STAINED_CLAY: Material;
  static readonly LEGACY_STAINED_GLASS_PANE: Material;
  static readonly LEGACY_LEAVES_2: Material;
  static readonly LEGACY_LOG_2: Material;
  static readonly LEGACY_ACACIA_STAIRS: Material;
  static readonly LEGACY_DARK_OAK_STAIRS: Material;
  static readonly LEGACY_SLIME_BLOCK: Material;
  static readonly LEGACY_BARRIER: Material;
  static readonly LEGACY_IRON_TRAPDOOR: Material;
  static readonly LEGACY_PRISMARINE: Material;
  static readonly LEGACY_SEA_LANTERN: Material;
  static readonly LEGACY_HAY_BLOCK: Material;
  static readonly LEGACY_CARPET: Material;
  static readonly LEGACY_HARD_CLAY: Material;
  static readonly LEGACY_COAL_BLOCK: Material;
  static readonly LEGACY_PACKED_ICE: Material;
  static readonly LEGACY_DOUBLE_PLANT: Material;
  static readonly LEGACY_STANDING_BANNER: Material;
  static readonly LEGACY_WALL_BANNER: Material;
  static readonly LEGACY_DAYLIGHT_DETECTOR_INVERTED: Material;
  static readonly LEGACY_RED_SANDSTONE: Material;
  static readonly LEGACY_RED_SANDSTONE_STAIRS: Material;
  static readonly LEGACY_DOUBLE_STONE_SLAB2: Material;
  static readonly LEGACY_STONE_SLAB2: Material;
  static readonly LEGACY_SPRUCE_FENCE_GATE: Material;
  static readonly LEGACY_BIRCH_FENCE_GATE: Material;
  static readonly LEGACY_JUNGLE_FENCE_GATE: Material;
  static readonly LEGACY_DARK_OAK_FENCE_GATE: Material;
  static readonly LEGACY_ACACIA_FENCE_GATE: Material;
  static readonly LEGACY_SPRUCE_FENCE: Material;
  static readonly LEGACY_BIRCH_FENCE: Material;
  static readonly LEGACY_JUNGLE_FENCE: Material;
  static readonly LEGACY_DARK_OAK_FENCE: Material;
  static readonly LEGACY_ACACIA_FENCE: Material;
  static readonly LEGACY_SPRUCE_DOOR: Material;
  static readonly LEGACY_BIRCH_DOOR: Material;
  static readonly LEGACY_JUNGLE_DOOR: Material;
  static readonly LEGACY_ACACIA_DOOR: Material;
  static readonly LEGACY_DARK_OAK_DOOR: Material;
  static readonly LEGACY_END_ROD: Material;
  static readonly LEGACY_CHORUS_PLANT: Material;
  static readonly LEGACY_CHORUS_FLOWER: Material;
  static readonly LEGACY_PURPUR_BLOCK: Material;
  static readonly LEGACY_PURPUR_PILLAR: Material;
  static readonly LEGACY_PURPUR_STAIRS: Material;
  static readonly LEGACY_PURPUR_DOUBLE_SLAB: Material;
  static readonly LEGACY_PURPUR_SLAB: Material;
  static readonly LEGACY_END_BRICKS: Material;
  static readonly LEGACY_BEETROOT_BLOCK: Material;
  static readonly LEGACY_GRASS_PATH: Material;
  static readonly LEGACY_END_GATEWAY: Material;
  static readonly LEGACY_COMMAND_REPEATING: Material;
  static readonly LEGACY_COMMAND_CHAIN: Material;
  static readonly LEGACY_FROSTED_ICE: Material;
  static readonly LEGACY_MAGMA: Material;
  static readonly LEGACY_NETHER_WART_BLOCK: Material;
  static readonly LEGACY_RED_NETHER_BRICK: Material;
  static readonly LEGACY_BONE_BLOCK: Material;
  static readonly LEGACY_STRUCTURE_VOID: Material;
  static readonly LEGACY_OBSERVER: Material;
  static readonly LEGACY_WHITE_SHULKER_BOX: Material;
  static readonly LEGACY_ORANGE_SHULKER_BOX: Material;
  static readonly LEGACY_MAGENTA_SHULKER_BOX: Material;
  static readonly LEGACY_LIGHT_BLUE_SHULKER_BOX: Material;
  static readonly LEGACY_YELLOW_SHULKER_BOX: Material;
  static readonly LEGACY_LIME_SHULKER_BOX: Material;
  static readonly LEGACY_PINK_SHULKER_BOX: Material;
  static readonly LEGACY_GRAY_SHULKER_BOX: Material;
  static readonly LEGACY_SILVER_SHULKER_BOX: Material;
  static readonly LEGACY_CYAN_SHULKER_BOX: Material;
  static readonly LEGACY_PURPLE_SHULKER_BOX: Material;
  static readonly LEGACY_BLUE_SHULKER_BOX: Material;
  static readonly LEGACY_BROWN_SHULKER_BOX: Material;
  static readonly LEGACY_GREEN_SHULKER_BOX: Material;
  static readonly LEGACY_RED_SHULKER_BOX: Material;
  static readonly LEGACY_BLACK_SHULKER_BOX: Material;
  static readonly LEGACY_WHITE_GLAZED_TERRACOTTA: Material;
  static readonly LEGACY_ORANGE_GLAZED_TERRACOTTA: Material;
  static readonly LEGACY_MAGENTA_GLAZED_TERRACOTTA: Material;
  static readonly LEGACY_LIGHT_BLUE_GLAZED_TERRACOTTA: Material;
  static readonly LEGACY_YELLOW_GLAZED_TERRACOTTA: Material;
  static readonly LEGACY_LIME_GLAZED_TERRACOTTA: Material;
  static readonly LEGACY_PINK_GLAZED_TERRACOTTA: Material;
  static readonly LEGACY_GRAY_GLAZED_TERRACOTTA: Material;
  static readonly LEGACY_SILVER_GLAZED_TERRACOTTA: Material;
  static readonly LEGACY_CYAN_GLAZED_TERRACOTTA: Material;
  static readonly LEGACY_PURPLE_GLAZED_TERRACOTTA: Material;
  static readonly LEGACY_BLUE_GLAZED_TERRACOTTA: Material;
  static readonly LEGACY_BROWN_GLAZED_TERRACOTTA: Material;
  static readonly LEGACY_GREEN_GLAZED_TERRACOTTA: Material;
  static readonly LEGACY_RED_GLAZED_TERRACOTTA: Material;
  static readonly LEGACY_BLACK_GLAZED_TERRACOTTA: Material;
  static readonly LEGACY_CONCRETE: Material;
  static readonly LEGACY_CONCRETE_POWDER: Material;
  static readonly LEGACY_STRUCTURE_BLOCK: Material;
  static readonly LEGACY_IRON_SPADE: Material;
  static readonly LEGACY_IRON_PICKAXE: Material;
  static readonly LEGACY_IRON_AXE: Material;
  static readonly LEGACY_FLINT_AND_STEEL: Material;
  static readonly LEGACY_APPLE: Material;
  static readonly LEGACY_BOW: Material;
  static readonly LEGACY_ARROW: Material;
  static readonly LEGACY_COAL: Material;
  static readonly LEGACY_DIAMOND: Material;
  static readonly LEGACY_IRON_INGOT: Material;
  static readonly LEGACY_GOLD_INGOT: Material;
  static readonly LEGACY_IRON_SWORD: Material;
  static readonly LEGACY_WOOD_SWORD: Material;
  static readonly LEGACY_WOOD_SPADE: Material;
  static readonly LEGACY_WOOD_PICKAXE: Material;
  static readonly LEGACY_WOOD_AXE: Material;
  static readonly LEGACY_STONE_SWORD: Material;
  static readonly LEGACY_STONE_SPADE: Material;
  static readonly LEGACY_STONE_PICKAXE: Material;
  static readonly LEGACY_STONE_AXE: Material;
  static readonly LEGACY_DIAMOND_SWORD: Material;
  static readonly LEGACY_DIAMOND_SPADE: Material;
  static readonly LEGACY_DIAMOND_PICKAXE: Material;
  static readonly LEGACY_DIAMOND_AXE: Material;
  static readonly LEGACY_STICK: Material;
  static readonly LEGACY_BOWL: Material;
  static readonly LEGACY_MUSHROOM_SOUP: Material;
  static readonly LEGACY_GOLD_SWORD: Material;
  static readonly LEGACY_GOLD_SPADE: Material;
  static readonly LEGACY_GOLD_PICKAXE: Material;
  static readonly LEGACY_GOLD_AXE: Material;
  static readonly LEGACY_STRING: Material;
  static readonly LEGACY_FEATHER: Material;
  static readonly LEGACY_SULPHUR: Material;
  static readonly LEGACY_WOOD_HOE: Material;
  static readonly LEGACY_STONE_HOE: Material;
  static readonly LEGACY_IRON_HOE: Material;
  static readonly LEGACY_DIAMOND_HOE: Material;
  static readonly LEGACY_GOLD_HOE: Material;
  static readonly LEGACY_SEEDS: Material;
  static readonly LEGACY_WHEAT: Material;
  static readonly LEGACY_BREAD: Material;
  static readonly LEGACY_LEATHER_HELMET: Material;
  static readonly LEGACY_LEATHER_CHESTPLATE: Material;
  static readonly LEGACY_LEATHER_LEGGINGS: Material;
  static readonly LEGACY_LEATHER_BOOTS: Material;
  static readonly LEGACY_CHAINMAIL_HELMET: Material;
  static readonly LEGACY_CHAINMAIL_CHESTPLATE: Material;
  static readonly LEGACY_CHAINMAIL_LEGGINGS: Material;
  static readonly LEGACY_CHAINMAIL_BOOTS: Material;
  static readonly LEGACY_IRON_HELMET: Material;
  static readonly LEGACY_IRON_CHESTPLATE: Material;
  static readonly LEGACY_IRON_LEGGINGS: Material;
  static readonly LEGACY_IRON_BOOTS: Material;
  static readonly LEGACY_DIAMOND_HELMET: Material;
  static readonly LEGACY_DIAMOND_CHESTPLATE: Material;
  static readonly LEGACY_DIAMOND_LEGGINGS: Material;
  static readonly LEGACY_DIAMOND_BOOTS: Material;
  static readonly LEGACY_GOLD_HELMET: Material;
  static readonly LEGACY_GOLD_CHESTPLATE: Material;
  static readonly LEGACY_GOLD_LEGGINGS: Material;
  static readonly LEGACY_GOLD_BOOTS: Material;
  static readonly LEGACY_FLINT: Material;
  static readonly LEGACY_PORK: Material;
  static readonly LEGACY_GRILLED_PORK: Material;
  static readonly LEGACY_PAINTING: Material;
  static readonly LEGACY_GOLDEN_APPLE: Material;
  static readonly LEGACY_SIGN: Material;
  static readonly LEGACY_WOOD_DOOR: Material;
  static readonly LEGACY_BUCKET: Material;
  static readonly LEGACY_WATER_BUCKET: Material;
  static readonly LEGACY_LAVA_BUCKET: Material;
  static readonly LEGACY_MINECART: Material;
  static readonly LEGACY_SADDLE: Material;
  static readonly LEGACY_IRON_DOOR: Material;
  static readonly LEGACY_REDSTONE: Material;
  static readonly LEGACY_SNOW_BALL: Material;
  static readonly LEGACY_BOAT: Material;
  static readonly LEGACY_LEATHER: Material;
  static readonly LEGACY_MILK_BUCKET: Material;
  static readonly LEGACY_CLAY_BRICK: Material;
  static readonly LEGACY_CLAY_BALL: Material;
  static readonly LEGACY_SUGAR_CANE: Material;
  static readonly LEGACY_PAPER: Material;
  static readonly LEGACY_BOOK: Material;
  static readonly LEGACY_SLIME_BALL: Material;
  static readonly LEGACY_STORAGE_MINECART: Material;
  static readonly LEGACY_POWERED_MINECART: Material;
  static readonly LEGACY_EGG: Material;
  static readonly LEGACY_COMPASS: Material;
  static readonly LEGACY_FISHING_ROD: Material;
  static readonly LEGACY_WATCH: Material;
  static readonly LEGACY_GLOWSTONE_DUST: Material;
  static readonly LEGACY_RAW_FISH: Material;
  static readonly LEGACY_COOKED_FISH: Material;
  static readonly LEGACY_INK_SACK: Material;
  static readonly LEGACY_BONE: Material;
  static readonly LEGACY_SUGAR: Material;
  static readonly LEGACY_CAKE: Material;
  static readonly LEGACY_BED: Material;
  static readonly LEGACY_DIODE: Material;
  static readonly LEGACY_COOKIE: Material;
  /**
   * @see org.bukkit.map.MapView
  */
  static readonly LEGACY_MAP: Material;
  static readonly LEGACY_SHEARS: Material;
  static readonly LEGACY_MELON: Material;
  static readonly LEGACY_PUMPKIN_SEEDS: Material;
  static readonly LEGACY_MELON_SEEDS: Material;
  static readonly LEGACY_RAW_BEEF: Material;
  static readonly LEGACY_COOKED_BEEF: Material;
  static readonly LEGACY_RAW_CHICKEN: Material;
  static readonly LEGACY_COOKED_CHICKEN: Material;
  static readonly LEGACY_ROTTEN_FLESH: Material;
  static readonly LEGACY_ENDER_PEARL: Material;
  static readonly LEGACY_BLAZE_ROD: Material;
  static readonly LEGACY_GHAST_TEAR: Material;
  static readonly LEGACY_GOLD_NUGGET: Material;
  static readonly LEGACY_NETHER_STALK: Material;
  static readonly LEGACY_POTION: Material;
  static readonly LEGACY_GLASS_BOTTLE: Material;
  static readonly LEGACY_SPIDER_EYE: Material;
  static readonly LEGACY_FERMENTED_SPIDER_EYE: Material;
  static readonly LEGACY_BLAZE_POWDER: Material;
  static readonly LEGACY_MAGMA_CREAM: Material;
  static readonly LEGACY_BREWING_STAND_ITEM: Material;
  static readonly LEGACY_CAULDRON_ITEM: Material;
  static readonly LEGACY_EYE_OF_ENDER: Material;
  static readonly LEGACY_SPECKLED_MELON: Material;
  static readonly LEGACY_MONSTER_EGG: Material;
  static readonly LEGACY_EXP_BOTTLE: Material;
  static readonly LEGACY_FIREBALL: Material;
  static readonly LEGACY_BOOK_AND_QUILL: Material;
  static readonly LEGACY_WRITTEN_BOOK: Material;
  static readonly LEGACY_EMERALD: Material;
  static readonly LEGACY_ITEM_FRAME: Material;
  static readonly LEGACY_FLOWER_POT_ITEM: Material;
  static readonly LEGACY_CARROT_ITEM: Material;
  static readonly LEGACY_POTATO_ITEM: Material;
  static readonly LEGACY_BAKED_POTATO: Material;
  static readonly LEGACY_POISONOUS_POTATO: Material;
  static readonly LEGACY_EMPTY_MAP: Material;
  static readonly LEGACY_GOLDEN_CARROT: Material;
  static readonly LEGACY_SKULL_ITEM: Material;
  static readonly LEGACY_CARROT_STICK: Material;
  static readonly LEGACY_NETHER_STAR: Material;
  static readonly LEGACY_PUMPKIN_PIE: Material;
  static readonly LEGACY_FIREWORK: Material;
  static readonly LEGACY_FIREWORK_CHARGE: Material;
  static readonly LEGACY_ENCHANTED_BOOK: Material;
  static readonly LEGACY_REDSTONE_COMPARATOR: Material;
  static readonly LEGACY_NETHER_BRICK_ITEM: Material;
  static readonly LEGACY_QUARTZ: Material;
  static readonly LEGACY_EXPLOSIVE_MINECART: Material;
  static readonly LEGACY_HOPPER_MINECART: Material;
  static readonly LEGACY_PRISMARINE_SHARD: Material;
  static readonly LEGACY_PRISMARINE_CRYSTALS: Material;
  static readonly LEGACY_RABBIT: Material;
  static readonly LEGACY_COOKED_RABBIT: Material;
  static readonly LEGACY_RABBIT_STEW: Material;
  static readonly LEGACY_RABBIT_FOOT: Material;
  static readonly LEGACY_RABBIT_HIDE: Material;
  static readonly LEGACY_ARMOR_STAND: Material;
  static readonly LEGACY_IRON_BARDING: Material;
  static readonly LEGACY_GOLD_BARDING: Material;
  static readonly LEGACY_DIAMOND_BARDING: Material;
  static readonly LEGACY_LEASH: Material;
  static readonly LEGACY_NAME_TAG: Material;
  static readonly LEGACY_COMMAND_MINECART: Material;
  static readonly LEGACY_MUTTON: Material;
  static readonly LEGACY_COOKED_MUTTON: Material;
  static readonly LEGACY_BANNER: Material;
  static readonly LEGACY_END_CRYSTAL: Material;
  static readonly LEGACY_SPRUCE_DOOR_ITEM: Material;
  static readonly LEGACY_BIRCH_DOOR_ITEM: Material;
  static readonly LEGACY_JUNGLE_DOOR_ITEM: Material;
  static readonly LEGACY_ACACIA_DOOR_ITEM: Material;
  static readonly LEGACY_DARK_OAK_DOOR_ITEM: Material;
  static readonly LEGACY_CHORUS_FRUIT: Material;
  static readonly LEGACY_CHORUS_FRUIT_POPPED: Material;
  static readonly LEGACY_BEETROOT: Material;
  static readonly LEGACY_BEETROOT_SEEDS: Material;
  static readonly LEGACY_BEETROOT_SOUP: Material;
  static readonly LEGACY_DRAGONS_BREATH: Material;
  static readonly LEGACY_SPLASH_POTION: Material;
  static readonly LEGACY_SPECTRAL_ARROW: Material;
  static readonly LEGACY_TIPPED_ARROW: Material;
  static readonly LEGACY_LINGERING_POTION: Material;
  static readonly LEGACY_SHIELD: Material;
  static readonly LEGACY_ELYTRA: Material;
  static readonly LEGACY_BOAT_SPRUCE: Material;
  static readonly LEGACY_BOAT_BIRCH: Material;
  static readonly LEGACY_BOAT_JUNGLE: Material;
  static readonly LEGACY_BOAT_ACACIA: Material;
  static readonly LEGACY_BOAT_DARK_OAK: Material;
  static readonly LEGACY_TOTEM: Material;
  static readonly LEGACY_SHULKER_SHELL: Material;
  static readonly LEGACY_IRON_NUGGET: Material;
  static readonly LEGACY_KNOWLEDGE_BOOK: Material;
  static readonly LEGACY_GOLD_RECORD: Material;
  static readonly LEGACY_GREEN_RECORD: Material;
  static readonly LEGACY_RECORD_3: Material;
  static readonly LEGACY_RECORD_4: Material;
  static readonly LEGACY_RECORD_5: Material;
  static readonly LEGACY_RECORD_6: Material;
  static readonly LEGACY_RECORD_7: Material;
  static readonly LEGACY_RECORD_8: Material;
  static readonly LEGACY_RECORD_9: Material;
  static readonly LEGACY_RECORD_10: Material;
  static readonly LEGACY_RECORD_11: Material;
  static readonly LEGACY_RECORD_12: Material;
  static valueOf(name: string): Material;
  static values(): Material[];
  static readonly LEGACY_PREFIX: string;
  readonly data: Class<any>;
  /**
   * @return If the type is either AIR, CAVE_AIR or VOID_AIR
  */
  isEmpty(): boolean;
  /**
   * Return the translation key for the Material, so the client can translate it into the active
   * locale when using a TranslatableComponent.
   * @return the translation key
   * @deprecated use {@link #translationKey()}
  */
  getTranslationKey(): string;
  /**
   * Returns the item rarity for the item. The Material MUST be an Item not a block.
   * Use {@link #isItem()} before this.
   *
   * @return the item rarity
  */
  getItemRarity(): ItemRarity;
  /**
   * Returns an immutable multimap of attributes for the slot.
   * {@link #isItem()} must be true for this material.
   *
   * @param equipmentSlot the slot to get the attributes for
   * @throws IllegalArgumentException if {@link #isItem()} is false
   * @return an immutable multimap of attributes
   * @deprecated use {@link #getDefaultAttributeModifiers(EquipmentSlot)}
  */
  getItemAttributes(equipmentSlot: EquipmentSlot): Multimap<Attribute, AttributeModifier>;
  /**
   * Checks if this material is collidable.
   *
   * @return true if collidable
   * @throws IllegalArgumentException if {@link #isBlock()} is false
  */
  isCollidable(): boolean;
  /**
   * Do not use for any reason.
   *
   * @return ID of this material
   * @deprecated Magic value
  */
  getId(): number;
  isLegacy(): boolean;
  getKey(): NamespacedKey;
  /**
   * Gets the maximum amount of this material that can be held in a stack
   *
   * @return Maximum stack size for this material
  */
  getMaxStackSize(): number;
  /**
   * Gets the maximum durability of this material
   *
   * @return Maximum durability for this material
  */
  getMaxDurability(): number;
  /**
   * Creates a new {@link BlockData} instance for this Material, with all
   * properties initialized to unspecified defaults.
   *
   * @return new data instance
  */
  createBlockData(): BlockData;
  /**
   * Creates a new {@link BlockData} instance for this Material, with
   * all properties initialized to unspecified defaults.
   *
   * @param consumer consumer to run on new instance before returning
   * @return new data instance
  */
  createBlockData(consumer: Consumer<BlockData> | null): BlockData;
  /**
   * Creates a new {@link BlockData} instance for this Material, with all
   * properties initialized to unspecified defaults, except for those provided
   * in data.
   *
   * @param data data string
   * @return new data instance
   * @throws IllegalArgumentException if the specified data is not valid
  */
  createBlockData(data: string | null): BlockData;
  /**
   * Gets the MaterialData class associated with this Material
   *
   * @return MaterialData associated with this Material
   * @deprecated use {@link #createBlockData()}
  */
  getData(): Class<MaterialData>;
  /**
   * Constructs a new MaterialData relevant for this Material, with the
   * given initial data
   *
   * @param raw Initial data to construct the MaterialData with
   * @return New MaterialData with the given data
   * @deprecated Magic value
  */
  getNewData(raw: number): MaterialData;
  /**
   * Checks if this Material is a placable block
   *
   * @return true if this material is a block
  */
  isBlock(): boolean;
  /**
   * Checks if this Material is edible.
   *
   * @return true if this Material is edible.
  */
  isEdible(): boolean;
  /**
   * Attempts to get the Material with the given name.
   * 
   * This is a normal lookup, names must be the precise name they are given
   * in the enum.
   *
   * @param name Name of the material to get
   * @return Material if found, or null
  */
  static getMaterial(name: string): Material | null;
  /**
   * Attempts to get the Material with the given name.
   * 
   * This is a normal lookup, names must be the precise name they are given in
   * the enum (but optionally including the LEGACY_PREFIX if legacyName is
   * true).
   * 
   * If legacyName is true, then the lookup will be against legacy materials,
   * but the returned Material will be a modern material (ie this method is
   * useful for updating stored data).
   *
   * @param name Name of the material to get
   * @param legacyName whether this is a legacy name lookup
   * @return Material if found, or null
  */
  static getMaterial(name: string, legacyName: boolean): Material | null;
  /**
   * Attempts to match the Material with the given name.
   * 
   * This is a match lookup; names will be stripped of the "minecraft:"
   * namespace, converted to uppercase, then stripped of special characters in
   * an attempt to format it like the enum.
   *
   * @param name Name of the material to get
   * @return Material if found, or null
  */
  static matchMaterial(name: string): Material | null;
  /**
   * Attempts to match the Material with the given name.
   * 
   * This is a match lookup; names will be stripped of the "minecraft:"
   * namespace, converted to uppercase, then stripped of special characters in
   * an attempt to format it like the enum.
   *
   * @param name Name of the material to get
   * @param legacyName whether this is a legacy name (see
   * {@link #getMaterial(java.lang.String, boolean)}
   * @return Material if found, or null
  */
  static matchMaterial(name: string, legacyName: boolean): Material | null;
  /**
   * @return True if this material represents a playable music disk.
  */
  isRecord(): boolean;
  /**
   * Check if the material is a block and solid (can be built upon)
   *
   * @return True if this material is a block and solid
  */
  isSolid(): boolean;
  /**
   * Check if the material is an air block.
   *
   * @return True if this material is an air block.
  */
  isAir(): boolean;
  /**
   * Check if the material is a block and does not block any light
   *
   * @return True if this material is a block and does not block any light
   * @deprecated currently does not have an implementation which is well
   * linked to the underlying server. Contributions welcome.
  */
  isTransparent(): boolean;
  /**
   * Check if the material is a block and can catch fire
   *
   * @return True if this material is a block and can catch fire
  */
  isFlammable(): boolean;
  /**
   * Check if the material is a block and can burn away
   *
   * @return True if this material is a block and can burn away
  */
  isBurnable(): boolean;
  /**
   * Checks if this Material can be used as fuel in a Furnace
   *
   * @return true if this Material can be used as fuel.
  */
  isFuel(): boolean;
  /**
   * Check if the material is a block and completely blocks vision
   *
   * @return True if this material is a block and completely blocks vision
  */
  isOccluding(): boolean;
  /**
   * @return True if this material is affected by gravity.
  */
  hasGravity(): boolean;
  /**
   * Checks if this Material is an obtainable item.
   *
   * @return true if this material is an item
  */
  isItem(): boolean;
  /**
   * Checks if this Material can be interacted with.
   *
   * Interactable materials include those with functionality when they are
   * interacted with by a player such as chests, furnaces, etc.
   *
   * Some blocks such as piston heads and stairs are considered interactable
   * though may not perform any additional functionality.
   *
   * Note that the interactability of some materials may be dependant on their
   * state as well. This method will return true if there is at least one
   * state in which additional interact handling is performed for the
   * material.
   *
   * @return true if this material can be interacted with.
  */
  isInteractable(): boolean;
  /**
   * Obtains the block's hardness level (also known as "strength").
   * 
   * This number is used to calculate the time required to break each block.
   * 
   * Only available when {@link #isBlock()} is true.
   *
   * @return the hardness of that material.
  */
  getHardness(): number;
  /**
   * Obtains the blast resistance value (also known as block "durability").
   * 
   * This value is used in explosions to calculate whether a block should be
   * broken or not.
   * 
   * Only available when {@link #isBlock()} is true.
   *
   * @return the blast resistance of that material.
  */
  getBlastResistance(): number;
  /**
   * Returns a value that represents how 'slippery' the block is.
   *
   * Blocks with higher slipperiness, like {@link Material#ICE} can be slid on
   * further by the player and other entities.
   *
   * Most blocks have a default slipperiness of `0.6f`.
   *
   * Only available when {@link #isBlock()} is true.
   *
   * @return the slipperiness of this block
  */
  getSlipperiness(): number;
  /**
   * Determines the remaining item in a crafting grid after crafting with this
   * ingredient.
   * 
   * Only available when {@link #isItem()} is true.
   *
   * @return the item left behind when crafting, or null if nothing is.
  */
  getCraftingRemainingItem(): Material | null;
  /**
   * Get the best suitable slot for this Material.
   *
   * For most items this will be {@link EquipmentSlot#HAND}.
   *
   * @return the best EquipmentSlot for this Material
  */
  getEquipmentSlot(): EquipmentSlot;
  /**
   * Return an immutable copy of all default {@link Attribute}s and their
   * {@link AttributeModifier}s for a given {@link EquipmentSlot}.
   *
   * Default attributes are those that are always preset on some items, such
   * as the attack damage on weapons or the armor value on armor.
   *
   * Only available when {@link #isItem()} is true.
   *
   * @param slot the {@link EquipmentSlot} to check
   * @return the immutable {@link Multimap} with the respective default
   * Attributes and modifiers, or an empty map if no attributes are set.
  */
  getDefaultAttributeModifiers(slot: EquipmentSlot): Multimap<Attribute, AttributeModifier>;
  /**
   * Get the {@link CreativeCategory} to which this material belongs.
   *
   * @return the creative category. null if does not belong to a category
  */
  getCreativeCategory(): CreativeCategory | null;
}
/**
 * Represents a registry of Bukkit objects that may be retrieved by
 * {@link NamespacedKey}.
 *
 * @param  type of item in the registry
*/
export class Registry<T> extends Iterable<T> {
  /**
   * Server advancements.
   *
   * @see Bukkit#getAdvancement(org.bukkit.NamespacedKey)
   * @see Bukkit#advancementIterator()
  */
  static readonly ADVANCEMENT: Registry<Advancement>;
  /**
   * Server art.
   *
   * @see Art
  */
  static readonly ART: Registry<Art>;
  /**
   * Attribute.
   *
   * @see Attribute
  */
  static readonly ATTRIBUTE: Registry<Attribute>;
  /**
   * Server biomes.
   *
   * @see Biome
  */
  static readonly BIOME: Registry<Biome>;
  /**
   * Custom boss bars.
   *
   * @see Bukkit#getBossBar(org.bukkit.NamespacedKey)
   * @see Bukkit#getBossBars()
  */
  static readonly BOSS_BARS: Registry<KeyedBossBar>;
  /**
   * Server enchantments.
   *
   * @see Enchantment#getByKey(org.bukkit.NamespacedKey)
  */
  static readonly ENCHANTMENT: Registry<Enchantment>;
  /**
   * Server entity types.
   *
   * @see EntityType
  */
  static readonly ENTITY_TYPE: Registry<EntityType>;
  /**
   * Default server loot tables.
   *
   * @see LootTables
  */
  static readonly LOOT_TABLES: Registry<LootTables>;
  /**
   * Server materials.
   *
   * @see Material
  */
  static readonly MATERIAL: Registry<Material>;
  /**
   * Server statistics.
   *
   * @see Statistic
  */
  static readonly STATISTIC: Registry<Statistic>;
  /**
   * Sound keys.
   *
   * @see Sound
  */
  static readonly SOUNDS: Registry<Sound>;
  /**
   * Villager profession.
   *
   * @see Villager.Profession
  */
  static readonly VILLAGER_PROFESSION: Registry<Profession>;
  /**
   * Villager type.
   *
   * @see Villager.Type
  */
  static readonly VILLAGER_TYPE: Registry<org_bukkit_entity_Villager_Type>;
  /**
   * Memory Keys.
   *
   * @see MemoryKey
  */
  static readonly MEMORY_MODULE_TYPE: Registry<MemoryKey>;
  /**
   * Server fluids.
   *
   * @see Fluid
  */
  static readonly FLUID: Registry<Fluid>;
  /**
   * Game events.
   *
   * @see GameEvent
  */
  static readonly GAME_EVENT: Registry<GameEvent>;
  /**
   * Configured structures.
   * @see io.papermc.paper.world.structure.ConfiguredStructure
  */
  static readonly CONFIGURED_STRUCTURE: Registry<ConfiguredStructure>;
  /**
   * Potion effect types.
   *
   * @see org.bukkit.potion.PotionEffectType
  */
  static readonly POTION_EFFECT_TYPE: Registry<PotionEffectType>;
  /**
   * Structure types.
   *
   * @see StructureType
  */
  static readonly STRUCTURE_TYPE: Registry<StructureType>;
  /**
   * Get the object by its key.
   *
   * @param key non-null key
   * @return item or null if does not exist
  */
  get(key: NamespacedKey): T | null;
}
/**
 * Represents a group of sounds for blocks that are played when various actions
 * happen (ie stepping, breaking, hitting, etc).
*/
export class SoundGroup {
  /**
   * Get the volume these sounds are played at.
   *
   * Note that this volume does not always represent the actual volume
   * received by the client.
   *
   * @return volume
  */
  getVolume(): number;
  /**
   * Gets the pitch these sounds are played at.
   *
   * Note that this pitch does not always represent the actual pitch received
   * by the client.
   *
   * @return pitch
  */
  getPitch(): number;
  /**
   * Gets the corresponding breaking sound for this group.
   *
   * @return the break sound
  */
  getBreakSound(): Sound;
  /**
   * Gets the corresponding step sound for this group.
   *
   * @return the step sound
  */
  getStepSound(): Sound;
  /**
   * Gets the corresponding place sound for this group.
   *
   * @return the place sound
  */
  getPlaceSound(): Sound;
  /**
   * Gets the corresponding hit sound for this group.
   *
   * @return the hit sound
  */
  getHitSound(): Sound;
  /**
   * Gets the corresponding fall sound for this group.
   *
   * @return the fall sound
  */
  getFallSound(): Sound;
}
/**
 * Represents a static, thread-safe snapshot of chunk of blocks.
 * 
 * Purpose is to allow clean, efficient copy of a chunk data to be made, and
 * then handed off for processing in another thread (e.g. map rendering)
*/
export class ChunkSnapshot {
  /**
   * Gets the X-coordinate of this chunk
   *
   * @return X-coordinate
  */
  getX(): number;
  /**
   * Gets the Z-coordinate of this chunk
   *
   * @return Z-coordinate
  */
  getZ(): number;
  /**
   * Gets name of the world containing this chunk
   *
   * @return Parent World Name
  */
  getWorldName(): string;
  /**
   * Get block type for block at corresponding coordinate in the chunk
   *
   * @param x 0-15
   * @param y world minHeight (inclusive) - world maxHeight (exclusive)
   * @param z 0-15
   * @return block material type
  */
  getBlockType(x: number, y: number, z: number): Material;
  /**
   * Get block data for block at corresponding coordinate in the chunk
   *
   * @param x 0-15
   * @param y world minHeight (inclusive) - world maxHeight (exclusive)
   * @param z 0-15
   * @return block material type
  */
  getBlockData(x: number, y: number, z: number): BlockData;
  /**
   * Get block data for block at corresponding coordinate in the chunk
   *
   * @param x 0-15
   * @param y world minHeight (inclusive) - world maxHeight (exclusive)
   * @param z 0-15
   * @return 0-15
   * @deprecated Magic value
  */
  getData(x: number, y: number, z: number): number;
  /**
   * Get sky light level for block at corresponding coordinate in the chunk
   *
   * @param x 0-15
   * @param y world minHeight (inclusive) - world maxHeight (exclusive)
   * @param z 0-15
   * @return 0-15
  */
  getBlockSkyLight(x: number, y: number, z: number): number;
  /**
   * Get light level emitted by block at corresponding coordinate in the
   * chunk
   *
   * @param x 0-15
   * @param y world minHeight (inclusive) - world maxHeight (exclusive)
   * @param z 0-15
   * @return 0-15
  */
  getBlockEmittedLight(x: number, y: number, z: number): number;
  /**
   * Gets the highest non-air coordinate at the given coordinates
   *
   * @param x X-coordinate of the blocks (0-15)
   * @param z Z-coordinate of the blocks (0-15)
   * @return Y-coordinate of the highest non-air block
  */
  getHighestBlockYAt(x: number, z: number): number;
  /**
   * Get biome at given coordinates
   *
   * @param x X-coordinate (0-15)
   * @param z Z-coordinate (0-15)
   * @return Biome at given coordinate
   * @deprecated biomes are now 3-dimensional
  */
  getBiome(x: number, z: number): Biome;
  /**
   * Get biome at given coordinates
   *
   * @param x X-coordinate (0-15)
   * @param y Y-coordinate (world minHeight (inclusive) - world maxHeight (exclusive))
   * @param z Z-coordinate (0-15)
   * @return Biome at given coordinate
  */
  getBiome(x: number, y: number, z: number): Biome;
  /**
   * Get raw biome temperature at given coordinates
   *
   * @param x X-coordinate (0-15)
   * @param z Z-coordinate (0-15)
   * @return temperature at given coordinate
   * @deprecated biomes are now 3-dimensional
  */
  getRawBiomeTemperature(x: number, z: number): number;
  /**
   * Get raw biome temperature at given coordinates
   *
   * @param x X-coordinate (0-15)
   * @param y Y-coordinate (0-15)
   * @param z Z-coordinate (0-15)
   * @return temperature at given coordinate
  */
  getRawBiomeTemperature(x: number, y: number, z: number): number;
  /**
   * Get world full time when chunk snapshot was captured
   *
   * @return time in ticks
  */
  getCaptureFullTime(): number;
  /**
   * Test if section is empty
   *
   * @param sy - section Y coordinate (block Y / 16, world minHeight (inclusive) - world maxHeight (exclusive))
   * @return true if empty, false if not
  */
  isSectionEmpty(sy: number): boolean;
  /**
   * Tests if this snapshot contains the specified block.
   *
   * @param block block to test
   * @return if the block is contained within
  */
  contains(block: BlockData): boolean;
}
/**
 * Represents a countable statistic, which is tracked by the server.
*/
export class Statistic extends Enum<Statistic> {
  static readonly DAMAGE_DEALT: Statistic;
  static readonly DAMAGE_TAKEN: Statistic;
  static readonly DEATHS: Statistic;
  static readonly MOB_KILLS: Statistic;
  static readonly PLAYER_KILLS: Statistic;
  static readonly FISH_CAUGHT: Statistic;
  static readonly ANIMALS_BRED: Statistic;
  static readonly LEAVE_GAME: Statistic;
  static readonly JUMP: Statistic;
  static readonly DROP_COUNT: Statistic;
  static readonly DROP: Statistic;
  static readonly PICKUP: Statistic;
  /**
   * Name is misleading, actually records ticks played.
  */
  static readonly PLAY_ONE_MINUTE: Statistic;
  static readonly TOTAL_WORLD_TIME: Statistic;
  static readonly WALK_ONE_CM: Statistic;
  static readonly WALK_ON_WATER_ONE_CM: Statistic;
  static readonly FALL_ONE_CM: Statistic;
  static readonly SNEAK_TIME: Statistic;
  static readonly CLIMB_ONE_CM: Statistic;
  static readonly FLY_ONE_CM: Statistic;
  static readonly WALK_UNDER_WATER_ONE_CM: Statistic;
  static readonly MINECART_ONE_CM: Statistic;
  static readonly BOAT_ONE_CM: Statistic;
  static readonly PIG_ONE_CM: Statistic;
  static readonly HORSE_ONE_CM: Statistic;
  static readonly SPRINT_ONE_CM: Statistic;
  static readonly CROUCH_ONE_CM: Statistic;
  static readonly AVIATE_ONE_CM: Statistic;
  static readonly MINE_BLOCK: Statistic;
  static readonly USE_ITEM: Statistic;
  static readonly BREAK_ITEM: Statistic;
  static readonly CRAFT_ITEM: Statistic;
  static readonly KILL_ENTITY: Statistic;
  static readonly ENTITY_KILLED_BY: Statistic;
  static readonly TIME_SINCE_DEATH: Statistic;
  static readonly TALKED_TO_VILLAGER: Statistic;
  static readonly TRADED_WITH_VILLAGER: Statistic;
  static readonly CAKE_SLICES_EATEN: Statistic;
  static readonly CAULDRON_FILLED: Statistic;
  static readonly CAULDRON_USED: Statistic;
  static readonly ARMOR_CLEANED: Statistic;
  static readonly BANNER_CLEANED: Statistic;
  static readonly BREWINGSTAND_INTERACTION: Statistic;
  static readonly BEACON_INTERACTION: Statistic;
  static readonly DROPPER_INSPECTED: Statistic;
  static readonly HOPPER_INSPECTED: Statistic;
  static readonly DISPENSER_INSPECTED: Statistic;
  static readonly NOTEBLOCK_PLAYED: Statistic;
  static readonly NOTEBLOCK_TUNED: Statistic;
  static readonly FLOWER_POTTED: Statistic;
  static readonly TRAPPED_CHEST_TRIGGERED: Statistic;
  static readonly ENDERCHEST_OPENED: Statistic;
  static readonly ITEM_ENCHANTED: Statistic;
  static readonly RECORD_PLAYED: Statistic;
  static readonly FURNACE_INTERACTION: Statistic;
  static readonly CRAFTING_TABLE_INTERACTION: Statistic;
  static readonly CHEST_OPENED: Statistic;
  static readonly SLEEP_IN_BED: Statistic;
  static readonly SHULKER_BOX_OPENED: Statistic;
  static readonly TIME_SINCE_REST: Statistic;
  static readonly SWIM_ONE_CM: Statistic;
  static readonly DAMAGE_DEALT_ABSORBED: Statistic;
  static readonly DAMAGE_DEALT_RESISTED: Statistic;
  static readonly DAMAGE_BLOCKED_BY_SHIELD: Statistic;
  static readonly DAMAGE_ABSORBED: Statistic;
  static readonly DAMAGE_RESISTED: Statistic;
  static readonly CLEAN_SHULKER_BOX: Statistic;
  static readonly OPEN_BARREL: Statistic;
  static readonly INTERACT_WITH_BLAST_FURNACE: Statistic;
  static readonly INTERACT_WITH_SMOKER: Statistic;
  static readonly INTERACT_WITH_LECTERN: Statistic;
  static readonly INTERACT_WITH_CAMPFIRE: Statistic;
  static readonly INTERACT_WITH_CARTOGRAPHY_TABLE: Statistic;
  static readonly INTERACT_WITH_LOOM: Statistic;
  static readonly INTERACT_WITH_STONECUTTER: Statistic;
  static readonly BELL_RING: Statistic;
  static readonly RAID_TRIGGER: Statistic;
  static readonly RAID_WIN: Statistic;
  static readonly INTERACT_WITH_ANVIL: Statistic;
  static readonly INTERACT_WITH_GRINDSTONE: Statistic;
  static readonly TARGET_HIT: Statistic;
  static readonly INTERACT_WITH_SMITHING_TABLE: Statistic;
  static readonly STRIDER_ONE_CM: Statistic;
  static valueOf(name: string): Statistic;
  static values(): Statistic[];
  /**
   * Gets the type of this statistic.
   *
   * @return the type of this statistic
  */
  getType(): org_bukkit_Statistic_Type;
  /**
   * Checks if this is a substatistic.
   * 
   * A substatistic exists en masse for each block, item, or entitytype, depending on
   * {@link #getType()}.
   * 
   * This is a redundant method and equivalent to checking
   * getType() != Type.UNTYPED
   *
   * @return true if this is a substatistic
  */
  isSubstatistic(): boolean;
  /**
   * Checks if this is a substatistic dealing with blocks.
   * 
   * This is a redundant method and equivalent to checking
   * getType() == Type.BLOCK
   *
   * @return true if this deals with blocks
  */
  isBlock(): boolean;
  getKey(): NamespacedKey;
}
/**
 * A delegate for handling block changes. This serves as a direct interface
 * between generation algorithms in the server implementation and utilizing
 * code.
*/
export class BlockChangeDelegate {
  /**
   * Set a block data at the specified coordinates.
   *
   * @param x X coordinate
   * @param y Y coordinate
   * @param z Z coordinate
   * @param blockData Block data
   * @return true if the block was set successfully
  */
  setBlockData(x: number, y: number, z: number, blockData: BlockData): boolean;
  /**
   * Get the block data at the location.
   *
   * @param x X coordinate
   * @param y Y coordinate
   * @param z Z coordinate
   * @return The block data
  */
  getBlockData(x: number, y: number, z: number): BlockData;
  /**
   * Gets the height of the world.
   *
   * @return Height of the world
  */
  getHeight(): number;
  /**
   * Checks if the specified block is empty (air) or not.
   *
   * @param x X coordinate
   * @param y Y coordinate
   * @param z Z coordinate
   * @return True if the block is considered empty.
  */
  isEmpty(x: number, y: number, z: number): boolean;
}
/**
 * Represents the Bukkit core, for version and Server singleton handling
*/
export class Bukkit {
  /**
   * Gets the current {@link Server} singleton
   *
   * @return Server instance being ran
  */
  static getServer(): Server;
  /**
   * Returns the de facto plugins directory, generally used for storing plugin jars to be loaded,
   * as well as their {@link org.bukkit.plugin.Plugin#getDataFolder() data folders}.
   *
   * Plugins should use {@link org.bukkit.plugin.Plugin#getDataFolder()} rather than traversing this
   * directory manually when determining the location in which to store their data and configuration files.
   *
   * @return plugins directory
  */
  static getPluginsFolder(): File;
  /**
   * Attempts to set the {@link Server} singleton.
   * 
   * This cannot be done if the Server is already set.
   *
   * @param server Server instance
  */
  static setServer(server: Server);
  /**
   * Gets message describing the version server is running.
   *
   * @return message describing the version server is running
  */
  static getVersionMessage(): string;
  /**
   * Gets the name of this server implementation.
   *
   * @return name of this server implementation
  */
  static getName(): string;
  /**
   * Gets the version string of this server implementation.
   *
   * @return version of this server implementation
  */
  static getVersion(): string;
  /**
   * Gets the Bukkit version that this server is running.
   *
   * @return version of Bukkit
  */
  static getBukkitVersion(): string;
  /**
   * Gets the version of game this server implements
   *
   * @return version of game
  */
  static getMinecraftVersion(): string;
  /**
   * Gets a view of all currently logged in players. This {@linkplain
   * Collections#unmodifiableCollection(Collection) view} is a reused
   * object, making some operations like {@link Collection#size()}
   * zero-allocation.
   * 
   * The collection is a view backed by the internal representation, such
   * that, changes to the internal state of the server will be reflected
   * immediately. However, the reuse of the returned collection (identity)
   * is not strictly guaranteed for future or all implementations. Casting
   * the collection, or relying on interface implementations (like {@link
   * Serializable} or {@link List}), is deprecated.
   * 
   * Iteration behavior is undefined outside of self-contained main-thread
   * uses. Normal and immediate iterator use without consequences that
   * affect the collection are fully supported. The effects following
   * (non-exhaustive) {@link Entity#teleport(Location) teleportation},
   * {@link Player#setHealth(double) death}, and {@link Player#kickPlayer(
   * String) kicking} are undefined. Any use of this collection from
   * asynchronous threads is unsafe.
   * 
   * For safe consequential iteration or mimicking the old array behavior,
   * using {@link Collection#toArray(Object[])} is recommended. For making
   * snapshots, {@link ImmutableList#copyOf(Collection)} is recommended.
   *
   * @return a view of currently online players.
  */
  static getOnlinePlayers(): Collection<Player>;
  /**
   * Get the maximum amount of players which can login to this server.
   *
   * @return the amount of players this server allows
  */
  static getMaxPlayers(): number;
  /**
   * Set the maximum amount of players which can login to this server.
   *
   * @param maxPlayers the amount of players this server allows
  */
  static setMaxPlayers(maxPlayers: number);
  /**
   * Get the game port that the server runs on.
   *
   * @return the port number of this server
  */
  static getPort(): number;
  /**
   * Get the view distance from this server.
   *
   * @return the view distance from this server.
  */
  static getViewDistance(): number;
  /**
   * Get the simulation distance from this server.
   *
   * @return the simulation distance from this server.
  */
  static getSimulationDistance(): number;
  /**
   * Get the IP that this server is bound to, or empty string if not
   * specified.
   *
   * @return the IP string that this server is bound to, otherwise empty
   *     string
  */
  static getIp(): string;
  /**
   * Get world type (level-type setting) for default world.
   *
   * @return the value of level-type (e.g. DEFAULT, FLAT, DEFAULT_1_1)
  */
  static getWorldType(): string;
  /**
   * Get generate-structures setting.
   *
   * @return true if structure generation is enabled, false otherwise
  */
  static getGenerateStructures(): boolean;
  /**
   * Get max world size.
   *
   * @return the maximum world size as specified for the server
  */
  static getMaxWorldSize(): number;
  /**
   * Gets whether this server allows the End or not.
   *
   * @return whether this server allows the End or not
  */
  static getAllowEnd(): boolean;
  /**
   * Gets whether this server allows the Nether or not.
   *
   * @return whether this server allows the Nether or not
  */
  static getAllowNether(): boolean;
  /**
   * Gets the server resource pack uri, or empty string if not specified.
   *
   * @return the server resource pack uri, otherwise empty string
  */
  static getResourcePack(): string;
  /**
   * Gets the SHA-1 digest of the server resource pack, or empty string if
   * not specified.
   *
   * @return the SHA-1 digest of the server resource pack, otherwise empty
   *     string
  */
  static getResourcePackHash(): string;
  /**
   * Gets the custom prompt message to be shown when the server resource
   * pack is required, or empty string if not specified.
   *
   * @return the custom prompt message to be shown when the server resource,
   *     otherwise empty string
  */
  static getResourcePackPrompt(): string;
  /**
   * Gets whether the server resource pack is enforced.
   *
   * @return whether the server resource pack is enforced
  */
  static isResourcePackRequired(): boolean;
  /**
   * Gets whether this server has a whitelist or not.
   *
   * @return whether this server has a whitelist or not
  */
  static hasWhitelist(): boolean;
  /**
   * Sets if the server is whitelisted.
   *
   * @param value true for whitelist on, false for off
  */
  static setWhitelist(value: boolean): void;
  /**
   * Gets whether the server whitelist is enforced.
   *
   * If the whitelist is enforced, non-whitelisted players will be
   * disconnected when the server whitelist is reloaded.
   *
   * @return whether the server whitelist is enforced
  */
  static isWhitelistEnforced(): boolean;
  /**
   * Sets if the server whitelist is enforced.
   *
   * If the whitelist is enforced, non-whitelisted players will be
   * disconnected when the server whitelist is reloaded.
   *
   * @param value true for enforced, false for not
  */
  static setWhitelistEnforced(value: boolean): void;
  /**
   * Gets a list of whitelisted players.
   *
   * @return a set containing all whitelisted players
  */
  static getWhitelistedPlayers(): Set<OfflinePlayer>;
  /**
   * Reloads the whitelist from disk.
  */
  static reloadWhitelist(): void;
  /**
   * Broadcast a message to all players.
   * 
   * This is the same as calling {@link #broadcast(java.lang.String,
   * java.lang.String)} to {@link Server#BROADCAST_CHANNEL_USERS}
   *
   * @param message the message
   * @return the number of players
   * @deprecated in favour of {@link Server#broadcast(net.kyori.adventure.text.Component)}
  */
  static broadcastMessage(message: string): number;
  /**
   * Gets the name of the update folder. The update folder is used to safely
   * update plugins at the right moment on a plugin load.
   * 
   * The update folder name is relative to the plugins folder.
   *
   * @return the name of the update folder
  */
  static getUpdateFolder(): string;
  /**
   * Gets the update folder. The update folder is used to safely update
   * plugins at the right moment on a plugin load.
   *
   * @return the update folder
  */
  static getUpdateFolderFile(): File;
  /**
   * Gets the value of the connection throttle setting.
   *
   * @return the value of the connection throttle setting
  */
  static getConnectionThrottle(): number;
  /**
   * Gets default ticks per animal spawns value.
   * 
   * Example Usage:
   * 
   * A value of 1 will mean the server will attempt to spawn monsters
   *     every tick.
   * A value of 400 will mean the server will attempt to spawn monsters
   *     every 400th tick.
   * A value below 0 will be reset back to Minecraft's default.
   * 
   * 
   * Note: If set to 0, animal spawning will be disabled. We
   * recommend using spawn-animals to control this instead.
   * 
   * Minecraft default: 400.
   *
   * @return the default ticks per animal spawns value
   * @deprecated Deprecated in favor of {@link #getTicksPerSpawns(SpawnCategory)}
  */
  static getTicksPerAnimalSpawns(): number;
  /**
   * Gets the default ticks per monster spawns value.
   * 
   * Example Usage:
   * 
   * A value of 1 will mean the server will attempt to spawn monsters
   *     every tick.
   * A value of 400 will mean the server will attempt to spawn monsters
   *     every 400th tick.
   * A value below 0 will be reset back to Minecraft's default.
   * 
   * 
   * Note: If set to 0, monsters spawning will be disabled. We
   * recommend using spawn-monsters to control this instead.
   * 
   * Minecraft default: 1.
   *
   * @return the default ticks per monsters spawn value
   * @deprecated Deprecated in favor of {@link #getTicksPerSpawns(SpawnCategory)}
  */
  static getTicksPerMonsterSpawns(): number;
  /**
   * Gets the default ticks per water mob spawns value.
   * 
   * Example Usage:
   * 
   * A value of 1 will mean the server will attempt to spawn water mobs
   *     every tick.
   * A value of 400 will mean the server will attempt to spawn water mobs
   *     every 400th tick.
   * A value below 0 will be reset back to Minecraft's default.
   * 
   * 
   * Note: If set to 0, water mobs spawning will be disabled.
   * 
   * Minecraft default: 1.
   *
   * @return the default ticks per water mobs spawn value
   * @deprecated Deprecated in favor of {@link #getTicksPerSpawns(SpawnCategory)}
  */
  static getTicksPerWaterSpawns(): number;
  /**
   * Gets the default ticks per ambient mob spawns value.
   * 
   * Example Usage:
   * 
   * A value of 1 will mean the server will attempt to spawn ambient mobs
   *     every tick.
   * A value of 400 will mean the server will attempt to spawn ambient mobs
   *     every 400th tick.
   * A value below 0 will be reset back to Minecraft's default.
   * 
   * 
   * Note: If set to 0, ambient mobs spawning will be disabled.
   * 
   * Minecraft default: 1.
   *
   * @return the default ticks per ambient mobs spawn value
   * @deprecated Deprecated in favor of {@link #getTicksPerSpawns(SpawnCategory)}
  */
  static getTicksPerAmbientSpawns(): number;
  /**
   * Gets the default ticks per water ambient mob spawns value.
   * 
   * Example Usage:
   * 
   * A value of 1 will mean the server will attempt to spawn water ambient mobs
   *     every tick.
   * A value of 400 will mean the server will attempt to spawn water ambient mobs
   *     every 400th tick.
   * A value below 0 will be reset back to Minecraft's default.
   * 
   * 
   * Note: If set to 0, ambient mobs spawning will be disabled.
   * 
   * Minecraft default: 1.
   *
   * @return the default ticks per water ambient mobs spawn value
   * @deprecated Deprecated in favor of {@link #getTicksPerSpawns(SpawnCategory)}
  */
  static getTicksPerWaterAmbientSpawns(): number;
  /**
   * Gets the default ticks per water underground creature spawns value.
   * 
   * Example Usage:
   * 
   * A value of 1 will mean the server will attempt to spawn water underground creature
   *     every tick.
   * A value of 400 will mean the server will attempt to spawn water underground creature
   *     every 400th tick.
   * A value below 0 will be reset back to Minecraft's default.
   * 
   * 
   * Note: If set to 0, water underground creature spawning will be disabled.
   * 
   * Minecraft default: 1.
   *
   * @return the default ticks per water underground creature spawn value
   * @deprecated Deprecated in favor of {@link #getTicksPerSpawns(SpawnCategory)}
  */
  static getTicksPerWaterUndergroundCreatureSpawns(): number;
  /**
   * Gets the default ticks per {@link SpawnCategory} spawns value.
   * 
   * Example Usage:
   * 
   * A value of 1 will mean the server will attempt to spawn {@link SpawnCategory} mobs
   *     every tick.
   * A value of 400 will mean the server will attempt to spawn {@link SpawnCategory} mobs
   *     every 400th tick.
   * A value below 0 will be reset back to Minecraft's default.
   * 
   * 
   * Note: If set to 0, {@link SpawnCategory} mobs spawning will be disabled.
   * 
   * Minecraft default: 1.
   * 
   * Note:  the {@link SpawnCategory#MISC} are not consider.
   *
   * @param spawnCategory the category of spawn
   * @return the default ticks per {@link SpawnCategory} mobs spawn value
  */
  static getTicksPerSpawns(spawnCategory: SpawnCategory): number;
  /**
   * Gets a player object by the given username.
   * 
   * This method may not return objects for offline players.
   *
   * @param name the name to look up
   * @return a player if one was found, null otherwise
  */
  static getPlayer(name: string): Player | null;
  /**
   * Gets the player with the exact given name, case insensitive.
   *
   * @param name Exact name of the player to retrieve
   * @return a player object if one was found, null otherwise
  */
  static getPlayerExact(name: string): Player | null;
  /**
   * Attempts to match any players with the given name, and returns a list
   * of all possibly matches.
   * 
   * This list is not sorted in any particular order. If an exact match is
   * found, the returned list will only contain a single result.
   *
   * @param name the (partial) name to match
   * @return list of all possible players
  */
  static matchPlayer(name: string): Player[];
  /**
   * Gets the player with the given UUID.
   *
   * @param id UUID of the player to retrieve
   * @return a player object if one was found, null otherwise
  */
  static getPlayer(id: UUID): Player | null;
  /**
   * Gets the unique ID of the player currently known as the specified player name
   * In Offline Mode, will return an Offline UUID
   *
   * @param playerName the player name to look up the unique ID for
   * @return A UUID, or null if that player name is not registered with Minecraft and the server is in online mode
  */
  static getPlayerUniqueId(playerName: string): UUID | null;
  /**
   * Gets the plugin manager for interfacing with plugins.
   *
   * @return a plugin manager for this Server instance
  */
  static getPluginManager(): PluginManager;
  /**
   * Gets the scheduler for managing scheduled events.
   *
   * @return a scheduling service for this server
  */
  static getScheduler(): BukkitScheduler;
  /**
   * Gets a services manager.
   *
   * @return s services manager
  */
  static getServicesManager(): ServicesManager;
  /**
   * Gets a list of all worlds on this server.
   *
   * @return a list of worlds
  */
  static getWorlds(): World[];
  /**
   * Creates or loads a world with the given name using the specified
   * options.
   * 
   * If the world is already loaded, it will just return the equivalent of
   * getWorld(creator.name()).
   *
   * @param creator the options to use when creating the world
   * @return newly created or loaded world
  */
  static createWorld(creator: WorldCreator): World | null;
  /**
   * Unloads a world with the given name.
   *
   * @param name Name of the world to unload
   * @param save whether to save the chunks before unloading
   * @return true if successful, false otherwise
  */
  static unloadWorld(name: string, save: boolean): boolean;
  /**
   * Unloads the given world.
   *
   * @param world the world to unload
   * @param save whether to save the chunks before unloading
   * @return true if successful, false otherwise
  */
  static unloadWorld(world: World, save: boolean): boolean;
  /**
   * Gets the world with the given name.
   *
   * @param name the name of the world to retrieve
   * @return a world with the given name, or null if none exists
  */
  static getWorld(name: string): World | null;
  /**
   * Gets the world from the given Unique ID.
   *
   * @param uid a unique-id of the world to retrieve
   * @return a world with the given Unique ID, or null if none exists
  */
  static getWorld(uid: UUID): World | null;
  /**
   * Gets the world from the given NamespacedKey
   *
   * @param worldKey the NamespacedKey of the world to retrieve
   * @return a world with the given NamespacedKey, or null if none exists
  */
  static getWorld(worldKey: NamespacedKey): World | null;
  /**
   * Create a new virtual {@link WorldBorder}.
   *
   * @return the created world border instance
   *
   * @see Player#setWorldBorder(WorldBorder)
  */
  static createWorldBorder(): WorldBorder;
  /**
   * Gets the map from the given item ID.
   *
   * @param id the id of the map to get
   * @return a map view if it exists, or null otherwise
   * @deprecated Magic value
  */
  static getMap(id: number): MapView | null;
  /**
   * Create a new map with an automatically assigned ID.
   *
   * @param world the world the map will belong to
   * @return a newly created map view
  */
  static createMap(world: World): MapView;
  /**
   * Create a new explorer map targeting the closest nearby structure of a
   * given {@link StructureType}.
   * 
   * This method uses implementation default values for radius and
   * findUnexplored (usually 100, true).
   *
   * @param world the world the map will belong to
   * @param location the origin location to find the nearest structure
   * @param structureType the type of structure to find
   * @return a newly created item stack
   *
   * @see World#locateNearestStructure(org.bukkit.Location,
   *      org.bukkit.StructureType, int, boolean)
  */
  static createExplorerMap(world: World, location: Location, structureType: StructureType): ItemStack;
  /**
   * Create a new explorer map targeting the closest nearby structure of a
   * given {@link StructureType}.
   * 
   * This method uses implementation default values for radius and
   * findUnexplored (usually 100, true).
   *
   * @param world the world the map will belong to
   * @param location the origin location to find the nearest structure
   * @param structureType the type of structure to find
   * @param radius radius to search, see World#locateNearestStructure for more
   *               information
   * @param findUnexplored whether to find unexplored structures
   * @return the newly created item stack
   *
   * @see World#locateNearestStructure(org.bukkit.Location,
   *      org.bukkit.StructureType, int, boolean)
  */
  static createExplorerMap(world: World, location: Location, structureType: StructureType, radius: number, findUnexplored: boolean): ItemStack;
  /**
   * Reloads the server, refreshing settings and plugin information.
  */
  static reload(): void;
  /**
   * Reload only the Minecraft data for the server. This includes custom
   * advancements and loot tables.
  */
  static reloadData(): void;
  /**
   * Returns the primary logger associated with this server instance.
   *
   * @return Logger associated with this server
  */
  static getLogger(): Logger;
  /**
   * Gets a {@link PluginCommand} with the given name or alias.
   *
   * @param name the name of the command to retrieve
   * @return a plugin command if found, null otherwise
  */
  static getPluginCommand(name: string): PluginCommand | null;
  /**
   * Writes loaded players to disk.
  */
  static savePlayers(): void;
  /**
   * Dispatches a command on this server, and executes it if found.
   *
   * @param sender the apparent sender of the command
   * @param commandLine the command + arguments. Example: test abc
   *     123
   * @return returns false if no target is found
   * @throws CommandException thrown when the executor for the given command
   *     fails with an unhandled exception
  */
  static dispatchCommand(sender: CommandSender, commandLine: string): boolean;
  /**
   * Adds a recipe to the crafting manager.
   *
   * @param recipe the recipe to add
   * @return true if the recipe was added, false if it wasn't for some
   *     reason
  */
  static addRecipe(recipe: Recipe | null): boolean;
  /**
   * Get a list of all recipes for a given item. The stack size is ignored
   * in comparisons. If the durability is -1, it will match any data value.
   *
   * @param result the item to match against recipe results
   * @return a list of recipes with the given result
  */
  static getRecipesFor(result: ItemStack): Recipe[];
  /**
   * Get the {@link Recipe} for the given key.
   *
   * @param recipeKey the key of the recipe to return
   * @return the recipe for the given key or null.
  */
  static getRecipe(recipeKey: NamespacedKey): Recipe | null;
  /**
   * Get the {@link Recipe} for the list of ItemStacks provided.
   *
   * The list is formatted as a crafting matrix where the index follow
   * the pattern below:
   *
   *      * [ 0 1 2 ]
   * [ 3 4 5 ]
   * [ 6 7 8 ]
   * 
   *
   * NOTE: This method will not modify the provided ItemStack array, for that, use
   * {@link #craftItem(ItemStack[], World, Player)}.
   *
   * @param craftingMatrix list of items to be crafted from.
   *                       Must not contain more than 9 items.
   * @param world The world the crafting takes place in.
   * @return the {@link Recipe} resulting from the given crafting matrix.
  */
  static getCraftingRecipe(craftingMatrix: ItemStack[], world: World): Recipe | null;
  /**
   * Get the crafted item using the list of {@link ItemStack} provided.
   *
   * The list is formatted as a crafting matrix where the index follow
   * the pattern below:
   *
   *      * [ 0 1 2 ]
   * [ 3 4 5 ]
   * [ 6 7 8 ]
   * 
   *
   * The {@link World} and {@link Player} arguments are required to fulfill the Bukkit Crafting
   * events.
   *
   * Calls {@link org.bukkit.event.inventory.PrepareItemCraftEvent} to imitate the {@link Player}
   * initiating the crafting event.
   *
   * @param craftingMatrix list of items to be crafted from.
   *                       Must not contain more than 9 items.
   * @param world The world the crafting takes place in.
   * @param player The player to imitate the crafting event on.
   * @return the {@link ItemStack} resulting from the given crafting matrix, if no recipe is found
   * an ItemStack of {@link Material#AIR} is returned.
  */
  static craftItem(craftingMatrix: ItemStack[], world: World, player: Player): ItemStack;
  /**
   * Get an iterator through the list of crafting recipes.
   *
   * @return an iterator
  */
  static recipeIterator(): Iterator<Recipe>;
  /**
   * Clears the list of crafting recipes.
  */
  static clearRecipes(): void;
  /**
   * Resets the list of crafting recipes to the default.
  */
  static resetRecipes(): void;
  /**
   * Remove a recipe from the server.
   *
   * Note that removing a recipe may cause permanent loss of data
   * associated with that recipe (eg whether it has been discovered by
   * players).
   *
   * @param key NamespacedKey of recipe to remove.
   * @return True if recipe was removed
  */
  static removeRecipe(key: NamespacedKey): boolean;
  /**
   * Gets a list of command aliases defined in the server properties.
   *
   * @return a map of aliases to command names
  */
  static getCommandAliases(): Map<string, string[]>;
  /**
   * Gets the radius, in blocks, around each worlds spawn point to protect.
   *
   * @return spawn radius, or 0 if none
  */
  static getSpawnRadius(): number;
  /**
   * Sets the radius, in blocks, around each worlds spawn point to protect.
   *
   * @param value new spawn radius, or 0 if none
  */
  static setSpawnRadius(spawnRadius: number);
  /**
   * Gets whether the Server hide online players in server status.
   *
   * @return true if the server hide online players, false otherwise
  */
  static getHideOnlinePlayers(): boolean;
  /**
   * Gets whether the Server is in online mode or not.
   *
   * @return true if the server authenticates clients, false otherwise
  */
  static getOnlineMode(): boolean;
  /**
   * Gets whether this server allows flying or not.
   *
   * @return true if the server allows flight, false otherwise
  */
  static getAllowFlight(): boolean;
  /**
   * Gets whether the server is in hardcore mode or not.
   *
   * @return true if the server mode is hardcore, false otherwise
  */
  static isHardcore(): boolean;
  /**
   * Shutdowns the server, stopping everything.
  */
  static shutdown(): void;
  /**
   * Broadcast a message to all players.
   * 
   * This is the same as calling {@link #broadcast(net.kyori.adventure.text.Component,
   * java.lang.String)} with the {@link Server#BROADCAST_CHANNEL_USERS} permission.
   *
   * @param message the message
   * @return the number of players
  */
  static broadcast(message: Component): number;
  /**
   * Broadcasts the specified message to every user with the given
   * permission name.
   *
   * @param message message to broadcast
   * @param permission the required permission {@link Permissible
   *     permissibles} must have to receive the broadcast
   * @return number of message recipients
  */
  static broadcast(message: Component, permission: string): number;
  /**
   * Broadcasts the specified message to every user with the given
   * permission name.
   *
   * @param message message to broadcast
   * @param permission the required permission {@link Permissible
   *     permissibles} must have to receive the broadcast
   * @return number of message recipients
   * @deprecated in favour of {@link #broadcast(net.kyori.adventure.text.Component, String)}
  */
  static broadcast(message: string, permission: string): number;
  static getOfflinePlayer(name: string): OfflinePlayer;
  /**
   * Gets the player by the given name, regardless if they are offline or
   * online.
   * 
   * This will not make a web request to get the UUID for the given name,
   * thus this method will not block. However this method will return
   * `null` if the player is not cached.
   * 
   *
   * @param name the name of the player to retrieve
   * @return an offline player if cached, `null` otherwise
   * @see #getOfflinePlayer(String)
   * @see #getOfflinePlayer(java.util.UUID)
  */
  static getOfflinePlayerIfCached(name: string): OfflinePlayer | null;
  /**
   * Gets the player by the given UUID, regardless if they are offline or
   * online.
   * 
   * This will return an object even if the player does not exist. To this
   * method, all players will exist.
   *
   * @param id the UUID of the player to retrieve
   * @return an offline player
  */
  static getOfflinePlayer(id: UUID): OfflinePlayer;
  /**
   * Creates a new {@link PlayerProfile}.
   *
   * @param uniqueId the unique id
   * @param name the name
   * @return the new PlayerProfile
   * @throws IllegalArgumentException if both the unique id is
   * null and the name is null or blank
   * @deprecated use {@link #createProfile(UUID, String)}
  */
  static createPlayerProfile(uniqueId: UUID | null, name: string | null): PlayerProfile;
  /**
   * Creates a new {@link PlayerProfile}.
   *
   * @param uniqueId the unique id
   * @return the new PlayerProfile
   * @throws IllegalArgumentException if the unique id is null
   * @deprecated use {@link #createProfile(UUID)}
  */
  static createPlayerProfile(uniqueId: UUID): PlayerProfile;
  /**
   * Creates a new {@link PlayerProfile}.
   *
   * @param name the name
   * @return the new PlayerProfile
   * @throws IllegalArgumentException if the name is null or
   * blank
   * @deprecated use {@link #createProfile(String)}
  */
  static createPlayerProfile(name: string): PlayerProfile;
  /**
   * Gets a set containing all current IPs that are banned.
   *
   * @return a set containing banned IP addresses
  */
  static getIPBans(): Set<string>;
  /**
   * Bans the specified address from the server.
   *
   * @param address the IP address to ban
  */
  static banIP(address: string): void;
  /**
   * Unbans the specified address from the server.
   *
   * @param address the IP address to unban
  */
  static unbanIP(address: string): void;
  /**
   * Gets a set containing all banned players.
   *
   * @return a set containing banned players
  */
  static getBannedPlayers(): Set<OfflinePlayer>;
  /**
   * Gets a ban list for the supplied type.
   * 
   * Bans by name are no longer supported and this method will return
   * null when trying to request them. The replacement is bans by UUID.
   *
   * @param type the type of list to fetch, cannot be null
   * @return a ban list of the specified type
  */
  static getBanList(type: Type): BanList;
  /**
   * Gets a set containing all player operators.
   *
   * @return a set containing player operators
  */
  static getOperators(): Set<OfflinePlayer>;
  /**
   * Gets the default {@link GameMode} for new players.
   *
   * @return the default game mode
  */
  static getDefaultGameMode(): GameMode;
  /**
   * Sets the default {@link GameMode} for new players.
   *
   * @param mode the new game mode
  */
  static setDefaultGameMode(defaultGameMode: GameMode);
  /**
   * Gets a {@link ConsoleCommandSender} that may be used as an input source
   * for this server.
   *
   * @return a console command sender
  */
  static getConsoleSender(): ConsoleCommandSender;
  /**
   * Creates a special {@link CommandSender} which redirects command feedback (in the form of chat messages) to the
   * specified listener. The returned sender will have the same effective permissions as {@link #getConsoleSender()}.
   *
   * @param feedback feedback listener
   * @return a command sender
  */
  static createCommandSender(feedback: Consumer<any>): CommandSender;
  /**
   * Gets the folder that contains all of the various {@link World}s.
   *
   * @return folder that contains all worlds
  */
  static getWorldContainer(): File;
  /**
   * Gets every player that has ever played on this server.
   * 
   * This method can be expensive as it loads all the player data files from the disk.
   *
   * @return an array containing all previous players
  */
  static getOfflinePlayers(): OfflinePlayer[];
  /**
   * Gets the {@link Messenger} responsible for this server.
   *
   * @return messenger responsible for this server
  */
  static getMessenger(): Messenger;
  /**
   * Gets the {@link HelpMap} providing help topics for this server.
   *
   * @return a help map for this server
  */
  static getHelpMap(): HelpMap;
  /**
   * Creates an empty inventory with the specified type. If the type
   * is {@link InventoryType#CHEST}, the new inventory has a size of 27;
   * otherwise the new inventory has the normal size for its type.
   * 
   * {@link InventoryType#WORKBENCH} will not process crafting recipes if
   * created with this method. Use
   * {@link Player#openWorkbench(Location, boolean)} instead.
   * 
   * {@link InventoryType#ENCHANTING} will not process {@link ItemStack}s
   * for possible enchanting results. Use
   * {@link Player#openEnchanting(Location, boolean)} instead.
   *
   * @param owner the holder of the inventory, or null to indicate no holder
   * @param type the type of inventory to create
   * @return a new inventory
   * @throws IllegalArgumentException if the {@link InventoryType} cannot be
   * viewed.
   *
   * @see InventoryType#isCreatable()
  */
  static createInventory(owner: InventoryHolder | null, type: InventoryType): Inventory;
  /**
   * Creates an empty inventory with the specified type and title. If the type
   * is {@link InventoryType#CHEST}, the new inventory has a size of 27;
   * otherwise the new inventory has the normal size for its type.
   * It should be noted that some inventory types do not support titles and
   * may not render with said titles on the Minecraft client.
   * 
   * {@link InventoryType#WORKBENCH} will not process crafting recipes if
   * created with this method. Use
   * {@link Player#openWorkbench(Location, boolean)} instead.
   * 
   * {@link InventoryType#ENCHANTING} will not process {@link ItemStack}s
   * for possible enchanting results. Use
   * {@link Player#openEnchanting(Location, boolean)} instead.
   *
   * @param owner The holder of the inventory; can be null if there's no holder.
   * @param type The type of inventory to create.
   * @param title The title of the inventory, to be displayed when it is viewed.
   * @return The new inventory.
   * @throws IllegalArgumentException if the {@link InventoryType} cannot be
   * viewed.
   *
   * @see InventoryType#isCreatable()
  */
  static createInventory(owner: InventoryHolder | null, type: InventoryType, title: Component): Inventory;
  /**
   * Creates an empty inventory with the specified type and title. If the type
   * is {@link InventoryType#CHEST}, the new inventory has a size of 27;
   * otherwise the new inventory has the normal size for its type.
   * It should be noted that some inventory types do not support titles and
   * may not render with said titles on the Minecraft client.
   * 
   * {@link InventoryType#WORKBENCH} will not process crafting recipes if
   * created with this method. Use
   * {@link Player#openWorkbench(Location, boolean)} instead.
   * 
   * {@link InventoryType#ENCHANTING} will not process {@link ItemStack}s
   * for possible enchanting results. Use
   * {@link Player#openEnchanting(Location, boolean)} instead.
   *
   * @param owner The holder of the inventory; can be null if there's no holder.
   * @param type The type of inventory to create.
   * @param title The title of the inventory, to be displayed when it is viewed.
   * @return The new inventory.
   * @throws IllegalArgumentException if the {@link InventoryType} cannot be
   * viewed.
   * @deprecated in favour of {@link #createInventory(InventoryHolder, InventoryType, net.kyori.adventure.text.Component)}
   *
   * @see InventoryType#isCreatable()
  */
  static createInventory(owner: InventoryHolder | null, type: InventoryType, title: string): Inventory;
  /**
   * Creates an empty inventory of type {@link InventoryType#CHEST} with the
   * specified size.
   *
   * @param owner the holder of the inventory, or null to indicate no holder
   * @param size a multiple of 9 as the size of inventory to create
   * @return a new inventory
   * @throws IllegalArgumentException if the size is not a multiple of 9
  */
  static createInventory(owner: InventoryHolder | null, size: number): Inventory;
  /**
   * Creates an empty inventory of type {@link InventoryType#CHEST} with the
   * specified size and title.
   *
   * @param owner the holder of the inventory, or null to indicate no holder
   * @param size a multiple of 9 as the size of inventory to create
   * @param title the title of the inventory, displayed when inventory is
   *     viewed
   * @return a new inventory
   * @throws IllegalArgumentException if the size is not a multiple of 9
  */
  static createInventory(owner: InventoryHolder | null, size: number, title: Component): Inventory;
  /**
   * Creates an empty inventory of type {@link InventoryType#CHEST} with the
   * specified size and title.
   *
   * @param owner the holder of the inventory, or null to indicate no holder
   * @param size a multiple of 9 as the size of inventory to create
   * @param title the title of the inventory, displayed when inventory is
   *     viewed
   * @return a new inventory
   * @throws IllegalArgumentException if the size is not a multiple of 9
   * @deprecated in favour of {@link #createInventory(InventoryHolder, InventoryType, net.kyori.adventure.text.Component)}
  */
  static createInventory(owner: InventoryHolder | null, size: number, title: string): Inventory;
  /**
   * Creates an empty merchant.
   *
   * @param title the title of the corresponding merchant inventory, displayed
   * when the merchant inventory is viewed
   * @return a new merchant
  */
  static createMerchant(title: Component | null): Merchant;
  /**
   * Creates an empty merchant.
   *
   * @param title the title of the corresponding merchant inventory, displayed
   * when the merchant inventory is viewed
   * @return a new merchant
   * @deprecated in favour of {@link #createMerchant(net.kyori.adventure.text.Component)}
  */
  static createMerchant(title: string | null): Merchant;
  /**
   * Gets user-specified limit for number of monsters that can spawn in a
   * chunk.
   *
   * @return the monster spawn limit
   * @deprecated Deprecated in favor of {@link #getSpawnLimit(SpawnCategory)}
  */
  static getMonsterSpawnLimit(): number;
  /**
   * Gets user-specified limit for number of animals that can spawn in a
   * chunk.
   *
   * @return the animal spawn limit
   * @deprecated Deprecated in favor of {@link #getSpawnLimit(SpawnCategory)}
  */
  static getAnimalSpawnLimit(): number;
  /**
   * Gets user-specified limit for number of water animals that can spawn in
   * a chunk.
   *
   * @return the water animal spawn limit
   * @deprecated Deprecated in favor of {@link #getSpawnLimit(SpawnCategory)}
  */
  static getWaterAnimalSpawnLimit(): number;
  /**
   * Gets user-specified limit for number of water ambient mobs that can spawn
   * in a chunk.
   *
   * @return the water ambient spawn limit
   * @deprecated Deprecated in favor of {@link #getSpawnLimit(SpawnCategory)}
  */
  static getWaterAmbientSpawnLimit(): number;
  /**
   * Get user-specified limit for number of water creature underground that can spawn
   * in a chunk.
   *
   * @return the water underground creature limit
   * @deprecated Deprecated in favor of {@link #getSpawnLimit(SpawnCategory)}
  */
  static getWaterUndergroundCreatureSpawnLimit(): number;
  /**
   * Gets user-specified limit for number of ambient mobs that can spawn in
   * a chunk.
   *
   * @return the ambient spawn limit
   * @deprecated Deprecated in favor of {@link #getSpawnLimit(SpawnCategory)}
  */
  static getAmbientSpawnLimit(): number;
  /**
   * Gets user-specified limit for number of {@link SpawnCategory} mobs that can spawn in
   * a chunk.
   *
   * Note: the {@link SpawnCategory#MISC} are not consider.
   *
   * @param spawnCategory the category spawn
   * @return the {@link SpawnCategory} spawn limit
  */
  static getSpawnLimit(spawnCategory: SpawnCategory): number;
  /**
   * Checks the current thread against the expected primary thread for the
   * server.
   * 
   * Note: this method should not be used to indicate the current
   * synchronized state of the runtime. A current thread matching the main
   * thread indicates that it is synchronized, but a mismatch does not
   * preclude the same assumption.
   *
   * @return true if the current thread matches the expected primary thread,
   *     false otherwise
  */
  static isPrimaryThread(): boolean;
  /**
   * Gets the message that is displayed on the server list.
   *
   * @return the server's MOTD
  */
  static motd(): Component;
  /**
   * Gets the default message that is displayed when the server is stopped.
   *
   * @return the shutdown message
  */
  static shutdownMessage(): Component | null;
  /**
   * Gets the current warning state for the server.
   *
   * @return the configured warning state
  */
  static getWarningState(): WarningState;
  /**
   * Gets the instance of the item factory (for {@link ItemMeta}).
   *
   * @return the item factory
   * @see ItemFactory
  */
  static getItemFactory(): ItemFactory;
  /**
   * Gets the instance of the scoreboard manager.
   * 
   * This will only exist after the first world has loaded.
   *
   * @return the scoreboard manager or null if no worlds are loaded.
  */
  static getScoreboardManager(): ScoreboardManager;
  /**
   * Gets an instance of the server's default server-icon.
   *
   * @return the default server-icon; null values may be used by the
   *     implementation to indicate no defined icon, but this behavior is
   *     not guaranteed
  */
  static getServerIcon(): CachedServerIcon | null;
  /**
   * Loads an image from a file, and returns a cached image for the specific
   * server-icon.
   * 
   * Size and type are implementation defined. An incompatible file is
   * guaranteed to throw an implementation-defined {@link Exception}.
   *
   * @param file the file to load the from
   * @return a cached server-icon that can be used for a {@link
   *     ServerListPingEvent#setServerIcon(CachedServerIcon)}
   * @throws IllegalArgumentException if image is null
   * @throws Exception if the image does not meet current server server-icon
   *     specifications
  */
  static loadServerIcon(file: File): CachedServerIcon;
  /**
   * Creates a cached server-icon for the specific image.
   * 
   * Size and type are implementation defined. An incompatible file is
   * guaranteed to throw an implementation-defined {@link Exception}.
   *
   * @param image the image to use
   * @return a cached server-icon that can be used for a {@link
   *     ServerListPingEvent#setServerIcon(CachedServerIcon)}
   * @throws IllegalArgumentException if image is null
   * @throws Exception if the image does not meet current server
   *     server-icon specifications
  */
  static loadServerIcon(image: BufferedImage): CachedServerIcon;
  /**
   * Set the idle kick timeout. Any players idle for the specified amount of
   * time will be automatically kicked.
   * 
   * A value of 0 will disable the idle kick timeout.
   *
   * @param threshold the idle timeout in minutes
  */
  static setIdleTimeout(idleTimeout: number);
  /**
   * Gets the idle kick timeout.
   *
   * @return the idle timeout in minutes
  */
  static getIdleTimeout(): number;
  /**
   * Create a ChunkData for use in a generator.
   *
   * See {@link ChunkGenerator#generateChunkData(org.bukkit.World, java.util.Random, int, int, org.bukkit.generator.ChunkGenerator.BiomeGrid)}
   *
   * @param world the world to create the ChunkData for
   * @return a new ChunkData for the world
   *
  */
  static createChunkData(world: World): ChunkData;
  /**
   * Create a ChunkData for use in a generator, that is populated by the vanilla generator for that world
   *
   * @param world the world to create the ChunkData for
   * @param x the x coordinate of the chunk
   * @param z the z coordinate of the chunk
   * @return a new ChunkData for the world
   * @deprecated The new multi-stage worldgen API allows a similar effect by overriding all of the "shouldGenerate..." methods to
   * return true, and then modifying the chunkdata in a later stage such as surface or bedrock generation.
  */
  static createVanillaChunkData(world: World, x: number, z: number): ChunkData;
  /**
   * Creates a boss bar instance to display to players. The progress
   * defaults to 1.0
   *
   * @param title the title of the boss bar
   * @param color the color of the boss bar
   * @param style the style of the boss bar
   * @param flags an optional list of flags to set on the boss bar
   * @return the created boss bar
  */
  static createBossBar(title: string | null, color: BarColor, style: BarStyle, ...flags: BarFlag[]): BossBar;
  /**
   * Creates a boss bar instance to display to players. The progress defaults
   * to 1.0.
   * 
   * This instance is added to the persistent storage of the server and will
   * be editable by commands and restored after restart.
   *
   * @param key the key of the boss bar that is used to access the boss bar
   * @param title the title of the boss bar
   * @param color the color of the boss bar
   * @param style the style of the boss bar
   * @param flags an optional list of flags to set on the boss bar
   * @return the created boss bar
  */
  static createBossBar(key: NamespacedKey, title: string | null, color: BarColor, style: BarStyle, ...flags: BarFlag[]): KeyedBossBar;
  /**
   * Gets an unmodifiable iterator through all persistent bossbars.
   * 
   *   not bound to a {@link org.bukkit.entity.Boss}
   *   
   *     not created using
   *     {@link #createBossBar(String, BarColor, BarStyle, BarFlag...)}
   *   
   * 
   *
   * e.g. bossbars created using the bossbar command
   *
   * @return a bossbar iterator
  */
  static getBossBars(): Iterator<KeyedBossBar>;
  /**
   * Gets the {@link KeyedBossBar} specified by this key.
   * 
   *   not bound to a {@link org.bukkit.entity.Boss}
   *   
   *     not created using
   *     {@link #createBossBar(String, BarColor, BarStyle, BarFlag...)}
   *   
   * 
   *
   * e.g. bossbars created using the bossbar command
   *
   * @param key unique bossbar key
   * @return bossbar or null if not exists
  */
  static getBossBar(key: NamespacedKey): KeyedBossBar | null;
  /**
   * Removes a {@link KeyedBossBar} specified by this key.
   * 
   *   not bound to a {@link org.bukkit.entity.Boss}
   *   
   *     not created using
   *     {@link #createBossBar(String, BarColor, BarStyle, BarFlag...)}
   *   
   * 
   *
   * e.g. bossbars created using the bossbar command
   *
   * @param key unique bossbar key
   * @return true if removal succeeded or false
  */
  static removeBossBar(key: NamespacedKey): boolean;
  /**
   * Gets an entity on the server by its UUID
   *
   * @param uuid the UUID of the entity
   * @return the entity with the given UUID, or null if it isn't found
  */
  static getEntity(uuid: UUID): Entity | null;
  /**
   * Gets the current server TPS
   * @return current server TPS (1m, 5m, 15m in Paper-Server)
  */
  static getTPS(): number[];
  /**
   * Get a sample of the servers last tick times (in nanos)
   *
   * @return A sample of the servers last tick times (in nanos)
  */
  static getTickTimes(): number[];
  /**
   * Get the average tick time (in millis)
   *
   * @return Average tick time (in millis)
  */
  static getAverageTickTime(): number;
  /**
   * Get the advancement specified by this key.
   *
   * @param key unique advancement key
   * @return advancement or null if not exists
  */
  static getAdvancement(key: NamespacedKey): Advancement | null;
  /**
   * Get an iterator through all advancements. Advancements cannot be removed
   * from this iterator,
   *
   * @return an advancement iterator
  */
  static advancementIterator(): Iterator<Advancement>;
  /**
   * Creates a new {@link BlockData} instance for the specified Material, with
   * all properties initialized to unspecified defaults.
   *
   * @param material the material
   * @return new data instance
  */
  static createBlockData(material: Material): BlockData;
  /**
   * Creates a new {@link BlockData} instance for the specified Material, with
   * all properties initialized to unspecified defaults.
   *
   * @param material the material
   * @param consumer consumer to run on new instance before returning
   * @return new data instance
  */
  static createBlockData(material: Material, consumer: Consumer<BlockData> | null): BlockData;
  /**
   * Creates a new {@link BlockData} instance with material and properties
   * parsed from provided data.
   *
   * @param data data string
   * @return new data instance
   * @throws IllegalArgumentException if the specified data is not valid
  */
  static createBlockData(data: string): BlockData;
  /**
   * Creates a new {@link BlockData} instance for the specified Material, with
   * all properties initialized to unspecified defaults, except for those
   * provided in data.
   *
   * @param material the material
   * @param data data string
   * @return new data instance
   * @throws IllegalArgumentException if the specified data is not valid
  */
  static createBlockData(material: Material | null, data: string | null): BlockData;
  /**
   * Gets a tag which has already been defined within the server. Plugins are
   * suggested to use the concrete tags in {@link Tag} rather than this method
   * which makes no guarantees about which tags are available, and may also be
   * less performant due to lack of caching.
   * 
   * Tags will be searched for in an implementation specific manner, but a
   * path consisting of namespace/tags/registry/key is expected.
   * 
   * Server implementations are allowed to handle only the registries
   * indicated in {@link Tag}.
   *
   * @param  type of the tag
   * @param registry the tag registry to look at
   * @param tag the name of the tag
   * @param clazz the class of the tag entries
   * @return the tag or null
  */
  static getTag<T>(registry: string, tag: NamespacedKey, clazz: Class<T>): Tag<T> | null;
  /**
   * Gets a all tags which have been defined within the server.
   * 
   * Server implementations are allowed to handle only the registries
   * indicated in {@link Tag}.
   * 
   * No guarantees are made about the mutability of the returned iterator.
   *
   * @param  type of the tag
   * @param registry the tag registry to look at
   * @param clazz the class of the tag entries
   * @return all defined tags
  */
  static getTags<T>(registry: string, clazz: Class<T>): Iterable<Tag<T>>;
  /**
   * Gets the specified {@link LootTable}.
   *
   * @param key the name of the LootTable
   * @return the LootTable, or null if no LootTable is found with that name
  */
  static getLootTable(key: NamespacedKey): LootTable | null;
  /**
   * Selects entities using the given Vanilla selector.
   * 
   * No guarantees are made about the selector format, other than they match
   * the Vanilla format for the active Minecraft version.
   * 
   * Usually a selector will start with '@', unless selecting a Player in
   * which case it may simply be the Player's name or UUID.
   * 
   * Note that in Vanilla, elevated permissions are usually required to use
   * '@' selectors, but this method should not check such permissions from the
   * sender.
   *
   * @param sender the sender to execute as, must be provided
   * @param selector the selection string
   * @return a list of the selected entities. The list will not be null, but
   * no further guarantees are made.
   * @throws IllegalArgumentException if the selector is malformed in any way
   * or a parameter is null
  */
  static selectEntities(sender: CommandSender, selector: string): Entity[];
  /**
   * Gets the structure manager for loading and saving structures.
   *
   * @return the structure manager
  */
  static getStructureManager(): StructureManager;
  /**
   * @return the unsafe values instance
   * @see UnsafeValues
  */
  static getUnsafe(): UnsafeValues;
  /**
   * Gets the active {@link org.bukkit.command.CommandMap}
   *
   * @return the active command map
  */
  static getCommandMap(): CommandMap;
  /**
   * Reload the Permissions in permissions.yml
  */
  static reloadPermissions(): void;
  /**
   * Reload the Command Aliases in commands.yml
   *
   * @return Whether the reload was successful
  */
  static reloadCommandAliases(): boolean;
  /**
   * Checks if player names should be suggested when a command returns `null` as
   * their tab completion result.
   *
   * @return true if player names should be suggested
  */
  static suggestPlayerNamesWhenNullTabCompletions(): boolean;
  /**
   *
   * @return the default no permission message used on the server
  */
  static getPermissionMessage(): string;
  /**
   * Creates a PlayerProfile for the specified uuid, with name as null.
   *
   * If a player with the passed uuid exists on the server at the time of creation, the returned player profile will
   * be populated with the properties of said player (including their uuid and name).
   *
   * @param uuid UUID to create profile for
   * @return A PlayerProfile object
  */
  static createProfile(uuid: UUID): com_destroystokyo_paper_profile_PlayerProfile;
  /**
   * Creates a PlayerProfile for the specified name, with UUID as null.
   *
   * If a player with the passed name exists on the server at the time of creation, the returned player profile will
   * be populated with the properties of said player (including their uuid and name).
   * 
   * E.g. if the player 'jeb_' is currently playing on the server, calling `createProfile("JEB_")` will
   * yield a profile with the name 'jeb_', their uuid and their textures.
   * To bypass this pre-population on a case-insensitive name match, see {@link #createProfileExact(UUID, String)}.
   * 
   *
   * @param name Name to create profile for
   * @return A PlayerProfile object
  */
  static createProfile(name: string): com_destroystokyo_paper_profile_PlayerProfile;
  /**
   * Creates a PlayerProfile for the specified name/uuid
   *
   * Both UUID and Name can not be null at same time. One must be supplied.
   * If a player with the passed uuid or name exists on the server at the time of creation, the returned player
   * profile will be populated with the properties of said player (including their uuid and name).
   * 
   * E.g. if the player 'jeb_' is currently playing on the server, calling `createProfile(null, "JEB_")` will
   * yield a profile with the name 'jeb_', their uuid and their textures.
   * To bypass this pre-population on an case-insensitive name match, see {@link #createProfileExact(UUID, String)}.
   * 
   *
   * The name comparison will compare the {@link String#toLowerCase()} version of both the passed name parameter and
   * a players name to honour the case-insensitive nature of a mojang profile lookup.
   *
   * @param uuid UUID to create profile for
   * @param name Name to create profile for
   * @return A PlayerProfile object
  */
  static createProfile(uuid: UUID | null, name: string | null): com_destroystokyo_paper_profile_PlayerProfile;
  /**
   * Creates an exact PlayerProfile for the specified name/uuid
   *
   * Both UUID and Name can not be null at same time. One must be supplied.
   * If a player with the passed uuid or name exists on the server at the time of creation, the returned player
   * profile will be populated with the properties of said player.
   * 
   * Compared to {@link #createProfile(UUID, String)}, this method will never mutate the passed uuid or name.
   * If a player with either the same uuid or a matching name (case-insensitive) is found on the server, their
   * properties, such as textures, will be pre-populated in the profile, however the passed uuid and name stay intact.
   *
   * @param uuid UUID to create profile for
   * @param name Name to create profile for
   * @return A PlayerProfile object
  */
  static createProfileExact(uuid: UUID | null, name: string | null): com_destroystokyo_paper_profile_PlayerProfile;
  static getCurrentTick(): number;
  /**
   * Checks if the server is in the process of being shutdown.
   *
   * @return true if server is in the process of being shutdown
  */
  static isStopping(): boolean;
  /**
   * Returns the {@link com.destroystokyo.paper.entity.ai.MobGoals} manager
   *
   * @return the mob goals manager
  */
  static getMobGoals(): MobGoals;
  /**
   * @return the datapack manager
  */
  static getDatapackManager(): DatapackManager;
  /**
   * Gets the potion brewer.
   *
   * @return the potion brewer
  */
  static getPotionBrewer(): PotionBrewer;
  static spigot(): Spigot;
}
/**
 * A list of effects that the server is able to send to players.
*/
export class Effect extends Enum<Effect> {
  /**
   * An alternate click sound.
  */
  static readonly CLICK2: Effect;
  /**
   * A click sound.
  */
  static readonly CLICK1: Effect;
  /**
   * Sound of a bow firing.
  */
  static readonly BOW_FIRE: Effect;
  /**
   * Sound of a door opening.
  */
  static readonly DOOR_TOGGLE: Effect;
  /**
   * Sound of a door opening.
  */
  static readonly IRON_DOOR_TOGGLE: Effect;
  /**
   * Sound of a trapdoor opening.
  */
  static readonly TRAPDOOR_TOGGLE: Effect;
  /**
   * Sound of a door opening.
  */
  static readonly IRON_TRAPDOOR_TOGGLE: Effect;
  /**
   * Sound of a door opening.
  */
  static readonly FENCE_GATE_TOGGLE: Effect;
  /**
   * Sound of a door closing.
  */
  static readonly DOOR_CLOSE: Effect;
  /**
   * Sound of a door closing.
  */
  static readonly IRON_DOOR_CLOSE: Effect;
  /**
   * Sound of a trapdoor closing.
  */
  static readonly TRAPDOOR_CLOSE: Effect;
  /**
   * Sound of a door closing.
  */
  static readonly IRON_TRAPDOOR_CLOSE: Effect;
  /**
   * Sound of a door closing.
  */
  static readonly FENCE_GATE_CLOSE: Effect;
  /**
   * Sound of fire being extinguished.
  */
  static readonly EXTINGUISH: Effect;
  /**
   * A song from a record. Needs the record item ID as additional info
  */
  static readonly RECORD_PLAY: Effect;
  /**
   * Sound of ghast shrieking.
  */
  static readonly GHAST_SHRIEK: Effect;
  /**
   * Sound of ghast firing.
  */
  static readonly GHAST_SHOOT: Effect;
  /**
   * Sound of blaze firing.
  */
  static readonly BLAZE_SHOOT: Effect;
  /**
   * Sound of zombies chewing on wooden doors.
  */
  static readonly ZOMBIE_CHEW_WOODEN_DOOR: Effect;
  /**
   * Sound of zombies chewing on iron doors.
  */
  static readonly ZOMBIE_CHEW_IRON_DOOR: Effect;
  /**
   * Sound of zombies destroying a door.
  */
  static readonly ZOMBIE_DESTROY_DOOR: Effect;
  /**
   * A visual smoke effect. Needs direction as additional info.
  */
  static readonly SMOKE: Effect;
  /**
   * Sound of a block breaking. Needs block ID as additional info.
  */
  static readonly STEP_SOUND: Effect;
  /**
   * Visual effect of a splash potion breaking. Needs potion data value as
   * additional info.
  */
  static readonly POTION_BREAK: Effect;
  /**
   * Visual effect of an instant splash potion breaking. Needs color data
   * value as additional info.
  */
  static readonly INSTANT_POTION_BREAK: Effect;
  /**
   * An ender eye signal; a visual effect.
  */
  static readonly ENDER_SIGNAL: Effect;
  /**
   * The flames seen on a mobspawner; a visual effect.
  */
  static readonly MOBSPAWNER_FLAMES: Effect;
  /**
   * The sound played by brewing stands when brewing
  */
  static readonly BREWING_STAND_BREW: Effect;
  /**
   * The sound played when a chorus flower grows
  */
  static readonly CHORUS_FLOWER_GROW: Effect;
  /**
   * The sound played when a chorus flower dies
  */
  static readonly CHORUS_FLOWER_DEATH: Effect;
  /**
   * The sound played when traveling through a portal
  */
  static readonly PORTAL_TRAVEL: Effect;
  /**
   * The sound played when launching an endereye
  */
  static readonly ENDEREYE_LAUNCH: Effect;
  /**
   * The sound played when launching a firework
  */
  static readonly FIREWORK_SHOOT: Effect;
  /**
   * Particles displayed when a villager grows a plant, data
   * is the number of particles
  */
  static readonly VILLAGER_PLANT_GROW: Effect;
  /**
   * The sound/particles used by the enderdragon's breath
   * attack.
  */
  static readonly DRAGON_BREATH: Effect;
  /**
   * The sound played when an anvil breaks
  */
  static readonly ANVIL_BREAK: Effect;
  /**
   * The sound played when an anvil is used
  */
  static readonly ANVIL_USE: Effect;
  /**
   * The sound played when an anvil lands after
   * falling
  */
  static readonly ANVIL_LAND: Effect;
  /**
   * Sound of an enderdragon firing
  */
  static readonly ENDERDRAGON_SHOOT: Effect;
  /**
   * The sound played when a wither breaks a block
  */
  static readonly WITHER_BREAK_BLOCK: Effect;
  /**
   * Sound of a wither shooting
  */
  static readonly WITHER_SHOOT: Effect;
  /**
   * The sound played when a zombie infects a target
  */
  static readonly ZOMBIE_INFECT: Effect;
  /**
   * The sound played when a villager is converted by
   * a zombie
  */
  static readonly ZOMBIE_CONVERTED_VILLAGER: Effect;
  /**
   * Sound played by a bat taking off
  */
  static readonly BAT_TAKEOFF: Effect;
  /**
   * The sound/particles caused by a end gateway spawning
  */
  static readonly END_GATEWAY_SPAWN: Effect;
  /**
   * The sound of an enderdragon growling
  */
  static readonly ENDERDRAGON_GROWL: Effect;
  /**
   * The sound played when phantom bites.
  */
  static readonly PHANTOM_BITE: Effect;
  /**
   * The sound played when a zombie converts to a drowned.
  */
  static readonly ZOMBIE_CONVERTED_TO_DROWNED: Effect;
  /**
   * The sound played when a husk converts to a zombie.
  */
  static readonly HUSK_CONVERTED_TO_ZOMBIE: Effect;
  /**
   * The sound played when a grindstone is being used.
  */
  static readonly GRINDSTONE_USE: Effect;
  /**
   * The sound played when a book page is being turned.
  */
  static readonly BOOK_PAGE_TURN: Effect;
  /**
   * The sound played when a smithing table is being used.
  */
  static readonly SMITHING_TABLE_USE: Effect;
  /**
   * The sound played when a pointed dripstone hits the surface.
  */
  static readonly POINTED_DRIPSTONE_LAND: Effect;
  /**
   * The sound played when a pointed driptone drips lava into a cauldron.
  */
  static readonly POINTED_DRIPSTONE_DRIP_LAVA_INTO_CAULDRON: Effect;
  /**
   * The sound played when a pointed driptone drips water into a cauldron.
  */
  static readonly POINTED_DRIPSTONE_DRIP_WATER_INTO_CAULDRON: Effect;
  /**
   * The sound played when a skeleton converts to a stray.
  */
  static readonly SKELETON_CONVERTED_TO_STRAY: Effect;
  /**
   * The sound played / particles shown when a composter is being attempted to
   * fill.
   *
   * True for a successful attempt false for an unsuccessful attempt.
  */
  static readonly COMPOSTER_FILL_ATTEMPT: Effect;
  /**
   * The sound played / particles shown when lava interacts with the world.
   *
   * For example by forming stone, obsidian, basalt or destroying blocks such
   * as torches.
  */
  static readonly LAVA_INTERACT: Effect;
  /**
   * The sound played / particles shown when a redstone torch burns out.
  */
  static readonly REDSTONE_TORCH_BURNOUT: Effect;
  /**
   * The sound played / particles shown when an eye of ender is placed into an
   * ender portal frame.
  */
  static readonly END_PORTAL_FRAME_FILL: Effect;
  /**
   * The particles shown when a dripstone drips lava or water.
   *
   * This effect requires a driptone at the location as well as lava or water
   * at the root of the dripstone.
  */
  static readonly DRIPPING_DRIPSTONE: Effect;
  /**
   * The sound played / particles shown when bone meal is used to grow a
   * plant.
   *
   * Data is the number of particles.
  */
  static readonly BONE_MEAL_USE: Effect;
  /**
   * The particles shown when an ender dragon destroys blocks.
  */
  static readonly ENDER_DRAGON_DESTROY_BLOCK: Effect;
  /**
   * The particles shown when a sponge drys in an ultra warm world (nether).
  */
  static readonly SPONGE_DRY: Effect;
  /**
   * The particles shown when a lightning hits a lightning rod or oxidised
   * copper.
   *
   * Data is the axis at which the particle should be shown. If no data is
   * provided it will show the particles at the block faces.
  */
  static readonly ELECTRIC_SPARK: Effect;
  /**
   * The sound played / particles shown when wax is applied to a copper block.
  */
  static readonly COPPER_WAX_ON: Effect;
  /**
   * The particles shown when wax is removed from a copper block.
  */
  static readonly COPPER_WAX_OFF: Effect;
  /**
   * The particles shown when oxidisation is scraped of an oxidised copper
   * block.
  */
  static readonly OXIDISED_COPPER_SCRAPE: Effect;
  /**
   * The sound of a wither spawning
  */
  static readonly WITHER_SPAWNED: Effect;
  /**
   * The sound of an ender dragon dying
  */
  static readonly ENDER_DRAGON_DEATH: Effect;
  /**
   * The sound of an ender portal being created in the overworld
  */
  static readonly END_PORTAL_CREATED_IN_OVERWORLD: Effect;
  /**
   * The sound of phantom's bites
   *
   * @deprecated use {@link #PHANTOM_BITE}
  */
  static readonly PHANTOM_BITES: Effect;
  /**
   * The sound of zombie converting to drowned zombie
   *
   * @deprecated use {@link #ZOMBIE_CONVERTED_TO_DROWNED}
  */
  static readonly ZOMBIE_CONVERTS_TO_DROWNED: Effect;
  /**
   * The sound of a husk converting to zombie by drowning
   *
   * @deprecated use {@link #HUSK_CONVERTED_TO_ZOMBIE}
  */
  static readonly HUSK_CONVERTS_TO_ZOMBIE: Effect;
  /**
   * The sound of a grindstone being used
   *
   * @deprecated use {@link #GRINDSTONE_USE}
  */
  static readonly GRINDSTONE_USED: Effect;
  /**
   * The sound of a book page being turned
   *
   * @deprecated use {@link #BOOK_PAGE_TURN}
  */
  static readonly BOOK_PAGE_TURNED: Effect;
  /**
   * Particles displayed when a composter composts
   *
   * @deprecated use {@link #COMPOSTER_FILL_ATTEMPT}
  */
  static readonly COMPOSTER_COMPOSTS: Effect;
  /**
   * Particles displayed when lava converts a block (either water to stone, or
   * removing existing blocks such as torches)
   *
   * @deprecated use {@link #LAVA_INTERACT}
  */
  static readonly LAVA_CONVERTS_BLOCK: Effect;
  /**
   * Particles displayd when a redstone torch burns out
   *
   * @deprecated use {@link #REDSTONE_TORCH_BURNOUT}
  */
  static readonly REDSTONE_TORCH_BURNS_OUT: Effect;
  /**
   * Particles displayed when an ender eye is placed
   *
   * @deprecated use {@link #END_PORTAL_FRAME_FILL}
  */
  static readonly ENDER_EYE_PLACED: Effect;
  /**
   * Particles displayed when an ender dragon destroys block
   *
   * @deprecated use {@link #ENDER_DRAGON_DESTROY_BLOCK}
  */
  static readonly ENDER_DRAGON_DESTROYS_BLOCK: Effect;
  /**
   * Particles displayed when a wet sponge vaporizes in nether.
   *
   * @deprecated use {@link #SPONGE_DRY}
  */
  static readonly WET_SPONGE_VAPORIZES_IN_NETHER: Effect;
  static valueOf(name: string): Effect;
  static values(): Effect[];
  /**
   * Gets the ID for this effect.
   *
   * @return ID of this effect
   * @deprecated Magic value
  */
  getId(): number;
  /**
   * @return The type of the effect.
  */
  getType(): org_bukkit_Effect_Type;
  /**
   * @return The class which represents data for this effect, or null if
   *     none
  */
  getData(): Class<any> | null;
  /**
   * Gets the Effect associated with the given ID.
   *
   * @param id ID of the Effect to return
   * @return Effect with the given ID
   * @deprecated Magic value
  */
  static getById(id: number): Effect | null;
}
/**
 * An Enum of categories for sounds.
*/
export class SoundCategory extends Enum<SoundCategory> {
  static readonly MASTER: SoundCategory;
  static readonly MUSIC: SoundCategory;
  static readonly RECORDS: SoundCategory;
  static readonly WEATHER: SoundCategory;
  static readonly BLOCKS: SoundCategory;
  static readonly HOSTILE: SoundCategory;
  static readonly NEUTRAL: SoundCategory;
  static readonly PLAYERS: SoundCategory;
  static readonly AMBIENT: SoundCategory;
  static readonly VOICE: SoundCategory;
  static valueOf(name: string): SoundCategory;
  static values(): SoundCategory[];
  soundSource(): Source;
}
/**
 * This annotation indicates a method (and sometimes constructor) will chain
 * its internal operations.
 * 
 * This is solely meant for identifying methods that don't need to be
 * overridden / handled manually.
*/
export class Utility {

}
/**
 * An enum to specify a rotation based orientation, like that on a clock.
 * 
 * It represents how something is viewed, as opposed to cardinal directions.
*/
export class Rotation extends Enum<Rotation> {
  /**
   * No rotation
  */
  static readonly NONE: Rotation;
  /**
   * Rotated clockwise by 45 degrees
  */
  static readonly CLOCKWISE_45: Rotation;
  /**
   * Rotated clockwise by 90 degrees
  */
  static readonly CLOCKWISE: Rotation;
  /**
   * Rotated clockwise by 135 degrees
  */
  static readonly CLOCKWISE_135: Rotation;
  /**
   * Flipped upside-down, a 180 degree rotation
  */
  static readonly FLIPPED: Rotation;
  /**
   * Flipped upside-down + 45 degree rotation
  */
  static readonly FLIPPED_45: Rotation;
  /**
   * Rotated counter-clockwise by 90 degrees
  */
  static readonly COUNTER_CLOCKWISE: Rotation;
  /**
   * Rotated counter-clockwise by 45 degrees
  */
  static readonly COUNTER_CLOCKWISE_45: Rotation;
  static valueOf(name: string): Rotation;
  static values(): Rotation[];
  /**
   * Rotate clockwise by 90 degrees.
   *
   * @return the relative rotation
  */
  rotateClockwise(): Rotation;
  /**
   * Rotate counter-clockwise by 90 degrees.
   *
   * @return the relative rotation
  */
  rotateCounterClockwise(): Rotation;
}
/**
 * Represents the various type of game modes that {@link HumanEntity}s may
 * have
*/
export class GameMode extends Enum<GameMode> {
  /**
   * Creative mode may fly, build instantly, become invulnerable and create
   * free items.
  */
  static readonly CREATIVE: GameMode;
  /**
   * Survival mode is the "normal" gameplay type, with no special features.
  */
  static readonly SURVIVAL: GameMode;
  /**
   * Adventure mode cannot break blocks without the correct tools.
  */
  static readonly ADVENTURE: GameMode;
  /**
   * Spectator mode cannot interact with the world in anyway and is
   * invisible to normal players. This grants the player the
   * ability to no-clip through the world.
  */
  static readonly SPECTATOR: GameMode;
  static valueOf(name: string): GameMode;
  static values(): GameMode[];
  translationKey(): string;
  /**
   * Gets the mode value associated with this GameMode
   *
   * @return An integer value of this gamemode
   * @deprecated Magic value
  */
  getValue(): number;
  /**
   * Gets the GameMode represented by the specified value
   *
   * @param value Value to check
   * @return Associative {@link GameMode} with the given value, or null if
   *     it doesn't exist
   * @deprecated Magic value
  */
  static getByValue(value: number): GameMode | null;
}
/**
 * A container for a color palette. This class is immutable; the set methods
 * return a new color. The color names listed as fields are HTML4 standards,
 * but subject to change.
*/
export class Color extends ConfigurationSerializable {
  /**
   * White, or (0xFF,0xFF,0xFF) in (R,G,B)
  */
  static readonly WHITE: Color;
  /**
   * Silver, or (0xC0,0xC0,0xC0) in (R,G,B)
  */
  static readonly SILVER: Color;
  /**
   * Gray, or (0x80,0x80,0x80) in (R,G,B)
  */
  static readonly GRAY: Color;
  /**
   * Black, or (0x00,0x00,0x00) in (R,G,B)
  */
  static readonly BLACK: Color;
  /**
   * Red, or (0xFF,0x00,0x00) in (R,G,B)
  */
  static readonly RED: Color;
  /**
   * Maroon, or (0x80,0x00,0x00) in (R,G,B)
  */
  static readonly MAROON: Color;
  /**
   * Yellow, or (0xFF,0xFF,0x00) in (R,G,B)
  */
  static readonly YELLOW: Color;
  /**
   * Olive, or (0x80,0x80,0x00) in (R,G,B)
  */
  static readonly OLIVE: Color;
  /**
   * Lime, or (0x00,0xFF,0x00) in (R,G,B)
  */
  static readonly LIME: Color;
  /**
   * Green, or (0x00,0x80,0x00) in (R,G,B)
  */
  static readonly GREEN: Color;
  /**
   * Aqua, or (0x00,0xFF,0xFF) in (R,G,B)
  */
  static readonly AQUA: Color;
  /**
   * Teal, or (0x00,0x80,0x80) in (R,G,B)
  */
  static readonly TEAL: Color;
  /**
   * Blue, or (0x00,0x00,0xFF) in (R,G,B)
  */
  static readonly BLUE: Color;
  /**
   * Navy, or (0x00,0x00,0x80) in (R,G,B)
  */
  static readonly NAVY: Color;
  /**
   * Fuchsia, or (0xFF,0x00,0xFF) in (R,G,B)
  */
  static readonly FUCHSIA: Color;
  /**
   * Purple, or (0x80,0x00,0x80) in (R,G,B)
  */
  static readonly PURPLE: Color;
  /**
   * Orange, or (0xFF,0xA5,0x00) in (R,G,B)
  */
  static readonly ORANGE: Color;
  /**
   * Creates a new Color object from a red, green, and blue
   *
   * @param red integer from 0-255
   * @param green integer from 0-255
   * @param blue integer from 0-255
   * @return a new Color object for the red, green, blue
   * @throws IllegalArgumentException if any value is strictly {@literal >255 or <0}
  */
  static fromRGB(red: number, green: number, blue: number): Color;
  /**
   * Creates a new Color object from a blue, green, and red
   *
   * @param blue integer from 0-255
   * @param green integer from 0-255
   * @param red integer from 0-255
   * @return a new Color object for the red, green, blue
   * @throws IllegalArgumentException if any value is strictly {@literal >255 or <0}
  */
  static fromBGR(blue: number, green: number, red: number): Color;
  /**
   * Creates a new color object from an integer that contains the red,
   * green, and blue bytes in the lowest order 24 bits.
   *
   * @param rgb the integer storing the red, green, and blue values
   * @return a new color object for specified values
   * @throws IllegalArgumentException if any data is in the highest order 8
   *     bits
  */
  static fromRGB(rgb: number): Color;
  /**
   * Creates a new color object from an integer that contains the blue,
   * green, and red bytes in the lowest order 24 bits.
   *
   * @param bgr the integer storing the blue, green, and red values
   * @return a new color object for specified values
   * @throws IllegalArgumentException if any data is in the highest order 8
   *     bits
  */
  static fromBGR(bgr: number): Color;
  /**
   * Gets the red component
   *
   * @return red component, from 0 to 255
  */
  getRed(): number;
  /**
   * Creates a new Color object with specified component
   *
   * @param red the red component, from 0 to 255
   * @return a new color object with the red component
  */
  setRed(red: number);
  /**
   * Gets the green component
   *
   * @return green component, from 0 to 255
  */
  getGreen(): number;
  /**
   * Creates a new Color object with specified component
   *
   * @param green the red component, from 0 to 255
   * @return a new color object with the red component
  */
  setGreen(green: number);
  /**
   * Gets the blue component
   *
   * @return blue component, from 0 to 255
  */
  getBlue(): number;
  /**
   * Creates a new Color object with specified component
   *
   * @param blue the red component, from 0 to 255
   * @return a new color object with the red component
  */
  setBlue(blue: number);
  /**
   * Gets the color as an RGB integer.
   *
   * @return An integer representation of this color, as 0xRRGGBB
  */
  asRGB(): number;
  /**
   * Gets the color as an BGR integer.
   *
   * @return An integer representation of this color, as 0xBBGGRR
  */
  asBGR(): number;
  mixDyes(...colors: DyeColor[]): Color;
  mixColors(...colors: Color[]): Color;
  equals(o: any): boolean;
  hashCode(): number;
  /**
   * Creates a Map representation of this class.
   * 
   * This class must provide a method to restore this class, as defined in
   * the {@link ConfigurationSerializable} interface javadocs.
   *
   * @return Map containing the current state of this class
  */
  serialize(): Map<string, any>;
  static deserialize(map: Map<string, any>): Color;
  toString(): string;
}
/**
 * Represents a mutually perpendicular axis in 3D Cartesian coordinates. In
 * Minecraft the x, z axes lie in the horizontal plane, whilst the y axis points
 * upwards.
*/
export class Axis extends Enum<Axis> {
  /**
   * The x axis.
  */
  static readonly X: Axis;
  /**
   * The y axis.
  */
  static readonly Y: Axis;
  /**
   * The z axis.
  */
  static readonly Z: Axis;
  static valueOf(name: string): Axis;
  static values(): Axis[];
}
/**
 * A RegionAccessor gives access to getting, modifying and spawning {@link Biome}, {@link BlockState} and {@link Entity},
 * as well as generating some basic structures.
*/
export class RegionAccessor extends Keyed {
  /**
   * Gets the {@link Biome} at the given {@link Location}.
   *
   * @param location the location of the biome
   * @return Biome at the given location
   * @see #getComputedBiome(int, int, int)
  */
  getBiome(location: Location): Biome;
  /**
   * Gets the {@link Biome} at the given coordinates.
   *
   * @param x X-coordinate of the block
   * @param y Y-coordinate of the block
   * @param z Z-coordinate of the block
   * @return Biome at the given coordinates
   * @see #getComputedBiome(int, int, int)
  */
  getBiome(x: number, y: number, z: number): Biome;
  /**
   * Gets the computed {@link Biome} at the given coordinates.
   *
   * The computed Biome is the Biome as seen by clients for rendering
   * purposes and in the "F3" debug menu. This is computed by looking at the noise biome
   * at this and surrounding quarts and applying complex math operations.
   *
   * Most other Biome-related methods named getBiome, setBiome, and similar
   * operate on the "noise biome", which is stored per-quart, or in other words,
   * 1 Biome per 4x4x4 block region. This is how Biomes are currently generated and
   * stored on disk.
   *
   * @param x X-coordinate of the block
   * @param y Y-coordinate of the block
   * @param z Z-coordinate of the block
   * @return Biome at the given coordinates
  */
  getComputedBiome(x: number, y: number, z: number): Biome;
  /**
   * Sets the {@link Biome} at the given {@link Location}.
   *
   * @param location the location of the biome
   * @param biome New Biome type for this block
  */
  setBiome(location: Location, biome: Biome): void;
  /**
   * Sets the {@link Biome} for the given block coordinates
   *
   * @param x X-coordinate of the block
   * @param y Y-coordinate of the block
   * @param z Z-coordinate of the block
   * @param biome New Biome type for this block
  */
  setBiome(x: number, y: number, z: number, biome: Biome): void;
  /**
   * Gets the {@link BlockState} at the given {@link Location}.
   *
   * @param location The location of the block state
   * @return Block state at the given location
  */
  getBlockState(location: Location): BlockState;
  /**
   * Gets the {@link BlockState} at the given coordinates.
   *
   * @param x X-coordinate of the block state
   * @param y Y-coordinate of the block state
   * @param z Z-coordinate of the block state
   * @return Block state at the given coordinates
  */
  getBlockState(x: number, y: number, z: number): BlockState;
  /**
   * Gets the {@link BlockData} at the given {@link Location}.
   *
   * @param location The location of the block data
   * @return Block data at the given location
  */
  getBlockData(location: Location): BlockData;
  /**
   * Gets the {@link BlockData} at the given coordinates.
   *
   * @param x X-coordinate of the block data
   * @param y Y-coordinate of the block data
   * @param z Z-coordinate of the block data
   * @return Block data at the given coordinates
  */
  getBlockData(x: number, y: number, z: number): BlockData;
  /**
   * Gets the type of the block at the given {@link Location}.
   *
   * @param location The location of the block
   * @return Material at the given coordinates
  */
  getType(location: Location): Material;
  /**
   * Gets the type of the block at the given coordinates.
   *
   * @param x X-coordinate of the block
   * @param y Y-coordinate of the block
   * @param z Z-coordinate of the block
   * @return Material at the given coordinates
  */
  getType(x: number, y: number, z: number): Material;
  /**
   * Sets the {@link BlockData} at the given {@link Location}.
   *
   * @param location The location of the block
   * @param blockData The block data to set the block to
  */
  setBlockData(location: Location, blockData: BlockData): void;
  /**
   * Sets the {@link BlockData} at the given coordinates.
   *
   * @param x X-coordinate of the block
   * @param y Y-coordinate of the block
   * @param z Z-coordinate of the block
   * @param blockData The block data to set the block to
  */
  setBlockData(x: number, y: number, z: number, blockData: BlockData): void;
  /**
   * Sets the {@link Material} at the given {@link Location}.
   *
   * @param location The location of the block
   * @param material The type to set the block to
  */
  setType(location: Location, material: Material): void;
  /**
   * Sets the {@link Material} at the given coordinates.
   *
   * @param x X-coordinate of the block
   * @param y Y-coordinate of the block
   * @param z Z-coordinate of the block
   * @param material The type to set the block to
  */
  setType(x: number, y: number, z: number, material: Material): void;
  /**
   * Creates a tree at the given {@link Location}
   *
   * @param location Location to spawn the tree
   * @param random Random to use to generated the tree
   * @param type Type of the tree to create
   * @return true if the tree was created successfully, otherwise false
  */
  generateTree(location: Location, random: Random, type: TreeType): boolean;
  /**
   * Creates a tree at the given {@link Location}
   * 
   * The provided consumer gets called for every block which gets changed
   * as a result of the tree generation. When the consumer gets called no
   * modifications to the world are done yet. Which means, that calling
   * {@link #getBlockState(Location)} in the consumer while return the state
   * of the block before the generation.
   * 
   * Modifications done to the {@link BlockState} in the consumer are respected,
   * which means that it is not necessary to call {@link BlockState#update()}
   *
   * @param location Location to spawn the tree
   * @param random Random to use to generated the tree
   * @param type Type of the tree to create
   * @param stateConsumer The consumer which should get called for every block which gets changed
   * @return true if the tree was created successfully, otherwise false
  */
  generateTree(location: Location, random: Random, type: TreeType, stateConsumer: org_bukkit_util_Consumer<BlockState> | null): boolean;
  /**
   * Creates a tree at the given {@link Location}
   * 
   * The provided predicate gets called for every block which gets changed
   * as a result of the tree generation. When the predicate gets called no
   * modifications to the world are done yet. Which means, that calling
   * {@link #getBlockState(Location)} in the predicate will return the state
   * of the block before the generation.
   * 
   * If the predicate returns `true` the block gets set in the world.
   * If it returns `false` the block won't get set in the world.
   *
   * @param location Location to spawn the tree
   * @param random Random to use to generated the tree
   * @param type Type of the tree to create
   * @param statePredicate The predicate which should get used to test if a block should be set or not.
   * @return true if the tree was created successfully, otherwise false
  */
  generateTree(location: Location, random: Random, type: TreeType, statePredicate: Predicate<BlockState> | null): boolean;
  /**
   * Creates a entity at the given {@link Location}
   *
   * @param location The location to spawn the entity
   * @param type The entity to spawn
   * @return Resulting Entity of this method
  */
  spawnEntity(location: Location, type: EntityType): Entity;
  /**
   * Creates a new entity at the given {@link Location}.
   *
   * @param loc the location at which the entity will be spawned.
   * @param type the entity type that determines the entity to spawn.
   * @param randomizeData whether or not the entity's data should be randomised
   *                      before spawning. By default entities are randomised
   *                      before spawning in regards to their equipment, age,
   *                      attributes, etc.
   *                      An example of this randomization would be the color of
   *                      a sheep, random enchantments on the equipment of mobs
   *                      or even a zombie becoming a chicken jockey.
   *                      If set to false, the entity will not be randomised
   *                      before spawning, meaning all their data will remain
   *                      in their default state and not further modifications
   *                      to the entity will be made.
   *                      Notably only entities that extend the
   *                      {@link org.bukkit.entity.Mob} interface provide
   *                      randomisation logic for their spawn.
   *                      This parameter is hence useless for any other type
   *                      of entity.
   * @return the spawned entity instance.
  */
  spawnEntity(loc: Location, type: EntityType, randomizeData: boolean): Entity;
  /**
   * Get a list of all entities in this RegionAccessor
   *
   * @return A List of all Entities currently residing in this world accessor
  */
  getEntities(): Entity[];
  /**
   * Get a list of all living entities in this RegionAccessor
   *
   * @return A List of all LivingEntities currently residing in this world accessor
  */
  getLivingEntities(): LivingEntity[];
  /**
   * Get a collection of all entities in this RegionAccessor matching the given
   * class/interface
   *
   * @param  an entity subclass
   * @param cls The class representing the type of entity to match
   * @return A List of all Entities currently residing in this world accessor
   *     that match the given class/interface
  */
  getEntitiesByClass<T>(cls: Class<T>): Collection<T>;
  /**
   * Get a collection of all entities in this RegionAccessor matching any of the
   * given classes/interfaces
   *
   * @param classes The classes representing the types of entity to match
   * @return A List of all Entities currently residing in this world accessor
   *     that match one or more of the given classes/interfaces
  */
  getEntitiesByClasses(...classes: Class[]): Collection<Entity>;
  /**
   * Spawn an entity of a specific class at the given {@link Location}
   *
   * @param location the {@link Location} to spawn the entity at
   * @param clazz the class of the {@link Entity} to spawn
   * @param  the class of the {@link Entity} to spawn
   * @return an instance of the spawned {@link Entity}
   * @throws IllegalArgumentException if either parameter is null or the
   *     {@link Entity} requested cannot be spawned
  */
  spawn<T>(location: Location, clazz: Class<T>): T;
  /**
   * Spawn an entity of a specific class at the given {@link Location}, with
   * the supplied function run before the entity is added to the world.
   * 
   * Note that when the function is run, the entity will not be actually in
   * the world. Any operation involving such as teleporting the entity is undefined
   * until after this function returns.
   *
   * @param location the {@link Location} to spawn the entity at
   * @param clazz the class of the {@link Entity} to spawn
   * @param function the function to be run before the entity is spawned.
   * @param  the class of the {@link Entity} to spawn
   * @return an instance of the spawned {@link Entity}
   * @throws IllegalArgumentException if either parameter is null or the
   *     {@link Entity} requested cannot be spawned
  */
  spawn<T>(location: Location, clazz: Class<T>, func: org_bukkit_util_Consumer<T> | null): T;
  spawn<T>(location: Location, clazz: Class<T>, reason: SpawnReason): T;
  spawn<T>(location: Location, clazz: Class<T>, reason: SpawnReason, func: org_bukkit_util_Consumer<T> | null): T;
  spawnEntity(loc: Location, type: EntityType, reason: SpawnReason): Entity;
  spawnEntity(loc: Location, type: EntityType, reason: SpawnReason, func: org_bukkit_util_Consumer<Entity> | null): Entity;
  spawn<T>(location: Location, clazz: Class<T>, func: org_bukkit_util_Consumer<T> | null, reason: SpawnReason): T;
  /**
   * Creates a new entity at the given {@link Location} with the supplied
   * function run before the entity is added to the world.
   * 
   * Note that when the function is run, the entity will not be actually in
   * the world. Any operation involving such as teleporting the entity is undefined
   * until after this function returns.
   * The passed function however is run after the potential entity's spawn
   * randomization and hence already allows access to the values of the mob,
   * whether or not those were randomized, such as attributes or the entity
   * equipment.
   *
   * @param location      the location at which the entity will be spawned.
   * @param clazz         the class of the {@link Entity} that is to be spawned.
   * @param            the generic type of the entity that is being created.
   * @param randomizeData whether or not the entity's data should be randomised
   *                      before spawning. By default entities are randomised
   *                      before spawning in regards to their equipment, age,
   *                      attributes, etc.
   *                      An example of this randomization would be the color of
   *                      a sheep, random enchantments on the equipment of mobs
   *                      or even a zombie becoming a chicken jockey.
   *                      If set to false, the entity will not be randomised
   *                      before spawning, meaning all their data will remain
   *                      in their default state and not further modifications
   *                      to the entity will be made.
   *                      Notably only entities that extend the
   *                      {@link org.bukkit.entity.Mob} interface provide
   *                      randomisation logic for their spawn.
   *                      This parameter is hence useless for any other type
   *                      of entity.
   * @param function      the function to be run before the entity is spawned.
   * @return the spawned entity instance.
   * @throws IllegalArgumentException if either the world or clazz parameter are null.
  */
  spawn<T>(location: Location, clazz: Class<T>, randomizeData: boolean, func: org_bukkit_util_Consumer<T> | null): T;
  /**
   * @return the current moon phase at the current time in the world
  */
  getMoonPhase(): MoonPhase;
  /**
   * Get the world's key
   *
   * @return the world's key
  */
  getKey(): NamespacedKey;
  /**
   * Tell whether a line of sight exists between the given locations
   * @param from Location to start at
   * @param to target Location
   * @return whether a line of sight exists between `from` and `to`
  */
  lineOfSightExists(from: Location, to: Location): boolean;
}
/**
 * All supported color values for dyes and cloth
*/
export class DyeColor extends Enum<DyeColor> {
  /**
   * Represents white dye.
  */
  static readonly WHITE: DyeColor;
  /**
   * Represents orange dye.
  */
  static readonly ORANGE: DyeColor;
  /**
   * Represents magenta dye.
  */
  static readonly MAGENTA: DyeColor;
  /**
   * Represents light blue dye.
  */
  static readonly LIGHT_BLUE: DyeColor;
  /**
   * Represents yellow dye.
  */
  static readonly YELLOW: DyeColor;
  /**
   * Represents lime dye.
  */
  static readonly LIME: DyeColor;
  /**
   * Represents pink dye.
  */
  static readonly PINK: DyeColor;
  /**
   * Represents gray dye.
  */
  static readonly GRAY: DyeColor;
  /**
   * Represents light gray dye.
  */
  static readonly LIGHT_GRAY: DyeColor;
  /**
   * Represents cyan dye.
  */
  static readonly CYAN: DyeColor;
  /**
   * Represents purple dye.
  */
  static readonly PURPLE: DyeColor;
  /**
   * Represents blue dye.
  */
  static readonly BLUE: DyeColor;
  /**
   * Represents brown dye.
  */
  static readonly BROWN: DyeColor;
  /**
   * Represents green dye.
  */
  static readonly GREEN: DyeColor;
  /**
   * Represents red dye.
  */
  static readonly RED: DyeColor;
  /**
   * Represents black dye.
  */
  static readonly BLACK: DyeColor;
  static valueOf(name: string): DyeColor;
  static values(): DyeColor[];
  /**
   * Gets the associated wool data value representing this color.
   *
   * @return A byte containing the wool data value of this color
   * @see #getDyeData()
   * @deprecated Magic value
  */
  getWoolData(): number;
  /**
   * Gets the associated dye data value representing this color.
   *
   * @return A byte containing the dye data value of this color
   * @see #getWoolData()
   * @deprecated Magic value
  */
  getDyeData(): number;
  /**
   * Gets the color that this dye represents.
   *
   * @return The {@link Color} that this dye represents
  */
  getColor(): Color;
  /**
   * Gets the firework color that this dye represents.
   *
   * @return The {@link Color} that this dye represents
  */
  getFireworkColor(): Color;
  /**
   * Gets the DyeColor with the given wool data value.
   *
   * @param data Wool data value to fetch
   * @return The {@link DyeColor} representing the given value, or null if
   *     it doesn't exist
   * @see #getByDyeData(byte)
   * @deprecated Magic value
  */
  static getByWoolData(data: number): DyeColor | null;
  /**
   * Gets the DyeColor with the given dye data value.
   *
   * @param data Dye data value to fetch
   * @return The {@link DyeColor} representing the given value, or null if
   *     it doesn't exist
   * @see #getByWoolData(byte)
   * @deprecated Magic value
  */
  static getByDyeData(data: number): DyeColor | null;
  /**
   * Gets the DyeColor with the given color value.
   *
   * @param color Color value to get the dye by
   * @return The {@link DyeColor} representing the given value, or null if
   *     it doesn't exist
  */
  static getByColor(color: Color): DyeColor | null;
  /**
   * Gets the DyeColor with the given firework color value.
   *
   * @param color Color value to get dye by
   * @return The {@link DyeColor} representing the given value, or null if
   *     it doesn't exist
  */
  static getByFireworkColor(color: Color): DyeColor | null;
  /**
   * Gets the DyeColor for the given name, possibly doing legacy transformations.
   *
   * @param name dye name
   * @return dye color
   * @deprecated legacy use only
  */
  static legacyValueOf(name: string | null): DyeColor;
}
/**
 * @deprecated use {@link org.bukkit.block.data.BlockData} and {@link org.bukkit.block.data.Ageable}
*/
export class NetherWartsState extends Enum<NetherWartsState> {
  /**
   * State when first seeded
  */
  static readonly SEEDED: NetherWartsState;
  /**
   * First growth stage
  */
  static readonly STAGE_ONE: NetherWartsState;
  /**
   * Second growth stage
  */
  static readonly STAGE_TWO: NetherWartsState;
  /**
   * Ready to harvest
  */
  static readonly RIPE: NetherWartsState;
  static valueOf(name: string): NetherWartsState;
  static values(): NetherWartsState[];
}
/**
 * Represents the art on a painting
*/
export class Art extends Enum<Art> {
  static readonly KEBAB: Art;
  static readonly AZTEC: Art;
  static readonly ALBAN: Art;
  static readonly AZTEC2: Art;
  static readonly BOMB: Art;
  static readonly PLANT: Art;
  static readonly WASTELAND: Art;
  static readonly POOL: Art;
  static readonly COURBET: Art;
  static readonly SEA: Art;
  static readonly SUNSET: Art;
  static readonly CREEBET: Art;
  static readonly WANDERER: Art;
  static readonly GRAHAM: Art;
  static readonly MATCH: Art;
  static readonly BUST: Art;
  static readonly STAGE: Art;
  static readonly VOID: Art;
  static readonly SKULL_AND_ROSES: Art;
  static readonly WITHER: Art;
  static readonly FIGHTERS: Art;
  static readonly POINTER: Art;
  static readonly PIGSCENE: Art;
  static readonly BURNING_SKULL: Art;
  static readonly SKELETON: Art;
  static readonly DONKEY_KONG: Art;
  static valueOf(name: string): Art;
  static values(): Art[];
  /**
   * Gets the width of the painting, in blocks
   *
   * @return The width of the painting, in blocks
  */
  getBlockWidth(): number;
  /**
   * Gets the height of the painting, in blocks
   *
   * @return The height of the painting, in blocks
  */
  getBlockHeight(): number;
  /**
   * Get the ID of this painting.
   *
   * @return The ID of this painting
   * @deprecated Magic value
  */
  getId(): number;
  getKey(): NamespacedKey;
  /**
   * Get a painting by its numeric ID
   *
   * @param id The ID
   * @return The painting
   * @deprecated Magic value
  */
  static getById(id: number): Art | null;
  /**
   * Get a painting by its unique name
   * 
   * This ignores underscores and capitalization
   *
   * @param name The name
   * @return The painting
  */
  static getByName(name: string): Art | null;
}
/**
 * An Enum of Sounds the server is able to send to players.
 * 
 * WARNING: At any time, sounds may be added/removed from this Enum or even
 * MineCraft itself! There is no guarantee the sounds will play. There is no
 * guarantee values will not be removed from this Enum. As such, you should not
 * depend on the ordinal values of this class.
*/
export class Sound extends Enum<Sound> {
  static readonly AMBIENT_BASALT_DELTAS_ADDITIONS: Sound;
  static readonly AMBIENT_BASALT_DELTAS_LOOP: Sound;
  static readonly AMBIENT_BASALT_DELTAS_MOOD: Sound;
  static readonly AMBIENT_CAVE: Sound;
  static readonly AMBIENT_CRIMSON_FOREST_ADDITIONS: Sound;
  static readonly AMBIENT_CRIMSON_FOREST_LOOP: Sound;
  static readonly AMBIENT_CRIMSON_FOREST_MOOD: Sound;
  static readonly AMBIENT_NETHER_WASTES_ADDITIONS: Sound;
  static readonly AMBIENT_NETHER_WASTES_LOOP: Sound;
  static readonly AMBIENT_NETHER_WASTES_MOOD: Sound;
  static readonly AMBIENT_SOUL_SAND_VALLEY_ADDITIONS: Sound;
  static readonly AMBIENT_SOUL_SAND_VALLEY_LOOP: Sound;
  static readonly AMBIENT_SOUL_SAND_VALLEY_MOOD: Sound;
  static readonly AMBIENT_UNDERWATER_ENTER: Sound;
  static readonly AMBIENT_UNDERWATER_EXIT: Sound;
  static readonly AMBIENT_UNDERWATER_LOOP: Sound;
  static readonly AMBIENT_UNDERWATER_LOOP_ADDITIONS: Sound;
  static readonly AMBIENT_UNDERWATER_LOOP_ADDITIONS_RARE: Sound;
  static readonly AMBIENT_UNDERWATER_LOOP_ADDITIONS_ULTRA_RARE: Sound;
  static readonly AMBIENT_WARPED_FOREST_ADDITIONS: Sound;
  static readonly AMBIENT_WARPED_FOREST_LOOP: Sound;
  static readonly AMBIENT_WARPED_FOREST_MOOD: Sound;
  static readonly BLOCK_AMETHYST_BLOCK_BREAK: Sound;
  static readonly BLOCK_AMETHYST_BLOCK_CHIME: Sound;
  static readonly BLOCK_AMETHYST_BLOCK_FALL: Sound;
  static readonly BLOCK_AMETHYST_BLOCK_HIT: Sound;
  static readonly BLOCK_AMETHYST_BLOCK_PLACE: Sound;
  static readonly BLOCK_AMETHYST_BLOCK_STEP: Sound;
  static readonly BLOCK_AMETHYST_CLUSTER_BREAK: Sound;
  static readonly BLOCK_AMETHYST_CLUSTER_FALL: Sound;
  static readonly BLOCK_AMETHYST_CLUSTER_HIT: Sound;
  static readonly BLOCK_AMETHYST_CLUSTER_PLACE: Sound;
  static readonly BLOCK_AMETHYST_CLUSTER_STEP: Sound;
  static readonly BLOCK_ANCIENT_DEBRIS_BREAK: Sound;
  static readonly BLOCK_ANCIENT_DEBRIS_FALL: Sound;
  static readonly BLOCK_ANCIENT_DEBRIS_HIT: Sound;
  static readonly BLOCK_ANCIENT_DEBRIS_PLACE: Sound;
  static readonly BLOCK_ANCIENT_DEBRIS_STEP: Sound;
  static readonly BLOCK_ANVIL_BREAK: Sound;
  static readonly BLOCK_ANVIL_DESTROY: Sound;
  static readonly BLOCK_ANVIL_FALL: Sound;
  static readonly BLOCK_ANVIL_HIT: Sound;
  static readonly BLOCK_ANVIL_LAND: Sound;
  static readonly BLOCK_ANVIL_PLACE: Sound;
  static readonly BLOCK_ANVIL_STEP: Sound;
  static readonly BLOCK_ANVIL_USE: Sound;
  static readonly BLOCK_AZALEA_BREAK: Sound;
  static readonly BLOCK_AZALEA_FALL: Sound;
  static readonly BLOCK_AZALEA_HIT: Sound;
  static readonly BLOCK_AZALEA_LEAVES_BREAK: Sound;
  static readonly BLOCK_AZALEA_LEAVES_FALL: Sound;
  static readonly BLOCK_AZALEA_LEAVES_HIT: Sound;
  static readonly BLOCK_AZALEA_LEAVES_PLACE: Sound;
  static readonly BLOCK_AZALEA_LEAVES_STEP: Sound;
  static readonly BLOCK_AZALEA_PLACE: Sound;
  static readonly BLOCK_AZALEA_STEP: Sound;
  static readonly BLOCK_BAMBOO_BREAK: Sound;
  static readonly BLOCK_BAMBOO_FALL: Sound;
  static readonly BLOCK_BAMBOO_HIT: Sound;
  static readonly BLOCK_BAMBOO_PLACE: Sound;
  static readonly BLOCK_BAMBOO_SAPLING_BREAK: Sound;
  static readonly BLOCK_BAMBOO_SAPLING_HIT: Sound;
  static readonly BLOCK_BAMBOO_SAPLING_PLACE: Sound;
  static readonly BLOCK_BAMBOO_STEP: Sound;
  static readonly BLOCK_BARREL_CLOSE: Sound;
  static readonly BLOCK_BARREL_OPEN: Sound;
  static readonly BLOCK_BASALT_BREAK: Sound;
  static readonly BLOCK_BASALT_FALL: Sound;
  static readonly BLOCK_BASALT_HIT: Sound;
  static readonly BLOCK_BASALT_PLACE: Sound;
  static readonly BLOCK_BASALT_STEP: Sound;
  static readonly BLOCK_BEACON_ACTIVATE: Sound;
  static readonly BLOCK_BEACON_AMBIENT: Sound;
  static readonly BLOCK_BEACON_DEACTIVATE: Sound;
  static readonly BLOCK_BEACON_POWER_SELECT: Sound;
  static readonly BLOCK_BEEHIVE_DRIP: Sound;
  static readonly BLOCK_BEEHIVE_ENTER: Sound;
  static readonly BLOCK_BEEHIVE_EXIT: Sound;
  static readonly BLOCK_BEEHIVE_SHEAR: Sound;
  static readonly BLOCK_BEEHIVE_WORK: Sound;
  static readonly BLOCK_BELL_RESONATE: Sound;
  static readonly BLOCK_BELL_USE: Sound;
  static readonly BLOCK_BIG_DRIPLEAF_BREAK: Sound;
  static readonly BLOCK_BIG_DRIPLEAF_FALL: Sound;
  static readonly BLOCK_BIG_DRIPLEAF_HIT: Sound;
  static readonly BLOCK_BIG_DRIPLEAF_PLACE: Sound;
  static readonly BLOCK_BIG_DRIPLEAF_STEP: Sound;
  static readonly BLOCK_BIG_DRIPLEAF_TILT_DOWN: Sound;
  static readonly BLOCK_BIG_DRIPLEAF_TILT_UP: Sound;
  static readonly BLOCK_BLASTFURNACE_FIRE_CRACKLE: Sound;
  static readonly BLOCK_BONE_BLOCK_BREAK: Sound;
  static readonly BLOCK_BONE_BLOCK_FALL: Sound;
  static readonly BLOCK_BONE_BLOCK_HIT: Sound;
  static readonly BLOCK_BONE_BLOCK_PLACE: Sound;
  static readonly BLOCK_BONE_BLOCK_STEP: Sound;
  static readonly BLOCK_BREWING_STAND_BREW: Sound;
  static readonly BLOCK_BUBBLE_COLUMN_BUBBLE_POP: Sound;
  static readonly BLOCK_BUBBLE_COLUMN_UPWARDS_AMBIENT: Sound;
  static readonly BLOCK_BUBBLE_COLUMN_UPWARDS_INSIDE: Sound;
  static readonly BLOCK_BUBBLE_COLUMN_WHIRLPOOL_AMBIENT: Sound;
  static readonly BLOCK_BUBBLE_COLUMN_WHIRLPOOL_INSIDE: Sound;
  static readonly BLOCK_CAKE_ADD_CANDLE: Sound;
  static readonly BLOCK_CALCITE_BREAK: Sound;
  static readonly BLOCK_CALCITE_FALL: Sound;
  static readonly BLOCK_CALCITE_HIT: Sound;
  static readonly BLOCK_CALCITE_PLACE: Sound;
  static readonly BLOCK_CALCITE_STEP: Sound;
  static readonly BLOCK_CAMPFIRE_CRACKLE: Sound;
  static readonly BLOCK_CANDLE_AMBIENT: Sound;
  static readonly BLOCK_CANDLE_BREAK: Sound;
  static readonly BLOCK_CANDLE_EXTINGUISH: Sound;
  static readonly BLOCK_CANDLE_FALL: Sound;
  static readonly BLOCK_CANDLE_HIT: Sound;
  static readonly BLOCK_CANDLE_PLACE: Sound;
  static readonly BLOCK_CANDLE_STEP: Sound;
  static readonly BLOCK_CAVE_VINES_BREAK: Sound;
  static readonly BLOCK_CAVE_VINES_FALL: Sound;
  static readonly BLOCK_CAVE_VINES_HIT: Sound;
  static readonly BLOCK_CAVE_VINES_PICK_BERRIES: Sound;
  static readonly BLOCK_CAVE_VINES_PLACE: Sound;
  static readonly BLOCK_CAVE_VINES_STEP: Sound;
  static readonly BLOCK_CHAIN_BREAK: Sound;
  static readonly BLOCK_CHAIN_FALL: Sound;
  static readonly BLOCK_CHAIN_HIT: Sound;
  static readonly BLOCK_CHAIN_PLACE: Sound;
  static readonly BLOCK_CHAIN_STEP: Sound;
  static readonly BLOCK_CHEST_CLOSE: Sound;
  static readonly BLOCK_CHEST_LOCKED: Sound;
  static readonly BLOCK_CHEST_OPEN: Sound;
  static readonly BLOCK_CHORUS_FLOWER_DEATH: Sound;
  static readonly BLOCK_CHORUS_FLOWER_GROW: Sound;
  static readonly BLOCK_COMPARATOR_CLICK: Sound;
  static readonly BLOCK_COMPOSTER_EMPTY: Sound;
  static readonly BLOCK_COMPOSTER_FILL: Sound;
  static readonly BLOCK_COMPOSTER_FILL_SUCCESS: Sound;
  static readonly BLOCK_COMPOSTER_READY: Sound;
  static readonly BLOCK_CONDUIT_ACTIVATE: Sound;
  static readonly BLOCK_CONDUIT_AMBIENT: Sound;
  static readonly BLOCK_CONDUIT_AMBIENT_SHORT: Sound;
  static readonly BLOCK_CONDUIT_ATTACK_TARGET: Sound;
  static readonly BLOCK_CONDUIT_DEACTIVATE: Sound;
  static readonly BLOCK_COPPER_BREAK: Sound;
  static readonly BLOCK_COPPER_FALL: Sound;
  static readonly BLOCK_COPPER_HIT: Sound;
  static readonly BLOCK_COPPER_PLACE: Sound;
  static readonly BLOCK_COPPER_STEP: Sound;
  static readonly BLOCK_CORAL_BLOCK_BREAK: Sound;
  static readonly BLOCK_CORAL_BLOCK_FALL: Sound;
  static readonly BLOCK_CORAL_BLOCK_HIT: Sound;
  static readonly BLOCK_CORAL_BLOCK_PLACE: Sound;
  static readonly BLOCK_CORAL_BLOCK_STEP: Sound;
  static readonly BLOCK_CROP_BREAK: Sound;
  static readonly BLOCK_DEEPSLATE_BREAK: Sound;
  static readonly BLOCK_DEEPSLATE_BRICKS_BREAK: Sound;
  static readonly BLOCK_DEEPSLATE_BRICKS_FALL: Sound;
  static readonly BLOCK_DEEPSLATE_BRICKS_HIT: Sound;
  static readonly BLOCK_DEEPSLATE_BRICKS_PLACE: Sound;
  static readonly BLOCK_DEEPSLATE_BRICKS_STEP: Sound;
  static readonly BLOCK_DEEPSLATE_FALL: Sound;
  static readonly BLOCK_DEEPSLATE_HIT: Sound;
  static readonly BLOCK_DEEPSLATE_PLACE: Sound;
  static readonly BLOCK_DEEPSLATE_STEP: Sound;
  static readonly BLOCK_DEEPSLATE_TILES_BREAK: Sound;
  static readonly BLOCK_DEEPSLATE_TILES_FALL: Sound;
  static readonly BLOCK_DEEPSLATE_TILES_HIT: Sound;
  static readonly BLOCK_DEEPSLATE_TILES_PLACE: Sound;
  static readonly BLOCK_DEEPSLATE_TILES_STEP: Sound;
  static readonly BLOCK_DISPENSER_DISPENSE: Sound;
  static readonly BLOCK_DISPENSER_FAIL: Sound;
  static readonly BLOCK_DISPENSER_LAUNCH: Sound;
  static readonly BLOCK_DRIPSTONE_BLOCK_BREAK: Sound;
  static readonly BLOCK_DRIPSTONE_BLOCK_FALL: Sound;
  static readonly BLOCK_DRIPSTONE_BLOCK_HIT: Sound;
  static readonly BLOCK_DRIPSTONE_BLOCK_PLACE: Sound;
  static readonly BLOCK_DRIPSTONE_BLOCK_STEP: Sound;
  static readonly BLOCK_ENCHANTMENT_TABLE_USE: Sound;
  static readonly BLOCK_ENDER_CHEST_CLOSE: Sound;
  static readonly BLOCK_ENDER_CHEST_OPEN: Sound;
  static readonly BLOCK_END_GATEWAY_SPAWN: Sound;
  static readonly BLOCK_END_PORTAL_FRAME_FILL: Sound;
  static readonly BLOCK_END_PORTAL_SPAWN: Sound;
  static readonly BLOCK_FENCE_GATE_CLOSE: Sound;
  static readonly BLOCK_FENCE_GATE_OPEN: Sound;
  static readonly BLOCK_FIRE_AMBIENT: Sound;
  static readonly BLOCK_FIRE_EXTINGUISH: Sound;
  static readonly BLOCK_FLOWERING_AZALEA_BREAK: Sound;
  static readonly BLOCK_FLOWERING_AZALEA_FALL: Sound;
  static readonly BLOCK_FLOWERING_AZALEA_HIT: Sound;
  static readonly BLOCK_FLOWERING_AZALEA_PLACE: Sound;
  static readonly BLOCK_FLOWERING_AZALEA_STEP: Sound;
  static readonly BLOCK_FUNGUS_BREAK: Sound;
  static readonly BLOCK_FUNGUS_FALL: Sound;
  static readonly BLOCK_FUNGUS_HIT: Sound;
  static readonly BLOCK_FUNGUS_PLACE: Sound;
  static readonly BLOCK_FUNGUS_STEP: Sound;
  static readonly BLOCK_FURNACE_FIRE_CRACKLE: Sound;
  static readonly BLOCK_GILDED_BLACKSTONE_BREAK: Sound;
  static readonly BLOCK_GILDED_BLACKSTONE_FALL: Sound;
  static readonly BLOCK_GILDED_BLACKSTONE_HIT: Sound;
  static readonly BLOCK_GILDED_BLACKSTONE_PLACE: Sound;
  static readonly BLOCK_GILDED_BLACKSTONE_STEP: Sound;
  static readonly BLOCK_GLASS_BREAK: Sound;
  static readonly BLOCK_GLASS_FALL: Sound;
  static readonly BLOCK_GLASS_HIT: Sound;
  static readonly BLOCK_GLASS_PLACE: Sound;
  static readonly BLOCK_GLASS_STEP: Sound;
  static readonly BLOCK_GRASS_BREAK: Sound;
  static readonly BLOCK_GRASS_FALL: Sound;
  static readonly BLOCK_GRASS_HIT: Sound;
  static readonly BLOCK_GRASS_PLACE: Sound;
  static readonly BLOCK_GRASS_STEP: Sound;
  static readonly BLOCK_GRAVEL_BREAK: Sound;
  static readonly BLOCK_GRAVEL_FALL: Sound;
  static readonly BLOCK_GRAVEL_HIT: Sound;
  static readonly BLOCK_GRAVEL_PLACE: Sound;
  static readonly BLOCK_GRAVEL_STEP: Sound;
  static readonly BLOCK_GRINDSTONE_USE: Sound;
  static readonly BLOCK_GROWING_PLANT_CROP: Sound;
  static readonly BLOCK_HANGING_ROOTS_BREAK: Sound;
  static readonly BLOCK_HANGING_ROOTS_FALL: Sound;
  static readonly BLOCK_HANGING_ROOTS_HIT: Sound;
  static readonly BLOCK_HANGING_ROOTS_PLACE: Sound;
  static readonly BLOCK_HANGING_ROOTS_STEP: Sound;
  static readonly BLOCK_HONEY_BLOCK_BREAK: Sound;
  static readonly BLOCK_HONEY_BLOCK_FALL: Sound;
  static readonly BLOCK_HONEY_BLOCK_HIT: Sound;
  static readonly BLOCK_HONEY_BLOCK_PLACE: Sound;
  static readonly BLOCK_HONEY_BLOCK_SLIDE: Sound;
  static readonly BLOCK_HONEY_BLOCK_STEP: Sound;
  static readonly BLOCK_IRON_DOOR_CLOSE: Sound;
  static readonly BLOCK_IRON_DOOR_OPEN: Sound;
  static readonly BLOCK_IRON_TRAPDOOR_CLOSE: Sound;
  static readonly BLOCK_IRON_TRAPDOOR_OPEN: Sound;
  static readonly BLOCK_LADDER_BREAK: Sound;
  static readonly BLOCK_LADDER_FALL: Sound;
  static readonly BLOCK_LADDER_HIT: Sound;
  static readonly BLOCK_LADDER_PLACE: Sound;
  static readonly BLOCK_LADDER_STEP: Sound;
  static readonly BLOCK_LANTERN_BREAK: Sound;
  static readonly BLOCK_LANTERN_FALL: Sound;
  static readonly BLOCK_LANTERN_HIT: Sound;
  static readonly BLOCK_LANTERN_PLACE: Sound;
  static readonly BLOCK_LANTERN_STEP: Sound;
  static readonly BLOCK_LARGE_AMETHYST_BUD_BREAK: Sound;
  static readonly BLOCK_LARGE_AMETHYST_BUD_PLACE: Sound;
  static readonly BLOCK_LAVA_AMBIENT: Sound;
  static readonly BLOCK_LAVA_EXTINGUISH: Sound;
  static readonly BLOCK_LAVA_POP: Sound;
  static readonly BLOCK_LEVER_CLICK: Sound;
  static readonly BLOCK_LILY_PAD_PLACE: Sound;
  static readonly BLOCK_LODESTONE_BREAK: Sound;
  static readonly BLOCK_LODESTONE_FALL: Sound;
  static readonly BLOCK_LODESTONE_HIT: Sound;
  static readonly BLOCK_LODESTONE_PLACE: Sound;
  static readonly BLOCK_LODESTONE_STEP: Sound;
  static readonly BLOCK_MEDIUM_AMETHYST_BUD_BREAK: Sound;
  static readonly BLOCK_MEDIUM_AMETHYST_BUD_PLACE: Sound;
  static readonly BLOCK_METAL_BREAK: Sound;
  static readonly BLOCK_METAL_FALL: Sound;
  static readonly BLOCK_METAL_HIT: Sound;
  static readonly BLOCK_METAL_PLACE: Sound;
  static readonly BLOCK_METAL_PRESSURE_PLATE_CLICK_OFF: Sound;
  static readonly BLOCK_METAL_PRESSURE_PLATE_CLICK_ON: Sound;
  static readonly BLOCK_METAL_STEP: Sound;
  static readonly BLOCK_MOSS_BREAK: Sound;
  static readonly BLOCK_MOSS_CARPET_BREAK: Sound;
  static readonly BLOCK_MOSS_CARPET_FALL: Sound;
  static readonly BLOCK_MOSS_CARPET_HIT: Sound;
  static readonly BLOCK_MOSS_CARPET_PLACE: Sound;
  static readonly BLOCK_MOSS_CARPET_STEP: Sound;
  static readonly BLOCK_MOSS_FALL: Sound;
  static readonly BLOCK_MOSS_HIT: Sound;
  static readonly BLOCK_MOSS_PLACE: Sound;
  static readonly BLOCK_MOSS_STEP: Sound;
  static readonly BLOCK_NETHERITE_BLOCK_BREAK: Sound;
  static readonly BLOCK_NETHERITE_BLOCK_FALL: Sound;
  static readonly BLOCK_NETHERITE_BLOCK_HIT: Sound;
  static readonly BLOCK_NETHERITE_BLOCK_PLACE: Sound;
  static readonly BLOCK_NETHERITE_BLOCK_STEP: Sound;
  static readonly BLOCK_NETHERRACK_BREAK: Sound;
  static readonly BLOCK_NETHERRACK_FALL: Sound;
  static readonly BLOCK_NETHERRACK_HIT: Sound;
  static readonly BLOCK_NETHERRACK_PLACE: Sound;
  static readonly BLOCK_NETHERRACK_STEP: Sound;
  static readonly BLOCK_NETHER_BRICKS_BREAK: Sound;
  static readonly BLOCK_NETHER_BRICKS_FALL: Sound;
  static readonly BLOCK_NETHER_BRICKS_HIT: Sound;
  static readonly BLOCK_NETHER_BRICKS_PLACE: Sound;
  static readonly BLOCK_NETHER_BRICKS_STEP: Sound;
  static readonly BLOCK_NETHER_GOLD_ORE_BREAK: Sound;
  static readonly BLOCK_NETHER_GOLD_ORE_FALL: Sound;
  static readonly BLOCK_NETHER_GOLD_ORE_HIT: Sound;
  static readonly BLOCK_NETHER_GOLD_ORE_PLACE: Sound;
  static readonly BLOCK_NETHER_GOLD_ORE_STEP: Sound;
  static readonly BLOCK_NETHER_ORE_BREAK: Sound;
  static readonly BLOCK_NETHER_ORE_FALL: Sound;
  static readonly BLOCK_NETHER_ORE_HIT: Sound;
  static readonly BLOCK_NETHER_ORE_PLACE: Sound;
  static readonly BLOCK_NETHER_ORE_STEP: Sound;
  static readonly BLOCK_NETHER_SPROUTS_BREAK: Sound;
  static readonly BLOCK_NETHER_SPROUTS_FALL: Sound;
  static readonly BLOCK_NETHER_SPROUTS_HIT: Sound;
  static readonly BLOCK_NETHER_SPROUTS_PLACE: Sound;
  static readonly BLOCK_NETHER_SPROUTS_STEP: Sound;
  static readonly BLOCK_NETHER_WART_BREAK: Sound;
  static readonly BLOCK_NOTE_BLOCK_BANJO: Sound;
  static readonly BLOCK_NOTE_BLOCK_BASEDRUM: Sound;
  static readonly BLOCK_NOTE_BLOCK_BASS: Sound;
  static readonly BLOCK_NOTE_BLOCK_BELL: Sound;
  static readonly BLOCK_NOTE_BLOCK_BIT: Sound;
  static readonly BLOCK_NOTE_BLOCK_CHIME: Sound;
  static readonly BLOCK_NOTE_BLOCK_COW_BELL: Sound;
  static readonly BLOCK_NOTE_BLOCK_DIDGERIDOO: Sound;
  static readonly BLOCK_NOTE_BLOCK_FLUTE: Sound;
  static readonly BLOCK_NOTE_BLOCK_GUITAR: Sound;
  static readonly BLOCK_NOTE_BLOCK_HARP: Sound;
  static readonly BLOCK_NOTE_BLOCK_HAT: Sound;
  static readonly BLOCK_NOTE_BLOCK_IRON_XYLOPHONE: Sound;
  static readonly BLOCK_NOTE_BLOCK_PLING: Sound;
  static readonly BLOCK_NOTE_BLOCK_SNARE: Sound;
  static readonly BLOCK_NOTE_BLOCK_XYLOPHONE: Sound;
  static readonly BLOCK_NYLIUM_BREAK: Sound;
  static readonly BLOCK_NYLIUM_FALL: Sound;
  static readonly BLOCK_NYLIUM_HIT: Sound;
  static readonly BLOCK_NYLIUM_PLACE: Sound;
  static readonly BLOCK_NYLIUM_STEP: Sound;
  static readonly BLOCK_PISTON_CONTRACT: Sound;
  static readonly BLOCK_PISTON_EXTEND: Sound;
  static readonly BLOCK_POINTED_DRIPSTONE_BREAK: Sound;
  static readonly BLOCK_POINTED_DRIPSTONE_DRIP_LAVA: Sound;
  static readonly BLOCK_POINTED_DRIPSTONE_DRIP_LAVA_INTO_CAULDRON: Sound;
  static readonly BLOCK_POINTED_DRIPSTONE_DRIP_WATER: Sound;
  static readonly BLOCK_POINTED_DRIPSTONE_DRIP_WATER_INTO_CAULDRON: Sound;
  static readonly BLOCK_POINTED_DRIPSTONE_FALL: Sound;
  static readonly BLOCK_POINTED_DRIPSTONE_HIT: Sound;
  static readonly BLOCK_POINTED_DRIPSTONE_LAND: Sound;
  static readonly BLOCK_POINTED_DRIPSTONE_PLACE: Sound;
  static readonly BLOCK_POINTED_DRIPSTONE_STEP: Sound;
  static readonly BLOCK_POLISHED_DEEPSLATE_BREAK: Sound;
  static readonly BLOCK_POLISHED_DEEPSLATE_FALL: Sound;
  static readonly BLOCK_POLISHED_DEEPSLATE_HIT: Sound;
  static readonly BLOCK_POLISHED_DEEPSLATE_PLACE: Sound;
  static readonly BLOCK_POLISHED_DEEPSLATE_STEP: Sound;
  static readonly BLOCK_PORTAL_AMBIENT: Sound;
  static readonly BLOCK_PORTAL_TRAVEL: Sound;
  static readonly BLOCK_PORTAL_TRIGGER: Sound;
  static readonly BLOCK_POWDER_SNOW_BREAK: Sound;
  static readonly BLOCK_POWDER_SNOW_FALL: Sound;
  static readonly BLOCK_POWDER_SNOW_HIT: Sound;
  static readonly BLOCK_POWDER_SNOW_PLACE: Sound;
  static readonly BLOCK_POWDER_SNOW_STEP: Sound;
  static readonly BLOCK_PUMPKIN_CARVE: Sound;
  static readonly BLOCK_REDSTONE_TORCH_BURNOUT: Sound;
  static readonly BLOCK_RESPAWN_ANCHOR_AMBIENT: Sound;
  static readonly BLOCK_RESPAWN_ANCHOR_CHARGE: Sound;
  static readonly BLOCK_RESPAWN_ANCHOR_DEPLETE: Sound;
  static readonly BLOCK_RESPAWN_ANCHOR_SET_SPAWN: Sound;
  static readonly BLOCK_ROOTED_DIRT_BREAK: Sound;
  static readonly BLOCK_ROOTED_DIRT_FALL: Sound;
  static readonly BLOCK_ROOTED_DIRT_HIT: Sound;
  static readonly BLOCK_ROOTED_DIRT_PLACE: Sound;
  static readonly BLOCK_ROOTED_DIRT_STEP: Sound;
  static readonly BLOCK_ROOTS_BREAK: Sound;
  static readonly BLOCK_ROOTS_FALL: Sound;
  static readonly BLOCK_ROOTS_HIT: Sound;
  static readonly BLOCK_ROOTS_PLACE: Sound;
  static readonly BLOCK_ROOTS_STEP: Sound;
  static readonly BLOCK_SAND_BREAK: Sound;
  static readonly BLOCK_SAND_FALL: Sound;
  static readonly BLOCK_SAND_HIT: Sound;
  static readonly BLOCK_SAND_PLACE: Sound;
  static readonly BLOCK_SAND_STEP: Sound;
  static readonly BLOCK_SCAFFOLDING_BREAK: Sound;
  static readonly BLOCK_SCAFFOLDING_FALL: Sound;
  static readonly BLOCK_SCAFFOLDING_HIT: Sound;
  static readonly BLOCK_SCAFFOLDING_PLACE: Sound;
  static readonly BLOCK_SCAFFOLDING_STEP: Sound;
  static readonly BLOCK_SCULK_SENSOR_BREAK: Sound;
  static readonly BLOCK_SCULK_SENSOR_CLICKING: Sound;
  static readonly BLOCK_SCULK_SENSOR_CLICKING_STOP: Sound;
  static readonly BLOCK_SCULK_SENSOR_FALL: Sound;
  static readonly BLOCK_SCULK_SENSOR_HIT: Sound;
  static readonly BLOCK_SCULK_SENSOR_PLACE: Sound;
  static readonly BLOCK_SCULK_SENSOR_STEP: Sound;
  static readonly BLOCK_SHROOMLIGHT_BREAK: Sound;
  static readonly BLOCK_SHROOMLIGHT_FALL: Sound;
  static readonly BLOCK_SHROOMLIGHT_HIT: Sound;
  static readonly BLOCK_SHROOMLIGHT_PLACE: Sound;
  static readonly BLOCK_SHROOMLIGHT_STEP: Sound;
  static readonly BLOCK_SHULKER_BOX_CLOSE: Sound;
  static readonly BLOCK_SHULKER_BOX_OPEN: Sound;
  static readonly BLOCK_SLIME_BLOCK_BREAK: Sound;
  static readonly BLOCK_SLIME_BLOCK_FALL: Sound;
  static readonly BLOCK_SLIME_BLOCK_HIT: Sound;
  static readonly BLOCK_SLIME_BLOCK_PLACE: Sound;
  static readonly BLOCK_SLIME_BLOCK_STEP: Sound;
  static readonly BLOCK_SMALL_AMETHYST_BUD_BREAK: Sound;
  static readonly BLOCK_SMALL_AMETHYST_BUD_PLACE: Sound;
  static readonly BLOCK_SMALL_DRIPLEAF_BREAK: Sound;
  static readonly BLOCK_SMALL_DRIPLEAF_FALL: Sound;
  static readonly BLOCK_SMALL_DRIPLEAF_HIT: Sound;
  static readonly BLOCK_SMALL_DRIPLEAF_PLACE: Sound;
  static readonly BLOCK_SMALL_DRIPLEAF_STEP: Sound;
  static readonly BLOCK_SMITHING_TABLE_USE: Sound;
  static readonly BLOCK_SMOKER_SMOKE: Sound;
  static readonly BLOCK_SNOW_BREAK: Sound;
  static readonly BLOCK_SNOW_FALL: Sound;
  static readonly BLOCK_SNOW_HIT: Sound;
  static readonly BLOCK_SNOW_PLACE: Sound;
  static readonly BLOCK_SNOW_STEP: Sound;
  static readonly BLOCK_SOUL_SAND_BREAK: Sound;
  static readonly BLOCK_SOUL_SAND_FALL: Sound;
  static readonly BLOCK_SOUL_SAND_HIT: Sound;
  static readonly BLOCK_SOUL_SAND_PLACE: Sound;
  static readonly BLOCK_SOUL_SAND_STEP: Sound;
  static readonly BLOCK_SOUL_SOIL_BREAK: Sound;
  static readonly BLOCK_SOUL_SOIL_FALL: Sound;
  static readonly BLOCK_SOUL_SOIL_HIT: Sound;
  static readonly BLOCK_SOUL_SOIL_PLACE: Sound;
  static readonly BLOCK_SOUL_SOIL_STEP: Sound;
  static readonly BLOCK_SPORE_BLOSSOM_BREAK: Sound;
  static readonly BLOCK_SPORE_BLOSSOM_FALL: Sound;
  static readonly BLOCK_SPORE_BLOSSOM_HIT: Sound;
  static readonly BLOCK_SPORE_BLOSSOM_PLACE: Sound;
  static readonly BLOCK_SPORE_BLOSSOM_STEP: Sound;
  static readonly BLOCK_STEM_BREAK: Sound;
  static readonly BLOCK_STEM_FALL: Sound;
  static readonly BLOCK_STEM_HIT: Sound;
  static readonly BLOCK_STEM_PLACE: Sound;
  static readonly BLOCK_STEM_STEP: Sound;
  static readonly BLOCK_STONE_BREAK: Sound;
  static readonly BLOCK_STONE_BUTTON_CLICK_OFF: Sound;
  static readonly BLOCK_STONE_BUTTON_CLICK_ON: Sound;
  static readonly BLOCK_STONE_FALL: Sound;
  static readonly BLOCK_STONE_HIT: Sound;
  static readonly BLOCK_STONE_PLACE: Sound;
  static readonly BLOCK_STONE_PRESSURE_PLATE_CLICK_OFF: Sound;
  static readonly BLOCK_STONE_PRESSURE_PLATE_CLICK_ON: Sound;
  static readonly BLOCK_STONE_STEP: Sound;
  static readonly BLOCK_SWEET_BERRY_BUSH_BREAK: Sound;
  static readonly BLOCK_SWEET_BERRY_BUSH_PICK_BERRIES: Sound;
  static readonly BLOCK_SWEET_BERRY_BUSH_PLACE: Sound;
  static readonly BLOCK_TRIPWIRE_ATTACH: Sound;
  static readonly BLOCK_TRIPWIRE_CLICK_OFF: Sound;
  static readonly BLOCK_TRIPWIRE_CLICK_ON: Sound;
  static readonly BLOCK_TRIPWIRE_DETACH: Sound;
  static readonly BLOCK_TUFF_BREAK: Sound;
  static readonly BLOCK_TUFF_FALL: Sound;
  static readonly BLOCK_TUFF_HIT: Sound;
  static readonly BLOCK_TUFF_PLACE: Sound;
  static readonly BLOCK_TUFF_STEP: Sound;
  static readonly BLOCK_VINE_BREAK: Sound;
  static readonly BLOCK_VINE_FALL: Sound;
  static readonly BLOCK_VINE_HIT: Sound;
  static readonly BLOCK_VINE_PLACE: Sound;
  static readonly BLOCK_VINE_STEP: Sound;
  static readonly BLOCK_WART_BLOCK_BREAK: Sound;
  static readonly BLOCK_WART_BLOCK_FALL: Sound;
  static readonly BLOCK_WART_BLOCK_HIT: Sound;
  static readonly BLOCK_WART_BLOCK_PLACE: Sound;
  static readonly BLOCK_WART_BLOCK_STEP: Sound;
  static readonly BLOCK_WATER_AMBIENT: Sound;
  static readonly BLOCK_WEEPING_VINES_BREAK: Sound;
  static readonly BLOCK_WEEPING_VINES_FALL: Sound;
  static readonly BLOCK_WEEPING_VINES_HIT: Sound;
  static readonly BLOCK_WEEPING_VINES_PLACE: Sound;
  static readonly BLOCK_WEEPING_VINES_STEP: Sound;
  static readonly BLOCK_WET_GRASS_BREAK: Sound;
  static readonly BLOCK_WET_GRASS_FALL: Sound;
  static readonly BLOCK_WET_GRASS_HIT: Sound;
  static readonly BLOCK_WET_GRASS_PLACE: Sound;
  static readonly BLOCK_WET_GRASS_STEP: Sound;
  static readonly BLOCK_WOODEN_BUTTON_CLICK_OFF: Sound;
  static readonly BLOCK_WOODEN_BUTTON_CLICK_ON: Sound;
  static readonly BLOCK_WOODEN_DOOR_CLOSE: Sound;
  static readonly BLOCK_WOODEN_DOOR_OPEN: Sound;
  static readonly BLOCK_WOODEN_PRESSURE_PLATE_CLICK_OFF: Sound;
  static readonly BLOCK_WOODEN_PRESSURE_PLATE_CLICK_ON: Sound;
  static readonly BLOCK_WOODEN_TRAPDOOR_CLOSE: Sound;
  static readonly BLOCK_WOODEN_TRAPDOOR_OPEN: Sound;
  static readonly BLOCK_WOOD_BREAK: Sound;
  static readonly BLOCK_WOOD_FALL: Sound;
  static readonly BLOCK_WOOD_HIT: Sound;
  static readonly BLOCK_WOOD_PLACE: Sound;
  static readonly BLOCK_WOOD_STEP: Sound;
  static readonly BLOCK_WOOL_BREAK: Sound;
  static readonly BLOCK_WOOL_FALL: Sound;
  static readonly BLOCK_WOOL_HIT: Sound;
  static readonly BLOCK_WOOL_PLACE: Sound;
  static readonly BLOCK_WOOL_STEP: Sound;
  static readonly ENCHANT_THORNS_HIT: Sound;
  static readonly ENTITY_ARMOR_STAND_BREAK: Sound;
  static readonly ENTITY_ARMOR_STAND_FALL: Sound;
  static readonly ENTITY_ARMOR_STAND_HIT: Sound;
  static readonly ENTITY_ARMOR_STAND_PLACE: Sound;
  static readonly ENTITY_ARROW_HIT: Sound;
  static readonly ENTITY_ARROW_HIT_PLAYER: Sound;
  static readonly ENTITY_ARROW_SHOOT: Sound;
  static readonly ENTITY_AXOLOTL_ATTACK: Sound;
  static readonly ENTITY_AXOLOTL_DEATH: Sound;
  static readonly ENTITY_AXOLOTL_HURT: Sound;
  static readonly ENTITY_AXOLOTL_IDLE_AIR: Sound;
  static readonly ENTITY_AXOLOTL_IDLE_WATER: Sound;
  static readonly ENTITY_AXOLOTL_SPLASH: Sound;
  static readonly ENTITY_AXOLOTL_SWIM: Sound;
  static readonly ENTITY_BAT_AMBIENT: Sound;
  static readonly ENTITY_BAT_DEATH: Sound;
  static readonly ENTITY_BAT_HURT: Sound;
  static readonly ENTITY_BAT_LOOP: Sound;
  static readonly ENTITY_BAT_TAKEOFF: Sound;
  static readonly ENTITY_BEE_DEATH: Sound;
  static readonly ENTITY_BEE_HURT: Sound;
  static readonly ENTITY_BEE_LOOP: Sound;
  static readonly ENTITY_BEE_LOOP_AGGRESSIVE: Sound;
  static readonly ENTITY_BEE_POLLINATE: Sound;
  static readonly ENTITY_BEE_STING: Sound;
  static readonly ENTITY_BLAZE_AMBIENT: Sound;
  static readonly ENTITY_BLAZE_BURN: Sound;
  static readonly ENTITY_BLAZE_DEATH: Sound;
  static readonly ENTITY_BLAZE_HURT: Sound;
  static readonly ENTITY_BLAZE_SHOOT: Sound;
  static readonly ENTITY_BOAT_PADDLE_LAND: Sound;
  static readonly ENTITY_BOAT_PADDLE_WATER: Sound;
  static readonly ENTITY_CAT_AMBIENT: Sound;
  static readonly ENTITY_CAT_BEG_FOR_FOOD: Sound;
  static readonly ENTITY_CAT_DEATH: Sound;
  static readonly ENTITY_CAT_EAT: Sound;
  static readonly ENTITY_CAT_HISS: Sound;
  static readonly ENTITY_CAT_HURT: Sound;
  static readonly ENTITY_CAT_PURR: Sound;
  static readonly ENTITY_CAT_PURREOW: Sound;
  static readonly ENTITY_CAT_STRAY_AMBIENT: Sound;
  static readonly ENTITY_CHICKEN_AMBIENT: Sound;
  static readonly ENTITY_CHICKEN_DEATH: Sound;
  static readonly ENTITY_CHICKEN_EGG: Sound;
  static readonly ENTITY_CHICKEN_HURT: Sound;
  static readonly ENTITY_CHICKEN_STEP: Sound;
  static readonly ENTITY_COD_AMBIENT: Sound;
  static readonly ENTITY_COD_DEATH: Sound;
  static readonly ENTITY_COD_FLOP: Sound;
  static readonly ENTITY_COD_HURT: Sound;
  static readonly ENTITY_COW_AMBIENT: Sound;
  static readonly ENTITY_COW_DEATH: Sound;
  static readonly ENTITY_COW_HURT: Sound;
  static readonly ENTITY_COW_MILK: Sound;
  static readonly ENTITY_COW_STEP: Sound;
  static readonly ENTITY_CREEPER_DEATH: Sound;
  static readonly ENTITY_CREEPER_HURT: Sound;
  static readonly ENTITY_CREEPER_PRIMED: Sound;
  static readonly ENTITY_DOLPHIN_AMBIENT: Sound;
  static readonly ENTITY_DOLPHIN_AMBIENT_WATER: Sound;
  static readonly ENTITY_DOLPHIN_ATTACK: Sound;
  static readonly ENTITY_DOLPHIN_DEATH: Sound;
  static readonly ENTITY_DOLPHIN_EAT: Sound;
  static readonly ENTITY_DOLPHIN_HURT: Sound;
  static readonly ENTITY_DOLPHIN_JUMP: Sound;
  static readonly ENTITY_DOLPHIN_PLAY: Sound;
  static readonly ENTITY_DOLPHIN_SPLASH: Sound;
  static readonly ENTITY_DOLPHIN_SWIM: Sound;
  static readonly ENTITY_DONKEY_AMBIENT: Sound;
  static readonly ENTITY_DONKEY_ANGRY: Sound;
  static readonly ENTITY_DONKEY_CHEST: Sound;
  static readonly ENTITY_DONKEY_DEATH: Sound;
  static readonly ENTITY_DONKEY_EAT: Sound;
  static readonly ENTITY_DONKEY_HURT: Sound;
  static readonly ENTITY_DRAGON_FIREBALL_EXPLODE: Sound;
  static readonly ENTITY_DROWNED_AMBIENT: Sound;
  static readonly ENTITY_DROWNED_AMBIENT_WATER: Sound;
  static readonly ENTITY_DROWNED_DEATH: Sound;
  static readonly ENTITY_DROWNED_DEATH_WATER: Sound;
  static readonly ENTITY_DROWNED_HURT: Sound;
  static readonly ENTITY_DROWNED_HURT_WATER: Sound;
  static readonly ENTITY_DROWNED_SHOOT: Sound;
  static readonly ENTITY_DROWNED_STEP: Sound;
  static readonly ENTITY_DROWNED_SWIM: Sound;
  static readonly ENTITY_EGG_THROW: Sound;
  static readonly ENTITY_ELDER_GUARDIAN_AMBIENT: Sound;
  static readonly ENTITY_ELDER_GUARDIAN_AMBIENT_LAND: Sound;
  static readonly ENTITY_ELDER_GUARDIAN_CURSE: Sound;
  static readonly ENTITY_ELDER_GUARDIAN_DEATH: Sound;
  static readonly ENTITY_ELDER_GUARDIAN_DEATH_LAND: Sound;
  static readonly ENTITY_ELDER_GUARDIAN_FLOP: Sound;
  static readonly ENTITY_ELDER_GUARDIAN_HURT: Sound;
  static readonly ENTITY_ELDER_GUARDIAN_HURT_LAND: Sound;
  static readonly ENTITY_ENDERMAN_AMBIENT: Sound;
  static readonly ENTITY_ENDERMAN_DEATH: Sound;
  static readonly ENTITY_ENDERMAN_HURT: Sound;
  static readonly ENTITY_ENDERMAN_SCREAM: Sound;
  static readonly ENTITY_ENDERMAN_STARE: Sound;
  static readonly ENTITY_ENDERMAN_TELEPORT: Sound;
  static readonly ENTITY_ENDERMITE_AMBIENT: Sound;
  static readonly ENTITY_ENDERMITE_DEATH: Sound;
  static readonly ENTITY_ENDERMITE_HURT: Sound;
  static readonly ENTITY_ENDERMITE_STEP: Sound;
  static readonly ENTITY_ENDER_DRAGON_AMBIENT: Sound;
  static readonly ENTITY_ENDER_DRAGON_DEATH: Sound;
  static readonly ENTITY_ENDER_DRAGON_FLAP: Sound;
  static readonly ENTITY_ENDER_DRAGON_GROWL: Sound;
  static readonly ENTITY_ENDER_DRAGON_HURT: Sound;
  static readonly ENTITY_ENDER_DRAGON_SHOOT: Sound;
  static readonly ENTITY_ENDER_EYE_DEATH: Sound;
  static readonly ENTITY_ENDER_EYE_LAUNCH: Sound;
  static readonly ENTITY_ENDER_PEARL_THROW: Sound;
  static readonly ENTITY_EVOKER_AMBIENT: Sound;
  static readonly ENTITY_EVOKER_CAST_SPELL: Sound;
  static readonly ENTITY_EVOKER_CELEBRATE: Sound;
  static readonly ENTITY_EVOKER_DEATH: Sound;
  static readonly ENTITY_EVOKER_FANGS_ATTACK: Sound;
  static readonly ENTITY_EVOKER_HURT: Sound;
  static readonly ENTITY_EVOKER_PREPARE_ATTACK: Sound;
  static readonly ENTITY_EVOKER_PREPARE_SUMMON: Sound;
  static readonly ENTITY_EVOKER_PREPARE_WOLOLO: Sound;
  static readonly ENTITY_EXPERIENCE_BOTTLE_THROW: Sound;
  static readonly ENTITY_EXPERIENCE_ORB_PICKUP: Sound;
  static readonly ENTITY_FIREWORK_ROCKET_BLAST: Sound;
  static readonly ENTITY_FIREWORK_ROCKET_BLAST_FAR: Sound;
  static readonly ENTITY_FIREWORK_ROCKET_LARGE_BLAST: Sound;
  static readonly ENTITY_FIREWORK_ROCKET_LARGE_BLAST_FAR: Sound;
  static readonly ENTITY_FIREWORK_ROCKET_LAUNCH: Sound;
  static readonly ENTITY_FIREWORK_ROCKET_SHOOT: Sound;
  static readonly ENTITY_FIREWORK_ROCKET_TWINKLE: Sound;
  static readonly ENTITY_FIREWORK_ROCKET_TWINKLE_FAR: Sound;
  static readonly ENTITY_FISHING_BOBBER_RETRIEVE: Sound;
  static readonly ENTITY_FISHING_BOBBER_SPLASH: Sound;
  static readonly ENTITY_FISHING_BOBBER_THROW: Sound;
  static readonly ENTITY_FISH_SWIM: Sound;
  static readonly ENTITY_FOX_AGGRO: Sound;
  static readonly ENTITY_FOX_AMBIENT: Sound;
  static readonly ENTITY_FOX_BITE: Sound;
  static readonly ENTITY_FOX_DEATH: Sound;
  static readonly ENTITY_FOX_EAT: Sound;
  static readonly ENTITY_FOX_HURT: Sound;
  static readonly ENTITY_FOX_SCREECH: Sound;
  static readonly ENTITY_FOX_SLEEP: Sound;
  static readonly ENTITY_FOX_SNIFF: Sound;
  static readonly ENTITY_FOX_SPIT: Sound;
  static readonly ENTITY_FOX_TELEPORT: Sound;
  static readonly ENTITY_GENERIC_BIG_FALL: Sound;
  static readonly ENTITY_GENERIC_BURN: Sound;
  static readonly ENTITY_GENERIC_DEATH: Sound;
  static readonly ENTITY_GENERIC_DRINK: Sound;
  static readonly ENTITY_GENERIC_EAT: Sound;
  static readonly ENTITY_GENERIC_EXPLODE: Sound;
  static readonly ENTITY_GENERIC_EXTINGUISH_FIRE: Sound;
  static readonly ENTITY_GENERIC_HURT: Sound;
  static readonly ENTITY_GENERIC_SMALL_FALL: Sound;
  static readonly ENTITY_GENERIC_SPLASH: Sound;
  static readonly ENTITY_GENERIC_SWIM: Sound;
  static readonly ENTITY_GHAST_AMBIENT: Sound;
  static readonly ENTITY_GHAST_DEATH: Sound;
  static readonly ENTITY_GHAST_HURT: Sound;
  static readonly ENTITY_GHAST_SCREAM: Sound;
  static readonly ENTITY_GHAST_SHOOT: Sound;
  static readonly ENTITY_GHAST_WARN: Sound;
  static readonly ENTITY_GLOW_ITEM_FRAME_ADD_ITEM: Sound;
  static readonly ENTITY_GLOW_ITEM_FRAME_BREAK: Sound;
  static readonly ENTITY_GLOW_ITEM_FRAME_PLACE: Sound;
  static readonly ENTITY_GLOW_ITEM_FRAME_REMOVE_ITEM: Sound;
  static readonly ENTITY_GLOW_ITEM_FRAME_ROTATE_ITEM: Sound;
  static readonly ENTITY_GLOW_SQUID_AMBIENT: Sound;
  static readonly ENTITY_GLOW_SQUID_DEATH: Sound;
  static readonly ENTITY_GLOW_SQUID_HURT: Sound;
  static readonly ENTITY_GLOW_SQUID_SQUIRT: Sound;
  static readonly ENTITY_GOAT_AMBIENT: Sound;
  static readonly ENTITY_GOAT_DEATH: Sound;
  static readonly ENTITY_GOAT_EAT: Sound;
  static readonly ENTITY_GOAT_HURT: Sound;
  static readonly ENTITY_GOAT_LONG_JUMP: Sound;
  static readonly ENTITY_GOAT_MILK: Sound;
  static readonly ENTITY_GOAT_PREPARE_RAM: Sound;
  static readonly ENTITY_GOAT_RAM_IMPACT: Sound;
  static readonly ENTITY_GOAT_SCREAMING_AMBIENT: Sound;
  static readonly ENTITY_GOAT_SCREAMING_DEATH: Sound;
  static readonly ENTITY_GOAT_SCREAMING_EAT: Sound;
  static readonly ENTITY_GOAT_SCREAMING_HURT: Sound;
  static readonly ENTITY_GOAT_SCREAMING_LONG_JUMP: Sound;
  static readonly ENTITY_GOAT_SCREAMING_MILK: Sound;
  static readonly ENTITY_GOAT_SCREAMING_PREPARE_RAM: Sound;
  static readonly ENTITY_GOAT_SCREAMING_RAM_IMPACT: Sound;
  static readonly ENTITY_GOAT_STEP: Sound;
  static readonly ENTITY_GUARDIAN_AMBIENT: Sound;
  static readonly ENTITY_GUARDIAN_AMBIENT_LAND: Sound;
  static readonly ENTITY_GUARDIAN_ATTACK: Sound;
  static readonly ENTITY_GUARDIAN_DEATH: Sound;
  static readonly ENTITY_GUARDIAN_DEATH_LAND: Sound;
  static readonly ENTITY_GUARDIAN_FLOP: Sound;
  static readonly ENTITY_GUARDIAN_HURT: Sound;
  static readonly ENTITY_GUARDIAN_HURT_LAND: Sound;
  static readonly ENTITY_HOGLIN_AMBIENT: Sound;
  static readonly ENTITY_HOGLIN_ANGRY: Sound;
  static readonly ENTITY_HOGLIN_ATTACK: Sound;
  static readonly ENTITY_HOGLIN_CONVERTED_TO_ZOMBIFIED: Sound;
  static readonly ENTITY_HOGLIN_DEATH: Sound;
  static readonly ENTITY_HOGLIN_HURT: Sound;
  static readonly ENTITY_HOGLIN_RETREAT: Sound;
  static readonly ENTITY_HOGLIN_STEP: Sound;
  static readonly ENTITY_HORSE_AMBIENT: Sound;
  static readonly ENTITY_HORSE_ANGRY: Sound;
  static readonly ENTITY_HORSE_ARMOR: Sound;
  static readonly ENTITY_HORSE_BREATHE: Sound;
  static readonly ENTITY_HORSE_DEATH: Sound;
  static readonly ENTITY_HORSE_EAT: Sound;
  static readonly ENTITY_HORSE_GALLOP: Sound;
  static readonly ENTITY_HORSE_HURT: Sound;
  static readonly ENTITY_HORSE_JUMP: Sound;
  static readonly ENTITY_HORSE_LAND: Sound;
  static readonly ENTITY_HORSE_SADDLE: Sound;
  static readonly ENTITY_HORSE_STEP: Sound;
  static readonly ENTITY_HORSE_STEP_WOOD: Sound;
  static readonly ENTITY_HOSTILE_BIG_FALL: Sound;
  static readonly ENTITY_HOSTILE_DEATH: Sound;
  static readonly ENTITY_HOSTILE_HURT: Sound;
  static readonly ENTITY_HOSTILE_SMALL_FALL: Sound;
  static readonly ENTITY_HOSTILE_SPLASH: Sound;
  static readonly ENTITY_HOSTILE_SWIM: Sound;
  static readonly ENTITY_HUSK_AMBIENT: Sound;
  static readonly ENTITY_HUSK_CONVERTED_TO_ZOMBIE: Sound;
  static readonly ENTITY_HUSK_DEATH: Sound;
  static readonly ENTITY_HUSK_HURT: Sound;
  static readonly ENTITY_HUSK_STEP: Sound;
  static readonly ENTITY_ILLUSIONER_AMBIENT: Sound;
  static readonly ENTITY_ILLUSIONER_CAST_SPELL: Sound;
  static readonly ENTITY_ILLUSIONER_DEATH: Sound;
  static readonly ENTITY_ILLUSIONER_HURT: Sound;
  static readonly ENTITY_ILLUSIONER_MIRROR_MOVE: Sound;
  static readonly ENTITY_ILLUSIONER_PREPARE_BLINDNESS: Sound;
  static readonly ENTITY_ILLUSIONER_PREPARE_MIRROR: Sound;
  static readonly ENTITY_IRON_GOLEM_ATTACK: Sound;
  static readonly ENTITY_IRON_GOLEM_DAMAGE: Sound;
  static readonly ENTITY_IRON_GOLEM_DEATH: Sound;
  static readonly ENTITY_IRON_GOLEM_HURT: Sound;
  static readonly ENTITY_IRON_GOLEM_REPAIR: Sound;
  static readonly ENTITY_IRON_GOLEM_STEP: Sound;
  static readonly ENTITY_ITEM_BREAK: Sound;
  static readonly ENTITY_ITEM_FRAME_ADD_ITEM: Sound;
  static readonly ENTITY_ITEM_FRAME_BREAK: Sound;
  static readonly ENTITY_ITEM_FRAME_PLACE: Sound;
  static readonly ENTITY_ITEM_FRAME_REMOVE_ITEM: Sound;
  static readonly ENTITY_ITEM_FRAME_ROTATE_ITEM: Sound;
  static readonly ENTITY_ITEM_PICKUP: Sound;
  static readonly ENTITY_LEASH_KNOT_BREAK: Sound;
  static readonly ENTITY_LEASH_KNOT_PLACE: Sound;
  static readonly ENTITY_LIGHTNING_BOLT_IMPACT: Sound;
  static readonly ENTITY_LIGHTNING_BOLT_THUNDER: Sound;
  static readonly ENTITY_LINGERING_POTION_THROW: Sound;
  static readonly ENTITY_LLAMA_AMBIENT: Sound;
  static readonly ENTITY_LLAMA_ANGRY: Sound;
  static readonly ENTITY_LLAMA_CHEST: Sound;
  static readonly ENTITY_LLAMA_DEATH: Sound;
  static readonly ENTITY_LLAMA_EAT: Sound;
  static readonly ENTITY_LLAMA_HURT: Sound;
  static readonly ENTITY_LLAMA_SPIT: Sound;
  static readonly ENTITY_LLAMA_STEP: Sound;
  static readonly ENTITY_LLAMA_SWAG: Sound;
  static readonly ENTITY_MAGMA_CUBE_DEATH: Sound;
  static readonly ENTITY_MAGMA_CUBE_DEATH_SMALL: Sound;
  static readonly ENTITY_MAGMA_CUBE_HURT: Sound;
  static readonly ENTITY_MAGMA_CUBE_HURT_SMALL: Sound;
  static readonly ENTITY_MAGMA_CUBE_JUMP: Sound;
  static readonly ENTITY_MAGMA_CUBE_SQUISH: Sound;
  static readonly ENTITY_MAGMA_CUBE_SQUISH_SMALL: Sound;
  static readonly ENTITY_MINECART_INSIDE: Sound;
  static readonly ENTITY_MINECART_INSIDE_UNDERWATER: Sound;
  static readonly ENTITY_MINECART_RIDING: Sound;
  static readonly ENTITY_MOOSHROOM_CONVERT: Sound;
  static readonly ENTITY_MOOSHROOM_EAT: Sound;
  static readonly ENTITY_MOOSHROOM_MILK: Sound;
  static readonly ENTITY_MOOSHROOM_SHEAR: Sound;
  static readonly ENTITY_MOOSHROOM_SUSPICIOUS_MILK: Sound;
  static readonly ENTITY_MULE_AMBIENT: Sound;
  static readonly ENTITY_MULE_ANGRY: Sound;
  static readonly ENTITY_MULE_CHEST: Sound;
  static readonly ENTITY_MULE_DEATH: Sound;
  static readonly ENTITY_MULE_EAT: Sound;
  static readonly ENTITY_MULE_HURT: Sound;
  static readonly ENTITY_OCELOT_AMBIENT: Sound;
  static readonly ENTITY_OCELOT_DEATH: Sound;
  static readonly ENTITY_OCELOT_HURT: Sound;
  static readonly ENTITY_PAINTING_BREAK: Sound;
  static readonly ENTITY_PAINTING_PLACE: Sound;
  static readonly ENTITY_PANDA_AGGRESSIVE_AMBIENT: Sound;
  static readonly ENTITY_PANDA_AMBIENT: Sound;
  static readonly ENTITY_PANDA_BITE: Sound;
  static readonly ENTITY_PANDA_CANT_BREED: Sound;
  static readonly ENTITY_PANDA_DEATH: Sound;
  static readonly ENTITY_PANDA_EAT: Sound;
  static readonly ENTITY_PANDA_HURT: Sound;
  static readonly ENTITY_PANDA_PRE_SNEEZE: Sound;
  static readonly ENTITY_PANDA_SNEEZE: Sound;
  static readonly ENTITY_PANDA_STEP: Sound;
  static readonly ENTITY_PANDA_WORRIED_AMBIENT: Sound;
  static readonly ENTITY_PARROT_AMBIENT: Sound;
  static readonly ENTITY_PARROT_DEATH: Sound;
  static readonly ENTITY_PARROT_EAT: Sound;
  static readonly ENTITY_PARROT_FLY: Sound;
  static readonly ENTITY_PARROT_HURT: Sound;
  static readonly ENTITY_PARROT_IMITATE_BLAZE: Sound;
  static readonly ENTITY_PARROT_IMITATE_CREEPER: Sound;
  static readonly ENTITY_PARROT_IMITATE_DROWNED: Sound;
  static readonly ENTITY_PARROT_IMITATE_ELDER_GUARDIAN: Sound;
  static readonly ENTITY_PARROT_IMITATE_ENDERMITE: Sound;
  static readonly ENTITY_PARROT_IMITATE_ENDER_DRAGON: Sound;
  static readonly ENTITY_PARROT_IMITATE_EVOKER: Sound;
  static readonly ENTITY_PARROT_IMITATE_GHAST: Sound;
  static readonly ENTITY_PARROT_IMITATE_GUARDIAN: Sound;
  static readonly ENTITY_PARROT_IMITATE_HOGLIN: Sound;
  static readonly ENTITY_PARROT_IMITATE_HUSK: Sound;
  static readonly ENTITY_PARROT_IMITATE_ILLUSIONER: Sound;
  static readonly ENTITY_PARROT_IMITATE_MAGMA_CUBE: Sound;
  static readonly ENTITY_PARROT_IMITATE_PHANTOM: Sound;
  static readonly ENTITY_PARROT_IMITATE_PIGLIN: Sound;
  static readonly ENTITY_PARROT_IMITATE_PIGLIN_BRUTE: Sound;
  static readonly ENTITY_PARROT_IMITATE_PILLAGER: Sound;
  static readonly ENTITY_PARROT_IMITATE_RAVAGER: Sound;
  static readonly ENTITY_PARROT_IMITATE_SHULKER: Sound;
  static readonly ENTITY_PARROT_IMITATE_SILVERFISH: Sound;
  static readonly ENTITY_PARROT_IMITATE_SKELETON: Sound;
  static readonly ENTITY_PARROT_IMITATE_SLIME: Sound;
  static readonly ENTITY_PARROT_IMITATE_SPIDER: Sound;
  static readonly ENTITY_PARROT_IMITATE_STRAY: Sound;
  static readonly ENTITY_PARROT_IMITATE_VEX: Sound;
  static readonly ENTITY_PARROT_IMITATE_VINDICATOR: Sound;
  static readonly ENTITY_PARROT_IMITATE_WITCH: Sound;
  static readonly ENTITY_PARROT_IMITATE_WITHER: Sound;
  static readonly ENTITY_PARROT_IMITATE_WITHER_SKELETON: Sound;
  static readonly ENTITY_PARROT_IMITATE_ZOGLIN: Sound;
  static readonly ENTITY_PARROT_IMITATE_ZOMBIE: Sound;
  static readonly ENTITY_PARROT_IMITATE_ZOMBIE_VILLAGER: Sound;
  static readonly ENTITY_PARROT_STEP: Sound;
  static readonly ENTITY_PHANTOM_AMBIENT: Sound;
  static readonly ENTITY_PHANTOM_BITE: Sound;
  static readonly ENTITY_PHANTOM_DEATH: Sound;
  static readonly ENTITY_PHANTOM_FLAP: Sound;
  static readonly ENTITY_PHANTOM_HURT: Sound;
  static readonly ENTITY_PHANTOM_SWOOP: Sound;
  static readonly ENTITY_PIGLIN_ADMIRING_ITEM: Sound;
  static readonly ENTITY_PIGLIN_AMBIENT: Sound;
  static readonly ENTITY_PIGLIN_ANGRY: Sound;
  static readonly ENTITY_PIGLIN_BRUTE_AMBIENT: Sound;
  static readonly ENTITY_PIGLIN_BRUTE_ANGRY: Sound;
  static readonly ENTITY_PIGLIN_BRUTE_CONVERTED_TO_ZOMBIFIED: Sound;
  static readonly ENTITY_PIGLIN_BRUTE_DEATH: Sound;
  static readonly ENTITY_PIGLIN_BRUTE_HURT: Sound;
  static readonly ENTITY_PIGLIN_BRUTE_STEP: Sound;
  static readonly ENTITY_PIGLIN_CELEBRATE: Sound;
  static readonly ENTITY_PIGLIN_CONVERTED_TO_ZOMBIFIED: Sound;
  static readonly ENTITY_PIGLIN_DEATH: Sound;
  static readonly ENTITY_PIGLIN_HURT: Sound;
  static readonly ENTITY_PIGLIN_JEALOUS: Sound;
  static readonly ENTITY_PIGLIN_RETREAT: Sound;
  static readonly ENTITY_PIGLIN_STEP: Sound;
  static readonly ENTITY_PIG_AMBIENT: Sound;
  static readonly ENTITY_PIG_DEATH: Sound;
  static readonly ENTITY_PIG_HURT: Sound;
  static readonly ENTITY_PIG_SADDLE: Sound;
  static readonly ENTITY_PIG_STEP: Sound;
  static readonly ENTITY_PILLAGER_AMBIENT: Sound;
  static readonly ENTITY_PILLAGER_CELEBRATE: Sound;
  static readonly ENTITY_PILLAGER_DEATH: Sound;
  static readonly ENTITY_PILLAGER_HURT: Sound;
  static readonly ENTITY_PLAYER_ATTACK_CRIT: Sound;
  static readonly ENTITY_PLAYER_ATTACK_KNOCKBACK: Sound;
  static readonly ENTITY_PLAYER_ATTACK_NODAMAGE: Sound;
  static readonly ENTITY_PLAYER_ATTACK_STRONG: Sound;
  static readonly ENTITY_PLAYER_ATTACK_SWEEP: Sound;
  static readonly ENTITY_PLAYER_ATTACK_WEAK: Sound;
  static readonly ENTITY_PLAYER_BIG_FALL: Sound;
  static readonly ENTITY_PLAYER_BREATH: Sound;
  static readonly ENTITY_PLAYER_BURP: Sound;
  static readonly ENTITY_PLAYER_DEATH: Sound;
  static readonly ENTITY_PLAYER_HURT: Sound;
  static readonly ENTITY_PLAYER_HURT_DROWN: Sound;
  static readonly ENTITY_PLAYER_HURT_FREEZE: Sound;
  static readonly ENTITY_PLAYER_HURT_ON_FIRE: Sound;
  static readonly ENTITY_PLAYER_HURT_SWEET_BERRY_BUSH: Sound;
  static readonly ENTITY_PLAYER_LEVELUP: Sound;
  static readonly ENTITY_PLAYER_SMALL_FALL: Sound;
  static readonly ENTITY_PLAYER_SPLASH: Sound;
  static readonly ENTITY_PLAYER_SPLASH_HIGH_SPEED: Sound;
  static readonly ENTITY_PLAYER_SWIM: Sound;
  static readonly ENTITY_POLAR_BEAR_AMBIENT: Sound;
  static readonly ENTITY_POLAR_BEAR_AMBIENT_BABY: Sound;
  static readonly ENTITY_POLAR_BEAR_DEATH: Sound;
  static readonly ENTITY_POLAR_BEAR_HURT: Sound;
  static readonly ENTITY_POLAR_BEAR_STEP: Sound;
  static readonly ENTITY_POLAR_BEAR_WARNING: Sound;
  static readonly ENTITY_PUFFER_FISH_AMBIENT: Sound;
  static readonly ENTITY_PUFFER_FISH_BLOW_OUT: Sound;
  static readonly ENTITY_PUFFER_FISH_BLOW_UP: Sound;
  static readonly ENTITY_PUFFER_FISH_DEATH: Sound;
  static readonly ENTITY_PUFFER_FISH_FLOP: Sound;
  static readonly ENTITY_PUFFER_FISH_HURT: Sound;
  static readonly ENTITY_PUFFER_FISH_STING: Sound;
  static readonly ENTITY_RABBIT_AMBIENT: Sound;
  static readonly ENTITY_RABBIT_ATTACK: Sound;
  static readonly ENTITY_RABBIT_DEATH: Sound;
  static readonly ENTITY_RABBIT_HURT: Sound;
  static readonly ENTITY_RABBIT_JUMP: Sound;
  static readonly ENTITY_RAVAGER_AMBIENT: Sound;
  static readonly ENTITY_RAVAGER_ATTACK: Sound;
  static readonly ENTITY_RAVAGER_CELEBRATE: Sound;
  static readonly ENTITY_RAVAGER_DEATH: Sound;
  static readonly ENTITY_RAVAGER_HURT: Sound;
  static readonly ENTITY_RAVAGER_ROAR: Sound;
  static readonly ENTITY_RAVAGER_STEP: Sound;
  static readonly ENTITY_RAVAGER_STUNNED: Sound;
  static readonly ENTITY_SALMON_AMBIENT: Sound;
  static readonly ENTITY_SALMON_DEATH: Sound;
  static readonly ENTITY_SALMON_FLOP: Sound;
  static readonly ENTITY_SALMON_HURT: Sound;
  static readonly ENTITY_SHEEP_AMBIENT: Sound;
  static readonly ENTITY_SHEEP_DEATH: Sound;
  static readonly ENTITY_SHEEP_HURT: Sound;
  static readonly ENTITY_SHEEP_SHEAR: Sound;
  static readonly ENTITY_SHEEP_STEP: Sound;
  static readonly ENTITY_SHULKER_AMBIENT: Sound;
  static readonly ENTITY_SHULKER_BULLET_HIT: Sound;
  static readonly ENTITY_SHULKER_BULLET_HURT: Sound;
  static readonly ENTITY_SHULKER_CLOSE: Sound;
  static readonly ENTITY_SHULKER_DEATH: Sound;
  static readonly ENTITY_SHULKER_HURT: Sound;
  static readonly ENTITY_SHULKER_HURT_CLOSED: Sound;
  static readonly ENTITY_SHULKER_OPEN: Sound;
  static readonly ENTITY_SHULKER_SHOOT: Sound;
  static readonly ENTITY_SHULKER_TELEPORT: Sound;
  static readonly ENTITY_SILVERFISH_AMBIENT: Sound;
  static readonly ENTITY_SILVERFISH_DEATH: Sound;
  static readonly ENTITY_SILVERFISH_HURT: Sound;
  static readonly ENTITY_SILVERFISH_STEP: Sound;
  static readonly ENTITY_SKELETON_AMBIENT: Sound;
  static readonly ENTITY_SKELETON_CONVERTED_TO_STRAY: Sound;
  static readonly ENTITY_SKELETON_DEATH: Sound;
  static readonly ENTITY_SKELETON_HORSE_AMBIENT: Sound;
  static readonly ENTITY_SKELETON_HORSE_AMBIENT_WATER: Sound;
  static readonly ENTITY_SKELETON_HORSE_DEATH: Sound;
  static readonly ENTITY_SKELETON_HORSE_GALLOP_WATER: Sound;
  static readonly ENTITY_SKELETON_HORSE_HURT: Sound;
  static readonly ENTITY_SKELETON_HORSE_JUMP_WATER: Sound;
  static readonly ENTITY_SKELETON_HORSE_STEP_WATER: Sound;
  static readonly ENTITY_SKELETON_HORSE_SWIM: Sound;
  static readonly ENTITY_SKELETON_HURT: Sound;
  static readonly ENTITY_SKELETON_SHOOT: Sound;
  static readonly ENTITY_SKELETON_STEP: Sound;
  static readonly ENTITY_SLIME_ATTACK: Sound;
  static readonly ENTITY_SLIME_DEATH: Sound;
  static readonly ENTITY_SLIME_DEATH_SMALL: Sound;
  static readonly ENTITY_SLIME_HURT: Sound;
  static readonly ENTITY_SLIME_HURT_SMALL: Sound;
  static readonly ENTITY_SLIME_JUMP: Sound;
  static readonly ENTITY_SLIME_JUMP_SMALL: Sound;
  static readonly ENTITY_SLIME_SQUISH: Sound;
  static readonly ENTITY_SLIME_SQUISH_SMALL: Sound;
  static readonly ENTITY_SNOWBALL_THROW: Sound;
  static readonly ENTITY_SNOW_GOLEM_AMBIENT: Sound;
  static readonly ENTITY_SNOW_GOLEM_DEATH: Sound;
  static readonly ENTITY_SNOW_GOLEM_HURT: Sound;
  static readonly ENTITY_SNOW_GOLEM_SHEAR: Sound;
  static readonly ENTITY_SNOW_GOLEM_SHOOT: Sound;
  static readonly ENTITY_SPIDER_AMBIENT: Sound;
  static readonly ENTITY_SPIDER_DEATH: Sound;
  static readonly ENTITY_SPIDER_HURT: Sound;
  static readonly ENTITY_SPIDER_STEP: Sound;
  static readonly ENTITY_SPLASH_POTION_BREAK: Sound;
  static readonly ENTITY_SPLASH_POTION_THROW: Sound;
  static readonly ENTITY_SQUID_AMBIENT: Sound;
  static readonly ENTITY_SQUID_DEATH: Sound;
  static readonly ENTITY_SQUID_HURT: Sound;
  static readonly ENTITY_SQUID_SQUIRT: Sound;
  static readonly ENTITY_STRAY_AMBIENT: Sound;
  static readonly ENTITY_STRAY_DEATH: Sound;
  static readonly ENTITY_STRAY_HURT: Sound;
  static readonly ENTITY_STRAY_STEP: Sound;
  static readonly ENTITY_STRIDER_AMBIENT: Sound;
  static readonly ENTITY_STRIDER_DEATH: Sound;
  static readonly ENTITY_STRIDER_EAT: Sound;
  static readonly ENTITY_STRIDER_HAPPY: Sound;
  static readonly ENTITY_STRIDER_HURT: Sound;
  static readonly ENTITY_STRIDER_RETREAT: Sound;
  static readonly ENTITY_STRIDER_SADDLE: Sound;
  static readonly ENTITY_STRIDER_STEP: Sound;
  static readonly ENTITY_STRIDER_STEP_LAVA: Sound;
  static readonly ENTITY_TNT_PRIMED: Sound;
  static readonly ENTITY_TROPICAL_FISH_AMBIENT: Sound;
  static readonly ENTITY_TROPICAL_FISH_DEATH: Sound;
  static readonly ENTITY_TROPICAL_FISH_FLOP: Sound;
  static readonly ENTITY_TROPICAL_FISH_HURT: Sound;
  static readonly ENTITY_TURTLE_AMBIENT_LAND: Sound;
  static readonly ENTITY_TURTLE_DEATH: Sound;
  static readonly ENTITY_TURTLE_DEATH_BABY: Sound;
  static readonly ENTITY_TURTLE_EGG_BREAK: Sound;
  static readonly ENTITY_TURTLE_EGG_CRACK: Sound;
  static readonly ENTITY_TURTLE_EGG_HATCH: Sound;
  static readonly ENTITY_TURTLE_HURT: Sound;
  static readonly ENTITY_TURTLE_HURT_BABY: Sound;
  static readonly ENTITY_TURTLE_LAY_EGG: Sound;
  static readonly ENTITY_TURTLE_SHAMBLE: Sound;
  static readonly ENTITY_TURTLE_SHAMBLE_BABY: Sound;
  static readonly ENTITY_TURTLE_SWIM: Sound;
  static readonly ENTITY_VEX_AMBIENT: Sound;
  static readonly ENTITY_VEX_CHARGE: Sound;
  static readonly ENTITY_VEX_DEATH: Sound;
  static readonly ENTITY_VEX_HURT: Sound;
  static readonly ENTITY_VILLAGER_AMBIENT: Sound;
  static readonly ENTITY_VILLAGER_CELEBRATE: Sound;
  static readonly ENTITY_VILLAGER_DEATH: Sound;
  static readonly ENTITY_VILLAGER_HURT: Sound;
  static readonly ENTITY_VILLAGER_NO: Sound;
  static readonly ENTITY_VILLAGER_TRADE: Sound;
  static readonly ENTITY_VILLAGER_WORK_ARMORER: Sound;
  static readonly ENTITY_VILLAGER_WORK_BUTCHER: Sound;
  static readonly ENTITY_VILLAGER_WORK_CARTOGRAPHER: Sound;
  static readonly ENTITY_VILLAGER_WORK_CLERIC: Sound;
  static readonly ENTITY_VILLAGER_WORK_FARMER: Sound;
  static readonly ENTITY_VILLAGER_WORK_FISHERMAN: Sound;
  static readonly ENTITY_VILLAGER_WORK_FLETCHER: Sound;
  static readonly ENTITY_VILLAGER_WORK_LEATHERWORKER: Sound;
  static readonly ENTITY_VILLAGER_WORK_LIBRARIAN: Sound;
  static readonly ENTITY_VILLAGER_WORK_MASON: Sound;
  static readonly ENTITY_VILLAGER_WORK_SHEPHERD: Sound;
  static readonly ENTITY_VILLAGER_WORK_TOOLSMITH: Sound;
  static readonly ENTITY_VILLAGER_WORK_WEAPONSMITH: Sound;
  static readonly ENTITY_VILLAGER_YES: Sound;
  static readonly ENTITY_VINDICATOR_AMBIENT: Sound;
  static readonly ENTITY_VINDICATOR_CELEBRATE: Sound;
  static readonly ENTITY_VINDICATOR_DEATH: Sound;
  static readonly ENTITY_VINDICATOR_HURT: Sound;
  static readonly ENTITY_WANDERING_TRADER_AMBIENT: Sound;
  static readonly ENTITY_WANDERING_TRADER_DEATH: Sound;
  static readonly ENTITY_WANDERING_TRADER_DISAPPEARED: Sound;
  static readonly ENTITY_WANDERING_TRADER_DRINK_MILK: Sound;
  static readonly ENTITY_WANDERING_TRADER_DRINK_POTION: Sound;
  static readonly ENTITY_WANDERING_TRADER_HURT: Sound;
  static readonly ENTITY_WANDERING_TRADER_NO: Sound;
  static readonly ENTITY_WANDERING_TRADER_REAPPEARED: Sound;
  static readonly ENTITY_WANDERING_TRADER_TRADE: Sound;
  static readonly ENTITY_WANDERING_TRADER_YES: Sound;
  static readonly ENTITY_WITCH_AMBIENT: Sound;
  static readonly ENTITY_WITCH_CELEBRATE: Sound;
  static readonly ENTITY_WITCH_DEATH: Sound;
  static readonly ENTITY_WITCH_DRINK: Sound;
  static readonly ENTITY_WITCH_HURT: Sound;
  static readonly ENTITY_WITCH_THROW: Sound;
  static readonly ENTITY_WITHER_AMBIENT: Sound;
  static readonly ENTITY_WITHER_BREAK_BLOCK: Sound;
  static readonly ENTITY_WITHER_DEATH: Sound;
  static readonly ENTITY_WITHER_HURT: Sound;
  static readonly ENTITY_WITHER_SHOOT: Sound;
  static readonly ENTITY_WITHER_SKELETON_AMBIENT: Sound;
  static readonly ENTITY_WITHER_SKELETON_DEATH: Sound;
  static readonly ENTITY_WITHER_SKELETON_HURT: Sound;
  static readonly ENTITY_WITHER_SKELETON_STEP: Sound;
  static readonly ENTITY_WITHER_SPAWN: Sound;
  static readonly ENTITY_WOLF_AMBIENT: Sound;
  static readonly ENTITY_WOLF_DEATH: Sound;
  static readonly ENTITY_WOLF_GROWL: Sound;
  static readonly ENTITY_WOLF_HOWL: Sound;
  static readonly ENTITY_WOLF_HURT: Sound;
  static readonly ENTITY_WOLF_PANT: Sound;
  static readonly ENTITY_WOLF_SHAKE: Sound;
  static readonly ENTITY_WOLF_STEP: Sound;
  static readonly ENTITY_WOLF_WHINE: Sound;
  static readonly ENTITY_ZOGLIN_AMBIENT: Sound;
  static readonly ENTITY_ZOGLIN_ANGRY: Sound;
  static readonly ENTITY_ZOGLIN_ATTACK: Sound;
  static readonly ENTITY_ZOGLIN_DEATH: Sound;
  static readonly ENTITY_ZOGLIN_HURT: Sound;
  static readonly ENTITY_ZOGLIN_STEP: Sound;
  static readonly ENTITY_ZOMBIE_AMBIENT: Sound;
  static readonly ENTITY_ZOMBIE_ATTACK_IRON_DOOR: Sound;
  static readonly ENTITY_ZOMBIE_ATTACK_WOODEN_DOOR: Sound;
  static readonly ENTITY_ZOMBIE_BREAK_WOODEN_DOOR: Sound;
  static readonly ENTITY_ZOMBIE_CONVERTED_TO_DROWNED: Sound;
  static readonly ENTITY_ZOMBIE_DEATH: Sound;
  static readonly ENTITY_ZOMBIE_DESTROY_EGG: Sound;
  static readonly ENTITY_ZOMBIE_HORSE_AMBIENT: Sound;
  static readonly ENTITY_ZOMBIE_HORSE_DEATH: Sound;
  static readonly ENTITY_ZOMBIE_HORSE_HURT: Sound;
  static readonly ENTITY_ZOMBIE_HURT: Sound;
  static readonly ENTITY_ZOMBIE_INFECT: Sound;
  static readonly ENTITY_ZOMBIE_STEP: Sound;
  static readonly ENTITY_ZOMBIE_VILLAGER_AMBIENT: Sound;
  static readonly ENTITY_ZOMBIE_VILLAGER_CONVERTED: Sound;
  static readonly ENTITY_ZOMBIE_VILLAGER_CURE: Sound;
  static readonly ENTITY_ZOMBIE_VILLAGER_DEATH: Sound;
  static readonly ENTITY_ZOMBIE_VILLAGER_HURT: Sound;
  static readonly ENTITY_ZOMBIE_VILLAGER_STEP: Sound;
  static readonly ENTITY_ZOMBIFIED_PIGLIN_AMBIENT: Sound;
  static readonly ENTITY_ZOMBIFIED_PIGLIN_ANGRY: Sound;
  static readonly ENTITY_ZOMBIFIED_PIGLIN_DEATH: Sound;
  static readonly ENTITY_ZOMBIFIED_PIGLIN_HURT: Sound;
  static readonly EVENT_RAID_HORN: Sound;
  static readonly ITEM_ARMOR_EQUIP_CHAIN: Sound;
  static readonly ITEM_ARMOR_EQUIP_DIAMOND: Sound;
  static readonly ITEM_ARMOR_EQUIP_ELYTRA: Sound;
  static readonly ITEM_ARMOR_EQUIP_GENERIC: Sound;
  static readonly ITEM_ARMOR_EQUIP_GOLD: Sound;
  static readonly ITEM_ARMOR_EQUIP_IRON: Sound;
  static readonly ITEM_ARMOR_EQUIP_LEATHER: Sound;
  static readonly ITEM_ARMOR_EQUIP_NETHERITE: Sound;
  static readonly ITEM_ARMOR_EQUIP_TURTLE: Sound;
  static readonly ITEM_AXE_SCRAPE: Sound;
  static readonly ITEM_AXE_STRIP: Sound;
  static readonly ITEM_AXE_WAX_OFF: Sound;
  static readonly ITEM_BONE_MEAL_USE: Sound;
  static readonly ITEM_BOOK_PAGE_TURN: Sound;
  static readonly ITEM_BOOK_PUT: Sound;
  static readonly ITEM_BOTTLE_EMPTY: Sound;
  static readonly ITEM_BOTTLE_FILL: Sound;
  static readonly ITEM_BOTTLE_FILL_DRAGONBREATH: Sound;
  static readonly ITEM_BUCKET_EMPTY: Sound;
  static readonly ITEM_BUCKET_EMPTY_AXOLOTL: Sound;
  static readonly ITEM_BUCKET_EMPTY_FISH: Sound;
  static readonly ITEM_BUCKET_EMPTY_LAVA: Sound;
  static readonly ITEM_BUCKET_EMPTY_POWDER_SNOW: Sound;
  static readonly ITEM_BUCKET_FILL: Sound;
  static readonly ITEM_BUCKET_FILL_AXOLOTL: Sound;
  static readonly ITEM_BUCKET_FILL_FISH: Sound;
  static readonly ITEM_BUCKET_FILL_LAVA: Sound;
  static readonly ITEM_BUCKET_FILL_POWDER_SNOW: Sound;
  static readonly ITEM_BUNDLE_DROP_CONTENTS: Sound;
  static readonly ITEM_BUNDLE_INSERT: Sound;
  static readonly ITEM_BUNDLE_REMOVE_ONE: Sound;
  static readonly ITEM_CHORUS_FRUIT_TELEPORT: Sound;
  static readonly ITEM_CROP_PLANT: Sound;
  static readonly ITEM_CROSSBOW_HIT: Sound;
  static readonly ITEM_CROSSBOW_LOADING_END: Sound;
  static readonly ITEM_CROSSBOW_LOADING_MIDDLE: Sound;
  static readonly ITEM_CROSSBOW_LOADING_START: Sound;
  static readonly ITEM_CROSSBOW_QUICK_CHARGE_1: Sound;
  static readonly ITEM_CROSSBOW_QUICK_CHARGE_2: Sound;
  static readonly ITEM_CROSSBOW_QUICK_CHARGE_3: Sound;
  static readonly ITEM_CROSSBOW_SHOOT: Sound;
  static readonly ITEM_DYE_USE: Sound;
  static readonly ITEM_ELYTRA_FLYING: Sound;
  static readonly ITEM_FIRECHARGE_USE: Sound;
  static readonly ITEM_FLINTANDSTEEL_USE: Sound;
  static readonly ITEM_GLOW_INK_SAC_USE: Sound;
  static readonly ITEM_HOE_TILL: Sound;
  static readonly ITEM_HONEYCOMB_WAX_ON: Sound;
  static readonly ITEM_HONEY_BOTTLE_DRINK: Sound;
  static readonly ITEM_INK_SAC_USE: Sound;
  static readonly ITEM_LODESTONE_COMPASS_LOCK: Sound;
  static readonly ITEM_NETHER_WART_PLANT: Sound;
  static readonly ITEM_SHIELD_BLOCK: Sound;
  static readonly ITEM_SHIELD_BREAK: Sound;
  static readonly ITEM_SHOVEL_FLATTEN: Sound;
  static readonly ITEM_SPYGLASS_STOP_USING: Sound;
  static readonly ITEM_SPYGLASS_USE: Sound;
  static readonly ITEM_TOTEM_USE: Sound;
  static readonly ITEM_TRIDENT_HIT: Sound;
  static readonly ITEM_TRIDENT_HIT_GROUND: Sound;
  static readonly ITEM_TRIDENT_RETURN: Sound;
  static readonly ITEM_TRIDENT_RIPTIDE_1: Sound;
  static readonly ITEM_TRIDENT_RIPTIDE_2: Sound;
  static readonly ITEM_TRIDENT_RIPTIDE_3: Sound;
  static readonly ITEM_TRIDENT_THROW: Sound;
  static readonly ITEM_TRIDENT_THUNDER: Sound;
  static readonly MUSIC_CREATIVE: Sound;
  static readonly MUSIC_CREDITS: Sound;
  static readonly MUSIC_DISC_11: Sound;
  static readonly MUSIC_DISC_13: Sound;
  static readonly MUSIC_DISC_BLOCKS: Sound;
  static readonly MUSIC_DISC_CAT: Sound;
  static readonly MUSIC_DISC_CHIRP: Sound;
  static readonly MUSIC_DISC_FAR: Sound;
  static readonly MUSIC_DISC_MALL: Sound;
  static readonly MUSIC_DISC_MELLOHI: Sound;
  static readonly MUSIC_DISC_OTHERSIDE: Sound;
  static readonly MUSIC_DISC_PIGSTEP: Sound;
  static readonly MUSIC_DISC_STAL: Sound;
  static readonly MUSIC_DISC_STRAD: Sound;
  static readonly MUSIC_DISC_WAIT: Sound;
  static readonly MUSIC_DISC_WARD: Sound;
  static readonly MUSIC_DRAGON: Sound;
  static readonly MUSIC_END: Sound;
  static readonly MUSIC_GAME: Sound;
  static readonly MUSIC_MENU: Sound;
  static readonly MUSIC_NETHER_BASALT_DELTAS: Sound;
  static readonly MUSIC_NETHER_CRIMSON_FOREST: Sound;
  static readonly MUSIC_NETHER_NETHER_WASTES: Sound;
  static readonly MUSIC_NETHER_SOUL_SAND_VALLEY: Sound;
  static readonly MUSIC_NETHER_WARPED_FOREST: Sound;
  static readonly MUSIC_OVERWORLD_DRIPSTONE_CAVES: Sound;
  static readonly MUSIC_OVERWORLD_FROZEN_PEAKS: Sound;
  static readonly MUSIC_OVERWORLD_GROVE: Sound;
  static readonly MUSIC_OVERWORLD_JAGGED_PEAKS: Sound;
  static readonly MUSIC_OVERWORLD_LUSH_CAVES: Sound;
  static readonly MUSIC_OVERWORLD_MEADOW: Sound;
  static readonly MUSIC_OVERWORLD_SNOWY_SLOPES: Sound;
  static readonly MUSIC_OVERWORLD_STONY_PEAKS: Sound;
  static readonly MUSIC_UNDER_WATER: Sound;
  static readonly PARTICLE_SOUL_ESCAPE: Sound;
  static readonly UI_BUTTON_CLICK: Sound;
  static readonly UI_CARTOGRAPHY_TABLE_TAKE_RESULT: Sound;
  static readonly UI_LOOM_SELECT_PATTERN: Sound;
  static readonly UI_LOOM_TAKE_RESULT: Sound;
  static readonly UI_STONECUTTER_SELECT_RECIPE: Sound;
  static readonly UI_STONECUTTER_TAKE_RESULT: Sound;
  static readonly UI_TOAST_CHALLENGE_COMPLETE: Sound;
  static readonly UI_TOAST_IN: Sound;
  static readonly UI_TOAST_OUT: Sound;
  static readonly WEATHER_RAIN: Sound;
  static readonly WEATHER_RAIN_ABOVE: Sound;
  static valueOf(name: string): Sound;
  static values(): Sound[];
  getKey(): NamespacedKey;
}
/**
 * A note class to store a specific note.
*/
export class Note {
  /**
   * Creates a new note.
   *
   * @param note Internal note id. {@link #getId()} always return this
   *     value. The value has to be in the interval [0;24].
  */
  constructor(note: number);
  /**
   * Creates a new note.
   *
   * @param octave The octave where the note is in. Has to be 0 - 2.
   * @param tone The tone within the octave. If the octave is 2 the note has
   *     to be F#.
   * @param sharped Set if the tone is sharped (e.g. for F#).
  */
  constructor(octave: number, tone: Tone, sharped: boolean);
  /**
   * Creates a new note for a flat tone, such as A-flat.
   *
   * @param octave The octave where the note is in. Has to be 0 - 1.
   * @param tone The tone within the octave.
   * @return The new note.
  */
  static flat(octave: number, tone: Tone): Note;
  /**
   * Creates a new note for a sharp tone, such as A-sharp.
   *
   * @param octave The octave where the note is in. Has to be 0 - 2.
   * @param tone The tone within the octave. If the octave is 2 the note has
   *     to be F#.
   * @return The new note.
  */
  static sharp(octave: number, tone: Tone): Note;
  /**
   * Creates a new note for a natural tone, such as A-natural.
   *
   * @param octave The octave where the note is in. Has to be 0 - 1.
   * @param tone The tone within the octave.
   * @return The new note.
  */
  static natural(octave: number, tone: Tone): Note;
  /**
   * @return The note a semitone above this one.
  */
  sharped(): Note;
  /**
   * @return The note a semitone below this one.
  */
  flattened(): Note;
  /**
   * Returns the internal id of this note.
   *
   * @return the internal id of this note.
   * @deprecated Magic value
  */
  getId(): number;
  /**
   * Returns the octave of this note.
   *
   * @return the octave of this note.
  */
  getOctave(): number;
  /**
   * Returns the tone of this note.
   *
   * @return the tone of this note.
  */
  getTone(): Tone;
  /**
   * Returns if this note is sharped.
   *
   * @return if this note is sharped.
  */
  isSharped(): boolean;
  hashCode(): number;
  equals(obj: any): boolean;
  toString(): string;
}
export class StructureType extends Keyed {
  /**
   * Mineshafts are underground structures which consist of branching mining
   * tunnels with wooden supports and broken rails.
   * 
   * They are the only place where cave spider spawners and minecarts with
   * chests can be found naturally.
  */
  static readonly MINESHAFT: StructureType;
  /**
   * Villages are naturally generating structures that form above ground.
   * 
   * They are usually generated in desert, plains, taiga, and savanna biomes
   * and are a site for villager spawns, with whom the player can trade.
  */
  static readonly VILLAGE: StructureType;
  /**
   * Nether fortresses are very large complexes that mainly consist of
   * netherbricks.
   * 
   * They contain blaze spawners, nether wart farms, and loot chests. They are
   * only generated in the nether dimension.
  */
  static readonly NETHER_FORTRESS: StructureType;
  /**
   * Strongholds are underground structures that consist of many rooms,
   * libraries, and an end portal room.
   * 
   * They can be found using an {@link Material#ENDER_EYE}.
  */
  static readonly STRONGHOLD: StructureType;
  /**
   * Jungle pyramids (also known as jungle temples) are found in jungles.
   * 
   * They are usually composed of cobblestone and mossy cobblestone. They
   * consist of three floors, with the bottom floor containing treasure
   * chests.
  */
  static readonly JUNGLE_PYRAMID: StructureType;
  /**
   * Ocean ruins are clusters of many different blocks that generate
   * underwater in ocean biomes (as well as on the surface of beaches).
   * 
   * They come in my different variations. The cold variants consist primarily
   * of stone brick, and the warm variants consist of sandstone.
  */
  static readonly OCEAN_RUIN: StructureType;
  /**
   * Desert pyramids (also known as desert temples) are found in deserts.
   * 
   * They are usually composed of sandstone and stained terracotta.
  */
  static readonly DESERT_PYRAMID: StructureType;
  /**
   * Igloos are structures that generate in snowy biomes.
   * 
   * They consist of the house, as well as a basement.
  */
  static readonly IGLOO: StructureType;
  /**
   * Swamp huts (also known as witch huts) generate in swamp biomes and have
   * the ability to spawn witches.
  */
  static readonly SWAMP_HUT: StructureType;
  /**
   * Ocean monuments are underwater structures.
   * 
   * They are usually composed on all three different prismarine types and sea
   * lanterns. They are the only place guardians and elder guardians spawn
   * naturally.
  */
  static readonly OCEAN_MONUMENT: StructureType;
  /**
   * End Cities are tall castle-like structures that generate in the outer
   * island of the End dimension.
   * 
   * They consist primarily of end stone bricks, purpur blocks, and end rods.
   * They are the only place where shulkers can be found.
  */
  static readonly END_CITY: StructureType;
  /**
   * Mansions (also known as woodland mansions) are massive house structures
   * that generate in dark forests, containing a wide variety of rooms.
   * 
   * They are the only place where evokers, vindicators, and vexes spawn
   * naturally (but only once)
  */
  static readonly WOODLAND_MANSION: StructureType;
  /**
   * Buried treasure consists of a single chest buried in the beach sand or
   * gravel, with random loot in it.
  */
  static readonly BURIED_TREASURE: StructureType;
  /**
   * Shipwrecks are structures that generate on the floor of oceans or
   * beaches.
   * 
   * They are made up of wood materials, and contain 1-3 loot chests. They can
   * generate sideways, upside-down, or upright.
  */
  static readonly SHIPWRECK: StructureType;
  /**
   * Pillager outposts may contain crossbows.
  */
  static readonly PILLAGER_OUTPOST: StructureType;
  /**
   * Nether fossils.
  */
  static readonly NETHER_FOSSIL: StructureType;
  /**
   * Ruined portal.
  */
  static readonly RUINED_PORTAL: StructureType;
  /**
   * Bastion remnant.
  */
  static readonly BASTION_REMNANT: StructureType;
  /**
   * Get the name of this structure. This is case-sensitive when used in
   * commands.
   *
   * @return the name of this structure
  */
  getName(): string;
  /**
   * Get the {@link org.bukkit.map.MapCursor.Type} that this structure can use on maps. If
   * this is null, this structure will not appear on explorer maps.
   *
   * @return the {@link org.bukkit.map.MapCursor.Type} or null.
  */
  getMapIcon(): org_bukkit_map_MapCursor_Type | null;
  equals(other: any): boolean;
  hashCode(): number;
  toString(): string;
  /**
   * Get all registered {@link StructureType}s.
   *
   * @return an immutable copy of registered structure types.
  */
  static getStructureTypes(): Map<string, StructureType>;
  /**
   * Return the namespaced identifier for this object.
   *
   * @return this object's key
  */
  getKey(): NamespacedKey;
}
export class Fluid extends Enum<Fluid> {
  static readonly WATER: Fluid;
  static readonly FLOWING_WATER: Fluid;
  static readonly LAVA: Fluid;
  static readonly FLOWING_LAVA: Fluid;
  static valueOf(name: string): Fluid;
  static values(): Fluid[];
  getKey(): NamespacedKey;
}
/**
 * Represents various types of portals that can be made in a world.
*/
export class PortalType extends Enum<PortalType> {
  /**
   * This is a Nether portal, made of obsidian.
  */
  static readonly NETHER: PortalType;
  /**
   * This is an Ender portal.
  */
  static readonly ENDER: PortalType;
  /**
   * This is a custom Plugin portal.
  */
  static readonly CUSTOM: PortalType;
  static valueOf(name: string): PortalType;
  static values(): PortalType[];
}
/**
 * Represents the different growth states of crops
*/
export class CropState extends Enum<CropState> {
  /**
   * State when first seeded
  */
  static readonly SEEDED: CropState;
  /**
   * First growth stage
  */
  static readonly GERMINATED: CropState;
  /**
   * Second growth stage
  */
  static readonly VERY_SMALL: CropState;
  /**
   * Third growth stage
  */
  static readonly SMALL: CropState;
  /**
   * Fourth growth stage
  */
  static readonly MEDIUM: CropState;
  /**
   * Fifth growth stage
  */
  static readonly TALL: CropState;
  /**
   * Almost ripe stage
  */
  static readonly VERY_TALL: CropState;
  /**
   * Ripe stage
  */
  static readonly RIPE: CropState;
  static valueOf(name: string): CropState;
  static values(): CropState[];
  /**
   * Gets the associated data value representing this growth state
   *
   * @return A byte containing the data value of this growth state
   * @deprecated Magic value
  */
  getData(): number;
  /**
   * Gets the CropState with the given data value
   *
   * @param data Data value to fetch
   * @return The {@link CropState} representing the given value, or null if
   *     it doesn't exist
   * @deprecated Magic value
  */
  static getByData(data: number): CropState | null;
}
/**
 * Represents a generic Mojang game event.
*/
export class GameEvent extends Keyed {
  static readonly BLOCK_ATTACH: GameEvent;
  static readonly BLOCK_CHANGE: GameEvent;
  static readonly BLOCK_CLOSE: GameEvent;
  static readonly BLOCK_DESTROY: GameEvent;
  static readonly BLOCK_DETACH: GameEvent;
  static readonly BLOCK_OPEN: GameEvent;
  static readonly BLOCK_PLACE: GameEvent;
  static readonly BLOCK_PRESS: GameEvent;
  static readonly BLOCK_SWITCH: GameEvent;
  static readonly BLOCK_UNPRESS: GameEvent;
  static readonly BLOCK_UNSWITCH: GameEvent;
  static readonly CONTAINER_CLOSE: GameEvent;
  static readonly CONTAINER_OPEN: GameEvent;
  static readonly DISPENSE_FAIL: GameEvent;
  static readonly DRINKING_FINISH: GameEvent;
  static readonly EAT: GameEvent;
  static readonly ELYTRA_FREE_FALL: GameEvent;
  static readonly ENTITY_DAMAGED: GameEvent;
  static readonly ENTITY_KILLED: GameEvent;
  static readonly ENTITY_PLACE: GameEvent;
  static readonly EQUIP: GameEvent;
  static readonly EXPLODE: GameEvent;
  static readonly FISHING_ROD_CAST: GameEvent;
  static readonly FISHING_ROD_REEL_IN: GameEvent;
  static readonly FLAP: GameEvent;
  static readonly FLUID_PICKUP: GameEvent;
  static readonly FLUID_PLACE: GameEvent;
  static readonly HIT_GROUND: GameEvent;
  static readonly LIGHTNING_STRIKE: GameEvent;
  static readonly MINECART_MOVING: GameEvent;
  static readonly MOB_INTERACT: GameEvent;
  static readonly PISTON_CONTRACT: GameEvent;
  static readonly PISTON_EXTEND: GameEvent;
  static readonly PRIME_FUSE: GameEvent;
  static readonly PROJECTILE_LAND: GameEvent;
  static readonly PROJECTILE_SHOOT: GameEvent;
  static readonly RAVAGER_ROAR: GameEvent;
  static readonly RING_BELL: GameEvent;
  static readonly SHEAR: GameEvent;
  static readonly SHULKER_CLOSE: GameEvent;
  static readonly SHULKER_OPEN: GameEvent;
  static readonly SPLASH: GameEvent;
  static readonly STEP: GameEvent;
  static readonly SWIM: GameEvent;
  static readonly WOLF_SHAKING: GameEvent;
  /**
   * Return the namespaced identifier for this object.
   *
   * @return this object's key
  */
  getKey(): NamespacedKey;
  /**
   * Returns a {@link GameEvent} by a {@link NamespacedKey}.
   *
   * @param namespacedKey the key
   * @return the event or null
  */
  static getByKey(namespacedKey: NamespacedKey): GameEvent | null;
  /**
   * Returns the set of all GameEvents.
   *
   * @return the memoryKeys
  */
  static values(): Collection<GameEvent>;
}
/**
 * Annotation for types, whose nullability is not well defined, so
 * {@link org.jetbrains.annotations.NotNull} nor
 * {@link org.jetbrains.annotations.Nullable} is applicable. For example when
 * interface defines a method, whose nullability depends on the implementation.
 *
 * @deprecated This should generally not be used in any new API code as it
 * suggests a bad API design.
*/
export class UndefinedNullability {

}
/**
 * Tree and organic structure types.
*/
export class TreeType extends Enum<TreeType> {
  /**
   * Regular tree, no branches
  */
  static readonly TREE: TreeType;
  /**
   * Regular tree, extra tall with branches
  */
  static readonly BIG_TREE: TreeType;
  /**
   * Redwood tree, shaped like a pine tree
  */
  static readonly REDWOOD: TreeType;
  /**
   * Tall redwood tree with just a few leaves at the top
  */
  static readonly TALL_REDWOOD: TreeType;
  /**
   * Birch tree
  */
  static readonly BIRCH: TreeType;
  /**
   * Standard jungle tree; 4 blocks wide and tall
  */
  static readonly JUNGLE: TreeType;
  /**
   * Smaller jungle tree; 1 block wide
  */
  static readonly SMALL_JUNGLE: TreeType;
  /**
   * Jungle tree with cocoa plants; 1 block wide
  */
  static readonly COCOA_TREE: TreeType;
  /**
   * Small bush that grows in the jungle
  */
  static readonly JUNGLE_BUSH: TreeType;
  /**
   * Big red mushroom; short and fat
  */
  static readonly RED_MUSHROOM: TreeType;
  /**
   * Big brown mushroom; tall and umbrella-like
  */
  static readonly BROWN_MUSHROOM: TreeType;
  /**
   * Swamp tree (regular with vines on the side)
  */
  static readonly SWAMP: TreeType;
  /**
   * Acacia tree.
  */
  static readonly ACACIA: TreeType;
  /**
   * Dark Oak tree.
  */
  static readonly DARK_OAK: TreeType;
  /**
   * Mega redwood tree; 4 blocks wide and tall
  */
  static readonly MEGA_REDWOOD: TreeType;
  /**
   * Tall birch tree
  */
  static readonly TALL_BIRCH: TreeType;
  /**
   * Large plant native to The End
  */
  static readonly CHORUS_PLANT: TreeType;
  /**
   * Large crimson fungus native to the nether
  */
  static readonly CRIMSON_FUNGUS: TreeType;
  /**
   * Large warped fungus native to the nether
  */
  static readonly WARPED_FUNGUS: TreeType;
  /**
   * Tree with large roots which grows above lush caves
  */
  static readonly AZALEA: TreeType;
  static valueOf(name: string): TreeType;
  static values(): TreeType[];
}
/**
 * Represents a tag that may be defined by the server or a resource pack to
 * group like things together.
 *
 * Note that whilst all tags defined within this interface must be present in
 * implementations, their existence is not guaranteed across future versions.
 *
 * Custom tags defined by Paper are not present (as constants) in this class.
 * To access them please refer to {@link com.destroystokyo.paper.MaterialTags}
 * and {@link io.papermc.paper.tag.EntityTags}.
 *
 * @param  the type of things grouped by this tag
*/
export class Tag<T> extends Keyed {
  /**
   * Key for the built in block registry.
  */
  static readonly REGISTRY_BLOCKS: string;
  /**
   * Vanilla block tag representing all colors of wool.
  */
  static readonly WOOL: Tag<Material>;
  /**
   * Vanilla block tag representing all plank variants.
  */
  static readonly PLANKS: Tag<Material>;
  /**
   * Vanilla block tag representing all regular/mossy/cracked/chiseled stone
   * bricks.
  */
  static readonly STONE_BRICKS: Tag<Material>;
  /**
   * Vanilla block tag representing all wooden buttons.
  */
  static readonly WOODEN_BUTTONS: Tag<Material>;
  /**
   * Vanilla block tag representing all buttons (inherits from
   * {@link #WOODEN_BUTTONS}.
  */
  static readonly BUTTONS: Tag<Material>;
  /**
   * Vanilla block tag representing all colors of carpet.
  */
  static readonly CARPETS: Tag<Material>;
  /**
   * Vanilla block tag representing all wooden doors.
  */
  static readonly WOODEN_DOORS: Tag<Material>;
  /**
   * Vanilla block tag representing all wooden stairs.
  */
  static readonly WOODEN_STAIRS: Tag<Material>;
  /**
   * Vanilla block tag representing all wooden slabs.
  */
  static readonly WOODEN_SLABS: Tag<Material>;
  /**
   * Vanilla block tag representing all wooden fences.
  */
  static readonly WOODEN_FENCES: Tag<Material>;
  /**
   * Vanilla block tag representing all pressure plates.
  */
  static readonly PRESSURE_PLATES: Tag<Material>;
  /**
   * Vanilla block tag representing all wooden pressure plates.
  */
  static readonly WOODEN_PRESSURE_PLATES: Tag<Material>;
  /**
   * Vanilla block tag representing all stone pressure plates.
  */
  static readonly STONE_PRESSURE_PLATES: Tag<Material>;
  /**
   * Vanilla block tag representing all wooden trapdoors.
  */
  static readonly WOODEN_TRAPDOORS: Tag<Material>;
  /**
   * Vanilla block tag representing all doors (inherits from
   * {@link #WOODEN_DOORS}.
  */
  static readonly DOORS: Tag<Material>;
  /**
   * Vanilla block tag representing all sapling variants.
  */
  static readonly SAPLINGS: Tag<Material>;
  /**
   * Vanilla block tag representing all log and bark variants that burn.
  */
  static readonly LOGS_THAT_BURN: Tag<Material>;
  /**
   * Vanilla block tag representing all log and bark variants.
  */
  static readonly LOGS: Tag<Material>;
  /**
   * Vanilla block tag representing all dark oak log and bark variants.
  */
  static readonly DARK_OAK_LOGS: Tag<Material>;
  /**
   * Vanilla block tag representing all oak log and bark variants.
  */
  static readonly OAK_LOGS: Tag<Material>;
  /**
   * Vanilla block tag representing all birch log and bark variants.
  */
  static readonly BIRCH_LOGS: Tag<Material>;
  /**
   * Vanilla block tag representing all acacia log and bark variants.
  */
  static readonly ACACIA_LOGS: Tag<Material>;
  /**
   * Vanilla block tag representing all jungle log and bark variants.
  */
  static readonly JUNGLE_LOGS: Tag<Material>;
  /**
   * Vanilla block tag representing all spruce log and bark variants.
  */
  static readonly SPRUCE_LOGS: Tag<Material>;
  /**
   * Vanilla block tag representing all crimson stems.
  */
  static readonly CRIMSON_STEMS: Tag<Material>;
  /**
   * Vanilla block tag representing all warped stems.
  */
  static readonly WARPED_STEMS: Tag<Material>;
  /**
   * Vanilla block tag representing all banner blocks.
  */
  static readonly BANNERS: Tag<Material>;
  /**
   * Vanilla block tag representing all sand blocks.
  */
  static readonly SAND: Tag<Material>;
  /**
   * Vanilla block tag representing all stairs.
  */
  static readonly STAIRS: Tag<Material>;
  /**
   * Vanilla block tag representing all slabs.
  */
  static readonly SLABS: Tag<Material>;
  /**
   * Vanilla block tag representing all walls.
  */
  static readonly WALLS: Tag<Material>;
  /**
   * Vanilla block tag representing all damaged and undamaged anvils.
  */
  static readonly ANVIL: Tag<Material>;
  /**
   * Vanilla block tag representing all Minecart rails.
  */
  static readonly RAILS: Tag<Material>;
  /**
   * Vanilla block tag representing all leaves fans.
  */
  static readonly LEAVES: Tag<Material>;
  /**
   * Vanilla block tag representing all trapdoors (inherits from
   * {@link #WOODEN_TRAPDOORS}.
  */
  static readonly TRAPDOORS: Tag<Material>;
  /**
   * Vanilla block tag representing all empty and filled flower pots.
  */
  static readonly FLOWER_POTS: Tag<Material>;
  /**
   * Vanilla block tag representing all small flowers.
  */
  static readonly SMALL_FLOWERS: Tag<Material>;
  /**
   * Vanilla block tag representing all beds.
  */
  static readonly BEDS: Tag<Material>;
  /**
   * Vanilla block tag representing all fences.
  */
  static readonly FENCES: Tag<Material>;
  /**
   * Vanilla block tag representing all tall flowers.
  */
  static readonly TALL_FLOWERS: Tag<Material>;
  /**
   * Vanilla block tag representing all flowers.
  */
  static readonly FLOWERS: Tag<Material>;
  /**
   * Vanilla block tag representing all piglin repellents.
  */
  static readonly PIGLIN_REPELLENTS: Tag<Material>;
  /**
   * Vanilla block tag representing all gold ores.
  */
  static readonly GOLD_ORES: Tag<Material>;
  /**
   * Vanilla block tag representing all iron ores.
  */
  static readonly IRON_ORES: Tag<Material>;
  /**
   * Vanilla block tag representing all diamond ores.
  */
  static readonly DIAMOND_ORES: Tag<Material>;
  /**
   * Vanilla block tag representing all redstone ores.
  */
  static readonly REDSTONE_ORES: Tag<Material>;
  /**
   * Vanilla block tag representing all lapis ores.
  */
  static readonly LAPIS_ORES: Tag<Material>;
  /**
   * Vanilla block tag representing all coal ores.
  */
  static readonly COAL_ORES: Tag<Material>;
  /**
   * Vanilla block tag representing all emerald ores.
  */
  static readonly EMERALD_ORES: Tag<Material>;
  /**
   * Vanilla block tag representing all copper ores.
  */
  static readonly COPPER_ORES: Tag<Material>;
  /**
   * Vanilla block tag representing all non flammable wood.
  */
  static readonly NON_FLAMMABLE_WOOD: Tag<Material>;
  /**
   * Vanilla block tag representing all candles.
  */
  static readonly CANDLES: Tag<Material>;
  /**
   * Vanilla block tag representing all dirt.
  */
  static readonly DIRT: Tag<Material>;
  /**
   * Vanilla block tag representing all terracotta.
  */
  static readonly TERRACOTTA: Tag<Material>;
  /**
   * Vanilla block tag denoting blocks that enderman may pick up and hold.
  */
  static readonly ENDERMAN_HOLDABLE: Tag<Material>;
  /**
   * Vanilla block tag denoting ice blocks.
  */
  static readonly ICE: Tag<Material>;
  /**
   * Vanilla block tag denoting all valid mob spawn positions.
  */
  static readonly VALID_SPAWN: Tag<Material>;
  /**
   * Vanilla block tag denoting impermeable blocks which do not drip fluids.
  */
  static readonly IMPERMEABLE: Tag<Material>;
  /**
   * Vanilla block tag denoting all underwater blocks which may be bonemealed.
  */
  static readonly UNDERWATER_BONEMEALS: Tag<Material>;
  /**
   * Vanilla block tag representing all coral blocks.
  */
  static readonly CORAL_BLOCKS: Tag<Material>;
  /**
   * Vanilla block tag representing all wall corals.
  */
  static readonly WALL_CORALS: Tag<Material>;
  /**
   * Vanilla block tag representing all coral plants.
  */
  static readonly CORAL_PLANTS: Tag<Material>;
  /**
   * Vanilla block tag representing all coral.
  */
  static readonly CORALS: Tag<Material>;
  /**
   * Vanilla block tag denoting all blocks bamboo may be planted on.
  */
  static readonly BAMBOO_PLANTABLE_ON: Tag<Material>;
  /**
   * Vanilla block tag representing all standing signs.
  */
  static readonly STANDING_SIGNS: Tag<Material>;
  /**
   * Vanilla block tag representing all wall signs.
  */
  static readonly WALL_SIGNS: Tag<Material>;
  /**
   * Vanilla block tag representing all signs.
  */
  static readonly SIGNS: Tag<Material>;
  /**
   * Vanilla block tag representing all blocks immune to dragons.
  */
  static readonly DRAGON_IMMUNE: Tag<Material>;
  /**
   * Vanilla block tag representing all blocks immune to withers.
  */
  static readonly WITHER_IMMUNE: Tag<Material>;
  /**
   * Vanilla block tag representing all base blocks used for wither summoning.
  */
  static readonly WITHER_SUMMON_BASE_BLOCKS: Tag<Material>;
  /**
   * Vanilla block tag representing all beehives.
  */
  static readonly BEEHIVES: Tag<Material>;
  /**
   * Vanilla block tag representing all crops.
  */
  static readonly CROPS: Tag<Material>;
  /**
   * Vanilla block tag representing all bee growables.
  */
  static readonly BEE_GROWABLES: Tag<Material>;
  /**
   * Vanilla block tag representing all portals.
  */
  static readonly PORTALS: Tag<Material>;
  /**
   * Vanilla block tag representing all fire blocks.
  */
  static readonly FIRE: Tag<Material>;
  /**
   * Vanilla block tag representing all nylium blocks.
  */
  static readonly NYLIUM: Tag<Material>;
  /**
   * Vanilla block tag representing all wart blocks.
  */
  static readonly WART_BLOCKS: Tag<Material>;
  /**
   * Vanilla block tag representing all beacon base blocks.
  */
  static readonly BEACON_BASE_BLOCKS: Tag<Material>;
  /**
   * Vanilla block tag representing all blocks affected by the soul speed
   * enchantment.
  */
  static readonly SOUL_SPEED_BLOCKS: Tag<Material>;
  /**
   * Vanilla block tag representing all wall post overrides.
  */
  static readonly WALL_POST_OVERRIDE: Tag<Material>;
  /**
   * Vanilla block tag representing all climbable blocks.
  */
  static readonly CLIMBABLE: Tag<Material>;
  /**
   * Vanilla block tag representing all blocks which reset fall damage.
  */
  static readonly FALL_DAMAGE_RESETTING: Tag<Material>;
  /**
   * Vanilla block tag representing all shulker boxes.
  */
  static readonly SHULKER_BOXES: Tag<Material>;
  /**
   * Vanilla block tag representing all hoglin repellents.
  */
  static readonly HOGLIN_REPELLENTS: Tag<Material>;
  /**
   * Vanilla block tag representing all soul fire base blocks.
  */
  static readonly SOUL_FIRE_BASE_BLOCKS: Tag<Material>;
  /**
   * Vanilla block tag representing all warm strider blocks.
  */
  static readonly STRIDER_WARM_BLOCKS: Tag<Material>;
  /**
   * Vanilla block tag representing all campfires.
  */
  static readonly CAMPFIRES: Tag<Material>;
  /**
   * Vanilla block tag representing all blocks guarded by piglins.
  */
  static readonly GUARDED_BY_PIGLINS: Tag<Material>;
  /**
   * Vanilla block tag representing all blocks that prevent inside mob
   * spawning.
  */
  static readonly PREVENT_MOB_SPAWNING_INSIDE: Tag<Material>;
  /**
   * Vanilla block tag representing all fence gates.
  */
  static readonly FENCE_GATES: Tag<Material>;
  /**
   * Vanilla block tag representing all unstable bottom center blocks.
  */
  static readonly UNSTABLE_BOTTOM_CENTER: Tag<Material>;
  static readonly MUSHROOM_GROW_BLOCK: Tag<Material>;
  /**
   * Vanilla block tag representing all blocks that burn forever in the
   * overworld.
  */
  static readonly INFINIBURN_OVERWORLD: Tag<Material>;
  /**
   * Vanilla block tag representing all blocks that burn forever in the
   * nether.
  */
  static readonly INFINIBURN_NETHER: Tag<Material>;
  /**
   * Vanilla block tag representing all blocks that burn forever in the end.
  */
  static readonly INFINIBURN_END: Tag<Material>;
  /**
   * Vanilla block tag representing the overworld base material.
  */
  static readonly BASE_STONE_OVERWORLD: Tag<Material>;
  /**
   * Vanilla block tag representing all blocks that may be replaced by ores.
  */
  static readonly STONE_ORE_REPLACEABLES: Tag<Material>;
  /**
   * Vanilla block tag representing all blocks that may be replaced by
   * deepslate ores.
  */
  static readonly DEEPSLATE_ORE_REPLACEABLES: Tag<Material>;
  /**
   * Vanilla block tag representing the nether base material.
  */
  static readonly BASE_STONE_NETHER: Tag<Material>;
  /**
   * Vanilla block tag representing all candle cakes.
  */
  static readonly CANDLE_CAKES: Tag<Material>;
  /**
   * Vanilla block tag representing all cauldrons.
  */
  static readonly CAULDRONS: Tag<Material>;
  /**
   * Vanilla block tag representing all blocks that make cryustal sounds.
  */
  static readonly CRYSTAL_SOUND_BLOCKS: Tag<Material>;
  /**
   * Vanilla block tag representing all blocks that play muffled step sounds.
  */
  static readonly INSIDE_STEP_SOUND_BLOCKS: Tag<Material>;
  /**
   * Vanilla block tag representing all blocks that block vibration signals.
  */
  static readonly OCCLUDES_VIBRATION_SIGNALS: Tag<Material>;
  /**
   * Vanilla block tag representing all blocks that are replaceable by
   * dripstone.
  */
  static readonly DRIPSTONE_REPLACEABLE: Tag<Material>;
  /**
   * Vanilla block tag representing all cave vines.
  */
  static readonly CAVE_VINES: Tag<Material>;
  /**
   * Vanilla block tag representing all blocks replaceable by moss.
  */
  static readonly MOSS_REPLACEABLE: Tag<Material>;
  /**
   * Vanilla block tag representing all blocks replaceable by lush ground.
  */
  static readonly LUSH_GROUND_REPLACEABLE: Tag<Material>;
  /**
   * Vanilla block tag representing all blocks replaceable by azalea root.
  */
  static readonly AZALEA_ROOT_REPLACEABLE: Tag<Material>;
  /**
   * Vanilla block tag representing all blocks which small dripleaf can be
   * placed on.
  */
  static readonly SMALL_DRIPLEAF_PLACEABLE: Tag<Material>;
  /**
   * Vanilla block tag representing all blocks which big dripleaf can be
   * placed on.
  */
  static readonly BIG_DRIPLEAF_PLACEABLE: Tag<Material>;
  /**
   * Vanilla block tag representing all snow blocks.
  */
  static readonly SNOW: Tag<Material>;
  /**
   * Vanilla block tag representing all blocks mineable with an axe.
  */
  static readonly MINEABLE_AXE: Tag<Material>;
  /**
   * Vanilla block tag representing all blocks mineable with a hoe.
  */
  static readonly MINEABLE_HOE: Tag<Material>;
  /**
   * Vanilla block tag representing all blocks mineable with a pickaxe.
  */
  static readonly MINEABLE_PICKAXE: Tag<Material>;
  /**
   * Vanilla block tag representing all blocks mineable with a shovel.
  */
  static readonly MINEABLE_SHOVEL: Tag<Material>;
  /**
   * Vanilla block tag representing all blocks which require a diamond tool.
  */
  static readonly NEEDS_DIAMOND_TOOL: Tag<Material>;
  /**
   * Vanilla block tag representing all blocks which require an iron tool.
  */
  static readonly NEEDS_IRON_TOOL: Tag<Material>;
  /**
   * Vanilla block tag representing all blocks which require a stone tool.
  */
  static readonly NEEDS_STONE_TOOL: Tag<Material>;
  /**
   * Vanilla block tag representing all blocks which will not be replaced by
   * world generation features.
  */
  static readonly FEATURES_CANNOT_REPLACE: Tag<Material>;
  /**
   * Vanilla block tag representing all blocks which lava pools will not
   * replace.
  */
  static readonly LAVA_POOL_STONE_CANNOT_REPLACE: Tag<Material>;
  /**
   * Vanilla block tag representing all blocks which geodes will not spawn in.
  */
  static readonly GEODE_INVALID_BLOCKS: Tag<Material>;
  /**
   * Vanilla block tag representing all blocks which animals will spawn on.
  */
  static readonly ANIMALS_SPAWNABLE_ON: Tag<Material>;
  /**
   * Vanilla block tag representing all blocks which axolotls will spawn on.
  */
  static readonly AXOLOTLS_SPAWNABLE_ON: Tag<Material>;
  /**
   * Vanilla block tag representing all blocks which goats will spawn on.
  */
  static readonly GOATS_SPAWNABLE_ON: Tag<Material>;
  /**
   * Vanilla block tag representing all blocks which mooshrooms will spawn on.
  */
  static readonly MOOSHROOMS_SPAWNABLE_ON: Tag<Material>;
  /**
   * Vanilla block tag representing all blocks which parrots will spawn on.
  */
  static readonly PARROTS_SPAWNABLE_ON: Tag<Material>;
  /**
   * Vanilla block tag representing all blocks which polar bears will spawn
   * on.
  */
  static readonly POLAR_BEARS_SPAWNABLE_ON_IN_FROZEN_OCEAN: Tag<Material>;
  /**
   * Vanilla block tag representing all blocks which rabbits will spawn on.
  */
  static readonly RABBITS_SPAWNABLE_ON: Tag<Material>;
  /**
   * Vanilla block tag representing all blocks which foxes will spawn on.
  */
  static readonly FOXES_SPAWNABLE_ON: Tag<Material>;
  /**
   * Vanilla block tag representing all blocks which wolves will spawn on.
  */
  static readonly WOLVES_SPAWNABLE_ON: Tag<Material>;
  /**
   * Vanilla block tag representing all blocks which azaleas will grow on.
  */
  static readonly AZALEA_GROWS_ON: Tag<Material>;
  /**
   * Vanilla block tag representing all plant blocks which may be replaced.
  */
  static readonly REPLACEABLE_PLANTS: Tag<Material>;
  /**
   * Key for the built in item registry.
  */
  static readonly REGISTRY_ITEMS: string;
  /**
   * Vanilla item tag representing all items loved by piglins.
  */
  static readonly ITEMS_PIGLIN_LOVED: Tag<Material>;
  /**
   * Vanilla item tag representing all items ignored by piglin babies.
  */
  static readonly IGNORED_BY_PIGLIN_BABIES: Tag<Material>;
  /**
   * Vanilla item tag representing all piglin food.
  */
  static readonly PIGLIN_FOOD: Tag<Material>;
  /**
   * Vanilla item tag representing all fox food.
  */
  static readonly FOX_FOOD: Tag<Material>;
  /**
   * Vanilla item tag representing all banner items.
  */
  static readonly ITEMS_BANNERS: Tag<Material>;
  /**
   * Vanilla item tag representing all boat items.
  */
  static readonly ITEMS_BOATS: Tag<Material>;
  /**
   * Vanilla item tag representing all fish items.
  */
  static readonly ITEMS_FISHES: Tag<Material>;
  /**
   * Vanilla item tag representing all music disc items.
  */
  static readonly ITEMS_MUSIC_DISCS: Tag<Material>;
  /**
   * Vanilla item tag representing all music disc items dropped by creepers.
  */
  static readonly ITEMS_CREEPER_DROP_MUSIC_DISCS: Tag<Material>;
  /**
   * Vanilla item tag representing all coal items.
  */
  static readonly ITEMS_COALS: Tag<Material>;
  /**
   * Vanilla item tag representing all arrow items.
  */
  static readonly ITEMS_ARROWS: Tag<Material>;
  /**
   * Vanilla item tag representing all books that may be placed on lecterns.
  */
  static readonly ITEMS_LECTERN_BOOKS: Tag<Material>;
  /**
   * Vanilla item tag representing all items that may be placed in beacons.
  */
  static readonly ITEMS_BEACON_PAYMENT_ITEMS: Tag<Material>;
  /**
   * Vanilla item tag representing all stone tool materials.
  */
  static readonly ITEMS_STONE_TOOL_MATERIALS: Tag<Material>;
  /**
   * Vanilla item tag representing all furnace materials.
  */
  static readonly ITEMS_FURNACE_MATERIALS: Tag<Material>;
  /**
   * Vanilla item tag representing all items that confer freeze immunity on
   * the wearer.
  */
  static readonly FREEZE_IMMUNE_WEARABLES: Tag<Material>;
  /**
   * Vanilla item tag representing all items which tempt axolotls.
  */
  static readonly AXOLOTL_TEMPT_ITEMS: Tag<Material>;
  /**
   * Vanilla item tag representing all items which are preferred for
   * harvesting clusters (unused).
  */
  static readonly CLUSTER_MAX_HARVESTABLES: Tag<Material>;
  /**
   * Key for the built in fluid registry.
  */
  static readonly REGISTRY_FLUIDS: string;
  /**
   * Vanilla fluid tag representing lava and flowing lava.
  */
  static readonly FLUIDS_LAVA: Tag<Fluid>;
  /**
   * Vanilla fluid tag representing water and flowing water.
  */
  static readonly FLUIDS_WATER: Tag<Fluid>;
  /**
   * Key for the built in entity registry.
  */
  static readonly REGISTRY_ENTITY_TYPES: string;
  /**
   * Vanilla tag representing skeletons.
  */
  static readonly ENTITY_TYPES_SKELETONS: Tag<EntityType>;
  /**
   * Vanilla tag representing raiders.
  */
  static readonly ENTITY_TYPES_RAIDERS: Tag<EntityType>;
  /**
   * Vanilla tag representing entities which can live in beehives.
  */
  static readonly ENTITY_TYPES_BEEHIVE_INHABITORS: Tag<EntityType>;
  /**
   * Vanilla tag representing arrows.
  */
  static readonly ENTITY_TYPES_ARROWS: Tag<EntityType>;
  /**
   * Vanilla tag representing projectiles.
  */
  static readonly ENTITY_TYPES_IMPACT_PROJECTILES: Tag<EntityType>;
  /**
   * Vanilla tag representing mobs which can walk on powder snow.
  */
  static readonly ENTITY_TYPES_POWDER_SNOW_WALKABLE_MOBS: Tag<EntityType>;
  /**
   * Vanilla tag representing which entities axolotls are always hostile to.
  */
  static readonly ENTITY_TYPES_AXOLOTL_ALWAYS_HOSTILES: Tag<EntityType>;
  /**
   * Vanilla tag representing axolotl targets.
  */
  static readonly ENTITY_TYPES_AXOLOTL_HUNT_TARGETS: Tag<EntityType>;
  /**
   * Vanilla tag representing entities immune from freezing.
  */
  static readonly ENTITY_TYPES_FREEZE_IMMUNE_ENTITY_TYPES: Tag<EntityType>;
  /**
   * Vanilla tag representing entities extra susceptible to freezing.
  */
  static readonly ENTITY_TYPES_FREEZE_HURTS_EXTRA_TYPES: Tag<EntityType>;
  /**
   * Key for the built-in entity registry
   * @deprecated use {@link #REGISTRY_ENTITY_TYPES}
  */
  static readonly REGISTRY_ENTITIES: string;
  /**
   * Vanilla entity tag representing arrow entities.
   * @deprecated use {@link #ENTITY_TYPES_ARROWS}
  */
  static readonly ARROWS: Tag<EntityType>;
  /**
   * Vanilla entity tag representing entities that live in beehives
   * @deprecated use {@link #ENTITY_TYPES_BEEHIVE_INHABITORS}
  */
  static readonly BEEHIVE_INHABITORS: Tag<EntityType>;
  /**
   * Vanilla entity tag representing projectiles that impact
   * @deprecated use {@link #ENTITY_TYPES_IMPACT_PROJECTILES}
  */
  static readonly IMPACT_PROJECTILES: Tag<EntityType>;
  /**
   * Vanilla entity tag for village raiders
   * @deprecated use {@link #ENTITY_TYPES_RAIDERS}
  */
  static readonly RAIDERS: Tag<EntityType>;
  /**
   * Vanilla entity tag for skeleton types
   * @deprecated use {@link #ENTITY_TYPES_SKELETONS}
  */
  static readonly SKELETONS: Tag<EntityType>;
  static readonly REGISTRY_GAME_EVENTS: string;
  /**
   * Tag for game events that trigger sculk sensors
  */
  static readonly GAME_EVENT_VIBRATIONS: Tag<GameEvent>;
  /**
   * Tag for game events that are ignored if the entity is sneaking
  */
  static readonly GAME_EVENT_IGNORE_VIBRATIONS_SNEAKING: Tag<GameEvent>;
  /**
   * Returns whether or not this tag has an entry for the specified item.
   *
   * @param item to check
   * @return if it is tagged
  */
  isTagged(item: T): boolean;
  /**
   * Gets an immutable set of all tagged items.
   *
   * @return set of tagged items
  */
  getValues(): Set<T>;
}
/**
 * Represents an object which has a {@link NamespacedKey} attached to it.
*/
export class Keyed extends net_kyori_adventure_key_Keyed {
  /**
   * Return the namespaced identifier for this object.
   *
   * @return this object's key
  */
  getKey(): NamespacedKey;
}
/**
 * A list of all Effects that can happen to entities.
*/
export class EntityEffect extends Enum<EntityEffect> {
  /**
   * Colored particles from a tipped arrow.
  */
  static readonly ARROW_PARTICLES: EntityEffect;
  /**
   * Rabbit jumping.
  */
  static readonly RABBIT_JUMP: EntityEffect;
  /**
   * When mobs get hurt.
  */
  static readonly HURT: EntityEffect;
  /**
   * When a mob dies.
   * 
   * This will cause client-glitches!
   *
   * @deprecated although this effect may trigger other events on non-living
   * entities, it's only supported usage is on living ones.
  */
  static readonly DEATH: EntityEffect;
  /**
   * The smoke when taming a wolf fails.
  */
  static readonly WOLF_SMOKE: EntityEffect;
  /**
   * The hearts when taming a wolf succeeds.
  */
  static readonly WOLF_HEARTS: EntityEffect;
  /**
   * When a wolf shakes (after being wet).
  */
  static readonly WOLF_SHAKE: EntityEffect;
  /**
   * When an entity eats a LONG_GRASS block.
   *
   * @deprecated although this effect may trigger other events on non-living
   * entities, it's only supported usage is on living ones.
  */
  static readonly SHEEP_EAT: EntityEffect;
  /**
   * When an Iron Golem gives a rose.
  */
  static readonly IRON_GOLEM_ROSE: EntityEffect;
  /**
   * Hearts from a villager.
  */
  static readonly VILLAGER_HEART: EntityEffect;
  /**
   * When a villager is angry.
  */
  static readonly VILLAGER_ANGRY: EntityEffect;
  /**
   * Happy particles from a villager.
  */
  static readonly VILLAGER_HAPPY: EntityEffect;
  /**
   * Magic particles from a witch.
  */
  static readonly WITCH_MAGIC: EntityEffect;
  /**
   * When a zombie transforms into a villager by shaking violently.
  */
  static readonly ZOMBIE_TRANSFORM: EntityEffect;
  /**
   * When a firework explodes.
  */
  static readonly FIREWORK_EXPLODE: EntityEffect;
  /**
   * Hearts from a breeding entity.
  */
  static readonly LOVE_HEARTS: EntityEffect;
  /**
   * Resets squid rotation.
  */
  static readonly SQUID_ROTATE: EntityEffect;
  /**
   * Silverfish entering block, spawner spawning.
  */
  static readonly ENTITY_POOF: EntityEffect;
  /**
   * Guardian plays the attack sound effect.
  */
  static readonly GUARDIAN_TARGET: EntityEffect;
  /**
   * Shield blocks attack.
  */
  static readonly SHIELD_BLOCK: EntityEffect;
  /**
   * Shield breaks.
  */
  static readonly SHIELD_BREAK: EntityEffect;
  /**
   * Armor stand is hit.
  */
  static readonly ARMOR_STAND_HIT: EntityEffect;
  /**
   * Entity hurt by thorns attack.
  */
  static readonly THORNS_HURT: EntityEffect;
  /**
   * Iron golem puts away rose.
  */
  static readonly IRON_GOLEM_SHEATH: EntityEffect;
  /**
   * Totem prevents entity death.
  */
  static readonly TOTEM_RESURRECT: EntityEffect;
  /**
   * Entity hurt due to drowning damage.
  */
  static readonly HURT_DROWN: EntityEffect;
  /**
   * Entity hurt due to explosion damage.
  */
  static readonly HURT_EXPLOSION: EntityEffect;
  /**
   * Dolphin has been fed and is locating a structure.
  */
  static readonly DOLPHIN_FED: EntityEffect;
  /**
   * Ravager has been stunned for 40 ticks.
  */
  static readonly RAVAGER_STUNNED: EntityEffect;
  /**
   * Cat taming failed.
  */
  static readonly CAT_TAME_FAIL: EntityEffect;
  /**
   * Cat taming succeeded.
  */
  static readonly CAT_TAME_SUCCESS: EntityEffect;
  /**
   * Villager splashes particles during a raid.
  */
  static readonly VILLAGER_SPLASH: EntityEffect;
  /**
   * Player's bad omen effect removed to start or increase raid difficult.
  */
  static readonly PLAYER_BAD_OMEN_RAID: EntityEffect;
  /**
   * Entity hurt due to berry bush. Prickly!
  */
  static readonly HURT_BERRY_BUSH: EntityEffect;
  /**
   * Fox chews the food in its mouth
  */
  static readonly FOX_CHEW: EntityEffect;
  /**
   * Entity teleported as a result of chorus fruit or as an enderman
  */
  static readonly TELEPORT_ENDER: EntityEffect;
  /**
   * Entity breaks item in main hand
  */
  static readonly BREAK_EQUIPMENT_MAIN_HAND: EntityEffect;
  /**
   * Entity breaks item in off hand
  */
  static readonly BREAK_EQUIPMENT_OFF_HAND: EntityEffect;
  /**
   * Entity breaks item in helmet slot
  */
  static readonly BREAK_EQUIPMENT_HELMET: EntityEffect;
  /**
   * Entity breaks item in chestplate slot
  */
  static readonly BREAK_EQUIPMENT_CHESTPLATE: EntityEffect;
  /**
   * Entity breaks item in legging slot
  */
  static readonly BREAK_EQUIPMENT_LEGGINGS: EntityEffect;
  /**
   * Entity breaks item in boot slot
  */
  static readonly BREAK_EQUIPMENT_BOOTS: EntityEffect;
  static valueOf(name: string): EntityEffect;
  static values(): EntityEffect[];
  /**
   * Gets the data value of this EntityEffect
   *
   * @return The data value
   * @deprecated Magic value
  */
  getData(): number;
  /**
   * Gets entity superclass which this affect is applicable to.
   *
   * @return applicable class
  */
  getApplicable(): Class<Entity>;
}
/**
 * Represents the various difficulty levels that are available.
*/
export class Difficulty extends Enum<Difficulty> {
  /**
   * Players regain health over time, hostile mobs don't spawn, the hunger
   * bar does not deplete.
  */
  static readonly PEACEFUL: Difficulty;
  /**
   * Hostile mobs spawn, enemies deal less damage than on normal difficulty,
   * the hunger bar does deplete and starving deals up to 5 hearts of
   * damage. (Default value)
  */
  static readonly EASY: Difficulty;
  /**
   * Hostile mobs spawn, enemies deal normal amounts of damage, the hunger
   * bar does deplete and starving deals up to 9.5 hearts of damage.
  */
  static readonly NORMAL: Difficulty;
  /**
   * Hostile mobs spawn, enemies deal greater damage than on normal
   * difficulty, the hunger bar does deplete and starving can kill players.
  */
  static readonly HARD: Difficulty;
  static valueOf(name: string): Difficulty;
  static values(): Difficulty[];
  /**
   * Gets the difficulty value associated with this Difficulty.
   *
   * @return An integer value of this difficulty
   * @deprecated Magic value
  */
  getValue(): number;
  translationKey(): string;
  /**
   * Gets the Difficulty represented by the specified value
   *
   * @param value Value to check
   * @return Associative {@link Difficulty} with the given value, or null if
   *     it doesn't exist
   * @deprecated Magic value
  */
  static getByValue(value: number): Difficulty | null;
}
/**
 * Represents the three different types of Sandstone
 * @deprecated use {@link org.bukkit.block.data.BlockData}
*/
export class SandstoneType extends Enum<SandstoneType> {
  static readonly CRACKED: SandstoneType;
  static readonly GLYPHED: SandstoneType;
  static readonly SMOOTH: SandstoneType;
  static valueOf(name: string): SandstoneType;
  static values(): SandstoneType[];
  /**
   * Gets the associated data value representing this type of sandstone
   *
   * @return A byte containing the data value of this sandstone type
   * @deprecated Magic value
  */
  getData(): number;
  /**
   * Gets the type of sandstone with the given data value
   *
   * @param data Data value to fetch
   * @return The {@link SandstoneType} representing the given value, or null
   *     if it doesn't exist
   * @deprecated Magic value
  */
  static getByData(data: number): SandstoneType | null;
}
/**
 * Represents various types of worlds that may exist
*/
export class WorldType extends Enum<WorldType> {
  static readonly NORMAL: WorldType;
  static readonly FLAT: WorldType;
  static readonly LARGE_BIOMES: WorldType;
  static readonly AMPLIFIED: WorldType;
  static valueOf(name: string): WorldType;
  static values(): WorldType[];
  /**
   * Gets the name of this WorldType
   *
   * @return Name of this type
  */
  getName(): string;
  /**
   * Gets a WorldType by its name
   *
   * @param name Name of the WorldType to get
   * @return Requested WorldType, or null if not found
  */
  static getByName(name: string): WorldType | null;
}

}
declare module 'org.bukkit.inventory' {
import { Component } from 'net.kyori.adventure.text';
import { Set, Random, HashMap, List, ListIterator, Map } from 'java.util';
import { SlotType } from 'org.bukkit.event.inventory.InventoryType';
import { Enchantment } from 'org.bukkit.enchantments';
import { ItemRarity } from 'io.papermc.paper.inventory';
import { ItemMeta } from 'org.bukkit.inventory.meta';
import { NamespacedKey, Color, Material, Keyed, Location } from 'org.bukkit';
import { HoverEventSource, HoverEvent } from 'net.kyori.adventure.text.event';
import { Property } from 'org.bukkit.inventory.InventoryView';
import { Enum, Iterable, Cloneable, Class } from 'java.lang';
import { BrewingStand, Block, Lectern, DoubleChest, Furnace } from 'org.bukkit.block';
import { InventoryType } from 'org.bukkit.event.inventory';
import { MaterialData } from 'org.bukkit.material';
import { ConfigurationSerializable } from 'org.bukkit.configuration.serialization';
import { Consumer, UnaryOperator, Predicate } from 'java.util.function';
import { ShowItem } from 'net.kyori.adventure.text.event.HoverEvent';
import { Translatable } from 'net.kyori.adventure.translation';
import { EntityType, Entity, HumanEntity } from 'org.bukkit.entity';
/**
 * Represents a smithing recipe.
*/
export class SmithingRecipe extends Recipe {
  /**
   * Create a smithing recipe to produce the specified result ItemStack.
   *
   * @param key The unique recipe key
   * @param result The item you want the recipe to create.
   * @param base The base ingredient
   * @param addition The addition ingredient
  */
  constructor(key: NamespacedKey, result: ItemStack, base: RecipeChoice, addition: RecipeChoice);
  /**
   * Create a smithing recipe to produce the specified result ItemStack.
   *
   * @param key The unique recipe key
   * @param result The item you want the recipe to create.
   * @param base The base ingredient
   * @param addition The addition ingredient
   * @param copyNbt whether to copy the nbt from the input base item to the output
  */
  constructor(key: NamespacedKey, result: ItemStack, base: RecipeChoice, addition: RecipeChoice, copyNbt: boolean);
  /**
   * Get the base recipe item.
   *
   * @return base choice
  */
  getBase(): RecipeChoice;
  /**
   * Get the addition recipe item.
   *
   * @return addition choice
  */
  getAddition(): RecipeChoice;
  /**
   * Get the result of this recipe.
   *
   * @return The result stack
  */
  getResult(): ItemStack;
  /**
   * Return the namespaced identifier for this object.
   *
   * @return this object's key
  */
  getKey(): NamespacedKey;
  /**
   * Whether or not to copy the NBT of the input base item to the output.
   *
   * @return true to copy the NBT (default for vanilla smithing recipes)
  */
  willCopyNbt(): boolean;
}
export interface SmithingRecipe extends Recipe, Keyed {}
/**
 * Interface to the inventory of a Furnace.
*/
export class FurnaceInventory extends Inventory {
  /**
   * Get the current item in the result slot.
   *
   * @return The item
  */
  getResult(): ItemStack | null;
  /**
   * Get the current fuel.
   *
   * @return The item
  */
  getFuel(): ItemStack | null;
  /**
   * Get the item currently smelting.
   *
   * @return The item
  */
  getSmelting(): ItemStack | null;
  /**
   * Set the current fuel.
   *
   * @param stack The item
  */
  setFuel(fuel: ItemStack | null);
  /**
   * Set the current item in the result slot.
   *
   * @param stack The item
  */
  setResult(result: ItemStack | null);
  /**
   * Set the item currently smelting.
   *
   * @param stack The item
  */
  setSmelting(smelting: ItemStack | null);
  /**
   * Check if an item can be used as a fuel source in this furnace container
   *
   * @param item Item to check
   * @return True if a valid fuel source
  */
  isFuel(item: ItemStack | null): boolean;
  /**
   * Check if an item can be smelted in this furnace container
   *
   * @param item Item to check
   * @return True if can be smelt
  */
  canSmelt(item: ItemStack | null): boolean;
  getHolder(): Furnace | null;
}
/**
 * Interface to the inventory of an Anvil.
*/
export class AnvilInventory extends Inventory {
  /**
   * Get the name to be applied to the repaired item. An empty string denotes
   * the default item name.
   *
   * @return the rename text
  */
  getRenameText(): string | null;
  /**
   * Get the item cost (in amount) to complete the current repair.
   *
   * @return the amount
  */
  getRepairCostAmount(): number;
  /**
   * Set the item cost (in amount) to complete the current repair.
   *
   * @param amount the amount
  */
  setRepairCostAmount(repairCostAmount: number);
  /**
   * Get the experience cost (in levels) to complete the current repair.
   *
   * @return the experience cost
  */
  getRepairCost(): number;
  /**
   * Set the experience cost (in levels) to complete the current repair.
   *
   * @param levels the experience cost
  */
  setRepairCost(repairCost: number);
  /**
   * Get the maximum experience cost (in levels) to be allowed by the current
   * repair. If the result of {@link #getRepairCost()} exceeds the returned
   * value, the repair result will be air to due being "too expensive".
   * 
   * By default, this level is set to 40. Players in creative mode ignore the
   * maximum repair cost.
   *
   * @return the maximum experience cost
  */
  getMaximumRepairCost(): number;
  /**
   * Set the maximum experience cost (in levels) to be allowed by the current
   * repair. The default value set by vanilla Minecraft is 40.
   *
   * @param levels the maximum experience cost
  */
  setMaximumRepairCost(maximumRepairCost: number);
  /**
   * Gets the item in the left input slot.
   *
   * @return item in the first slot
  */
  getFirstItem(): ItemStack | null;
  /**
   * Sets the item in the left input slot.
   *
   * @param firstItem item to set
  */
  setFirstItem(firstItem: ItemStack | null);
  /**
   * Gets the item in the right input slot.
   *
   * @return item in the second slot
  */
  getSecondItem(): ItemStack | null;
  /**
   * Sets the item in the right input slot.
   *
   * @param secondItem item to set
  */
  setSecondItem(secondItem: ItemStack | null);
  /**
   * Gets the item in the result slot.
   *
   * @return item in the result slot
  */
  getResult(): ItemStack | null;
  /**
   * Sets the item in the result slot.
   * Note that the client might not be able to take out the item if it does not match the input items.
   *
   * @param result item to set
  */
  setResult(result: ItemStack | null);
}
/**
 * Represents a trading inventory between a player and a merchant.
 * 
 * The holder of this Inventory is the owning Villager, or null if the player is
 * trading with a merchant created by a plugin.
*/
export class MerchantInventory extends Inventory {
  /**
   * Get the index of the currently selected recipe.
   *
   * @return the index of the currently selected recipe
  */
  getSelectedRecipeIndex(): number;
  /**
   * Get the currently active recipe.
   * 
   * This will be null if the items provided by the player do
   * not match the ingredients of the selected recipe. This does not
   * necessarily match the recipe selected by the player: If the player has
   * selected the first recipe, the merchant will search all of its offers
   * for a matching recipe to activate.
   *
   * @return the currently active recipe
  */
  getSelectedRecipe(): MerchantRecipe | null;
  /**
   * Gets the Merchant associated with this inventory.
   *
   * @return merchant
  */
  getMerchant(): Merchant;
}
/**
 * Interface to the inventory of a Beacon.
*/
export class BeaconInventory extends Inventory {
  /**
   * Set the item powering the beacon.
   *
   * @param item The new item
  */
  setItem(item: ItemStack | null);
  /**
   * Get the item powering the beacon.
   *
   * @return The current item.
  */
  getItem(): ItemStack | null;
}
/**
 * Represents a campfire recipe.
*/
export class CampfireRecipe extends CookingRecipe<CampfireRecipe> {
  constructor(key: NamespacedKey, result: ItemStack, source: Material, experience: number, cookingTime: number);
  constructor(key: NamespacedKey, result: ItemStack, input: RecipeChoice, experience: number, cookingTime: number);
}
/**
 * Represents a stack of items.
 * 
 * IMPORTANT: An ItemStack is only designed to contain items. Do not
 * use this class to encapsulate Materials for which {@link Material#isItem()}
 * returns false.
*/
export class ItemStack extends Cloneable {
  /**
   * Defaults stack size to 1, with no extra data.
   * 
   * IMPORTANT: An ItemStack is only designed to contain
   * items. Do not use this class to encapsulate Materials for which
   * {@link Material#isItem()} returns false.
   *
   * @param type item material
  */
  constructor(type: Material);
  /**
   * An item stack with no extra data.
   * 
   * IMPORTANT: An ItemStack is only designed to contain
   * items. Do not use this class to encapsulate Materials for which
   * {@link Material#isItem()} returns false.
   *
   * @param type item material
   * @param amount stack size
  */
  constructor(type: Material, amount: number);
  /**
   * An item stack with the specified damage / durability
   *
   * @param type item material
   * @param amount stack size
   * @param damage durability / damage
   * @deprecated see {@link #setDurability(short)}
  */
  constructor(type: Material, amount: number, damage: number);
  /**
   * @param type the type
   * @param amount the amount in the stack
   * @param damage the damage value of the item
   * @param data the data value or null
   * @deprecated this method uses an ambiguous data byte object
  */
  constructor(type: Material, amount: number, damage: number, data: number | null);
  /**
   * Creates a new item stack derived from the specified stack
   *
   * @param stack the stack to copy
   * @throws IllegalArgumentException if the specified stack is null or
   *     returns an item meta not created by the item factory
  */
  constructor(stack: ItemStack);
  /**
   * Gets the type of this item
   *
   * @return Type of the items in this stack
  */
  getType(): Material;
  /**
   * Sets the type of this item
   * 
   * Note that in doing so you will reset the MaterialData for this stack.
   * 
   * IMPORTANT: An ItemStack is only designed to contain
   * items. Do not use this class to encapsulate Materials for which
   * {@link Material#isItem()} returns false.
   *
   * @param type New type to set the items in this stack to
  */
  setType(type: Material);
  /**
   * Gets the amount of items in this stack
   *
   * @return Amount of items in this stack
  */
  getAmount(): number;
  /**
   * Sets the amount of items in this stack
   *
   * @param amount New amount of items in this stack
  */
  setAmount(amount: number);
  /**
   * Gets the MaterialData for this stack of items
   *
   * @return MaterialData for this item
   * @deprecated cast to {@link org.bukkit.inventory.meta.BlockDataMeta} and use {@link org.bukkit.inventory.meta.BlockDataMeta#getBlockData(Material)}
  */
  getData(): MaterialData | null;
  /**
   * Sets the MaterialData for this stack of items
   *
   * @param data New MaterialData for this item
   * @deprecated cast to {@link org.bukkit.inventory.meta.BlockDataMeta} and use {@link org.bukkit.inventory.meta.BlockDataMeta#setBlockData(org.bukkit.block.data.BlockData)}
  */
  setData(data: MaterialData | null);
  /**
   * Sets the durability of this item
   *
   * @param durability Durability of this item
   * @deprecated durability is now part of ItemMeta. To avoid confusion and
   * misuse, {@link #getItemMeta()}, {@link #setItemMeta(ItemMeta)} and
   * {@link Damageable#setDamage(int)} should be used instead. This is because
   * any call to this method will be overwritten by subsequent setting of
   * ItemMeta which was created before this call.
  */
  setDurability(durability: number);
  /**
   * Gets the durability of this item
   *
   * @return Durability of this item
   * @deprecated see {@link #setDurability(short)}
  */
  getDurability(): number;
  /**
   * Get the maximum stacksize for the material hold in this ItemStack.
   * (Returns -1 if it has no idea)
   *
   * @return The maximum you can stack this material to.
  */
  getMaxStackSize(): number;
  toString(): string;
  equals(obj: any): boolean;
  /**
   * This method is the same as equals, but does not consider stack size
   * (amount).
   *
   * @param stack the item stack to compare to
   * @return true if the two stacks are equal, ignoring the amount
  */
  isSimilar(stack: ItemStack | null): boolean;
  clone(): ItemStack;
  hashCode(): number;
  /**
   * Checks if this ItemStack contains the given {@link Enchantment}
   *
   * @param ench Enchantment to test
   * @return True if this has the given enchantment
  */
  containsEnchantment(ench: Enchantment): boolean;
  /**
   * Gets the level of the specified enchantment on this item stack
   *
   * @param ench Enchantment to check
   * @return Level of the enchantment, or 0
  */
  getEnchantmentLevel(ench: Enchantment): number;
  /**
   * Gets a map containing all enchantments and their levels on this item.
   *
   * @return Map of enchantments.
  */
  getEnchantments(): Map<Enchantment, number>;
  /**
   * Adds the specified enchantments to this item stack.
   * 
   * This method is the same as calling {@link
   * #addEnchantment(org.bukkit.enchantments.Enchantment, int)} for each
   * element of the map.
   *
   * @param enchantments Enchantments to add
   * @throws IllegalArgumentException if the specified enchantments is null
   * @throws IllegalArgumentException if any specific enchantment or level
   *     is null. Warning: Some enchantments may be added before this
   *     exception is thrown.
  */
  addEnchantments(enchantments: Map<Enchantment, number>): void;
  /**
   * Adds the specified {@link Enchantment} to this item stack.
   * 
   * If this item stack already contained the given enchantment (at any
   * level), it will be replaced.
   *
   * @param ench Enchantment to add
   * @param level Level of the enchantment
   * @throws IllegalArgumentException if enchantment null, or enchantment is
   *     not applicable
  */
  addEnchantment(ench: Enchantment, level: number): void;
  /**
   * Adds the specified enchantments to this item stack in an unsafe manner.
   * 
   * This method is the same as calling {@link
   * #addUnsafeEnchantment(org.bukkit.enchantments.Enchantment, int)} for
   * each element of the map.
   *
   * @param enchantments Enchantments to add
  */
  addUnsafeEnchantments(enchantments: Map<Enchantment, number>): void;
  /**
   * Adds the specified {@link Enchantment} to this item stack.
   * 
   * If this item stack already contained the given enchantment (at any
   * level), it will be replaced.
   * 
   * This method is unsafe and will ignore level restrictions or item type.
   * Use at your own discretion.
   *
   * @param ench Enchantment to add
   * @param level Level of the enchantment
  */
  addUnsafeEnchantment(ench: Enchantment, level: number): void;
  /**
   * Removes the specified {@link Enchantment} if it exists on this
   * ItemStack
   *
   * @param ench Enchantment to remove
   * @return Previous level, or 0
  */
  removeEnchantment(ench: Enchantment): number;
  /**
   * Creates a Map representation of this class.
   * 
   * This class must provide a method to restore this class, as defined in
   * the {@link ConfigurationSerializable} interface javadocs.
   *
   * @return Map containing the current state of this class
  */
  serialize(): Map<string, any>;
  /**
   * Required method for configuration serialization
   *
   * @param args map to deserialize
   * @return deserialized item stack
   * @see ConfigurationSerializable
  */
  static deserialize(args: Map<string, any>): ItemStack;
  /**
   * Edits the {@link ItemMeta} of this stack.
   * 
   * The {@link java.util.function.Consumer} must only interact
   * with this stack's {@link ItemMeta} through the provided {@link ItemMeta} instance.
   * Calling this method or any other meta-related method of the {@link ItemStack} class
   * (such as {@link #getItemMeta()}, {@link #addItemFlags(ItemFlag...)}, {@link #lore()}, etc.)
   * from inside the consumer is disallowed and will produce undefined results or exceptions.
   * 
   *
   * @param consumer the meta consumer
   * @return `true` if the edit was successful, `false` otherwise
  */
  editMeta(consumer: Consumer<any>): boolean;
  /**
   * Edits the {@link ItemMeta} of this stack if the meta is of the specified type.
   * 
   * The {@link java.util.function.Consumer} must only interact
   * with this stack's {@link ItemMeta} through the provided {@link ItemMeta} instance.
   * Calling this method or any other meta-related method of the {@link ItemStack} class
   * (such as {@link #getItemMeta()}, {@link #addItemFlags(ItemFlag...)}, {@link #lore()}, etc.)
   * from inside the consumer is disallowed and will produce undefined results or exceptions.
   * 
   *
   * @param metaClass the type of meta to edit
   * @param consumer the meta consumer
   * @param  the meta type
   * @return `true` if the edit was successful, `false` otherwise
  */
  editMeta<M>(metaClass: Class<M>, consumer: Consumer<any>): boolean;
  /**
   * Get a copy of this ItemStack's {@link ItemMeta}.
   *
   * @return a copy of the current ItemStack's ItemData
  */
  getItemMeta(): ItemMeta;
  /**
   * Checks to see if any meta data has been defined.
   *
   * @return Returns true if some meta data has been set for this item
  */
  hasItemMeta(): boolean;
  /**
   * Set the ItemMeta of this ItemStack.
   *
   * @param itemMeta new ItemMeta, or null to indicate meta data be cleared.
   * @return True if successfully applied ItemMeta, see {@link
   *     ItemFactory#isApplicable(ItemMeta, ItemStack)}
   * @throws IllegalArgumentException if the item meta was not created by
   *     the {@link ItemFactory}
  */
  setItemMeta(itemMeta: ItemMeta | null);
  /**
   * Randomly enchants a copy of this {@link ItemStack} using the given experience levels.
   *
   * If this ItemStack is already enchanted, the existing enchants will be removed before enchanting.
   *
   * Levels must be in range `[1, 30]`.
   *
   * @param levels levels to use for enchanting
   * @param allowTreasure whether to allow enchantments where {@link org.bukkit.enchantments.Enchantment#isTreasure()} returns true
   * @param random {@link java.util.Random} instance to use for enchanting
   * @return enchanted copy of the provided ItemStack
   * @throws IllegalArgumentException on bad arguments
  */
  enchantWithLevels(levels: number, allowTreasure: boolean, random: Random): ItemStack;
  /**
   * Represent this object as a hover event.
   *
   * @return a hover event
   * @since 4.0.0
  */
  asHoverEvent(op: UnaryOperator<ShowItem>): HoverEvent<ShowItem>;
  /**
   * Get the formatted display name of the {@link ItemStack}.
   *
   * @return display name of the {@link ItemStack}
  */
  displayName(): Component;
  /**
   * Minecraft updates are converting simple item stacks into more complex NBT oriented Item Stacks.
   *
   * Use this method to to ensure any desired data conversions are processed.
   * The input itemstack will not be the same as the returned itemstack.
   *
   * @return A potentially Data Converted ItemStack
  */
  ensureServerConversions(): ItemStack;
  /**
   * Deserializes this itemstack from raw NBT bytes. NBT is safer for data migrations as it will
   * use the built in data converter instead of bukkits dangerous serialization system.
   *
   * This expects that the DataVersion was stored on the root of the Compound, as saved from
   * the {@link #serializeAsBytes()} API returned.
   * @param bytes bytes representing an item in NBT
   * @return ItemStack migrated to this version of Minecraft if needed.
  */
  static deserializeBytes(bytes: number[]): ItemStack;
  /**
   * Serializes this itemstack to raw bytes in NBT. NBT is safer for data migrations as it will
   * use the built in data converter instead of bukkits dangerous serialization system.
   * @return bytes representing this item in NBT.
  */
  serializeAsBytes(): number[];
  /**
   * Gets the Display name as seen in the Client.
   * Currently the server only supports the English language. To override this,
   * You must replace the language file embedded in the server jar.
   *
   * @return Display name of Item
   * @deprecated {@link ItemStack} implements {@link net.kyori.adventure.translation.Translatable}; use that and
   * {@link net.kyori.adventure.text.Component#translatable(net.kyori.adventure.translation.Translatable)} instead.
  */
  getI18NDisplayName(): string | null;
  getMaxItemUseDuration(): number;
  /**
   * Clones the itemstack and returns it a single quantity.
   * @return The new itemstack with 1 quantity
  */
  asOne(): ItemStack;
  /**
   * Clones the itemstack and returns it as the specified quantity
   * @param qty The quantity of the cloned item
   * @return The new itemstack with specified quantity
  */
  asQuantity(qty: number): ItemStack;
  /**
   * Adds 1 to this itemstack. Will not go over the items max stack size.
   * @return The same item (not a clone)
  */
  add(): ItemStack;
  /**
   * Adds quantity to this itemstack. Will not go over the items max stack size.
   *
   * @param qty The amount to add
   * @return The same item (not a clone)
  */
  add(qty: number): ItemStack;
  /**
   * Subtracts 1 to this itemstack.  Going to 0 or less will invalidate the item.
   * @return The same item (not a clone)
  */
  subtract(): ItemStack;
  /**
   * Subtracts quantity to this itemstack. Going to 0 or less will invalidate the item.
   *
   * @param qty The amount to add
   * @return The same item (not a clone)
  */
  subtract(qty: number): ItemStack;
  /**
   * If the item has lore, returns it, else it will return null
   * @return The lore, or null
   * @deprecated in favor of {@link #lore()}
  */
  getLore(): string[] | null;
  /**
   * Sets the lore for this item.
   * Removes lore when given null.
   *
   * @param lore the lore that will be set
   * @deprecated in favour of {@link #lore(List)}
  */
  setLore(lore: string[] | null);
  /**
   * Set itemflags which should be ignored when rendering a ItemStack in the Client. This Method does silently ignore double set itemFlags.
   *
   * @param itemFlags The hideflags which shouldn't be rendered
  */
  addItemFlags(...itemFlags: ItemFlag[]): void;
  /**
   * Remove specific set of itemFlags. This tells the Client it should render it again. This Method does silently ignore double removed itemFlags.
   *
   * @param itemFlags Hideflags which should be removed
  */
  removeItemFlags(...itemFlags: ItemFlag[]): void;
  /**
   * Get current set itemFlags. The collection returned is unmodifiable.
   *
   * @return A set of all itemFlags set
  */
  getItemFlags(): Set<ItemFlag>;
  /**
   * Check if the specified flag is present on this item.
   *
   * @param flag the flag to check
   * @return if it is present
  */
  hasItemFlag(flag: ItemFlag): boolean;
  /**
   * Gets the translation key for this itemstack.
   * This is not the same as getting the translation key
   * for the material of this itemstack.
   *
   * @return the translation key
   * @deprecated use {@link #translationKey()}
  */
  getTranslationKey(): string;
  /**
   * Gets the item rarity of the itemstack. The rarity can change based on enchantements.
   *
   * @return the itemstack rarity
  */
  getRarity(): ItemRarity;
  /**
   * Checks if an itemstack can repair this itemstack.
   * Returns false if `this` or `repairMaterial`'s type is not an item ({@link Material#isItem()}).
   *
   * @param repairMaterial the repair material
   * @return true if it is repairable by, false if not
  */
  isRepairableBy(repairMaterial: ItemStack): boolean;
  /**
   * Checks if this itemstack can repair another.
   * Returns false if `this` or `toBeRepaired`'s type is not an item ({@link Material#isItem()}).
   *
   * @param toBeRepaired the itemstack to be repaired
   * @return true if it can repair, false if not
  */
  canRepair(toBeRepaired: ItemStack): boolean;
  /**
   * Represent this object as a hover event.
   *
   * @return a hover event
   * @since 4.0.0
  */
  asHoverEvent(): HoverEvent<V>;
}
export interface ItemStack extends Cloneable, ConfigurationSerializable, HoverEventSource<ShowItem>, Translatable {}
/**
 * Represents a Stonecutting recipe.
*/
export class StonecuttingRecipe extends Recipe {
  /**
   * Create a Stonecutting recipe to craft the specified ItemStack.
   *
   * @param key The unique recipe key
   * @param result The item you want the recipe to create.
   * @param source The input material.
  */
  constructor(key: NamespacedKey, result: ItemStack, source: Material);
  /**
   * Create a cooking recipe to craft the specified ItemStack.
   *
   * @param key The unique recipe key
   * @param result The item you want the recipe to create.
   * @param input The input choices.
  */
  constructor(key: NamespacedKey, result: ItemStack, input: RecipeChoice);
  /**
   * Sets the input of this cooking recipe.
   *
   * @param input The input material.
   * @return The changed recipe, so you can chain calls.
  */
  setInput(input: Material);
  /**
   * Get the input material.
   *
   * @return The input material.
  */
  getInput(): ItemStack;
  /**
   * Sets the input of this cooking recipe.
   *
   * @param input The input choice.
   * @return The changed recipe, so you can chain calls.
  */
  setInputChoice(inputChoice: RecipeChoice);
  /**
   * Get the input choice.
   *
   * @return The input choice.
  */
  getInputChoice(): RecipeChoice;
  /**
   * Get the result of this recipe.
   *
   * @return The resulting stack.
  */
  getResult(): ItemStack;
  /**
   * Return the namespaced identifier for this object.
   *
   * @return this object's key
  */
  getKey(): NamespacedKey;
  /**
   * Get the group of this recipe. Recipes with the same group may be grouped
   * together when displayed in the client.
   *
   * @return recipe group. An empty string denotes no group. May not be null.
  */
  getGroup(): string;
  /**
   * Set the group of this recipe. Recipes with the same group may be grouped
   * together when displayed in the client.
   *
   * @param group recipe group. An empty string denotes no group. May not be
   * null.
  */
  setGroup(group: string);
}
export interface StonecuttingRecipe extends Recipe, Keyed {}
/**
 * An interface to the inventory of a {@link Llama}.
*/
export class LlamaInventory extends SaddledHorseInventory {
  /**
   * Gets the item in the llama's decor slot.
   *
   * @return the decor item
  */
  getDecor(): ItemStack | null;
  /**
   * Sets the item in the llama's decor slot.
   *
   * @param stack the new item
  */
  setDecor(decor: ItemStack | null);
}
/**
 * Interface to the inventory of an Enchantment Table.
*/
export class EnchantingInventory extends Inventory {
  /**
   * Set the item being enchanted.
   *
   * @param item The new item
  */
  setItem(item: ItemStack | null);
  /**
   * Get the item being enchanted.
   *
   * @return The current item.
  */
  getItem(): ItemStack | null;
  /**
   * Set the secondary item being used for the enchant.
   *
   * @param item The new item
  */
  setSecondary(secondary: ItemStack | null);
  /**
   * Get the secondary item being used for the enchant.
   *
   * @return The second item
  */
  getSecondary(): ItemStack | null;
}
/**
 * Represents a block inventory holder - either a BlockState, or a regular
 * Block.
*/
export class BlockInventoryHolder extends InventoryHolder {
  /**
   * Gets the block associated with this holder.
   *
   * @return the block associated with this holder
   * @throws IllegalStateException if the holder is a block state and is not
   * placed
  */
  getBlock(): Block;
}
/**
 * Represents a potential item match within a recipe. All choices within a
 * recipe must be satisfied for it to be craftable.
 *
 * This class is not legal for implementation by plugins!
*/
export class RecipeChoice extends Predicate<ItemStack> {
  /**
   * Gets a single item stack representative of this stack choice.
   *
   * @return a single representative item
   * @deprecated for compatibility only
  */
  getItemStack(): ItemStack;
  clone(): RecipeChoice;
  test(itemStack: ItemStack): boolean;
}
export interface RecipeChoice extends Predicate<ItemStack>, Cloneable {}
export class SaddledHorseInventory extends AbstractHorseInventory {

}
/**
 * Interface to the inventory of a Grindstone.
*/
export class GrindstoneInventory extends Inventory {
  /**
   * Gets the upper input item.
   *
   * @return upper input item
  */
  getUpperItem(): ItemStack | null;
  /**
   * Sets the upper input item.
   *
   * @param upperItem item to set
  */
  setUpperItem(upperItem: ItemStack | null);
  /**
   * Gets the lower input item.
   *
   * @return lower input item
  */
  getLowerItem(): ItemStack | null;
  /**
   * Sets the lower input item.
   *
   * @param lowerItem item to set
  */
  setLowerItem(lowerItem: ItemStack | null);
  /**
   * Gets the result.
   *
   * @return result
  */
  getResult(): ItemStack | null;
  /**
   * Sets the result.
   *
   * @param result item to set
  */
  setResult(result: ItemStack | null);
}
/**
 * Interface to the inventory of a Loom.
*/
export class LoomInventory extends Inventory {

}
/**
 * Interface to the inventory of a Brewing Stand.
*/
export class BrewerInventory extends Inventory {
  /**
   * Get the current ingredient for brewing.
   *
   * @return The ingredient.
  */
  getIngredient(): ItemStack | null;
  /**
   * Set the current ingredient for brewing.
   *
   * @param ingredient The ingredient
  */
  setIngredient(ingredient: ItemStack | null);
  /**
   * Get the current fuel for brewing.
   *
   * @return The fuel
  */
  getFuel(): ItemStack | null;
  /**
   * Set the current fuel for brewing. Generally only
   * {@link Material#BLAZE_POWDER} will be of use.
   *
   * @param fuel The fuel
  */
  setFuel(fuel: ItemStack | null);
  getHolder(): BrewingStand | null;
}
/**
 * Interface to the inventory of a Stonecutter.
*/
export class StonecutterInventory extends Inventory {
  /**
   * Gets the input item.
   *
   * @return input item
  */
  getInputItem(): ItemStack | null;
  /**
   * Sets the input item.
   *
   * @param itemStack item to set
  */
  setInputItem(inputItem: ItemStack | null);
  /**
   * Gets the result item.
   *
   * @return result
  */
  getResult(): ItemStack | null;
  /**
   * Sets the result item.
   *
   * @param itemStack item to set
  */
  setResult(result: ItemStack | null);
}
/**
 * Represents the chosen main hand of a player
*/
export class MainHand extends Enum<MainHand> {
  static readonly LEFT: MainHand;
  static readonly RIGHT: MainHand;
  static valueOf(name: string): MainHand;
  static values(): MainHand[];
}
/**
 * Represents a view linking two inventories and a single player (whose
 * inventory may or may not be one of the two).
 * 
 * Note: If you implement this interface but fail to satisfy the expected
 * contracts of certain methods, there's no guarantee that the game will work
 * as it should.
*/
export class InventoryView {
  static readonly OUTSIDE: number;
  /**
   * Get the upper inventory involved in this transaction.
   *
   * @return the inventory
  */
  getTopInventory(): Inventory;
  /**
   * Get the lower inventory involved in this transaction.
   *
   * @return the inventory
  */
  getBottomInventory(): Inventory;
  /**
   * Get the player viewing.
   *
   * @return the player
  */
  getPlayer(): HumanEntity;
  /**
   * Determine the type of inventory involved in the transaction. This
   * indicates the window style being shown. It will never return PLAYER,
   * since that is common to all windows.
   *
   * @return the inventory type
  */
  getType(): InventoryType;
  /**
   * Sets one item in this inventory view by its raw slot ID.
   * 
   * Note: If slot ID -999 is chosen, it may be expected that the item is
   * dropped on the ground. This is not required behaviour, however.
   *
   * @param slot The ID as returned by InventoryClickEvent.getRawSlot()
   * @param item The new item to put in the slot, or null to clear it.
  */
  setItem(slot: number, item: ItemStack | null): void;
  /**
   * Gets one item in this inventory view by its raw slot ID.
   *
   * @param slot The ID as returned by InventoryClickEvent.getRawSlot()
   * @return The item currently in the slot.
  */
  getItem(slot: number): ItemStack | null;
  /**
   * Sets the item on the cursor of one of the viewing players.
   *
   * @param item The item to put on the cursor, or null to remove the item
   *     on their cursor.
  */
  setCursor(cursor: ItemStack | null);
  /**
   * Get the item on the cursor of one of the viewing players.
   *
   * @return The item on the player's cursor, or null if they aren't holding
   *     one.
  */
  getCursor(): ItemStack | null;
  /**
   * Gets the inventory corresponding to the given raw slot ID.
   *
   * If the slot ID is {@link #OUTSIDE} null will be returned, otherwise
   * behaviour for illegal and negative slot IDs is undefined.
   *
   * May be used with {@link #convertSlot(int)} to directly index an
   * underlying inventory.
   *
   * @param rawSlot The raw slot ID.
   * @return corresponding inventory, or null
  */
  getInventory(rawSlot: number): Inventory | null;
  /**
   * Converts a raw slot ID into its local slot ID into whichever of the two
   * inventories the slot points to.
   * 
   * If the raw slot refers to the upper inventory, it will be returned
   * unchanged and thus be suitable for getTopInventory().getItem(); if it
   * refers to the lower inventory, the output will differ from the input
   * and be suitable for getBottomInventory().getItem().
   *
   * @param rawSlot The raw slot ID.
   * @return The converted slot ID.
  */
  convertSlot(rawSlot: number): number;
  /**
   * Determine the type of the slot by its raw slot ID.
   * 
   * If the type of the slot is unknown, then
   * {@link InventoryType.SlotType#CONTAINER} will be returned.
   *
   * @param slot The raw slot ID
   * @return the slot type
  */
  getSlotType(slot: number): SlotType;
  /**
   * Closes the inventory view.
  */
  close(): void;
  /**
   * Check the total number of slots in this view, combining the upper and
   * lower inventories.
   * 
   * Note though that it's possible for this to be greater than the sum of
   * the two inventories if for example some slots are not being used.
   *
   * @return The total size
  */
  countSlots(): number;
  /**
   * Sets an extra property of this inventory if supported by that
   * inventory, for example the state of a progress bar.
   *
   * @param prop the window property to update
   * @param value the new value for the window property
   * @return true if the property was updated successfully, false if the
   *     property is not supported by that inventory
  */
  setProperty(prop: Property, value: number): boolean;
  /**
   * Get the title of this inventory window.
   *
   * @return The title or empty string when title is `null`. 
  */
  title(): Component;
}
/**
 * Represents a furnace recipe.
*/
export class FurnaceRecipe extends CookingRecipe<FurnaceRecipe> {
  constructor(result: ItemStack, source: Material);
  constructor(result: ItemStack, source: MaterialData);
  constructor(result: ItemStack, source: MaterialData, experience: number);
  constructor(result: ItemStack, source: Material, data: number);
  /**
   * Create a furnace recipe to craft the specified ItemStack.
   *
   * @param key The unique recipe key
   * @param result The item you want the recipe to create.
   * @param source The input material.
   * @param experience The experience given by this recipe
   * @param cookingTime The cooking time (in ticks)
  */
  constructor(key: NamespacedKey, result: ItemStack, source: Material, experience: number, cookingTime: number);
  constructor(key: NamespacedKey, result: ItemStack, source: Material, data: number, experience: number, cookingTime: number);
  /**
   * Create a furnace recipe to craft the specified ItemStack.
   *
   * @param key The unique recipe key
   * @param result The item you want the recipe to create.
   * @param input The input choices.
   * @param experience The experience given by this recipe
   * @param cookingTime The cooking time (in ticks)
  */
  constructor(key: NamespacedKey, result: ItemStack, input: RecipeChoice, experience: number, cookingTime: number);
  /**
   * Sets the input of this furnace recipe.
   *
   * @param input The input material.
   * @return The changed recipe, so you can chain calls.
   * @deprecated use {@link #setInputChoice(RecipeChoice)}
  */
  setInput(input: MaterialData): void;
  setInput(input: Material): void;
  /**
   * Sets the input of this furnace recipe.
   *
   * @param input The input material.
   * @param data The data value. (Note: This is currently ignored by the
   *     CraftBukkit server.)
   * @return The changed recipe, so you can chain calls.
   * @deprecated Magic value
  */
  setInput(input: Material, data: number): FurnaceRecipe;
  setInputChoice(inputChoice: RecipeChoice);
  /**
   * Get the input material.
   *
   * @return The input material.
  */
  getInput(): ItemStack;
  /**
   * Get the input choice.
   *
   * @return The input choice.
  */
  getInputChoice(): RecipeChoice;
}
/**
 * Represents a campfire recipe.
*/
export class SmokingRecipe extends CookingRecipe<SmokingRecipe> {
  constructor(key: NamespacedKey, result: ItemStack, source: Material, experience: number, cookingTime: number);
  constructor(key: NamespacedKey, result: ItemStack, input: RecipeChoice, experience: number, cookingTime: number);
}
export class InventoryHolder {
  /**
   * Get the object's inventory.
   *
   * @return The inventory.
  */
  getInventory(): Inventory;
}
/**
 * An instance of the ItemFactory can be obtained with {@link
 * Server#getItemFactory()}.
 * 
 * The ItemFactory is solely responsible for creating item meta containers to
 * apply on item stacks.
*/
export class ItemFactory {
  /**
   * This creates a new item meta for the material.
   *
   * @param material The material to consider as base for the meta
   * @return a new ItemMeta that could be applied to an item stack of the
   *     specified material
  */
  getItemMeta(material: Material): ItemMeta;
  /**
   * This method checks the item meta to confirm that it is applicable (no
   * data lost if applied) to the specified ItemStack.
   * 
   * A {@link SkullMeta} would not be valid for a sword, but a normal {@link
   * ItemMeta} from an enchanted dirt block would.
   *
   * @param meta Meta to check
   * @param stack Item that meta will be applied to
   * @return true if the meta can be applied without losing data, false
   *     otherwise
   * @throws IllegalArgumentException if the meta was not created by this
   *     factory
  */
  isApplicable(meta: ItemMeta | null, stack: ItemStack | null): boolean;
  /**
   * This method checks the item meta to confirm that it is applicable (no
   * data lost if applied) to the specified Material.
   * 
   * A {@link SkullMeta} would not be valid for a sword, but a normal {@link
   * ItemMeta} from an enchanted dirt block would.
   *
   * @param meta Meta to check
   * @param material Material that meta will be applied to
   * @return true if the meta can be applied without losing data, false
   *     otherwise
   * @throws IllegalArgumentException if the meta was not created by this
   *     factory
  */
  isApplicable(meta: ItemMeta | null, material: Material | null): boolean;
  /**
   * This method is used to compare two item meta data objects.
   *
   * @param meta1 First meta to compare, and may be null to indicate no data
   * @param meta2 Second meta to compare, and may be null to indicate no
   *     data
   * @return false if one of the meta has data the other does not, otherwise
   *     true
   * @throws IllegalArgumentException if either meta was not created by this
   *     factory
  */
  equals(meta1: ItemMeta | null, meta2: ItemMeta | null): boolean;
  /**
   * Returns an appropriate item meta for the specified stack.
   * 
   * The item meta returned will always be a valid meta for a given
   * ItemStack of the specified material. It may be a more or less specific
   * meta, and could also be the same meta or meta type as the parameter.
   * The item meta returned will also always be the most appropriate meta.
   * 
   * Example, if a {@link SkullMeta} is being applied to a book, this method
   * would return a {@link BookMeta} containing all information in the
   * specified meta that is applicable to an {@link ItemMeta}, the highest
   * common interface.
   *
   * @param meta the meta to convert
   * @param stack the stack to convert the meta for
   * @return An appropriate item meta for the specified item stack. No
   *     guarantees are made as to if a copy is returned. This will be null
   *     for a stack of air.
   * @throws IllegalArgumentException if the specified meta was not created
   *     by this factory
  */
  asMetaFor(meta: ItemMeta, stack: ItemStack): ItemMeta | null;
  /**
   * Returns an appropriate item meta for the specified material.
   * 
   * The item meta returned will always be a valid meta for a given
   * ItemStack of the specified material. It may be a more or less specific
   * meta, and could also be the same meta or meta type as the parameter.
   * The item meta returned will also always be the most appropriate meta.
   * 
   * Example, if a {@link SkullMeta} is being applied to a book, this method
   * would return a {@link BookMeta} containing all information in the
   * specified meta that is applicable to an {@link ItemMeta}, the highest
   * common interface.
   *
   * @param meta the meta to convert
   * @param material the material to convert the meta for
   * @return An appropriate item meta for the specified item material. No
   *     guarantees are made as to if a copy is returned. This will be null for air.
   * @throws IllegalArgumentException if the specified meta was not created
   *     by this factory
  */
  asMetaFor(meta: ItemMeta, material: Material): ItemMeta | null;
  /**
   * Returns the default color for all leather armor.
   *
   * @return the default color for leather armor
  */
  getDefaultLeatherColor(): Color;
  /**
   * Create a new {@link ItemStack} given the supplied input.
   * 
   * The input should match the same input as expected by Minecraft's `/give`
   * command. For example, "minecraft:diamond_sword{Enchantments:[{id:"minecraft:sharpness", lvl:3}]}"
   * would yield an ItemStack of {@link Material#DIAMOND_SWORD} with an {@link ItemMeta}
   * containing a level 3 {@link Enchantment#DAMAGE_ALL}
   * enchantment.
   *
   * @param input the item input string
   * @return the created ItemStack
   * @throws IllegalArgumentException if the input string was provided in an
   * invalid or unsupported format
  */
  createItemStack(input: string): ItemStack;
  /**
   * Apply a material change for an item meta. Do not use under any
   * circumstances.
   *
   * @param meta meta
   * @param material material
   * @return updated material
   * @throws IllegalArgumentException if bad material or data
   * @deprecated for internal use only
  */
  updateMaterial(meta: ItemMeta, material: Material): Material;
  /**
   * Randomly enchants a copy of the provided {@link ItemStack} using the given experience levels.
   *
   * If the provided ItemStack is already enchanted, the existing enchants will be removed before enchanting.
   *
   * Levels must be in range `[1, 30]`.
   *
   * @param itemStack ItemStack to enchant
   * @param levels levels to use for enchanting
   * @param allowTreasure whether to allow enchantments where {@link org.bukkit.enchantments.Enchantment#isTreasure()} returns true
   * @param random {@link java.util.Random} instance to use for enchanting
   * @return enchanted copy of the provided ItemStack
   * @throws IllegalArgumentException on bad arguments
  */
  enchantWithLevels(itemStack: ItemStack, levels: number, allowTreasure: boolean, random: Random): ItemStack;
  /**
   * Creates a hover event for the given item.
   *
   * @param item The item
   * @return A hover event
  */
  asHoverEvent(item: ItemStack, op: UnaryOperator<ShowItem>): HoverEvent<ShowItem>;
  /**
   * Get the formatted display name of the {@link ItemStack}.
   *
   * @param itemStack the {@link ItemStack}
   * @return display name of the {@link ItemStack}
  */
  displayName(itemStack: ItemStack): Component;
  /**
   * Gets the Display name as seen in the Client.
   * Currently the server only supports the English language. To override this,
   * You must replace the language file embedded in the server jar.
   *
   * @param item Item to return Display name of
   * @return Display name of Item
   * @deprecated {@link ItemStack} implements {@link net.kyori.adventure.translation.Translatable}; use that and
   * {@link net.kyori.adventure.text.Component#translatable(net.kyori.adventure.translation.Translatable)} instead.
  */
  getI18NDisplayName(item: ItemStack | null): string | null;
  /**
   * Minecraft updates are converting simple item stacks into more complex NBT oriented Item Stacks.
   *
   * Use this method to to ensure any desired data conversions are processed.
   * The input itemstack will not be the same as the returned itemstack.
   *
   * @param item The item to process conversions on
   * @return A potentially Data Converted ItemStack
  */
  ensureServerConversions(item: ItemStack): ItemStack;
  /**
   * Get a spawn egg ItemStack from an EntityType
   *
   * @param type EntityType
   * @return ItemStack spawner egg
  */
  getSpawnEgg(type: EntityType | null): ItemStack | null;
}
/**
 * Interface to the inventory of a Lectern.
*/
export class LecternInventory extends Inventory {
  getHolder(): Lectern | null;
  /**
   * Gets the lectern's held book.
   *
   * @return book set in the lectern
  */
  getBook(): ItemStack | null;
  /**
   * Sets the lectern's held book.
   *
   * @param book the new book
  */
  setBook(book: ItemStack | null);
}
/**
 * An interface to a creatures inventory
*/
export class EntityEquipment {
  /**
   * Stores the ItemStack at the given equipment slot in the inventory.
   *
   * @param slot the slot to put the ItemStack
   * @param item the ItemStack to set
  */
  setItem(slot: EquipmentSlot, item: ItemStack | null): void;
  /**
   * Stores the ItemStack at the given equipment slot in the inventory.
   *
   * @param slot the slot to put the ItemStack
   * @param item the ItemStack to set
   * @param silent whether or not the equip sound should be silenced
  */
  setItem(slot: EquipmentSlot, item: ItemStack | null, silent: boolean): void;
  /**
   * Gets the ItemStack at the given equipment slot in the inventory.
   *
   * @param slot the slot to get the ItemStack
   * @return the ItemStack in the given slot
  */
  getItem(slot: EquipmentSlot): ItemStack;
  /**
   * Gets the item the entity is currently holding
   * in their main hand.
   *
   * 
   * This returns a copy if this equipment instance is from a non-player,
   * or it's an empty stack (has AIR as its type).
   * For non-empty stacks from players, this returns a live mirror. You can check if this
   * will return a mirror with
   * {@code
   * EntityEquipment equipment = entity.getEquipment();
   * if (equipment instanceof PlayerInventory) {
   *     equipment.getItemInMainHand(); // will return a mirror
   * } else {
   *     equipment.getItemInMainHand(); // will return a copy
   * }
   * }
   *
   * @return the currently held item
  */
  getItemInMainHand(): ItemStack;
  /**
   * Sets the item the entity is holding in their main hand.
   *
   * @param item The item to put into the entities hand
  */
  setItemInMainHand(itemInMainHand: ItemStack | null);
  /**
   * Sets the item the entity is holding in their main hand.
   *
   * @param item The item to put into the entities hand
   * @param silent whether or not the equip sound should be silenced
  */
  setItemInMainHand(item: ItemStack | null, silent: boolean): void;
  /**
   * Gets the item the entity is currently holding
   * in their off hand.
   *
   * 
   * This returns a copy if this equipment instance is from a non-player,
   * or it's an empty stack (has AIR as its type).
   * For non-empty stacks from players, this returns a live mirror. You can check if this
   * will return a mirror with
   * {@code
   * EntityEquipment equipment = entity.getEquipment();
   * if (equipment instanceof PlayerInventory) {
   *     equipment.getItemInOffHand(); // will return a mirror
   * } else {
   *     equipment.getItemInOffHand(); // will return a copy
   * }
   * }
   *
   * @return the currently held item
  */
  getItemInOffHand(): ItemStack;
  /**
   * Sets the item the entity is holding in their off hand.
   *
   * @param item The item to put into the entities hand
  */
  setItemInOffHand(itemInOffHand: ItemStack | null);
  /**
   * Sets the item the entity is holding in their off hand.
   *
   * @param item The item to put into the entities hand
   * @param silent whether or not the equip sound should be silenced
  */
  setItemInOffHand(item: ItemStack | null, silent: boolean): void;
  /**
   * Gets the item the entity is currently holding
   *
   * 
   * This returns a copy if this equipment instance is from a non-player,
   * or it's an empty stack (has AIR as its type).
   * For non-empty stacks from players, this returns a live mirror. You can check if this
   * will return a mirror with
   * {@code
   * EntityEquipment equipment = entity.getEquipment();
   * if (equipment instanceof PlayerInventory) {
   *     equipment.getItemInHand(); // will return a mirror
   * } else {
   *     equipment.getItemInHand(); // will return a copy
   * }
   * }
   *
   * @return the currently held item
   * @see #getItemInMainHand()
   * @see #getItemInOffHand()
   * @deprecated entities can duel wield now use the methods for the
   *      specific hand instead
  */
  getItemInHand(): ItemStack;
  /**
   * Sets the item the entity is holding
   *
   * @param stack The item to put into the entities hand
   * @see #setItemInMainHand(ItemStack)
   * @see #setItemInOffHand(ItemStack)
   * @deprecated entities can duel wield now use the methods for the
   *      specific hand instead
  */
  setItemInHand(itemInHand: ItemStack | null);
  /**
   * Gets the helmet currently being worn by the entity
   *
   * 
   * This returns a copy if this equipment instance is from a non-player.
   * For stacks from players, this returns a live mirror (or null). You can check if this
   * will return a mirror with
   * {@code
   * EntityEquipment equipment = entity.getEquipment();
   * if (equipment instanceof PlayerInventory) {
   *     equipment.getItemInHand(); // will return a mirror
   * } else {
   *     equipment.getItemInHand(); // will return a copy
   * }
   * }
   *
   * @return The helmet being worn
  */
  getHelmet(): ItemStack;
  /**
   * Sets the helmet worn by the entity
   *
   * @param helmet The helmet to put on the entity
  */
  setHelmet(helmet: ItemStack | null);
  /**
   * Sets the helmet worn by the entity
   *
   * @param helmet The helmet to put on the entity
   * @param silent whether or not the equip sound should be silenced
  */
  setHelmet(helmet: ItemStack | null, silent: boolean): void;
  /**
   * Gets the chest plate currently being worn by the entity
   *
   * 
   * This returns a copy if this equipment instance is from a non-player.
   * For stacks from players, this returns a live mirror (or null). You can check if this
   * will return a mirror with
   * {@code
   * EntityEquipment equipment = entity.getEquipment();
   * if (equipment instanceof PlayerInventory) {
   *     equipment.getChestplate(); // will return a mirror
   * } else {
   *     equipment.getChestplate(); // will return a copy
   * }
   * }
   *
   * @return The chest plate being worn
  */
  getChestplate(): ItemStack;
  /**
   * Sets the chest plate worn by the entity
   *
   * @param chestplate The chest plate to put on the entity
  */
  setChestplate(chestplate: ItemStack | null);
  /**
   * Sets the chest plate worn by the entity
   *
   * @param chestplate The chest plate to put on the entity
   * @param silent whether or not the equip sound should be silenced
  */
  setChestplate(chestplate: ItemStack | null, silent: boolean): void;
  /**
   * Gets the leggings currently being worn by the entity
   *
   * 
   * This returns a copy if this equipment instance is from a non-player.
   * For stacks from players, this returns a live mirror (or null). You can check if this
   * will return a mirror with
   * {@code
   * EntityEquipment equipment = entity.getEquipment();
   * if (equipment instanceof PlayerInventory) {
   *     equipment.getLeggings(); // will return a mirror
   * } else {
   *     equipment.getLeggings(); // will return a copy
   * }
   * }
   *
   * @return The leggings being worn
  */
  getLeggings(): ItemStack;
  /**
   * Sets the leggings worn by the entity
   *
   * @param leggings The leggings to put on the entity
  */
  setLeggings(leggings: ItemStack | null);
  /**
   * Sets the leggings worn by the entity
   *
   * @param leggings The leggings to put on the entity
   * @param silent whether or not the equip sound should be silenced
  */
  setLeggings(leggings: ItemStack | null, silent: boolean): void;
  /**
   * Gets the boots currently being worn by the entity
   *
   * 
   * This returns a copy if this equipment instance is from a non-player.
   * For stacks from players, this returns a live mirror (or null). You can check if this
   * will return a mirror with
   * {@code
   * EntityEquipment equipment = entity.getEquipment();
   * if (equipment instanceof PlayerInventory) {
   *     equipment.getBoots(); // will return a mirror
   * } else {
   *     equipment.getBoots(); // will return a copy
   * }
   * }
   *
   * @return The boots being worn
  */
  getBoots(): ItemStack;
  /**
   * Sets the boots worn by the entity
   *
   * @param boots The boots to put on the entity
  */
  setBoots(boots: ItemStack | null);
  /**
   * Sets the boots worn by the entity
   *
   * @param boots The boots to put on the entity
   * @param silent whether or not the equip sound should be silenced
  */
  setBoots(boots: ItemStack | null, silent: boolean): void;
  getArmorContents(): ItemStack[];
  /**
   * Sets the entities armor to the provided array of ItemStacks
   *
   * @param items The items to set the armor as. Individual items may be null.
  */
  setArmorContents(armorContents: ItemStack[]);
  /**
   * Clears the entity of all armor and held items
  */
  clear(): void;
  /**
   * @return drop chance
   * @see #getItemInMainHandDropChance()
   * @see #getItemInOffHandDropChance()
   * @deprecated entities can duel wield now use the methods for the specific
   * hand instead
  */
  getItemInHandDropChance(): number;
  /**
   * @param chance drop chance
   * @see #setItemInMainHandDropChance(float)
   * @see #setItemInOffHandDropChance(float)
   * @deprecated entities can duel wield now use the methods for the specific
   * hand instead
  */
  setItemInHandDropChance(itemInHandDropChance: number);
  /**
   * Gets the chance of the main hand item being dropped upon this creature's
   * death.
   *
   * 
   * A drop chance of 0.0F will never drop
   * A drop chance of 1.0F will always drop
   * 
   *
   * @return chance of the currently held item being dropped (1 for non-{@link Mob})
  */
  getItemInMainHandDropChance(): number;
  /**
   * Sets the chance of the item this creature is currently holding in their
   * main hand being dropped upon this creature's death.
   *
   * 
   * A drop chance of 0.0F will never drop
   * A drop chance of 1.0F will always drop
   * 
   *
   * @param chance the chance of the main hand item being dropped
   * @throws UnsupportedOperationException when called on non-{@link Mob}
  */
  setItemInMainHandDropChance(itemInMainHandDropChance: number);
  /**
   * Gets the chance of the off hand item being dropped upon this creature's
   * death.
   *
   * 
   * A drop chance of 0.0F will never drop
   * A drop chance of 1.0F will always drop
   * 
   *
   * @return chance of the off hand item being dropped (1 for non-{@link Mob})
  */
  getItemInOffHandDropChance(): number;
  /**
   * Sets the chance of the off hand item being dropped upon this creature's
   * death.
   *
   * 
   * A drop chance of 0.0F will never drop
   * A drop chance of 1.0F will always drop
   * 
   *
   * @param chance the chance of off hand item being dropped
   * @throws UnsupportedOperationException when called on non-{@link Mob}
  */
  setItemInOffHandDropChance(itemInOffHandDropChance: number);
  /**
   * Gets the chance of the helmet being dropped upon this creature's death.
   *
   * 
   * A drop chance of 0.0F will never drop
   * A drop chance of 1.0F will always drop
   * 
   *
   * @return the chance of the helmet being dropped (1 for non-{@link Mob})
  */
  getHelmetDropChance(): number;
  /**
   * Sets the chance of the helmet being dropped upon this creature's death.
   *
   * 
   * A drop chance of 0.0F will never drop
   * A drop chance of 1.0F will always drop
   * 
   *
   * @param chance of the helmet being dropped
   * @throws UnsupportedOperationException when called on non-{@link Mob}
  */
  setHelmetDropChance(helmetDropChance: number);
  /**
   * Gets the chance of the chest plate being dropped upon this creature's
   * death.
   *
   * 
   * A drop chance of 0.0F will never drop
   * A drop chance of 1.0F will always drop
   * 
   *
   * @return the chance of the chest plate being dropped (1 for non-{@link Mob})
  */
  getChestplateDropChance(): number;
  /**
   * Sets the chance of the chest plate being dropped upon this creature's
   * death.
   *
   * 
   * A drop chance of 0.0F will never drop
   * A drop chance of 1.0F will always drop
   * 
   *
   * @param chance of the chest plate being dropped
   * @throws UnsupportedOperationException when called on non-{@link Mob}
  */
  setChestplateDropChance(chestplateDropChance: number);
  /**
   * Gets the chance of the leggings being dropped upon this creature's
   * death.
   *
   * 
   * A drop chance of 0.0F will never drop
   * A drop chance of 1.0F will always drop
   * 
   *
   * @return the chance of the leggings being dropped (1 for non-{@link Mob})
  */
  getLeggingsDropChance(): number;
  /**
   * Sets the chance of the leggings being dropped upon this creature's
   * death.
   *
   * 
   * A drop chance of 0.0F will never drop
   * A drop chance of 1.0F will always drop
   * 
   *
   * @param chance chance of the leggings being dropped
   * @throws UnsupportedOperationException when called on non-{@link Mob}
  */
  setLeggingsDropChance(leggingsDropChance: number);
  /**
   * Gets the chance of the boots being dropped upon this creature's death.
   *
   * 
   * A drop chance of 0.0F will never drop
   * A drop chance of 1.0F will always drop
   * 
   *
   * @return the chance of the boots being dropped (1 for non-{@link Mob})
  */
  getBootsDropChance(): number;
  /**
   * Sets the chance of the boots being dropped upon this creature's death.
   *
   * 
   * A drop chance of 0.0F will never drop
   * A drop chance of 1.0F will always drop
   * 
   *
   * @param chance of the boots being dropped
   * @throws UnsupportedOperationException when called on non-{@link Mob}
  */
  setBootsDropChance(bootsDropChance: number);
  /**
   * Get the entity this EntityEquipment belongs to
   *
   * @return the entity this EntityEquipment belongs to
  */
  getHolder(): Entity;
  /**
   * Gets the drop chance of specified slot.
   *
   * 
   * A drop chance of 0.0F will never drop
   * A drop chance of 1.0F will always drop
   * 
   *
   * @param slot the slot to get the drop chance of
   * @return the drop chance for the slot
  */
  getDropChance(slot: EquipmentSlot): number;
  /**
   * Sets the drop chance of the specified slot.
   *
   * 
   * A drop chance of 0.0F will never drop
   * A drop chance of 1.0F will always drop
   * 
   *
   * @param slot the slot to set the drop chance of
   * @param chance the drop chance for the slot
   * @throws UnsupportedOperationException when called on non-{@link Mob} entities
  */
  setDropChance(slot: EquipmentSlot, chance: number): void;
}
/**
 * Represents a campfire recipe.
*/
export class BlastingRecipe extends CookingRecipe<BlastingRecipe> {
  constructor(key: NamespacedKey, result: ItemStack, source: Material, experience: number, cookingTime: number);
  constructor(key: NamespacedKey, result: ItemStack, input: RecipeChoice, experience: number, cookingTime: number);
}
/**
 * Interface to the inventory of a Cartography table.
*/
export class CartographyInventory extends Inventory {

}
/**
 * Interface to the inventory of a Double Chest.
*/
export class DoubleChestInventory extends Inventory {
  /**
   * Get the left half of this double chest.
   *
   * @return The left side inventory
  */
  getLeftSide(): Inventory;
  /**
   * Get the right side of this double chest.
   *
   * @return The right side inventory
  */
  getRightSide(): Inventory;
  getHolder(): DoubleChest | null;
}
/**
 * Represents a merchant. A merchant is a special type of inventory which can
 * facilitate custom trades between items.
*/
export class Merchant {
  /**
   * Get a list of trades currently available from this merchant.
   *
   * @return an immutable list of trades
  */
  getRecipes(): MerchantRecipe[];
  /**
   * Set the list of trades currently available from this merchant.
   * 
   * This will not change the selected trades of players currently trading
   * with this merchant.
   *
   * @param recipes a list of recipes
  */
  setRecipes(recipes: MerchantRecipe[]);
  /**
   * Get the recipe at a certain index of this merchant's trade list.
   *
   * @param i the index
   * @return the recipe
   * @throws IndexOutOfBoundsException if recipe index out of bounds
  */
  getRecipe(i: number): MerchantRecipe;
  /**
   * Set the recipe at a certain index of this merchant's trade list.
   *
   * @param i the index
   * @param recipe the recipe
   * @throws IndexOutOfBoundsException if recipe index out of bounds
  */
  setRecipe(i: number, recipe: MerchantRecipe): void;
  /**
   * Get the number of trades this merchant currently has available.
   *
   * @return the recipe count
  */
  getRecipeCount(): number;
  /**
   * Gets whether this merchant is currently trading.
   *
   * @return whether the merchant is trading
  */
  isTrading(): boolean;
  /**
   * Gets the player this merchant is trading with, or null if it is not
   * currently trading.
   *
   * @return the trader, or null
  */
  getTrader(): HumanEntity | null;
}
/**
 * Represents a complex recipe which has imperative server-defined behavior, eg
 * armor dyeing.
 *
 * Note: Since a complex recipe has dynamic outputs, {@link #getResult()} will
 * sometimes return an AIR ItemStack.
*/
export class ComplexRecipe extends Recipe {

}
export interface ComplexRecipe extends Recipe, Keyed {}
/**
 * An interface to the inventory of an {@link AbstractHorse}.
*/
export class AbstractHorseInventory extends Inventory {
  /**
   * Gets the item in the horse's saddle slot.
   *
   * @return the saddle item
  */
  getSaddle(): ItemStack | null;
  /**
   * Sets the item in the horse's saddle slot.
   *
   * @param stack the new item
  */
  setSaddle(saddle: ItemStack | null);
}
/**
 * Represents a category in the creative inventory.
*/
export class CreativeCategory extends Enum<CreativeCategory> {
  static readonly BUILDING_BLOCKS: CreativeCategory;
  static readonly DECORATIONS: CreativeCategory;
  static readonly REDSTONE: CreativeCategory;
  static readonly TRANSPORTATION: CreativeCategory;
  static readonly MISC: CreativeCategory;
  static readonly FOOD: CreativeCategory;
  static readonly TOOLS: CreativeCategory;
  static readonly COMBAT: CreativeCategory;
  static readonly BREWING: CreativeCategory;
  static valueOf(name: string): CreativeCategory;
  static values(): CreativeCategory[];
  translationKey(): string;
}
/**
 * Represents a merchant's trade.
 * 
 * Trades can take one or two ingredients, and provide one result. The
 * ingredients' ItemStack amounts are respected in the trade.
 * 
 * A trade has a maximum number of uses. A {@link Villager} may periodically
 * replenish its trades by resetting the {@link #getUses uses} of its merchant
 * recipes to 0, allowing them to be used again.
 * 
 * A trade may or may not reward experience for being completed.
 * 
 * During trades, the {@link MerchantRecipe} dynamically adjusts the amount of
 * its first ingredient based on the following criteria:
 * 
 * {@link #getDemand() Demand}: This value is periodically updated by the
 * villager that owns this merchant recipe based on how often the recipe has
 * been used since it has been last restocked in relation to its
 * {@link #getMaxUses maximum uses}. The amount by which the demand influences
 * the amount of the first ingredient is scaled by the recipe's
 * {@link #getPriceMultiplier price multiplier}, and can never be below zero.
 * {@link #getSpecialPrice() Special price}: This value is dynamically
 * updated whenever a player starts and stops trading with a villager that owns
 * this merchant recipe. It is based on the player's individual reputation with
 * the villager, and the player's currently active status effects (see
 * {@link PotionEffectType#HERO_OF_THE_VILLAGE}). The influence of the player's
 * reputation on the special price is scaled by the recipe's
 * {@link #getPriceMultiplier price multiplier}.
 * 
 * The adjusted amount of the first ingredient is calculated by adding up the
 * original amount of the first ingredient, the demand scaled by the recipe's
 * {@link #getPriceMultiplier price multiplier} and truncated to the next lowest
 * integer value greater than or equal to 0, and the special price, and then
 * constraining the resulting value between 1 and the item stack's
 * {@link ItemStack#getMaxStackSize() maximum stack size}.
*/
export class MerchantRecipe extends Recipe {
  constructor(result: ItemStack, maxUses: number);
  constructor(result: ItemStack, uses: number, maxUses: number, experienceReward: boolean);
  constructor(result: ItemStack, uses: number, maxUses: number, experienceReward: boolean, villagerExperience: number, priceMultiplier: number);
  constructor(result: ItemStack, uses: number, maxUses: number, experienceReward: boolean, villagerExperience: number, priceMultiplier: number, demand: number, specialPrice: number);
  constructor(result: ItemStack, uses: number, maxUses: number, experienceReward: boolean, villagerExperience: number, priceMultiplier: number, ignoreDiscounts: boolean);
  constructor(result: ItemStack, uses: number, maxUses: number, experienceReward: boolean, villagerExperience: number, priceMultiplier: number, demand: number, specialPrice: number, ignoreDiscounts: boolean);
  /**
   * Get the result of this recipe.
   *
   * @return The result stack
  */
  getResult(): ItemStack;
  addIngredient(item: ItemStack): void;
  removeIngredient(index: number): void;
  setIngredients(ingredients: ItemStack[]);
  getIngredients(): ItemStack[];
  /**
   * Gets the {@link #adjust(ItemStack) adjusted} first ingredient.
   *
   * @return the adjusted first ingredient, or null if this
   * recipe has no ingredients
   * @see #adjust(ItemStack)
  */
  getAdjustedIngredient1(): ItemStack | null;
  /**
   * Modifies the amount of the given {@link ItemStack} in the same way as
   * MerchantRecipe dynamically adjusts the amount of the first ingredient
   * during trading.
   * 
   * This is calculated by adding up the original amount of the item, the
   * demand scaled by the recipe's
   * {@link #getPriceMultiplier price multiplier} and truncated to the next
   * lowest integer value greater than or equal to 0, and the special price,
   * and then constraining the resulting value between 1 and the
   * {@link ItemStack}'s {@link ItemStack#getMaxStackSize()
   * maximum stack size}.
   *
   * @param itemStack the item to adjust
  */
  adjust(itemStack: ItemStack | null): void;
  /**
   * Get the demand for this trade.
   *
   * @return the demand
  */
  getDemand(): number;
  /**
   * Set the demand for this trade.
   *
   * @param demand the new demand
  */
  setDemand(demand: number);
  /**
   * Get the special price for this trade.
   *
   * @return special price value
  */
  getSpecialPrice(): number;
  /**
   * Set the special price for this trade.
   *
   * @param specialPrice special price value
  */
  setSpecialPrice(specialPrice: number);
  /**
   * Get the number of times this trade has been used.
   *
   * @return the number of uses
  */
  getUses(): number;
  /**
   * Set the number of times this trade has been used.
   *
   * @param uses the number of uses
  */
  setUses(uses: number);
  /**
   * Get the maximum number of uses this trade has.
   *
   * @return the maximum number of uses
  */
  getMaxUses(): number;
  /**
   * Set the maximum number of uses this trade has.
   *
   * @param maxUses the maximum number of time this trade can be used
  */
  setMaxUses(maxUses: number);
  /**
   * Whether to reward experience to the player for the trade.
   *
   * @return whether to reward experience to the player for completing this
   * trade
  */
  hasExperienceReward(): boolean;
  /**
   * Set whether to reward experience to the player for the trade.
   *
   * @param flag whether to reward experience to the player for completing
   * this trade
  */
  setExperienceReward(flag: boolean): void;
  /**
   * Gets the amount of experience the villager earns from this trade.
   *
   * @return villager experience
  */
  getVillagerExperience(): number;
  /**
   * Sets the amount of experience the villager earns from this trade.
   *
   * @param villagerExperience new experience amount
  */
  setVillagerExperience(villagerExperience: number);
  /**
   * Gets the price multiplier for the cost of this trade.
   *
   * @return price multiplier
  */
  getPriceMultiplier(): number;
  /**
   * Sets the price multiplier for the cost of this trade.
   *
   * @param priceMultiplier new price multiplier
  */
  setPriceMultiplier(priceMultiplier: number);
  /**
   * @return Whether all discounts on this trade should be ignored.
  */
  shouldIgnoreDiscounts(): boolean;
  /**
   * @param ignoreDiscounts Whether all discounts on this trade should be ignored.
  */
  setIgnoreDiscounts(ignoreDiscounts: boolean): void;
}
/**
 * Interface to the crafting inventories
*/
export class CraftingInventory extends Inventory {
  /**
   * Check what item is in the result slot of this crafting inventory.
   *
   * @return The result item.
  */
  getResult(): ItemStack | null;
  getMatrix(): ItemStack[] | null;
  /**
   * Set the item in the result slot of the crafting inventory.
   *
   * @param newResult The new result item.
  */
  setResult(result: ItemStack | null);
  setMatrix(matrix: ItemStack[] | null);
  /**
   * Get the current recipe formed on the crafting inventory, if any.
   *
   * @return The recipe, or null if the current contents don't match any
   *     recipe.
  */
  getRecipe(): Recipe | null;
}
export class EquipmentSlot extends Enum<EquipmentSlot> {
  static readonly HAND: EquipmentSlot;
  static readonly OFF_HAND: EquipmentSlot;
  static readonly FEET: EquipmentSlot;
  static readonly LEGS: EquipmentSlot;
  static readonly CHEST: EquipmentSlot;
  static readonly HEAD: EquipmentSlot;
  static valueOf(name: string): EquipmentSlot;
  static values(): EquipmentSlot[];
}
/**
 * Interface to the inventory of a Smithing table.
*/
export class SmithingInventory extends Inventory {
  /**
   * Check what item is in the result slot of this smithing table.
   *
   * @return the result item
  */
  getResult(): ItemStack | null;
  /**
   * Set the item in the result slot of the smithing table
   *
   * @param newResult the new result item
  */
  setResult(result: ItemStack | null);
  /**
   * Get the current recipe formed on the smithing table, if any.
   *
   * @return the recipe, or null if the current contents don't match any
   * recipe
  */
  getRecipe(): Recipe | null;
  /**
   * Gets the input equipment (first slot).
   *
   * @return input equipment item
  */
  getInputEquipment(): ItemStack | null;
  /**
   * Sets the input equipment (first slot).
   *
   * @param itemStack item to set
  */
  setInputEquipment(inputEquipment: ItemStack | null);
  /**
   * Gets the input mineral (second slot).
   *
   * @return input mineral item
  */
  getInputMineral(): ItemStack | null;
  /**
   * Sets the input mineral (second slot).
   *
   * @param itemStack item to set
  */
  setInputMineral(inputMineral: ItemStack | null);
}
export class ArmoredHorseInventory extends AbstractHorseInventory {
  /**
   * Gets the item in the horse's armor slot.
   *
   * @return the armor item
  */
  getArmor(): ItemStack | null;
  /**
   * Sets the item in the horse's armor slot.
   *
   * @param stack the new item
  */
  setArmor(armor: ItemStack | null);
}
/**
 * A ItemFlag can hide some Attributes from ItemStacks
*/
export class ItemFlag extends Enum<ItemFlag> {
  /**
   * Setting to show/hide enchants
  */
  static readonly HIDE_ENCHANTS: ItemFlag;
  /**
   * Setting to show/hide Attributes like Damage
  */
  static readonly HIDE_ATTRIBUTES: ItemFlag;
  /**
   * Setting to show/hide the unbreakable State
  */
  static readonly HIDE_UNBREAKABLE: ItemFlag;
  /**
   * Setting to show/hide what the ItemStack can break/destroy
  */
  static readonly HIDE_DESTROYS: ItemFlag;
  /**
   * Setting to show/hide where this ItemStack can be build/placed on
  */
  static readonly HIDE_PLACED_ON: ItemFlag;
  /**
   * Setting to show/hide potion effects, book and firework information, map
   * tooltips, and enchantments of enchanted books.
  */
  static readonly HIDE_POTION_EFFECTS: ItemFlag;
  /**
   * Setting to show/hide dyes from coloured leather armour
  */
  static readonly HIDE_DYE: ItemFlag;
  static valueOf(name: string): ItemFlag;
  static values(): ItemFlag[];
}
/**
 * Represents a shapeless recipe, where the arrangement of the ingredients on
 * the crafting grid does not matter.
*/
export class ShapelessRecipe extends Recipe {
  constructor(result: ItemStack);
  /**
   * Create a shapeless recipe to craft the specified ItemStack. The
   * constructor merely determines the result and type; to set the actual
   * recipe, you'll need to call the appropriate methods.
   *
   * @param key the unique recipe key
   * @param result The item you want the recipe to create.
   * @see ShapelessRecipe#addIngredient(Material)
   * @see ShapelessRecipe#addIngredient(MaterialData)
   * @see ShapelessRecipe#addIngredient(Material,int)
   * @see ShapelessRecipe#addIngredient(int,Material)
   * @see ShapelessRecipe#addIngredient(int,MaterialData)
   * @see ShapelessRecipe#addIngredient(int,Material,int)
  */
  constructor(key: NamespacedKey, result: ItemStack);
  /**
   * Adds the specified ingredient.
   *
   * @param ingredient The ingredient to add.
   * @return The changed recipe, so you can chain calls.
   * @deprecated use {@link #addIngredient(RecipeChoice)}
  */
  addIngredient(ingredient: MaterialData): ShapelessRecipe;
  /**
   * Adds the specified ingredient.
   *
   * @param ingredient The ingredient to add.
   * @return The changed recipe, so you can chain calls.
  */
  addIngredient(ingredient: Material): ShapelessRecipe;
  /**
   * Adds the specified ingredient.
   *
   * @param ingredient The ingredient to add.
   * @param rawdata The data value, or -1 to allow any data value.
   * @return The changed recipe, so you can chain calls.
   * @deprecated Magic value
  */
  addIngredient(ingredient: Material, rawdata: number): ShapelessRecipe;
  /**
   * Adds multiples of the specified ingredient.
   *
   * @param count How many to add (can't be more than 9!)
   * @param ingredient The ingredient to add.
   * @return The changed recipe, so you can chain calls.
   * @deprecated use {@link #addIngredient(int, Material)}
  */
  addIngredient(count: number, ingredient: MaterialData): ShapelessRecipe;
  /**
   * Adds multiples of the specified ingredient.
   *
   * @param count How many to add (can't be more than 9!)
   * @param ingredient The ingredient to add.
   * @return The changed recipe, so you can chain calls.
  */
  addIngredient(count: number, ingredient: Material): ShapelessRecipe;
  /**
   * Adds multiples of the specified ingredient.
   *
   * @param count How many to add (can't be more than 9!)
   * @param ingredient The ingredient to add.
   * @param rawdata The data value, or -1 to allow any data value.
   * @return The changed recipe, so you can chain calls.
   * @deprecated Magic value
  */
  addIngredient(count: number, ingredient: Material, rawdata: number): ShapelessRecipe;
  addIngredient(ingredient: RecipeChoice): ShapelessRecipe;
  addIngredient(item: ItemStack): ShapelessRecipe;
  addIngredient(count: number, item: ItemStack): ShapelessRecipe;
  removeIngredient(item: ItemStack): ShapelessRecipe;
  removeIngredient(count: number, item: ItemStack): ShapelessRecipe;
  /**
   * Removes an ingredient from the list.
   *
   * @param ingredient The ingredient to remove
   * @return The changed recipe.
  */
  removeIngredient(ingredient: RecipeChoice): ShapelessRecipe;
  /**
   * Removes an ingredient from the list. If the ingredient occurs multiple
   * times, only one instance of it is removed. Only removes exact matches,
   * with a data value of 0.
   *
   * @param ingredient The ingredient to remove
   * @return The changed recipe.
  */
  removeIngredient(ingredient: Material): ShapelessRecipe;
  /**
   * Removes an ingredient from the list. If the ingredient occurs multiple
   * times, only one instance of it is removed. If the data value is -1,
   * only ingredients with a -1 data value will be removed.
   *
   * @param ingredient The ingredient to remove
   * @return The changed recipe.
   * @deprecated use {@link #removeIngredient(Material)}
  */
  removeIngredient(ingredient: MaterialData): ShapelessRecipe;
  /**
   * Removes multiple instances of an ingredient from the list. If there are
   * less instances then specified, all will be removed. Only removes exact
   * matches, with a data value of 0.
   *
   * @param count The number of copies to remove.
   * @param ingredient The ingredient to remove
   * @return The changed recipe.
  */
  removeIngredient(count: number, ingredient: Material): ShapelessRecipe;
  /**
   * Removes multiple instances of an ingredient from the list. If there are
   * less instances then specified, all will be removed. If the data value
   * is -1, only ingredients with a -1 data value will be removed.
   *
   * @param count The number of copies to remove.
   * @param ingredient The ingredient to remove.
   * @return The changed recipe.
   * @deprecated use {@link #removeIngredient(int, Material)}
  */
  removeIngredient(count: number, ingredient: MaterialData): ShapelessRecipe;
  /**
   * Removes an ingredient from the list. If the ingredient occurs multiple
   * times, only one instance of it is removed. If the data value is -1,
   * only ingredients with a -1 data value will be removed.
   *
   * @param ingredient The ingredient to remove
   * @param rawdata The data value;
   * @return The changed recipe.
   * @deprecated Magic value
  */
  removeIngredient(ingredient: Material, rawdata: number): ShapelessRecipe;
  /**
   * Removes multiple instances of an ingredient from the list. If there are
   * less instances then specified, all will be removed. If the data value
   * is -1, only ingredients with a -1 data value will be removed.
   *
   * @param count The number of copies to remove.
   * @param ingredient The ingredient to remove.
   * @param rawdata The data value.
   * @return The changed recipe.
   * @deprecated Magic value
  */
  removeIngredient(count: number, ingredient: Material, rawdata: number): ShapelessRecipe;
  /**
   * Get the result of this recipe.
   *
   * @return The result stack.
  */
  getResult(): ItemStack;
  /**
   * Get the list of ingredients used for this recipe.
   *
   * @return The input list
  */
  getIngredientList(): ItemStack[];
  getChoiceList(): RecipeChoice[];
  /**
   * Return the namespaced identifier for this object.
   *
   * @return this object's key
  */
  getKey(): NamespacedKey;
  /**
   * Get the group of this recipe. Recipes with the same group may be grouped
   * together when displayed in the client.
   *
   * @return recipe group. An empty string denotes no group. May not be null.
  */
  getGroup(): string;
  /**
   * Set the group of this recipe. Recipes with the same group may be grouped
   * together when displayed in the client.
   *
   * @param group recipe group. An empty string denotes no group. May not be
   * null.
  */
  setGroup(group: string);
}
export interface ShapelessRecipe extends Recipe, Keyed {}
/**
 * Represents some type of crafting recipe.
*/
export class Recipe {
  /**
   * Get the result of this recipe.
   *
   * @return The result stack
  */
  getResult(): ItemStack;
}
/**
 * Represents a shaped (ie normal) crafting recipe.
*/
export class ShapedRecipe extends Recipe {
  constructor(result: ItemStack);
  /**
   * Create a shaped recipe to craft the specified ItemStack. The
   * constructor merely determines the result and type; to set the actual
   * recipe, you'll need to call the appropriate methods.
   *
   * @param key the unique recipe key
   * @param result The item you want the recipe to create.
   * @see ShapedRecipe#shape(String...)
   * @see ShapedRecipe#setIngredient(char, Material)
   * @see ShapedRecipe#setIngredient(char, Material, int)
   * @see ShapedRecipe#setIngredient(char, MaterialData)
  */
  constructor(key: NamespacedKey, result: ItemStack);
  /**
   * Set the shape of this recipe to the specified rows. Each character
   * represents a different ingredient; exactly what each character
   * represents is set separately. The first row supplied corresponds with
   * the upper most part of the recipe on the workbench e.g. if all three
   * rows are supplies the first string represents the top row on the
   * workbench.
   *
   * @param shape The rows of the recipe (up to 3 rows).
   * @return The changed recipe, so you can chain calls.
  */
  shape(...shape: string[]): ShapedRecipe;
  /**
   * Sets the material that a character in the recipe shape refers to.
   *
   * @param key The character that represents the ingredient in the shape.
   * @param ingredient The ingredient.
   * @return The changed recipe, so you can chain calls.
   * @deprecated use {@link #setIngredient(char, RecipeChoice)}
  */
  setIngredient(key: string, ingredient: MaterialData): ShapedRecipe;
  /**
   * Sets the material that a character in the recipe shape refers to.
   *
   * @param key The character that represents the ingredient in the shape.
   * @param ingredient The ingredient.
   * @return The changed recipe, so you can chain calls.
  */
  setIngredient(key: string, ingredient: Material): ShapedRecipe;
  /**
   * Sets the material that a character in the recipe shape refers to.
   *
   * @param key The character that represents the ingredient in the shape.
   * @param ingredient The ingredient.
   * @param raw The raw material data as an integer.
   * @return The changed recipe, so you can chain calls.
   * @deprecated Magic value
  */
  setIngredient(key: string, ingredient: Material, raw: number): ShapedRecipe;
  setIngredient(key: string, ingredient: RecipeChoice): ShapedRecipe;
  setIngredient(key: string, item: ItemStack): ShapedRecipe;
  /**
   * Get a copy of the ingredients map.
   *
   * @return The mapping of character to ingredients.
  */
  getIngredientMap(): Map<string, ItemStack>;
  getChoiceMap(): Map<string, RecipeChoice>;
  /**
   * Get the shape.
   *
   * @return The recipe's shape.
   * @throws NullPointerException when not set yet
  */
  getShape(): string[];
  /**
   * Get the result.
   *
   * @return The result stack.
  */
  getResult(): ItemStack;
  /**
   * Return the namespaced identifier for this object.
   *
   * @return this object's key
  */
  getKey(): NamespacedKey;
  /**
   * Get the group of this recipe. Recipes with the same group may be grouped
   * together when displayed in the client.
   *
   * @return recipe group. An empty string denotes no group. May not be null.
  */
  getGroup(): string;
  /**
   * Set the group of this recipe. Recipes with the same group may be grouped
   * together when displayed in the client.
   *
   * @param group recipe group. An empty string denotes no group. May not be
   * null.
  */
  setGroup(group: string);
}
export interface ShapedRecipe extends Recipe, Keyed {}
/**
 * Represents a cooking recipe.
 * @param  type of recipe
*/
export class CookingRecipe<T> extends Recipe {
  /**
   * Create a cooking recipe to craft the specified ItemStack.
   *
   * @param key The unique recipe key
   * @param result The item you want the recipe to create.
   * @param source The input material.
   * @param experience The experience given by this recipe
   * @param cookingTime The cooking time (in ticks)
  */
  constructor(key: NamespacedKey, result: ItemStack, source: Material, experience: number, cookingTime: number);
  /**
   * Create a cooking recipe to craft the specified ItemStack.
   *
   * @param key The unique recipe key
   * @param result The item you want the recipe to create.
   * @param input The input choices.
   * @param experience The experience given by this recipe
   * @param cookingTime The cooking time (in ticks)
  */
  constructor(key: NamespacedKey, result: ItemStack, input: RecipeChoice, experience: number, cookingTime: number);
  /**
   * Sets the input of this cooking recipe.
   *
   * @param input The input material.
   * @return The changed recipe, so you can chain calls.
  */
  setInput(input: Material);
  /**
   * Get the input material.
   *
   * @return The input material.
  */
  getInput(): ItemStack;
  /**
   * Sets the input of this cooking recipe.
   *
   * @param input The input choice.
   * @return The changed recipe, so you can chain calls.
  */
  setInputChoice(inputChoice: RecipeChoice);
  /**
   * Get the input choice.
   *
   * @return The input choice.
  */
  getInputChoice(): RecipeChoice;
  /**
   * Get the result of this recipe.
   *
   * @return The resulting stack.
  */
  getResult(): ItemStack;
  /**
   * Sets the experience given by this recipe.
   *
   * @param experience the experience level
  */
  setExperience(experience: number);
  /**
   * Get the experience given by this recipe.
   *
   * @return experience level
  */
  getExperience(): number;
  /**
   * Set the cooking time for this recipe in ticks.
   *
   * @param cookingTime new cooking time
  */
  setCookingTime(cookingTime: number);
  /**
   * Get the cooking time for this recipe in ticks.
   *
   * @return cooking time
  */
  getCookingTime(): number;
  /**
   * Return the namespaced identifier for this object.
   *
   * @return this object's key
  */
  getKey(): NamespacedKey;
  /**
   * Get the group of this recipe. Recipes with the same group may be grouped
   * together when displayed in the client.
   *
   * @return recipe group. An empty string denotes no group. May not be null.
  */
  getGroup(): string;
  /**
   * Set the group of this recipe. Recipes with the same group may be grouped
   * together when displayed in the client.
   *
   * @param group recipe group. An empty string denotes no group. May not be
   * null.
  */
  setGroup(group: string);
}
export interface CookingRecipe<T> extends Recipe, Keyed {}
/**
 * Interface to the various inventories. Behavior relating to {@link
 * Material#AIR} is unspecified.
 *
 * 
 * Note that whilst {@link #iterator()} deals with the entire inventory, add
 * / contains / remove methods deal only with the storage contents.
 * 
 * Consider using {@link #getContents()} and {@link #getStorageContents()} for
 * specific iteration.
 *
 * @see #getContents()
 * @see #getStorageContents()
*/
export class Inventory extends Iterable<ItemStack> {
  /**
   * Returns the size of the inventory
   *
   * @return The size of the inventory
  */
  getSize(): number;
  /**
   * Returns the maximum stack size for an ItemStack in this inventory.
   *
   * @return The maximum size for an ItemStack in this inventory.
  */
  getMaxStackSize(): number;
  /**
   * This method allows you to change the maximum stack size for an
   * inventory.
   * 
   * Caveats:
   * 
   * Not all inventories respect this value.
   * Stacks larger than 127 may be clipped when the world is saved.
   * This value is not guaranteed to be preserved; be sure to set it
   *     before every time you want to set a slot over the max stack size.
   * Stacks larger than the default max size for this type of inventory
   *     may not display correctly in the client.
   * 
   *
   * @param size The new maximum stack size for items in this inventory.
  */
  setMaxStackSize(maxStackSize: number);
  /**
   * Returns the ItemStack found in the slot at the given index
   *
   * @param index The index of the Slot's ItemStack to return
   * @return The ItemStack in the slot
  */
  getItem(index: number): ItemStack | null;
  /**
   * Stores the ItemStack at the given index of the inventory.
   *
   * @param index The index where to put the ItemStack
   * @param item The ItemStack to set
  */
  setItem(index: number, item: ItemStack | null): void;
  /**
   * Stores the given ItemStacks in the inventory. This will try to fill
   * existing stacks and empty slots as well as it can.
   * 
   * The returned HashMap contains what it couldn't store, where the key is
   * the index of the parameter, and the value is the ItemStack at that
   * index of the varargs parameter. If all items are stored, it will return
   * an empty HashMap.
   * 
   * If you pass in ItemStacks which exceed the maximum stack size for the
   * Material, first they will be added to partial stacks where
   * Material.getMaxStackSize() is not exceeded, up to
   * Material.getMaxStackSize(). When there are no partial stacks left
   * stacks will be split on Inventory.getMaxStackSize() allowing you to
   * exceed the maximum stack size for that material.
   * 
   * It is known that in some implementations this method will also set
   * the inputted argument amount to the number of that item not placed in
   * slots.
   *
   * @param items The ItemStacks to add
   * @return A HashMap containing items that didn't fit.
   * @throws IllegalArgumentException if items or any element in it is null
  */
  addItem(...items: ItemStack[]): HashMap<number, ItemStack>;
  /**
   * Removes the given ItemStacks from the inventory.
   * 
   * It will try to remove 'as much as possible' from the types and amounts
   * you give as arguments.
   * 
   * The returned HashMap contains what it couldn't remove, where the key is
   * the index of the parameter, and the value is the ItemStack at that
   * index of the varargs parameter. If all the given ItemStacks are
   * removed, it will return an empty HashMap.
   * 
   * It is known that in some implementations this method will also set the
   * inputted argument amount to the number of that item not removed from
   * slots.
   *
   * @param items The ItemStacks to remove
   * @return A HashMap containing items that couldn't be removed.
   * @throws IllegalArgumentException if items is null
  */
  removeItem(...items: ItemStack[]): HashMap<number, ItemStack>;
  /**
   * Searches all possible inventory slots in order to remove the given ItemStacks.
   * 
   * Similar to {@link Inventory#removeItem(ItemStack...)} in behavior, except this
   * method will check all possible slots in the inventory, rather than just the main
   * storage contents.
   * 
   * It will try to remove 'as much as possible' from the types and amounts
   * you give as arguments.
   * 
   * The returned HashMap contains what it couldn't remove, where the key is
   * the index of the parameter, and the value is the ItemStack at that
   * index of the varargs parameter. If all the given ItemStacks are
   * removed, it will return an empty HashMap.
   * 
   * It is known that in some implementations this method will also set the
   * inputted argument amount to the number of that item not removed from
   * slots.
   *
   * @param items The ItemStacks to remove
   * @return A HashMap containing items that couldn't be removed.
   * @throws IllegalArgumentException if items is null
  */
  removeItemAnySlot(...items: ItemStack[]): HashMap<number, ItemStack>;
  getContents(): ItemStack[] | null;
  setContents(contents: ItemStack[] | null);
  getStorageContents(): ItemStack[] | null;
  setStorageContents(storageContents: ItemStack[] | null);
  /**
   * Checks if the inventory contains any ItemStacks with the given
   * material.
   *
   * @param material The material to check for
   * @return true if an ItemStack is found with the given Material
   * @throws IllegalArgumentException if material is null
  */
  contains(material: Material): boolean;
  /**
   * Checks if the inventory contains any ItemStacks matching the given
   * ItemStack.
   * 
   * This will only return true if both the type and the amount of the stack
   * match.
   *
   * @param item The ItemStack to match against
   * @return false if item is null, true if any exactly matching ItemStacks
   *     were found
  */
  contains(item: ItemStack | null): boolean;
  /**
   * Checks if the inventory contains any ItemStacks with the given
   * material, adding to at least the minimum amount specified.
   *
   * @param material The material to check for
   * @param amount The minimum amount
   * @return true if amount is less than 1, true if enough ItemStacks were
   *     found to add to the given amount
   * @throws IllegalArgumentException if material is null
  */
  contains(material: Material, amount: number): boolean;
  /**
   * Checks if the inventory contains at least the minimum amount specified
   * of exactly matching ItemStacks.
   * 
   * An ItemStack only counts if both the type and the amount of the stack
   * match.
   *
   * @param item the ItemStack to match against
   * @param amount how many identical stacks to check for
   * @return false if item is null, true if amount less than 1, true if
   *     amount of exactly matching ItemStacks were found
   * @see #containsAtLeast(ItemStack, int)
  */
  contains(item: ItemStack | null, amount: number): boolean;
  /**
   * Checks if the inventory contains ItemStacks matching the given
   * ItemStack whose amounts sum to at least the minimum amount specified.
   *
   * @param item the ItemStack to match against
   * @param amount the minimum amount
   * @return false if item is null, true if amount less than 1, true if
   *     enough ItemStacks were found to add to the given amount
  */
  containsAtLeast(item: ItemStack | null, amount: number): boolean;
  /**
   * Returns a HashMap with all slots and ItemStacks in the inventory with
   * the given Material.
   * 
   * The HashMap contains entries where, the key is the slot index, and the
   * value is the ItemStack in that slot. If no matching ItemStack with the
   * given Material is found, an empty map is returned.
   *
   * @param material The material to look for
   * @return A HashMap containing the slot index, ItemStack pairs
   * @throws IllegalArgumentException if material is null
  */
  all(material: Material): HashMap<number, ItemStack>;
  /**
   * Finds all slots in the inventory containing any ItemStacks with the
   * given ItemStack. This will only match slots if both the type and the
   * amount of the stack match
   * 
   * The HashMap contains entries where, the key is the slot index, and the
   * value is the ItemStack in that slot. If no matching ItemStack with the
   * given Material is found, an empty map is returned.
   *
   * @param item The ItemStack to match against
   * @return A map from slot indexes to item at index
  */
  all(item: ItemStack | null): HashMap<number, ItemStack>;
  /**
   * Finds the first slot in the inventory containing an ItemStack with the
   * given material
   *
   * @param material The material to look for
   * @return The slot index of the given Material or -1 if not found
   * @throws IllegalArgumentException if material is null
  */
  first(material: Material): number;
  /**
   * Returns the first slot in the inventory containing an ItemStack with
   * the given stack. This will only match a slot if both the type and the
   * amount of the stack match
   *
   * @param item The ItemStack to match against
   * @return The slot index of the given ItemStack or -1 if not found
  */
  first(item: ItemStack): number;
  /**
   * Returns the first empty Slot.
   *
   * @return The first empty Slot found, or -1 if no empty slots.
  */
  firstEmpty(): number;
  /**
   * Check whether or not this inventory is empty. An inventory is considered
   * to be empty if there are no ItemStacks in any slot of this inventory.
   *
   * @return true if empty, false otherwise
  */
  isEmpty(): boolean;
  /**
   * Removes all stacks in the inventory matching the given material.
   *
   * @param material The material to remove
   * @throws IllegalArgumentException if material is null
  */
  remove(material: Material): void;
  /**
   * Removes all stacks in the inventory matching the given stack.
   * 
   * This will only match a slot if both the type and the amount of the
   * stack match
   *
   * @param item The ItemStack to match against
  */
  remove(item: ItemStack): void;
  /**
   * Clears out a particular slot in the index.
   *
   * @param index The index to empty.
  */
  clear(index: number): void;
  /**
   * Clears out the whole Inventory.
  */
  clear(): void;
  /**
   * Closes the inventory for all viewers.
   *
   * @return the number if viewers the inventory was closed for
  */
  close(): number;
  /**
   * Gets a list of players viewing the inventory. Note that a player is
   * considered to be viewing their own inventory and internal crafting
   * screen even when said inventory is not open. They will normally be
   * considered to be viewing their inventory even when they have a
   * different inventory screen open, but it's possible for customized
   * inventory screens to exclude the viewer's inventory, so this should
   * never be assumed to be non-empty.
   *
   * @return A list of HumanEntities who are viewing this Inventory.
  */
  getViewers(): HumanEntity[];
  /**
   * Returns what type of inventory this is.
   *
   * @return The InventoryType representing the type of inventory.
  */
  getType(): InventoryType;
  /**
   * Gets the block or entity belonging to the open inventory
   *
   * @return The holder of the inventory; null if it has no holder.
  */
  getHolder(): InventoryHolder | null;
  /**
   * Gets the block or entity belonging to the open inventory
   *
   * @param useSnapshot Create a snapshot if the holder is a tile entity
   * @return The holder of the inventory; null if it has no holder.
  */
  getHolder(useSnapshot: boolean): InventoryHolder | null;
  iterator(): ListIterator<ItemStack>;
  /**
   * Returns an iterator starting at the given index. If the index is
   * positive, then the first call to next() will return the item at that
   * index; if it is negative, the first call to previous will return the
   * item at index (getSize() + index).
   *
   * @param index The index.
   * @return An iterator.
  */
  iterator(index: number): ListIterator<ItemStack>;
  /**
   * Get the location of the block or entity which corresponds to this inventory. May return null if this container
   * was custom created or is a virtual / subcontainer.
   *
   * @return location or null if not applicable.
  */
  getLocation(): Location | null;
}
/**
 * Interface to the inventory of a Player, including the four armor slots and any extra slots.
*/
export class PlayerInventory extends Inventory {
  getArmorContents(): ItemStack[] | null;
  getExtraContents(): ItemStack[] | null;
  /**
   * Return the ItemStack from the helmet slot
   *
   * @return The ItemStack in the helmet slot
  */
  getHelmet(): ItemStack | null;
  /**
   * Return the ItemStack from the chestplate slot
   *
   * @return The ItemStack in the chestplate slot
  */
  getChestplate(): ItemStack | null;
  /**
   * Return the ItemStack from the leg slot
   *
   * @return The ItemStack in the leg slot
  */
  getLeggings(): ItemStack | null;
  /**
   * Return the ItemStack from the boots slot
   *
   * @return The ItemStack in the boots slot
  */
  getBoots(): ItemStack | null;
  /**
   * Stores the ItemStack at the given index of the inventory.
   * 
   * Indexes 0 through 8 refer to the hotbar. 9 through 35 refer to the main inventory, counting up from 9 at the top
   * left corner of the inventory, moving to the right, and moving to the row below it back on the left side when it
   * reaches the end of the row. It follows the same path in the inventory like you would read a book.
   * 
   * Indexes 36 through 39 refer to the armor slots. Though you can set armor with this method using these indexes,
   * you are encouraged to use the provided methods for those slots.
   * 
   * Index 40 refers to the off hand (shield) item slot. Though you can set off hand with this method using this index,
   * you are encouraged to use the provided method for this slot.
   * 
   * If you attempt to use this method with an index less than 0 or greater than 40, an ArrayIndexOutOfBounds
   * exception will be thrown.
   *
   * @param index The index where to put the ItemStack
   * @param item The ItemStack to set
   * @throws ArrayIndexOutOfBoundsException when index < 0 || index > 40
   * @see #setBoots(ItemStack)
   * @see #setChestplate(ItemStack)
   * @see #setHelmet(ItemStack)
   * @see #setLeggings(ItemStack)
   * @see #setItemInOffHand(ItemStack)
  */
  setItem(index: number, item: ItemStack | null): void;
  /**
   * Stores the ItemStack at the given equipment slot in the inventory.
   *
   * @param slot the slot to put the ItemStack
   * @param item the ItemStack to set
   *
   * @see #setItem(int, ItemStack)
  */
  setItem(slot: EquipmentSlot, item: ItemStack | null): void;
  /**
   * Gets the ItemStack at the given equipment slot in the inventory.
   *
   * @param slot the slot to get the ItemStack
   *
   * @return the ItemStack in the given slot
  */
  getItem(slot: EquipmentSlot): ItemStack;
  /**
   * Put the given ItemStacks into the armor slots
   *
   * @param items The ItemStacks to use as armour
  */
  setArmorContents(armorContents: ItemStack[] | null);
  /**
   * Put the given ItemStacks into the extra slots
   * 
   * See {@link #getExtraContents()} for an explanation of extra slots.
   *
   * @param items The ItemStacks to use as extra
  */
  setExtraContents(extraContents: ItemStack[] | null);
  /**
   * Put the given ItemStack into the helmet slot. This does not check if
   * the ItemStack is a helmet
   *
   * @param helmet The ItemStack to use as helmet
  */
  setHelmet(helmet: ItemStack | null);
  /**
   * Put the given ItemStack into the chestplate slot. This does not check
   * if the ItemStack is a chestplate
   *
   * @param chestplate The ItemStack to use as chestplate
  */
  setChestplate(chestplate: ItemStack | null);
  /**
   * Put the given ItemStack into the leg slot. This does not check if the
   * ItemStack is a pair of leggings
   *
   * @param leggings The ItemStack to use as leggings
  */
  setLeggings(leggings: ItemStack | null);
  /**
   * Put the given ItemStack into the boots slot. This does not check if the
   * ItemStack is a boots
   *
   * @param boots The ItemStack to use as boots
  */
  setBoots(boots: ItemStack | null);
  /**
   * Gets the item the player is currently holding
   * in their main hand.
   *
   * @return the currently held item
  */
  getItemInMainHand(): ItemStack;
  /**
   * Sets the item the player is holding in their main hand.
   *
   * @param item The item to put into the player's hand
  */
  setItemInMainHand(itemInMainHand: ItemStack | null);
  /**
   * Gets the item the player is currently holding
   * in their off hand.
   *
   * @return the currently held item
  */
  getItemInOffHand(): ItemStack;
  /**
   * Sets the item the player is holding in their off hand.
   *
   * @param item The item to put into the player's hand
  */
  setItemInOffHand(itemInOffHand: ItemStack | null);
  /**
   * Gets the item the player is currently holding
   *
   * @return the currently held item
   * @see #getItemInMainHand()
   * @see #getItemInOffHand()
   * @deprecated players can duel wield now use the methods for the
   *      specific hand instead
  */
  getItemInHand(): ItemStack;
  /**
   * Sets the item the player is holding
   *
   * @param stack The item to put into the player's hand
   * @see #setItemInMainHand(ItemStack)
   * @see #setItemInOffHand(ItemStack)
   * @deprecated players can duel wield now use the methods for the
   *      specific hand instead
  */
  setItemInHand(itemInHand: ItemStack | null);
  /**
   * Get the slot number of the currently held item
   *
   * @return Held item slot number
  */
  getHeldItemSlot(): number;
  /**
   * Set the slot number of the currently held item.
   * 
   * This validates whether the slot is between 0 and 8 inclusive.
   *
   * @param slot The new slot number
   * @throws IllegalArgumentException Thrown if slot is not between 0 and 8
   *     inclusive
  */
  setHeldItemSlot(heldItemSlot: number);
  getHolder(): HumanEntity | null;
  /**
   * Returns the ItemStack found in the slot at the given index
   *
   * @param index The index of the Slot's ItemStack to return
   * @return The ItemStack in the slot
  */
  getItem(index: number): ItemStack | null;
}
/**
 * An interface to the inventory of a Horse.
*/
export class HorseInventory extends AbstractHorseInventory {

}
export interface HorseInventory extends AbstractHorseInventory, ArmoredHorseInventory {}

}
declare module 'org.bukkit.event.world.TimeSkipEvent' {
import { Enum } from 'java.lang';
/**
 * An enum specifying the reason the time skipped.
*/
export class SkipReason extends Enum<SkipReason> {
  /**
   * When time is changed using the vanilla /time command.
  */
  static readonly COMMAND: SkipReason;
  /**
   * When time is changed by a plugin.
  */
  static readonly CUSTOM: SkipReason;
  /**
   * When time is changed by all players sleeping in their beds and the
   * night skips.
  */
  static readonly NIGHT_SKIP: SkipReason;
  static valueOf(name: string): SkipReason;
  static values(): SkipReason[];
}

}
declare module 'org.bukkit.entity' {
import { Spell as org_bukkit_entity_Evoker_Spell } from 'org.bukkit.entity.Evoker';
import { BossBar, DragonBattle } from 'org.bukkit.boss';
import { Attributable } from 'org.bukkit.attribute';
import { AdvancementProgress, Advancement } from 'org.bukkit.advancement';
import { FireworkMeta, PotionMeta } from 'org.bukkit.inventory.meta';
import { Spigot as org_bukkit_entity_Player_Spigot } from 'org.bukkit.entity.Player';
import { InventoryView, LlamaInventory, Merchant, EntityEquipment, AbstractHorseInventory, EquipmentSlot, PlayerInventory, HorseInventory, MainHand, ItemStack, InventoryHolder, Inventory } from 'org.bukkit.inventory';
import { Art, Server, TreeSpecies, World, FluidCollisionMode, Particle, Nameable, EntityEffect, WeatherType, NamespacedKey, WorldBorder, OfflinePlayer, SoundCategory, Color as org_bukkit_Color, Material, Sound, Chunk, DyeColor, Rotation, GameMode, Note, Instrument, Effect, BanEntry, Location } from 'org.bukkit';
import { Variant as org_bukkit_entity_Axolotl_Variant } from 'org.bukkit.entity.Axolotl';
import { InetSocketAddress } from 'java.net';
import { BlockFace, PistonMoveReaction, Block, Sign } from 'org.bukkit.block';
import { Title, ClientOption } from 'com.destroystokyo.paper';
import { Plugin } from 'org.bukkit.plugin';
import { Conversable } from 'org.bukkit.conversations';
import { PlayerProfile } from 'com.destroystokyo.paper.profile';
import { Type as org_bukkit_entity_Ocelot_Type } from 'org.bukkit.entity.Ocelot';
import { Type as org_bukkit_entity_Rabbit_Type } from 'org.bukkit.entity.Rabbit';
import { Spigot } from 'org.bukkit.entity.Entity';
import { SpawnReason } from 'org.bukkit.event.entity.CreatureSpawnEvent';
import { CompletableFuture } from 'java.util.concurrent';
import { ProjectileSource } from 'org.bukkit.projectiles';
import { Type as org_bukkit_entity_Cat_Type } from 'org.bukkit.entity.Cat';
import { Type, Profession } from 'org.bukkit.entity.Villager';
import { Book } from 'net.kyori.adventure.inventory';
import { Property } from 'org.bukkit.inventory.InventoryView';
import { Enum, Class } from 'java.lang';
import { Emitter } from 'net.kyori.adventure.sound.Sound';
import { Variant as org_bukkit_entity_Horse_Variant, Color as org_bukkit_entity_Horse_Color, Style } from 'org.bukkit.entity.Horse';
import { Type as org_bukkit_entity_Fox_Type } from 'org.bukkit.entity.Fox';
import { Cause } from 'org.bukkit.event.player.PlayerKickEvent';
import { HookState } from 'org.bukkit.entity.FishHook';
import { UnaryOperator } from 'java.util.function';
import { Scoreboard } from 'org.bukkit.scoreboard';
import { ShowEntity } from 'net.kyori.adventure.text.event.HoverEvent';
import { Variant as org_bukkit_entity_Parrot_Variant } from 'org.bukkit.entity.Parrot';
import { Locale, Set, Collection, List, UUID, Map, Date } from 'java.util';
import { Gene } from 'org.bukkit.entity.Panda';
import { Head } from 'org.bukkit.entity.Wither';
import { PluginMessageRecipient } from 'org.bukkit.plugin.messaging';
import { NetworkClient } from 'com.destroystokyo.paper.network';
import { EntityDamageEvent } from 'org.bukkit.event.entity';
import { Pattern } from 'org.bukkit.entity.TropicalFish';
import { Builder } from 'net.kyori.adventure.inventory.Book';
import { Reason } from 'org.bukkit.event.inventory.InventoryCloseEvent';
import { TargetBlockInfo } from 'com.destroystokyo.paper.block';
import { PotionData, PotionEffect, PotionEffectType } from 'org.bukkit.potion';
import { HoverEventSource, HoverEvent } from 'net.kyori.adventure.text.event';
import { Color } from 'org.bukkit.entity.Llama';
import { Spigot as org_bukkit_entity_LightningStrike_Spigot } from 'org.bukkit.entity.LightningStrike';
import { TriState } from 'net.kyori.adventure.util';
import { Lootable } from 'org.bukkit.loot';
import { Colorable, MaterialData, Attachable } from 'org.bukkit.material';
import { SoundStop, Sound as net_kyori_adventure_sound_Sound } from 'net.kyori.adventure.sound';
import { Variant } from 'org.bukkit.entity.MushroomCow';
import { PickupRule, PickupStatus } from 'org.bukkit.entity.AbstractArrow';
import { ComponentLike, Component } from 'net.kyori.adventure.text';
import { CollarColorable, Bucketable } from 'io.papermc.paper.entity';
import { MapView } from 'org.bukkit.map';
import { CommandSender } from 'org.bukkit.command';
import { SkeletonType } from 'org.bukkit.entity.Skeleton';
import { Metadatable } from 'org.bukkit.metadata';
import { Spell } from 'org.bukkit.entity.Spellcaster';
import { MemoryKey } from 'org.bukkit.entity.memory';
import { Reputation } from 'com.destroystokyo.paper.entity.villager';
import { FluidMode } from 'com.destroystokyo.paper.block.TargetBlockInfo';
import { SpawnReason as org_bukkit_entity_ExperienceOrb_SpawnReason } from 'org.bukkit.entity.ExperienceOrb';
import { TeleportCause } from 'org.bukkit.event.player.PlayerTeleportEvent';
import { Status } from 'org.bukkit.event.player.PlayerResourcePackStatusEvent';
import { Identified, Identity } from 'net.kyori.adventure.identity';
import { BoundingBox, RayTraceResult, EulerAngle, Vector } from 'org.bukkit.util';
import { LockType } from 'org.bukkit.entity.ArmorStand';
import { Pathfinder, RangedEntity, TargetEntityInfo } from 'com.destroystokyo.paper.entity';
import { BlockData } from 'org.bukkit.block.data';
import { Phase } from 'org.bukkit.entity.EnderDragon';
import { PersistentDataHolder } from 'org.bukkit.persistence';
/**
 * Represents a Blaze monster
*/
export class Blaze extends Monster {

}
/**
 * Represents a Zoglin.
*/
export class Zoglin extends Monster {
  /**
   * Gets whether the zoglin is a baby
   *
   * @return Whether the zoglin is a baby
   * @deprecated see {@link Ageable#isAdult()}
  */
  isBaby(): boolean;
  /**
   * Sets whether the zoglin is a baby
   *
   * @param flag Whether the zoglin is a baby
   * @deprecated see {@link Ageable#setBaby()} and {@link Ageable#setAdult()}
  */
  setBaby(flag: boolean): void;
  /**
   * Sets the age of the mob to a baby
  */
  setBaby(): void;
}
export interface Zoglin extends Monster, Ageable {}
/**
 * An iron Golem that protects Villages.
*/
export class IronGolem extends Golem {
  /**
   * Gets whether this iron golem was built by a player.
   *
   * @return Whether this iron golem was built by a player
  */
  isPlayerCreated(): boolean;
  /**
   * Sets whether this iron golem was built by a player or not.
   *
   * @param playerCreated true if you want to set the iron golem as being
   *     player created, false if you want it to be a natural village golem.
  */
  setPlayerCreated(playerCreated: boolean): void;
}
/**
 * Represents a Wither boss
*/
export class Wither extends Monster {
  /**
   * {@inheritDoc}
   * 
   * This method will set the target of the {@link Head#CENTER center head} of
   * the wither.
   *
   * @see #setTarget(org.bukkit.entity.Wither.Head, org.bukkit.entity.LivingEntity)
  */
  setTarget(target: LivingEntity | null);
  /**
   * This method will set the target of individual heads {@link Head} of the
   * wither.
   *
   * @param head the individual head
   * @param target the entity that should be targeted
  */
  setTarget(head: Head, target: LivingEntity | null): void;
  /**
   * This method will get the target of individual heads {@link Head} of the
   * wither.
   *
   * @param head the individual head
   * @return the entity targeted by the given head, or null if none is
   * targeted
  */
  getTarget(head: Head): LivingEntity | null;
  /**
   * @return whether the wither is charged
  */
  isCharged(): boolean;
  /**
   * @return ticks the wither is invulnerable for
  */
  getInvulnerableTicks(): number;
  /**
   * Sets for how long in the future, the wither should be invulnerable.
   *
   * @param ticks ticks the wither is invulnerable for
  */
  setInvulnerableTicks(invulnerableTicks: number);
  /**
   * @return whether the wither can travel through portals
  */
  canTravelThroughPortals(): boolean;
  /**
   * Sets whether the wither can travel through portals.
   *
   * @param value whether the wither can travel through portals
  */
  setCanTravelThroughPortals(value: boolean): void;
  /**
   * Gets the current target of this Mob
   *
   * @return Current target of this creature, or null if none exists
  */
  getTarget(): LivingEntity | null;
}
export interface Wither extends Monster, Boss, RangedEntity {}
/**
 * Represents a spell casting "Illager".
*/
export class Spellcaster extends Illager {
  /**
   * Gets the {@link Spell} the entity is currently using.
   *
   * @return the current spell
  */
  getSpell(): Spell;
  /**
   * Sets the {@link Spell} the entity is currently using.
   *
   * @param spell the spell the entity should be using
  */
  setSpell(spell: Spell);
}
/**
 * Represents a type of "Illager".
*/
export class Illager extends Raider {

}
export class Pillager extends Illager {

}
export interface Pillager extends Illager, InventoryHolder, RangedEntity {}
/**
 * Represents a MagmaCube.
*/
export class MagmaCube extends Slime {

}
export class EntityType extends Enum<EntityType> {
  /**
   * An item resting on the ground.
   * 
   * Spawn with {@link World#dropItem(Location, ItemStack)} or {@link
   * World#dropItemNaturally(Location, ItemStack)}
  */
  static readonly DROPPED_ITEM: EntityType;
  /**
   * An experience orb.
  */
  static readonly EXPERIENCE_ORB: EntityType;
  /**
   * @see AreaEffectCloud
  */
  static readonly AREA_EFFECT_CLOUD: EntityType;
  /**
   * @see ElderGuardian
  */
  static readonly ELDER_GUARDIAN: EntityType;
  /**
   * @see WitherSkeleton
  */
  static readonly WITHER_SKELETON: EntityType;
  /**
   * @see Stray
  */
  static readonly STRAY: EntityType;
  /**
   * A flying chicken egg.
  */
  static readonly EGG: EntityType;
  /**
   * A leash attached to a fencepost.
  */
  static readonly LEASH_HITCH: EntityType;
  /**
   * A painting on a wall.
  */
  static readonly PAINTING: EntityType;
  /**
   * An arrow projectile; may get stuck in the ground.
  */
  static readonly ARROW: EntityType;
  /**
   * A flying snowball.
  */
  static readonly SNOWBALL: EntityType;
  /**
   * A flying large fireball, as thrown by a Ghast for example.
  */
  static readonly FIREBALL: EntityType;
  /**
   * A flying small fireball, such as thrown by a Blaze or player.
  */
  static readonly SMALL_FIREBALL: EntityType;
  /**
   * A flying ender pearl.
  */
  static readonly ENDER_PEARL: EntityType;
  /**
   * An ender eye signal.
  */
  static readonly ENDER_SIGNAL: EntityType;
  /**
   * A flying splash potion.
  */
  static readonly SPLASH_POTION: EntityType;
  /**
   * A flying experience bottle.
  */
  static readonly THROWN_EXP_BOTTLE: EntityType;
  /**
   * An item frame on a wall.
  */
  static readonly ITEM_FRAME: EntityType;
  /**
   * A flying wither skull projectile.
  */
  static readonly WITHER_SKULL: EntityType;
  /**
   * Primed TNT that is about to explode.
  */
  static readonly PRIMED_TNT: EntityType;
  /**
   * A block that is going to or is about to fall.
  */
  static readonly FALLING_BLOCK: EntityType;
  /**
   * Internal representation of a Firework once it has been launched.
  */
  static readonly FIREWORK: EntityType;
  /**
   * @see Husk
  */
  static readonly HUSK: EntityType;
  /**
   * Like {@link #ARROW} but causes the {@link PotionEffectType#GLOWING} effect on all team members.
  */
  static readonly SPECTRAL_ARROW: EntityType;
  /**
   * Bullet fired by {@link #SHULKER}.
  */
  static readonly SHULKER_BULLET: EntityType;
  /**
   * Like {@link #FIREBALL} but with added effects.
  */
  static readonly DRAGON_FIREBALL: EntityType;
  /**
   * @see ZombieVillager
  */
  static readonly ZOMBIE_VILLAGER: EntityType;
  /**
   * @see SkeletonHorse
  */
  static readonly SKELETON_HORSE: EntityType;
  /**
   * @see ZombieHorse
  */
  static readonly ZOMBIE_HORSE: EntityType;
  /**
   * Mechanical entity with an inventory for placing weapons / armor into.
  */
  static readonly ARMOR_STAND: EntityType;
  /**
   * @see Donkey
  */
  static readonly DONKEY: EntityType;
  /**
   * @see Mule
  */
  static readonly MULE: EntityType;
  /**
   * @see EvokerFangs
  */
  static readonly EVOKER_FANGS: EntityType;
  /**
   * @see Evoker
  */
  static readonly EVOKER: EntityType;
  /**
   * @see Vex
  */
  static readonly VEX: EntityType;
  /**
   * @see Vindicator
  */
  static readonly VINDICATOR: EntityType;
  /**
   * @see Illusioner
  */
  static readonly ILLUSIONER: EntityType;
  /**
   * @see CommandMinecart
  */
  static readonly MINECART_COMMAND: EntityType;
  /**
   * A placed boat.
  */
  static readonly BOAT: EntityType;
  /**
   * @see RideableMinecart
  */
  static readonly MINECART: EntityType;
  /**
   * @see StorageMinecart
  */
  static readonly MINECART_CHEST: EntityType;
  /**
   * @see PoweredMinecart
  */
  static readonly MINECART_FURNACE: EntityType;
  /**
   * @see ExplosiveMinecart
  */
  static readonly MINECART_TNT: EntityType;
  /**
   * @see HopperMinecart
  */
  static readonly MINECART_HOPPER: EntityType;
  /**
   * @see SpawnerMinecart
  */
  static readonly MINECART_MOB_SPAWNER: EntityType;
  static readonly CREEPER: EntityType;
  static readonly SKELETON: EntityType;
  static readonly SPIDER: EntityType;
  static readonly GIANT: EntityType;
  static readonly ZOMBIE: EntityType;
  static readonly SLIME: EntityType;
  static readonly GHAST: EntityType;
  static readonly ZOMBIFIED_PIGLIN: EntityType;
  static readonly ENDERMAN: EntityType;
  static readonly CAVE_SPIDER: EntityType;
  static readonly SILVERFISH: EntityType;
  static readonly BLAZE: EntityType;
  static readonly MAGMA_CUBE: EntityType;
  static readonly ENDER_DRAGON: EntityType;
  static readonly WITHER: EntityType;
  static readonly BAT: EntityType;
  static readonly WITCH: EntityType;
  static readonly ENDERMITE: EntityType;
  static readonly GUARDIAN: EntityType;
  static readonly SHULKER: EntityType;
  static readonly PIG: EntityType;
  static readonly SHEEP: EntityType;
  static readonly COW: EntityType;
  static readonly CHICKEN: EntityType;
  static readonly SQUID: EntityType;
  static readonly WOLF: EntityType;
  static readonly MUSHROOM_COW: EntityType;
  static readonly SNOWMAN: EntityType;
  static readonly OCELOT: EntityType;
  static readonly IRON_GOLEM: EntityType;
  static readonly HORSE: EntityType;
  static readonly RABBIT: EntityType;
  static readonly POLAR_BEAR: EntityType;
  static readonly LLAMA: EntityType;
  static readonly LLAMA_SPIT: EntityType;
  static readonly PARROT: EntityType;
  static readonly VILLAGER: EntityType;
  static readonly ENDER_CRYSTAL: EntityType;
  static readonly TURTLE: EntityType;
  static readonly PHANTOM: EntityType;
  static readonly TRIDENT: EntityType;
  static readonly COD: EntityType;
  static readonly SALMON: EntityType;
  static readonly PUFFERFISH: EntityType;
  static readonly TROPICAL_FISH: EntityType;
  static readonly DROWNED: EntityType;
  static readonly DOLPHIN: EntityType;
  static readonly CAT: EntityType;
  static readonly PANDA: EntityType;
  static readonly PILLAGER: EntityType;
  static readonly RAVAGER: EntityType;
  static readonly TRADER_LLAMA: EntityType;
  static readonly WANDERING_TRADER: EntityType;
  static readonly FOX: EntityType;
  static readonly BEE: EntityType;
  static readonly HOGLIN: EntityType;
  static readonly PIGLIN: EntityType;
  static readonly STRIDER: EntityType;
  static readonly ZOGLIN: EntityType;
  static readonly PIGLIN_BRUTE: EntityType;
  static readonly AXOLOTL: EntityType;
  static readonly GLOW_ITEM_FRAME: EntityType;
  static readonly GLOW_SQUID: EntityType;
  static readonly GOAT: EntityType;
  static readonly MARKER: EntityType;
  /**
   * A fishing line and bobber.
  */
  static readonly FISHING_HOOK: EntityType;
  /**
   * A bolt of lightning.
   * 
   * Spawn with {@link World#strikeLightning(Location)}.
  */
  static readonly LIGHTNING: EntityType;
  static readonly PLAYER: EntityType;
  /**
   * An unknown entity without an Entity Class
  */
  static readonly UNKNOWN: EntityType;
  static valueOf(name: string): EntityType;
  static values(): EntityType[];
  /**
   * Gets the entity type name.
   *
   * @return the entity type's name
   * @deprecated Magic value
  */
  getName(): string | null;
  getKey(): NamespacedKey;
  getEntityClass(): Class<Entity> | null;
  /**
   * Gets the entity type id.
   *
   * @return the raw type id
   * @deprecated Magic value
  */
  getTypeId(): number;
  /**
   * Gets an entity type from its name.
   *
   * @param name the entity type's name
   * @return the matching entity type or null
   * @deprecated Magic value
  */
  static fromName(name: string | null): EntityType | null;
  /**
   * Gets an entity from its id.
   *
   * @param id the raw type id
   * @return the matching entity type or null
   * @deprecated Magic value
  */
  static fromId(id: number): EntityType | null;
  /**
   * Some entities cannot be spawned using {@link
   * World#spawnEntity(Location, EntityType)} or {@link
   * World#spawn(Location, Class)}, usually because they require additional
   * information in order to spawn.
   *
   * @return False if the entity type cannot be spawned
  */
  isSpawnable(): boolean;
  isAlive(): boolean;
  /**
   * Return the translation key for the EntityType, so the client can translate it into the active
   * locale when using a TranslatableComponent.
   * This is null, when the EntityType isn't known to NMS (custom entities)
   * @return the translation key
   * @deprecated use {@link #translationKey()}
  */
  getTranslationKey(): string | null;
  /**
   * Checks if the entity has default attributes.
   *
   * @return true if it has default attributes
  */
  hasDefaultAttributes(): boolean;
  /**
   * Gets the default attributes for the entity.
   *
   * @return an unmodifiable instance of Attributable for reading default attributes.
   * @throws IllegalArgumentException if the entity does not exist of have default attributes (use {@link #hasDefaultAttributes()} first)
  */
  getDefaultAttributes(): Attributable;
}
/**
 * Represents a Pig.
*/
export class Pig extends Steerable {

}
export interface Pig extends Steerable, Vehicle {}
/**
 * Represents a cod fish.
*/
export class Cod extends Fish {

}
export class Trident extends AbstractArrow {
  /**
   * Returns whether the trident has an enchanted glow.
   * This can be separate from the underlying item having any enchantments.
   *
   * @return whether the trident has an enchanted glow
  */
  hasGlint(): boolean;
  /**
   * Sets whether the trident has an enchanted glow.
   * This is separate from the underlying item having any enchantments.
   *
   * @param glint whether the trident should have an enchanted glow
  */
  setGlint(glint: boolean): void;
  /**
   * Returns the loyalty level of the trident.
   * This can be separate from the underlying item's enchantments.
   *
   * @return loyalty level of the trident
  */
  getLoyaltyLevel(): number;
  /**
   * Sets the loyalty level of the trident.
   * This is separate from the underlying item's enchantments.
   *
   * @param loyaltyLevel loyalty level
   * @throws IllegalArgumentException if the loyalty level is lower than 0 or greater than 127
  */
  setLoyaltyLevel(loyaltyLevel: number);
}
export interface Trident extends AbstractArrow, ThrowableProjectile {}
/**
 * Represents a Llama.
*/
export class Llama extends ChestedHorse {
  /**
   * Gets the llama's color.
   *
   * @return a {@link Color} representing the llama's color
  */
  getColor(): Color;
  /**
   * Sets the llama's color.
   *
   * @param color a {@link Color} for this llama
  */
  setColor(color: Color);
  /**
   * Gets the llama's strength. A higher strength llama will have more
   * inventory slots and be more threatening to entities.
   *
   * @return llama strength [1,5]
  */
  getStrength(): number;
  /**
   * Sets the llama's strength. A higher strength llama will have more
   * inventory slots and be more threatening to entities. Inventory slots are
   * equal to strength * 3.
   *
   * @param strength llama strength [1,5]
  */
  setStrength(strength: number);
  getInventory(): LlamaInventory;
}
export interface Llama extends ChestedHorse, RangedEntity {}
/**
 * Represents a mushroom {@link Cow}
*/
export class MushroomCow extends Cow {
  /**
   * Get the variant of this cow.
   *
   * @return cow variant
  */
  getVariant(): Variant;
  /**
   * Set the variant of this cow.
   *
   * @param variant cow variant
  */
  setVariant(variant: Variant);
}
/**
 * Piglin / Piglin Brute.
*/
export class PiglinAbstract extends Monster {
  /**
   * Gets whether the piglin is immune to zombification.
   *
   * @return Whether the piglin is immune to zombification
  */
  isImmuneToZombification(): boolean;
  /**
   * Sets whether the piglin is immune to zombification.
   *
   * @param flag Whether the piglin is immune to zombification
  */
  setImmuneToZombification(flag: boolean): void;
  /**
   * Gets the amount of ticks until this entity will be converted to a
   * Zombified Piglin.
   *
   * When this reaches 300, the entity will be converted.
   *
   * @return conversion time
   * @throws IllegalStateException if {@link #isConverting()} is false.
  */
  getConversionTime(): number;
  /**
   * Sets the conversion counter value. The counter is incremented
   * every tick the {@link #isConverting()} returns true. Setting this
   * value will not start the conversion if the {@link PiglinAbstract} is
   * not in a valid environment ({@link org.bukkit.World#isPiglinSafe})
   * to convert or {@link #isImmuneToZombification()} is true or
   * has no AI.
   *
   * When this reaches 300, the entity will be converted. To stop the
   * conversion use {@link #setImmuneToZombification(boolean)}.
   *
   * @param time new conversion counter
  */
  setConversionTime(conversionTime: number);
  /**
   * Get if this entity is in the process of converting to a Zombified Piglin.
   *
   * @return conversion status
  */
  isConverting(): boolean;
  /**
   * Gets whether the piglin is a baby
   *
   * @return Whether the piglin is a baby
   * @deprecated see {@link Ageable#isAdult()}
  */
  isBaby(): boolean;
  /**
   * Sets whether the piglin is a baby
   *
   * @param flag Whether the piglin is a baby
   * @deprecated see {@link Ageable#setBaby()} and {@link Ageable#setAdult()}
  */
  setBaby(flag: boolean): void;
  /**
   * Sets the age of the mob to a baby
  */
  setBaby(): void;
}
export interface PiglinAbstract extends Monster, Ageable {}
/**
 * @deprecated tipped status depends only on base potion type not being
 * UNCRAFTABLE and effects being empty.
*/
export class TippedArrow extends Arrow {

}
/**
 * Represents a Cow.
*/
export class Cow extends Animals {

}
/**
 * A Goat.
*/
export class Goat extends Animals {
  /**
   * Gets if this is a screaming goat.
   *
   * A screaming goat makes screaming sounds and rams more often. They do not
   * offer home loans.
   *
   * @return screaming status
  */
  isScreaming(): boolean;
  /**
   * Sets if this is a screaming goat.
   *
   * A screaming goat makes screaming sounds and rams more often. They do not
   * offer home loans.
   *
   * @param screaming screaming status
  */
  setScreaming(screaming: boolean): void;
  /**
   * Makes the goat ram at the specified entity
   * @param entity the entity to ram at
  */
  ram(entity: LivingEntity): void;
}
/**
 * Represents an Item Frame
*/
export class ItemFrame extends Hanging {
  /**
   * Get the item in this frame
   *
   * @return a defensive copy the item in this item frame
  */
  getItem(): ItemStack;
  /**
   * Set the item in this frame
   *
   * @param item the new item
  */
  setItem(item: ItemStack | null);
  /**
   * Set the item in this frame
   *
   * @param item the new item
   * @param playSound whether or not to play the item placement sound
  */
  setItem(item: ItemStack | null, playSound: boolean): void;
  /**
   * Gets the chance of the item being dropped upon this frame's destruction.
   *
   * 
   * A drop chance of 0.0F will never drop
   * A drop chance of 1.0F will always drop
   * 
   *
   * @return chance of the off hand item being dropped
  */
  getItemDropChance(): number;
  /**
   * Sets the chance of the off hand item being dropped upon this frame's
   * destruction.
   *
   * 
   * A drop chance of 0.0F will never drop
   * A drop chance of 1.0F will always drop
   * 
   *
   * @param chance the chance of off hand item being dropped
  */
  setItemDropChance(itemDropChance: number);
  /**
   * Get the rotation of the frame's item
   *
   * @return the direction
  */
  getRotation(): Rotation;
  /**
   * Set the rotation of the frame's item
   *
   * @param rotation the new rotation
   * @throws IllegalArgumentException if rotation is null
  */
  setRotation(rotation: Rotation);
  /**
   * Returns whether the item frame is be visible or not.
   *
   * @return whether the item frame is visible or not
  */
  isVisible(): boolean;
  /**
   * Sets whether the item frame should be visible or not.
   *
   * @param visible whether the item frame is visible or not
  */
  setVisible(visible: boolean): void;
  /**
   * Returns whether the item frame is "fixed" or not.
   *
   * When true it's not possible to destroy/move the frame (e.g. by damage,
   * interaction, pistons, or missing supporting blocks), rotate the item or
   * place/remove items.
   *
   * @return whether the item frame is fixed or not
  */
  isFixed(): boolean;
  /**
   * Sets whether the item frame should be fixed or not.
   *
   * When set to true it's not possible to destroy/move the frame (e.g. by
   * damage, interaction, pistons, or missing supporting blocks), rotate the
   * item or place/remove items.
   *
   * @param fixed whether the item frame is fixed or not
  */
  setFixed(fixed: boolean): void;
}
/**
 * Represents a Spider.
*/
export class Spider extends Monster {

}
/**
 * Represents a Hanging entity
*/
export class Hanging extends Entity {
  /**
   * Sets the direction of the hanging entity, potentially overriding rules
   * of placement. Note that if the result is not valid the object would
   * normally drop as an item.
   *
   * @param face The new direction.
   * @param force Whether to force it.
   * @return False if force was false and there was no block for it to
   *     attach to in order to face the given direction.
  */
  setFacingDirection(face: BlockFace, force: boolean): boolean;
}
export interface Hanging extends Entity, Attachable {}
/**
 * Represents a Leash Hitch on a fence
*/
export class LeashHitch extends Hanging {

}
/**
 * Represents a vehicle entity.
*/
export class Vehicle extends Entity {
  /**
   * Gets the vehicle's velocity.
   *
   * @return velocity vector
  */
  getVelocity(): Vector;
  /**
   * Sets the vehicle's velocity in meters per tick.
   *
   * @param vel velocity vector
  */
  setVelocity(velocity: Vector);
}
export class Fish extends WaterMob {

}
export interface Fish extends WaterMob, Bucketable {}
/**
 * Represents Evoker Fangs.
*/
export class EvokerFangs extends Entity {
  /**
   * Gets the {@link LivingEntity} which summoned the fangs.
   *
   * @return the {@link LivingEntity} which summoned the fangs
  */
  getOwner(): LivingEntity | null;
  /**
   * Sets the {@link LivingEntity} which summoned the fangs.
   *
   * @param owner the {@link LivingEntity} which summoned the fangs
  */
  setOwner(owner: LivingEntity | null);
}
/**
 * A Glow Squid.
*/
export class GlowSquid extends Squid {
  /**
   * Get the number of dark ticks remaining for this squid.
   *
   * Bravo Six will go dark for 100 ticks (5 seconds) if damaged.
   *
   * @return dark ticks remaining
  */
  getDarkTicksRemaining(): number;
  /**
   * Sets the number of dark ticks remaining for this squid.
   *
   * Bravo Six will go dark for 100 ticks (5 seconds) if damaged.
   *
   * @param darkTicksRemaining dark ticks remaining
  */
  setDarkTicksRemaining(darkTicksRemaining: number);
}
/**
 * Represents a Sheep.
*/
export class Sheep extends Animals {
  /**
   * @return Whether the sheep is sheared.
  */
  isSheared(): boolean;
  /**
   * @param flag Whether to shear the sheep
  */
  setSheared(flag: boolean): void;
}
export interface Sheep extends Animals, Colorable {}
/**
 * Represents a Wolf
*/
export class Wolf extends Tameable {
  /**
   * Checks if this wolf is angry
   *
   * @return Anger true if angry
  */
  isAngry(): boolean;
  /**
   * Sets the anger of this wolf.
   * 
   * An angry wolf can not be fed or tamed.
   *
   * @param angry true if angry
   * @see #setTarget(org.bukkit.entity.LivingEntity)
  */
  setAngry(angry: boolean): void;
  /**
   * Get the collar color of this wolf
   *
   * @return the color of the collar
  */
  getCollarColor(): DyeColor;
  /**
   * Set the collar color of this wolf
   *
   * @param color the color to apply
  */
  setCollarColor(collarColor: DyeColor);
  /**
   * Sets if the wolf is interested.
   * 
   * This causes the wolf to tilt its head to the side.
   *
   * @param interested is interested
  */
  setInterested(interested: boolean): void;
  /**
   * Gets if the wolf is interested.
   *
   * @return is interested
  */
  isInterested(): boolean;
}
export interface Wolf extends Tameable, Sittable, CollarColorable {}
/**
 * Represents a ZombieHorse - variant of {@link AbstractHorse}.
*/
export class ZombieHorse extends AbstractHorse {

}
/**
 * An animal that can sit still.
*/
export class Sittable {
  /**
   * Checks if this animal is sitting
   *
   * @return true if sitting
  */
  isSitting(): boolean;
  /**
   * Sets if this animal is sitting. Will remove any path that the animal
   * was following beforehand.
   *
   * @param sitting true if sitting
  */
  setSitting(sitting: boolean): void;
}
/**
 * Represents a Giant.
*/
export class Giant extends Monster {

}
/**
 * Represents a human entity, such as an NPC or a player
*/
export class HumanEntity extends LivingEntity {
  getEquipment(): EntityEquipment;
  /**
   * Returns the name of this player
   *
   * @return Player name
  */
  getName(): string;
  /**
   * Get the player's inventory.
   *
   * @return The inventory of the player, this also contains the armor
   *     slots.
  */
  getInventory(): PlayerInventory;
  /**
   * Get the player's EnderChest inventory
   *
   * @return The EnderChest of the player
  */
  getEnderChest(): Inventory;
  /**
   * Gets the player's selected main hand
   *
   * @return the players main hand
  */
  getMainHand(): MainHand;
  /**
   * If the player currently has an inventory window open, this method will
   * set a property of that window, such as the state of a progress bar.
   *
   * @param prop The property.
   * @param value The value to set the property to.
   * @return True if the property was successfully set.
  */
  setWindowProperty(prop: Property, value: number): boolean;
  /**
   * Gets the inventory view the player is currently viewing. If they do not
   * have an inventory window open, it returns their internal crafting view.
   *
   * @return The inventory view.
  */
  getOpenInventory(): InventoryView;
  /**
   * Opens an inventory window with the specified inventory on the top and
   * the player's inventory on the bottom.
   *
   * @param inventory The inventory to open
   * @return The newly opened inventory view
  */
  openInventory(inventory: Inventory): InventoryView | null;
  /**
   * Opens an empty workbench inventory window with the player's inventory
   * on the bottom.
   *
   * @param location The location to attach it to. If null, the player's
   *     location is used.
   * @param force If false, and there is no workbench block at the location,
   *     no inventory will be opened and null will be returned.
   * @return The newly opened inventory view, or null if it could not be
   *     opened.
  */
  openWorkbench(location: Location | null, force: boolean): InventoryView | null;
  /**
   * Opens an empty enchanting inventory window with the player's inventory
   * on the bottom.
   *
   * @param location The location to attach it to. If null, the player's
   *     location is used.
   * @param force If false, and there is no enchanting table at the
   *     location, no inventory will be opened and null will be returned.
   * @return The newly opened inventory view, or null if it could not be
   *     opened.
  */
  openEnchanting(location: Location | null, force: boolean): InventoryView | null;
  /**
   * Opens an inventory window to the specified inventory view.
   *
   * @param inventory The view to open
  */
  openInventory(inventory: InventoryView): void;
  /**
   * Starts a trade between the player and the villager.
   *
   * Note that only one player may trade with a villager at once. You must use
   * the force parameter for this.
   *
   * @param trader The merchant to trade with. Cannot be null.
   * @param force whether to force the trade even if another player is trading
   * @return The newly opened inventory view, or null if it could not be
   * opened.
  */
  openMerchant(trader: Villager, force: boolean): InventoryView | null;
  /**
   * Starts a trade between the player and the merchant.
   *
   * Note that only one player may trade with a merchant at once. You must use
   * the force parameter for this.
   *
   * @param merchant The merchant to trade with. Cannot be null.
   * @param force whether to force the trade even if another player is trading
   * @return The newly opened inventory view, or null if it could not be
   * opened.
  */
  openMerchant(merchant: Merchant, force: boolean): InventoryView | null;
  /**
   * Opens an empty anvil inventory window with the player's inventory
   * on the bottom.
   *
   * @param location The location to attach it to. If null, the player's
   *     location is used.
   * @param force If false, and there is no anvil block at the location,
   *     no inventory will be opened and null will be returned.
   * @return The newly opened inventory view, or null if it could not be
   *     opened.
  */
  openAnvil(location: Location | null, force: boolean): InventoryView | null;
  /**
   * Opens an empty cartography table inventory window with the player's inventory
   * on the bottom.
   *
   * @param location The location to attach it to. If null, the player's
   *     location is used.
   * @param force If false, and there is no cartography table block at the location,
   *     no inventory will be opened and null will be returned.
   * @return The newly opened inventory view, or null if it could not be
   *     opened.
  */
  openCartographyTable(location: Location | null, force: boolean): InventoryView | null;
  /**
   * Opens an empty grindstone inventory window with the player's inventory
   * on the bottom.
   *
   * @param location The location to attach it to. If null, the player's
   *     location is used.
   * @param force If false, and there is no grindstone block at the location,
   *     no inventory will be opened and null will be returned.
   * @return The newly opened inventory view, or null if it could not be
   *     opened.
  */
  openGrindstone(location: Location | null, force: boolean): InventoryView | null;
  /**
   * Opens an empty loom inventory window with the player's inventory
   * on the bottom.
   *
   * @param location The location to attach it to. If null, the player's
   *     location is used.
   * @param force If false, and there is no loom block at the location,
   *     no inventory will be opened and null will be returned.
   * @return The newly opened inventory view, or null if it could not be
   *     opened.
  */
  openLoom(location: Location | null, force: boolean): InventoryView | null;
  /**
   * Opens an empty smithing table inventory window with the player's inventory
   * on the bottom.
   *
   * @param location The location to attach it to. If null, the player's
   *     location is used.
   * @param force If false, and there is no smithing table block at the location,
   *     no inventory will be opened and null will be returned.
   * @return The newly opened inventory view, or null if it could not be
   *     opened.
  */
  openSmithingTable(location: Location | null, force: boolean): InventoryView | null;
  /**
   * Opens an empty stonecutter inventory window with the player's inventory
   * on the bottom.
   *
   * @param location The location to attach it to. If null, the player's
   *     location is used.
   * @param force If false, and there is no stonecutter block at the location,
   *     no inventory will be opened and null will be returned.
   * @return The newly opened inventory view, or null if it could not be
   *     opened.
  */
  openStonecutter(location: Location | null, force: boolean): InventoryView | null;
  /**
   * Force-closes the currently open inventory view for this player, if any.
  */
  closeInventory(): void;
  /**
   * Force-closes the currently open inventory view for this player, if any.
   *
   * @param reason why the inventory is closing
  */
  closeInventory(reason: Reason): void;
  /**
   * Returns the ItemStack currently in your hand, can be empty.
   *
   * @return The ItemStack of the item you are currently holding.
   * @deprecated Humans may now dual wield in their off hand, use explicit
   * methods in {@link PlayerInventory}.
  */
  getItemInHand(): ItemStack;
  /**
   * Sets the item to the given ItemStack, this will replace whatever the
   * user was holding.
   *
   * @param item The ItemStack which will end up in the hand
   * @deprecated Humans may now dual wield in their off hand, use explicit
   * methods in {@link PlayerInventory}.
  */
  setItemInHand(itemInHand: ItemStack | null);
  /**
   * Returns the ItemStack currently on your cursor, can be empty. Will
   * always be empty if the player currently has no open window.
   *
   * @return The ItemStack of the item you are currently moving around.
  */
  getItemOnCursor(): ItemStack;
  /**
   * Sets the item to the given ItemStack, this will replace whatever the
   * user was moving. Will always be empty if the player currently has no
   * open window.
   *
   * @param item The ItemStack which will end up in the hand
  */
  setItemOnCursor(itemOnCursor: ItemStack | null);
  /**
   * Check whether a cooldown is active on the specified material.
   *
   * @param material the material to check
   * @return if a cooldown is active on the material
   * @throws IllegalArgumentException if the material is not an item
  */
  hasCooldown(material: Material): boolean;
  /**
   * Get the cooldown time in ticks remaining for the specified material.
   *
   * @param material the material to check
   * @return the remaining cooldown time in ticks
   * @throws IllegalArgumentException if the material is not an item
  */
  getCooldown(material: Material): number;
  /**
   * Set a cooldown on the specified material for a certain amount of ticks.
   * ticks. 0 ticks will result in the removal of the cooldown.
   * 
   * Cooldowns are used by the server for items such as ender pearls and
   * shields to prevent them from being used repeatedly.
   * 
   * Note that cooldowns will not by themselves stop an item from being used
   * for attacking.
   *
   * @param material the material to set the cooldown for
   * @param ticks the amount of ticks to set or 0 to remove
   * @throws IllegalArgumentException if the material is not an item
  */
  setCooldown(material: Material, ticks: number): void;
  /**
   * If the player has slept enough to count towards passing the night.
   *
   * @return true if the player has slept enough
  */
  isDeeplySleeping(): boolean;
  /**
   * Get the sleep ticks of the player. This value may be capped.
   *
   * @return slumber ticks
  */
  getSleepTicks(): number;
  /**
   * Gets the Location of the player's bed, null if they have not slept
   * in one. This method will not attempt to validate if the current bed
   * is still valid.
   *
   * @return Bed Location if has slept in one, otherwise null.
  */
  getPotentialBedLocation(): Location | null;
  /**
   * Attempts to make the entity sleep at the given location.
   * 
   * The location must be in the current world and have a bed placed at the
   * location. The game may also enforce other requirements such as proximity
   * to bed, monsters, and dimension type if force is not set.
   *
   * @param location the location of the bed
   * @param force whether to try and sleep at the location even if not
   * normally possible
   * @return whether the sleep was successful
  */
  sleep(location: Location, force: boolean): boolean;
  /**
   * Causes the player to wakeup if they are currently sleeping.
   *
   * @param setSpawnLocation whether to set their spawn location to the bed
   * they are currently sleeping in
   * @throws IllegalStateException if not sleeping
  */
  wakeup(setSpawnLocation: boolean): void;
  /**
   * Gets the location of the bed the player is currently sleeping in
   *
   * @return location
   * @throws IllegalStateException if not sleeping
  */
  getBedLocation(): Location;
  /**
   * Gets this human's current {@link GameMode}
   *
   * @return Current game mode
  */
  getGameMode(): GameMode;
  /**
   * Sets this human's current {@link GameMode}
   *
   * @param mode New game mode
  */
  setGameMode(gameMode: GameMode);
  /**
   * Check if the player is currently blocking (ie with a shield).
   *
   * @return Whether they are blocking.
  */
  isBlocking(): boolean;
  /**
   * Check if the player currently has their hand raised (ie about to begin
   * blocking).
   *
   * @return Whether their hand is raised
  */
  isHandRaised(): boolean;
  /**
   * Gets the item that the player is using (eating food, drawing back a bow,
   * blocking, etc.)
   *
   * @return the item being used by the player, or null if they are not using
   * an item
  */
  getItemInUse(): ItemStack | null;
  /**
   * Get the total amount of experience required for the player to level
   *
   * @return Experience required to level up
  */
  getExpToLevel(): number;
  /**
   * If there is an Entity on this entities left shoulder, it will be released to the world and returned.
   * If no Entity is released, null will be returned.
   *
   * @return The released entity, or null
  */
  releaseLeftShoulderEntity(): Entity | null;
  /**
   * If there is an Entity on this entities left shoulder, it will be released to the world and returned.
   * If no Entity is released, null will be returned.
   *
   * @return The released entity, or null
  */
  releaseRightShoulderEntity(): Entity | null;
  /**
   * Gets the current cooldown for a player's attack.
   *
   * This is used to calculate damage, with 1.0 representing a fully charged
   * attack and 0.0 representing a non-charged attack
   *
   * @return A float between 0.0-1.0 representing the progress of the charge
  */
  getAttackCooldown(): number;
  /**
   * Discover a recipe for this player such that it has not already been
   * discovered. This method will add the key's associated recipe to the
   * player's recipe book.
   *
   * @param recipe the key of the recipe to discover
   *
   * @return whether or not the recipe was newly discovered
  */
  discoverRecipe(recipe: NamespacedKey): boolean;
  /**
   * Discover a collection of recipes for this player such that they have not
   * already been discovered. This method will add the keys' associated
   * recipes to the player's recipe book. If a recipe in the provided
   * collection has already been discovered, it will be silently ignored.
   *
   * @param recipes the keys of the recipes to discover
   *
   * @return the amount of newly discovered recipes where 0 indicates that
   * none were newly discovered and a number equal to `recipes.size()`
   * indicates that all were new
  */
  discoverRecipes(recipes: Collection<NamespacedKey>): number;
  /**
   * Undiscover a recipe for this player such that it has already been
   * discovered. This method will remove the key's associated recipe from the
   * player's recipe book.
   *
   * @param recipe the key of the recipe to undiscover
   *
   * @return whether or not the recipe was successfully undiscovered (i.e. it
   * was previously discovered)
  */
  undiscoverRecipe(recipe: NamespacedKey): boolean;
  /**
   * Undiscover a collection of recipes for this player such that they have
   * already been discovered. This method will remove the keys' associated
   * recipes from the player's recipe book. If a recipe in the provided
   * collection has not yet been discovered, it will be silently ignored.
   *
   * @param recipes the keys of the recipes to undiscover
   *
   * @return the amount of undiscovered recipes where 0 indicates that none
   * were undiscovered and a number equal to `recipes.size()` indicates
   * that all were undiscovered
  */
  undiscoverRecipes(recipes: Collection<NamespacedKey>): number;
  /**
   * Check whether or not this entity has discovered the specified recipe.
   *
   * @param recipe the key of the recipe to check
   *
   * @return true if discovered, false otherwise
  */
  hasDiscoveredRecipe(recipe: NamespacedKey): boolean;
  /**
   * Get an immutable set of recipes this entity has discovered.
   *
   * @return all discovered recipes
  */
  getDiscoveredRecipes(): Set<NamespacedKey>;
  /**
   * Gets the entity currently perched on the left shoulder or null if no
   * entity.
   * 
   * The returned entity will not be spawned within the world, so most
   * operations are invalid unless the entity is first spawned in.
   *
   * @return left shoulder entity
   * @deprecated There are currently no well defined semantics regarding
   * serialized entities in Bukkit. Use with care.
  */
  getShoulderEntityLeft(): Entity | null;
  /**
   * Sets the entity currently perched on the left shoulder, or null to
   * remove. This method will remove the entity from the world.
   * 
   * Note that only a copy of the entity will be set to display on the
   * shoulder.
   * 
   * Also note that the client will currently only render {@link Parrot}
   * entities.
   *
   * @param entity left shoulder entity
   * @deprecated There are currently no well defined semantics regarding
   * serialized entities in Bukkit. Use with care.
  */
  setShoulderEntityLeft(shoulderEntityLeft: Entity | null);
  /**
   * Gets the entity currently perched on the right shoulder or null if no
   * entity.
   * 
   * The returned entity will not be spawned within the world, so most
   * operations are invalid unless the entity is first spawned in.
   *
   * @return right shoulder entity
   * @deprecated There are currently no well defined semantics regarding
   * serialized entities in Bukkit. Use with care.
  */
  getShoulderEntityRight(): Entity | null;
  /**
   * Sets the entity currently perched on the right shoulder, or null to
   * remove. This method will remove the entity from the world.
   * 
   * Note that only a copy of the entity will be set to display on the
   * shoulder.
   * 
   * Also note that the client will currently only render {@link Parrot}
   * entities.
   *
   * @param entity right shoulder entity
   * @deprecated There are currently no well defined semantics regarding
   * serialized entities in Bukkit. Use with care.
  */
  setShoulderEntityRight(shoulderEntityRight: Entity | null);
  /**
   * Opens an editor window for the specified sign
   *
   * @param sign The sign to open
  */
  openSign(sign: Sign): void;
  /**
   * Make the entity drop the item in their hand.
   * 
   * This will force the entity to drop the item they are holding with
   * an option to drop the entire {@link ItemStack} or just 1 of the items.
   *
   * @param dropAll True to drop entire stack, false to drop 1 of the stack
   * @return True if item was dropped successfully
  */
  dropItem(dropAll: boolean): boolean;
  /**
   * Gets the players current exhaustion level.
   * 
   * Exhaustion controls how fast the food level drops. While you have a
   * certain amount of exhaustion, your saturation will drop to zero, and
   * then your food will drop to zero.
   *
   * @return Exhaustion level
  */
  getExhaustion(): number;
  /**
   * Sets the players current exhaustion level
   *
   * @param value Exhaustion level
  */
  setExhaustion(exhaustion: number);
  /**
   * Gets the players current saturation level.
   * 
   * Saturation is a buffer for food level. Your food level will not drop if
   * you are saturated {@literal >} 0.
   *
   * @return Saturation level
  */
  getSaturation(): number;
  /**
   * Sets the players current saturation level
   *
   * @param value Saturation level
  */
  setSaturation(saturation: number);
  /**
   * Gets the players current food level
   *
   * @return Food level
  */
  getFoodLevel(): number;
  /**
   * Sets the players current food level
   *
   * @param value New food level
  */
  setFoodLevel(foodLevel: number);
  /**
   * Get the regeneration rate (1 health per x ticks) of
   * the HumanEntity when they have saturation and
   * their food level is {@literal >=} 20. Default is 10.
   *
   * @return the regeneration rate
  */
  getSaturatedRegenRate(): number;
  /**
   * Set the regeneration rate (1 health per x ticks) of
   * the HumanEntity when they have saturation and
   * their food level is {@literal >=} 20. Default is 10.
   * Not affected if the world's difficulty is peaceful.
   *
   * @param ticks the amount of ticks to gain 1 health.
  */
  setSaturatedRegenRate(saturatedRegenRate: number);
  /**
   * Get the regeneration rate (1 health per x ticks) of
   * the HumanEntity when they have no saturation and
   * their food level is {@literal >=} 18. Default is 80.
   *
   * @return the regeneration rate
  */
  getUnsaturatedRegenRate(): number;
  /**
   * Get the regeneration rate (1 health per x ticks) of
   * the HumanEntity when they have no saturation and
   * their food level is {@literal >=} 18. Default is 80.
   * Not affected if the world's difficulty is peaceful.
   *
   * @param ticks the amount of ticks to gain 1 health.
  */
  setUnsaturatedRegenRate(unsaturatedRegenRate: number);
  /**
   * Get the starvation rate (1 health per x ticks) of
   * the HumanEntity. Default is 80.
   *
   * @return the starvation rate
  */
  getStarvationRate(): number;
  /**
   * Get the starvation rate (1 health per x ticks) of
   * the HumanEntity. Default is 80.
   *
   * @param ticks the amount of ticks to lose 1 health
  */
  setStarvationRate(starvationRate: number);
}
export interface HumanEntity extends LivingEntity, AnimalTamer, InventoryHolder {}
export class PolarBear extends Animals {
  /**
   * Returns whether the polar bear is standing.
   *
   * @return whether the polar bear is standing
  */
  isStanding(): boolean;
  /**
   * Sets whether the polar bear is standing.
   *
   * @param standing whether the polar bear should be standing
  */
  setStanding(standing: boolean): void;
}
/**
 * Represents a thrown Ender Pearl entity
*/
export class EnderPearl extends ThrowableProjectile {

}
/**
 * Represents an ElderGuardian - variant of {@link Guardian}.
*/
export class ElderGuardian extends Guardian {

}
/**
 * A representation of an explosive entity
*/
export class Explosive extends Entity {
  /**
   * Set the radius affected by this explosive's explosion
   *
   * @param yield The explosive yield
  */
  setYield(yield: number);
  /**
   * Return the radius or yield of this explosive's explosion
   *
   * @return the radius of blocks affected
  */
  getYield(): number;
  /**
   * Set whether or not this explosive's explosion causes fire
   *
   * @param isIncendiary Whether it should cause fire
  */
  setIsIncendiary(isIncendiary: boolean): void;
  /**
   * Return whether or not this explosive creates a fire when exploding
   *
   * @return true if the explosive creates fire, false otherwise
  */
  isIncendiary(): boolean;
}
export class Drowned extends Zombie {

}
export interface Drowned extends Zombie, RangedEntity {}
/**
 * Represents an Enderman.
*/
export class Enderman extends Monster {
  teleportRandomly(): boolean;
  /**
   * Gets the id and data of the block that the Enderman is carrying.
   *
   * @return MaterialData containing the id and data of the block
   * @deprecated use {@link #getCarriedBlock()}
  */
  getCarriedMaterial(): MaterialData;
  /**
   * Sets the id and data of the block that the Enderman is carrying.
   *
   * @param material data to set the carried block to
   * @deprecated use {@link #setCarriedBlock(BlockData)}
  */
  setCarriedMaterial(carriedMaterial: MaterialData);
  /**
   * Gets the data of the block that the Enderman is carrying.
   *
   * @return BlockData containing the carried block, or null if none
  */
  getCarriedBlock(): BlockData | null;
  /**
   * Sets the data of the block that the Enderman is carrying.
   *
   * @param blockData data to set the carried block to, or null to remove
  */
  setCarriedBlock(carriedBlock: BlockData | null);
  /**
   * Returns whether the enderman is screaming/angry.
   *
   * @return whether the enderman is screaming
  */
  isScreaming(): boolean;
  /**
   * Sets whether the enderman is screaming/angry.
   *
   * @param screaming whether the enderman is screaming
  */
  setScreaming(screaming: boolean): void;
  /**
   * Returns whether the enderman has been stared at.
   * If set to true, players will hear an ambient sound.
   *
   * @return whether the enderman has been stared at
  */
  hasBeenStaredAt(): boolean;
  /**
   * Sets whether the enderman has been stared at.
   * If set to true, players will hear an ambient sound.
   *
   * @param hasBeenStaredAt whether the enderman has been stared at
  */
  setHasBeenStaredAt(hasBeenStaredAt: boolean): void;
}
/**
 * Represents an EnderSignal, which is created upon throwing an ender eye.
*/
export class EnderSignal extends Entity {
  /**
   * Get the location this EnderSignal is moving towards.
   *
   * @return the {@link Location} this EnderSignal is moving towards.
  */
  getTargetLocation(): Location;
  /**
   * Set the {@link Location} this EnderSignal is moving towards.
   * 
   * When setting a new target location, the {@link #getDropItem()} resets to
   * a random value and the despawn timer gets set back to 0.
   *
   * @param location the new target location
  */
  setTargetLocation(targetLocation: Location);
  /**
   * Set the {@link Location} this EnderSignal is moving towards.
   *
   * @param location the new target location
   * @param update true to reset the {@link #getDropItem()}
   *               to a random value and {@link #getDespawnTimer()} to 0
  */
  setTargetLocation(location: Location, update: boolean): void;
  /**
   * Gets if the EnderSignal should drop an item on death.
   * If `true`, it will drop an item. If `false`, it will shatter.
   *
   * @return true if the EnderSignal will drop an item on death, or false if
   * it will shatter
  */
  getDropItem(): boolean;
  /**
   * Sets if the EnderSignal should drop an item on death; or if it should
   * shatter.
   *
   * @param drop true if the EnderSignal should drop an item on death, or
   * false if it should shatter.
  */
  setDropItem(drop: boolean): void;
  /**
   * Get the {@link ItemStack} to be displayed while in the air and to be
   * dropped on death.
   *
   * @return the item stack
  */
  getItem(): ItemStack;
  /**
   * Set the {@link ItemStack} to be displayed while in the air and to be
   * dropped on death.
   *
   * @param item the item to set. If null, resets to the default eye of ender
  */
  setItem(item: ItemStack | null);
  /**
   * Gets the amount of time this entity has been alive (in ticks).
   * 
   * When this number is greater than 80, it will despawn on the next tick.
   *
   * @return the number of ticks this EnderSignal has been alive.
  */
  getDespawnTimer(): number;
  /**
   * Set how long this entity has been alive (in ticks).
   * 
   * When this number is greater than 80, it will despawn on the next tick.
   *
   * @param timer how long (in ticks) this EnderSignal has been alive.
  */
  setDespawnTimer(despawnTimer: number);
}
/**
 * Represents a non-player character
*/
export class NPC extends Creature {

}
/**
 * Represents a base entity in the world
*/
export class Entity extends Metadatable {
  /**
   * Gets the entity's current position
   *
   * @return a new copy of Location containing the position of this entity
  */
  getLocation(): Location;
  /**
   * Stores the entity's current position in the provided Location object.
   * 
   * If the provided Location is null this method does nothing and returns
   * null.
   *
   * @param loc the location to copy into
   * @return The Location object provided or null
  */
  getLocation(loc: Location | null): Location | null;
  /**
   * Sets this entity's velocity in meters per tick
   *
   * @param velocity New velocity to travel with
  */
  setVelocity(velocity: Vector);
  /**
   * Gets this entity's current velocity
   *
   * @return Current traveling velocity of this entity
  */
  getVelocity(): Vector;
  /**
   * Gets the entity's height
   *
   * @return height of entity
  */
  getHeight(): number;
  /**
   * Gets the entity's width
   *
   * @return width of entity
  */
  getWidth(): number;
  /**
   * Gets the entity's current bounding box.
   * 
   * The returned bounding box reflects the entity's current location and
   * size.
   *
   * @return the entity's current bounding box
  */
  getBoundingBox(): BoundingBox;
  /**
   * Returns true if the entity is supported by a block. This value is a
   * state updated by the server and is not recalculated unless the entity
   * moves.
   *
   * @return True if entity is on ground.
   * @see Player#isOnGround()
  */
  isOnGround(): boolean;
  /**
   * Returns true if the entity is in water.
   *
   * @return true if the entity is in water.
  */
  isInWater(): boolean;
  /**
   * Gets the current world this entity resides in
   *
   * @return World
  */
  getWorld(): World;
  /**
   * Sets the entity's rotation.
   * 
   * Note that if the entity is affected by AI, it may override this rotation.
   *
   * @param yaw the yaw
   * @param pitch the pitch
   * @throws UnsupportedOperationException if used for players
  */
  setRotation(yaw: number, pitch: number): void;
  /**
   * Teleports this entity to the given location. If this entity is riding a
   * vehicle, it will be dismounted prior to teleportation.
   *
   * @param location New location to teleport this entity to
   * @return true if the teleport was successful
  */
  teleport(location: Location): boolean;
  /**
   * Teleports this entity to the given location. If this entity is riding a
   * vehicle, it will be dismounted prior to teleportation.
   *
   * @param location New location to teleport this entity to
   * @param cause The cause of this teleportation
   * @return true if the teleport was successful
  */
  teleport(location: Location, cause: TeleportCause): boolean;
  /**
   * Teleports this entity to the target Entity. If this entity is riding a
   * vehicle, it will be dismounted prior to teleportation.
   *
   * @param destination Entity to teleport this entity to
   * @return true if the teleport was successful
  */
  teleport(destination: Entity): boolean;
  /**
   * Teleports this entity to the target Entity. If this entity is riding a
   * vehicle, it will be dismounted prior to teleportation.
   *
   * @param destination Entity to teleport this entity to
   * @param cause The cause of this teleportation
   * @return true if the teleport was successful
  */
  teleport(destination: Entity, cause: TeleportCause): boolean;
  /**
   * Loads/Generates(in 1.13+) the Chunk asynchronously, and then teleports the entity when the chunk is ready.
   * @param loc Location to teleport to
   * @return A future that will be completed with the result of the teleport
  */
  teleportAsync(loc: Location): CompletableFuture<boolean>;
  /**
   * Loads/Generates(in 1.13+) the Chunk asynchronously, and then teleports the entity when the chunk is ready.
   * @param loc Location to teleport to
   * @param cause Reason for teleport
   * @return A future that will be completed with the result of the teleport
  */
  teleportAsync(loc: Location, cause: TeleportCause): CompletableFuture<boolean>;
  /**
   * Returns a list of entities within a bounding box centered around this
   * entity
   *
   * @param x 1/2 the size of the box along x axis
   * @param y 1/2 the size of the box along y axis
   * @param z 1/2 the size of the box along z axis
   * @return `List` List of entities nearby
  */
  getNearbyEntities(x: number, y: number, z: number): Entity[];
  /**
   * Returns a unique id for this entity
   *
   * @return Entity id
  */
  getEntityId(): number;
  /**
   * Returns the entity's current fire ticks (ticks before the entity stops
   * being on fire).
   *
   * @return int fireTicks
  */
  getFireTicks(): number;
  /**
   * Returns the entity's maximum fire ticks.
   *
   * @return int maxFireTicks
  */
  getMaxFireTicks(): number;
  /**
   * Sets the entity's current fire ticks (ticks before the entity stops
   * being on fire).
   *
   * @param ticks Current ticks remaining
  */
  setFireTicks(fireTicks: number);
  /**
   * Sets if the entity has visual fire (it will always appear to be on fire).
   *
   * @param fire whether visual fire is enabled
  */
  setVisualFire(fire: boolean): void;
  /**
   * Gets if the entity has visual fire (it will always appear to be on fire).
   *
   * @return whether visual fire is enabled
  */
  isVisualFire(): boolean;
  /**
   * Returns the entity's current freeze ticks (amount of ticks the entity has
   * been in powdered snow).
   *
   * @return int freeze ticks
  */
  getFreezeTicks(): number;
  /**
   * Returns the entity's maximum freeze ticks (amount of ticks before it will
   * be fully frozen)
   *
   * @return int max freeze ticks
  */
  getMaxFreezeTicks(): number;
  /**
   * Sets the entity's current freeze ticks (amount of ticks the entity has
   * been in powdered snow).
   *
   * @param ticks Current ticks
  */
  setFreezeTicks(freezeTicks: number);
  /**
   * Gets if the entity is fully frozen (it has been in powdered snow for max
   * freeze ticks).
   *
   * @return freeze status
  */
  isFrozen(): boolean;
  /**
   * Gets if the entity currently has its freeze ticks locked
   * to a set amount.
   * 
   * This is only set by plugins
   *
   * @return locked or not
  */
  isFreezeTickingLocked(): boolean;
  /**
   * Sets if the entity currently has its freeze ticks locked,
   * preventing default vanilla freeze tick modification.
   *
   * @param locked prevent vanilla modification or not
  */
  lockFreezeTicks(locked: boolean): void;
  /**
   * Mark the entity's removal.
  */
  remove(): void;
  /**
   * Returns true if this entity has been marked for removal.
   *
   * @return True if it is dead.
  */
  isDead(): boolean;
  /**
   * Returns false if the entity has died or been despawned for some other
   * reason.
   *
   * @return True if valid.
  */
  isValid(): boolean;
  /**
   * Gets the {@link Server} that contains this Entity
   *
   * @return Server instance running this Entity
  */
  getServer(): Server;
  /**
   * Returns true if the entity gets persisted.
   * 
   * By default all entities are persistent. An entity will also not get
   * persisted, if it is riding an entity that is not persistent.
   * 
   * The persistent flag on players controls whether or not to save their
   * playerdata file when they quit. If a player is directly or indirectly
   * riding a non-persistent entity, the vehicle at the root and all its
   * passengers won't get persisted.
   * 
   * This should not be confused with
   * {@link LivingEntity#setRemoveWhenFarAway(boolean)} which controls
   * despawning of living entities. 
   *
   * @return true if this entity is persistent
  */
  isPersistent(): boolean;
  /**
   * Sets whether or not the entity gets persisted.
   *
   * @param persistent the persistence status
   * @see #isPersistent()
  */
  setPersistent(persistent: boolean): void;
  /**
   * Gets the primary passenger of a vehicle. For vehicles that could have
   * multiple passengers, this will only return the primary passenger.
   *
   * @return an entity
   * @deprecated entities may have multiple passengers, use
   * {@link #getPassengers()}
  */
  getPassenger(): Entity | null;
  /**
   * Set the passenger of a vehicle.
   *
   * @param passenger The new passenger.
   * @return false if it could not be done for whatever reason
   * @deprecated entities may have multiple passengers, use
   * {@link #addPassenger(org.bukkit.entity.Entity)}
  */
  setPassenger(passenger: Entity);
  /**
   * Gets a list of passengers of this vehicle.
   * 
   * The returned list will not be directly linked to the entity's current
   * passengers, and no guarantees are made as to its mutability.
   *
   * @return list of entities corresponding to current passengers.
  */
  getPassengers(): Entity[];
  /**
   * Add a passenger to the vehicle.
   *
   * @param passenger The passenger to add
   * @return false if it could not be done for whatever reason
  */
  addPassenger(passenger: Entity): boolean;
  /**
   * Remove a passenger from the vehicle.
   *
   * @param passenger The passenger to remove
   * @return false if it could not be done for whatever reason
  */
  removePassenger(passenger: Entity): boolean;
  /**
   * Check if a vehicle has passengers.
   *
   * @return True if the vehicle has no passengers.
  */
  isEmpty(): boolean;
  /**
   * Eject any passenger.
   *
   * @return True if there was a passenger.
  */
  eject(): boolean;
  /**
   * Returns the distance this entity has fallen
   *
   * @return The distance.
  */
  getFallDistance(): number;
  /**
   * Sets the fall distance for this entity
   *
   * @param distance The new distance.
  */
  setFallDistance(fallDistance: number);
  /**
   * Record the last {@link EntityDamageEvent} inflicted on this entity
   *
   * @param event a {@link EntityDamageEvent}
  */
  setLastDamageCause(lastDamageCause: EntityDamageEvent | null);
  /**
   * Retrieve the last {@link EntityDamageEvent} inflicted on this entity.
   * This event may have been cancelled.
   *
   * @return the last known {@link EntityDamageEvent} or null if hitherto
   *     unharmed
  */
  getLastDamageCause(): EntityDamageEvent | null;
  /**
   * Returns a unique and persistent id for this entity
   *
   * @return unique id
  */
  getUniqueId(): UUID;
  /**
   * Gets the amount of ticks this entity has lived for.
   * 
   * This is the equivalent to "age" in entities.
   *
   * @return Age of entity
  */
  getTicksLived(): number;
  /**
   * Sets the amount of ticks this entity has lived for.
   * 
   * This is the equivalent to "age" in entities. May not be less than one
   * tick.
   *
   * @param value Age of entity
  */
  setTicksLived(ticksLived: number);
  /**
   * Performs the specified {@link EntityEffect} for this entity.
   * 
   * This will be viewable to all players near the entity.
   * 
   * If the effect is not applicable to this class of entity, it will not play.
   *
   * @param type Effect to play.
  */
  playEffect(type: EntityEffect): void;
  /**
   * Get the type of the entity.
   *
   * @return The entity type.
  */
  getType(): EntityType;
  /**
   * Returns whether this entity is inside a vehicle.
   *
   * @return True if the entity is in a vehicle.
  */
  isInsideVehicle(): boolean;
  /**
   * Leave the current vehicle. If the entity is currently in a vehicle (and
   * is removed from it), true will be returned, otherwise false will be
   * returned.
   *
   * @return True if the entity was in a vehicle.
  */
  leaveVehicle(): boolean;
  /**
   * Get the vehicle that this player is inside. If there is no vehicle,
   * null will be returned.
   *
   * @return The current vehicle.
  */
  getVehicle(): Entity | null;
  /**
   * Sets whether or not to display the mob's custom name client side. The
   * name will be displayed above the mob similarly to a player.
   * 
   * This value has no effect on players, they will always display their
   * name.
   *
   * @param flag custom name or not
  */
  setCustomNameVisible(flag: boolean): void;
  /**
   * Gets whether or not the mob's custom name is displayed client side.
   * 
   * This value has no effect on players, they will always display their
   * name.
   *
   * @return if the custom name is displayed
  */
  isCustomNameVisible(): boolean;
  /**
   * Sets whether the entity has a team colored (default: white) glow.
   *
   * nb: this refers to the 'Glowing' entity property, not whether a
   * glowing potion effect is applied
   *
   * @param flag if the entity is glowing
  */
  setGlowing(flag: boolean): void;
  /**
   * Gets whether the entity is glowing or not.
   *
   * nb: this refers to the 'Glowing' entity property, not whether a
   * glowing potion effect is applied
   *
   * @return whether the entity is glowing
  */
  isGlowing(): boolean;
  /**
   * Sets whether the entity is invulnerable or not.
   * 
   * When an entity is invulnerable it can only be damaged by players in
   * creative mode.
   *
   * @param flag if the entity is invulnerable
  */
  setInvulnerable(flag: boolean): void;
  /**
   * Gets whether the entity is invulnerable or not.
   *
   * @return whether the entity is
  */
  isInvulnerable(): boolean;
  /**
   * Gets whether the entity is silent or not.
   *
   * @return whether the entity is silent.
  */
  isSilent(): boolean;
  /**
   * Sets whether the entity is silent or not.
   * 
   * When an entity is silent it will not produce any sound.
   *
   * @param flag if the entity is silent
  */
  setSilent(flag: boolean): void;
  /**
   * Returns whether gravity applies to this entity.
   *
   * @return whether gravity applies
  */
  hasGravity(): boolean;
  /**
   * Sets whether gravity applies to this entity.
   *
   * @param gravity whether gravity should apply
  */
  setGravity(gravity: boolean): void;
  /**
   * Gets the period of time (in ticks) before this entity can use a portal.
   *
   * @return portal cooldown ticks
  */
  getPortalCooldown(): number;
  /**
   * Sets the period of time (in ticks) before this entity can use a portal.
   *
   * @param cooldown portal cooldown ticks
  */
  setPortalCooldown(portalCooldown: number);
  /**
   * Returns a set of tags for this entity.
   * 
   * Entities can have no more than 1024 tags.
   *
   * @return a set of tags for this entity
  */
  getScoreboardTags(): Set<string>;
  /**
   * Add a tag to this entity.
   * 
   * Entities can have no more than 1024 tags.
   *
   * @param tag the tag to add
   * @return true if the tag was successfully added
  */
  addScoreboardTag(tag: string): boolean;
  /**
   * Removes a given tag from this entity.
   *
   * @param tag the tag to remove
   * @return true if the tag was successfully removed
  */
  removeScoreboardTag(tag: string): boolean;
  /**
   * Returns the reaction of the entity when moved by a piston.
   *
   * @return reaction
  */
  getPistonMoveReaction(): PistonMoveReaction;
  /**
   * Get the closest cardinal {@link BlockFace} direction an entity is
   * currently facing.
   * 
   * This will not return any non-cardinal directions such as
   * {@link BlockFace#UP} or {@link BlockFace#DOWN}.
   * 
   * {@link Hanging} entities will override this call and thus their behavior
   * may be different.
   *
   * @return the entity's current cardinal facing.
   * @see Hanging
   * @see Directional#getFacing()
  */
  getFacing(): BlockFace;
  /**
   * Gets the entity's current pose.
   *
   * Note that the pose is only updated at the end of a tick, so may be
   * inconsistent with other methods. eg {@link Player#isSneaking()} being
   * true does not imply the current pose will be {@link Pose#SNEAKING}
   *
   * @return current pose
  */
  getPose(): Pose;
  /**
   * Get the category of spawn to which this entity belongs.
   *
   * @return the entitys category spawn
  */
  getSpawnCategory(): SpawnCategory;
  spigot(): Spigot;
  /**
   * Gets the entity's display name formatted with their team prefix/suffix and
   * the entity's default hover/click events.
   *
   * @return the team display name
  */
  teamDisplayName(): Component;
  asHoverEvent(op: UnaryOperator<ShowEntity>): HoverEvent<ShowEntity>;
  /**
   * Gets the location where this entity originates from.
   * 
   * This value can be null if the entity hasn't yet been added to the world.
   *
   * @return Location where entity originates or null if not yet added
  */
  getOrigin(): Location | null;
  /**
   * Returns whether this entity was spawned from a mob spawner.
   *
   * @return True if entity spawned from a mob spawner
  */
  fromMobSpawner(): boolean;
  /**
   * Gets the latest chunk an entity is currently or was in.
   *
   * @return The current, or most recent chunk if the entity is invalid (which may load the chunk)
  */
  getChunk(): Chunk;
  /**
   * @return The {@link org.bukkit.event.entity.CreatureSpawnEvent.SpawnReason} that initially spawned this entity. 
  */
  getEntitySpawnReason(): SpawnReason;
  /**
   * Check if entity is in rain
  */
  isInRain(): boolean;
  /**
   * Check if entity is in bubble column
  */
  isInBubbleColumn(): boolean;
  /**
   * Check if entity is in water or rain
  */
  isInWaterOrRain(): boolean;
  /**
   * Check if entity is in water or bubble column
  */
  isInWaterOrBubbleColumn(): boolean;
  /**
   * Check if entity is in water or rain or bubble column
  */
  isInWaterOrRainOrBubbleColumn(): boolean;
  /**
   * Check if entity is in lava
  */
  isInLava(): boolean;
  /**
   * Check if entity is inside a ticking chunk
  */
  isTicking(): boolean;
  /**
   * Returns a set of {@link Player Players} within this entity's tracking range (players that can "see" this entity).
   *
   * @return players in tracking range
  */
  getTrackedPlayers(): Set<Player>;
  /**
   * Spawns the entity in the world at the given {@link Location} with the default spawn reason.
   * 
   * This will not spawn the entity if the entity is already spawned or has previously been despawned.
   * 
   * Also, this method will fire the same events as a normal entity spawn.
   *
   * @param location The location to spawn the entity at.
   * @return Whether the entity was successfully spawned.
  */
  spawnAt(location: Location): boolean;
  /**
   * Spawns the entity in the world at the given {@link Location} with the reason given.
   * 
   * This will not spawn the entity if the entity is already spawned or has previously been despawned.
   * 
   * Also, this method will fire the same events as a normal entity spawn.
   *
   * @param location The location to spawn the entity at.
   * @param reason   The reason for the entity being spawned.
   * @return Whether the entity was successfully spawned.
  */
  spawnAt(location: Location, reason: SpawnReason): boolean;
  /**
   * Check if entity is inside powdered snow.
   *
   * @return true if in powdered snow.
  */
  isInPowderedSnow(): boolean;
  /**
   * Represent this object as a hover event.
   *
   * @return a hover event
   * @since 4.0.0
  */
  asHoverEvent(): HoverEvent<V>;
}
export interface Entity extends Metadatable, CommandSender, Nameable, PersistentDataHolder, HoverEventSource<ShowEntity>, Emitter {}
/**
 * Represents a falling block
*/
export class FallingBlock extends Entity {
  /**
   * Get the Material of the falling block
   *
   * @return Material of the block
   * @deprecated use {@link #getBlockData()}
  */
  getMaterial(): Material;
  /**
   * Get the data for the falling block
   *
   * @return data of the block
  */
  getBlockData(): BlockData;
  /**
   * Get if the falling block will break into an item if it cannot be placed
   *
   * @return true if the block will break into an item when obstructed
  */
  getDropItem(): boolean;
  /**
   * Set if the falling block will break into an item if it cannot be placed
   *
   * @param drop true to break into an item when obstructed
  */
  setDropItem(drop: boolean): void;
  /**
   * Get the HurtEntities state of this block.
   *
   * @return whether entities will be damaged by this block.
  */
  canHurtEntities(): boolean;
  /**
   * Set the HurtEntities state of this block.
   *
   * @param hurtEntities whether entities will be damaged by this block.
  */
  setHurtEntities(hurtEntities: boolean): void;
  /**
   * Gets the source block location of the FallingBlock
   *
   * @return the source block location the FallingBlock was spawned from
   * @deprecated replaced by {@link Entity#getOrigin()}
  */
  getSourceLoc(): Location;
  /**
   * Sets if this falling block should expire after:
   * - 30 seconds
   * - 5 seconds and is outside of the world
   *
   * @return if this behavior occurs
  */
  doesAutoExpire(): boolean;
  /**
   * Sets if this falling block should expire after:
   * - 30 seconds
   * - 5 seconds and is outside of the world
   *
   * @param autoExpires if this behavior should occur
  */
  shouldAutoExpire(autoExpires: boolean): void;
}
/**
 * Panda entity.
*/
export class Panda extends Animals {
  /**
   * Gets this Panda's main gene.
   *
   * @return main gene
  */
  getMainGene(): Gene;
  /**
   * Sets this Panda's main gene.
   *
   * @param gene main gene
  */
  setMainGene(mainGene: Gene);
  /**
   * Gets this Panda's hidden gene.
   *
   * @return hidden gene
  */
  getHiddenGene(): Gene;
  /**
   * Sets this Panda's hidden gene.
   *
   * @param gene hidden gene
  */
  setHiddenGene(hiddenGene: Gene);
  /**
   * Sets the sneeze progress in this animation.
   * This value counts up only if {@link Panda#isSneezing()} is true
   *
   * @param ticks sneeze progress
  */
  setSneezeTicks(sneezeTicks: number);
  /**
   * Gets the current sneeze progress, or how many ticks this panda will sneeze for.
   *
   * @return sneeze progress
  */
  getSneezeTicks(): number;
  /**
   * Sets if the panda is sneezing, which causes the sneeze counter to count.
   * 
   * When false, this will automatically set the sneeze ticks to 0.
   *
   * @param sneeze if the panda is sneezing or not
  */
  setSneezing(sneeze: boolean): void;
  /**
   * Gets if the panda is sneezing
   *
   * @return is sneezing
  */
  isSneezing(): boolean;
  /**
   * Sets the eating ticks for this panda.
   * 
   *
   * This starts counting up as long as it is greater than 0.
   *
   * @param ticks eating ticks
  */
  setEatingTicks(eatingTicks: number);
  /**
   * Gets the current eating progress, or how many ticks this panda has been eating for.
   *
   * @return eating progress
  */
  getEatingTicks(): number;
  /**
   * Sets the number of ticks this panda will be unhappy for.
   * 
   * This value counts down.
   *
   * @param ticks unhappy ticks
  */
  setUnhappyTicks(unhappyTicks: number);
  /**
   * Gets how many ticks this panda will be unhappy for.
   *
   * @return unhappy ticks
  */
  getUnhappyTicks(): number;
  /**
   * Sets if this panda is currently rolling.
   *
   * @param rolling should roll
  */
  setRolling(rolling: boolean): void;
  /**
   * Gets if this panda is currently rolling on the ground.
   *
   * @return is rolling
  */
  isRolling(): boolean;
  /**
   * Sets if this panda is currently on its back.
   *
   * @param onBack is on its back
  */
  setIsOnBack(onBack: boolean): void;
  /**
   * Gets if this panda is currently on its back.
   *
   * @return is on back
  */
  isOnBack(): boolean;
  /**
   * Sets if this panda is currently sitting.
   *
   * @param sitting is currently sitting
   * @deprecated use {@link #setSitting(boolean)}
  */
  setIsSitting(sitting: boolean): void;
  /**
   * Sets if this panda is currently sitting.
   *
   * @param sitting is currently sitting
  */
  setSitting(sitting: boolean): void;
  /**
   * Gets if this panda is sitting.
   *
   * @return is sitting
  */
  isSitting(): boolean;
}
export interface Panda extends Animals, Sittable {}
/**
 * Represents a Mob. Mobs are living entities with simple AI.
*/
export class Mob extends LivingEntity {
  getEquipment(): EntityEquipment;
  /**
   * Enables access to control the pathing of an Entity
   * @return Pathfinding Manager for this entity
  */
  getPathfinder(): Pathfinder;
  /**
   * Check if this mob is exposed to daylight
   *
   * @return True if mob is exposed to daylight
  */
  isInDaylight(): boolean;
  /**
   * Instruct this Mob to look at a specific Location
   * 
   * Useful when implementing custom mob goals
   *
   * @param location location to look at
  */
  lookAt(location: Location): void;
  /**
   * Instruct this Mob to look at a specific Location
   * 
   * Useful when implementing custom mob goals
   *
   * @param location location to look at
   * @param headRotationSpeed head rotation speed
   * @param maxHeadPitch max head pitch rotation
  */
  lookAt(location: Location, headRotationSpeed: number, maxHeadPitch: number): void;
  /**
   * Instruct this Mob to look at a specific Entity
   * 
   * If a LivingEntity, look at eye location
   * 
   * Useful when implementing custom mob goals
   *
   * @param entity entity to look at
  */
  lookAt(entity: Entity): void;
  /**
   * Instruct this Mob to look at a specific Entity
   * 
   * If a LivingEntity, look at eye location
   * 
   * Useful when implementing custom mob goals
   *
   * @param entity entity to look at
   * @param headRotationSpeed head rotation speed
   * @param maxHeadPitch max head pitch rotation
  */
  lookAt(entity: Entity, headRotationSpeed: number, maxHeadPitch: number): void;
  /**
   * Instruct this Mob to look at a specific position
   * 
   * Useful when implementing custom mob goals
   *
   * @param x x coordinate
   * @param y y coordinate
   * @param z z coordinate
  */
  lookAt(x: number, y: number, z: number): void;
  /**
   * Instruct this Mob to look at a specific position
   * 
   * Useful when implementing custom mob goals
   *
   * @param x x coordinate
   * @param y y coordinate
   * @param z z coordinate
   * @param headRotationSpeed head rotation speed
   * @param maxHeadPitch max head pitch rotation
  */
  lookAt(x: number, y: number, z: number, headRotationSpeed: number, maxHeadPitch: number): void;
  /**
   * Gets the head rotation speed
   *
   * @return the head rotation speed
  */
  getHeadRotationSpeed(): number;
  /**
   * Gets the max head pitch rotation
   *
   * @return the max head pitch rotation
  */
  getMaxHeadPitch(): number;
  /**
   * Instructs this Mob to set the specified LivingEntity as its target.
   * 
   * Hostile creatures may attack their target, and friendly creatures may
   * follow their target.
   *
   * @param target New LivingEntity to target, or null to clear the target
  */
  setTarget(target: LivingEntity | null);
  /**
   * Gets the current target of this Mob
   *
   * @return Current target of this creature, or null if none exists
  */
  getTarget(): LivingEntity | null;
  /**
   * Sets whether this mob is aware of its surroundings.
   *
   * Unaware mobs will still move if pushed, attacked, etc. but will not move
   * or perform any actions on their own. Unaware mobs may also have other
   * unspecified behaviours disabled, such as drowning.
   *
   * @param aware whether the mob is aware
  */
  setAware(aware: boolean): void;
  /**
   * Gets whether this mob is aware of its surroundings.
   *
   * Unaware mobs will still move if pushed, attacked, etc. but will not move
   * or perform any actions on their own. Unaware mobs may also have other
   * unspecified behaviours disabled, such as drowning.
   *
   * @return whether the mob is aware
  */
  isAware(): boolean;
  /**
   * Check if Mob is left-handed
   *
   * @return True if left-handed
  */
  isLeftHanded(): boolean;
  /**
   * Set if Mob is left-handed
   *
   * @param leftHanded True if left-handed
  */
  setLeftHanded(leftHanded: boolean): void;
}
export interface Mob extends LivingEntity, Lootable {}
/**
 * Represents Llama spit.
*/
export class LlamaSpit extends Projectile {

}
/**
 * Represents a turtle.
*/
export class Turtle extends Animals {
  /**
   * Get the turtle's home location
   *
   * @return Home location
  */
  getHome(): Location;
  /**
   * Set the turtle's home location
   *
   * @param location Home location
  */
  setHome(home: Location);
  /**
   * Check if turtle is currently pathfinding to it's home
   *
   * @return True if going home
  */
  isGoingHome(): boolean;
  /**
   * Get if turtle is digging to lay eggs
   *
   * @return True if digging
  */
  isDigging(): boolean;
  /**
   * Get if turtle is carrying egg
   *
   * @return True if carrying egg
  */
  hasEgg(): boolean;
  /**
   * Set if turtle is carrying egg
   *
   * @param hasEgg True if carrying egg
  */
  setHasEgg(hasEgg: boolean): void;
  /**
   * Returns whether the turtle is currently laying an egg.
   *
   * @return whether the turtle is laying an egg
  */
  isLayingEgg(): boolean;
}
/**
 * Represents a salmon fish.
*/
export class Salmon extends Fish {

}
/**
 * Represents a player, connected or not
*/
export class Player extends HumanEntity {
  identity(): Identity;
  /**
   * Gets the "friendly" name to display of this player.
   *
   * @return the display name
  */
  displayName(): Component;
  /**
   * Sets the "friendly" name to display of this player.
   *
   * @param displayName the display name to set
  */
  displayName(displayName: Component | null): void;
  /**
   * Sets the "friendly" name to display of this player. This may include
   * color.
   * 
   * Note that this name will not be displayed in game, only in chat and
   * places defined by plugins.
   *
   * @param name The new display name.
   * @deprecated in favour of {@link #displayName(net.kyori.adventure.text.Component)}
  */
  setDisplayName(displayName: string | null): void;
  /**
   * Sets the name that is shown on the in-game player list.
   * 
   * If the value is null, the name will be identical to {@link #getName()}.
   *
   * @param name new player list name
  */
  playerListName(name: Component | null): void;
  /**
   * Gets the name that is shown on the in-game player list.
   *
   * @return the player list name
  */
  playerListName(): Component;
  /**
   * Gets the currently displayed player list header for this player.
   *
   * @return player list header or null
  */
  playerListHeader(): Component | null;
  /**
   * Gets the currently displayed player list footer for this player.
   *
   * @return player list footer or null
  */
  playerListFooter(): Component | null;
  /**
   * Sets the name that is shown on the in-game player list.
   * 
   * If the value is null, the name will be identical to {@link #getName()}.
   *
   * @param name new player list name
   * @deprecated in favour of {@link #playerListName(net.kyori.adventure.text.Component)}
  */
  setPlayerListName(playerListName: string | null): void;
  /**
   * Sets the currently displayed player list header for this player.
   *
   * @param header player list header, null for empty
   * @deprecated in favour of {@link #sendPlayerListHeader(net.kyori.adventure.text.Component)}
  */
  setPlayerListHeader(playerListHeader: string | null): void;
  /**
   * Sets the currently displayed player list footer for this player.
   *
   * @param footer player list footer, null for empty
   * @deprecated in favour of {@link #sendPlayerListFooter(net.kyori.adventure.text.Component)}
  */
  setPlayerListFooter(playerListFooter: string | null): void;
  /**
   * Sets the currently displayed player list header and footer for this
   * player.
   *
   * @param header player list header, null for empty
   * @param footer player list footer, null for empty
   * @deprecated in favour of {@link #sendPlayerListHeaderAndFooter(net.kyori.adventure.text.Component, net.kyori.adventure.text.Component)}
  */
  setPlayerListHeaderFooter(header: string | null, footer: string | null): void;
  /**
   * Set the target of the player's compass.
   *
   * @param loc Location to point to
  */
  setCompassTarget(compassTarget: Location);
  /**
   * Get the previously set compass target.
   *
   * @return location of the target
  */
  getCompassTarget(): Location;
  /**
   * Gets the socket address of this player
   *
   * @return the player's address
  */
  getAddress(): InetSocketAddress | null;
  /**
   * Sends this sender a message raw
   *
   * @param message Message to be displayed
  */
  sendRawMessage(message: string): void;
  /**
   * Kicks player with custom kick message.
   *
   * @param message kick message
   * @deprecated in favour of {@link #kick(net.kyori.adventure.text.Component)}
  */
  kickPlayer(message: string | null): void;
  /**
   * Kicks the player with the default kick message.
   * @see #kick(Component)
  */
  kick(): void;
  /**
   * Kicks player with custom kick message.
   *
   * @param message kick message
  */
  kick(message: Component | null): void;
  /**
   * Kicks player with custom kick message and cause.
   *
   * @param message kick message
   * @param cause kick cause
  */
  kick(message: Component | null, cause: Cause): void;
  /**
   * Says a message (or runs a command).
   *
   * @param msg message to print
  */
  chat(msg: string): void;
  /**
   * Makes the player perform the given command
   *
   * @param command Command to perform
   * @return true if the command was successful, otherwise false
  */
  performCommand(command: string): boolean;
  /**
   * Returns true if the entity is supported by a block.
   *
   * This value is a state updated by the client after each movement.
   *
   * @return True if entity is on ground.
   * @deprecated This value is controlled only by the client and is therefore
   * unreliable and vulnerable to spoofing and/or desync depending on the
   * context/time which it is accessed
  */
  isOnGround(): boolean;
  /**
   * Returns if the player is in sneak mode
   *
   * @return true if player is in sneak mode
  */
  isSneaking(): boolean;
  /**
   * Sets the sneak mode the player
   *
   * @param sneak true if player should appear sneaking
  */
  setSneaking(sneak: boolean): void;
  /**
   * Gets whether the player is sprinting or not.
   *
   * @return true if player is sprinting.
  */
  isSprinting(): boolean;
  /**
   * Sets whether the player is sprinting or not.
   *
   * @param sprinting true if the player should be sprinting
  */
  setSprinting(sprinting: boolean): void;
  /**
   * Saves the players current location, health, inventory, motion, and
   * other information into the username.dat file, in the world/player
   * folder
  */
  saveData(): void;
  /**
   * Loads the players current location, health, inventory, motion, and
   * other information from the username.dat file, in the world/player
   * folder.
   * 
   * Note: This will overwrite the players current inventory, health,
   * motion, etc, with the state from the saved dat file.
  */
  loadData(): void;
  /**
   * Sets whether the player is ignored as not sleeping. If everyone is
   * either sleeping or has this flag set, then time will advance to the
   * next day. If everyone has this flag set but no one is actually in bed,
   * then nothing will happen.
   *
   * @param isSleeping Whether to ignore.
  */
  setSleepingIgnored(isSleeping: boolean): void;
  /**
   * Returns whether the player is sleeping ignored.
   *
   * @return Whether player is ignoring sleep.
  */
  isSleepingIgnored(): boolean;
  /**
   * Gets the Location where the player will spawn at their bed, null if
   * they have not slept in one or their current bed spawn is invalid.
   *
   * @return Bed Spawn Location if bed exists, otherwise null.
  */
  getBedSpawnLocation(): Location | null;
  /**
   * Sets the Location where the player will spawn at their bed.
   *
   * @param location where to set the respawn location
  */
  setBedSpawnLocation(bedSpawnLocation: Location | null);
  /**
   * Sets the Location where the player will spawn at their bed.
   *
   * @param location where to set the respawn location
   * @param force whether to forcefully set the respawn location even if a
   *     valid bed is not present
  */
  setBedSpawnLocation(location: Location | null, force: boolean): void;
  /**
   * Play a note for a player at a location. This requires a note block
   * at the particular location (as far as the client is concerned). This
   * will not work without a note block. This will not work with cake.
   *
   * @param loc The location of a note block.
   * @param instrument The instrument ID.
   * @param note The note ID.
   * @deprecated Magic value
  */
  playNote(loc: Location, instrument: number, note: number): void;
  /**
   * Play a note for a player at a location. This requires a note block
   * at the particular location (as far as the client is concerned). This
   * will not work without a note block. This will not work with cake.
   *
   * @param loc The location of a note block
   * @param instrument The instrument
   * @param note The note
  */
  playNote(loc: Location, instrument: Instrument, note: Note): void;
  /**
   * Play a sound for a player at the location.
   * 
   * This function will fail silently if Location or Sound are null.
   *
   * @param location The location to play the sound
   * @param sound The sound to play
   * @param volume The volume of the sound
   * @param pitch The pitch of the sound
  */
  playSound(location: Location, sound: Sound, volume: number, pitch: number): void;
  /**
   * Play a sound for a player at the location.
   * 
   * This function will fail silently if Location or Sound are null. No
   * sound will be heard by the player if their client does not have the
   * respective sound for the value passed.
   *
   * @param location the location to play the sound
   * @param sound the internal sound name to play
   * @param volume the volume of the sound
   * @param pitch the pitch of the sound
  */
  playSound(location: Location, sound: string, volume: number, pitch: number): void;
  /**
   * Play a sound for a player at the location.
   * 
   * This function will fail silently if Location or Sound are null.
   *
   * @param location The location to play the sound
   * @param sound The sound to play
   * @param category The category of the sound
   * @param volume The volume of the sound
   * @param pitch The pitch of the sound
  */
  playSound(location: Location, sound: Sound, category: SoundCategory, volume: number, pitch: number): void;
  /**
   * Play a sound for a player at the location.
   * 
   * This function will fail silently if Location or Sound are null. No sound
   * will be heard by the player if their client does not have the respective
   * sound for the value passed.
   *
   * @param location the location to play the sound
   * @param sound the internal sound name to play
   * @param category The category of the sound
   * @param volume the volume of the sound
   * @param pitch the pitch of the sound
  */
  playSound(location: Location, sound: string, category: SoundCategory, volume: number, pitch: number): void;
  /**
   * Play a sound for a player at the location of the entity.
   * 
   * This function will fail silently if Entity or Sound are null.
   *
   * @param entity The entity to play the sound
   * @param sound The sound to play
   * @param volume The volume of the sound
   * @param pitch The pitch of the sound
  */
  playSound(entity: Entity, sound: Sound, volume: number, pitch: number): void;
  /**
   * Play a sound for a player at the location of the entity.
   * 
   * This function will fail silently if Entity or Sound are null.
   *
   * @param entity The entity to play the sound
   * @param sound The sound to play
   * @param category The category of the sound
   * @param volume The volume of the sound
   * @param pitch The pitch of the sound
  */
  playSound(entity: Entity, sound: Sound, category: SoundCategory, volume: number, pitch: number): void;
  /**
   * Stop the specified sound from playing.
   *
   * @param sound the sound to stop
  */
  stopSound(sound: Sound): void;
  /**
   * Stop the specified sound from playing.
   *
   * @param sound the sound to stop
  */
  stopSound(sound: string): void;
  /**
   * Stop the specified sound from playing.
   *
   * @param sound the sound to stop
   * @param category the category of the sound
  */
  stopSound(sound: Sound, category: SoundCategory | null): void;
  /**
   * Stop the specified sound from playing.
   *
   * @param sound the sound to stop
   * @param category the category of the sound
  */
  stopSound(sound: string, category: SoundCategory | null): void;
  /**
   * Stop all sounds from playing.
  */
  stopAllSounds(): void;
  /**
   * Plays an effect to just this player.
   *
   * @param loc the location to play the effect at
   * @param effect the {@link Effect}
   * @param data a data bit needed for some effects
   * @deprecated Magic value
  */
  playEffect(loc: Location, effect: Effect, data: number): void;
  /**
   * Plays an effect to just this player.
   *
   * @param  the data based based on the type of the effect
   * @param loc the location to play the effect at
   * @param effect the {@link Effect}
   * @param data a data bit needed for some effects
  */
  playEffect<T>(loc: Location, effect: Effect, data: T | null): void;
  /**
   * Force this player to break a Block using the item in their main hand.
   *
   * This method will respect enchantments, handle item durability (if
   * applicable) and drop experience and the correct items according to the
   * tool/item in the player's hand.
   * 
   * Note that this method will call a {@link BlockBreakEvent}, meaning that
   * this method may not be successful in breaking the block if the event was
   * cancelled by a third party plugin. Care should be taken if running this
   * method in a BlockBreakEvent listener as recursion may be possible if it
   * is invoked on the same {@link Block} being broken in the event.
   * 
   * Additionally, a {@link BlockDropItemEvent} is called for the items
   * dropped by this method (if successful).
   * 
   * The block must be in the same world as the player.
   *
   * @param block the block to break
   *
   * @return true if the block was broken, false if the break failed
  */
  breakBlock(block: Block): boolean;
  /**
   * Send a block change. This fakes a block change packet for a user at a
   * certain location. This will not actually change the world in any way.
   *
   * @param loc The location of the changed block
   * @param material The new block
   * @param data The block data
   * @deprecated Magic value
  */
  sendBlockChange(loc: Location, material: Material, data: number): void;
  /**
   * Send a block change. This fakes a block change packet for a user at a
   * certain location. This will not actually change the world in any way.
   *
   * @param loc The location of the changed block
   * @param block The new block
  */
  sendBlockChange(loc: Location, block: BlockData): void;
  /**
   * Send block damage. This fakes block break progress for a user at a
   * certain location. This will not actually change the block's break
   * progress in any way.
   *
   * @param loc the location of the damaged block
   * @param progress the progress from 0.0 - 1.0 where 0 is no damage and
   * 1.0 is the most damaged
  */
  sendBlockDamage(loc: Location, progress: number): void;
  /**
   * Send multiple block changes. This fakes a multi block change packet for each
   * chunk section that a block change occurs. This will not actually change the world in any way.
   *
   * @param blockChanges A map of the locations you want to change to their new block data
  */
  sendMultiBlockChange(blockChanges: Map<Location, BlockData>): void;
  /**
   * Send multiple block changes. This fakes a multi block change packet for each
   * chunk section that a block change occurs. This will not actually change the world in any way.
   *
   * @param blockChanges A map of the locations you want to change to their new block data
   * @param suppressLightUpdates Whether to suppress light updates or not
  */
  sendMultiBlockChange(blockChanges: Map<Location, BlockData>, suppressLightUpdates: boolean): void;
  /**
   * Send the equipment change of an entity. This fakes the equipment change
   * of an entity for a user. This will not actually change the inventory of
   * the specified entity in any way.
   *
   * @param entity The entity that the player will see the change for
   * @param slot The slot of the spoofed equipment change
   * @param item The ItemStack to display for the player
  */
  sendEquipmentChange(entity: LivingEntity, slot: EquipmentSlot, item: ItemStack): void;
  /**
   * Send a sign change. This fakes a sign change packet for a user at
   * a certain location. This will not actually change the world in any way.
   * This method will use a sign at the location's block or a faked sign
   * sent via
   * {@link #sendBlockChange(org.bukkit.Location, org.bukkit.Material, byte)}.
   * 
   * If the client does not have a sign at the given location it will
   * display an error message to the user.
   *
   * @param loc the location of the sign
   * @param lines the new text on the sign or null to clear it
   * @throws IllegalArgumentException if location is null
   * @throws IllegalArgumentException if lines is non-null and has a length less than 4
  */
  sendSignChange(loc: Location, lines: Component[] | null): void;
  /**
   * Send a sign change. This fakes a sign change packet for a user at
   * a certain location. This will not actually change the world in any way.
   * This method will use a sign at the location's block or a faked sign
   * sent via
   * {@link #sendBlockChange(org.bukkit.Location, org.bukkit.Material, byte)}.
   * 
   * If the client does not have a sign at the given location it will
   * display an error message to the user.
   *
   * @param loc the location of the sign
   * @param lines the new text on the sign or null to clear it
   * @param dyeColor the color of the sign
   * @throws IllegalArgumentException if location is null
   * @throws IllegalArgumentException if dyeColor is null
   * @throws IllegalArgumentException if lines is non-null and has a length less than 4
  */
  sendSignChange(loc: Location, lines: Component[] | null, dyeColor: DyeColor): void;
  /**
   * Send a sign change. This fakes a sign change packet for a user at
   * a certain location. This will not actually change the world in any way.
   * This method will use a sign at the location's block or a faked sign
   * sent via
   * {@link #sendBlockChange(org.bukkit.Location, org.bukkit.Material, byte)}.
   * 
   * If the client does not have a sign at the given location it will
   * display an error message to the user.
   *
   * @param loc the location of the sign
   * @param lines the new text on the sign or null to clear it
   * @param hasGlowingText whether the text of the sign should glow as if dyed with a glowing ink sac
   * @throws IllegalArgumentException if location is null
   * @throws IllegalArgumentException if dyeColor is null
   * @throws IllegalArgumentException if lines is non-null and has a length less than 4
  */
  sendSignChange(loc: Location, lines: Component[] | null, hasGlowingText: boolean): void;
  /**
   * Send a sign change. This fakes a sign change packet for a user at
   * a certain location. This will not actually change the world in any way.
   * This method will use a sign at the location's block or a faked sign
   * sent via
   * {@link #sendBlockChange(org.bukkit.Location, org.bukkit.Material, byte)}.
   * 
   * If the client does not have a sign at the given location it will
   * display an error message to the user.
   *
   * @param loc the location of the sign
   * @param lines the new text on the sign or null to clear it
   * @param dyeColor the color of the sign
   * @param hasGlowingText whether the text of the sign should glow as if dyed with a glowing ink sac
   * @throws IllegalArgumentException if location is null
   * @throws IllegalArgumentException if dyeColor is null
   * @throws IllegalArgumentException if lines is non-null and has a length less than 4
  */
  sendSignChange(loc: Location, lines: Component[] | null, dyeColor: DyeColor, hasGlowingText: boolean): void;
  /**
   * Send a sign change. This fakes a sign change packet for a user at
   * a certain location. This will not actually change the world in any way.
   * This method will use a sign at the location's block or a faked sign
   * sent via
   * {@link #sendBlockChange(org.bukkit.Location, org.bukkit.Material, byte)}.
   * 
   * If the client does not have a sign at the given location it will
   * display an error message to the user.
   *
   * @param loc the location of the sign
   * @param lines the new text on the sign or null to clear it
   * @throws IllegalArgumentException if location is null
   * @throws IllegalArgumentException if lines is non-null and has a length less than 4
   * @deprecated in favour of {@link #sendSignChange(org.bukkit.Location, java.util.List)}
  */
  sendSignChange(loc: Location, lines: string[] | null): void;
  /**
   * Send a sign change. This fakes a sign change packet for a user at
   * a certain location. This will not actually change the world in any way.
   * This method will use a sign at the location's block or a faked sign
   * sent via
   * {@link #sendBlockChange(org.bukkit.Location, org.bukkit.Material, byte)}.
   * 
   * If the client does not have a sign at the given location it will
   * display an error message to the user.
   *
   * @param loc the location of the sign
   * @param lines the new text on the sign or null to clear it
   * @param dyeColor the color of the sign
   * @throws IllegalArgumentException if location is null
   * @throws IllegalArgumentException if dyeColor is null
   * @throws IllegalArgumentException if lines is non-null and has a length less than 4
   * @deprecated in favour of {@link #sendSignChange(org.bukkit.Location, java.util.List, org.bukkit.DyeColor)}
  */
  sendSignChange(loc: Location, lines: string[] | null, dyeColor: DyeColor): void;
  /**
   * Send a sign change. This fakes a sign change packet for a user at
   * a certain location. This will not actually change the world in any way.
   * This method will use a sign at the location's block or a faked sign
   * sent via
   * {@link #sendBlockChange(org.bukkit.Location, org.bukkit.Material, byte)}.
   * 
   * If the client does not have a sign at the given location it will
   * display an error message to the user.
   *
   * @param loc the location of the sign
   * @param lines the new text on the sign or null to clear it
   * @param dyeColor the color of the sign
   * @param hasGlowingText if the sign's text should be glowing
   * @throws IllegalArgumentException if location is null
   * @throws IllegalArgumentException if dyeColor is null
   * @throws IllegalArgumentException if lines is non-null and has a length less than 4
   * @deprecated Deprecated in favour of {@link #sendSignChange(Location, java.util.List, DyeColor, boolean)}
  */
  sendSignChange(loc: Location, lines: string[] | null, dyeColor: DyeColor, hasGlowingText: boolean): void;
  /**
   * Render a map and send it to the player in its entirety. This may be
   * used when streaming the map in the normal manner is not desirable.
   *
   * @param map The map to be sent
  */
  sendMap(map: MapView): void;
  banPlayerFull(reason: string | null): BanEntry | null;
  /**
   * Permanently Bans the Profile and IP address currently used by the player.
   *
   * @param reason Reason for ban
   * @param source Source of ban, or null for default
   * @return Ban Entry
  */
  banPlayerFull(reason: string | null, source: string | null): BanEntry | null;
  /**
   * Bans the Profile and IP address currently used by the player.
   *
   * @param reason Reason for Ban
   * @param expires When to expire the ban
   * @return Ban Entry
  */
  banPlayerFull(reason: string | null, expires: Date | null): BanEntry | null;
  /**
   * Bans the Profile and IP address currently used by the player.
   *
   * @param reason Reason for Ban
   * @param expires When to expire the ban
   * @param source Source of the ban, or null for default
   * @return Ban Entry
  */
  banPlayerFull(reason: string | null, expires: Date | null, source: string | null): BanEntry | null;
  /**
   * Permanently Bans the IP address currently used by the player.
   * Does not ban the Profile, use {@link #banPlayerFull(String, java.util.Date, String)}
   *
   * @param reason Reason for ban
   * @param kickPlayer Whether or not to kick the player afterwards
   * @return Ban Entry
  */
  banPlayerIP(reason: string | null, kickPlayer: boolean): BanEntry | null;
  /**
   * Permanently Bans the IP address currently used by the player.
   * Does not ban the Profile, use {@link #banPlayerFull(String, java.util.Date, String)}
   * @param reason Reason for ban
   * @param source Source of ban, or null for default
   * @param kickPlayer Whether or not to kick the player afterwards
   * @return Ban Entry
  */
  banPlayerIP(reason: string | null, source: string | null, kickPlayer: boolean): BanEntry | null;
  /**
   * Bans the IP address currently used by the player.
   * Does not ban the Profile, use {@link #banPlayerFull(String, java.util.Date, String)}
   * @param reason Reason for Ban
   * @param expires When to expire the ban
   * @param kickPlayer Whether or not to kick the player afterwards
   * @return Ban Entry
  */
  banPlayerIP(reason: string | null, expires: Date | null, kickPlayer: boolean): BanEntry | null;
  /**
   * Permanently Bans the IP address currently used by the player.
   * Does not ban the Profile, use {@link #banPlayerFull(String, java.util.Date, String)}
   *
   * @param reason Reason for ban
   * @return Ban Entry
  */
  banPlayerIP(reason: string | null): BanEntry | null;
  /**
   * Permanently Bans the IP address currently used by the player.
   * Does not ban the Profile, use {@link #banPlayerFull(String, java.util.Date, String)}
   * @param reason Reason for ban
   * @param source Source of ban, or null for default
   * @return Ban Entry
  */
  banPlayerIP(reason: string | null, source: string | null): BanEntry | null;
  /**
   * Bans the IP address currently used by the player.
   * Does not ban the Profile, use {@link #banPlayerFull(String, java.util.Date, String)}
   * @param reason Reason for Ban
   * @param expires When to expire the ban
   * @return Ban Entry
  */
  banPlayerIP(reason: string | null, expires: Date | null): BanEntry | null;
  /**
   * Bans the IP address currently used by the player.
   * Does not ban the Profile, use {@link #banPlayerFull(String, java.util.Date, String)}
   * @param reason Reason for Ban
   * @param expires When to expire the ban
   * @param source Source of the banm or null for default
   * @return Ban Entry
  */
  banPlayerIP(reason: string | null, expires: Date | null, source: string | null): BanEntry | null;
  /**
   * Bans the IP address currently used by the player.
   * Does not ban the Profile, use {@link #banPlayerFull(String, java.util.Date, String)}
   * @param reason Reason for Ban
   * @param expires When to expire the ban
   * @param source Source of the banm or null for default
   * @param kickPlayer if the targeted player should be kicked
   * @return Ban Entry
  */
  banPlayerIP(reason: string | null, expires: Date | null, source: string | null, kickPlayer: boolean): BanEntry | null;
  /**
   * Sends an Action Bar message to the client.
   *
   * Use Section symbols for legacy color codes to send formatting.
   *
   * @param message The message to send
   * @deprecated use {@link #sendActionBar(Component)}
  */
  sendActionBar(message: string): void;
  /**
   * Sends an Action Bar message to the client.
   *
   * Use supplied alternative character to the section symbol to represent legacy color codes.
   *
   * @param alternateChar Alternate symbol such as '&'
   * @param message The message to send
   * @deprecated use {@link #sendActionBar(Component)}
  */
  sendActionBar(alternateChar: string, message: string): void;
  /**
   * Update the times for titles displayed to the player
   *
   * @param fadeInTicks  ticks to fade-in
   * @param stayTicks    ticks to stay visible
   * @param fadeOutTicks ticks to fade-out
   * @deprecated Use {@link #showTitle(net.kyori.adventure.title.Title)} or {@link #sendTitlePart(net.kyori.adventure.title.TitlePart, Object)}
  */
  setTitleTimes(fadeInTicks: number, stayTicks: number, fadeOutTicks: number): void;
  /**
   * Show the title to the player, overriding any previously displayed title.
   *
   * This method overrides any previous title, use {@link #updateTitle(Title)} to change the existing one.
   *
   * @param title the title to send
   * @throws NullPointerException if the title is null
   * @deprecated Use {@link #showTitle(net.kyori.adventure.title.Title)} or {@link #sendTitlePart(net.kyori.adventure.title.TitlePart, Object)}
  */
  sendTitle(title: Title): void;
  /**
   * Show the title to the player, overriding any previously displayed title.
   *
   * This method doesn't override previous titles, but changes their values.
   *
   * @param title the title to send
   * @throws NullPointerException if title is null
   * @deprecated Use {@link #showTitle(net.kyori.adventure.title.Title)} or {@link #sendTitlePart(net.kyori.adventure.title.TitlePart, Object)}
  */
  updateTitle(title: Title): void;
  /**
   * Hide any title that is currently visible to the player
   *
   * @deprecated use {@link #clearTitle()}
  */
  hideTitle(): void;
  updateInventory(): void;
  /**
   * Gets this player's previous {@link GameMode}
   *
   * @return Previous game mode or null
  */
  getPreviousGameMode(): GameMode | null;
  /**
   * Sets the current time on the player's client. When relative is true the
   * player's time will be kept synchronized to its world time with the
   * specified offset.
   * 
   * When using non relative time the player's time will stay fixed at the
   * specified time parameter. It's up to the caller to continue updating
   * the player's time. To restore player time to normal use
   * resetPlayerTime().
   *
   * @param time The current player's perceived time or the player's time
   *     offset from the server time.
   * @param relative When true the player time is kept relative to its world
   *     time.
  */
  setPlayerTime(time: number, relative: boolean): void;
  /**
   * Returns the player's current timestamp.
   *
   * @return The player's time
  */
  getPlayerTime(): number;
  /**
   * Returns the player's current time offset relative to server time, or
   * the current player's fixed time if the player's time is absolute.
   *
   * @return The player's time
  */
  getPlayerTimeOffset(): number;
  /**
   * Returns true if the player's time is relative to the server time,
   * otherwise the player's time is absolute and will not change its current
   * time unless done so with setPlayerTime().
   *
   * @return true if the player's time is relative to the server time.
  */
  isPlayerTimeRelative(): boolean;
  /**
   * Restores the normal condition where the player's time is synchronized
   * with the server time.
   * 
   * Equivalent to calling setPlayerTime(0, true).
  */
  resetPlayerTime(): void;
  /**
   * Sets the type of weather the player will see.  When used, the weather
   * status of the player is locked until {@link #resetPlayerWeather()} is
   * used.
   *
   * @param type The WeatherType enum type the player should experience
  */
  setPlayerWeather(playerWeather: WeatherType);
  /**
   * Returns the type of weather the player is currently experiencing.
   *
   * @return The WeatherType that the player is currently experiencing or
   *     null if player is seeing server weather.
  */
  getPlayerWeather(): WeatherType | null;
  /**
   * Restores the normal condition where the player's weather is controlled
   * by server conditions.
  */
  resetPlayerWeather(): void;
  /**
   * Gives the player the amount of experience specified.
   *
   * @param amount Exp amount to give
  */
  giveExp(amount: number): void;
  /**
   * Gives the player the amount of experience specified.
   *
   * @param amount Exp amount to give
   * @param applyMending Mend players items with mending, with same behavior as picking up orbs. calls {@link #applyMending(int)}
  */
  giveExp(amount: number, applyMending: boolean): void;
  /**
   * Applies the mending effect to any items just as picking up an orb would.
   *
   * Can also be called with {@link #giveExp(int, boolean)} by passing true to applyMending
   *
   * @param amount Exp to apply
   * @return the remaining experience
  */
  applyMending(amount: number): number;
  /**
   * Gives the player the amount of experience levels specified. Levels can
   * be taken by specifying a negative amount.
   *
   * @param amount amount of experience levels to give or take
  */
  giveExpLevels(amount: number): void;
  /**
   * Gets the players current experience points towards the next level.
   * 
   * This is a percentage value. 0 is "no progress" and 1 is "next level".
   *
   * @return Current experience points
  */
  getExp(): number;
  /**
   * Sets the players current experience points towards the next level
   * 
   * This is a percentage value. 0 is "no progress" and 1 is "next level".
   *
   * @param exp New experience points
  */
  setExp(exp: number);
  /**
   * Gets the players current experience level
   *
   * @return Current experience level
  */
  getLevel(): number;
  /**
   * Sets the players current experience level
   *
   * @param level New experience level
  */
  setLevel(level: number);
  /**
   * Gets the players total experience points.
   * 
   * This refers to the total amount of experience the player has collected
   * over time and is not currently displayed to the client.
   *
   * @return Current total experience points
  */
  getTotalExperience(): number;
  /**
   * Sets the players current experience points.
   * 
   * This refers to the total amount of experience the player has collected
   * over time and is not currently displayed to the client.
   *
   * @param exp New total experience points
  */
  setTotalExperience(totalExperience: number);
  /**
   * Send an experience change.
   *
   * This fakes an experience change packet for a user. This will not actually
   * change the experience points in any way.
   *
   * @param progress Experience progress percentage (between 0.0 and 1.0)
   * @see #setExp(float)
  */
  sendExperienceChange(progress: number): void;
  /**
   * Send an experience change.
   *
   * This fakes an experience change packet for a user. This will not actually
   * change the experience points in any way.
   *
   * @param progress New experience progress percentage (between 0.0 and 1.0)
   * @param level New experience level
   *
   * @see #setExp(float)
   * @see #setLevel(int)
  */
  sendExperienceChange(progress: number, level: number): void;
  /**
   * Determines if the Player is allowed to fly via jump key double-tap like
   * in creative mode.
   *
   * @return True if the player is allowed to fly.
  */
  getAllowFlight(): boolean;
  /**
   * Sets if the Player is allowed to fly via jump key double-tap like in
   * creative mode.
   *
   * @param flight If flight should be allowed.
  */
  setAllowFlight(flight: boolean): void;
  /**
   * Hides a player from this player
   *
   * @param player Player to hide
   * @deprecated see {@link #hidePlayer(Plugin, Player)}
  */
  hidePlayer(player: Player): void;
  /**
   * Hides a player from this player
   *
   * @param plugin Plugin that wants to hide the player
   * @param player Player to hide
  */
  hidePlayer(plugin: Plugin, player: Player): void;
  /**
   * Allows this player to see a player that was previously hidden
   *
   * @param player Player to show
   * @deprecated see {@link #showPlayer(Plugin, Player)}
  */
  showPlayer(player: Player): void;
  /**
   * Allows this player to see a player that was previously hidden. If
   * another another plugin had hidden the player too, then the player will
   * remain hidden until the other plugin calls this method too.
   *
   * @param plugin Plugin that wants to show the player
   * @param player Player to show
  */
  showPlayer(plugin: Plugin, player: Player): void;
  /**
   * Checks to see if a player has been hidden from this player
   *
   * @param player Player to check
   * @return True if the provided player is not being hidden from this
   *     player
  */
  canSee(player: Player): boolean;
  /**
   * Visually hides an entity from this player.
   *
   * @param plugin Plugin that wants to hide the entity
   * @param entity Entity to hide
  */
  hideEntity(plugin: Plugin, entity: Entity): void;
  /**
   * Allows this player to see an entity that was previously hidden. If
   * another another plugin had hidden the entity too, then the entity will
   * remain hidden until the other plugin calls this method too.
   *
   * @param plugin Plugin that wants to show the entity
   * @param entity Entity to show
  */
  showEntity(plugin: Plugin, entity: Entity): void;
  /**
   * Checks to see if an entity has been visually hidden from this player.
   *
   * @param entity Entity to check
   * @return True if the provided entity is not being hidden from this
   *     player
  */
  canSee(entity: Entity): boolean;
  /**
   * Checks to see if this player is currently flying or not.
   *
   * @return True if the player is flying, else false.
  */
  isFlying(): boolean;
  /**
   * Makes this player start or stop flying.
   *
   * @param value True to fly.
  */
  setFlying(value: boolean): void;
  /**
   * Sets the speed at which a client will fly. Negative values indicate
   * reverse directions.
   *
   * @param value The new speed, from -1 to 1.
   * @throws IllegalArgumentException If new speed is less than -1 or
   *     greater than 1
  */
  setFlySpeed(flySpeed: number);
  /**
   * Sets the speed at which a client will walk. Negative values indicate
   * reverse directions.
   *
   * @param value The new speed, from -1 to 1.
   * @throws IllegalArgumentException If new speed is less than -1 or
   *     greater than 1
  */
  setWalkSpeed(walkSpeed: number);
  /**
   * Gets the current allowed speed that a client can fly.
   *
   * @return The current allowed speed, from -1 to 1
  */
  getFlySpeed(): number;
  /**
   * Gets the current allowed speed that a client can walk.
   *
   * @return The current allowed speed, from -1 to 1
  */
  getWalkSpeed(): number;
  /**
   * Request that the player's client download and switch texture packs.
   * 
   * The player's client will download the new texture pack asynchronously
   * in the background, and will automatically switch to it once the
   * download is complete. If the client has downloaded and cached the same
   * texture pack in the past, it will perform a file size check against
   * the response content to determine if the texture pack has changed and
   * needs to be downloaded again. When this request is sent for the very
   * first time from a given server, the client will first display a
   * confirmation GUI to the player before proceeding with the download.
   * 
   * Notes:
   * 
   * Players can disable server textures on their client, in which
   *     case this method will have no affect on them. Use the
   *     {@link PlayerResourcePackStatusEvent} to figure out whether or not
   *     the player loaded the pack!
   * There is no concept of resetting texture packs back to default
   *     within Minecraft, so players will have to relog to do so or you
   *     have to send an empty pack.
   * The request is send with "null" as the hash. This might result
   *     in newer versions not loading the pack correctly.
   * 
   *
   * @param url The URL from which the client will download the texture
   *     pack. The string must contain only US-ASCII characters and should
   *     be encoded as per RFC 1738.
   * @throws IllegalArgumentException Thrown if the URL is null.
   * @throws IllegalArgumentException Thrown if the URL is too long.
   * @deprecated Minecraft no longer uses textures packs. Instead you
   *     should use {@link #setResourcePack(String)}.
  */
  setTexturePack(texturePack: string);
  /**
   * Request that the player's client download and switch resource packs.
   * 
   * The player's client will download the new resource pack asynchronously
   * in the background, and will automatically switch to it once the
   * download is complete. If the client has downloaded and cached the same
   * resource pack in the past, it will perform a file size check against
   * the response content to determine if the resource pack has changed and
   * needs to be downloaded again. When this request is sent for the very
   * first time from a given server, the client will first display a
   * confirmation GUI to the player before proceeding with the download.
   * 
   * Notes:
   * 
   * Players can disable server resources on their client, in which
   *     case this method will have no affect on them. Use the
   *     {@link PlayerResourcePackStatusEvent} to figure out whether or not
   *     the player loaded the pack!
   * There is no concept of resetting resource packs back to default
   *     within Minecraft, so players will have to relog to do so or you
   *     have to send an empty pack.
   * The request is send with empty string as the hash. This might result
   *     in newer versions not loading the pack correctly.
   * 
   *
   * @param url The URL from which the client will download the resource
   *     pack. The string must contain only US-ASCII characters and should
   *     be encoded as per RFC 1738.
   * @throws IllegalArgumentException Thrown if the URL is null.
   * @throws IllegalArgumentException Thrown if the URL is too long. The
   *     length restriction is an implementation specific arbitrary value.
   * @deprecated use {@link #setResourcePack(String, String)}
  */
  setResourcePack(resourcePack: string);
  /**
   * Request that the player's client download and switch resource packs.
   * 
   * The player's client will download the new resource pack asynchronously
   * in the background, and will automatically switch to it once the
   * download is complete. If the client has downloaded and cached a
   * resource pack with the same hash in the past it will not download but
   * directly apply the cached pack. If the hash is null and the client has
   * downloaded and cached the same resource pack in the past, it will
   * perform a file size check against the response content to determine if
   * the resource pack has changed and needs to be downloaded again. When
   * this request is sent for the very first time from a given server, the
   * client will first display a confirmation GUI to the player before
   * proceeding with the download.
   * 
   * Notes:
   * 
   * Players can disable server resources on their client, in which
   *     case this method will have no affect on them. Use the
   *     {@link PlayerResourcePackStatusEvent} to figure out whether or not
   *     the player loaded the pack!
   * There is no concept of resetting resource packs back to default
   *     within Minecraft, so players will have to relog to do so or you
   *     have to send an empty pack.
   * The request is sent with empty string as the hash when the hash is
   *     not provided. This might result in newer versions not loading the
   *     pack correctly.
   * 
   *
   * @param url The URL from which the client will download the resource
   *     pack. The string must contain only US-ASCII characters and should
   *     be encoded as per RFC 1738.
   * @param hash The sha1 hash sum of the resource pack file which is used
   *     to apply a cached version of the pack directly without downloading
   *     if it is available. Hast to be 20 bytes long!
   * @throws IllegalArgumentException Thrown if the URL is null.
   * @throws IllegalArgumentException Thrown if the URL is too long. The
   *     length restriction is an implementation specific arbitrary value.
   * @throws IllegalArgumentException Thrown if the hash is not 20 bytes
   *     long.
  */
  setResourcePack(url: string, hash: number[] | null): void;
  /**
   * Request that the player's client download and switch resource packs.
   * 
   * The player's client will download the new resource pack asynchronously
   * in the background, and will automatically switch to it once the
   * download is complete. If the client has downloaded and cached a
   * resource pack with the same hash in the past it will not download but
   * directly apply the cached pack. If the hash is null and the client has
   * downloaded and cached the same resource pack in the past, it will
   * perform a file size check against the response content to determine if
   * the resource pack has changed and needs to be downloaded again. When
   * this request is sent for the very first time from a given server, the
   * client will first display a confirmation GUI to the player before
   * proceeding with the download.
   * 
   * Notes:
   * 
   * Players can disable server resources on their client, in which
   *     case this method will have no affect on them. Use the
   *     {@link PlayerResourcePackStatusEvent} to figure out whether or not
   *     the player loaded the pack!
   * There is no concept of resetting resource packs back to default
   *     within Minecraft, so players will have to relog to do so or you
   *     have to send an empty pack.
   * The request is sent with empty string as the hash when the hash is
   *     not provided. This might result in newer versions not loading the
   *     pack correctly.
   * 
   *
   * @deprecated in favour of {@link #setResourcePack(String, byte[], Component)}
   * @param url The URL from which the client will download the resource
   *     pack. The string must contain only US-ASCII characters and should
   *     be encoded as per RFC 1738.
   * @param hash The sha1 hash sum of the resource pack file which is used
   *     to apply a cached version of the pack directly without downloading
   *     if it is available. Hast to be 20 bytes long!
   * @param prompt The optional custom prompt message to be shown to client.
   * @throws IllegalArgumentException Thrown if the URL is null.
   * @throws IllegalArgumentException Thrown if the URL is too long. The
   *     length restriction is an implementation specific arbitrary value.
   * @throws IllegalArgumentException Thrown if the hash is not 20 bytes
   *     long.
  */
  setResourcePack(url: string, hash: number[] | null, prompt: string | null): void;
  /**
   * Request that the player's client download and switch resource packs.
   * 
   * The player's client will download the new resource pack asynchronously
   * in the background, and will automatically switch to it once the
   * download is complete. If the client has downloaded and cached a
   * resource pack with the same hash in the past it will not download but
   * directly apply the cached pack. If the hash is null and the client has
   * downloaded and cached the same resource pack in the past, it will
   * perform a file size check against the response content to determine if
   * the resource pack has changed and needs to be downloaded again. When
   * this request is sent for the very first time from a given server, the
   * client will first display a confirmation GUI to the player before
   * proceeding with the download.
   * 
   * Notes:
   * 
   * Players can disable server resources on their client, in which
   *     case this method will have no affect on them. Use the
   *     {@link PlayerResourcePackStatusEvent} to figure out whether or not
   *     the player loaded the pack!
   * There is no concept of resetting resource packs back to default
   *     within Minecraft, so players will have to relog to do so or you
   *     have to send an empty pack.
   * The request is sent with empty string as the hash when the hash is
   *     not provided. This might result in newer versions not loading the
   *     pack correctly.
   * 
   *
   * @param url The URL from which the client will download the resource
   *     pack. The string must contain only US-ASCII characters and should
   *     be encoded as per RFC 1738.
   * @param hash The sha1 hash sum of the resource pack file which is used
   *     to apply a cached version of the pack directly without downloading
   *     if it is available. Hast to be 20 bytes long!
   * @param prompt The optional custom prompt message to be shown to client.
   * @throws IllegalArgumentException Thrown if the URL is null.
   * @throws IllegalArgumentException Thrown if the URL is too long. The
   *     length restriction is an implementation specific arbitrary value.
   * @throws IllegalArgumentException Thrown if the hash is not 20 bytes
   *     long.
  */
  setResourcePack(url: string, hash: number[], prompt: Component): void;
  /**
   * Request that the player's client download and switch resource packs.
   * 
   * The player's client will download the new resource pack asynchronously
   * in the background, and will automatically switch to it once the
   * download is complete. If the client has downloaded and cached a
   * resource pack with the same hash in the past it will not download but
   * directly apply the cached pack. If the hash is null and the client has
   * downloaded and cached the same resource pack in the past, it will
   * perform a file size check against the response content to determine if
   * the resource pack has changed and needs to be downloaded again. When
   * this request is sent for the very first time from a given server, the
   * client will first display a confirmation GUI to the player before
   * proceeding with the download.
   * 
   * Notes:
   * 
   * Players can disable server resources on their client, in which
   *     case this method will have no affect on them. Use the
   *     {@link PlayerResourcePackStatusEvent} to figure out whether or not
   *     the player loaded the pack!
   * There is no concept of resetting resource packs back to default
   *     within Minecraft, so players will have to relog to do so or you
   *     have to send an empty pack.
   * The request is sent with empty string as the hash when the hash is
   *     not provided. This might result in newer versions not loading the
   *     pack correctly.
   * 
   *
   * @param url The URL from which the client will download the resource
   *     pack. The string must contain only US-ASCII characters and should
   *     be encoded as per RFC 1738.
   * @param hash The sha1 hash sum of the resource pack file which is used
   *     to apply a cached version of the pack directly without downloading
   *     if it is available. Hast to be 20 bytes long!
   * @param force If true, the client will be disconnected from the server
   *     when it declines to use the resource pack.
   * @throws IllegalArgumentException Thrown if the URL is null.
   * @throws IllegalArgumentException Thrown if the URL is too long. The
   *     length restriction is an implementation specific arbitrary value.
   * @throws IllegalArgumentException Thrown if the hash is not 20 bytes
   *     long.
  */
  setResourcePack(url: string, hash: number[] | null, force: boolean): void;
  /**
   * Request that the player's client download and switch resource packs.
   * 
   * The player's client will download the new resource pack asynchronously
   * in the background, and will automatically switch to it once the
   * download is complete. If the client has downloaded and cached a
   * resource pack with the same hash in the past it will not download but
   * directly apply the cached pack. If the hash is null and the client has
   * downloaded and cached the same resource pack in the past, it will
   * perform a file size check against the response content to determine if
   * the resource pack has changed and needs to be downloaded again. When
   * this request is sent for the very first time from a given server, the
   * client will first display a confirmation GUI to the player before
   * proceeding with the download.
   * 
   * Notes:
   * 
   * Players can disable server resources on their client, in which
   *     case this method will have no affect on them. Use the
   *     {@link PlayerResourcePackStatusEvent} to figure out whether or not
   *     the player loaded the pack!
   * There is no concept of resetting resource packs back to default
   *     within Minecraft, so players will have to relog to do so or you
   *     have to send an empty pack.
   * The request is sent with empty string as the hash when the hash is
   *     not provided. This might result in newer versions not loading the
   *     pack correctly.
   * 
   *
   * @deprecated in favour of {@link #setResourcePack(String, byte[], Component, boolean)}
   * @param url The URL from which the client will download the resource
   *     pack. The string must contain only US-ASCII characters and should
   *     be encoded as per RFC 1738.
   * @param hash The sha1 hash sum of the resource pack file which is used
   *     to apply a cached version of the pack directly without downloading
   *     if it is available. Hast to be 20 bytes long!
   * @param prompt The optional custom prompt message to be shown to client.
   * @param force If true, the client will be disconnected from the server
   *     when it declines to use the resource pack.
   * @throws IllegalArgumentException Thrown if the URL is null.
   * @throws IllegalArgumentException Thrown if the URL is too long. The
   *     length restriction is an implementation specific arbitrary value.
   * @throws IllegalArgumentException Thrown if the hash is not 20 bytes
   *     long.
  */
  setResourcePack(url: string, hash: number[] | null, prompt: string | null, force: boolean): void;
  /**
   * Request that the player's client download and switch resource packs.
   * 
   * The player's client will download the new resource pack asynchronously
   * in the background, and will automatically switch to it once the
   * download is complete. If the client has downloaded and cached a
   * resource pack with the same hash in the past it will not download but
   * directly apply the cached pack. If the hash is null and the client has
   * downloaded and cached the same resource pack in the past, it will
   * perform a file size check against the response content to determine if
   * the resource pack has changed and needs to be downloaded again. When
   * this request is sent for the very first time from a given server, the
   * client will first display a confirmation GUI to the player before
   * proceeding with the download.
   * 
   * Notes:
   * 
   * Players can disable server resources on their client, in which
   *     case this method will have no affect on them. Use the
   *     {@link PlayerResourcePackStatusEvent} to figure out whether or not
   *     the player loaded the pack!
   * There is no concept of resetting resource packs back to default
   *     within Minecraft, so players will have to relog to do so or you
   *     have to send an empty pack.
   * The request is sent with empty string as the hash when the hash is
   *     not provided. This might result in newer versions not loading the
   *     pack correctly.
   * 
   *
   * @param url The URL from which the client will download the resource
   *     pack. The string must contain only US-ASCII characters and should
   *     be encoded as per RFC 1738.
   * @param hash The sha1 hash sum of the resource pack file which is used
   *     to apply a cached version of the pack directly without downloading
   *     if it is available. Hast to be 20 bytes long!
   * @param prompt The optional custom prompt message to be shown to client.
   * @param force If true, the client will be disconnected from the server
   *     when it declines to use the resource pack.
   * @throws IllegalArgumentException Thrown if the URL is null.
   * @throws IllegalArgumentException Thrown if the URL is too long. The
   *     length restriction is an implementation specific arbitrary value.
   * @throws IllegalArgumentException Thrown if the hash is not 20 bytes
   *     long.
  */
  setResourcePack(url: string, hash: number[], prompt: Component, force: boolean): void;
  /**
   * Gets the Scoreboard displayed to this player
   *
   * @return The current scoreboard seen by this player
  */
  getScoreboard(): Scoreboard;
  /**
   * Sets the player's visible Scoreboard.
   *
   * @param scoreboard New Scoreboard for the player
   * @throws IllegalArgumentException if scoreboard is null
   * @throws IllegalArgumentException if scoreboard was not created by the
   *     {@link org.bukkit.scoreboard.ScoreboardManager scoreboard manager}
   * @throws IllegalStateException if this is a player that is not logged
   *     yet or has logged out
  */
  setScoreboard(scoreboard: Scoreboard);
  /**
   * Gets the {@link WorldBorder} visible to this Player, or null if viewing
   * the world's world border.
   *
   * @return the player's world border
  */
  getWorldBorder(): WorldBorder | null;
  /**
   * Sets the {@link WorldBorder} visible to this Player.
   *
   * @param border the border to set, or null to set to the world border of
   * the player's current world
   *
   * @throws UnsupportedOperationException if setting the border to that of
   * a world in which the player is not currently present.
   *
   * @see Server#createWorldBorder()
  */
  setWorldBorder(worldBorder: WorldBorder | null);
  /**
   * Gets if the client is displayed a 'scaled' health, that is, health on a
   * scale from 0-{@link #getHealthScale()}.
   *
   * @return if client health display is scaled
   * @see Player#setHealthScaled(boolean)
  */
  isHealthScaled(): boolean;
  /**
   * Sets if the client is displayed a 'scaled' health, that is, health on a
   * scale from 0-{@link #getHealthScale()}.
   * 
   * Displayed health follows a simple formula displayedHealth =
   * getHealth() / getMaxHealth() * getHealthScale().
   *
   * @param scale if the client health display is scaled
  */
  setHealthScaled(scale: boolean): void;
  /**
   * Sets the number to scale health to for the client; this will also
   * {@link #setHealthScaled(boolean) setHealthScaled(true)}.
   * 
   * Displayed health follows a simple formula displayedHealth =
   * getHealth() / getMaxHealth() * getHealthScale().
   *
   * @param scale the number to scale health to
   * @throws IllegalArgumentException if scale is <0
   * @throws IllegalArgumentException if scale is {@link Double#NaN}
   * @throws IllegalArgumentException if scale is too high
  */
  setHealthScale(healthScale: number);
  /**
   * Gets the number that health is scaled to for the client.
   *
   * @return the number that health would be scaled to for the client if
   *     HealthScaling is set to true
   * @see Player#setHealthScale(double)
   * @see Player#setHealthScaled(boolean)
  */
  getHealthScale(): number;
  /**
   * Forcefully sends a health update to the player.
   * This method can cause the client to display health values
   * different to their true server values. If the player takes damage or
   * causes an action to otherwise cause a health update, these values
   * will no longer be shown.
   * Setting the visible health to 0 will result in the client seeing
   * the death screen, unable to press the respawn button.
   * @see #sendHealthUpdate()
   * @param health the health of the player
   * @param foodLevel the food level of the player
   * @param saturationLevel the saturation level of the player
  */
  sendHealthUpdate(health: number, foodLevel: number, saturationLevel: number): void;
  /**
   * Forcefully sends a health update to the player.
   * This uses the player's current health, saturation, and food level.
   * Use after {@link #setHealth(double)} to show the heart animation
   * of gaining or losing health.
  */
  sendHealthUpdate(): void;
  /**
   * Gets the entity which is followed by the camera when in
   * {@link GameMode#SPECTATOR}.
   *
   * @return the followed entity, or null if not in spectator mode or not
   * following a specific entity.
  */
  getSpectatorTarget(): Entity | null;
  /**
   * Sets the entity which is followed by the camera when in
   * {@link GameMode#SPECTATOR}.
   *
   * @param entity the entity to follow or null to reset
   * @throws IllegalStateException if the player is not in
   * {@link GameMode#SPECTATOR}
  */
  setSpectatorTarget(spectatorTarget: Entity | null);
  /**
   * Sends a title and a subtitle message to the player. If either of these
   * values are null, they will not be sent and the display will remain
   * unchanged. If they are empty strings, the display will be updated as
   * such. If the strings contain a new line, only the first line will be
   * sent. The titles will be displayed with the client's default timings.
   *
   * @param title Title text
   * @param subtitle Subtitle text
   * @deprecated Use {@link #showTitle(net.kyori.adventure.title.Title)} or {@link #sendTitlePart(net.kyori.adventure.title.TitlePart, Object)}
  */
  sendTitle(title: string | null, subtitle: string | null): void;
  /**
   * Sends a title and a subtitle message to the player. If either of these
   * values are null, they will not be sent and the display will remain
   * unchanged. If they are empty strings, the display will be updated as
   * such. If the strings contain a new line, only the first line will be
   * sent. All timings values may take a value of -1 to indicate that they
   * will use the last value sent (or the defaults if no title has been
   * displayed).
   *
   * @param title Title text
   * @param subtitle Subtitle text
   * @param fadeIn time in ticks for titles to fade in. Defaults to 10.
   * @param stay time in ticks for titles to stay. Defaults to 70.
   * @param fadeOut time in ticks for titles to fade out. Defaults to 20.
   * @deprecated Use {@link #showTitle(net.kyori.adventure.title.Title)} or {@link #sendTitlePart(net.kyori.adventure.title.TitlePart, Object)}
  */
  sendTitle(title: string | null, subtitle: string | null, fadeIn: number, stay: number, fadeOut: number): void;
  /**
   * Resets the title displayed to the player. This will clear the displayed
   * title / subtitle and reset timings to their default values.
  */
  resetTitle(): void;
  /**
   * Spawns the particle (the number of times specified by count)
   * at the target location.
   *
   * @param particle the particle to spawn
   * @param location the location to spawn at
   * @param count the number of particles
  */
  spawnParticle(particle: Particle, location: Location, count: number): void;
  /**
   * Spawns the particle (the number of times specified by count)
   * at the target location.
   *
   * @param particle the particle to spawn
   * @param x the position on the x axis to spawn at
   * @param y the position on the y axis to spawn at
   * @param z the position on the z axis to spawn at
   * @param count the number of particles
  */
  spawnParticle(particle: Particle, x: number, y: number, z: number, count: number): void;
  /**
   * Spawns the particle (the number of times specified by count)
   * at the target location.
   *
   * @param  type of particle data (see {@link Particle#getDataType()}
   * @param particle the particle to spawn
   * @param location the location to spawn at
   * @param count the number of particles
   * @param data the data to use for the particle or null,
   *             the type of this depends on {@link Particle#getDataType()}
  */
  spawnParticle<T>(particle: Particle, location: Location, count: number, data: T | null): void;
  /**
   * Spawns the particle (the number of times specified by count)
   * at the target location.
   *
   * @param  type of particle data (see {@link Particle#getDataType()}
   * @param particle the particle to spawn
   * @param x the position on the x axis to spawn at
   * @param y the position on the y axis to spawn at
   * @param z the position on the z axis to spawn at
   * @param count the number of particles
   * @param data the data to use for the particle or null,
   *             the type of this depends on {@link Particle#getDataType()}
  */
  spawnParticle<T>(particle: Particle, x: number, y: number, z: number, count: number, data: T | null): void;
  /**
   * Spawns the particle (the number of times specified by count)
   * at the target location. The position of each particle will be
   * randomized positively and negatively by the offset parameters
   * on each axis.
   *
   * @param particle the particle to spawn
   * @param location the location to spawn at
   * @param count the number of particles
   * @param offsetX the maximum random offset on the X axis
   * @param offsetY the maximum random offset on the Y axis
   * @param offsetZ the maximum random offset on the Z axis
  */
  spawnParticle(particle: Particle, location: Location, count: number, offsetX: number, offsetY: number, offsetZ: number): void;
  /**
   * Spawns the particle (the number of times specified by count)
   * at the target location. The position of each particle will be
   * randomized positively and negatively by the offset parameters
   * on each axis.
   *
   * @param particle the particle to spawn
   * @param x the position on the x axis to spawn at
   * @param y the position on the y axis to spawn at
   * @param z the position on the z axis to spawn at
   * @param count the number of particles
   * @param offsetX the maximum random offset on the X axis
   * @param offsetY the maximum random offset on the Y axis
   * @param offsetZ the maximum random offset on the Z axis
  */
  spawnParticle(particle: Particle, x: number, y: number, z: number, count: number, offsetX: number, offsetY: number, offsetZ: number): void;
  /**
   * Spawns the particle (the number of times specified by count)
   * at the target location. The position of each particle will be
   * randomized positively and negatively by the offset parameters
   * on each axis.
   *
   * @param  type of particle data (see {@link Particle#getDataType()}
   * @param particle the particle to spawn
   * @param location the location to spawn at
   * @param count the number of particles
   * @param offsetX the maximum random offset on the X axis
   * @param offsetY the maximum random offset on the Y axis
   * @param offsetZ the maximum random offset on the Z axis
   * @param data the data to use for the particle or null,
   *             the type of this depends on {@link Particle#getDataType()}
  */
  spawnParticle<T>(particle: Particle, location: Location, count: number, offsetX: number, offsetY: number, offsetZ: number, data: T | null): void;
  /**
   * Spawns the particle (the number of times specified by count)
   * at the target location. The position of each particle will be
   * randomized positively and negatively by the offset parameters
   * on each axis.
   *
   * @param  type of particle data (see {@link Particle#getDataType()}
   * @param particle the particle to spawn
   * @param x the position on the x axis to spawn at
   * @param y the position on the y axis to spawn at
   * @param z the position on the z axis to spawn at
   * @param count the number of particles
   * @param offsetX the maximum random offset on the X axis
   * @param offsetY the maximum random offset on the Y axis
   * @param offsetZ the maximum random offset on the Z axis
   * @param data the data to use for the particle or null,
   *             the type of this depends on {@link Particle#getDataType()}
  */
  spawnParticle<T>(particle: Particle, x: number, y: number, z: number, count: number, offsetX: number, offsetY: number, offsetZ: number, data: T | null): void;
  /**
   * Spawns the particle (the number of times specified by count)
   * at the target location. The position of each particle will be
   * randomized positively and negatively by the offset parameters
   * on each axis.
   *
   * @param particle the particle to spawn
   * @param location the location to spawn at
   * @param count the number of particles
   * @param offsetX the maximum random offset on the X axis
   * @param offsetY the maximum random offset on the Y axis
   * @param offsetZ the maximum random offset on the Z axis
   * @param extra the extra data for this particle, depends on the
   *              particle used (normally speed)
  */
  spawnParticle(particle: Particle, location: Location, count: number, offsetX: number, offsetY: number, offsetZ: number, extra: number): void;
  /**
   * Spawns the particle (the number of times specified by count)
   * at the target location. The position of each particle will be
   * randomized positively and negatively by the offset parameters
   * on each axis.
   *
   * @param particle the particle to spawn
   * @param x the position on the x axis to spawn at
   * @param y the position on the y axis to spawn at
   * @param z the position on the z axis to spawn at
   * @param count the number of particles
   * @param offsetX the maximum random offset on the X axis
   * @param offsetY the maximum random offset on the Y axis
   * @param offsetZ the maximum random offset on the Z axis
   * @param extra the extra data for this particle, depends on the
   *              particle used (normally speed)
  */
  spawnParticle(particle: Particle, x: number, y: number, z: number, count: number, offsetX: number, offsetY: number, offsetZ: number, extra: number): void;
  /**
   * Spawns the particle (the number of times specified by count)
   * at the target location. The position of each particle will be
   * randomized positively and negatively by the offset parameters
   * on each axis.
   *
   * @param  type of particle data (see {@link Particle#getDataType()}
   * @param particle the particle to spawn
   * @param location the location to spawn at
   * @param count the number of particles
   * @param offsetX the maximum random offset on the X axis
   * @param offsetY the maximum random offset on the Y axis
   * @param offsetZ the maximum random offset on the Z axis
   * @param extra the extra data for this particle, depends on the
   *              particle used (normally speed)
   * @param data the data to use for the particle or null,
   *             the type of this depends on {@link Particle#getDataType()}
  */
  spawnParticle<T>(particle: Particle, location: Location, count: number, offsetX: number, offsetY: number, offsetZ: number, extra: number, data: T | null): void;
  /**
   * Spawns the particle (the number of times specified by count)
   * at the target location. The position of each particle will be
   * randomized positively and negatively by the offset parameters
   * on each axis.
   *
   * @param  type of particle data (see {@link Particle#getDataType()}
   * @param particle the particle to spawn
   * @param x the position on the x axis to spawn at
   * @param y the position on the y axis to spawn at
   * @param z the position on the z axis to spawn at
   * @param count the number of particles
   * @param offsetX the maximum random offset on the X axis
   * @param offsetY the maximum random offset on the Y axis
   * @param offsetZ the maximum random offset on the Z axis
   * @param extra the extra data for this particle, depends on the
   *              particle used (normally speed)
   * @param data the data to use for the particle or null,
   *             the type of this depends on {@link Particle#getDataType()}
  */
  spawnParticle<T>(particle: Particle, x: number, y: number, z: number, count: number, offsetX: number, offsetY: number, offsetZ: number, extra: number, data: T | null): void;
  /**
   * Return the player's progression on the specified advancement.
   *
   * @param advancement advancement
   * @return object detailing the player's progress
  */
  getAdvancementProgress(advancement: Advancement): AdvancementProgress;
  /**
   * Get the player's current client side view distance.
   * 
   * Will default to the server view distance if the client has not yet
   * communicated this information,
   *
   * @return client view distance as above
  */
  getClientViewDistance(): number;
  /**
   * Gets the player's current locale.
   *
   * @return the player's locale
  */
  locale(): Locale;
  /**
   * Gets the player's estimated ping in milliseconds.
   *
   * In Vanilla this value represents a weighted average of the response time
   * to application layer ping packets sent. This value does not represent the
   * network round trip time and as such may have less granularity and be
   * impacted by other sources. For these reasons it should not be used
   * for anti-cheat purposes. Its recommended use is only as a
   * qualitative indicator of connection quality (Vanilla uses it for
   * this purpose in the tab list).
   *
   * @return player ping
  */
  getPing(): number;
  /**
   * Get whether the player can affect mob spawning
   *
   * @return if the player can affect mob spawning
  */
  getAffectsSpawning(): boolean;
  /**
   * Set whether the player can affect mob spawning
   *
   * @param affects Whether the player can affect mob spawning
  */
  setAffectsSpawning(affects: boolean): void;
  /**
   * Gets the view distance for this player
   *
   * @return the player's view distance
   * @see org.bukkit.World#getViewDistance()
  */
  getViewDistance(): number;
  /**
   * Sets the view distance for this player
   *
   * @param viewDistance the player's view distance
   * @see org.bukkit.World#setViewDistance(int)
  */
  setViewDistance(viewDistance: number);
  /**
   * Gets the simulation distance for this player
   *
   * @return the player's simulation distance
  */
  getSimulationDistance(): number;
  /**
   * Sets the simulation distance for this player
   *
   * @param simulationDistance the player's new simulation distance
  */
  setSimulationDistance(simulationDistance: number);
  /**
   * Gets the no-ticking view distance for this player.
   * 
   * No-tick view distance is the view distance where chunks will load, however the chunks and their entities will not
   * be set to tick.
   * 
   * @return The no-tick view distance for this player.
   * @deprecated Use {@link #getViewDistance()}
  */
  getNoTickViewDistance(): number;
  /**
   * Sets the no-ticking view distance for this player.
   * 
   * No-tick view distance is the view distance where chunks will load, however the chunks and their entities will not
   * be set to tick.
   * 
   * @param viewDistance view distance in [2, 32] or -1
   * @deprecated Use {@link #setViewDistance(int)}
  */
  setNoTickViewDistance(noTickViewDistance: number);
  /**
   * Gets the sending view distance for this player.
   * 
   * Sending view distance is the view distance where chunks will load in for players.
   * 
   * @return The sending view distance for this player.
  */
  getSendViewDistance(): number;
  /**
   * Sets the sending view distance for this player.
   * 
   * Sending view distance is the view distance where chunks will load in for players.
   * 
   * @param viewDistance view distance in [2, 32] or -1
  */
  setSendViewDistance(sendViewDistance: number);
  /**
   * Update the list of commands sent to the client.
   * 
   * Generally useful to ensure the client has a complete list of commands
   * after permission changes are done.
  */
  updateCommands(): void;
  /**
   * Open a {@link Material#WRITTEN_BOOK} for a Player
   *
   * @param book The book to open for this player
  */
  openBook(book: ItemStack): void;
  /**
   * Open a Sign for editing by the Player.
   *
   * The Sign must be in the same world as the player.
   *
   * @param sign The sign to edit
  */
  openSign(sign: Sign): void;
  /**
   * Shows the demo screen to the player, this screen is normally only seen in
   * the demo version of the game.
   * 
   * Servers can modify the text on this screen using a resource pack.
  */
  showDemoScreen(): void;
  /**
   * Gets whether the player has the "Allow Server Listings" setting enabled.
   *
   * @return whether the player allows server listings
  */
  isAllowingServerListings(): boolean;
  asHoverEvent(op: UnaryOperator<ShowEntity>): HoverEvent<ShowEntity>;
  /**
   * Request that the player's client download and switch resource packs.
   * 
   * The player's client will download the new resource pack asynchronously
   * in the background, and will automatically switch to it once the
   * download is complete. If the client has downloaded and cached the same
   * resource pack in the past, it will perform a quick timestamp check
   * over the network to determine if the resource pack has changed and
   * needs to be downloaded again. When this request is sent for the very
   * first time from a given server, the client will first display a
   * confirmation GUI to the player before proceeding with the download.
   * 
   * Notes:
   * 
   * Players can disable server resources on their client, in which
   *     case this method will have no affect on them.
   * There is no concept of resetting resource packs back to default
   *     within Minecraft, so players will have to relog to do so.
   * 
   *
   * @param url The URL from which the client will download the resource
   *     pack. The string must contain only US-ASCII characters and should
   *     be encoded as per RFC 1738.
   * @param hash A 40 character hexadecimal and lowercase SHA-1 digest of
   *     the resource pack file.
   * @throws IllegalArgumentException Thrown if the URL is null.
   * @throws IllegalArgumentException Thrown if the URL is too long. The
   *     length restriction is an implementation specific arbitrary value.
  */
  setResourcePack(url: string, hash: string): void;
  /**
   * Request that the player's client download and switch resource packs.
   * 
   * The player's client will download the new resource pack asynchronously
   * in the background, and will automatically switch to it once the
   * download is complete. If the client has downloaded and cached the same
   * resource pack in the past, it will perform a quick timestamp check
   * over the network to determine if the resource pack has changed and
   * needs to be downloaded again. When this request is sent for the very
   * first time from a given server, the client will first display a
   * confirmation GUI to the player before proceeding with the download.
   * 
   * Notes:
   * 
   * Players can disable server resources on their client, in which
   *     case this method will have no affect on them.
   * There is no concept of resetting resource packs back to default
   *     within Minecraft, so players will have to relog to do so.
   * 
   *
   * @param url The URL from which the client will download the resource
   *     pack. The string must contain only US-ASCII characters and should
   *     be encoded as per RFC 1738.
   * @param hash A 40 character hexadecimal and lowercase SHA-1 digest of
   *     the resource pack file.
   * @param required Marks if the resource pack should be required by the client
   * @throws IllegalArgumentException Thrown if the URL is null.
   * @throws IllegalArgumentException Thrown if the URL is too long. The
   *     length restriction is an implementation specific arbitrary value.
  */
  setResourcePack(url: string, hash: string, required: boolean): void;
  /**
   * Request that the player's client download and switch resource packs.
   * 
   * The player's client will download the new resource pack asynchronously
   * in the background, and will automatically switch to it once the
   * download is complete. If the client has downloaded and cached the same
   * resource pack in the past, it will perform a quick timestamp check
   * over the network to determine if the resource pack has changed and
   * needs to be downloaded again. When this request is sent for the very
   * first time from a given server, the client will first display a
   * confirmation GUI to the player before proceeding with the download.
   * 
   * Notes:
   * 
   * Players can disable server resources on their client, in which
   *     case this method will have no affect on them.
   * There is no concept of resetting resource packs back to default
   *     within Minecraft, so players will have to relog to do so.
   * 
   *
   * @param url The URL from which the client will download the resource
   *     pack. The string must contain only US-ASCII characters and should
   *     be encoded as per RFC 1738.
   * @param hash A 40 character hexadecimal and lowercase SHA-1 digest of
   *     the resource pack file.
   * @param required Marks if the resource pack should be required by the client
   * @param resourcePackPrompt A Prompt to be displayed in the client request
   * @throws IllegalArgumentException Thrown if the URL is null.
   * @throws IllegalArgumentException Thrown if the URL is too long. The
   *     length restriction is an implementation specific arbitrary value.
  */
  setResourcePack(url: string, hash: string, required: boolean, resourcePackPrompt: Component | null): void;
  /**
   * @return the most recent resource pack status received from the player,
   *         or null if no status has ever been received from this player.
  */
  getResourcePackStatus(): Status | null;
  /**
   * @return the most recent resource pack hash received from the player,
   *         or null if no hash has ever been received from this player.
   *
   * @deprecated This is no longer sent from the client and will always be null
  */
  getResourcePackHash(): string | null;
  /**
   * @return true if the last resource pack status received from this player
   *         was {@link org.bukkit.event.player.PlayerResourcePackStatusEvent.Status#SUCCESSFULLY_LOADED}
  */
  hasResourcePack(): boolean;
  /**
   * Gets a copy of this players profile
   * @return The players profile object
  */
  getPlayerProfile(): PlayerProfile;
  /**
   * Changes the PlayerProfile for this player. This will cause this player
   * to be reregistered to all clients that can currently see this player
   * @param profile The new profile to use
  */
  setPlayerProfile(playerProfile: PlayerProfile);
  /**
   * Returns the amount of ticks the current cooldown lasts
   *
   * @return Amount of ticks cooldown will last
  */
  getCooldownPeriod(): number;
  /**
   * Returns the percentage of attack power available based on the cooldown (zero to one).
   *
   * @param adjustTicks Amount of ticks to add to cooldown counter for this calculation
   * @return Percentage of attack power available
  */
  getCooledAttackStrength(adjustTicks: number): number;
  /**
   * Reset the cooldown counter to 0, effectively starting the cooldown period.
  */
  resetCooldown(): void;
  /**
   * @return the client option value of the player
  */
  getClientOption<T>(option: ClientOption<T>): T;
  /**
   * Boost a Player that's {@link #isGliding()} using a {@link Firework}.
   * If the creation of the entity is cancelled, no boosting is done.
   * This method does not fire {@link com.destroystokyo.paper.event.player.PlayerElytraBoostEvent}.
   *
   * @param firework The {@link Material#FIREWORK_ROCKET} to boost the player with
   * @return The {@link Firework} boosting the Player or null if the spawning of the entity was cancelled
   * @throws IllegalArgumentException if {@link #isGliding()} is false
   * or if the `firework` isn't a {@link Material#FIREWORK_ROCKET}
  */
  boostElytra(firework: ItemStack): Firework | null;
  /**
   * Send a packet to the player indicating its operator status level.
   * 
   * Note: This will not persist across more than the current connection, and setting the player's operator
   * status as a later point will override the effects of this.
   *
   * @param level The level to send to the player. Must be in `[0, 4]`.
   * @throws IllegalArgumentException If the level is negative or greater than `4` (i.e. not within `[0, 4]`).
  */
  sendOpLevel(level: number): void;
  /**
   * Returns player's client brand name. If the client didn't send this information, the brand name will be null.
   * For the Notchian client this name defaults to vanilla. Some modified clients report other names such as forge.
   * @return client brand name
  */
  getClientBrandName(): string | null;
  spigot(): org_bukkit_entity_Player_Spigot;
  /**
   * Performs the specified {@link EntityEffect} for this entity.
   * 
   * This will be viewable to all players near the entity.
   * 
   * If the effect is not applicable to this class of entity, it will not play.
   *
   * @param type Effect to play.
  */
  playEffect(type: EntityEffect): void;
  /**
   * Represent this object as a hover event.
   *
   * @return a hover event
   * @since 4.0.0
  */
  asHoverEvent(): HoverEvent<V>;
  /**
   * Sends a message on the action bar.
   *
   * @param message a message
   * @see Component
   * @since 4.0.0
  */
  sendActionBar(message: ComponentLike): void;
  /**
   * Sends a message on the action bar.
   *
   * @param message a message
   * @see Component
   * @since 4.0.0
  */
  sendActionBar(message: Component): void;
  /**
   * Plays a sound at the location of the recipient of the sound.
   *
   * To play a sound that follows the recipient, use {@link #playSound(Sound, Sound.Emitter)} with {@link Sound.Emitter#self()}.
   *
   * @param sound a sound
   * @see Sound
   * @since 4.0.0
  */
  playSound(sound: net_kyori_adventure_sound_Sound): void;
  /**
   * Plays a sound at a location.
   *
   * @param sound a sound
   * @param x x coordinate
   * @param y y coordinate
   * @param z z coordinate
   * @see Sound
   * @since 4.0.0
  */
  playSound(sound: net_kyori_adventure_sound_Sound, x: number, y: number, z: number): void;
  /**
   * Stops a sound.
   *
   * @param sound the sound
   * @since 4.8.0
  */
  stopSound(sound: net_kyori_adventure_sound_Sound): void;
  /**
   * Plays a sound from an emitter, usually an entity.
   *
   * 
   *   Sounds played using this method will follow the emitter unless the sound is a custom sound.
   *   In this case the sound will be played at the location of the emitter and will not follow them.
   * 
   *
   * To play a sound that follows the recipient, use {@link Sound.Emitter#self()}.
   *
   * Note: Due to MC-138832, the volume and pitch may be ignored when using this method.
   *
   * @param sound a sound
   * @param emitter an emitter
   * @since 4.8.0
  */
  playSound(sound: net_kyori_adventure_sound_Sound, emitter: Emitter): void;
  /**
   * Stops a sound, or many sounds.
   *
   * @param stop a sound stop
   * @see SoundStop
   * @since 4.0.0
  */
  stopSound(stop: SoundStop): void;
  /**
   * Opens a book.
   *
   * When possible, no item should persist after closing the book.
   *
   * @param book a book
   * @see Book
   * @since 4.0.0
  */
  openBook(book: Builder): void;
  /**
   * Opens a book.
   *
   * When possible, no item should persist after closing the book.
   *
   * @param book a book
   * @see Book
   * @since 4.0.0
  */
  openBook(book: Book): void;
  /**
   * Sends this sender a message raw
   *
   * @param message Message to be displayed
   * @param sender The sender of this message
  */
  sendRawMessage(sender: UUID | null, message: string): void;
}
export interface Player extends HumanEntity, Conversable, OfflinePlayer, PluginMessageRecipient, Identified, NetworkClient {}
/**
 * Represents a boat entity.
*/
export class Boat extends Vehicle {
  /**
   * Gets the wood type of the boat.
   *
   * @return the wood type
  */
  getWoodType(): TreeSpecies;
  /**
   * Sets the wood type of the boat.
   *
   * @param species the new wood type
  */
  setWoodType(woodType: TreeSpecies);
  /**
   * Gets the maximum speed of a boat. The speed is unrelated to the
   * velocity.
   *
   * @return The max speed.
   * @deprecated boats are complex and many of these methods do not work correctly across multiple versions.
  */
  getMaxSpeed(): number;
  /**
   * Sets the maximum speed of a boat. Must be nonnegative. Default is 0.4D.
   *
   * @param speed The max speed.
   * @deprecated boats are complex and many of these methods do not work correctly across multiple versions.
  */
  setMaxSpeed(maxSpeed: number);
  /**
   * Gets the deceleration rate (newSpeed = curSpeed * rate) of occupied
   * boats. The default is 0.2.
   *
   * @return The rate of deceleration
   * @deprecated boats are complex and many of these methods do not work correctly across multiple versions.
  */
  getOccupiedDeceleration(): number;
  /**
   * Sets the deceleration rate (newSpeed = curSpeed * rate) of occupied
   * boats. Setting this to a higher value allows for quicker acceleration.
   * The default is 0.2.
   *
   * @param rate deceleration rate
   * @deprecated boats are complex and many of these methods do not work correctly across multiple versions.
  */
  setOccupiedDeceleration(occupiedDeceleration: number);
  /**
   * Gets the deceleration rate (newSpeed = curSpeed * rate) of unoccupied
   * boats. The default is -1. Values below 0 indicate that no additional
   * deceleration is imposed.
   *
   * @return The rate of deceleration
   * @deprecated boats are complex and many of these methods do not work correctly across multiple versions.
  */
  getUnoccupiedDeceleration(): number;
  /**
   * Sets the deceleration rate (newSpeed = curSpeed * rate) of unoccupied
   * boats. Setting this to a higher value allows for quicker deceleration
   * of boats when a player disembarks. The default is -1. Values below 0
   * indicate that no additional deceleration is imposed.
   *
   * @param rate deceleration rate
   * @deprecated boats are complex and many of these methods do not work correctly across multiple versions.
  */
  setUnoccupiedDeceleration(unoccupiedDeceleration: number);
  /**
   * Get whether boats can work on land.
   *
   * @return whether boats can work on land
   * @deprecated boats are complex and many of these methods do not work correctly across multiple versions.
  */
  getWorkOnLand(): boolean;
  /**
   * Set whether boats can work on land.
   *
   * @param workOnLand whether boats can work on land
   * @deprecated boats are complex and many of these methods do not work correctly across multiple versions.
  */
  setWorkOnLand(workOnLand: boolean): void;
  /**
   * Gets the {@link Material} that represents this Boat type.
   *
   * @return the boat material.
  */
  getBoatMaterial(): Material;
}
/**
 * Represents a Stray - variant of {@link AbstractSkeleton}.
*/
export class Stray extends AbstractSkeleton {

}
/**
 * Represents a large {@link Fireball}
*/
export class LargeFireball extends SizedFireball {

}
/**
 * Represents a villager NPC
*/
export class Villager extends AbstractVillager {
  /**
   * Gets the current profession of this villager.
   *
   * @return Current profession.
  */
  getProfession(): Profession;
  /**
   * Sets the new profession of this villager.
   *
   * @param profession New profession.
  */
  setProfession(profession: Profession);
  /**
   * Gets the current type of this villager.
   *
   * @return Current type.
  */
  getVillagerType(): Type;
  /**
   * Sets the new type of this villager.
   *
   * @param type New type.
  */
  setVillagerType(villagerType: Type);
  /**
   * Gets the level of this villager.
   *
   * A villager with a level of 1 and no experience is liable to lose its
   * profession.
   *
   * @return this villager's level
  */
  getVillagerLevel(): number;
  /**
   * Sets the level of this villager.
   *
   * A villager with a level of 1 and no experience is liable to lose its
   * profession.
   *
   * @param level the new level
   * @throws IllegalArgumentException if level not between [1, 5]
  */
  setVillagerLevel(villagerLevel: number);
  /**
   * Gets the trading experience of this villager.
   *
   * @return trading experience
  */
  getVillagerExperience(): number;
  /**
   * Sets the trading experience of this villager.
   *
   * @param experience new experience
   * @throws IllegalArgumentException if experience < 0
  */
  setVillagerExperience(villagerExperience: number);
  /**
   * Gets the amount of times a villager has restocked their trades today
   * @return The amount of trade restocks.
  */
  getRestocksToday(): number;
  /**
   * Sets the amount of times a villager has restocked their trades today
   * @param restocksToday new restock count
  */
  setRestocksToday(restocksToday: number);
  /**
   * Attempts to make this villager sleep at the given location.
   * 
   * The location must be in the current world and have a bed placed at the
   * location. The villager will put its head on the specified block while
   * sleeping.
   *
   * @param location the location of the bed
   * @return whether the sleep was successful
  */
  sleep(location: Location): boolean;
  /**
   * Causes this villager to wake up if he's currently sleeping.
   *
   * @throws IllegalStateException if not sleeping
  */
  wakeup(): void;
  /**
   * Causes this villager to shake his head.
  */
  shakeHead(): void;
  /**
   * Convert this Villager into a ZombieVillager as if it was killed by a
   * Zombie.
   *
   * Note: this will fire a EntityTransformEvent
   *
   * @return the converted entity {@link ZombieVillager} or null if the
   * conversion its cancelled
  */
  zombify(): ZombieVillager | null;
  /**
   * Get the {@link com.destroystokyo.paper.entity.villager.Reputation reputation}
   * for a specific player by {@link UUID}.
   *
   * @param uniqueId The {@link UUID} of the player to get the reputation of.
   * @return The player's copied reputation with this villager.
  */
  getReputation(uniqueId: UUID): Reputation | null;
  /**
   * Get all {@link com.destroystokyo.paper.entity.villager.Reputation reputations}
   * for all players mapped by their {@link UUID unique IDs}.
   *
   * @return All {@link com.destroystokyo.paper.entity.villager.Reputation reputations} for all players
   * in a copied map.
  */
  getReputations(): Map<UUID, Reputation>;
  /**
   * Set the {@link com.destroystokyo.paper.entity.villager.Reputation reputation}
   * for a specific player by {@link UUID}.
   *
   * @param uniqueId The {@link UUID} of the player to set the reputation of.
   * @param reputation The {@link com.destroystokyo.paper.entity.villager.Reputation reputation} to set.
  */
  setReputation(uniqueId: UUID, reputation: Reputation): void;
  /**
   * Set all {@link com.destroystokyo.paper.entity.villager.Reputation reputations}
   * for all players mapped by their {@link UUID unique IDs}.
   *
   * @param reputations All {@link com.destroystokyo.paper.entity.villager.Reputation reputations}
   * for all players mapped by their {@link UUID unique IDs}.
  */
  setReputations(reputations: Map<UUID, Reputation>);
  /**
   * Clear all reputations from this villager. This removes every single
   * reputation regardless of its impact and the player associated.
  */
  clearReputations(): void;
}
/**
 * Represents a Parrot.
*/
export class Parrot extends Tameable {
  /**
   * Get the variant of this parrot.
   *
   * @return parrot variant
  */
  getVariant(): org_bukkit_entity_Parrot_Variant;
  /**
   * Set the variant of this parrot.
   *
   * @param variant parrot variant
  */
  setVariant(variant: org_bukkit_entity_Parrot_Variant);
}
export interface Parrot extends Tameable, Sittable {}
/**
 * Represents a Piglin Brute.
*/
export class PiglinBrute extends PiglinAbstract {

}
export class ShulkerBullet extends Projectile {
  /**
   * Retrieve the target of this bullet.
   *
   * @return the targeted entity
  */
  getTarget(): Entity | null;
  /**
   * Sets the target of this bullet
   *
   * @param target the entity to target
  */
  setTarget(target: Entity | null);
}
/**
 * Represents a Mule - variant of {@link ChestedHorse}.
*/
export class Mule extends ChestedHorse {

}
/**
 * A classification of entities which may behave differently than others or be
 * affected uniquely by enchantments and potion effects among other things.
*/
export class EntityCategory extends Enum<EntityCategory> {
  /**
   * Any uncategorized entity. No additional effects are applied to these
   * entities relating to a categorization.
  */
  static readonly NONE: EntityCategory;
  /**
   * Undead creatures. These creatures:
   * 
   *   Are damaged by potions of healing.
   *   Are healed by potions of harming.
   *   Are immune to drowning and poison.
   *   Are subject to burning in daylight (though not all).
   *   Sink in water (except {@link Drowned}, {@link Phantom Phantoms}
   *   and {@link Wither Withers}).
   *   Take additional damage from {@link Enchantment#DAMAGE_UNDEAD}.
   *   Are ignored by {@link Wither Withers}.
   * 
  */
  static readonly UNDEAD: EntityCategory;
  /**
   * Entities of the arthropod family. These creatures:
   * 
   *   Take additional damage and receive {@link PotionEffectType#SLOW}
   *   from {@link Enchantment#DAMAGE_ARTHROPODS}.
   *   Are immune to {@link PotionEffectType#POISON} if they are spiders.
   * 
  */
  static readonly ARTHROPOD: EntityCategory;
  /**
   * Entities that participate in raids. These creatures:
   * 
   *   Are immune to damage from {@link EvokerFangs}.
   *   Are ignored by {@link Vindicator vindicators} named "Johnny".
   *   Are hostile to {@link Villager villagers},
   *   {@link WanderingTrader wandering traders}, {@link IronGolem iron golems}
   *   and {@link Player players}.
   * 
  */
  static readonly ILLAGER: EntityCategory;
  /**
   * Entities that reside primarily underwater (excluding {@link Drowned}).
   * These creatures:
   * 
   *   Take additional damage from {@link Enchantment#IMPALING}.
   *   Are immune to drowning (excluding {@link Dolphin dolphins}).
   *   Take suffocation damage when out of water for extended periods of
   *   time (excluding {@link Guardian guardians} and {@link Turtle turtles}).
   *   Are capable of swimming in water rather than floating or sinking.
   * 
  */
  static readonly WATER: EntityCategory;
  static valueOf(name: string): EntityCategory;
  static values(): EntityCategory[];
}
export class Rabbit extends Animals {
  /**
   * @return The type of rabbit.
  */
  getRabbitType(): org_bukkit_entity_Rabbit_Type;
  /**
   * @param type Sets the type of rabbit for this entity.
  */
  setRabbitType(rabbitType: org_bukkit_entity_Rabbit_Type);
}
/**
 * Represents a Vex.
*/
export class Vex extends Monster {
  /**
   * Gets the charging state of this entity.
   *
   * When this entity is charging it will having a glowing red texture.
   *
   * @return charging state
  */
  isCharging(): boolean;
  /**
   * Sets the charging state of this entity.
   *
   * When this entity is charging it will having a glowing red texture.
   *
   * @param charging new state
  */
  setCharging(charging: boolean): void;
  /**
   * Gets the bound of this entity.
   *
   * An idle vex will navigate a 15x11x15 area centered around its bound
   * location.
   *
   * When summoned by an Evoker, this location will be set to that of the
   * summoner.
   *
   * @return {@link Location} of the bound or null if not set
  */
  getBound(): Location | null;
  /**
   * Sets the bound of this entity.
   *
   * An idle vex will navigate a 15x11x15 area centered around its bound
   * location.
   *
   * When summoned by an Evoker, this location will be set to that of the
   * summoner.
   *
   * @param location {@link Location} of the bound or null to clear
  */
  setBound(bound: Location | null);
  /**
   * Gets the remaining lifespan of this entity.
   *
   * @return life in ticks
   * @deprecated This API duplicates existing API which uses the more
   * preferable name due to mirroring internals better
  */
  getLifeTicks(): number;
  /**
   * Sets the remaining lifespan of this entity.
   *
   * @param lifeTicks life in ticks, or negative for unlimited lifepan
   * @deprecated This API duplicates existing API which uses the more
   * preferable name due to mirroring internals better
  */
  setLifeTicks(lifeTicks: number);
  /**
   * Gets if the entity has a limited life.
   *
   * @return true if the entity has limited life
   * @deprecated This API duplicates existing API which uses the more
   * preferable name due to mirroring internals better
  */
  hasLimitedLife(): boolean;
  /**
   * Get the Mob that summoned this vex
   *
   * @return Mob that summoned this vex
  */
  getSummoner(): Mob | null;
  /**
   * Set the summoner of this vex
   *
   * @param summoner New summoner
  */
  setSummoner(summoner: Mob | null);
  /**
   * Gets if this vex should start to take damage
   * once {@link Vex#getLimitedLifetimeTicks()} is less than or equal to 0.
   * 
   * @return will take damage
  */
  hasLimitedLifetime(): boolean;
  /**
   * Sets if this vex should start to take damage
   * once {@link Vex#getLimitedLifetimeTicks()} is less than or equal to 0.
   *      
   * @param hasLimitedLifetime should take damage
  */
  setLimitedLifetime(hasLimitedLifetime: boolean): void;
  /**
   * Gets the number of ticks remaining until the vex will start
   * to take damage.
   * 
   * @return ticks until the vex will start to take damage
  */
  getLimitedLifetimeTicks(): number;
  /**
   * Sets the number of ticks remaining until the vex takes damage.
   * This number is ticked down only if {@link Vex#hasLimitedLifetime()} is true.
   * 
   * @param ticks ticks remaining
  */
  setLimitedLifetimeTicks(limitedLifetimeTicks: number);
}
/**
 * Represents a single part of a {@link ComplexLivingEntity}
*/
export class ComplexEntityPart extends Entity {
  /**
   * Gets the parent {@link ComplexLivingEntity} of this part.
   *
   * @return Parent complex entity
  */
  getParent(): ComplexLivingEntity;
}
/**
 * Meow.
*/
export class Cat extends Tameable {
  /**
   * Gets the current type of this cat.
   *
   * @return Type of the cat.
  */
  getCatType(): org_bukkit_entity_Cat_Type;
  /**
   * Sets the current type of this cat.
   *
   * @param type New type of this cat.
  */
  setCatType(catType: org_bukkit_entity_Cat_Type);
  /**
   * Get the collar color of this cat
   *
   * @return the color of the collar
  */
  getCollarColor(): DyeColor;
  /**
   * Set the collar color of this cat
   *
   * @param color the color to apply
  */
  setCollarColor(collarColor: DyeColor);
  /**
   * Sets if the cat is lying down.
   * This is visual and does not affect the behaviour of the cat.
   *
   * @param lyingDown whether the cat should lie down
  */
  setLyingDown(lyingDown: boolean): void;
  /**
   * Gets if the cat is lying down.
   *
   * @return whether the cat is lying down
  */
  isLyingDown(): boolean;
  /**
   * Sets if the cat has its head up.
   * This is visual and does not affect the behaviour of the cat.
   *
   * @param headUp head is up
  */
  setHeadUp(headUp: boolean): void;
  /**
   * Gets if the cat has its head up.
   *
   * @return head is up
  */
  isHeadUp(): boolean;
}
export interface Cat extends Tameable, Sittable, CollarColorable {}
/**
 * Represents a fishing hook.
*/
export class FishHook extends Projectile {
  /**
   * Get the minimum number of ticks one has to wait for a fish biting.
   * 
   * The default is 100 ticks (5 seconds).
   * Note that this is before applying lure.
   *
   * @return Minimum number of ticks one has to wait for a fish biting
  */
  getMinWaitTime(): number;
  /**
   * Set the minimum number of ticks one has to wait for a fish biting.
   * 
   * The default is 100 ticks (5 seconds).
   * Note that this is before applying lure.
   *
   * @param minWaitTime Minimum number of ticks one has to wait for a fish
   * biting
  */
  setMinWaitTime(minWaitTime: number);
  /**
   * Get the maximum number of ticks one has to wait for a fish biting.
   * 
   * The default is 600 ticks (30 seconds).
   * Note that this is before applying lure.
   *
   * @return Maximum number of ticks one has to wait for a fish biting
  */
  getMaxWaitTime(): number;
  /**
   * Set the maximum number of ticks one has to wait for a fish biting.
   * 
   * The default is 600 ticks (30 seconds).
   * Note that this is before applying lure.
   *
   * @param maxWaitTime Maximum number of ticks one has to wait for a fish
   * biting
  */
  setMaxWaitTime(maxWaitTime: number);
  /**
   * Get whether the lure enchantment should be applied to reduce the wait
   * time.
   * 
   * The default is true.
   * Lure reduces the wait time by 100 ticks (5 seconds) for each level of the
   * enchantment.
   *
   * @return Whether the lure enchantment should be applied to reduce the wait
   * time
  */
  getApplyLure(): boolean;
  /**
   * Set whether the lure enchantment should be applied to reduce the wait
   * time.
   * 
   * The default is true.
   * Lure reduces the wait time by 100 ticks (5 seconds) for each level of the
   * enchantment.
   *
   * @param applyLure Whether the lure enchantment should be applied to reduce
   * the wait time
  */
  setApplyLure(applyLure: boolean): void;
  /**
   * Gets the chance of a fish biting.
   * 
   * 0.0 = No Chance.
   * 1.0 = Instant catch.
   *
   * @return chance the bite chance
   * @deprecated has no effect in newer Minecraft versions
  */
  getBiteChance(): number;
  /**
   * Sets the chance of a fish biting.
   * 
   * 0.0 = No Chance.
   * 1.0 = Instant catch.
   *
   * @param chance the bite chance
   * @throws IllegalArgumentException if the bite chance is not between 0
   *     and 1
   * @deprecated has no effect in newer Minecraft versions
  */
  setBiteChance(biteChance: number);
  /**
   * Check whether or not this fish hook is in open water.
   * 
   * Open water is defined by a 5x4x5 area of water, air and lily pads. If in
   * open water, treasure items may be caught.
   *
   * @return true if in open water, false otherwise
  */
  isInOpenWater(): boolean;
  /**
   * Get the entity hooked by this fish hook.
   *
   * @return the hooked entity. null if none
  */
  getHookedEntity(): Entity | null;
  /**
   * Set the entity hooked by this fish hook.
   *
   * @param entity the entity to set, or null to unhook
  */
  setHookedEntity(hookedEntity: Entity | null);
  /**
   * Pull the hooked entity to the caster of this fish hook. If no entity is
   * hooked, this method has no effect.
   *
   * @return true if pulled, false if no entity is hooked
  */
  pullHookedEntity(): boolean;
  /**
   * Get the current state of this fish hook.
   *
   * @return the fish hook state
  */
  getState(): HookState;
  /**
   * Get the number of ticks the hook needs to wait for a fish to bite.
   *
   * @return Number of ticks
  */
  getWaitTime(): number;
  /**
   * Sets the number of ticks the hook needs to wait for a fish to bite.
   *
   * @param ticks Number of ticks
  */
  setWaitTime(waitTime: number);
}
/**
 * Represents a Silverfish.
*/
export class Silverfish extends Monster {

}
/**
 * Represents a phantom.
*/
export class Phantom extends Flying {
  /**
   * @return The size of the phantom
  */
  getSize(): number;
  /**
   * @param sz The new size of the phantom.
  */
  setSize(size: number);
  /**
   * Get the UUID of the entity that caused this phantom to spawn
   *
   * @return UUID
  */
  getSpawningEntity(): UUID | null;
  /**
   * Check if this phantom will burn in the sunlight
   *
   * @return True if phantom will burn in sunlight
  */
  shouldBurnInDay(): boolean;
  /**
   * Set if this phantom should burn in the sunlight
   *
   * @param shouldBurnInDay True to burn in sunlight
  */
  setShouldBurnInDay(shouldBurnInDay: boolean): void;
}
/**
 * Represents a Flying Entity.
*/
export class Flying extends Mob {

}
/**
 * Represents an entity body pose.
*/
export class Pose extends Enum<Pose> {
  /**
   * Entity is standing normally.
   *
  */
  static readonly STANDING: Pose;
  /**
   * Entity is gliding.
  */
  static readonly FALL_FLYING: Pose;
  /**
   * Entity is sleeping.
  */
  static readonly SLEEPING: Pose;
  /**
   * Entity is swimming.
  */
  static readonly SWIMMING: Pose;
  /**
   * Entity is riptiding with a trident.
  */
  static readonly SPIN_ATTACK: Pose;
  /**
   * Entity is sneaking.
  */
  static readonly SNEAKING: Pose;
  /**
   * Entity is long jumping.
  */
  static readonly LONG_JUMPING: Pose;
  /**
   * Entity is dead.
  */
  static readonly DYING: Pose;
  static valueOf(name: string): Pose;
  static values(): Pose[];
}
/**
 * A mechanical creature that may harm enemies.
*/
export class Golem extends Creature {

}
/**
 * Represents a small {@link Fireball}
*/
export class SmallFireball extends SizedFireball {

}
/**
 * Represents a thrown egg.
*/
export class Egg extends ThrowableProjectile {

}
/**
 * Represents a spectral arrow.
*/
export class SpectralArrow extends AbstractArrow {
  /**
   * Returns the amount of time that this arrow will apply
   * the glowing effect for.
   *
   * @return the glowing effect ticks
  */
  getGlowingTicks(): number;
  /**
   * Sets the amount of time to apply the glowing effect for.
   *
   * @param duration the glowing effect ticks
  */
  setGlowingTicks(glowingTicks: number);
}
/**
 * Represents a Horse.
*/
export class Horse extends AbstractHorse {
  /**
   * Gets the horse's color.
   * 
   * Colors only apply to horses, not to donkeys, mules, skeleton horses
   * or undead horses.
   *
   * @return a {@link Color} representing the horse's group
  */
  getColor(): org_bukkit_entity_Horse_Color;
  /**
   * Sets the horse's color.
   * 
   * Attempting to set a color for any donkey, mule, skeleton horse or
   * undead horse will not result in a change.
   *
   * @param color a {@link Color} for this horse
  */
  setColor(color: org_bukkit_entity_Horse_Color);
  /**
   * Gets the horse's style.
   * Styles determine what kind of markings or patterns a horse has.
   * 
   * Styles only apply to horses, not to donkeys, mules, skeleton horses
   * or undead horses.
   *
   * @return a {@link Style} representing the horse's style
  */
  getStyle(): Style;
  /**
   * Sets the style of this horse.
   * Styles determine what kind of markings or patterns a horse has.
   * 
   * Attempting to set a style for any donkey, mule, skeleton horse or
   * undead horse will not result in a change.
   *
   * @param style a {@link Style} for this horse
  */
  setStyle(style: Style);
  /**
   * @return carrying chest status
   * @deprecated see {@link ChestedHorse}
  */
  isCarryingChest(): boolean;
  /**
   * @param chest chest
   * @deprecated see {@link ChestedHorse}
  */
  setCarryingChest(chest: boolean): void;
  getInventory(): HorseInventory;
}
/**
 * Represents a WitherSkeleton - variant of {@link AbstractSkeleton}.
*/
export class WitherSkeleton extends AbstractSkeleton {

}
export class Arrow extends AbstractArrow {
  /**
   * Sets the underlying potion data
   *
   * @param data PotionData to set the base potion state to
  */
  setBasePotionData(basePotionData: PotionData);
  /**
   * Returns the potion data about the base potion
   *
   * @return a PotionData object
  */
  getBasePotionData(): PotionData;
  /**
   * Gets the color of this arrow.
   *
   * @return arrow {@link Color} or null if not color is set
  */
  getColor(): org_bukkit_Color | null;
  /**
   * Sets the color of this arrow. Will be applied as a tint to its particles.
   *
   * @param color arrow color, null to clear the color
  */
  setColor(color: org_bukkit_Color | null);
  /**
   * Checks for the presence of custom potion effects.
   *
   * @return true if custom potion effects are applied
  */
  hasCustomEffects(): boolean;
  /**
   * Gets an immutable list containing all custom potion effects applied to
   * this arrow.
   * 
   * Plugins should check that hasCustomEffects() returns true before calling
   * this method.
   *
   * @return the immutable list of custom potion effects
  */
  getCustomEffects(): PotionEffect[];
  /**
   * Adds a custom potion effect to this arrow.
   *
   * @param effect the potion effect to add
   * @param overwrite true if any existing effect of the same type should be
   * overwritten
   * @return true if the effect was added as a result of this call
  */
  addCustomEffect(effect: PotionEffect, overwrite: boolean): boolean;
  /**
   * Removes a custom potion effect from this arrow.
   *
   * @param type the potion effect type to remove
   * @return true if the an effect was removed as a result of this call
   * @throws IllegalArgumentException if this operation would leave the Arrow
   * in a state with no Custom Effects and PotionType.UNCRAFTABLE
  */
  removeCustomEffect(type: PotionEffectType): boolean;
  /**
   * Checks for a specific custom potion effect type on this arrow.
   *
   * @param type the potion effect type to check for
   * @return true if the potion has this effect
  */
  hasCustomEffect(type: PotionEffectType | null): boolean;
  /**
   * Removes all custom potion effects from this arrow.
   *
   * @throws IllegalArgumentException if this operation would leave the Arrow
   * in a state with no Custom Effects and PotionType.UNCRAFTABLE
  */
  clearCustomEffects(): void;
}
/**
 * Represents an Illusioner "Illager".
*/
export class Illusioner extends Spellcaster {

}
export interface Illusioner extends Spellcaster, RangedEntity {}
/**
 * Represents a wither skull {@link Fireball}.
*/
export class WitherSkull extends Fireball {
  /**
   * Sets the charged status of the wither skull.
   *
   * @param charged whether it should be charged
  */
  setCharged(charged: boolean): void;
  /**
   * Gets whether or not the wither skull is charged.
   *
   * @return whether the wither skull is charged
  */
  isCharged(): boolean;
}
/**
 * Represents a minecart entity.
*/
export class Minecart extends Vehicle {
  /**
   * Sets a minecart's damage.
   *
   * @param damage over 40 to "kill" a minecart
  */
  setDamage(damage: number);
  /**
   * Gets a minecart's damage.
   *
   * @return The damage
  */
  getDamage(): number;
  /**
   * Gets the maximum speed of a minecart. The speed is unrelated to the
   * velocity.
   *
   * @return The max speed
  */
  getMaxSpeed(): number;
  /**
   * Sets the maximum speed of a minecart. Must be nonnegative. Default is
   * 0.4D.
   *
   * @param speed The max speed
  */
  setMaxSpeed(maxSpeed: number);
  /**
   * Returns whether this minecart will slow down faster without a passenger
   * occupying it
   *
   * @return Whether it decelerates faster
  */
  isSlowWhenEmpty(): boolean;
  /**
   * Sets whether this minecart will slow down faster without a passenger
   * occupying it
   *
   * @param slow Whether it will decelerate faster
  */
  setSlowWhenEmpty(slow: boolean): void;
  /**
   * Gets the flying velocity modifier. Used for minecarts that are in
   * mid-air. A flying minecart's velocity is multiplied by this factor each
   * tick.
   *
   * @return The vector factor
  */
  getFlyingVelocityMod(): Vector;
  /**
   * Sets the flying velocity modifier. Used for minecarts that are in
   * mid-air. A flying minecart's velocity is multiplied by this factor each
   * tick.
   *
   * @param flying velocity modifier vector
  */
  setFlyingVelocityMod(flyingVelocityMod: Vector);
  /**
   * Gets the derailed velocity modifier. Used for minecarts that are on the
   * ground, but not on rails.
   * 
   * A derailed minecart's velocity is multiplied by this factor each tick.
   *
   * @return derailed visible speed
  */
  getDerailedVelocityMod(): Vector;
  /**
   * Sets the derailed velocity modifier. Used for minecarts that are on the
   * ground, but not on rails. A derailed minecart's velocity is multiplied
   * by this factor each tick.
   *
   * @param derailed visible speed
  */
  setDerailedVelocityMod(derailedVelocityMod: Vector);
  /**
   * Sets the display block for this minecart.
   * Passing a null value will set the minecart to have no display block.
   *
   * @param material the material to set as display block.
   * @deprecated use {@link #setDisplayBlockData(BlockData)}
  */
  setDisplayBlock(displayBlock: MaterialData | null);
  /**
   * Gets the display block for this minecart.
   * This function will return the type AIR if none is set.
   *
   * @return the block displayed by this minecart.
   * @deprecated use {@link #getDisplayBlockData()}
  */
  getDisplayBlock(): MaterialData;
  /**
   * Sets the display block for this minecart.
   * Passing a null value will set the minecart to have no display block.
   *
   * @param blockData the material to set as display block.
  */
  setDisplayBlockData(displayBlockData: BlockData | null);
  /**
   * Gets the display block for this minecart.
   * This function will return the type AIR if none is set.
   *
   * @return the block displayed by this minecart.
  */
  getDisplayBlockData(): BlockData;
  /**
   * Sets the offset of the display block.
   *
   * @param offset the block offset to set for this minecart.
  */
  setDisplayBlockOffset(displayBlockOffset: number);
  /**
   * Gets the offset of the display block.
   *
   * @return the current block offset for this minecart.
  */
  getDisplayBlockOffset(): number;
  /**
   * Gets the {@link Material} that represents this Minecart type.
   *
   * @return the minecart material.
  */
  getMinecartMaterial(): Material;
}
/**
 * Represents a Donkey - variant of {@link ChestedHorse}.
*/
export class Donkey extends ChestedHorse {

}
/**
 * Represents a Chicken.
*/
export class Chicken extends Animals {

}
/**
 * Represents an Ender Dragon
*/
export class EnderDragon extends ComplexLivingEntity {
  /**
   * Gets the current phase that the dragon is performing.
   *
   * @return the current phase
  */
  getPhase(): Phase;
  /**
   * Sets the next phase for the dragon to perform.
   *
   * @param phase the next phase
  */
  setPhase(phase: Phase);
  /**
   * Get the {@link DragonBattle} associated with this EnderDragon.
   *
   * This will return null if the EnderDragon is not in the End dimension.
   *
   * @return the dragon battle
   *
   * @see World#getEnderDragonBattle()
  */
  getDragonBattle(): DragonBattle | null;
  /**
   * Get the current time in ticks relative to the start of this dragon's
   * death animation.
   *
   * If this dragon is alive, 0 will be returned. This value will never exceed
   * 200 (the length of the animation).
   *
   * @return this dragon's death animation ticks
  */
  getDeathAnimationTicks(): number;
  /**
   * Get the podium location used by the ender dragon.
   *
   * @return the podium location of the dragon
  */
  getPodium(): Location;
  /**
   * Sets the location of the podium for the ender dragon.
   *
   * @param location the location of the podium or null to use the default podium location (exit portal of the end)
  */
  setPodium(podium: Location | null);
}
export interface EnderDragon extends ComplexLivingEntity, Boss, Mob {}
export class Tameable extends Animals {
  /**
   * Check if this is tamed
   * 
   * If something is tamed then a player can not tame it through normal
   * methods, even if it does not belong to anyone in particular.
   *
   * @return true if this has been tamed
  */
  isTamed(): boolean;
  /**
   * Sets if this has been tamed. Not necessary if the method setOwner has
   * been used, as it tames automatically.
   * 
   * If something is tamed then a player can not tame it through normal
   * methods, even if it does not belong to anyone in particular.
   *
   * @param tame true if tame
  */
  setTamed(tame: boolean): void;
  /**
   * Gets the owners UUID
   *
   * @return the owners UUID, or null if not owned
  */
  getOwnerUniqueId(): UUID | null;
  /**
   * Gets the current owning AnimalTamer
   *
   * @see #getOwnerUniqueId() Recommended to use UUID version instead of this for performance.
   * This method will cause OfflinePlayer to be loaded from disk if the owner is not online.
   *
   * @return the owning AnimalTamer, or null if not owned
  */
  getOwner(): AnimalTamer | null;
  /**
   * Set this to be owned by given AnimalTamer.
   * 
   * If the owner is not null, this will be tamed and will have any current
   * path it is following removed. If the owner is set to null, this will be
   * untamed, and the current owner removed.
   *
   * @param tamer the AnimalTamer who should own this
  */
  setOwner(owner: AnimalTamer | null);
}
/**
 * A Glow Item Frame.
*/
export class GlowItemFrame extends ItemFrame {

}
/**
 * Represents a Monster.
*/
export class Monster extends Creature {

}
/**
 * Represents a wandering trader NPC
*/
export class WanderingTrader extends AbstractVillager {
  /**
   * Gets the despawn delay before this {@link WanderingTrader} is forcibly
   * despawned.
   *
   * If this is less than or equal to 0, then the trader will not be
   * despawned.
   *
   * @return The despawn delay before this {@link WanderingTrader} is forcibly
   * despawned
  */
  getDespawnDelay(): number;
  /**
   * Sets the despawn delay before this {@link WanderingTrader} is forcibly
   * despawned.
   *
   * If this is less than or equal to 0, then the trader will not be
   * despawned.
   *
   * @param despawnDelay The new despawn delay before this
   * {@link WanderingTrader} is forcibly despawned
  */
  setDespawnDelay(despawnDelay: number);
  /**
   * Set if the Wandering Trader can and will drink an invisibility potion.
   * @param bool whether the mob will drink
  */
  setCanDrinkPotion(bool: boolean): void;
  /**
   * Get if the Wandering Trader can and will drink an invisibility potion.
   * @return whether the mob will drink
  */
  canDrinkPotion(): boolean;
  /**
   * Set if the Wandering Trader can and will drink milk.
   * @param bool whether the mob will drink
  */
  setCanDrinkMilk(bool: boolean): void;
  /**
   * Get if the Wandering Trader can and will drink milk.
   * @return whether the mob will drink
  */
  canDrinkMilk(): boolean;
}
/**
 * Represents an entity that can age.
*/
export class Ageable extends Creature {
  /**
   * Gets the age of this mob.
   *
   * @return Age
  */
  getAge(): number;
  /**
   * Sets the age of this mob.
   *
   * @param age New age
  */
  setAge(age: number);
  /**
   * Lock the age of the animal, setting this will prevent the animal from
   * maturing or getting ready for mating.
   *
   * @param lock new lock
   * @deprecated see {@link Breedable#setAgeLock(boolean)}
  */
  setAgeLock(lock: boolean): void;
  /**
   * Gets the current agelock.
   *
   * @return the current agelock
   * @deprecated see {@link Breedable#getAgeLock()}
  */
  getAgeLock(): boolean;
  /**
   * Sets the age of the mob to a baby
  */
  setBaby(): void;
  /**
   * Sets the age of the mob to an adult
  */
  setAdult(): void;
  /**
   * Returns true if the mob is an adult.
   *
   * @return return true if the mob is an adult
  */
  isAdult(): boolean;
  /**
   * Return the ability to breed of the animal.
   *
   * @return the ability to breed of the animal
   * @deprecated see {@link Breedable#canBreed()}
  */
  canBreed(): boolean;
  /**
   * Set breedability of the animal, if the animal is a baby and set to
   * breed it will instantly grow up.
   *
   * @param breed breedability of the animal
   * @deprecated see {@link Breedable#setBreed(boolean)}
  */
  setBreed(breed: boolean): void;
}
/**
 * What does the fox say?
*/
export class Fox extends Animals {
  /**
   * Gets the current type of this fox.
   *
   * @return Type of the fox.
  */
  getFoxType(): org_bukkit_entity_Fox_Type;
  /**
   * Sets the current type of this fox.
   *
   * @param type New type of this fox.
  */
  setFoxType(foxType: org_bukkit_entity_Fox_Type);
  /**
   * Checks if this animal is crouching
   *
   * @return true if crouching
  */
  isCrouching(): boolean;
  /**
   * Sets if this animal is crouching.
   *
   * @param crouching true if crouching
  */
  setCrouching(crouching: boolean): void;
  /**
   * Sets if this animal is sleeping.
   *
   * @param sleeping true if sleeping
  */
  setSleeping(sleeping: boolean): void;
  /**
   * Gets the first trusted player.
   *
   * @return the owning AnimalTamer, or null if not owned
  */
  getFirstTrustedPlayer(): AnimalTamer | null;
  /**
   * Set the first trusted player.
   * 
   * The first trusted player may only be removed after the second.
   *
   * @param player the AnimalTamer to be trusted
  */
  setFirstTrustedPlayer(firstTrustedPlayer: AnimalTamer | null);
  /**
   * Gets the second trusted player.
   *
   * @return the owning AnimalTamer, or null if not owned
  */
  getSecondTrustedPlayer(): AnimalTamer | null;
  /**
   * Set the second trusted player.
   * 
   * The second trusted player may only be added after the first.
   *
   * @param player the AnimalTamer to be trusted
  */
  setSecondTrustedPlayer(secondTrustedPlayer: AnimalTamer | null);
  /**
   * Sets if the fox is interested.
   *
   * @param interested is interested
  */
  setInterested(interested: boolean): void;
  /**
   * Gets if the fox is interested.
   *
   * @return fox is interested
  */
  isInterested(): boolean;
  /**
   * Sets if the fox is leaping.
   *
   * @param leaping is leaping
  */
  setLeaping(leaping: boolean): void;
  /**
   * Gets if the fox is leaping.
   *
   * @return fox is leaping
  */
  isLeaping(): boolean;
  /**
   * Sets if the fox is defending.
   *
   * @param defending is defending
  */
  setDefending(defending: boolean): void;
  /**
   * Gets if the fox is defending.
   *
   * @return fox is defending
  */
  isDefending(): boolean;
  /**
   * Sets if the fox face planted.
   *
   * @param faceplanted face planted
  */
  setFaceplanted(faceplanted: boolean): void;
  /**
   * Gets if the fox face planted.
   *
   * @return fox face planted
  */
  isFaceplanted(): boolean;
}
export interface Fox extends Animals, Sittable {}
/**
 * Represents a thrown lingering potion bottle
 *
 * @deprecated lingering status depends on only on the potion item.
*/
export class LingeringPotion extends ThrownPotion {

}
/**
 * Represents a villager NPC
*/
export class AbstractVillager extends Breedable {
  /**
   * Gets this villager's inventory.
   * 
   * Note that this inventory is not the Merchant inventory, rather, it is the
   * items that a villager might have collected (from harvesting crops, etc.)
   *
   * {@inheritDoc}
  */
  getInventory(): Inventory;
  /**
   * Reset this villager's trade offers
  */
  resetOffers(): void;
}
export interface AbstractVillager extends Breedable, NPC, InventoryHolder, Merchant {}
/**
 * Represents a SkeletonHorse - variant of {@link AbstractHorse}.
*/
export class SkeletonHorse extends AbstractHorse {
  /**
   * Returns whether this skeleton horse is trapped.
   * 
   * When a horse is trapped and a player comes within 10 blocks of a trapped
   * horse, lightning will strike the horse. When struck, the skeleton trap
   * will activate, turning the horse into a skeleton horseman as well as
   * spawning three additional horsemen nearby.
   *
   * @return true if trapped
  */
  isTrapped(): boolean;
  /**
   * Sets if this skeleton horse is trapped.
   *
   * @param trapped new trapped state
  */
  setTrapped(trapped: boolean): void;
  /**
   * Returns the horse's current trap time in ticks.
   *
   * Trap time is incremented every tick when {@link #isTrapped()} is true.
   * The horse automatically despawns when it reaches 18000 ticks.
   *
   * @return current trap time
  */
  getTrapTime(): number;
  /**
   * Sets the trap time for the horse.
   *
   * Values greater than 18000 will cause the horse to despawn on the next
   * tick.
   *
   * @param trapTime new trap time
  */
  setTrapTime(trapTime: number);
  /**
   * @deprecated use {@link #isTrapped()}
  */
  isTrap(): boolean;
  /**
   * @deprecated use {@link #setTrapped(boolean)}
  */
  setTrap(trap: boolean): void;
}
/**
 * Represents a thrown potion bottle
*/
export class ThrownPotion extends Projectile {
  /**
   * Returns the effects that are applied by this potion.
   *
   * @return The potion effects
  */
  getEffects(): Collection<PotionEffect>;
  /**
   * Returns a copy of the ItemStack for this thrown potion.
   * 
   * Altering this copy will not alter the thrown potion directly. If you want
   * to alter the thrown potion, you must use the {@link
   * #setItem(ItemStack) setItemStack} method.
   *
   * @return A copy of the ItemStack for this thrown potion.
  */
  getItem(): ItemStack;
  /**
   * Set the ItemStack for this thrown potion.
   *
   * @param item New ItemStack
  */
  setItem(item: ItemStack);
  /**
   * Gets a copy of the PotionMeta for this thrown potion.
   * This includes what effects will be applied by this potion.
   *
   * @return potion meta
  */
  getPotionMeta(): PotionMeta;
  /**
   * Sets the PotionMeta of this thrown potion.
   * This will modify the effects applied by this potion.
   * 
   * Note that the type of {@link #getItem()} is irrelevant
   *
   * @param meta potion meta
  */
  setPotionMeta(potionMeta: PotionMeta);
}
/**
 * Represents a Zombie.
*/
export class Zombie extends Monster {
  /**
   * Gets whether the zombie is a baby
   *
   * @return Whether the zombie is a baby
   * @deprecated see {@link Ageable#isAdult()}
  */
  isBaby(): boolean;
  /**
   * Sets whether the zombie is a baby
   *
   * @param flag Whether the zombie is a baby
   * @deprecated see {@link Ageable#setBaby()} and {@link Ageable#setAdult()}
  */
  setBaby(flag: boolean): void;
  /**
   * Gets whether the zombie is a villager
   *
   * @return Whether the zombie is a villager
   * @deprecated check if instanceof {@link ZombieVillager}.
  */
  isVillager(): boolean;
  /**
   * @param flag flag
   * @deprecated must spawn {@link ZombieVillager}.
  */
  setVillager(flag: boolean): void;
  /**
   * @param profession profession
   * @see ZombieVillager#getVillagerProfession()
  */
  setVillagerProfession(villagerProfession: Profession);
  /**
   * @return profession
   * @see ZombieVillager#getVillagerProfession()
  */
  getVillagerProfession(): Profession | null;
  /**
   * Get if this entity is in the process of converting to a Drowned as a
   * result of being underwater.
   *
   * @return conversion status
  */
  isConverting(): boolean;
  /**
   * Gets the amount of ticks until this entity will be converted to a Drowned
   * as a result of being underwater.
   *
   * When this reaches 0, the entity will be converted.
   *
   * @return conversion time
   * @throws IllegalStateException if {@link #isConverting()} is false.
  */
  getConversionTime(): number;
  /**
   * Sets the amount of ticks until this entity will be converted to a Drowned
   * as a result of being underwater.
   *
   * When this reaches 0, the entity will be converted. A value of less than 0
   * will stop the current conversion process without converting the current
   * entity.
   *
   * @param time new conversion time
  */
  setConversionTime(conversionTime: number);
  /**
   * Check if zombie is drowning
   *
   * @return True if zombie conversion process has begun
  */
  isDrowning(): boolean;
  /**
   * Make zombie start drowning
   *
   * @param drownedConversionTime Amount of time until zombie converts from drowning
   *
   * @deprecated See {@link #setConversionTime(int)}
  */
  startDrowning(drownedConversionTime: number): void;
  /**
   * Stop a zombie from starting the drowning conversion process
  */
  stopDrowning(): void;
  /**
   * Set if zombie has its arms raised
   *
   * @param raised True to raise arms
  */
  setArmsRaised(raised: boolean): void;
  /**
   * Check if zombie has arms raised
   *
   * @return True if arms are raised
  */
  isArmsRaised(): boolean;
  /**
   * Check if this zombie will burn in the sunlight
   *
   * @return True if zombie will burn in sunlight
  */
  shouldBurnInDay(): boolean;
  /**
   * Set if this zombie should burn in the sunlight
   *
   * @param shouldBurnInDay True to burn in sunlight
  */
  setShouldBurnInDay(shouldBurnInDay: boolean): void;
  /**
   * Check if this zombie can break doors
   *
   * @return True if zombie can break doors
  */
  canBreakDoors(): boolean;
  /**
   * Sets if this zombie can break doors.
   * Check {@link #supportsBreakingDoors()} to see
   * if this zombie type will even be affected by using
   * this method.
   *
   * @param canBreakDoors True if zombie can break doors
  */
  setCanBreakDoors(canBreakDoors: boolean): void;
  /**
   * Checks if this zombie type supports breaking doors.
   * {@link Drowned} do not have support for breaking doors
   * so using {@link #setCanBreakDoors(boolean)} on them has
   * no effect.
   *
   * @return
  */
  supportsBreakingDoors(): boolean;
  /**
   * Sets the age of the mob to a baby
  */
  setBaby(): void;
}
export interface Zombie extends Monster, Ageable {}
/**
 * Represents a snowball.
*/
export class Snowball extends ThrowableProjectile {

}
/**
 * Represents a Hoglin.
*/
export class Hoglin extends Animals {
  /**
   * Gets whether the hoglin is immune to zombification.
   *
   * @return Whether the hoglin is immune to zombification
  */
  isImmuneToZombification(): boolean;
  /**
   * Sets whether the hoglin is immune to zombification.
   *
   * @param flag Whether the hoglin is immune to zombification
  */
  setImmuneToZombification(flag: boolean): void;
  /**
   * Get whether the hoglin is able to be hunted by piglins.
   *
   * @return Whether the hoglin is able to be hunted by piglins
  */
  isAbleToBeHunted(): boolean;
  /**
   * Sets whether the hoglin is able to be hunted by piglins.
   *
   * @param flag Whether the hoglin is able to be hunted by piglins.
  */
  setIsAbleToBeHunted(flag: boolean): void;
  /**
   * Gets the amount of ticks until this entity will be converted to a Zoglin.
   *
   * When this reaches 300, the entity will be converted.
   *
   * @return conversion time
   * @throws IllegalStateException if {@link #isConverting()} is false.
  */
  getConversionTime(): number;
  /**
   * Sets the amount of ticks until this entity will be converted to a Zoglin.
   *
   * When this reaches 0, the entity will be converted. A value of less than 0
   * will stop the current conversion process without converting the current
   * entity.
   *
   * @param time new conversion time
  */
  setConversionTime(conversionTime: number);
  /**
   * Get if this entity is in the process of converting to a Zoglin.
   *
   * @return conversion status
  */
  isConverting(): boolean;
}
/**
 * Represents the Boss Entity.
*/
export class Boss extends Entity {
  /**
   * Returns the {@link BossBar} of the {@link Boss}
   *
   * @return the {@link BossBar} of the entity
  */
  getBossBar(): BossBar | null;
}
/**
 * Represents a Horse-like creature.
*/
export class AbstractHorse extends Vehicle {
  /**
   * Gets the horse's variant.
   * 
   * A horse's variant defines its physical appearance and capabilities.
   * Whether a horse is a regular horse, donkey, mule, or other kind of horse
   * is determined using the variant.
   *
   * @return a {@link Horse.Variant} representing the horse's variant
   * @deprecated different variants are different classes
  */
  getVariant(): org_bukkit_entity_Horse_Variant;
  /**
   * @param variant variant
   * @deprecated you are required to spawn a different entity
  */
  setVariant(variant: org_bukkit_entity_Horse_Variant);
  /**
   * Gets the domestication level of this horse.
   * 
   * A higher domestication level indicates that the horse is closer to
   * becoming tame. As the domestication level gets closer to the max
   * domestication level, the chance of the horse becoming tame increases.
   *
   * @return domestication level
  */
  getDomestication(): number;
  /**
   * Sets the domestication level of this horse.
   * 
   * Setting the domestication level to a high value will increase the
   * horse's chances of becoming tame.
   * 
   * Domestication level must be greater than zero and no greater than
   * the max domestication level of the horse, determined with
   * {@link #getMaxDomestication()}
   *
   * @param level domestication level
  */
  setDomestication(domestication: number);
  /**
   * Gets the maximum domestication level of this horse.
   * 
   * The higher this level is, the longer it will likely take
   * for the horse to be tamed.
   *
   * @return the max domestication level
  */
  getMaxDomestication(): number;
  /**
   * Sets the maximum domestication level of this horse.
   * 
   * Setting a higher max domestication will increase the amount of
   * domesticating (feeding, riding, etc.) necessary in order to tame it,
   * while setting a lower max value will have the opposite effect.
   * 
   * Maximum domestication must be greater than zero.
   *
   * @param level the max domestication level
  */
  setMaxDomestication(maxDomestication: number);
  /**
   * Gets the jump strength of this horse.
   * 
   * Jump strength defines how high the horse can jump. A higher jump strength
   * increases how high a jump will go.
   *
   * @return the horse's jump strength
  */
  getJumpStrength(): number;
  /**
   * Sets the jump strength of this horse.
   * 
   * A higher jump strength increases how high a jump will go.
   * Setting a jump strength to 0 will result in no jump.
   * You cannot set a jump strength to a value below 0 or
   * above 2.
   *
   * @param strength jump strength for this horse
  */
  setJumpStrength(jumpStrength: number);
  /**
   * Gets whether the horse is currently grazing hay.
   *
   * @return true if eating hay
  */
  isEatingHaystack(): boolean;
  /**
   * Sets whether the horse is grazing hay.
   *
   * @param eatingHaystack new hay grazing status
  */
  setEatingHaystack(eatingHaystack: boolean): void;
  getInventory(): AbstractHorseInventory;
  /**
   * Gets if a horse is in their eating grass animation.
   *
   * @return eating grass animation is active
   * @deprecated use {@link #isEatingHaystack()}
  */
  isEatingGrass(): boolean;
  /**
   * Sets if a horse is in their eating grass animation.
   *
   * When true, the horse will lower its neck.
   *
   * @param eating eating grass animation is active
   * @deprecated use {@link #setEatingHaystack(boolean)}
  */
  setEatingGrass(eating: boolean): void;
  /**
   * Gets if a horse is in their rearing animation.
   *
   * @return rearing animation is active
  */
  isRearing(): boolean;
  /**
   * Sets if a horse is in their rearing animation.
   *
   * When true, the horse will stand on its hind legs.
   *
   * @param rearing rearing animation is active
  */
  setRearing(rearing: boolean): void;
  /**
   * Gets if a horse is in their eating animation.
   *
   * @return eating animation is active
  */
  isEating(): boolean;
  /**
   * Sets if a horse is in their eating animation.
   *
   * When true, the horse will bob its head.
   *
   * @param eating eating animation is active
  */
  setEating(eating: boolean): void;
}
export interface AbstractHorse extends Vehicle, InventoryHolder, Tameable {}
/**
 * Represents an {@link Entity} that has health and can take damage.
*/
export class Damageable extends Entity {
  /**
   * Deals the given amount of damage to this entity.
   *
   * @param amount Amount of damage to deal
  */
  damage(amount: number): void;
  /**
   * Deals the given amount of damage to this entity, from a specified
   * entity.
   *
   * @param amount Amount of damage to deal
   * @param source Entity which to attribute this damage from
  */
  damage(amount: number, source: Entity | null): void;
  /**
   * Gets the entity's health from 0 to {@link #getMaxHealth()}, where 0 is dead.
   *
   * @return Health represented from 0 to max
  */
  getHealth(): number;
  /**
   * Sets the entity's health from 0 to {@link #getMaxHealth()}, where 0 is
   * dead.
   *
   * @param health New health represented from 0 to max
   * @throws IllegalArgumentException Thrown if the health is {@literal < 0 or >}
   *     {@link #getMaxHealth()}
  */
  setHealth(health: number);
  /**
   * Gets the entity's absorption amount.
   *
   * @return absorption amount from 0
  */
  getAbsorptionAmount(): number;
  /**
   * Sets the entity's absorption amount.
   *
   * @param amount new absorption amount from 0
   * @throws IllegalArgumentException thrown if health is {@literal < 0} or
   * non-finite.
  */
  setAbsorptionAmount(absorptionAmount: number);
  /**
   * Gets the maximum health this entity has.
   *
   * @return Maximum health
   * @deprecated use {@link Attribute#GENERIC_MAX_HEALTH}.
  */
  getMaxHealth(): number;
  /**
   * Sets the maximum health this entity can have.
   * 
   * If the health of the entity is above the value provided it will be set
   * to that value.
   * 
   * Note: An entity with a health bar ({@link Player}, {@link EnderDragon},
   * {@link Wither}, etc...} will have their bar scaled accordingly.
   *
   * @param health amount of health to set the maximum to
   * @deprecated use {@link Attribute#GENERIC_MAX_HEALTH}.
  */
  setMaxHealth(maxHealth: number);
  /**
   * Resets the max health to the original amount.
   * @deprecated use {@link Attribute#GENERIC_MAX_HEALTH}.
  */
  resetMaxHealth(): void;
}
/**
 * Represents a dropped item.
*/
export class Item extends Entity {
  /**
   * Gets the item stack associated with this item drop.
   *
   * @return An item stack.
  */
  getItemStack(): ItemStack;
  /**
   * Sets the item stack associated with this item drop.
   *
   * @param stack An item stack.
  */
  setItemStack(itemStack: ItemStack);
  /**
   * Gets the delay before this Item is available to be picked up by players
   *
   * @return Remaining delay
  */
  getPickupDelay(): number;
  /**
   * Sets the delay before this Item is available to be picked up by players
   *
   * @param delay New delay
  */
  setPickupDelay(pickupDelay: number);
  /**
   * Sets if this Item should live forever
   *
   * @param unlimited true if the lifetime is unlimited
  */
  setUnlimitedLifetime(unlimited: boolean): void;
  /**
   * Gets if this Item lives forever
   *
   * @return true if the lifetime is unlimited
  */
  isUnlimitedLifetime(): boolean;
  /**
   * Sets the owner of this item.
   *
   * Other entities will not be able to pickup this item when an owner is set.
   *
   * @param owner UUID of new owner
  */
  setOwner(owner: UUID | null);
  /**
   * Get the owner of this item.
   *
   * @return UUID of owner
  */
  getOwner(): UUID | null;
  /**
   * Set the thrower of this item.
   *
   * The thrower is the entity which dropped the item. This affects the
   * trigger criteria for item pickups, for things such as advancements.
   *
   * @param uuid UUID of thrower
  */
  setThrower(thrower: UUID | null);
  /**
   * Get the thrower of this item.
   *
   * The thrower is the entity which dropped the item.
   *
   * @return UUID of thrower
  */
  getThrower(): UUID | null;
  /**
   * Gets if non-player entities can pick this Item up
   *
   * @return True if non-player entities can pickup
  */
  canMobPickup(): boolean;
  /**
   * Sets if non-player entities can pick this Item up
   *
   * @param canMobPickup True to allow non-player entity pickup
  */
  setCanMobPickup(canMobPickup: boolean): void;
  /**
   * Gets whether the player can pickup the item or not
   *
   * @return True if a player can pickup the item
  */
  canPlayerPickup(): boolean;
  /**
   * Sets whether the item can be picked up or not. Modifies the pickup delay value to do so.
   *
   * @param canPlayerPickup True if the player can pickup the item
  */
  setCanPlayerPickup(canPlayerPickup: boolean): void;
  /**
   * Gets whether the item will age and despawn from being on the ground too long
   *
   * @return True if the item will age
  */
  willAge(): boolean;
  /**
   * Sets whether the item will age or not. If the item is not ageing, it will not despawn
   * by being on the ground for too long.
   *
   * @param willAge True if the item should age
  */
  setWillAge(willAge: boolean): void;
  /**
   * Gets the health of item stack.
   * 
   * Currently the default max health is 5.
   *
   * @return the health
  */
  getHealth(): number;
  /**
   * Sets the health of the item stack. If the value is non-positive
   * the itemstack's normal "on destroy" functionality will be run.
   * 
   * Currently, the default max health is 5.
   *
   * @param health the health, a non-positive value will destroy the entity
  */
  setHealth(health: number);
}
export class AnimalTamer {
  /**
   * This is the name of the specified AnimalTamer.
   *
   * @return The name to reference on tamed animals or null if a name cannot be obtained
  */
  getName(): string | null;
  /**
   * This is the UUID of the specified AnimalTamer.
   *
   * @return The UUID to reference on tamed animals
  */
  getUniqueId(): UUID;
}
/**
 * Represents an arrow.
*/
export class AbstractArrow extends Projectile {
  /**
   * Gets the knockback strength for an arrow, which is the
   * {@link org.bukkit.enchantments.Enchantment#KNOCKBACK KnockBack} level
   * of the bow that shot it.
   *
   * @return the knockback strength value
  */
  getKnockbackStrength(): number;
  /**
   * Sets the knockback strength for an arrow.
   *
   * @param knockbackStrength the knockback strength value
  */
  setKnockbackStrength(knockbackStrength: number);
  /**
   * Gets the base amount of damage this arrow will do.
   *
   * Defaults to 2.0 for a normal arrow with
   * 0.5 * (1 + power level) added for arrows fired from
   * enchanted bows.
   *
   * @return base damage amount
  */
  getDamage(): number;
  /**
   * Sets the base amount of damage this arrow will do.
   *
   * @param damage new damage amount
  */
  setDamage(damage: number);
  /**
   * Gets the number of times this arrow can pierce through an entity.
   *
   * @return pierce level
  */
  getPierceLevel(): number;
  /**
   * Sets the number of times this arrow can pierce through an entity.
   *
   * Must be between 0 and 127 times.
   *
   * @param pierceLevel new pierce level
  */
  setPierceLevel(pierceLevel: number);
  /**
   * Gets whether this arrow is critical.
   * 
   * Critical arrows have increased damage and cause particle effects.
   * 
   * Critical arrows generally occur when a player fully draws a bow before
   * firing.
   *
   * @return true if it is critical
  */
  isCritical(): boolean;
  /**
   * Sets whether or not this arrow should be critical.
   *
   * @param critical whether or not it should be critical
  */
  setCritical(critical: boolean): void;
  /**
   * Gets whether this arrow is in a block or not.
   * 
   * Arrows in a block are motionless and may be picked up by players.
   *
   * @return true if in a block
  */
  isInBlock(): boolean;
  /**
   * Gets the block to which this arrow is attached.
   *
   * @return the attached block or null if not attached
  */
  getAttachedBlock(): Block | null;
  /**
   * Gets the current pickup status of this arrow.
   *
   * @return the pickup status of this arrow.
  */
  getPickupStatus(): PickupStatus;
  /**
   * Sets the current pickup status of this arrow.
   *
   * @param status new pickup status of this arrow.
  */
  setPickupStatus(pickupStatus: PickupStatus);
  /**
   * Gets if this arrow was shot from a crossbow.
   *
   * @return if shot from a crossbow
  */
  isShotFromCrossbow(): boolean;
  /**
   * Sets if this arrow was shot from a crossbow.
   *
   * @param shotFromCrossbow if shot from a crossbow
  */
  setShotFromCrossbow(shotFromCrossbow: boolean): void;
  /**
   * Gets the ItemStack for this arrow.
   *
   * @return The ItemStack, as if a player picked up the arrow
  */
  getItemStack(): ItemStack;
  /**
   * Sets this arrow to "noclip" status.
   *
   * @param noPhysics true to set "noclip"
  */
  setNoPhysics(noPhysics: boolean): void;
  /**
   * Gets if this arrow has "noclip".
   *
   * @return true if noclip is active
  */
  hasNoPhysics(): boolean;
  /**
   * Gets the {@link PickupRule} for this arrow.
   *
   * This is generally {@link PickupRule#ALLOWED} only if the arrow was
   * not fired from a bow with the infinity enchantment.
   *
   * @return The pickup rule
   * @deprecated Use {@link Arrow#getPickupStatus()} as an upstream compatible replacement for this function
  */
  getPickupRule(): PickupRule;
  /**
   * Set the rule for which players can pickup this arrow as an item.
   *
   * @param rule The pickup rule
   * @deprecated Use {@link Arrow#setPickupStatus(PickupStatus)} with {@link PickupStatus} as an upstream compatible replacement for this function
  */
  setPickupRule(pickupRule: PickupRule);
}
/**
 * Represents a Vindicator.
*/
export class Vindicator extends Illager {
  /**
   * Returns whether a vindicator is in "Johnny" mode.
   *
   * When this mode is active, vindicators will be hostile to all mobs.
   *
   * @return true if johnny
  */
  isJohnny(): boolean;
  /**
   * Sets the Johnny state of a vindicator.
   *
   * @param johnny new johnny state
  */
  setJohnny(johnny: boolean): void;
}
export class ThrowableProjectile extends Projectile {
  /**
   * Gets the ItemStack the thrown projectile will display.
   *
   * @return The thrown item display ItemStack
  */
  getItem(): ItemStack;
  /**
   * Sets the display ItemStack for the thrown projectile.
   *
   * @param item ItemStack set to be displayed
  */
  setItem(item: ItemStack);
}
/**
 * Represents a Witch
*/
export class Witch extends Raider {
  /**
   * Check if Witch is drinking a potion
   *
   * @return True if drinking a potion
  */
  isDrinkingPotion(): boolean;
  /**
   * Get time remaining (in ticks) the Witch is drinking a potion
   *
   * @return Time remaining (in ticks)
  */
  getPotionUseTimeLeft(): number;
  /**
   * Set time remaining (in ticks) that the Witch is drinking a potion.
   * 
   * This only has an effect while the Witch is drinking a potion.
   *
   * @param ticks Time in ticks remaining
   * @see #isDrinkingPotion
  */
  setPotionUseTimeLeft(potionUseTimeLeft: number);
  /**
   * Get the potion the Witch is drinking
   *
   * @return The potion the witch is drinking
  */
  getDrinkingPotion(): ItemStack | null;
  /**
   * Set the potion the Witch should drink
   *
   * @param potion Potion to drink
  */
  setDrinkingPotion(drinkingPotion: ItemStack | null);
}
export interface Witch extends Raider, RangedEntity {}
export class Ghast extends Flying {
  /**
   * Returns whether the ghast is charging an attack.
   *
   * @return whether the ghast is charging an attack
  */
  isCharging(): boolean;
  /**
   * Sets whether the ghast is charging an attack.
   * This determines whether the client displays the charging animation.
   *
   * @param charging whether the ghast is charging an attack
  */
  setCharging(charging: boolean): void;
  /**
   * Returns the explosion power of shot fireballs.
   *
   * @return explosion power of shot fireballs
  */
  getExplosionPower(): number;
  /**
   * Sets the explosion power of shot fireballs.
   *
   * @param explosionPower explosion power of shot fireballs
   * @throws IllegalArgumentException if the explosion power is less than 0 or greater than 127
  */
  setExplosionPower(explosionPower: number);
}
/**
 * Represents a Painting.
*/
export class Painting extends Hanging {
  /**
   * Get the art on this painting
   *
   * @return The art
  */
  getArt(): Art;
  /**
   * Set the art on this painting
   *
   * @param art The new art
   * @return False if the new art won't fit at the painting's current
   *     location
  */
  setArt(art: Art);
  /**
   * Set the art on this painting
   *
   * @param art The new art
   * @param force If true, force the new art regardless of whether it fits
   *     at the current location. Note that forcing it where it can't fit
   *     normally causes it to drop as an item unless you override this by
   *     catching the {@link HangingBreakEvent}.
   * @return False if force was false and the new art won't fit at the
   *     painting's current location
  */
  setArt(art: Art, force: boolean): boolean;
}
/**
 * Represents a Strider.
*/
export class Strider extends Steerable {
  /**
   * Check whether or not this strider is out of warm blocks and shivering.
   *
   * @return true if shivering, false otherwise
  */
  isShivering(): boolean;
  /**
   * Set whether or not this strider is shivering.
   *
   * Note that the shivering state is updated frequently on the server,
   * therefore this method may not affect the entity for long enough to have a
   * noticeable difference.
   *
   * @param shivering its new shivering state
  */
  setShivering(shivering: boolean): void;
}
export interface Strider extends Steerable, Vehicle {}
export class Endermite extends Monster {
  /**
   * Gets whether this Endermite was spawned by a player.
   *
   * An Endermite spawned by a player will be attacked by nearby Enderman.
   *
   * @return player spawned status
   * @deprecated this functionality no longer exists
  */
  isPlayerSpawned(): boolean;
  /**
   * Sets whether this Endermite was spawned by a player.
   *
   * An Endermite spawned by a player will be attacked by nearby Enderman.
   *
   * @param playerSpawned player spawned status
   * @deprecated this functionality no longer exists
  */
  setPlayerSpawned(playerSpawned: boolean): void;
}
export class ArmorStand extends LivingEntity {
  /**
   * Returns the item the armor stand is currently holding.
   *
   * @return the held item
   * @see #getEquipment()
   * @deprecated prefer {@link ArmorStand#getItem(EquipmentSlot)} // Paper
  */
  getItemInHand(): ItemStack;
  /**
   * Sets the item the armor stand is currently holding.
   *
   * @param item the item to hold
   * @see #getEquipment()
   * @deprecated prefer
   * {@link ArmorStand#setItem(EquipmentSlot, ItemStack)} // Paper
  */
  setItemInHand(itemInHand: ItemStack | null);
  /**
   * Returns the item currently being worn by the armor stand on its feet.
   *
   * @return the worn item
   * @see #getEquipment()
   * @deprecated prefer {@link EntityEquipment#getBoots()}
  */
  getBoots(): ItemStack;
  /**
   * Sets the item currently being worn by the armor stand on its feet.
   *
   * @param item the item to wear
   * @see #getEquipment()
   * @deprecated prefer
   * {@link EntityEquipment#setBoots(org.bukkit.inventory.ItemStack)}
  */
  setBoots(boots: ItemStack | null);
  /**
   * Returns the item currently being worn by the armor stand on its legs.
   *
   * @return the worn item
   * @see #getEquipment()
   * @deprecated prefer {@link EntityEquipment#getLeggings()}
  */
  getLeggings(): ItemStack;
  /**
   * Sets the item currently being worn by the armor stand on its legs.
   *
   * @param item the item to wear
   * @see #getEquipment()
   * @deprecated prefer
   * {@link EntityEquipment#setLeggings(org.bukkit.inventory.ItemStack)}
  */
  setLeggings(leggings: ItemStack | null);
  /**
   * Returns the item currently being worn by the armor stand on its chest.
   *
   * @return the worn item
   * @see #getEquipment()
   * @deprecated prefer {@link EntityEquipment#getChestplate()}
  */
  getChestplate(): ItemStack;
  /**
   * Sets the item currently being worn by the armor stand on its chest.
   *
   * @param item the item to wear
   * @see #getEquipment()
   * @deprecated prefer
   * {@link EntityEquipment#setChestplate(org.bukkit.inventory.ItemStack)}
  */
  setChestplate(chestplate: ItemStack | null);
  /**
   * Returns the item currently being worn by the armor stand on its head.
   *
   * @return the worn item
   * @see #getEquipment()
   * @deprecated prefer {@link EntityEquipment#getHelmet()}
  */
  getHelmet(): ItemStack;
  /**
   * Sets the item currently being worn by the armor stand on its head.
   *
   * @param item the item to wear
   * @see #getEquipment()
   * @deprecated prefer
   * {@link EntityEquipment#setHelmet(org.bukkit.inventory.ItemStack)}
  */
  setHelmet(helmet: ItemStack | null);
  /**
   * Returns the armor stand's body's current pose as a
   * {@link org.bukkit.util.EulerAngle}.
   *
   * @return the current pose
  */
  getBodyPose(): EulerAngle;
  /**
   * Sets the armor stand's body's current pose as a
   * {@link org.bukkit.util.EulerAngle}.
   *
   * @param pose the current pose
  */
  setBodyPose(bodyPose: EulerAngle);
  /**
   * Returns the armor stand's left arm's current pose as a
   * {@link org.bukkit.util.EulerAngle}.
   *
   * @return the current pose
  */
  getLeftArmPose(): EulerAngle;
  /**
   * Sets the armor stand's left arm's current pose as a
   * {@link org.bukkit.util.EulerAngle}.
   *
   * @param pose the current pose
  */
  setLeftArmPose(leftArmPose: EulerAngle);
  /**
   * Returns the armor stand's right arm's current pose as a
   * {@link org.bukkit.util.EulerAngle}.
   *
   * @return the current pose
  */
  getRightArmPose(): EulerAngle;
  /**
   * Sets the armor stand's right arm's current pose as a
   * {@link org.bukkit.util.EulerAngle}.
   *
   * @param pose the current pose
  */
  setRightArmPose(rightArmPose: EulerAngle);
  /**
   * Returns the armor stand's left leg's current pose as a
   * {@link org.bukkit.util.EulerAngle}.
   *
   * @return the current pose
  */
  getLeftLegPose(): EulerAngle;
  /**
   * Sets the armor stand's left leg's current pose as a
   * {@link org.bukkit.util.EulerAngle}.
   *
   * @param pose the current pose
  */
  setLeftLegPose(leftLegPose: EulerAngle);
  /**
   * Returns the armor stand's right leg's current pose as a
   * {@link org.bukkit.util.EulerAngle}.
   *
   * @return the current pose
  */
  getRightLegPose(): EulerAngle;
  /**
   * Sets the armor stand's right leg's current pose as a
   * {@link org.bukkit.util.EulerAngle}.
   *
   * @param pose the current pose
  */
  setRightLegPose(rightLegPose: EulerAngle);
  /**
   * Returns the armor stand's head's current pose as a
   * {@link org.bukkit.util.EulerAngle}.
   *
   * @return the current pose
  */
  getHeadPose(): EulerAngle;
  /**
   * Sets the armor stand's head's current pose as a
   * {@link org.bukkit.util.EulerAngle}.
   *
   * @param pose the current pose
  */
  setHeadPose(headPose: EulerAngle);
  /**
   * Returns whether the armor stand has a base plate.
   *
   * @return whether it has a base plate
  */
  hasBasePlate(): boolean;
  /**
   * Sets whether the armor stand has a base plate.
   *
   * @param basePlate whether is has a base plate
  */
  setBasePlate(basePlate: boolean): void;
  /**
   * Returns whether the armor stand should be visible or not.
   *
   * @return whether the stand is visible or not
  */
  isVisible(): boolean;
  /**
   * Sets whether the armor stand should be visible or not.
   *
   * @param visible whether the stand is visible or not
  */
  setVisible(visible: boolean): void;
  /**
   * Returns whether this armor stand has arms.
   *
   * @return whether this has arms or not
  */
  hasArms(): boolean;
  /**
   * Sets whether this armor stand has arms.
   *
   * @param arms whether this has arms or not
  */
  setArms(arms: boolean): void;
  /**
   * Returns whether this armor stand is scaled down.
   *
   * @return whether this is scaled down
  */
  isSmall(): boolean;
  /**
   * Sets whether this armor stand is scaled down.
   *
   * @param small whether this is scaled down
  */
  setSmall(small: boolean): void;
  /**
   * Returns whether this armor stand is a marker, meaning it has a very small
   * collision box.
   *
   * @return whether this is a marker
  */
  isMarker(): boolean;
  /**
   * Sets whether this armor stand is a marker, meaning it has a very small
   * collision box.
   *
   * @param marker whether this is a marker
  */
  setMarker(marker: boolean): void;
  /**
   * Locks the equipment slot with the specified
   * {@link LockType locking mechanism}.
   *
   * @param slot the equipment slot to lock
   * @param lockType the LockType to lock the equipment slot with
  */
  addEquipmentLock(slot: EquipmentSlot, lockType: LockType): void;
  /**
   * Remove a {@link LockType locking mechanism}.
   *
   * @param slot the equipment slot to change
   * @param lockType the LockType to remove
  */
  removeEquipmentLock(slot: EquipmentSlot, lockType: LockType): void;
  /**
   * Returns if the ArmorStand has the specified
   * {@link LockType locking mechanism}.
   *
   * @param slot the EquipmentSlot to test
   * @param lockType the LockType to test
   * @return if the ArmorStand has been locked with the parameters specified
  */
  hasEquipmentLock(slot: EquipmentSlot, lockType: LockType): boolean;
  /**
   * Tests if this armor stand can move.
   *
   * The default value is `true`.
   *
   * @return `true` if this armour stand can move, `false` otherwise
  */
  canMove(): boolean;
  /**
   * Sets if this armor stand can move.
   *
   * @param move `true` if this armour stand can move, `false` otherwise
  */
  setCanMove(move: boolean): void;
  getEquipment(): EntityEquipment;
  /**
   * Tests if this armor stand can tick.
   *
   * The default value is defined in `paper.yml`.
   *
   * @return `true` if this armour stand can tick, `false` otherwise
  */
  canTick(): boolean;
  /**
   * Sets if this armor stand can tick.
   *
   * @param tick `true` if this armour stand can tick, `false` otherwise
  */
  setCanTick(tick: boolean): void;
  /**
   * Returns the item the armor stand has
   * equip in the given equipment slot
   *
   * @param slot the equipment slot to get
   * @return the ItemStack in the equipment slot
  */
  getItem(slot: EquipmentSlot): ItemStack;
  /**
   * Sets the item the armor stand has
   * equip in the given equipment slot
   *
   * @param slot the equipment slot to set
   * @param item the item to hold
  */
  setItem(slot: EquipmentSlot, item: ItemStack | null): void;
  /**
   * Get the list of disabled slots
   *
   * @return list of disabled slots
  */
  getDisabledSlots(): Set<EquipmentSlot>;
  /**
   * Set the disabled slots
   *
   * This makes it so a player is unable to interact with the Armor Stand to place, remove, or replace an item in the given slot(s)
   * Note: Once a slot is disabled, the only way to get an item back it to break the armor stand.
   *
   * @param slots var-arg array of slots to lock
  */
  setDisabledSlots(disabledSlots: EquipmentSlot[]);
  /**
   * Disable specific slots, adding them
   * to the currently disabled slots
   *
   * This makes it so a player is unable to interact with the Armor Stand to place, remove, or replace an item in the given slot(s)
   * Note: Once a slot is disabled, the only way to get an item back it to break the armor stand.
   *
   * @param slots var-arg array of slots to lock
  */
  addDisabledSlots(...slots: EquipmentSlot[]): void;
  /**
   * Remove the given slots from the disabled
   * slots list, enabling them.
   *
   * This makes it so a player is able to interact with the Armor Stand to place, remove, or replace an item in the given slot(s)
   *
   * @param slots var-arg array of slots to unlock
  */
  removeDisabledSlots(...slots: EquipmentSlot[]): void;
  /**
   * Check if a specific slot is disabled
   *
   * @param slot The slot to check
   * @return `true` if the slot is disabled, else `false`.
  */
  isSlotDisabled(slot: EquipmentSlot): boolean;
}
export class Raider extends Monster {
  /**
   * Gets the block the raider is targeting to patrol.
   *
   * @return target block or null
  */
  getPatrolTarget(): Block | null;
  /**
   * Sets the block the raider is targeting to patrol.
   *
   * @param block target block or null. Must be in same world as the entity
  */
  setPatrolTarget(patrolTarget: Block | null);
  /**
   * Gets whether this entity is a patrol leader.
   *
   * @return patrol leader status
  */
  isPatrolLeader(): boolean;
  /**
   * Sets whether this entity is a patrol leader.
   *
   * @param leader patrol leader status
  */
  setPatrolLeader(leader: boolean): void;
  /**
   * Gets whether this mob can join an active raid.
   *
   * @return CanJoinRaid status
  */
  isCanJoinRaid(): boolean;
  /**
   * Sets whether this mob can join an active raid.
   *
   * @param join CanJoinRaid status
  */
  setCanJoinRaid(join: boolean): void;
  /**
   * Returns whether the raider is celebrating a raid victory.
   *
   * @return whether the raider is celebrating a raid victory
  */
  isCelebrating(): boolean;
  /**
   * Sets whether the raider is celebrating a raid victory.
   *
   * @param celebrating whether the raider is celebrating a raid victory
  */
  setCelebrating(celebrating: boolean): void;
}
/**
 * This interface defines or represents the abstract concept of skeleton-like
 * entities on the server. The interface is hence not a direct representation
 * of an entity but rather serves as a parent to interfaces/entity types like
 * {@link Skeleton}, {@link WitherSkeleton} or {@link Stray}.
 *
 * To compute what specific type of skeleton is present in a variable/field
 * of this type, instanceOf checks against the specific subtypes listed prior
 * are recommended.
*/
export class AbstractSkeleton extends Monster {
  /**
   * Gets the current type of this skeleton.
   *
   * @return Current type
   * @deprecated should check what class instance this is.
  */
  getSkeletonType(): SkeletonType;
  /**
   * @param type type
   * @deprecated Must spawn a new subtype variant
  */
  setSkeletonType(skeletonType: SkeletonType);
  /**
   * Check if this skeleton will burn in the sunlight. This
   * does not take into account an entity's natural fire
   * immunity.
   *
   * @return True if skeleton will burn in sunlight
  */
  shouldBurnInDay(): boolean;
  /**
   * Set if this skeleton should burn in the sunlight. This
   * will not override an entity's natural fire
   * immunity.
   *
   * @param shouldBurnInDay True to burn in sunlight
  */
  setShouldBurnInDay(shouldBurnInDay: boolean): void;
}
export interface AbstractSkeleton extends Monster, RangedEntity {}
/**
 * Represents an area effect cloud which will imbue a potion effect onto
 * entities which enter it.
*/
export class AreaEffectCloud extends Entity {
  /**
   * Gets the duration which this cloud will exist for (in ticks).
   *
   * @return cloud duration
  */
  getDuration(): number;
  /**
   * Sets the duration which this cloud will exist for (in ticks).
   *
   * @param duration cloud duration
  */
  setDuration(duration: number);
  /**
   * Gets the time which an entity has to be exposed to the cloud before the
   * effect is applied.
   *
   * @return wait time
  */
  getWaitTime(): number;
  /**
   * Sets the time which an entity has to be exposed to the cloud before the
   * effect is applied.
   *
   * @param waitTime wait time
  */
  setWaitTime(waitTime: number);
  /**
   * Gets the time that an entity will be immune from subsequent exposure.
   *
   * @return reapplication delay
  */
  getReapplicationDelay(): number;
  /**
   * Sets the time that an entity will be immune from subsequent exposure.
   *
   * @param delay reapplication delay
  */
  setReapplicationDelay(reapplicationDelay: number);
  /**
   * Gets the amount that the duration of this cloud will decrease by when it
   * applies an effect to an entity.
   *
   * @return duration on use delta
  */
  getDurationOnUse(): number;
  /**
   * Sets the amount that the duration of this cloud will decrease by when it
   * applies an effect to an entity.
   *
   * @param duration duration on use delta
  */
  setDurationOnUse(durationOnUse: number);
  /**
   * Gets the initial radius of the cloud.
   *
   * @return radius
  */
  getRadius(): number;
  /**
   * Sets the initial radius of the cloud.
   *
   * @param radius radius
  */
  setRadius(radius: number);
  /**
   * Gets the amount that the radius of this cloud will decrease by when it
   * applies an effect to an entity.
   *
   * @return radius on use delta
  */
  getRadiusOnUse(): number;
  /**
   * Sets the amount that the radius of this cloud will decrease by when it
   * applies an effect to an entity.
   *
   * @param radius radius on use delta
  */
  setRadiusOnUse(radiusOnUse: number);
  /**
   * Gets the amount that the radius of this cloud will decrease by each tick.
   *
   * @return radius per tick delta
  */
  getRadiusPerTick(): number;
  /**
   * Gets the amount that the radius of this cloud will decrease by each tick.
   *
   * @param radius per tick delta
  */
  setRadiusPerTick(radiusPerTick: number);
  /**
   * Gets the particle which this cloud will be composed of
   *
   * @return particle the set particle type
  */
  getParticle(): Particle;
  /**
   * Sets the particle which this cloud will be composed of
   *
   * @param particle the new particle type
  */
  setParticle(particle: Particle);
  /**
   * Sets the particle which this cloud will be composed of
   *
   * @param  type of particle data (see {@link Particle#getDataType()}
   * @param particle the new particle type
   * @param data the data to use for the particle or null,
   *             the type of this depends on {@link Particle#getDataType()}
  */
  setParticle<T>(particle: Particle, data: T | null): void;
  /**
   * Sets the underlying potion data
   *
   * @param data PotionData to set the base potion state to
  */
  setBasePotionData(basePotionData: PotionData);
  /**
   * Returns the potion data about the base potion
   *
   * @return a PotionData object
  */
  getBasePotionData(): PotionData;
  /**
   * Checks for the presence of custom potion effects.
   *
   * @return true if custom potion effects are applied
  */
  hasCustomEffects(): boolean;
  /**
   * Gets an immutable list containing all custom potion effects applied to
   * this cloud.
   * 
   * Plugins should check that hasCustomEffects() returns true before calling
   * this method.
   *
   * @return the immutable list of custom potion effects
  */
  getCustomEffects(): PotionEffect[];
  /**
   * Adds a custom potion effect to this cloud.
   *
   * @param effect the potion effect to add
   * @param overwrite true if any existing effect of the same type should be
   * overwritten
   * @return true if the effect was added as a result of this call
  */
  addCustomEffect(effect: PotionEffect, overwrite: boolean): boolean;
  /**
   * Removes a custom potion effect from this cloud.
   *
   * @param type the potion effect type to remove
   * @return true if the an effect was removed as a result of this call
  */
  removeCustomEffect(type: PotionEffectType): boolean;
  /**
   * Checks for a specific custom potion effect type on this cloud.
   *
   * @param type the potion effect type to check for
   * @return true if the potion has this effect
  */
  hasCustomEffect(type: PotionEffectType | null): boolean;
  /**
   * Removes all custom potion effects from this cloud.
  */
  clearCustomEffects(): void;
  /**
   * Gets the color of this cloud. Will be applied as a tint to its particles.
   *
   * @return cloud color
  */
  getColor(): org_bukkit_Color;
  /**
   * Sets the color of this cloud. Will be applied as a tint to its particles.
   *
   * @param color cloud color
  */
  setColor(color: org_bukkit_Color);
  /**
   * Retrieve the original source of this cloud.
   *
   * @return the {@link ProjectileSource} that threw the LingeringPotion
  */
  getSource(): ProjectileSource | null;
  /**
   * Set the original source of this cloud.
   *
   * @param source the {@link ProjectileSource} that threw the LingeringPotion
  */
  setSource(source: ProjectileSource | null);
}
/**
 * Represents a Water Mob
*/
export class WaterMob extends Creature {

}
/**
 * Represents an entity that can age and breed.
*/
export class Breedable extends Ageable {
  /**
   * Lock the age of the animal, setting this will prevent the animal from
   * maturing or getting ready for mating.
   *
   * @param lock new lock
  */
  setAgeLock(lock: boolean): void;
  /**
   * Gets the current agelock.
   *
   * @return the current agelock
  */
  getAgeLock(): boolean;
  /**
   * Return the ability to breed of the animal.
   *
   * @return the ability to breed of the animal
  */
  canBreed(): boolean;
  /**
   * Set breedability of the animal, if the animal is a baby and set to
   * breed it will instantly grow up.
   *
   * @param breed breedability of the animal
  */
  setBreed(breed: boolean): void;
}
/**
 * Represents a Squid.
*/
export class Squid extends WaterMob {

}
export class Guardian extends Monster {
  /**
   * Sets whether the guardian laser should show or not.
   *
   * A target must be present. If no target is present the laser will not show
   * and the method will return false.
   *
   * @param activated whether the laser is active
   * @return true if the laser was activated otherwise false
   * @see #getTarget()
   * @see #setTarget(LivingEntity)
  */
  setLaser(activated: boolean): boolean;
  /**
   * Gets whether the guardian laser is active or not.
   *
   * @return true if the laser is active otherwise false
  */
  hasLaser(): boolean;
  /**
   * Check if the Guardian is an elder Guardian
   *
   * @return true if the Guardian is an Elder Guardian, false if not
   * @deprecated should check if instance of {@link ElderGuardian}.
  */
  isElder(): boolean;
  /**
   * @param shouldBeElder shouldBeElder
   * @deprecated Must spawn a new {@link ElderGuardian}.
  */
  setElder(shouldBeElder: boolean): void;
}
/**
 * Tropical fish.
*/
export class TropicalFish extends Fish {
  /**
   * Gets the color of the fish's pattern.
   *
   * @return pattern color
  */
  getPatternColor(): DyeColor;
  /**
   * Sets the color of the fish's pattern
   *
   * @param color pattern color
  */
  setPatternColor(patternColor: DyeColor);
  /**
   * Gets the color of the fish's body.
   *
   * @return pattern color
  */
  getBodyColor(): DyeColor;
  /**
   * Sets the color of the fish's body
   *
   * @param color body color
  */
  setBodyColor(bodyColor: DyeColor);
  /**
   * Gets the fish's pattern.
   *
   * @return pattern
  */
  getPattern(): Pattern;
  /**
   * Sets the fish's pattern
   *
   * @param pattern new pattern
  */
  setPattern(pattern: Pattern);
}
/**
 * Represents groups of entities with shared spawn behaviors and mob caps.
 *
 * @see Minecraft Wiki
*/
export class SpawnCategory extends Enum<SpawnCategory> {
  /**
   * Entities related to Monsters, eg: Witch, Zombie, Creeper, etc.
  */
  static readonly MONSTER: SpawnCategory;
  /**
   * Entities related to Animals, eg: Strider, Cow, Turtle, etc.
  */
  static readonly ANIMAL: SpawnCategory;
  /**
   * Entities related to Water Animals, eg: Squid or Dolphin.
  */
  static readonly WATER_ANIMAL: SpawnCategory;
  /**
   * Entities related to Water Ambient, eg: Cod, PufferFish, Tropical Fish,
   * Salmon, etc.
  */
  static readonly WATER_AMBIENT: SpawnCategory;
  /**
   * Entities related to Water Underground, eg: Glow Squid.
  */
  static readonly WATER_UNDERGROUND_CREATURE: SpawnCategory;
  /**
   * Entities related to Ambient, eg: Bat.
  */
  static readonly AMBIENT: SpawnCategory;
  /**
   * All the Axolotl are represented by this Category.
  */
  static readonly AXOLOTL: SpawnCategory;
  /**
   * Entities not related to a mob, eg: Player, ArmorStand, Boat, etc.
  */
  static readonly MISC: SpawnCategory;
  static valueOf(name: string): SpawnCategory;
  static values(): SpawnCategory[];
}
/**
 * Represents an Experience Orb.
*/
export class ExperienceOrb extends Entity {
  /**
   * Gets how much experience is contained within this orb
   *
   * @return Amount of experience
  */
  getExperience(): number;
  /**
   * Sets how much experience is contained within this orb
   *
   * @param value Amount of experience
  */
  setExperience(experience: number);
  /**
   * Check if this orb was spawned from a {@link ThrownExpBottle}
   *
   * @return if orb was spawned from a bottle
   * @deprecated Use getSpawnReason() == EXP_BOTTLE
  */
  isFromBottle(): boolean;
  /**
   * If this experience orb was triggered to be spawned by
   * an entity such as a player, due to events such as killing entity,
   * breaking blocks, smelting in a furnace, etc, this will return the UUID
   * of the entity that triggered this orb to drop.
   *
   * In the case of an entity being killed, this will be the killers UUID.
   *
   * @return UUID of the player that triggered this orb to drop, or null if unknown/no triggering entity
  */
  getTriggerEntityId(): UUID | null;
  /**
   * If this experience orb was spawned in relation to another
   * entity, such as a player or other living entity death, or breeding,
   * return the source entity UUID.
   *
   * In the case of breeding, this will be the new baby entities UUID.
   * In the case of an entity being killed, this will be the dead entities UUID.
   *
   * @return The UUID of the entity that sourced this experience orb
  */
  getSourceEntityId(): UUID | null;
  /**
   * Gets the reason that this experience orb was spawned. For any case that we
   * do not know, such as orbs spawned before this API was added, UNKNOWN is returned.
   * @return The reason for this orb being spawned.
  */
  getSpawnReason(): org_bukkit_entity_ExperienceOrb_SpawnReason;
}
/**
 * Represents an ender dragon part
*/
export class EnderDragonPart extends ComplexEntityPart {
  getParent(): EnderDragon;
}
export interface EnderDragonPart extends ComplexEntityPart, Damageable {}
/**
 * Represents a Piglin.
*/
export class Piglin extends PiglinAbstract {
  /**
   * Get whether the piglin is able to hunt hoglins.
   *
   * @return Whether the piglin is able to hunt hoglins
  */
  isAbleToHunt(): boolean;
  /**
   * Sets whether the piglin is able to hunt hoglins.
   *
   * @param flag Whether the piglin is able to hunt hoglins.
  */
  setIsAbleToHunt(flag: boolean): void;
  /**
   * Adds a material to the allowed list of materials to barter with.
   *
   * @param material The material to add
   *
   * @return true if the item has been added successfully, false otherwise
  */
  addBarterMaterial(material: Material): boolean;
  /**
   * Removes a material from the allowed list of materials to barter with.
   *
   * Note: It's not possible to override the default
   * bartering item gold_ingots as payment. To block gold_ingots see
   * {@link org.bukkit.event.entity.PiglinBarterEvent}.
   *
   * @param material The material to remove
   *
   * @return true if the item has been removed successfully, false otherwise
  */
  removeBarterMaterial(material: Material): boolean;
  /**
   * Adds a material the piglin will pickup and store in his inventory.
   *
   * @param material The material you want the piglin to be interested in
   *
   * @return true if the item has been added successfully, false otherwise
  */
  addMaterialOfInterest(material: Material): boolean;
  /**
   * Removes a material from the list of materials the piglin will pickup.
   *
   * Note: It's not possible to override the default list of
   * item the piglin will pickup. To cancel pickup see
   * {@link org.bukkit.event.entity.EntityPickupItemEvent}.
   *
   * @param material The material you want removed from the interest list
   * @return true if the item has been removed successfully, false otherwise
  */
  removeMaterialOfInterest(material: Material): boolean;
  /**
   * Returns a immutable set of materials the piglins will pickup.
   * 
   * Note: This set will not include the items that are set
   * by default. To interact with those items see
   * {@link org.bukkit.event.entity.EntityPickupItemEvent}.
   *
   * @return An immutable materials set
  */
  getInterestList(): Set<Material>;
  /**
   * Returns a immutable set of materials the piglins will barter with.
   *
   * Note: This set will not include the items that are set
   * by default. To interact with those items see
   * {@link org.bukkit.event.entity.PiglinBarterEvent}.
   *
   * @return An immutable materials set
  */
  getBarterList(): Set<Material>;
  /**
   * Causes the piglin to appear as if they are charging
   * a crossbow.
   * 
   * This works with any item currently held in the piglin's hand.
   *
   * @param chargingCrossbow is charging
  */
  setChargingCrossbow(chargingCrossbow: boolean): void;
  /**
   * Gets if the piglin is currently charging the
   * item in their hand.
   *
   * @return is charging
  */
  isChargingCrossbow(): boolean;
}
export interface Piglin extends PiglinAbstract, InventoryHolder, RangedEntity {}
/**
 * An Axolotl.
*/
export class Axolotl extends Animals {
  /**
   * Gets if this axolotl is playing dead.
   *
   * An axolotl may play dead when it is damaged underwater.
   *
   * @return playing dead status
  */
  isPlayingDead(): boolean;
  /**
   * Sets if this axolotl is playing dead.
   *
   * An axolotl may play dead when it is damaged underwater.
   *
   * @param playingDead playing dead status
  */
  setPlayingDead(playingDead: boolean): void;
  /**
   * Get the variant of this axolotl.
   *
   * @return axolotl variant
  */
  getVariant(): org_bukkit_entity_Axolotl_Variant;
  /**
   * Set the variant of this axolotl.
   *
   * @param variant axolotl variant
  */
  setVariant(variant: org_bukkit_entity_Axolotl_Variant);
}
export interface Axolotl extends Animals, Bucketable {}
/**
 * Represents a puffer fish.
*/
export class PufferFish extends Fish {
  /**
   * Returns the current puff state of this fish (i.e. how inflated it is).
   *
   * @return current puff state
  */
  getPuffState(): number;
  /**
   * Sets the current puff state of this fish (i.e. how inflated it is).
   *
   * @param state new puff state
  */
  setPuffState(puffState: number);
}
export class DragonFireball extends Fireball {

}
/**
 * Represents a {@link Zombie} which was once a {@link Villager}.
*/
export class ZombieVillager extends Zombie {
  /**
   * Sets the villager profession of this zombie.
  */
  setVillagerProfession(villagerProfession: Profession | null);
  /**
   * Returns the villager profession of this zombie.
   *
   * @return the profession or null
  */
  getVillagerProfession(): Profession | null;
  /**
   * Gets the current type of this villager.
   *
   * @return Current type.
  */
  getVillagerType(): Type;
  /**
   * Sets the new type of this villager.
   *
   * @param type New type.
  */
  setVillagerType(villagerType: Type);
  /**
   * Get if this entity is in the process of converting to a Villager as a
   * result of being cured.
   *
   * @return conversion status
  */
  isConverting(): boolean;
  /**
   * Gets the amount of ticks until this entity will be converted to a
   * Villager as a result of being cured.
   *
   * When this reaches 0, the entity will be converted.
   *
   * @return conversion time
   * @throws IllegalStateException if {@link #isConverting()} is false.
  */
  getConversionTime(): number;
  /**
   * Sets the amount of ticks until this entity will be converted to a
   * Villager as a result of being cured.
   *
   * When this reaches 0, the entity will be converted. A value of less than 0
   * will stop the current conversion process without converting the current
   * entity.
   *
   * @param time new conversion time
  */
  setConversionTime(conversionTime: number);
  /**
   * Gets the player who initiated the conversion.
   *
   * @return the player, or null if the player is unknown or the
   * entity isn't converting currently
  */
  getConversionPlayer(): OfflinePlayer | null;
  /**
   * Sets the player who initiated the conversion.
   * 
   * This has no effect if this entity isn't converting currently.
   *
   * @param conversionPlayer the player
  */
  setConversionPlayer(conversionPlayer: OfflinePlayer | null);
}
/**
 * Represents an entity which may be saddled, ridden and steered using an item.
*/
export class Steerable extends Animals {
  /**
   * Check if the pig has a saddle.
   *
   * @return if the pig has been saddled.
  */
  hasSaddle(): boolean;
  /**
   * Sets if the pig has a saddle or not
   *
   * @param saddled set if the pig has a saddle or not.
  */
  setSaddle(saddled: boolean): void;
  /**
   * Get the time in ticks this entity's movement is being increased.
   *
   * Movement speed is often increased as a result of using the
   * {@link #getSteerMaterial()}.
   *
   * @return the current boost ticks
  */
  getBoostTicks(): number;
  /**
   * Set the time in ticks this entity's movement will be increased.
   *
   * This will reset the current boost ticks to 0
   * ({@link #getCurrentBoostTicks()}).
   *
   * @param ticks the boost time
  */
  setBoostTicks(boostTicks: number);
  /**
   * Get the time in ticks this entity's movement has been increased as of the
   * most recent boost.
   *
   * Current boost ticks will never be {@literal >} {@link #getBoostTicks()}.
   *
   * @return the current boost ticks
  */
  getCurrentBoostTicks(): number;
  /**
   * Set the time in ticks this entity's movement has been increased relative
   * to the most recent boost.
   *
   * @param ticks the current boost ticks. Must be {@literal >=} 0 and {@literal <=}
   * {@link #getBoostTicks()}
  */
  setCurrentBoostTicks(currentBoostTicks: number);
  /**
   * Get the material used to steer this entity when ridden by a player.
   *
   * @return the lure material
  */
  getSteerMaterial(): Material;
}
export class Shulker extends Golem {
  /**
   * Gets the peek state of the shulker between 0.0 and 1.0.
   *
   * @return the peek state of the shulker between 0.0 and 1.0
  */
  getPeek(): number;
  /**
   * Sets the peek state of the shulker, should be in between 0.0 and 1.0.
   *
   * @param value peek state of the shulker, should be in between 0.0 and 1.0
   * @throws IllegalArgumentException thrown if the value exceeds the valid
   * range in between of 0.0 and 1.0
  */
  setPeek(peek: number);
  /**
   * Gets the face to which the shulker is attached.
   *
   * @return the face to which the shulker is attached
  */
  getAttachedFace(): BlockFace;
  /**
   * Sets the face to which the shulker is attached.
   *
   * @param face the face to attach the shulker to
  */
  setAttachedFace(attachedFace: BlockFace);
}
export interface Shulker extends Golem, Colorable {}
/**
 * Represents a Creeper
*/
export class Creeper extends Monster {
  /**
   * Checks if this Creeper is powered (Electrocuted)
   *
   * @return true if this creeper is powered
  */
  isPowered(): boolean;
  /**
   * Sets the Powered status of this Creeper
   *
   * @param value New Powered status
  */
  setPowered(value: boolean): void;
  /**
   * Set the maximum fuse ticks for this Creeper, where the maximum ticks
   * is the amount of time in which a creeper is allowed to be in the
   * primed state before exploding.
   *
   * @param ticks the new maximum fuse ticks
  */
  setMaxFuseTicks(maxFuseTicks: number);
  /**
   * Get the maximum fuse ticks for this Creeper, where the maximum ticks
   * is the amount of time in which a creeper is allowed to be in the
   * primed state before exploding.
   *
   * @return the maximum fuse ticks
  */
  getMaxFuseTicks(): number;
  /**
   * Set the fuse ticks for this Creeper, where the ticks is the amount of
   * time in which a creeper has been in the primed state.
   *
   * @param ticks the new fuse ticks
  */
  setFuseTicks(fuseTicks: number);
  /**
   * Get the maximum fuse ticks for this Creeper, where the ticks is the
   * amount of time in which a creeper has been in the primed state.
   *
   * @return the fuse ticks
  */
  getFuseTicks(): number;
  /**
   * Set the explosion radius in which this Creeper's explosion will affect.
   *
   * @param radius the new explosion radius
  */
  setExplosionRadius(explosionRadius: number);
  /**
   * Get the explosion radius in which this Creeper's explosion will affect.
   *
   * @return the explosion radius
  */
  getExplosionRadius(): number;
  /**
   * Makes this Creeper explode instantly.
   *
   * The resulting explosion can be cancelled by an
   * {@link org.bukkit.event.entity.ExplosionPrimeEvent} and obeys the mob
   * griefing gamerule.
  */
  explode(): void;
  /**
   * Ignites this Creeper, beginning its fuse.
   *
   * The amount of time the Creeper takes to explode will depend on what
   * {@link #setMaxFuseTicks} is set as.
   *
   * The resulting explosion can be cancelled by an
   * {@link org.bukkit.event.entity.ExplosionPrimeEvent} and obeys the mob
   * griefing gamerule.
  */
  ignite(): void;
  /**
   * Set whether creeper is ignited or not (armed to explode)
   *
   * @param ignited New ignited state
  */
  setIgnited(ignited: boolean): void;
  /**
   * Check if creeper is ignited or not (armed to explode)
   *
   * @return Ignited state
  */
  isIgnited(): boolean;
}
/**
 * Represents an Evoker "Illager".
*/
export class Evoker extends Spellcaster {
  /**
   * Gets the {@link Spell} the Evoker is currently using.
   *
   * @return the current spell
   * @deprecated future versions of Minecraft have additional spell casting
   * entities.
   *
  */
  getCurrentSpell(): org_bukkit_entity_Evoker_Spell;
  /**
   * Sets the {@link Spell} the Evoker is currently using.
   *
   * @param spell the spell the evoker should be using
   * @deprecated future versions of Minecraft have additional spell casting
   * entities.
  */
  setCurrentSpell(currentSpell: org_bukkit_entity_Evoker_Spell | null);
  /**
   * @return the sheep being targeted by the {@link Spell#WOLOLO wololo spell}, or `null` if none
  */
  getWololoTarget(): Sheep | null;
  /**
   * Set the sheep to be the target of the {@link Spell#WOLOLO wololo spell}, or `null` to clear.
   *
   * @param sheep new wololo target
  */
  setWololoTarget(wololoTarget: Sheep | null);
}
/**
 * Represents a sized fireball.
*/
export class SizedFireball extends Fireball {
  /**
   * Gets the display {@link ItemStack}.
   *
   * @return display ItemStack
  */
  getDisplayItem(): ItemStack;
  /**
   * Sets the display {@link ItemStack} for the fireball.
   *
   * @param item the ItemStack to display
  */
  setDisplayItem(displayItem: ItemStack);
}
/**
 * Represents a Pig Zombie.
*/
export class PigZombie extends Zombie {
  /**
   * Get the pig zombie's current anger level.
   *
   * @return The anger level.
  */
  getAnger(): number;
  /**
   * Set the pig zombie's current anger level.
   *
   * @param level The anger level. Higher levels of anger take longer to
   *     wear off.
  */
  setAnger(anger: number);
  /**
   * Shorthand; sets to either 0 or the default level.
   *
   * @param angry Whether the zombie should be angry.
  */
  setAngry(angry: boolean): void;
  /**
   * Shorthand; gets whether the zombie is angry.
   *
   * @return True if the zombie is angry, otherwise false.
  */
  isAngry(): boolean;
  /**
   * Not applicable to this entity
   *
   * @return false
  */
  isConverting(): boolean;
  /**
   * Not applicable to this entity
   *
   * @return UnsuppotedOperationException
  */
  getConversionTime(): number;
  /**
   * Not applicable to this entity
   *
   * @param time unused
  */
  setConversionTime(conversionTime: number);
}
/**
 * Represents a living entity, such as a monster or player
*/
export class LivingEntity extends Attributable {
  /**
   * Gets the height of the living entity's eyes above its Location.
   *
   * @return height of the living entity's eyes above its location
  */
  getEyeHeight(): number;
  /**
   * Gets the height of the living entity's eyes above its Location.
   *
   * @param ignorePose if set to true, the effects of pose changes, eg
   *     sneaking and gliding will be ignored
   * @return height of the living entity's eyes above its location
  */
  getEyeHeight(ignorePose: boolean): number;
  /**
   * Get a Location detailing the current eye position of the living entity.
   *
   * @return a location at the eyes of the living entity
  */
  getEyeLocation(): Location;
  /**
   * Gets all blocks along the living entity's line of sight.
   * 
   * This list contains all blocks from the living entity's eye position to
   * target inclusive. This method considers all blocks as 1x1x1 in size.
   *
   * @param transparent Set containing all transparent block Materials (set to
   *     null for only air)
   * @param maxDistance this is the maximum distance to scan (may be limited
   *     by server by at least 100 blocks, no less)
   * @return list containing all blocks along the living entity's line of
   *     sight
  */
  getLineOfSight(transparent: Set<Material> | null, maxDistance: number): Block[];
  /**
   * Gets the block that the living entity has targeted.
   * 
   * This method considers all blocks as 1x1x1 in size. To take exact block
   * collision shapes into account, see {@link #getTargetBlockExact(int,
   * FluidCollisionMode)}.
   *
   * @param transparent Set containing all transparent block Materials (set to
   *     null for only air)
   * @param maxDistance this is the maximum distance to scan (may be limited
   *     by server by at least 100 blocks, no less)
   * @return block that the living entity has targeted
  */
  getTargetBlock(transparent: Set<Material> | null, maxDistance: number): Block;
  /**
   * Gets the block that the living entity has targeted, ignoring fluids
   *
   * @param maxDistance this is the maximum distance to scan
   * @return block that the living entity has targeted,
   *     or null if no block is within maxDistance
  */
  getTargetBlock(maxDistance: number): Block | null;
  /**
   * Gets the block that the living entity has targeted
   *
   * @param maxDistance this is the maximum distance to scan
   * @param fluidMode whether to check fluids or not
   * @return block that the living entity has targeted,
   *     or null if no block is within maxDistance
  */
  getTargetBlock(maxDistance: number, fluidMode: FluidMode): Block | null;
  /**
   * Gets the blockface of that block that the living entity has targeted, ignoring fluids
   *
   * @param maxDistance this is the maximum distance to scan
   * @return blockface of the block that the living entity has targeted,
   *     or null if no block is targeted
  */
  getTargetBlockFace(maxDistance: number): BlockFace | null;
  /**
   * Gets the blockface of that block that the living entity has targeted
   *
   * @param maxDistance this is the maximum distance to scan
   * @param fluidMode whether to check fluids or not
   * @return blockface of the block that the living entity has targeted,
   *     or null if no block is targeted
  */
  getTargetBlockFace(maxDistance: number, fluidMode: FluidMode): BlockFace | null;
  /**
   * Gets information about the block the living entity has targeted, ignoring fluids
   *
   * @param maxDistance this is the maximum distance to scan
   * @return TargetBlockInfo about the block the living entity has targeted,
   *     or null if no block is targeted
  */
  getTargetBlockInfo(maxDistance: number): TargetBlockInfo | null;
  /**
   * Gets information about the block the living entity has targeted
   *
   * @param maxDistance this is the maximum distance to scan
   * @param fluidMode whether to check fluids or not
   * @return TargetBlockInfo about the block the living entity has targeted,
   *     or null if no block is targeted
  */
  getTargetBlockInfo(maxDistance: number, fluidMode: FluidMode): TargetBlockInfo | null;
  /**
   * Gets information about the entity being targeted
   *
   * @param maxDistance this is the maximum distance to scan
   * @return entity being targeted, or null if no entity is targeted
  */
  getTargetEntity(maxDistance: number): Entity | null;
  /**
   * Gets information about the entity being targeted
   *
   * @param maxDistance this is the maximum distance to scan
   * @param ignoreBlocks true to scan through blocks
   * @return entity being targeted, or null if no entity is targeted
  */
  getTargetEntity(maxDistance: number, ignoreBlocks: boolean): Entity | null;
  /**
   * Gets information about the entity being targeted
   *
   * @param maxDistance this is the maximum distance to scan
   * @return TargetEntityInfo about the entity being targeted,
   *     or null if no entity is targeted
  */
  getTargetEntityInfo(maxDistance: number): TargetEntityInfo | null;
  /**
   * Gets information about the entity being targeted
   *
   * @param maxDistance this is the maximum distance to scan
   * @param ignoreBlocks true to scan through blocks
   * @return TargetEntityInfo about the entity being targeted,
   *     or null if no entity is targeted
  */
  getTargetEntityInfo(maxDistance: number, ignoreBlocks: boolean): TargetEntityInfo | null;
  /**
   * Gets the last two blocks along the living entity's line of sight.
   * 
   * The target block will be the last block in the list. This method
   * considers all blocks as 1x1x1 in size.
   *
   * @param transparent Set containing all transparent block Materials (set to
   *     null for only air)
   * @param maxDistance this is the maximum distance to scan. This may be
   *     further limited by the server, but never to less than 100 blocks
   * @return list containing the last 2 blocks along the living entity's
   *     line of sight
  */
  getLastTwoTargetBlocks(transparent: Set<Material> | null, maxDistance: number): Block[];
  /**
   * Gets the block that the living entity has targeted.
   * 
   * This takes the blocks' precise collision shapes into account. Fluids are
   * ignored.
   * 
   * This may cause loading of chunks! Some implementations may impose
   * artificial restrictions on the maximum distance.
   *
   * @param maxDistance the maximum distance to scan
   * @return block that the living entity has targeted
   * @see #getTargetBlockExact(int, org.bukkit.FluidCollisionMode)
  */
  getTargetBlockExact(maxDistance: number): Block | null;
  /**
   * Gets the block that the living entity has targeted.
   * 
   * This takes the blocks' precise collision shapes into account.
   * 
   * This may cause loading of chunks! Some implementations may impose
   * artificial restrictions on the maximum distance.
   *
   * @param maxDistance the maximum distance to scan
   * @param fluidCollisionMode the fluid collision mode
   * @return block that the living entity has targeted
   * @see #rayTraceBlocks(double, FluidCollisionMode)
  */
  getTargetBlockExact(maxDistance: number, fluidCollisionMode: FluidCollisionMode): Block | null;
  /**
   * Performs a ray trace that provides information on the targeted block.
   * 
   * This takes the blocks' precise collision shapes into account. Fluids are
   * ignored.
   * 
   * This may cause loading of chunks! Some implementations may impose
   * artificial restrictions on the maximum distance.
   *
   * @param maxDistance the maximum distance to scan
   * @return information on the targeted block, or null if there
   *     is no targeted block in range
   * @see #rayTraceBlocks(double, FluidCollisionMode)
  */
  rayTraceBlocks(maxDistance: number): RayTraceResult | null;
  /**
   * Performs a ray trace that provides information on the targeted block.
   * 
   * This takes the blocks' precise collision shapes into account.
   * 
   * This may cause loading of chunks! Some implementations may impose
   * artificial restrictions on the maximum distance.
   *
   * @param maxDistance the maximum distance to scan
   * @param fluidCollisionMode the fluid collision mode
   * @return information on the targeted block, or null if there
   *     is no targeted block in range
   * @see World#rayTraceBlocks(Location, Vector, double, FluidCollisionMode)
  */
  rayTraceBlocks(maxDistance: number, fluidCollisionMode: FluidCollisionMode): RayTraceResult | null;
  /**
   * Returns the amount of air that the living entity has remaining, in
   * ticks.
   *
   * @return amount of air remaining
  */
  getRemainingAir(): number;
  /**
   * Sets the amount of air that the living entity has remaining, in ticks.
   *
   * @param ticks amount of air remaining
  */
  setRemainingAir(remainingAir: number);
  /**
   * Returns the maximum amount of air the living entity can have, in ticks.
   *
   * @return maximum amount of air
  */
  getMaximumAir(): number;
  /**
   * Sets the maximum amount of air the living entity can have, in ticks.
   *
   * @param ticks maximum amount of air
  */
  setMaximumAir(maximumAir: number);
  /**
   * Gets the time in ticks until the next arrow leaves the entity's body.
   *
   * @return ticks until arrow leaves
  */
  getArrowCooldown(): number;
  /**
   * Sets the time in ticks until the next arrow leaves the entity's body.
   *
   * @param ticks time until arrow leaves
  */
  setArrowCooldown(arrowCooldown: number);
  /**
   * Gets the amount of arrows in an entity's body.
   *
   * @return amount of arrows in body
  */
  getArrowsInBody(): number;
  /**
   * Set the amount of arrows in the entity's body.
   *
   * @param count amount of arrows in entity's body
  */
  setArrowsInBody(arrowsInBody: number);
  /**
   * Gets the time in ticks until the next bee stinger leaves the entity's body.
   *
   * @return ticks until bee stinger leaves
  */
  getBeeStingerCooldown(): number;
  /**
   * Sets the time in ticks until the next stinger leaves the entity's body.
   *
   * @param ticks time until bee stinger leaves
  */
  setBeeStingerCooldown(beeStingerCooldown: number);
  /**
   * Gets the amount of bee stingers in an entity's body.
   *
   * @return amount of bee stingers in body
  */
  getBeeStingersInBody(): number;
  /**
   * Set the amount of bee stingers in the entity's body.
   *
   * @param count amount of bee stingers in entity's body
  */
  setBeeStingersInBody(beeStingersInBody: number);
  /**
   * Returns the living entity's current maximum no damage ticks.
   * 
   * This is the maximum duration in which the living entity will not take
   * damage.
   *
   * @return maximum no damage ticks
  */
  getMaximumNoDamageTicks(): number;
  /**
   * Sets the living entity's current maximum no damage ticks.
   *
   * @param ticks maximum amount of no damage ticks
  */
  setMaximumNoDamageTicks(maximumNoDamageTicks: number);
  /**
   * Returns the living entity's last damage taken in the current no damage
   * ticks time.
   * 
   * Only damage higher than this amount will further damage the living
   * entity.
   *
   * @return damage taken since the last no damage ticks time period
  */
  getLastDamage(): number;
  /**
   * Sets the damage dealt within the current no damage ticks time period.
   *
   * @param damage amount of damage
  */
  setLastDamage(lastDamage: number);
  /**
   * Returns the living entity's current no damage ticks.
   *
   * @return amount of no damage ticks
  */
  getNoDamageTicks(): number;
  /**
   * Sets the living entity's current no damage ticks.
   *
   * @param ticks amount of no damage ticks
  */
  setNoDamageTicks(noDamageTicks: number);
  /**
   * Gets the player identified as the killer of the living entity.
   * 
   * May be null.
   *
   * @return killer player, or null if none found
  */
  getKiller(): Player | null;
  /**
   * Sets the player identified as the killer of the living entity.
   *
   * @param killer player
  */
  setKiller(killer: Player | null);
  /**
   * Adds the given {@link PotionEffect} to the living entity.
   *
   * @param effect PotionEffect to be added
   * @return whether the effect could be added
  */
  addPotionEffect(effect: PotionEffect): boolean;
  /**
   * Adds the given {@link PotionEffect} to the living entity.
   * 
   * Only one potion effect can be present for a given {@link
   * PotionEffectType}.
   *
   * @param effect PotionEffect to be added
   * @param force whether conflicting effects should be removed
   * @return whether the effect could be added
   * @deprecated no need to force since multiple effects of the same type are
   * now supported.
  */
  addPotionEffect(effect: PotionEffect, force: boolean): boolean;
  /**
   * Attempts to add all of the given {@link PotionEffect} to the living
   * entity.
   *
   * @param effects the effects to add
   * @return whether all of the effects could be added
  */
  addPotionEffects(effects: Collection<PotionEffect>): boolean;
  /**
   * Returns whether the living entity already has an existing effect of
   * the given {@link PotionEffectType} applied to it.
   *
   * @param type the potion type to check
   * @return whether the living entity has this potion effect active on them
  */
  hasPotionEffect(type: PotionEffectType): boolean;
  /**
   * Returns the active {@link PotionEffect} of the specified type.
   * 
   * If the effect is not present on the entity then null will be returned.
   *
   * @param type the potion type to check
   * @return the effect active on this entity, or null if not active.
  */
  getPotionEffect(type: PotionEffectType): PotionEffect | null;
  /**
   * Removes any effects present of the given {@link PotionEffectType}.
   *
   * @param type the potion type to remove
  */
  removePotionEffect(type: PotionEffectType): void;
  /**
   * Returns all currently active {@link PotionEffect}s on the living
   * entity.
   *
   * @return a collection of {@link PotionEffect}s
  */
  getActivePotionEffects(): Collection<PotionEffect>;
  /**
   * Checks whether the living entity has block line of sight to another.
   * 
   * This uses the same algorithm that hostile mobs use to find the closest
   * player.
   *
   * @param other the entity to determine line of sight to
   * @return true if there is a line of sight, false if not
  */
  hasLineOfSight(other: Entity): boolean;
  /**
   * Checks whether the living entity has block line of sight to the given block.
   * 
   * This uses the same algorithm that hostile mobs use to find the closest
   * player.
   *
   * @param location the location to determine line of sight to
   * @return true if there is a line of sight, false if not
  */
  hasLineOfSight(location: Location): boolean;
  /**
   * Returns if the living entity despawns when away from players or not.
   * 
   * By default, animals are not removed while other mobs are.
   *
   * @return true if the living entity is removed when away from players
  */
  getRemoveWhenFarAway(): boolean;
  /**
   * Sets whether or not the living entity despawns when away from players
   * or not.
   *
   * @param remove the removal status
  */
  setRemoveWhenFarAway(remove: boolean): void;
  /**
   * Gets the inventory with the equipment worn by the living entity.
   *
   * @return the living entity's inventory
  */
  getEquipment(): EntityEquipment | null;
  /**
   * Sets whether or not the living entity can pick up items.
   *
   * @param pickup whether or not the living entity can pick up items
  */
  setCanPickupItems(pickup: boolean): void;
  /**
   * Gets if the living entity can pick up items.
   *
   * @return whether or not the living entity can pick up items
  */
  getCanPickupItems(): boolean;
  /**
   * Returns whether the entity is currently leashed.
   *
   * @return whether the entity is leashed
  */
  isLeashed(): boolean;
  /**
   * Gets the entity that is currently leading this entity.
   *
   * @return the entity holding the leash
   * @throws IllegalStateException if not currently leashed
  */
  getLeashHolder(): Entity;
  /**
   * Sets the leash on this entity to be held by the supplied entity.
   * 
   * This method has no effect on EnderDragons, Withers, Players, or Bats.
   * Non-living entities excluding leashes will not persist as leash
   * holders.
   *
   * @param holder the entity to leash this entity to, or null to unleash
   * @return whether the operation was successful
  */
  setLeashHolder(leashHolder: Entity | null);
  /**
   * Checks to see if an entity is gliding, such as using an Elytra.
   * @return True if this entity is gliding.
  */
  isGliding(): boolean;
  /**
   * Makes entity start or stop gliding. This will work even if an Elytra
   * is not equipped, but will be reverted by the server immediately after
   * unless an event-cancelling mechanism is put in place.
   * @param gliding True if the entity is gliding.
  */
  setGliding(gliding: boolean): void;
  /**
   * Checks to see if an entity is swimming.
   *
   * @return True if this entity is swimming.
  */
  isSwimming(): boolean;
  /**
   * Makes entity start or stop swimming.
   *
   * This may have unexpected results if the entity is not in water.
   *
   * @param swimming True if the entity is swimming.
  */
  setSwimming(swimming: boolean): void;
  /**
   * Checks to see if an entity is currently using the Riptide enchantment.
   *
   * @return True if this entity is currently riptiding.
  */
  isRiptiding(): boolean;
  /**
   * Returns whether this entity is slumbering.
   *
   * @return slumber state
  */
  isSleeping(): boolean;
  /**
   * Gets if the entity is climbing.
   *
   * @return if the entity is climbing
  */
  isClimbing(): boolean;
  /**
   * Sets whether an entity will have AI.
   *
   * The entity will be completely unable to move if it has no AI.
   *
   * @param ai whether the mob will have AI or not.
  */
  setAI(ai: boolean): void;
  /**
   * Checks whether an entity has AI.
   *
   * The entity will be completely unable to move if it has no AI.
   *
   * @return true if the entity has AI, otherwise false.
  */
  hasAI(): boolean;
  /**
   * Makes this entity attack the given entity with a melee attack.
   *
   * Attack damage is calculated by the server from the attributes and
   * equipment of this mob, and knockback is applied to `target` as
   * appropriate.
   *
   * @param target entity to attack.
  */
  attack(target: Entity): void;
  /**
   * Makes this entity swing their main hand.
   *
   * This method does nothing if this entity does not have an animation for
   * swinging their main hand.
  */
  swingMainHand(): void;
  /**
   * Makes this entity swing their off hand.
   *
   * This method does nothing if this entity does not have an animation for
   * swinging their off hand.
  */
  swingOffHand(): void;
  /**
   * Set if this entity will be subject to collisions with other entities.
   * 
   * Exemptions to this rule can be managed with
   * {@link #getCollidableExemptions()}
   *
   * @param collidable collision status
  */
  setCollidable(collidable: boolean): void;
  /**
   * Gets if this entity is subject to collisions with other entities.
   * 
   * Some entities might be exempted from the collidable rule of this entity.
   * Use {@link #getCollidableExemptions()} to get these.
   * 
   * Please note that this method returns only the custom collidable state,
   * not whether the entity is non-collidable for other reasons such as being
   * dead.
   *
   * @return collision status
  */
  isCollidable(): boolean;
  /**
   * Gets a mutable set of UUIDs of the entities which are exempt from the
   * entity's collidable rule and which's collision with this entity will
   * behave the opposite of it.
   * 
   * This set can be modified to add or remove exemptions.
   * 
   * For example if collidable is true and an entity is in the exemptions set
   * then it will not collide with it. Similarly if collidable is false and an
   * entity is in this set then it will still collide with it.
   * 
   * Note these exemptions are not (currently) persistent.
   *
   * @return the collidable exemption set
  */
  getCollidableExemptions(): Set<UUID>;
  /**
   * Returns the value of the memory specified.
   * 
   * Note that the value is null when the specific entity does not have that
   * value by default.
   *
   * @param memoryKey memory to access
   * @param  the type of the return value
   * @return a instance of the memory section value or null if not present
  */
  getMemory<T>(memoryKey: MemoryKey<T>): T | null;
  /**
   * Sets the value of the memory specified.
   * 
   * Note that the value will not be persisted when the specific entity does
   * not have that value by default.
   *
   * @param memoryKey the memory to access
   * @param memoryValue a typed memory value
   * @param  the type of the passed value
  */
  setMemory<T>(memoryKey: MemoryKey<T>, memoryValue: T | null): void;
  /**
   * Get the category to which this entity belongs.
   *
   * Categories may subject this entity to additional effects, benefits or
   * debuffs.
   *
   * @return the entity category
  */
  getCategory(): EntityCategory;
  /**
   * Sets whether the entity is invisible or not.
   *
   * @param invisible If the entity is invisible
  */
  setInvisible(invisible: boolean): void;
  /**
   * Gets whether the entity is invisible or not.
   *
   * @return Whether the entity is invisible
  */
  isInvisible(): boolean;
  /**
   * Get the number of arrows stuck in this entity
   * @return Number of arrows stuck
  */
  getArrowsStuck(): number;
  /**
   * Set the number of arrows stuck in this entity
   *
   * @param arrows Number of arrows to stick in this entity
  */
  setArrowsStuck(arrowsStuck: number);
  /**
   * Get the delay (in ticks) before blocking is effective for this entity
   *
   * @return Delay in ticks
  */
  getShieldBlockingDelay(): number;
  /**
   * Set the delay (in ticks) before blocking is effective for this entity
   *
   * @param delay Delay in ticks
  */
  setShieldBlockingDelay(shieldBlockingDelay: number);
  /**
   * Get's the item being actively "used" or consumed.
   * @return The item. Will be null if no active item.
  */
  getActiveItem(): ItemStack | null;
  /**
   * Interrupts any ongoing active "usage" or consumption or an item.
  */
  clearActiveItem(): void;
  /**
   * Get's remaining time a player needs to keep hands raised with an item to finish using it.
   * @return Remaining ticks to use the item
  */
  getItemUseRemainingTime(): number;
  /**
   * Get how long the players hands have been raised (Charging Bow attack, using a potion, etc)
   *
   * @return Get how long the players hands have been raised (Charging Bow attack, using a potion, etc)
  */
  getHandRaisedTime(): number;
  /**
   * Whether or not this entity is using or charging an attack (Bow pulled back, drinking potion, eating food)
   *
   * @return Whether or not this entity is using or charging an attack (Bow pulled back, drinking potion, eating food)
  */
  isHandRaised(): boolean;
  /**
   * Gets the hand raised by this living entity. Will be either
   * {@link org.bukkit.inventory.EquipmentSlot#HAND} or
   * {@link org.bukkit.inventory.EquipmentSlot#OFF_HAND}.
   *
   * @return the hand raised
  */
  getHandRaised(): EquipmentSlot;
  /**
   * Get entity jump state.
   * 
   * Jump state will be true when the entity has been marked to jump.
   *
   * @return entity jump state.
  */
  isJumping(): boolean;
  /**
   * Set entity jump state
   * 
   * Setting to true will mark the entity to jump.
   * 
   * Setting to false will unmark the entity to jump but will not stop a jump already in-progress.
   *
   * @param jumping entity jump state
  */
  setJumping(jumping: boolean): void;
  /**
   * Plays pickup item animation towards this entity.
   * 
   * This will remove the item on the client.
   * 
   * Quantity is inferred to be that of the {@link Item}.
   *
   * @param item item to pickup
  */
  playPickupItemAnimation(item: Item): void;
  /**
   * Plays pickup item animation towards this entity.
   * 
   * This will remove the item on the client.
   *
   * @param item item to pickup
   * @param quantity quantity of item
  */
  playPickupItemAnimation(item: Item, quantity: number): void;
  /**
   * Gets player hurt direction
   *
   * @return hurt direction
  */
  getHurtDirection(): number;
  /**
   * Sets player hurt direction
   *
   * @param hurtDirection hurt direction
  */
  setHurtDirection(hurtDirection: number);
}
export interface LivingEntity extends Attributable, Damageable, ProjectileSource {}
/**
 * Represents an ambient mob
*/
export class Ambient extends Mob {

}
/**
 * Represents an instance of a lightning strike. May or may not do damage.
*/
export class LightningStrike extends Entity {
  /**
   * Returns whether the strike is an effect that does no damage.
   *
   * @return whether the strike is an effect
  */
  isEffect(): boolean;
  spigot(): org_bukkit_entity_LightningStrike_Spigot;
  /**
   * Returns the amount of flash iterations that will be done before the lightning dies.
   *
   * @see #getLifeTicks() for how long the current flash will last
   * @return amount of flashes that will be shown before the lightning dies
  */
  getFlashCount(): number;
  /**
   * Sets the amount of life iterations that will be done before the lightning dies.
   * Default number of flashes on creation is between 1-3.
   *
   * @param flashes amount of iterations that will be done before the lightning dies, must to be a positive number
  */
  setFlashCount(flashCount: number);
  /**
   * Returns the amount of ticks the current flash will do damage for.
   * Starts with 2 by default, will damage while it is equal to or above 0, with the next flash beginning somewhere between 0 and -9.
   *
   * @return ticks the current flash will do damage for
  */
  getLifeTicks(): number;
  /**
   * Sets the amount of ticks the current flash will do damage/fire for.
   * Default is 2 for each flash, on which the sound and effect will also be played.
   *
   * @param lifeTicks ticks the current flash will do damage for
  */
  setLifeTicks(lifeTicks: number);
  /**
   * Returns the potential entity that caused this lightning strike to spawn in the world.
   * 
   * As of implementing this method, only {@link Player}s are capable of causing a lightning strike, however as this
   * might change in future minecraft releases, this method does not guarantee a player as the cause of a lightning.
   * Consumers of this method should hence validate whether or not the entity is a player if they want to use player
   * specific methods through an `instanceOf` check.
   * 
   * 
   * A player is, as of implementing this method, responsible for a lightning, and will hence be returned here as
   * a cause, if they channeled a {@link Trident} to summon it or were explicitly defined as the cause of this
   * lightning through {@link #setCausingPlayer(Player)}.
   * 
   *
   * @return the entity that caused this lightning or null if the lightning was not caused by a entity (e.g. normal
   * weather)
  */
  getCausingEntity(): Entity | null;
  /**
   * Updates the player that caused this lightning to be summoned into the world.
   * By default, players that channel their {@link Trident} will be the cause of the respective lightning.
   * 
   * While the respective getter method {@link #getCausingEntity()} does not guarantee a player as the cause of a
   * lightning to stay as future proof as possible, as of implementing this method, players are the only entities
   * that can cause a lightning strike and hence this setter is restricted to players.
   * 
   *
   * @param causingPlayer the player that should be the new cause of this lightning. `null` may be passed to
   *                      indicate that no player is responsible for this lightning.
  */
  setCausingPlayer(causingPlayer: Player | null);
}
export class Dolphin extends WaterMob {
  /**
   * Gets the moistness level of this dolphin
  */
  getMoistness(): number;
  /**
   * Sets the moistness of this dolphin, once this is less than 0 the dolphin will start to take damage.
   *
   * @param moistness moistness level
  */
  setMoistness(moistness: number);
  /**
   * Sets if this dolphin was fed a fish.
   *
   * @param hasFish has a fish
  */
  setHasFish(hasFish: boolean): void;
  /**
   * Gets if this dolphin has a fish.
   *
   * @return has a fish
  */
  hasFish(): boolean;
  /**
   * Gets the treasure location this dolphin tries to guide players to.
   * 
   * This value is calculated if the player has fed the dolphin a fish, and it tries to start the {@link com.destroystokyo.paper.entity.ai.VanillaGoal#DOLPHIN_SWIM_TO_TREASURE} goal.
   *
   *  @return calculated closest treasure location
  */
  getTreasureLocation(): Location;
  /**
   * Sets the treasure location that this dolphin will try to lead the player to.
   * This only has an effect if the dolphin is currently leading a player, as this value is recalculated next time it leads a player.
   * 
   * The world of the location does not matter, as the dolphin will always use the world it is currently in.
   *
   *  @param location location to guide to
  */
  setTreasureLocation(treasureLocation: Location);
}
/**
 * Represents a trader Llama.
*/
export class TraderLlama extends Llama {

}
/**
 * Represents a Fireball.
*/
export class Fireball extends Projectile {
  /**
   * Fireballs fly straight and do not take setVelocity(...) well.
   *
   * @param direction the direction this fireball is flying toward
  */
  setDirection(direction: Vector);
  /**
   * Retrieve the direction this fireball is heading toward
   *
   * @return the direction
  */
  getDirection(): Vector;
}
export interface Fireball extends Projectile, Explosive {}
/**
 * Represents a Slime.
*/
export class Slime extends Mob {
  /**
   * @return The size of the slime
  */
  getSize(): number;
  /**
   * Setting the size of the slime (regardless of previous size)
   * will set the following attributes:
   * 
   *     {@link org.bukkit.attribute.Attribute#GENERIC_MAX_HEALTH}
   *     {@link org.bukkit.attribute.Attribute#GENERIC_MOVEMENT_SPEED}
   *     {@link org.bukkit.attribute.Attribute#GENERIC_ATTACK_DAMAGE}
   * 
   * to their per-size defaults and heal the
   * slime to its max health (assuming it's alive).
   *
   * @param sz The new size of the slime.
  */
  setSize(size: number);
  /**
   * Get whether this slime can randomly wander/jump around on its own
   *
   * @return true if can wander
  */
  canWander(): boolean;
  /**
   * Set whether this slime can randomly wander/jump around on its own
   *
   * @param canWander true if can wander
  */
  setWander(canWander: boolean): void;
}
/**
 * Represents an Animal.
*/
export class Animals extends Breedable {
  /**
   * Get the UUID of the entity that caused this entity to enter the
   * {@link #canBreed()} state.
   *
   * @return uuid if set, or null
  */
  getBreedCause(): UUID | null;
  /**
   * Set the UUID of the entity that caused this entity to enter the
   * {@link #canBreed()} state.
   *
   * @param uuid new uuid, or null
  */
  setBreedCause(breedCause: UUID | null);
  /**
   * Get whether or not this entity is in love mode and will produce
   * offspring with another entity in love mode. Will return true if
   * and only if {@link #getLoveModeTicks()} is greater than 0.
   *
   * @return true if in love mode, false otherwise
  */
  isLoveMode(): boolean;
  /**
   * Get the amount of ticks remaining for this entity in love mode.
   * If the entity is not in love mode, 0 will be returned.
   *
   * @return the remaining love mode ticks
  */
  getLoveModeTicks(): number;
  /**
   * Set the amount of ticks for which this entity should be in love mode.
   * Setting the love mode ticks to 600 is the equivalent of a player
   * feeding the entity their breeding item of choice.
   *
   * @param ticks the love mode ticks. Must be positive
  */
  setLoveModeTicks(loveModeTicks: number);
  /**
   * Check if the provided ItemStack is the correct item used for breeding
   * this entity.
   *
   * @param stack ItemStack to check.
   * @return if the provided ItemStack is the correct food item for this
   * entity.
  */
  isBreedItem(stack: ItemStack): boolean;
  /**
   * Check if the provided ItemStack is the correct item used for breeding
   * this entity..
   *
   * @param material Material to check.
   * @return if the provided ItemStack is the correct food item for this
   * entity.
  */
  isBreedItem(material: Material): boolean;
}
/**
 * Represents a Spider.
*/
export class CaveSpider extends Spider {

}
/**
 * A crystal that heals nearby EnderDragons
*/
export class EnderCrystal extends Entity {
  /**
   * Return whether or not this end crystal is showing the
   * bedrock slate underneath it.
   *
   * @return true if the bottom is being shown
  */
  isShowingBottom(): boolean;
  /**
   * Sets whether or not this end crystal is showing the
   * bedrock slate underneath it.
   *
   * @param showing whether the bedrock slate should be shown
  */
  setShowingBottom(showing: boolean): void;
  /**
   * Gets the location that this end crystal is pointing its beam to.
   *
   * @return the location that the beam is pointed to, or null if the beam is not shown
  */
  getBeamTarget(): Location | null;
  /**
   * Sets the location that this end crystal is pointing to. Passing a null
   * value will remove the current beam.
   *
   * @param location the location to point the beam to
   * @throws IllegalArgumentException for differing worlds
  */
  setBeamTarget(beamTarget: Location | null);
}
/**
 * Represents Horse-like creatures which can carry an inventory.
*/
export class ChestedHorse extends AbstractHorse {
  /**
   * Gets whether the horse has a chest equipped.
   *
   * @return true if the horse has chest storage
  */
  isCarryingChest(): boolean;
  /**
   * Sets whether the horse has a chest equipped. Removing a chest will also
   * clear the chest's inventory.
   *
   * @param chest true if the horse should have a chest
  */
  setCarryingChest(chest: boolean): void;
}
/**
 * Represents a thrown splash potion bottle
 *
 * @deprecated splash status depends on only on the potion item.
*/
export class SplashPotion extends ThrownPotion {

}
/**
 * Represents a Skeleton.
 * 
 * This interface only represents the normal skeleton type on the server.
 * Other skeleton-like entities, such as the {@link WitherSkeleton} or the
 * {@link Stray} are not related to this type.
*/
export class Skeleton extends AbstractSkeleton {
  /**
   * Computes whether or not this skeleton is currently in the process of
   * converting to a {@link Stray} due to it being frozen by powdered snow.
   *
   * @return whether or not the skeleton is converting to a stray.
  */
  isConverting(): boolean;
  /**
   * Gets the amount of ticks until this entity will be converted to a stray
   * as a result of being frozen by a powdered snow block.
   * 
   * When this reaches 0, the entity will be converted.
   *
   * @return the conversion time left represented in ticks.
   *
   * @throws IllegalStateException if {@link #isConverting()} is false.
  */
  getConversionTime(): number;
  /**
   * Sets the amount of ticks until this entity will be converted to a stray
   * as a result of being frozen by a powdered snow block.
   * 
   * When this reaches 0, the entity will be converted. A value of less than 0
   * will stop the current conversion process without converting the current
   * entity.
   *
   * @param time the new conversion time left before the conversion in ticks.
  */
  setConversionTime(conversionTime: number);
  /**
   * Gets the time the skeleton
   * has been inside powdered snow.
   *
   * @return time in ticks
  */
  inPowderedSnowTime(): number;
}
/**
 * Represents a Bat
*/
export class Bat extends Ambient {
  /**
   * Checks the current waking state of this bat.
   * 
   * This does not imply any persistence of state past the method call.
   *
   * @return true if the bat is awake or false if it is currently hanging
   *     from a block
  */
  isAwake(): boolean;
  /**
   * This method modifies the current waking state of this bat.
   * 
   * This does not prevent a bat from spontaneously awaking itself, or from
   * reattaching itself to a block.
   *
   * @param state the new state
  */
  setAwake(state: boolean): void;
}
/**
 * Illager beast.
*/
export class Ravager extends Raider {

}
export class Firework extends Projectile {
  /**
   * Get a copy of the fireworks meta
   *
   * @return A copy of the current Firework meta
  */
  getFireworkMeta(): FireworkMeta;
  /**
   * Apply the provided meta to the fireworks
   * 
   * Adjusts detonation ticks automatically.
   *
   * @param meta The FireworkMeta to apply
  */
  setFireworkMeta(fireworkMeta: FireworkMeta);
  /**
   * Cause this firework to explode at earliest opportunity, as if it has no
   * remaining fuse.
  */
  detonate(): void;
  /**
   * Gets if the firework was shot at an angle (i.e. from a crossbow).
   *
   * A firework which was not shot at an angle will fly straight upwards.
   *
   * @return shot at angle status
  */
  isShotAtAngle(): boolean;
  /**
   * Sets if the firework was shot at an angle (i.e. from a crossbow).
   *
   * A firework which was not shot at an angle will fly straight upwards.
   *
   * @param shotAtAngle the new shotAtAngle
  */
  setShotAtAngle(shotAtAngle: boolean): void;
  getSpawningEntity(): UUID | null;
  /**
   * If this firework is boosting an entity, return it
   * @return The entity being boosted
  */
  getBoostedEntity(): LivingEntity | null;
  /**
   * Gets the item used in the firework.
   *
   * @return firework item
  */
  getItem(): ItemStack;
  /**
   * Sets the item used in the firework.
   * 
   * Firework explosion effects are used from this item.
   *
   * @param itemStack item to set
  */
  setItem(item: ItemStack | null);
  /**
   * Gets the number of ticks the firework has flown.
   *
   * @return ticks flown
  */
  getTicksFlown(): number;
  /**
   * Sets the number of ticks the firework has flown.
   * Setting this greater than detonation ticks will cause the firework to explode.
   *
   * @param ticks ticks flown
  */
  setTicksFlown(ticksFlown: number);
  /**
   * Gets the number of ticks the firework will detonate on.
   *
   * @return the tick to detonate on
  */
  getTicksToDetonate(): number;
  /**
   * Set the amount of ticks the firework will detonate on.
   *
   * @param ticks ticks to detonate on
  */
  setTicksToDetonate(ticksToDetonate: number);
}
/**
 * A Marker entity, exists only on the server.
*/
export class Marker extends Entity {

}
/**
 * Represents a shootable entity.
*/
export class Projectile extends Entity {
  /**
   * Retrieve the shooter of this projectile.
   *
   * @return the {@link ProjectileSource} that shot this projectile
  */
  getShooter(): ProjectileSource | null;
  /**
   * Set the shooter of this projectile.
   *
   * @param source the {@link ProjectileSource} that shot this projectile
  */
  setShooter(shooter: ProjectileSource | null);
  /**
   * Determine if this projectile should bounce or not when it hits.
   * 
   * If a small fireball does not bounce it will set the target on fire.
   *
   * @return true if it should bounce.
   * @deprecated Does not do anything
  */
  doesBounce(): boolean;
  /**
   * Set whether or not this projectile should bounce or not when it hits
   * something.
   *
   * @param doesBounce whether or not it should bounce.
   * @deprecated Does not do anything
  */
  setBounce(doesBounce: boolean): void;
}
/**
 * Represents a Creature. Creatures are non-intelligent monsters or animals
 * which have very simple abilities.
*/
export class Creature extends Mob {

}
/**
 * A wild tameable cat
*/
export class Ocelot extends Animals {
  /**
   * Checks if this ocelot trusts players.
   *
   * @return true if it trusts players
  */
  isTrusting(): boolean;
  /**
   * Sets if this ocelot trusts players.
   *
   * @param trust true if it trusts players
  */
  setTrusting(trust: boolean): void;
  /**
   * Gets the current type of this cat.
   *
   * @return Type of the cat.
  */
  getCatType(): org_bukkit_entity_Ocelot_Type;
  /**
   * Sets the current type of this cat.
   *
   * @param type New type of this cat.
  */
  setCatType(catType: org_bukkit_entity_Ocelot_Type);
}
/**
 * Represents a snowman entity
*/
export class Snowman extends Golem {
  /**
   * Gets whether this snowman is in "derp mode", meaning it is not wearing a
   * pumpkin.
   *
   * @return True if the snowman is bald, false if it is wearing a pumpkin
  */
  isDerp(): boolean;
  /**
   * Sets whether this snowman is in "derp mode", meaning it is not wearing a
   * pumpkin. NOTE: This value is not persisted to disk and will therefore
   * reset when the chunk is reloaded.
   *
   * @param derpMode True to remove the pumpkin, false to add a pumpkin
  */
  setDerp(derpMode: boolean): void;
}
export interface Snowman extends Golem, RangedEntity {}
/**
 * Represents a Bee.
*/
export class Bee extends Animals {
  /**
   * Get the bee's hive location.
   *
   * @return hive location or null
  */
  getHive(): Location | null;
  /**
   * Set the bee's hive location.
   *
   * @param location or null
  */
  setHive(hive: Location | null);
  /**
   * Get the bee's flower location.
   *
   * @return flower location or null
  */
  getFlower(): Location | null;
  /**
   * Set the bee's flower location.
   *
   * @param location or null
  */
  setFlower(flower: Location | null);
  /**
   * Get if the bee has nectar.
   *
   * @return nectar
  */
  hasNectar(): boolean;
  /**
   * Set if the bee has nectar.
   *
   * @param nectar whether the entity has nectar
  */
  setHasNectar(nectar: boolean): void;
  /**
   * Get if the bee has stung.
   *
   * @return has stung
  */
  hasStung(): boolean;
  /**
   * Set if the bee has stung.
   *
   * @param stung has stung
  */
  setHasStung(stung: boolean): void;
  /**
   * Get the bee's anger level.
   *
   * @return anger level
  */
  getAnger(): number;
  /**
   * Set the bee's new anger level.
   *
   * @param anger new anger
  */
  setAnger(anger: number);
  /**
   * Get the amount of ticks the bee cannot enter the hive for.
   *
   * @return Ticks the bee cannot enter a hive for
  */
  getCannotEnterHiveTicks(): number;
  /**
   * Set the amount of ticks the bee cannot enter a hive for.
   *
   * @param ticks Ticks the bee cannot enter a hive for
  */
  setCannotEnterHiveTicks(cannotEnterHiveTicks: number);
  /**
   * Sets the override for if the bee is currently rolling.
   *
   * @param rolling is rolling, or unset for vanilla behavior
  */
  setRollingOverride(rollingOverride: TriState);
  /**
   * Gets the plugin set override for if the bee is currently rolling.
   *
   * @return plugin set rolling override
  */
  getRollingOverride(): TriState;
  /**
   * Gets if the bee is currently rolling.
   *
   * @return is rolling
  */
  isRolling(): boolean;
}
/**
 * Represents a complex living entity - one that is made up of various smaller
 * parts
*/
export class ComplexLivingEntity extends LivingEntity {
  /**
   * Gets a list of parts that belong to this complex entity
   *
   * @return List of parts
  */
  getParts(): Set<ComplexEntityPart>;
}
/**
 * Represents a Husk - variant of {@link Zombie}.
*/
export class Husk extends Zombie {
  /**
   * Get if this entity is in the process of converting to a Zombie as a
   * result of being underwater.
   *
   * @return conversion status
  */
  isConverting(): boolean;
  /**
   * Gets the amount of ticks until this entity will be converted to a Zombie
   * as a result of being underwater.
   *
   * When this reaches 0, the entity will be converted.
   *
   * @return conversion time
   * @throws IllegalStateException if {@link #isConverting()} is false.
  */
  getConversionTime(): number;
  /**
   * Sets the amount of ticks until this entity will be converted to a Zombie
   * as a result of being underwater.
   *
   * When this reaches 0, the entity will be converted. A value of less than 0
   * will stop the current conversion process without converting the current
   * entity.
   *
   * @param time new conversion time
  */
  setConversionTime(conversionTime: number);
}
/**
 * Represents a Primed TNT.
*/
export class TNTPrimed extends Explosive {
  /**
   * Set the number of ticks until the TNT blows up after being primed.
   *
   * @param fuseTicks The fuse ticks
  */
  setFuseTicks(fuseTicks: number);
  /**
   * Retrieve the number of ticks until the explosion of this TNTPrimed
   * entity
   *
   * @return the number of ticks until this TNTPrimed explodes
  */
  getFuseTicks(): number;
  /**
   * Gets the source of this primed TNT. The source is the entity
   * responsible for the creation of this primed TNT. (I.E. player ignites
   * TNT with flint and steel.) Take note that this can be null if there is
   * no suitable source. (created by the {@link
   * org.bukkit.World#spawn(Location, Class)} method, for example.)
   * 
   * The source will become null if the chunk this primed TNT is in is
   * unloaded then reloaded. The source entity may be invalid if for example
   * it has since died or been unloaded. Callers should check
   * {@link Entity#isValid()}.
   *
   * @return the source of this primed TNT
  */
  getSource(): Entity | null;
  /**
   * Sets the source of this primed TNT.
   *
   * The source is the entity responsible for the creation of this primed TNT.
   * 
   * Must be instance of {@link org.bukkit.entity.LivingEntity} otherwise will
   * be set to null. The parameter is typed {@link
   * org.bukkit.entity.Entity} to be consistent with {@link
   * org.bukkit.entity.TNTPrimed#getSource()} method.
   *
   * @param source the source of this primed TNT
  */
  setSource(source: Entity | null);
  /**
   * Gets the source block location of the TNTPrimed
   *
   * @return the source block location the TNTPrimed was spawned from
   * @deprecated replaced by {@link Entity#getOrigin()}
  */
  getSourceLoc(): Location;
}
/**
 * Represents a thrown Experience bottle.
*/
export class ThrownExpBottle extends ThrowableProjectile {

}

}
declare module 'org.bukkit.BanList' {
import { Enum } from 'java.lang';
/**
 * Represents a ban-type that a {@link BanList} may track.
*/
export class Type extends Enum<Type> {
  /**
   * Banned player names
  */
  static readonly NAME: Type;
  /**
   * Banned player IP addresses
  */
  static readonly IP: Type;
  static valueOf(name: string): Type;
  static values(): Type[];
}

}
declare module 'org.bukkit.entity.Villager' {
import { Enum } from 'java.lang';
import { NamespacedKey } from 'org.bukkit';
/**
 * Represents Villager type, usually corresponding to what biome they spawn
 * in.
*/
export class Type extends Enum<Type> {
  static readonly DESERT: Type;
  static readonly JUNGLE: Type;
  static readonly PLAINS: Type;
  static readonly SAVANNA: Type;
  static readonly SNOW: Type;
  static readonly SWAMP: Type;
  static readonly TAIGA: Type;
  static valueOf(name: string): Type;
  static values(): Type[];
  getKey(): NamespacedKey;
}
/**
 * Represents the various different Villager professions there may be.
 * Villagers have different trading options depending on their profession,
*/
export class Profession extends Enum<Profession> {
  static readonly NONE: Profession;
  /**
   * Armorer profession. Wears a black apron. Armorers primarily trade for
   * iron armor, chainmail armor, and sometimes diamond armor.
  */
  static readonly ARMORER: Profession;
  /**
   * Butcher profession. Wears a white apron. Butchers primarily trade for
   * raw and cooked food.
  */
  static readonly BUTCHER: Profession;
  /**
   * Cartographer profession. Wears a white robe. Cartographers primarily
   * trade for explorer maps and some paper.
  */
  static readonly CARTOGRAPHER: Profession;
  /**
   * Cleric profession. Wears a purple robe. Clerics primarily trade for
   * rotten flesh, gold ingot, redstone, lapis, ender pearl, glowstone,
   * and bottle o' enchanting.
  */
  static readonly CLERIC: Profession;
  /**
   * Farmer profession. Wears a brown robe. Farmers primarily trade for
   * food-related items.
  */
  static readonly FARMER: Profession;
  /**
   * Fisherman profession. Wears a brown robe. Fisherman primarily trade
   * for fish, as well as possibly selling string and/or coal.
  */
  static readonly FISHERMAN: Profession;
  /**
   * Fletcher profession. Wears a brown robe. Fletchers primarily trade
   * for string, bows, and arrows.
  */
  static readonly FLETCHER: Profession;
  /**
   * Leatherworker profession. Wears a white apron. Leatherworkers
   * primarily trade for leather, and leather armor, as well as saddles.
  */
  static readonly LEATHERWORKER: Profession;
  /**
   * Librarian profession. Wears a white robe. Librarians primarily trade
   * for paper, books, and enchanted books.
  */
  static readonly LIBRARIAN: Profession;
  /**
   * Mason profession.
  */
  static readonly MASON: Profession;
  /**
   * Nitwit profession. Wears a green apron, cannot trade. Nitwit
   * villagers do not do anything. They do not have any trades by default.
  */
  static readonly NITWIT: Profession;
  /**
   * Sheperd profession. Wears a brown robe. Shepherds primarily trade for
   * wool items, and shears.
  */
  static readonly SHEPHERD: Profession;
  /**
   * Toolsmith profession. Wears a black apron. Tool smiths primarily
   * trade for iron and diamond tools.
  */
  static readonly TOOLSMITH: Profession;
  /**
   * Weaponsmith profession. Wears a black apron. Weapon smiths primarily
   * trade for iron and diamond weapons, sometimes enchanted.
  */
  static readonly WEAPONSMITH: Profession;
  static valueOf(name: string): Profession;
  static values(): Profession[];
  getKey(): NamespacedKey;
  translationKey(): string;
}

}
declare module 'org.bukkit.event.player.PlayerKickEvent' {
import { Enum } from 'java.lang';
export class Cause extends Enum<Cause> {
  static readonly PLUGIN: Cause;
  static readonly WHITELIST: Cause;
  static readonly BANNED: Cause;
  static readonly IP_BANNED: Cause;
  static readonly KICK_COMMAND: Cause;
  static readonly FLYING_PLAYER: Cause;
  static readonly FLYING_VEHICLE: Cause;
  static readonly TIMEOUT: Cause;
  static readonly IDLING: Cause;
  static readonly INVALID_VEHICLE_MOVEMENT: Cause;
  static readonly INVALID_PLAYER_MOVEMENT: Cause;
  static readonly INVALID_ENTITY_ATTACKED: Cause;
  static readonly INVALID_PAYLOAD: Cause;
  static readonly SPAM: Cause;
  static readonly ILLEGAL_ACTION: Cause;
  static readonly ILLEGAL_CHARACTERS: Cause;
  static readonly SELF_INTERACTION: Cause;
  static readonly DUPLICATE_LOGIN: Cause;
  static readonly RESOURCE_PACK_REJECTION: Cause;
  /**
   * Spigot's restart command
  */
  static readonly RESTART_COMMAND: Cause;
  /**
   * Fallback cause
  */
  static readonly UNKNOWN: Cause;
  static valueOf(name: string): Cause;
  static values(): Cause[];
}

}
declare module 'org.bukkit.Vibration' {
export class Destination {

}

}
declare module 'org.bukkit.util.permissions' {
import { Map } from 'java.util';
import { PermissionDefault, Permission } from 'org.bukkit.permissions';
export class BroadcastPermissions {
  static registerPermissions(parent: Permission): Permission;
}
export class DefaultPermissions {
  static registerPermission(perm: Permission): Permission;
  static registerPermission(perm: Permission, withLegacy: boolean): Permission;
  static registerPermission(perm: Permission, parent: Permission): Permission;
  static registerPermission(name: string, desc: string | null): Permission;
  static registerPermission(name: string, desc: string | null, parent: Permission): Permission;
  static registerPermission(name: string, desc: string | null, def: PermissionDefault | null): Permission;
  static registerPermission(name: string, desc: string | null, def: PermissionDefault | null, parent: Permission): Permission;
  static registerPermission(name: string, desc: string | null, def: PermissionDefault | null, children: Map<string, boolean> | null): Permission;
  static registerPermission(name: string, desc: string | null, def: PermissionDefault | null, children: Map<string, boolean> | null, parent: Permission): Permission;
  static registerCorePermissions(): void;
}
export class CommandPermissions {
  static registerPermissions(parent: Permission): Permission;
}

}
declare module 'org.bukkit.scoreboard' {
import { Component } from 'net.kyori.adventure.text';
import { Enum } from 'java.lang';
import { Set, Collection } from 'java.util';
import { Option, OptionStatus } from 'org.bukkit.scoreboard.Team';
import { Index } from 'net.kyori.adventure.util';
import { NamedTextColor, TextColor } from 'net.kyori.adventure.text.format';
import { OfflinePlayer, ChatColor } from 'org.bukkit';
import { Entity } from 'org.bukkit.entity';
/**
 * Manager of Scoreboards
*/
export class ScoreboardManager {
  /**
   * Gets the primary Scoreboard controlled by the server.
   * 
   * This Scoreboard is saved by the server, is affected by the /scoreboard
   * command, and is the scoreboard shown by default to players.
   *
   * @return the default server scoreboard
  */
  getMainScoreboard(): Scoreboard;
  /**
   * Gets a new Scoreboard to be tracked by the server. This scoreboard will
   * be tracked as long as a reference is kept, either by a player or by a
   * plugin.
   *
   * @return the registered Scoreboard
   * @see WeakReference
  */
  getNewScoreboard(): Scoreboard;
}
/**
 * A team on a scoreboard that has a common display theme and other
 * properties. This team is only relevant to the display of the associated
 * {@link #getScoreboard() scoreboard}.
*/
export class Team {
  /**
   * Gets the name of this Team
   *
   * @return Objective name
   * @throws IllegalStateException if this team has been unregistered
  */
  getName(): string;
  /**
   * Gets the name displayed to entries for this team
   *
   * @return Team display name
   * @throws IllegalStateException if this team has been unregistered
  */
  displayName(): Component;
  /**
   * Sets the name displayed to entries for this team
   *
   * @param displayName New display name
   * @throws IllegalStateException if this team has been unregistered
  */
  displayName(displayName: Component | null): void;
  /**
   * Gets the prefix prepended to the display of entries on this team.
   *
   * @return Team prefix
   * @throws IllegalStateException if this team has been unregistered
  */
  prefix(): Component;
  /**
   * Sets the prefix prepended to the display of entries on this team.
   *
   * @param prefix New prefix
   * @throws IllegalArgumentException if prefix is null
   *     characters
   * @throws IllegalStateException if this team has been unregistered
  */
  prefix(prefix: Component | null): void;
  /**
   * Gets the suffix appended to the display of entries on this team.
   *
   * @return the team's current suffix
   * @throws IllegalStateException if this team has been unregistered
  */
  suffix(): Component;
  /**
   * Sets the suffix appended to the display of entries on this team.
   *
   * @param suffix the new suffix for this team.
   * @throws IllegalArgumentException if suffix is null
   *     characters
   * @throws IllegalStateException if this team has been unregistered
  */
  suffix(suffix: Component | null): void;
  /**
   * Checks if the team has a color specified
   *
   * @return true if it has a color
   * @throws IllegalStateException if this team has been unregistered
  */
  hasColor(): boolean;
  /**
   * Gets the color of the team.
   * 
   * This only sets the team outline, other occurrences of colors such as in
   * names are handled by prefixes / suffixes.
   *
   * @return team color
   * @throws IllegalStateException if this team has been unregistered
   * @throws IllegalStateException if the team doesn't have a color
   * @see #hasColor()
  */
  color(): TextColor;
  /**
   * Sets the color of the team.
   * 
   * This only sets the team outline, other occurrences of colors such as in
   * names are handled by prefixes / suffixes.
   *
   * @param color new color, null for no color
  */
  color(color: NamedTextColor | null): void;
  /**
   * Sets the name displayed to entries for this team
   *
   * @param displayName New display name
   * @throws IllegalArgumentException if displayName is longer than 128
   *     characters.
   * @throws IllegalStateException if this team has been unregistered
   * @deprecated in favour of {@link #displayName(net.kyori.adventure.text.Component)}
  */
  setDisplayName(displayName: string): void;
  /**
   * Sets the prefix prepended to the display of entries on this team.
   *
   * @param prefix New prefix
   * @throws IllegalArgumentException if prefix is null
   * @throws IllegalArgumentException if prefix is longer than 64
   *     characters
   * @throws IllegalStateException if this team has been unregistered
   * @deprecated in favour of {@link #prefix(net.kyori.adventure.text.Component)}
  */
  setPrefix(prefix: string): void;
  /**
   * Sets the suffix appended to the display of entries on this team.
   *
   * @param suffix the new suffix for this team.
   * @throws IllegalArgumentException if suffix is null
   * @throws IllegalArgumentException if suffix is longer than 64
   *     characters
   * @throws IllegalStateException if this team has been unregistered
   * @deprecated in favour of {@link #suffix(net.kyori.adventure.text.Component)}
  */
  setSuffix(suffix: string): void;
  /**
   * Sets the color of the team.
   * 
   * This only sets the team outline, other occurrences of colors such as in
   * names are handled by prefixes / suffixes.
   *
   * @param color new color, must be non-null. Use {@link ChatColor#RESET} for
   * no color
   * @deprecated in favour of {@link #color(net.kyori.adventure.text.format.NamedTextColor)}
  */
  setColor(color: ChatColor): void;
  /**
   * Gets the team friendly fire state
   *
   * @return true if friendly fire is enabled
   * @throws IllegalStateException if this team has been unregistered
  */
  allowFriendlyFire(): boolean;
  /**
   * Sets the team friendly fire state
   *
   * @param enabled true if friendly fire is to be allowed
   * @throws IllegalStateException if this team has been unregistered
  */
  setAllowFriendlyFire(enabled: boolean): void;
  /**
   * Gets the team's ability to see {@link PotionEffectType#INVISIBILITY
   * invisible} teammates.
   *
   * @return true if team members can see invisible members
   * @throws IllegalStateException if this team has been unregistered
  */
  canSeeFriendlyInvisibles(): boolean;
  /**
   * Sets the team's ability to see {@link PotionEffectType#INVISIBILITY
   * invisible} teammates.
   *
   * @param enabled true if invisible teammates are to be visible
   * @throws IllegalStateException if this team has been unregistered
  */
  setCanSeeFriendlyInvisibles(enabled: boolean): void;
  /**
   * Gets the team's ability to see name tags
   *
   * @return the current name tag visibility for the team
   * @throws IllegalArgumentException if this team has been unregistered
   * @deprecated see {@link #getOption(org.bukkit.scoreboard.Team.Option)}
  */
  getNameTagVisibility(): NameTagVisibility;
  /**
   * Set's the team's ability to see name tags
   *
   * @param visibility The nameTagVisibility to set
   * @throws IllegalArgumentException if this team has been unregistered
   * @deprecated see
   * {@link #setOption(org.bukkit.scoreboard.Team.Option, org.bukkit.scoreboard.Team.OptionStatus)}
  */
  setNameTagVisibility(nameTagVisibility: NameTagVisibility);
  /**
   * Gets the Set of players on the team
   *
   * @return players on the team
   * @throws IllegalStateException if this team has been unregistered
   * @see #getEntries()
   * @deprecated Teams can contain entries that aren't players
  */
  getPlayers(): Set<OfflinePlayer>;
  /**
   * Gets the Set of entries on the team
   *
   * @return entries on the team
   * @throws IllegalStateException if this entries has been unregistered\
  */
  getEntries(): Set<string>;
  /**
   * Gets the size of the team
   *
   * @return number of entries on the team
   * @throws IllegalStateException if this team has been unregistered
  */
  getSize(): number;
  /**
   * Gets the Scoreboard to which this team is attached
   *
   * @return Owning scoreboard, or null if this team has been {@link
   *     #unregister() unregistered}
  */
  getScoreboard(): Scoreboard | null;
  addPlayer(player: OfflinePlayer): void;
  /**
   * This puts the specified entry onto this team for the scoreboard.
   * 
   * This will remove the entry from any other team on the scoreboard.
   *
   * @param entry the entry to add
   * @throws IllegalArgumentException if entry is null
   * @throws IllegalStateException if this team has been unregistered
  */
  addEntry(entry: string): void;
  /**
   * This puts a collection of entities onto this team for the scoreboard which results in one
   * packet for the updates rather than a packet-per-entity.
   * 
   * Entities on other teams will be removed from their respective teams.
   *
   * @param entities the entities to add
   * @throws IllegalArgumentException if entities are null
   * @throws IllegalStateException if this team has been unregistered
  */
  addEntities(...entities: Entity[]): void;
  /**
   * This puts a collection of entities onto this team for the scoreboard which results in one
   * packet for the updates rather than a packet-per-entity.
   * 
   * Entities on other teams will be removed from their respective teams.
   *
   * @param entities the entities to add
   * @throws IllegalArgumentException if entities are null
   * @throws IllegalStateException if this team has been unregistered
  */
  addEntities(entities: Collection<Entity>): void;
  /**
   * This puts a collection of entries onto this team for the scoreboard which results in one
   * packet for the updates rather than a packet-per-entry.
   * 
   * Entries on other teams will be removed from their respective teams.
   *
   * @param entries the entries to add
   * @throws IllegalArgumentException if entries are null
   * @throws IllegalStateException if this team has been unregistered
  */
  addEntries(...entries: string[]): void;
  /**
   * This puts a collection of entries onto this team for the scoreboard which results in one
   * packet for the updates rather than a packet-per-entry.
   * 
   * Entries on other teams will be removed from their respective teams.
   *
   * @param entries the entries to add
   * @throws IllegalArgumentException if entries are null
   * @throws IllegalStateException if this team has been unregistered
  */
  addEntries(entries: Collection<string>): void;
  removePlayer(player: OfflinePlayer): boolean;
  /**
   * Removes the entry from this team.
   *
   * @param entry the entry to remove
   * @return if the entry was a part of this team
   * @throws IllegalArgumentException if entry is null
   * @throws IllegalStateException if this team has been unregistered
  */
  removeEntry(entry: string): boolean;
  /**
   * Removes a collection of entities from this team  which results in one
   * packet for the updates rather than a packet-per-entity.
   *
   * @param entities the entries to remove
   * @return if any of the entities were a part of this team
   * @throws IllegalArgumentException if entities is null
   * @throws IllegalStateException if this team has been unregistered
  */
  removeEntities(...entities: Entity[]): boolean;
  /**
   * Removes a collection of entities from this team  which results in one
   * packet for the updates rather than a packet-per-entity.
   *
   * @param entities the entries to remove
   * @return if any of the entities were a part of this team
   * @throws IllegalArgumentException if entities is null
   * @throws IllegalStateException if this team has been unregistered
  */
  removeEntities(entities: Collection<Entity>): boolean;
  /**
   * Removes a collection of entries from this team  which results in one
   * packet for the updates rather than a packet-per-entry.
   *
   * @param entries the entries to remove
   * @return if any of the entries were a part of this team
   * @throws IllegalArgumentException if entries is null
   * @throws IllegalStateException if this team has been unregistered
  */
  removeEntries(...entries: string[]): boolean;
  /**
   * Removes a collection of entries from this team  which results in one
   * packet for the updates rather than a packet-per-entry.
   *
   * @param entries the entries to remove
   * @return if any of the entries were a part of this team
   * @throws IllegalArgumentException if entries is null
   * @throws IllegalStateException if this team has been unregistered
  */
  removeEntries(entries: Collection<string>): boolean;
  /**
   * Unregisters this team from the Scoreboard
   *
   * @throws IllegalStateException if this team has been unregistered
  */
  unregister(): void;
  hasPlayer(player: OfflinePlayer): boolean;
  /**
   * Checks to see if the specified entry is a member of this team.
   *
   * @param entry the entry to search for
   * @return true if the entry is a member of this team
   * @throws IllegalArgumentException if entry is null
   * @throws IllegalStateException if this team has been unregistered
  */
  hasEntry(entry: string): boolean;
  /**
   * Get an option for this team
   *
   * @param option the option to get
   * @return the option status
   * @throws IllegalStateException if this team has been unregistered
  */
  getOption(option: Option): OptionStatus;
  /**
   * Set an option for this team
   *
   * @param option the option to set
   * @param status the new option status
   * @throws IllegalStateException if this team has been unregistered
  */
  setOption(option: Option, status: OptionStatus): void;
  /**
   * This puts the specified entity onto this team for the scoreboard.
   * 
   * This will remove the entity from any other team on the scoreboard.
   *
   * @param entity the entity to add
   * @throws IllegalArgumentException if entity is null
   * @throws IllegalStateException if this team has been unregistered
   * @see #addEntry(String)
  */
  addEntity(entity: Entity): void;
  /**
   * Removes the entity from this team.
   *
   * @param entity the entity to remove
   * @return if the entity was on this team
   * @throws IllegalArgumentException if entity is null
   * @throws IllegalStateException if this team has been unregistered
   * @see #removeEntry(String)
  */
  removeEntity(entity: Entity): boolean;
  /**
   * Checks to see if the specified entity is a member of this team.
   *
   * @param entity the entity to search for
   * @return true if the entity is a member of this team
   * @throws IllegalArgumentException if entity is null
   * @throws IllegalStateException if this team has been unregistered
   * @see #hasEntry(String)
  */
  hasEntity(entity: Entity): boolean;
}
/**
 * A scoreboard
*/
export class Scoreboard {
  /**
   * Registers an Objective on this Scoreboard
   *
   * @param name Name of the Objective
   * @param criteria Criteria for the Objective
   * @return The registered Objective
   * @throws IllegalArgumentException if name is null
   * @throws IllegalArgumentException if name is longer than 32767
   *     characters.
   * @throws IllegalArgumentException if criteria is null
   * @throws IllegalArgumentException if an objective by that name already
   *     exists
   * @deprecated a displayName should be explicitly specified
  */
  registerNewObjective(name: string, criteria: string): Objective;
  /**
   * Registers an Objective on this Scoreboard
   *
   * @param name Name of the Objective
   * @param criteria Criteria for the Objective
   * @param displayName Name displayed to players for the Objective.
   * @return The registered Objective
   * @throws IllegalArgumentException if name is null
   * @throws IllegalArgumentException if name is longer than 32767
   *     characters.
   * @throws IllegalArgumentException if criteria is null
   * @throws IllegalArgumentException if displayName is null
   * @throws IllegalArgumentException if displayName is longer than 128
   *     characters.
   * @throws IllegalArgumentException if an objective by that name already
   *     exists
  */
  registerNewObjective(name: string, criteria: string, displayName: Component | null): Objective;
  /**
   * Registers an Objective on this Scoreboard
   *
   * @param name Name of the Objective
   * @param criteria Criteria for the Objective
   * @param displayName Name displayed to players for the Objective.
   * @param renderType Manner of rendering the Objective
   * @return The registered Objective
   * @throws IllegalArgumentException if name is null
   * @throws IllegalArgumentException if name is longer than 32767
   *     characters.
   * @throws IllegalArgumentException if criteria is null
   * @throws IllegalArgumentException if displayName is null
   * @throws IllegalArgumentException if displayName is longer than 128
   *     characters.
   * @throws IllegalArgumentException if renderType is null
   * @throws IllegalArgumentException if an objective by that name already
   *     exists
  */
  registerNewObjective(name: string, criteria: string, displayName: Component | null, renderType: RenderType): Objective;
  /**
   * Registers an Objective on this Scoreboard
   *
   * @param name Name of the Objective
   * @param criteria Criteria for the Objective
   * @param displayName Name displayed to players for the Objective.
   * @return The registered Objective
   * @throws IllegalArgumentException if name is null
   * @throws IllegalArgumentException if name is longer than 32767
   *     characters.
   * @throws IllegalArgumentException if criteria is null
   * @throws IllegalArgumentException if displayName is null
   * @throws IllegalArgumentException if displayName is longer than 128
   *     characters.
   * @throws IllegalArgumentException if an objective by that name already
   *     exists
   * @deprecated in favour of {@link #registerNewObjective(String, String, net.kyori.adventure.text.Component)}
  */
  registerNewObjective(name: string, criteria: string, displayName: string): Objective;
  /**
   * Registers an Objective on this Scoreboard
   *
   * @param name Name of the Objective
   * @param criteria Criteria for the Objective
   * @param displayName Name displayed to players for the Objective.
   * @param renderType Manner of rendering the Objective
   * @return The registered Objective
   * @throws IllegalArgumentException if name is null
   * @throws IllegalArgumentException if name is longer than 32767
   *     characters.
   * @throws IllegalArgumentException if criteria is null
   * @throws IllegalArgumentException if displayName is null
   * @throws IllegalArgumentException if displayName is longer than 128
   *     characters.
   * @throws IllegalArgumentException if renderType is null
   * @throws IllegalArgumentException if an objective by that name already
   *     exists
   * @deprecated in favour of {@link #registerNewObjective(String, String, net.kyori.adventure.text.Component, RenderType)}
  */
  registerNewObjective(name: string, criteria: string, displayName: string, renderType: RenderType): Objective;
  /**
   * Gets an Objective on this Scoreboard by name
   *
   * @param name Name of the Objective
   * @return the Objective or null if it does not exist
   * @throws IllegalArgumentException if name is null
  */
  getObjective(name: string): Objective | null;
  /**
   * Gets all Objectives of a Criteria on the Scoreboard
   *
   * @param criteria Criteria to search by
   * @return an immutable set of Objectives using the specified Criteria
   * @throws IllegalArgumentException if criteria is null
  */
  getObjectivesByCriteria(criteria: string): Set<Objective>;
  /**
   * Gets all Objectives on this Scoreboard
   *
   * @return An immutable set of all Objectives on this Scoreboard
  */
  getObjectives(): Set<Objective>;
  /**
   * Gets the Objective currently displayed in a DisplaySlot on this
   * Scoreboard
   *
   * @param slot The DisplaySlot
   * @return the Objective currently displayed or null if nothing is
   *     displayed in that DisplaySlot
   * @throws IllegalArgumentException if slot is null
  */
  getObjective(slot: DisplaySlot): Objective | null;
  getScores(player: OfflinePlayer): Set<Score>;
  /**
   * Gets all scores for an entry on this Scoreboard
   *
   * @param entry the entry whose scores are being retrieved
   * @return immutable set of all scores tracked for the entry
   * @throws IllegalArgumentException if entry is null
  */
  getScores(entry: string): Set<Score>;
  resetScores(player: OfflinePlayer): void;
  /**
   * Removes all scores for an entry on this Scoreboard
   *
   * @param entry the entry to drop all current scores for
   * @throws IllegalArgumentException if entry is null
  */
  resetScores(entry: string): void;
  getPlayerTeam(player: OfflinePlayer): Team | null;
  /**
   * Gets a entries Team on this Scoreboard
   *
   * @param entry the entry to search for
   * @return the entries Team or null if the entry is not on a team
   * @throws IllegalArgumentException if entry is null
  */
  getEntryTeam(entry: string): Team | null;
  /**
   * Gets a Team by name on this Scoreboard
   *
   * @param teamName Team name
   * @return the matching Team or null if no matches
   * @throws IllegalArgumentException if teamName is null
  */
  getTeam(teamName: string): Team | null;
  /**
   * Gets all teams on this Scoreboard
   *
   * @return an immutable set of Teams
  */
  getTeams(): Set<Team>;
  /**
   * Registers a Team on this Scoreboard
   *
   * @param name Team name
   * @return registered Team
   * @throws IllegalArgumentException if name is null
   * @throws IllegalArgumentException if team by that name already exists
  */
  registerNewTeam(name: string): Team;
  /**
   * Gets all players tracked by this Scoreboard
   *
   * @return immutable set of all tracked players
   * @see #getEntries()
   * @deprecated Scoreboards can contain entries that aren't players
  */
  getPlayers(): Set<OfflinePlayer>;
  /**
   * Gets all entries tracked by this Scoreboard
   *
   * @return immutable set of all tracked entries
  */
  getEntries(): Set<string>;
  /**
   * Clears any objective in the specified slot.
   *
   * @param slot the slot to remove objectives
   * @throws IllegalArgumentException if slot is null
  */
  clearSlot(slot: DisplaySlot): void;
  /**
   * Gets all scores for a entity on this Scoreboard
   *
   * @param entity the entity whose scores are being retrieved
   * @return immutable set of all scores tracked for the entity
   * @throws IllegalArgumentException if entity is null
   * @see #getScores(String)
  */
  getScoresFor(entity: Entity): Set<Score>;
  /**
   * Removes all scores for a entity on this Scoreboard
   *
   * @param entity the entity to drop all current scores for
   * @throws IllegalArgumentException if entity is null
   * @see #resetScores(String)
  */
  resetScoresFor(entity: Entity): void;
  /**
   * Gets a entity's Team on this Scoreboard
   *
   * @param entity the entity to search for
   * @return the entity's Team or null if the entity is not on a team
   * @throws IllegalArgumentException if entity is null
   * @see #getEntryTeam(String)
  */
  getEntityTeam(entity: Entity): Team | null;
}
/**
 * An objective on a scoreboard that can show scores specific to entries. This
 * objective is only relevant to the display of the associated {@link
 * #getScoreboard() scoreboard}.
*/
export class Objective {
  /**
   * Gets the name of this Objective
   *
   * @return this objective's name
   * @throws IllegalStateException if this objective has been unregistered
  */
  getName(): string;
  /**
   * Gets the name displayed to players for this objective
   *
   * @return this objective's display name
   * @throws IllegalStateException if this objective has been unregistered
  */
  displayName(): Component;
  /**
   * Sets the name displayed to players for this objective.
   *
   * @param displayName Display name to set
   * @throws IllegalStateException if this objective has been unregistered
   * @throws IllegalArgumentException if displayName is null
   * @throws IllegalArgumentException if displayName is longer than 128
   *     characters.
  */
  displayName(displayName: Component | null): void;
  /**
   * Sets the name displayed to players for this objective.
   *
   * @param displayName Display name to set
   * @throws IllegalStateException if this objective has been unregistered
   * @throws IllegalArgumentException if displayName is null
   * @throws IllegalArgumentException if displayName is longer than 128
   *     characters.
   * @deprecated in favour of {@link #displayName(net.kyori.adventure.text.Component)}
  */
  setDisplayName(displayName: string): void;
  /**
   * Gets the criteria this objective tracks.
   *
   * @return this objective's criteria
   * @throws IllegalStateException if this objective has been unregistered
  */
  getCriteria(): string;
  /**
   * Gets if the objective's scores can be modified directly by a plugin.
   *
   * @return true if scores are modifiable
   * @throws IllegalStateException if this objective has been unregistered
   * @see Criterias#HEALTH
  */
  isModifiable(): boolean;
  /**
   * Gets the scoreboard to which this objective is attached.
   *
   * @return Owning scoreboard, or null if it has been {@link #unregister()
   *     unregistered}
  */
  getScoreboard(): Scoreboard | null;
  /**
   * Unregisters this objective from the {@link Scoreboard scoreboard.}
   *
   * @throws IllegalStateException if this objective has been unregistered
  */
  unregister(): void;
  /**
   * Sets this objective to display on the specified slot for the
   * scoreboard, removing it from any other display slot.
   *
   * @param slot display slot to change, or null to not display
   * @throws IllegalStateException if this objective has been unregistered
  */
  setDisplaySlot(displaySlot: DisplaySlot | null);
  /**
   * Gets the display slot this objective is displayed at.
   *
   * @return the display slot for this objective, or null if not displayed
   * @throws IllegalStateException if this objective has been unregistered
  */
  getDisplaySlot(): DisplaySlot | null;
  /**
   * Sets manner in which this objective will be rendered.
   *
   * @param renderType new render type
   * @throws IllegalStateException if this objective has been unregistered
  */
  setRenderType(renderType: RenderType);
  /**
   * Sets manner in which this objective will be rendered.
   *
   * @return the render type
   * @throws IllegalStateException if this objective has been unregistered
  */
  getRenderType(): RenderType;
  getScore(player: OfflinePlayer): Score;
  /**
   * Gets an entry's Score for an Objective on this Scoreboard.
   *
   * @param entry Entry for the Score
   * @return Score tracking the Objective and entry specified
   * @throws IllegalArgumentException if entry is null
   * @throws IllegalStateException if this objective has been unregistered
   * @throws IllegalArgumentException if entry is longer than 32767 characters.
  */
  getScore(entry: string): Score;
  /**
   * Gets an entity's Score for an Objective on this Scoreboard.
   *
   * @param entity Entity for the Score
   * @return Score tracking the Objective and entity specified
   * @throws IllegalArgumentException if entity is null
   * @throws IllegalStateException if this objective has been unregistered
  */
  getScoreFor(entity: Entity): Score;
}
/**
 * @deprecated replaced by {@link Team.OptionStatus}
*/
export class NameTagVisibility extends Enum<NameTagVisibility> {
  /**
   * Always show the player's nametag.
  */
  static readonly ALWAYS: NameTagVisibility;
  /**
   * Never show the player's nametag.
  */
  static readonly NEVER: NameTagVisibility;
  /**
   * Show the player's nametag only to his own team members.
  */
  static readonly HIDE_FOR_OTHER_TEAMS: NameTagVisibility;
  /**
   * Show the player's nametag only to members of other teams.
  */
  static readonly HIDE_FOR_OWN_TEAM: NameTagVisibility;
  static valueOf(name: string): NameTagVisibility;
  static values(): NameTagVisibility[];
}
/**
 * Controls the way in which an {@link Objective} is rendered client side.
*/
export class RenderType extends Enum<RenderType> {
  /**
   * Display integer value.
  */
  static readonly INTEGER: RenderType;
  /**
   * Display number of hearts corresponding to value.
  */
  static readonly HEARTS: RenderType;
  static valueOf(name: string): RenderType;
  static values(): RenderType[];
}
/**
 * Criteria names which trigger an objective to be modified by actions in-game
*/
export class Criterias {
  static readonly HEALTH: string;
  static readonly PLAYER_KILLS: string;
  static readonly TOTAL_KILLS: string;
  static readonly DEATHS: string;
}
/**
 * Locations for displaying objectives to the player
*/
export class DisplaySlot extends Enum<DisplaySlot> {
  static readonly BELOW_NAME: DisplaySlot;
  static readonly PLAYER_LIST: DisplaySlot;
  static readonly SIDEBAR: DisplaySlot;
  static readonly SIDEBAR_TEAM_BLACK: DisplaySlot;
  static readonly SIDEBAR_TEAM_DARK_BLUE: DisplaySlot;
  static readonly SIDEBAR_TEAM_DARK_GREEN: DisplaySlot;
  static readonly SIDEBAR_TEAM_DARK_AQUA: DisplaySlot;
  static readonly SIDEBAR_TEAM_DARK_RED: DisplaySlot;
  static readonly SIDEBAR_TEAM_DARK_PURPLE: DisplaySlot;
  static readonly SIDEBAR_TEAM_GOLD: DisplaySlot;
  static readonly SIDEBAR_TEAM_GRAY: DisplaySlot;
  static readonly SIDEBAR_TEAM_DARK_GRAY: DisplaySlot;
  static readonly SIDEBAR_TEAM_BLUE: DisplaySlot;
  static readonly SIDEBAR_TEAM_GREEN: DisplaySlot;
  static readonly SIDEBAR_TEAM_AQUA: DisplaySlot;
  static readonly SIDEBAR_TEAM_RED: DisplaySlot;
  static readonly SIDEBAR_TEAM_LIGHT_PURPLE: DisplaySlot;
  static readonly SIDEBAR_TEAM_YELLOW: DisplaySlot;
  static readonly SIDEBAR_TEAM_WHITE: DisplaySlot;
  static valueOf(name: string): DisplaySlot;
  static values(): DisplaySlot[];
  static readonly NAMES: Index<string, DisplaySlot>;
  /**
   * Get the string id of this display slot.
   *
   * @return the string id
  */
  getId(): string;
  toString(): string;
}
/**
 * A score entry for an {@link #getEntry() entry} on an {@link
 * #getObjective() objective}. Changing this will not affect any other
 * objective or scoreboard.
*/
export class Score {
  /**
   * Gets the OfflinePlayer being tracked by this Score
   *
   * @return this Score's tracked player
   * @see #getEntry()
   * @deprecated Scoreboards can contain entries that aren't players
  */
  getPlayer(): OfflinePlayer;
  /**
   * Gets the entry being tracked by this Score
   *
   * @return this Score's tracked entry
  */
  getEntry(): string;
  /**
   * Gets the Objective being tracked by this Score
   *
   * @return this Score's tracked objective
  */
  getObjective(): Objective;
  /**
   * Gets the current score
   *
   * @return the current score
   * @throws IllegalStateException if the associated objective has been
   *     unregistered
  */
  getScore(): number;
  /**
   * Sets the current score.
   *
   * @param score New score
   * @throws IllegalStateException if the associated objective has been
   *     unregistered
  */
  setScore(score: number);
  /**
   * Shows if this score has been set at any point in time.
   *
   * @return if this score has been set before
   * @throws IllegalStateException if the associated objective has been
   *     unregistered
  */
  isScoreSet(): boolean;
  /**
   * Gets the scoreboard for the associated objective.
   *
   * @return the owning objective's scoreboard, or null if it has been
   *     {@link Objective#unregister() unregistered}
  */
  getScoreboard(): Scoreboard | null;
  /**
   * Resets this score, if a value has been set.
   *
   * @throws IllegalStateException if the associated objective has been
   *     unregistered
  */
  resetScore(): void;
}

}
declare module 'org.bukkit.block.data.Rail' {
import { Enum } from 'java.lang';
/**
 * The different types of shapes a rail block can occupy.
*/
export class Shape extends Enum<Shape> {
  /**
   * The rail runs flat along the north/south (Z) axis.
  */
  static readonly NORTH_SOUTH: Shape;
  /**
   * The rail runs flat along the east/west (X) axis.
  */
  static readonly EAST_WEST: Shape;
  /**
   * The rail ascends in the east (positive X) direction.
  */
  static readonly ASCENDING_EAST: Shape;
  /**
   * The rail ascends in the west (negative X) direction.
  */
  static readonly ASCENDING_WEST: Shape;
  /**
   * The rail ascends in the north (negative Z) direction.
  */
  static readonly ASCENDING_NORTH: Shape;
  /**
   * The rail ascends in the south (positive Z) direction.
  */
  static readonly ASCENDING_SOUTH: Shape;
  /**
   * The rail forms a curve connecting the south and east faces of the
   * block.
  */
  static readonly SOUTH_EAST: Shape;
  /**
   * The rail forms a curve connecting the south and west faces of the
   * block.
  */
  static readonly SOUTH_WEST: Shape;
  /**
   * The rail forms a curve connecting the north and west faces of the
   * block.
  */
  static readonly NORTH_WEST: Shape;
  /**
   * The rail forms a curve connecting the north and east faces of the
   * block.
  */
  static readonly NORTH_EAST: Shape;
  static valueOf(name: string): Shape;
  static values(): Shape[];
}

}
declare module 'org.bukkit.help' {
import { Class } from 'java.lang';
import { TopicNameComparator } from 'org.bukkit.help.HelpTopicComparator';
import { Collection, List, Comparator } from 'java.util';
import { Command, CommandSender } from 'org.bukkit.command';
/**
 * A HelpTopicFactory is used to create custom {@link HelpTopic} objects from
 * commands that inherit from a common base class or have executors that
 * inherit from a common base class. You can use a custom HelpTopic to change
 * the way all the commands in your plugin display in the help. If your plugin
 * implements a complex permissions system, a custom help topic may also be
 * appropriate.
 * 
 * To automatically bind your plugin's commands to your custom HelpTopic
 * implementation, first make sure all your commands or executors derive from
 * a custom base class (it doesn't have to do anything). Next implement a
 * custom HelpTopicFactory that accepts your custom command base class and
 * instantiates an instance of your custom HelpTopic from it. Finally,
 * register your HelpTopicFactory against your command base class using the
 * {@link HelpMap#registerHelpTopicFactory(Class, HelpTopicFactory)} method.
 * 
 * As the help system iterates over all registered commands to make help
 * topics, it first checks to see if there is a HelpTopicFactory registered
 * for the command's base class. If so, the factory is used to make a help
 * topic rather than a generic help topic. If no factory is found for the
 * command's base class and the command derives from {@link
 * org.bukkit.command.PluginCommand}, then the type of the command's executor
 * is inspected looking for a registered HelpTopicFactory. Finally, if no
 * factory is found, a generic help topic is created for the command.
 *
 * @param  The base class for your custom commands.
*/
export class HelpTopicFactory<TCommand> {
  /**
   * This method accepts a command deriving from a custom command base class
   * and constructs a custom HelpTopic for it.
   *
   * @param command The custom command to build a help topic for.
   * @return A new custom help topic or `null` to intentionally NOT
   *     create a topic.
  */
  createTopic(command: TCommand): HelpTopic | null;
}
/**
 * Lacking an alternative, the help system will create instances of
 * GenericCommandHelpTopic for each command in the server's CommandMap. You
 * can use this class as a base class for custom help topics, or as an example
 * for how to write your own.
*/
export class GenericCommandHelpTopic extends HelpTopic {
  constructor(command: Command);
  canSee(sender: CommandSender): boolean;
}
/**
 * This help topic generates a list of other help topics. This class is useful
 * for adding your own index help topics. To enforce a particular order, use a
 * sorted collection.
 * 
 * If a preamble is provided to the constructor, that text will be displayed
 * before the first item in the index.
*/
export class IndexHelpTopic extends HelpTopic {
  constructor(name: string, shortText: string | null, permission: string | null, topics: Collection<HelpTopic>);
  constructor(name: string, shortText: string | null, permission: string | null, topics: Collection<HelpTopic>, preamble: string | null);
  canSee(sender: CommandSender): boolean;
  amendCanSee(amendedPermission: string | null): void;
  getFullText(sender: CommandSender): string;
}
/**
 * HelpTopic implementations are displayed to the user when the user uses the
 * /help command.
 * 
 * Custom implementations of this class can work at two levels. A simple
 * implementation only needs to set the value of `name`, ` * shortText`, and `fullText` in the constructor. This base class will
 * take care of the rest.
 * 
 * Complex implementations can be created by overriding the behavior of all
 * the methods in this class.
*/
export class HelpTopic {
  /**
   * Determines if a {@link Player} is allowed to see this help topic.
   * 
   * HelpTopic implementations should take server administrator wishes into
   * account as set by the {@link HelpTopic#amendCanSee(String)} function.
   *
   * @param player The Player in question.
   * @return True of the Player can see this help topic, false otherwise.
  */
  canSee(player: CommandSender): boolean;
  /**
   * Allows the server administrator to override the permission required to
   * see a help topic.
   * 
   * HelpTopic implementations should take this into account when
   * determining topic visibility on the {@link
   * HelpTopic#canSee(org.bukkit.command.CommandSender)} function.
   *
   * @param amendedPermission The permission node the server administrator
   *     wishes to apply to this topic.
  */
  amendCanSee(amendedPermission: string | null): void;
  /**
   * Returns the name of this help topic.
   *
   * @return The topic name.
  */
  getName(): string;
  /**
   * Returns a brief description that will be displayed in the topic index.
   *
   * @return A brief topic description.
  */
  getShortText(): string;
  /**
   * Returns the full description of this help topic that is displayed when
   * the user requests this topic's details.
   * 
   * The result will be paginated to properly fit the user's client.
   *
   * @param forWho The player or console requesting the full text. Useful
   *     for further security trimming the command's full text based on
   *     sub-permissions in custom implementations.
   *
   * @return A full topic description.
  */
  getFullText(forWho: CommandSender): string;
  /**
   * Allows the server admin (or another plugin) to add or replace the
   * contents of a help topic.
   * 
   * A null in either parameter will leave that part of the topic unchanged.
   * In either amending parameter, the string {@literal } is replaced
   * with the existing contents in the help topic. Use this to append or
   * prepend additional content into an automatically generated help topic.
   *
   * @param amendedShortText The new topic short text to use, or null to
   *     leave alone.
   * @param amendedFullText The new topic full text to use, or null to leave
   *     alone.
  */
  amendTopic(amendedShortText: string | null, amendedFullText: string | null): void;
}
/**
 * Used to impose a custom total ordering on help topics.
 * 
 * All topics are listed in alphabetic order, but topics that start with a
 * slash come after topics that don't.
*/
export class HelpTopicComparator extends Comparator<HelpTopic> {
  static topicNameComparatorInstance(): TopicNameComparator;
  static helpTopicComparatorInstance(): HelpTopicComparator;
  compare(lhs: HelpTopic, rhs: HelpTopic): number;
}
/**
 * The HelpMap tracks all help topics registered in a Bukkit server. When the
 * server starts up or is reloaded, help is processed and topics are added in
 * the following order:
 *
 * 
 * General topics are loaded from the help.yml
 * Plugins load and optionally call `addTopic()`
 * Registered plugin commands are processed by {@link HelpTopicFactory}
 *     objects to create topics
 * Topic contents are amended as directed in help.yml
 * 
*/
export class HelpMap {
  /**
   * Returns a help topic for a given topic name.
   *
   * @param topicName The help topic name to look up.
   * @return A {@link HelpTopic} object matching the topic name or null if
   *     none can be found.
  */
  getHelpTopic(topicName: string): HelpTopic | null;
  /**
   * Returns a collection of all the registered help topics.
   *
   * @return All the registered help topics.
  */
  getHelpTopics(): Collection<HelpTopic>;
  /**
   * Adds a topic to the server's help index.
   *
   * @param topic The new help topic to add.
  */
  addTopic(topic: HelpTopic): void;
  /**
   * Clears out the contents of the help index. Normally called during
   * server reload.
  */
  clear(): void;
  /**
   * Associates a {@link HelpTopicFactory} object with given command base
   * class. Plugins typically call this method during `onLoad()`. Once
   * registered, the custom HelpTopicFactory will be used to create a custom
   * {@link HelpTopic} for all commands deriving from the `     * commandClass` base class, or all commands deriving from {@link
   * org.bukkit.command.PluginCommand} who's executor derives from `     * commandClass` base class.
   *
   * @param commandClass The class for which the custom HelpTopicFactory
   *     applies. Must derive from either {@link org.bukkit.command.Command}
   *     or {@link org.bukkit.command.CommandExecutor}.
   * @param factory The {@link HelpTopicFactory} implementation to associate
   *     with the `commandClass`.
   * @throws IllegalArgumentException Thrown if `commandClass` does
   *     not derive from a legal base class.
  */
  registerHelpTopicFactory(commandClass: Class<any>, factory: HelpTopicFactory<any>): void;
  /**
   * Gets the list of plugins the server administrator has chosen to exclude
   * from the help index. Plugin authors who choose to directly extend
   * {@link org.bukkit.command.Command} instead of {@link
   * org.bukkit.command.PluginCommand} will need to check this collection in
   * their {@link HelpTopicFactory} implementations to ensure they meet the
   * server administrator's expectations.
   *
   * @return A list of plugins that should be excluded from the help index.
  */
  getIgnoredPlugins(): string[];
}

}
declare module 'org.bukkit.entity.Parrot' {
import { Enum } from 'java.lang';
/**
 * Represents the variant of a parrot - ie its color.
*/
export class Variant extends Enum<Variant> {
  /**
   * Classic parrot - red with colored wingtips.
  */
  static readonly RED: Variant;
  /**
   * Royal blue colored parrot.
  */
  static readonly BLUE: Variant;
  /**
   * Green colored parrot.
  */
  static readonly GREEN: Variant;
  /**
   * Cyan colored parrot.
  */
  static readonly CYAN: Variant;
  /**
   * Gray colored parrot.
  */
  static readonly GRAY: Variant;
  static valueOf(name: string): Variant;
  static values(): Variant[];
}

}
declare module 'org.bukkit.event.weather.ThunderChangeEvent' {
import { Enum } from 'java.lang';
export class Cause extends Enum<Cause> {
  static readonly COMMAND: Cause;
  static readonly NATURAL: Cause;
  static readonly SLEEP: Cause;
  static readonly PLUGIN: Cause;
  static readonly UNKNOWN: Cause;
  static valueOf(name: string): Cause;
  static values(): Cause[];
}

}
declare module 'org.bukkit.FireworkEffect' {
import { Enum, Iterable } from 'java.lang';
import { Builder as com_google_common_collect_ImmutableList_Builder } from 'com.google.common.collect.ImmutableList';
import { Index } from 'net.kyori.adventure.util';
import { Color, FireworkEffect } from 'org.bukkit';
/**
 * The type or shape of the effect.
*/
export class Type extends Enum<Type> {
  static readonly BALL: Type;
  static readonly BALL_LARGE: Type;
  static readonly STAR: Type;
  static readonly BURST: Type;
  static readonly CREEPER: Type;
  static valueOf(name: string): Type;
  static values(): Type[];
  /**
   * The name map.
  */
  static readonly NAMES: Index<string, Type>;
  translationKey(): string;
}
/**
 * This is a builder for FireworkEffects.
 *
 * @see FireworkEffect#builder()
*/
export class Builder {
  /**
   * Specify the type of the firework effect.
   *
   * @param type The effect type
   * @return This object, for chaining
   * @throws IllegalArgumentException If type is null
  */
  with(type: Type): Builder;
  /**
   * Add a flicker to the firework effect.
   *
   * @return This object, for chaining
  */
  withFlicker(): Builder;
  /**
   * Set whether the firework effect should flicker.
   *
   * @param flicker true if it should flicker, false if not
   * @return This object, for chaining
  */
  flicker(flicker: boolean): Builder;
  /**
   * Add a trail to the firework effect.
   *
   * @return This object, for chaining
  */
  withTrail(): Builder;
  /**
   * Set whether the firework effect should have a trail.
   *
   * @param trail true if it should have a trail, false for no trail
   * @return This object, for chaining
  */
  trail(trail: boolean): Builder;
  /**
   * Add a primary color to the firework effect.
   *
   * @param color The color to add
   * @return This object, for chaining
   * @throws IllegalArgumentException If color is null
  */
  withColor(color: Color): Builder;
  /**
   * Add several primary colors to the firework effect.
   *
   * @param colors The colors to add
   * @return This object, for chaining
   * @throws IllegalArgumentException If colors is null
   * @throws IllegalArgumentException If any color is null (may be
   *     thrown after changes have occurred)
  */
  withColor(...colors: Color[]): Builder;
  /**
   * Add several primary colors to the firework effect.
   *
   * @param colors An iterable object whose iterator yields the desired
   *     colors
   * @return This object, for chaining
   * @throws IllegalArgumentException If colors is null
   * @throws IllegalArgumentException If any color is null (may be
   *     thrown after changes have occurred)
  */
  withColor(colors: Iterable<any>): Builder;
  /**
   * Add a fade color to the firework effect.
   *
   * @param color The color to add
   * @return This object, for chaining
   * @throws IllegalArgumentException If colors is null
   * @throws IllegalArgumentException If any color is null (may be
   *     thrown after changes have occurred)
  */
  withFade(color: Color): Builder;
  /**
   * Add several fade colors to the firework effect.
   *
   * @param colors The colors to add
   * @return This object, for chaining
   * @throws IllegalArgumentException If colors is null
   * @throws IllegalArgumentException If any color is null (may be
   *     thrown after changes have occurred)
  */
  withFade(...colors: Color[]): Builder;
  /**
   * Add several fade colors to the firework effect.
   *
   * @param colors An iterable object whose iterator yields the desired
   *     colors
   * @return This object, for chaining
   * @throws IllegalArgumentException If colors is null
   * @throws IllegalArgumentException If any color is null (may be
   *     thrown after changes have occurred)
  */
  withFade(colors: Iterable<any>): Builder;
  /**
   * Create a {@link FireworkEffect} from the current contents of this
   * builder.
   * 
   * To successfully build, you must have specified at least one color.
   *
   * @return The representative firework effect
  */
  build(): FireworkEffect;
}

}
declare module 'org.bukkit.inventory.meta.BookMeta' {
import { Component } from 'net.kyori.adventure.text';
import { Collection } from 'java.util';
import { Enum } from 'java.lang';
import { Builder } from 'net.kyori.adventure.inventory.Book';
import { BookMeta } from 'org.bukkit.inventory.meta';
/**
 * Represents the generation (or level of copying) of a written book
*/
export class Generation extends Enum<Generation> {
  /**
   * Book written into a book-and-quill. Can be copied. (Default value)
  */
  static readonly ORIGINAL: Generation;
  /**
   * Book that was copied from an original. Can be copied.
  */
  static readonly COPY_OF_ORIGINAL: Generation;
  /**
   * Book that was copied from a copy of an original. Can't be copied.
  */
  static readonly COPY_OF_COPY: Generation;
  /**
   * Unused; unobtainable by players. Can't be copied.
  */
  static readonly TATTERED: Generation;
  static valueOf(name: string): Generation;
  static values(): Generation[];
}
export class BookMetaBuilder extends Builder {
  title(title: Component | null): BookMetaBuilder;
  author(author: Component | null): BookMetaBuilder;
  addPage(page: Component): BookMetaBuilder;
  pages(...pages: Component[]): BookMetaBuilder;
  pages(pages: Collection<Component>): BookMetaBuilder;
  build(): BookMeta;
}
export class Spigot {

}

}
declare module 'org.bukkit.block.data.type.Bed' {
import { Enum } from 'java.lang';
/**
 * Horizontal half of a bed.
*/
export class Part extends Enum<Part> {
  /**
   * The head is the upper part of the bed containing the pillow.
  */
  static readonly HEAD: Part;
  /**
   * The foot is the lower half of the bed.
  */
  static readonly FOOT: Part;
  static valueOf(name: string): Part;
  static values(): Part[];
}

}
declare module 'org.bukkit.block.data.type.Wall' {
import { Enum } from 'java.lang';
/**
 * The different heights a face of a wall may have.
*/
export class Height extends Enum<Height> {
  /**
   * No wall present.
  */
  static readonly NONE: Height;
  /**
   * Low wall present.
  */
  static readonly LOW: Height;
  /**
   * Tall wall present.
  */
  static readonly TALL: Height;
  static valueOf(name: string): Height;
  static values(): Height[];
}

}
declare module 'org.bukkit.event.weather.WeatherChangeEvent' {
import { Enum } from 'java.lang';
export class Cause extends Enum<Cause> {
  static readonly COMMAND: Cause;
  static readonly NATURAL: Cause;
  static readonly SLEEP: Cause;
  static readonly PLUGIN: Cause;
  static readonly UNKNOWN: Cause;
  static valueOf(name: string): Cause;
  static values(): Cause[];
}

}
declare module 'org.bukkit.event.hanging.HangingBreakEvent' {
import { Enum } from 'java.lang';
/**
 * An enum to specify the cause of the removal
*/
export class RemoveCause extends Enum<RemoveCause> {
  /**
   * Removed by an entity
  */
  static readonly ENTITY: RemoveCause;
  /**
   * Removed by an explosion
  */
  static readonly EXPLOSION: RemoveCause;
  /**
   * Removed by placing a block on it
  */
  static readonly OBSTRUCTION: RemoveCause;
  /**
   * Removed by destroying the block behind it, etc
  */
  static readonly PHYSICS: RemoveCause;
  /**
   * Removed by an uncategorised cause
  */
  static readonly DEFAULT: RemoveCause;
  static valueOf(name: string): RemoveCause;
  static values(): RemoveCause[];
}

}
declare module 'org.bukkit.entity.Llama' {
import { Enum } from 'java.lang';
/**
 * Represents the base color that the llama has.
*/
export class Color extends Enum<Color> {
  /**
   * A cream-colored llama.
  */
  static readonly CREAMY: Color;
  /**
   * A white llama.
  */
  static readonly WHITE: Color;
  /**
   * A brown llama.
  */
  static readonly BROWN: Color;
  /**
   * A gray llama.
  */
  static readonly GRAY: Color;
  static valueOf(name: string): Color;
  static values(): Color[];
}

}
declare module 'org.bukkit.entity.LightningStrike' {
import { Spigot as org_bukkit_entity_Entity_Spigot } from 'org.bukkit.entity.Entity';
export class Spigot extends org_bukkit_entity_Entity_Spigot {
  isSilent(): boolean;
}

}
declare module 'org.bukkit.entity.MushroomCow' {
import { Enum } from 'java.lang';
/**
 * Represents the variant of a cow - ie its color.
*/
export class Variant extends Enum<Variant> {
  /**
   * Red mushroom cow.
  */
  static readonly RED: Variant;
  /**
   * Brown mushroom cow.
  */
  static readonly BROWN: Variant;
  static valueOf(name: string): Variant;
  static values(): Variant[];
}

}
declare module 'org.bukkit.map.MapView' {
import { Enum } from 'java.lang';
/**
 * An enum representing all possible scales a map can be set to.
*/
export class Scale extends Enum<Scale> {
  static readonly CLOSEST: Scale;
  static readonly CLOSE: Scale;
  static readonly NORMAL: Scale;
  static readonly FAR: Scale;
  static readonly FARTHEST: Scale;
  static valueOf(name: string): Scale;
  static values(): Scale[];
  /**
   * Get the scale given the raw value.
   *
   * @param value The raw scale
   * @return The enum scale, or null for an invalid input
   * @deprecated Magic value
  */
  static valueOf(value: number): Scale | null;
  /**
   * Get the raw value of this scale level.
   *
   * @return The scale value
   * @deprecated Magic value
  */
  getValue(): number;
}

}
declare module 'org.bukkit.entity.AbstractArrow' {
import { Enum } from 'java.lang';
/**
 * Represents the pickup status of this arrow.
*/
export class PickupStatus extends Enum<PickupStatus> {
  /**
   * The arrow cannot be picked up.
  */
  static readonly DISALLOWED: PickupStatus;
  /**
   * The arrow can be picked up.
  */
  static readonly ALLOWED: PickupStatus;
  /**
   * The arrow can only be picked up by players in creative mode.
  */
  static readonly CREATIVE_ONLY: PickupStatus;
  static valueOf(name: string): PickupStatus;
  static values(): PickupStatus[];
}
export class PickupRule extends Enum<PickupRule> {
  static readonly DISALLOWED: PickupRule;
  static readonly ALLOWED: PickupRule;
  static readonly CREATIVE_ONLY: PickupRule;
  static valueOf(name: string): PickupRule;
  static values(): PickupRule[];
}

}
declare module 'org.bukkit.block.data.type.Door' {
import { Enum } from 'java.lang';
/**
 * The hinge of a door.
*/
export class Hinge extends Enum<Hinge> {
  /**
   * Door is attached to the left side.
  */
  static readonly LEFT: Hinge;
  /**
   * Door is attached to the right side.
  */
  static readonly RIGHT: Hinge;
  static valueOf(name: string): Hinge;
  static values(): Hinge[];
}

}
declare module 'org.bukkit.command' {
import { ComponentLike, Component } from 'net.kyori.adventure.text';
import { Set, Collection, List, UUID, Map } from 'java.util';
import { Spigot } from 'org.bukkit.command.CommandSender';
import { Server, Location } from 'org.bukkit';
import { Permissible, Permission, PermissionAttachmentInfo, PermissionAttachment } from 'org.bukkit.permissions';
import { StringBuffer, RuntimeException, Iterable, Throwable } from 'java.lang';
import { Block } from 'org.bukkit.block';
import { Single } from 'net.kyori.adventure.audience.ForwardingAudience';
import { Identified, Identity } from 'net.kyori.adventure.identity';
import { Plugin } from 'org.bukkit.plugin';
import { Audience, ForwardingAudience, MessageType } from 'net.kyori.adventure.audience';
import { Conversable } from 'org.bukkit.conversations';
import { Timing } from 'co.aikar.timings';
/**
 * This class is provided as a convenience to implement both TabCompleter and
 * CommandExecutor.
*/
export class TabExecutor extends TabCompleter {

}
export interface TabExecutor extends TabCompleter, CommandExecutor {}
export class CommandMap {
  /**
   * Registers all the commands belonging to a certain plugin.
   * 
   * Caller can use:-
   * 
   * command.getName() to determine the label registered for this
   *     command
   * command.getAliases() to determine the aliases which where
   *     registered
   * 
   *
   * @param fallbackPrefix a prefix which is prepended to each command with
   *     a ':' one or more times to make the command unique
   * @param commands a list of commands to register
  */
  registerAll(fallbackPrefix: string, commands: Command[]): void;
  /**
   * Registers a command. Returns true on success; false if name is already
   * taken and fallback had to be used.
   * 
   * Caller can use:-
   * 
   * command.getName() to determine the label registered for this
   *     command
   * command.getAliases() to determine the aliases which where
   *     registered
   * 
   *
   * @param label the label of the command, without the '/'-prefix.
   * @param fallbackPrefix a prefix which is prepended to the command with a
   *     ':' one or more times to make the command unique
   * @param command the command to register
   * @return true if command was registered with the passed in label, false
   *     otherwise, which indicates the fallbackPrefix was used one or more
   *     times
  */
  register(label: string, fallbackPrefix: string, command: Command): boolean;
  /**
   * Registers a command. Returns true on success; false if name is already
   * taken and fallback had to be used.
   * 
   * Caller can use:-
   * 
   * command.getName() to determine the label registered for this
   *     command
   * command.getAliases() to determine the aliases which where
   *     registered
   * 
   *
   * @param fallbackPrefix a prefix which is prepended to the command with a
   *     ':' one or more times to make the command unique
   * @param command the command to register, from which label is determined
   *     from the command name
   * @return true if command was registered with the passed in label, false
   *     otherwise, which indicates the fallbackPrefix was used one or more
   *     times
  */
  register(fallbackPrefix: string, command: Command): boolean;
  /**
   * Looks for the requested command and executes it if found.
   *
   * @param sender The command's sender
   * @param cmdLine command + arguments. Example: "/test abc 123"
   * @return returns false if no target is found, true otherwise.
   * @throws CommandException Thrown when the executor for the given command
   *     fails with an unhandled exception
  */
  dispatch(sender: CommandSender, cmdLine: string): boolean;
  /**
   * Clears all registered commands.
  */
  clearCommands(): void;
  /**
   * Gets the command registered to the specified name
   *
   * @param name Name of the command to retrieve
   * @return Command with the specified name or null if a command with that
   *     label doesn't exist
  */
  getCommand(name: string): Command | null;
  /**
   * Looks for the requested command and executes an appropriate
   * tab-completer if found. This method will also tab-complete partial
   * commands.
   *
   * @param sender The command's sender.
   * @param cmdLine The entire command string to tab-complete, excluding
   *     initial slash.
   * @return a list of possible tab-completions. This list may be immutable.
   *     Will be null if no matching command of which sender has permission.
   * @throws CommandException Thrown when the tab-completer for the given
   *     command fails with an unhandled exception
   * @throws IllegalArgumentException if either sender or cmdLine are null
  */
  tabComplete(sender: CommandSender, cmdLine: string): string[] | null;
  /**
   * Looks for the requested command and executes an appropriate
   * tab-completer if found. This method will also tab-complete partial
   * commands.
   *
   * @param sender The command's sender.
   * @param cmdLine The entire command string to tab-complete, excluding
   *     initial slash.
   * @param location The position looked at by the sender, or null if none
   * @return a list of possible tab-completions. This list may be immutable.
   *     Will be null if no matching command of which sender has permission.
   * @throws CommandException Thrown when the tab-completer for the given
   *     command fails with an unhandled exception
   * @throws IllegalArgumentException if either sender or cmdLine are null
  */
  tabComplete(sender: CommandSender, cmdLine: string, location: Location | null): string[] | null;
  /**
   * Return a Map of known commands
   *
   * @return known commands
  */
  getKnownCommands(): Map<string, Command>;
}
export class RemoteConsoleCommandSender extends CommandSender {

}
export class BufferedCommandSender extends MessageCommandSender {
  sendMessage(message: string): void;
  getBuffer(): string;
  reset(): void;
  sendMessage(messages: string[]): void;
  sendMessage(sender: UUID | null, message: string): void;
  sendMessage(sender: UUID | null, messages: string[]): void;
  sendMessage(identity: Identity, message: Component, type: MessageType): void;
  /**
   * Sends a chat message with a {@link Identity#nil() nil} identity to this {@link Audience}.
   *
   * @param message a message
   * @see Component
   * @see #sendMessage(Identified, ComponentLike)
   * @see #sendMessage(Identity, ComponentLike)
   * @since 4.1.0
  */
  sendMessage(message: ComponentLike): void;
  /**
   * Sends a chat message from the given {@link Identified} to this {@link Audience}.
   *
   * @param source the source of the message
   * @param message a message
   * @see Component
   * @since 4.0.0
  */
  sendMessage(source: Identified, message: ComponentLike): void;
  /**
   * Sends a chat message from the entity represented by the given {@link Identity} (or the game using {@link Identity#nil()}) to this {@link Audience}.
   *
   * @param source the identity of the source of the message
   * @param message a message
   * @see Component
   * @since 4.0.0
  */
  sendMessage(source: Identity, message: ComponentLike): void;
  /**
   * Sends a chat message with a {@link Identity#nil() nil} identity to this {@link Audience}.
   *
   * @param message a message
   * @see Component
   * @see #sendMessage(Identified, Component)
   * @see #sendMessage(Identity, Component)
   * @since 4.1.0
  */
  sendMessage(message: Component): void;
  /**
   * Sends a chat message from the given {@link Identified} to this {@link Audience}.
   *
   * @param source the source of the message
   * @param message a message
   * @see Component
   * @since 4.0.0
  */
  sendMessage(source: Identified, message: Component): void;
  /**
   * Sends a chat message from the entity represented by the given {@link Identity} (or the game using {@link Identity#nil()}) to this {@link Audience}.
   *
   * @param source the identity of the source of the message
   * @param message a message
   * @see Component
   * @since 4.0.0
  */
  sendMessage(source: Identity, message: Component): void;
  /**
   * Sends a chat message with a {@link Identity#nil() nil} identity to this {@link Audience}.
   *
   * @param message a message
   * @param type the type
   * @see Component
   * @see #sendMessage(Identified, ComponentLike, MessageType)
   * @see #sendMessage(Identity, ComponentLike, MessageType)
   * @since 4.1.0
  */
  sendMessage(message: ComponentLike, type: MessageType): void;
  /**
   * Sends a chat message from the given {@link Identified} to this {@link Audience}.
   *
   * @param source the source of the message
   * @param message a message
   * @param type the type
   * @see Component
   * @since 4.0.0
  */
  sendMessage(source: Identified, message: ComponentLike, type: MessageType): void;
  /**
   * Sends a chat message from the entity represented by the given {@link Identity} (or the game using {@link Identity#nil()}) to this {@link Audience}.
   *
   * @param source the identity of the source of the message
   * @param message a message
   * @param type the type
   * @see Component
   * @since 4.0.0
  */
  sendMessage(source: Identity, message: ComponentLike, type: MessageType): void;
  /**
   * Sends a chat message with a {@link Identity#nil() nil} identity to this {@link Audience}.
   *
   * @param message a message
   * @param type the type
   * @see Component
   * @see #sendMessage(Identified, Component, MessageType)
   * @see #sendMessage(Identity, Component, MessageType)
   * @since 4.1.0
  */
  sendMessage(message: Component, type: MessageType): void;
  /**
   * Sends a chat message.
   *
   * @param source the source of the message
   * @param message a message
   * @param type the type
   * @see Component
   * @since 4.0.0
  */
  sendMessage(source: Identified, message: Component, type: MessageType): void;
}
export class FormattedCommandAlias extends Command {
  constructor(alias: string, formatStrings: string[]);
  execute(sender: CommandSender, commandLabel: string, args: string[]): boolean;
  getTimingName(): string;
}
/**
 * Represents a {@link Command} belonging to a plugin
*/
export class PluginCommand extends Command {
  /**
   * Executes the command, returning its success
   *
   * @param sender Source object which is executing this command
   * @param commandLabel The alias of the command used
   * @param args All arguments passed to the command, split via ' '
   * @return true if the command was successful, otherwise false
  */
  execute(sender: CommandSender, commandLabel: string, args: string[]): boolean;
  /**
   * Sets the {@link CommandExecutor} to run when parsing this command
   *
   * @param executor New executor to run
  */
  setExecutor(executor: CommandExecutor | null);
  /**
   * Gets the {@link CommandExecutor} associated with this command
   *
   * @return CommandExecutor object linked to this command
  */
  getExecutor(): CommandExecutor;
  /**
   * Sets the {@link TabCompleter} to run when tab-completing this command.
   * 
   * If no TabCompleter is specified, and the command's executor implements
   * TabCompleter, then the executor will be used for tab completion.
   *
   * @param completer New tab completer
  */
  setTabCompleter(tabCompleter: TabCompleter | null);
  /**
   * Gets the {@link TabCompleter} associated with this command.
   *
   * @return TabCompleter object linked to this command
  */
  getTabCompleter(): TabCompleter | null;
  /**
   * Gets the owner of this PluginCommand
   *
   * @return Plugin that owns this command
  */
  getPlugin(): Plugin;
  /**
   * {@inheritDoc}
   * 
   * Delegates to the tab completer if present.
   * 
   * If it is not present or returns null, will delegate to the current
   * command executor if it implements {@link TabCompleter}. If a non-null
   * list has not been found, will default to standard player name
   * completion in {@link
   * Command#tabComplete(CommandSender, String, String[])}.
   * 
   * This method does not consider permissions.
   *
   * @throws CommandException if the completer or executor throw an
   *     exception during the process of tab-completing.
   * @throws IllegalArgumentException if sender, alias, or args is null
  */
  tabComplete(sender: CommandSender, alias: string, args: string[]): string[];
  toString(): string;
  /**
   * Executed on tab completion for this command, returning a list of
   * options the player can tab through.
   *
   * @param sender Source object which is executing this command
   * @param alias the alias being used
   * @param args All arguments passed to the command, split via ' '
   * @param location The position looked at by the sender, or null if none
   * @return a list of tab-completions for the specified arguments. This
   *     will never be null. List may be immutable.
   * @throws IllegalArgumentException if sender, alias, or args is null
  */
  tabComplete(sender: CommandSender, alias: string, args: string[], location: Location | null): string[];
}
export interface PluginCommand extends Command, PluginIdentifiableCommand {}
export class PluginCommandYamlParser {
  static parse(plugin: Plugin): Command[];
}
/**
 * Represents a Command, which executes various tasks upon user input
*/
export class Command {
  timings: Timing;
  getTimingName(): string;
  /**
   * Executes the command, returning its success
   *
   * @param sender Source object which is executing this command
   * @param commandLabel The alias of the command used
   * @param args All arguments passed to the command, split via ' '
   * @return true if the command was successful, otherwise false
  */
  execute(sender: CommandSender, commandLabel: string, args: string[]): boolean;
  /**
   * Executed on tab completion for this command, returning a list of
   * options the player can tab through.
   *
   * @param sender Source object which is executing this command
   * @param alias the alias being used
   * @param args All arguments passed to the command, split via ' '
   * @return a list of tab-completions for the specified arguments. This
   *     will never be null. List may be immutable.
   * @throws IllegalArgumentException if sender, alias, or args is null
  */
  tabComplete(sender: CommandSender, alias: string, args: string[]): string[];
  /**
   * Executed on tab completion for this command, returning a list of
   * options the player can tab through.
   *
   * @param sender Source object which is executing this command
   * @param alias the alias being used
   * @param args All arguments passed to the command, split via ' '
   * @param location The position looked at by the sender, or null if none
   * @return a list of tab-completions for the specified arguments. This
   *     will never be null. List may be immutable.
   * @throws IllegalArgumentException if sender, alias, or args is null
  */
  tabComplete(sender: CommandSender, alias: string, args: string[], location: Location | null): string[];
  /**
   * Returns the name of this command
   *
   * @return Name of this command
  */
  getName(): string;
  /**
   * Sets the name of this command.
   * 
   * May only be used before registering the command.
   * Will return true if the new name is set, and false
   * if the command has already been registered.
   *
   * @param name New command name
   * @return returns true if the name change happened instantly or false if
   *     the command was already registered
  */
  setName(name: string);
  /**
   * Gets the permission required by users to be able to perform this
   * command
   *
   * @return Permission name, or null if none
  */
  getPermission(): string | null;
  /**
   * Sets the permission required by users to be able to perform this
   * command
   *
   * @param permission Permission name or null
  */
  setPermission(permission: string | null);
  /**
   * Tests the given {@link CommandSender} to see if they can perform this
   * command.
   * 
   * If they do not have permission, they will be informed that they cannot
   * do this.
   *
   * @param target User to test
   * @return true if they can use it, otherwise false
  */
  testPermission(target: CommandSender): boolean;
  /**
   * Tests the given {@link CommandSender} to see if they can perform this
   * command.
   * 
   * No error is sent to the sender.
   *
   * @param target User to test
   * @return true if they can use it, otherwise false
  */
  testPermissionSilent(target: CommandSender): boolean;
  /**
   * Returns the label for this command
   *
   * @return Label of this command
  */
  getLabel(): string;
  /**
   * Sets the label of this command.
   * 
   * May only be used before registering the command.
   * Will return true if the new name is set, and false
   * if the command has already been registered.
   *
   * @param name The command's name
   * @return returns true if the name change happened instantly or false if
   *     the command was already registered
  */
  setLabel(label: string);
  /**
   * Registers this command to a CommandMap.
   * Once called it only allows changes the registered CommandMap
   *
   * @param commandMap the CommandMap to register this command to
   * @return true if the registration was successful (the current registered
   *     CommandMap was the passed CommandMap or null) false otherwise
  */
  register(commandMap: CommandMap): boolean;
  /**
   * Unregisters this command from the passed CommandMap applying any
   * outstanding changes
   *
   * @param commandMap the CommandMap to unregister
   * @return true if the unregistration was successful (the current
   *     registered CommandMap was the passed CommandMap or null) false
   *     otherwise
  */
  unregister(commandMap: CommandMap): boolean;
  /**
   * Returns the current registered state of this command
   *
   * @return true if this command is currently registered false otherwise
  */
  isRegistered(): boolean;
  /**
   * Returns a list of active aliases of this command
   *
   * @return List of aliases
  */
  getAliases(): string[];
  /**
   * Returns a message to be displayed on a failed permission check for this
   * command
   *
   * @return Permission check failed message
   * @deprecated use {@link #permissionMessage()}
  */
  getPermissionMessage(): string | null;
  /**
   * Gets a brief description of this command
   *
   * @return Description of this command
  */
  getDescription(): string;
  /**
   * Gets an example usage of this command
   *
   * @return One or more example usages
  */
  getUsage(): string;
  /**
   * Sets the list of aliases to request on registration for this command.
   * This is not effective outside of defining aliases in the {@link
   * PluginDescriptionFile#getCommands()} (under the
   * `aliases' node) is equivalent to this method.
   *
   * @param aliases aliases to register to this command
   * @return this command object, for chaining
  */
  setAliases(aliases: string[]);
  /**
   * Sets a brief description of this command. Defining a description in the
   * {@link PluginDescriptionFile#getCommands()} (under the
   * `description' node) is equivalent to this method.
   *
   * @param description new command description
   * @return this command object, for chaining
  */
  setDescription(description: string);
  /**
   * Sets the message sent when a permission check fails
   *
   * @param permissionMessage new permission message, null to indicate
   *     default message, or an empty string to indicate no message
   * @return this command object, for chaining
   * @deprecated use {@link #permissionMessage(net.kyori.adventure.text.Component)}
  */
  setPermissionMessage(permissionMessage: string | null): void;
  /**
   * Sets the example usage of this command
   *
   * @param usage new example usage
   * @return this command object, for chaining
  */
  setUsage(usage: string);
  /**
   * Sets the permission message.
   *
   * @param permissionMessage the permission message
  */
  permissionMessage(permissionMessage: Component | null): void;
  static broadcastCommandMessage(source: CommandSender, message: string): void;
  static broadcastCommandMessage(source: CommandSender, message: string, sendToSource: boolean): void;
  static broadcastCommandMessage(source: CommandSender, message: Component): void;
  static broadcastCommandMessage(source: CommandSender, message: Component, sendToSource: boolean): void;
  toString(): string;
}
/**
 * This interface is used by the help system to group commands into
 * sub-indexes based on the {@link Plugin} they are a part of. Custom command
 * implementations will need to implement this interface to have a sub-index
 * automatically generated on the plugin's behalf.
*/
export class PluginIdentifiableCommand {
  /**
   * Gets the owner of this PluginIdentifiableCommand.
   *
   * @return Plugin that owns this PluginIdentifiableCommand.
  */
  getPlugin(): Plugin;
}
/**
 * Represents a command that delegates to one or more other commands
*/
export class MultipleCommandAlias extends Command {
  constructor(name: string, commands: Command[]);
  /**
   * Gets the commands associated with the multi-command alias.
   *
   * @return commands associated with alias
  */
  getCommands(): Command[];
  execute(sender: CommandSender, commandLabel: string, args: string[]): boolean;
}
/**
 * Represents a class which contains a single method for executing commands
*/
export class CommandExecutor {
  /**
   * Executes the given command, returning its success.
   * 
   * If false is returned, then the "usage" plugin.yml entry for this command
   * (if defined) will be sent to the player.
   *
   * @param sender Source of the command
   * @param command Command which was executed
   * @param label Alias of the command which was used
   * @param args Passed command arguments
   * @return true if a valid command, otherwise false
  */
  onCommand(sender: CommandSender, command: Command, label: string, args: string[]): boolean;
}
export class BlockCommandSender extends CommandSender {
  /**
   * Returns the block this command sender belongs to
   *
   * @return Block for the command sender
  */
  getBlock(): Block;
}
/**
 * For when all you care about is just messaging
*/
export class MessageCommandSender extends CommandSender {
  sendMessage(messages: string[]): void;
  sendMessage(sender: UUID | null, message: string): void;
  sendMessage(sender: UUID | null, messages: string[]): void;
  getServer(): Server;
  name(): Component;
  isOp(): boolean;
  setOp(value: boolean): void;
  isPermissionSet(name: string): boolean;
  isPermissionSet(perm: Permission): boolean;
  hasPermission(name: string): boolean;
  hasPermission(perm: Permission): boolean;
  addAttachment(plugin: Plugin, name: string, value: boolean): PermissionAttachment;
  addAttachment(plugin: Plugin): PermissionAttachment;
  addAttachment(plugin: Plugin, name: string, value: boolean, ticks: number): PermissionAttachment;
  addAttachment(plugin: Plugin, ticks: number): PermissionAttachment;
  removeAttachment(attachment: PermissionAttachment): void;
  recalculatePermissions(): void;
  getEffectivePermissions(): Set<PermissionAttachmentInfo>;
  spigot(): Spigot;
  /**
   * Sends this sender a message
   *
   * @param message Message to be displayed
   * @see #sendMessage(net.kyori.adventure.text.Component)
  */
  sendMessage(message: string): void;
  sendMessage(identity: Identity, message: Component, type: MessageType): void;
  /**
   * Sends a chat message with a {@link Identity#nil() nil} identity to this {@link Audience}.
   *
   * @param message a message
   * @see Component
   * @see #sendMessage(Identified, ComponentLike)
   * @see #sendMessage(Identity, ComponentLike)
   * @since 4.1.0
  */
  sendMessage(message: ComponentLike): void;
  /**
   * Sends a chat message from the given {@link Identified} to this {@link Audience}.
   *
   * @param source the source of the message
   * @param message a message
   * @see Component
   * @since 4.0.0
  */
  sendMessage(source: Identified, message: ComponentLike): void;
  /**
   * Sends a chat message from the entity represented by the given {@link Identity} (or the game using {@link Identity#nil()}) to this {@link Audience}.
   *
   * @param source the identity of the source of the message
   * @param message a message
   * @see Component
   * @since 4.0.0
  */
  sendMessage(source: Identity, message: ComponentLike): void;
  /**
   * Sends a chat message with a {@link Identity#nil() nil} identity to this {@link Audience}.
   *
   * @param message a message
   * @see Component
   * @see #sendMessage(Identified, Component)
   * @see #sendMessage(Identity, Component)
   * @since 4.1.0
  */
  sendMessage(message: Component): void;
  /**
   * Sends a chat message from the given {@link Identified} to this {@link Audience}.
   *
   * @param source the source of the message
   * @param message a message
   * @see Component
   * @since 4.0.0
  */
  sendMessage(source: Identified, message: Component): void;
  /**
   * Sends a chat message from the entity represented by the given {@link Identity} (or the game using {@link Identity#nil()}) to this {@link Audience}.
   *
   * @param source the identity of the source of the message
   * @param message a message
   * @see Component
   * @since 4.0.0
  */
  sendMessage(source: Identity, message: Component): void;
  /**
   * Sends a chat message with a {@link Identity#nil() nil} identity to this {@link Audience}.
   *
   * @param message a message
   * @param type the type
   * @see Component
   * @see #sendMessage(Identified, ComponentLike, MessageType)
   * @see #sendMessage(Identity, ComponentLike, MessageType)
   * @since 4.1.0
  */
  sendMessage(message: ComponentLike, type: MessageType): void;
  /**
   * Sends a chat message from the given {@link Identified} to this {@link Audience}.
   *
   * @param source the source of the message
   * @param message a message
   * @param type the type
   * @see Component
   * @since 4.0.0
  */
  sendMessage(source: Identified, message: ComponentLike, type: MessageType): void;
  /**
   * Sends a chat message from the entity represented by the given {@link Identity} (or the game using {@link Identity#nil()}) to this {@link Audience}.
   *
   * @param source the identity of the source of the message
   * @param message a message
   * @param type the type
   * @see Component
   * @since 4.0.0
  */
  sendMessage(source: Identity, message: ComponentLike, type: MessageType): void;
  /**
   * Sends a chat message with a {@link Identity#nil() nil} identity to this {@link Audience}.
   *
   * @param message a message
   * @param type the type
   * @see Component
   * @see #sendMessage(Identified, Component, MessageType)
   * @see #sendMessage(Identity, Component, MessageType)
   * @since 4.1.0
  */
  sendMessage(message: Component, type: MessageType): void;
  /**
   * Sends a chat message.
   *
   * @param source the source of the message
   * @param message a message
   * @param type the type
   * @see Component
   * @since 4.0.0
  */
  sendMessage(source: Identified, message: Component, type: MessageType): void;
}
/**
 * Thrown when an unhandled exception occurs during the execution of a Command
*/
export class CommandException extends RuntimeException {
  /**
   * Creates a new instance of CommandException without detail
   * message.
  */
  constructor();
  /**
   * Constructs an instance of CommandException with the
   * specified detail message.
   *
   * @param msg the detail message.
  */
  constructor(msg: string);
  constructor(msg: string, cause: Throwable);
}
export class ProxiedCommandSender extends CommandSender {
  /**
   * Returns the CommandSender which triggered this proxied command
   *
   * @return the caller which triggered the command
  */
  getCaller(): CommandSender;
  /**
   * Returns the CommandSender which is being used to call the command
   *
   * @return the caller which the command is being run as
  */
  getCallee(): CommandSender;
  sendMessage(source: Identity, message: Component, type: MessageType): void;
  audience(): Audience;
  /**
   * Sends this sender a message
   *
   * @param message Message to be displayed
   * @see #sendMessage(net.kyori.adventure.text.Component)
  */
  sendMessage(message: string): void;
  /**
   * Sends this sender multiple messages
   *
   * @param messages An array of messages to be displayed
   * @see #sendMessage(net.kyori.adventure.text.Component)
  */
  sendMessage(...messages: string[]): void;
  /**
   * Sends this sender a message
   *
   * @param message Message to be displayed
   * @param sender The sender of this message
   * @see #sendMessage(net.kyori.adventure.identity.Identified, net.kyori.adventure.text.Component)
  */
  sendMessage(sender: UUID | null, message: string): void;
  /**
   * Sends this sender multiple messages
   *
   * @param messages An array of messages to be displayed
   * @param sender The sender of this message
   * @see #sendMessage(net.kyori.adventure.identity.Identified, net.kyori.adventure.text.Component)
  */
  sendMessage(sender: UUID | null, ...messages: string[]): void;
  /**
   * Creates an audience that forwards to many other audiences.
   *
   * @param audiences an array of audiences, can be empty
   * @return an audience
   * @see ForwardingAudience
   * @since 4.0.0
  */
  static audience(...audiences: Audience[]): Audience;
  /**
   * Creates an audience that forwards to many other audiences.
   *
   * The underlying Iterable is not copied, therefore any changes
   * made will be reflected in Audience.
   *
   * @param audiences an iterable of audiences, can be empty
   * @return an audience
   * @see ForwardingAudience
   * @since 4.0.0
  */
  static audience(audiences: Iterable<Audience>): ForwardingAudience;
  /**
   * Sends a chat message with a {@link Identity#nil() nil} identity to this {@link Audience}.
   *
   * @param message a message
   * @see Component
   * @see #sendMessage(Identified, ComponentLike)
   * @see #sendMessage(Identity, ComponentLike)
   * @since 4.1.0
  */
  sendMessage(message: ComponentLike): void;
  /**
   * Sends a chat message from the given {@link Identified} to this {@link Audience}.
   *
   * @param source the source of the message
   * @param message a message
   * @see Component
   * @since 4.0.0
  */
  sendMessage(source: Identified, message: ComponentLike): void;
  /**
   * Sends a chat message from the entity represented by the given {@link Identity} (or the game using {@link Identity#nil()}) to this {@link Audience}.
   *
   * @param source the identity of the source of the message
   * @param message a message
   * @see Component
   * @since 4.0.0
  */
  sendMessage(source: Identity, message: ComponentLike): void;
  /**
   * Sends a chat message with a {@link Identity#nil() nil} identity to this {@link Audience}.
   *
   * @param message a message
   * @see Component
   * @see #sendMessage(Identified, Component)
   * @see #sendMessage(Identity, Component)
   * @since 4.1.0
  */
  sendMessage(message: Component): void;
  /**
   * Sends a chat message from the given {@link Identified} to this {@link Audience}.
   *
   * @param source the source of the message
   * @param message a message
   * @see Component
   * @since 4.0.0
  */
  sendMessage(source: Identified, message: Component): void;
  /**
   * Sends a chat message from the entity represented by the given {@link Identity} (or the game using {@link Identity#nil()}) to this {@link Audience}.
   *
   * @param source the identity of the source of the message
   * @param message a message
   * @see Component
   * @since 4.0.0
  */
  sendMessage(source: Identity, message: Component): void;
  /**
   * Sends a chat message with a {@link Identity#nil() nil} identity to this {@link Audience}.
   *
   * @param message a message
   * @param type the type
   * @see Component
   * @see #sendMessage(Identified, ComponentLike, MessageType)
   * @see #sendMessage(Identity, ComponentLike, MessageType)
   * @since 4.1.0
  */
  sendMessage(message: ComponentLike, type: MessageType): void;
  /**
   * Sends a chat message from the given {@link Identified} to this {@link Audience}.
   *
   * @param source the source of the message
   * @param message a message
   * @param type the type
   * @see Component
   * @since 4.0.0
  */
  sendMessage(source: Identified, message: ComponentLike, type: MessageType): void;
  /**
   * Sends a chat message from the entity represented by the given {@link Identity} (or the game using {@link Identity#nil()}) to this {@link Audience}.
   *
   * @param source the identity of the source of the message
   * @param message a message
   * @param type the type
   * @see Component
   * @since 4.0.0
  */
  sendMessage(source: Identity, message: ComponentLike, type: MessageType): void;
  /**
   * Sends a chat message with a {@link Identity#nil() nil} identity to this {@link Audience}.
   *
   * @param message a message
   * @param type the type
   * @see Component
   * @see #sendMessage(Identified, Component, MessageType)
   * @see #sendMessage(Identity, Component, MessageType)
   * @since 4.1.0
  */
  sendMessage(message: Component, type: MessageType): void;
  /**
   * Sends a chat message.
   *
   * @param source the source of the message
   * @param message a message
   * @param type the type
   * @see Component
   * @since 4.0.0
  */
  sendMessage(source: Identified, message: Component, type: MessageType): void;
}
export interface ProxiedCommandSender extends CommandSender, Single {}
export class ConsoleCommandSender extends CommandSender {

}
export interface ConsoleCommandSender extends CommandSender, Conversable {}
export class SimpleCommandMap extends CommandMap {
  constructor(server: Server);
  setFallbackCommands(): void;
  /**
   * Registers all the commands belonging to a certain plugin.
   * 
   * Caller can use:-
   * 
   * command.getName() to determine the label registered for this
   *     command
   * command.getAliases() to determine the aliases which where
   *     registered
   * 
   *
   * @param fallbackPrefix a prefix which is prepended to each command with
   *     a ':' one or more times to make the command unique
   * @param commands a list of commands to register
  */
  registerAll(fallbackPrefix: string, commands: Command[]): void;
  /**
   * Registers a command. Returns true on success; false if name is already
   * taken and fallback had to be used.
   * 
   * Caller can use:-
   * 
   * command.getName() to determine the label registered for this
   *     command
   * command.getAliases() to determine the aliases which where
   *     registered
   * 
   *
   * @param label the label of the command, without the '/'-prefix.
   * @param fallbackPrefix a prefix which is prepended to the command with a
   *     ':' one or more times to make the command unique
   * @param command the command to register
   * @return true if command was registered with the passed in label, false
   *     otherwise, which indicates the fallbackPrefix was used one or more
   *     times
  */
  register(fallbackPrefix: string, command: Command): boolean;
  /**
   * Registers a command. Returns true on success; false if name is already
   * taken and fallback had to be used.
   * 
   * Caller can use:-
   * 
   * command.getName() to determine the label registered for this
   *     command
   * command.getAliases() to determine the aliases which where
   *     registered
   * 
   *
   * @param label the label of the command, without the '/'-prefix.
   * @param fallbackPrefix a prefix which is prepended to the command with a
   *     ':' one or more times to make the command unique
   * @param command the command to register
   * @return true if command was registered with the passed in label, false
   *     otherwise, which indicates the fallbackPrefix was used one or more
   *     times
  */
  register(label: string, fallbackPrefix: string, command: Command): boolean;
  /**
   * Looks for the requested command and executes it if found.
   *
   * @param sender The command's sender
   * @param cmdLine command + arguments. Example: "/test abc 123"
   * @return returns false if no target is found, true otherwise.
   * @throws CommandException Thrown when the executor for the given command
   *     fails with an unhandled exception
  */
  dispatch(sender: CommandSender, commandLine: string): boolean;
  /**
   * Clears all registered commands.
  */
  clearCommands(): void;
  /**
   * Gets the command registered to the specified name
   *
   * @param name Name of the command to retrieve
   * @return Command with the specified name or null if a command with that
   *     label doesn't exist
  */
  getCommand(name: string): Command | null;
  /**
   * Looks for the requested command and executes an appropriate
   * tab-completer if found. This method will also tab-complete partial
   * commands.
   *
   * @param sender The command's sender.
   * @param cmdLine The entire command string to tab-complete, excluding
   *     initial slash.
   * @return a list of possible tab-completions. This list may be immutable.
   *     Will be null if no matching command of which sender has permission.
   * @throws CommandException Thrown when the tab-completer for the given
   *     command fails with an unhandled exception
   * @throws IllegalArgumentException if either sender or cmdLine are null
  */
  tabComplete(sender: CommandSender, cmdLine: string): string[] | null;
  /**
   * Looks for the requested command and executes an appropriate
   * tab-completer if found. This method will also tab-complete partial
   * commands.
   *
   * @param sender The command's sender.
   * @param cmdLine The entire command string to tab-complete, excluding
   *     initial slash.
   * @return a list of possible tab-completions. This list may be immutable.
   *     Will be null if no matching command of which sender has permission.
   * @throws CommandException Thrown when the tab-completer for the given
   *     command fails with an unhandled exception
   * @throws IllegalArgumentException if either sender or cmdLine are null
  */
  tabComplete(sender: CommandSender, cmdLine: string, location: Location | null): string[] | null;
  getCommands(): Collection<Command>;
  registerServerAliases(): void;
  getKnownCommands(): Map<string, Command>;
}
/**
 * Represents a class which can suggest tab completions for commands.
*/
export class TabCompleter {
  /**
   * Requests a list of possible completions for a command argument.
   *
   * @param sender Source of the command.  For players tab-completing a
   *     command inside of a command block, this will be the player, not
   *     the command block.
   * @param command Command which was executed
   * @param label Alias of the command which was used
   * @param args The arguments passed to the command, including final
   *     partial argument to be completed
   * @return A List of possible completions for the final argument, or null
   *     to default to the command executor
  */
  onTabComplete(sender: CommandSender, command: Command, label: string, args: string[]): string[] | null;
}
export class CommandSender extends Audience {
  /**
   * Sends this sender a message
   *
   * @param message Message to be displayed
   * @see #sendMessage(net.kyori.adventure.text.Component)
  */
  sendMessage(message: string): void;
  /**
   * Sends this sender multiple messages
   *
   * @param messages An array of messages to be displayed
   * @see #sendMessage(net.kyori.adventure.text.Component)
  */
  sendMessage(...messages: string[]): void;
  /**
   * Sends this sender a message
   *
   * @param message Message to be displayed
   * @param sender The sender of this message
   * @see #sendMessage(net.kyori.adventure.identity.Identified, net.kyori.adventure.text.Component)
  */
  sendMessage(sender: UUID | null, message: string): void;
  /**
   * Sends this sender multiple messages
   *
   * @param messages An array of messages to be displayed
   * @param sender The sender of this message
   * @see #sendMessage(net.kyori.adventure.identity.Identified, net.kyori.adventure.text.Component)
  */
  sendMessage(sender: UUID | null, ...messages: string[]): void;
  /**
   * Returns the server instance that this command is running on
   *
   * @return Server instance
  */
  getServer(): Server;
  /**
   * Gets the name of this command sender
   *
   * @return Name of the sender
  */
  getName(): string;
  spigot(): Spigot;
  sendMessage(identity: Identity, message: Component, type: MessageType): void;
  /**
   * Sends a chat message with a {@link Identity#nil() nil} identity to this {@link Audience}.
   *
   * @param message a message
   * @see Component
   * @see #sendMessage(Identified, ComponentLike)
   * @see #sendMessage(Identity, ComponentLike)
   * @since 4.1.0
  */
  sendMessage(message: ComponentLike): void;
  /**
   * Sends a chat message from the given {@link Identified} to this {@link Audience}.
   *
   * @param source the source of the message
   * @param message a message
   * @see Component
   * @since 4.0.0
  */
  sendMessage(source: Identified, message: ComponentLike): void;
  /**
   * Sends a chat message from the entity represented by the given {@link Identity} (or the game using {@link Identity#nil()}) to this {@link Audience}.
   *
   * @param source the identity of the source of the message
   * @param message a message
   * @see Component
   * @since 4.0.0
  */
  sendMessage(source: Identity, message: ComponentLike): void;
  /**
   * Sends a chat message with a {@link Identity#nil() nil} identity to this {@link Audience}.
   *
   * @param message a message
   * @see Component
   * @see #sendMessage(Identified, Component)
   * @see #sendMessage(Identity, Component)
   * @since 4.1.0
  */
  sendMessage(message: Component): void;
  /**
   * Sends a chat message from the given {@link Identified} to this {@link Audience}.
   *
   * @param source the source of the message
   * @param message a message
   * @see Component
   * @since 4.0.0
  */
  sendMessage(source: Identified, message: Component): void;
  /**
   * Sends a chat message from the entity represented by the given {@link Identity} (or the game using {@link Identity#nil()}) to this {@link Audience}.
   *
   * @param source the identity of the source of the message
   * @param message a message
   * @see Component
   * @since 4.0.0
  */
  sendMessage(source: Identity, message: Component): void;
  /**
   * Sends a chat message with a {@link Identity#nil() nil} identity to this {@link Audience}.
   *
   * @param message a message
   * @param type the type
   * @see Component
   * @see #sendMessage(Identified, ComponentLike, MessageType)
   * @see #sendMessage(Identity, ComponentLike, MessageType)
   * @since 4.1.0
  */
  sendMessage(message: ComponentLike, type: MessageType): void;
  /**
   * Sends a chat message from the given {@link Identified} to this {@link Audience}.
   *
   * @param source the source of the message
   * @param message a message
   * @param type the type
   * @see Component
   * @since 4.0.0
  */
  sendMessage(source: Identified, message: ComponentLike, type: MessageType): void;
  /**
   * Sends a chat message from the entity represented by the given {@link Identity} (or the game using {@link Identity#nil()}) to this {@link Audience}.
   *
   * @param source the identity of the source of the message
   * @param message a message
   * @param type the type
   * @see Component
   * @since 4.0.0
  */
  sendMessage(source: Identity, message: ComponentLike, type: MessageType): void;
  /**
   * Sends a chat message with a {@link Identity#nil() nil} identity to this {@link Audience}.
   *
   * @param message a message
   * @param type the type
   * @see Component
   * @see #sendMessage(Identified, Component, MessageType)
   * @see #sendMessage(Identity, Component, MessageType)
   * @since 4.1.0
  */
  sendMessage(message: Component, type: MessageType): void;
  /**
   * Sends a chat message.
   *
   * @param source the source of the message
   * @param message a message
   * @param type the type
   * @see Component
   * @since 4.0.0
  */
  sendMessage(source: Identified, message: Component, type: MessageType): void;
}
export interface CommandSender extends Audience, Permissible {}

}
declare module 'org.bukkit.event.server.ServerLoadEvent' {
import { Enum } from 'java.lang';
/**
 * Represents the context in which the enclosing event has been completed.
*/
export class LoadType extends Enum<LoadType> {
  static readonly STARTUP: LoadType;
  static readonly RELOAD: LoadType;
  static valueOf(name: string): LoadType;
  static values(): LoadType[];
}

}
declare module 'org.bukkit.event.raid' {
import { List } from 'java.util';
import { HandlerList, Cancellable } from 'org.bukkit.event';
import { Reason } from 'org.bukkit.event.raid.RaidStopEvent';
import { World, Raid } from 'org.bukkit';
import { WorldEvent } from 'org.bukkit.event.world';
import { Raider, Player } from 'org.bukkit.entity';
/**
 * Called when a {@link Raid} is triggered (e.g: a player with Bad Omen effect
 * enters a village).
*/
export class RaidTriggerEvent extends RaidEvent {
  constructor(raid: Raid, world: World, player: Player);
  /**
   * Returns the player who triggered the raid.
   *
   * @return triggering player
  */
  getPlayer(): Player;
  /**
   * Gets the cancellation state of this event. A cancelled event will not
   * be executed in the server, but will still pass to other plugins
   *
   * @return true if this event is cancelled
  */
  isCancelled(): boolean;
  /**
   * Sets the cancellation state of this event. A cancelled event will not
   * be executed in the server, but will still pass to other plugins.
   *
   * @param cancel true if you wish to cancel this event
  */
  setCancelled(cancel: boolean): void;
  getHandlers(): HandlerList;
  static getHandlerList(): HandlerList;
}
export interface RaidTriggerEvent extends RaidEvent, Cancellable {}
/**
 * Called when a {@link Raid} is stopped.
*/
export class RaidStopEvent extends RaidEvent {
  constructor(raid: Raid, world: World, reason: Reason);
  /**
   * Returns the stop reason.
   *
   * @return Reason
  */
  getReason(): Reason;
  getHandlers(): HandlerList;
  static getHandlerList(): HandlerList;
}
/**
 * This event is called when a {@link Raid} was complete with a clear result.
*/
export class RaidFinishEvent extends RaidEvent {
  constructor(raid: Raid, world: World, winners: Player[]);
  /**
   * Returns an immutable list contains all winners.
   * 
   * Note: Players who are considered as heroes but were not online at the
   * end would not be included in this list.
   *
   * @return winners
  */
  getWinners(): Player[];
  getHandlers(): HandlerList;
  static getHandlerList(): HandlerList;
}
/**
 * Called when a raid wave spawns.
*/
export class RaidSpawnWaveEvent extends RaidEvent {
  constructor(raid: Raid, world: World, leader: Raider | null, raiders: Raider[]);
  /**
   * Returns the patrol leader.
   *
   * @return {@link Raider}
  */
  getPatrolLeader(): Raider | null;
  /**
   * Returns all {@link Raider} that spawned in this wave.
   *
   * @return an immutable list of raiders
  */
  getRaiders(): Raider[];
  getHandlers(): HandlerList;
  static getHandlerList(): HandlerList;
}
/**
 * Represents events related to raids.
*/
export class RaidEvent extends WorldEvent {
  /**
   * Returns the raid involved with this event.
   *
   * @return Raid
  */
  getRaid(): Raid;
}

}
declare module 'org.bukkit.permissions' {
import { Enum } from 'java.lang';
import { Set, List, Map } from 'java.util';
import { TriState } from 'net.kyori.adventure.util';
import { Plugin } from 'org.bukkit.plugin';
/**
 * Represents a class which is to be notified when a {@link
 * PermissionAttachment} is removed from a {@link Permissible}
*/
export class PermissionRemovedExecutor {
  /**
   * Called when a {@link PermissionAttachment} is removed from a {@link
   * Permissible}
   *
   * @param attachment Attachment which was removed
  */
  attachmentRemoved(attachment: PermissionAttachment): void;
}
/**
 * Holds information about a permission attachment on a {@link Permissible}
 * object
*/
export class PermissionAttachment {
  constructor(plugin: Plugin, permissible: Permissible);
  /**
   * Gets the plugin responsible for this attachment
   *
   * @return Plugin responsible for this permission attachment
  */
  getPlugin(): Plugin;
  /**
   * Sets an object to be called for when this attachment is removed from a
   * {@link Permissible}. May be null.
   *
   * @param ex Object to be called when this is removed
  */
  setRemovalCallback(removalCallback: PermissionRemovedExecutor | null);
  /**
   * Gets the class that was previously set to be called when this
   * attachment was removed from a {@link Permissible}. May be null.
   *
   * @return Object to be called when this is removed
  */
  getRemovalCallback(): PermissionRemovedExecutor | null;
  /**
   * Gets the Permissible that this is attached to
   *
   * @return Permissible containing this attachment
  */
  getPermissible(): Permissible;
  /**
   * Gets a copy of all set permissions and values contained within this
   * attachment.
   * 
   * This map may be modified but will not affect the attachment, as it is a
   * copy.
   *
   * @return Copy of all permissions and values expressed by this attachment
  */
  getPermissions(): Map<string, boolean>;
  /**
   * Sets a permission to the given value, by its fully qualified name
   *
   * @param name Name of the permission
   * @param value New value of the permission
  */
  setPermission(name: string, value: boolean): void;
  /**
   * Sets a permission to the given value
   *
   * @param perm Permission to set
   * @param value New value of the permission
  */
  setPermission(perm: Permission, value: boolean): void;
  /**
   * Removes the specified permission from this attachment.
   * 
   * If the permission does not exist in this attachment, nothing will
   * happen.
   *
   * @param name Name of the permission to remove
  */
  unsetPermission(name: string): void;
  /**
   * Removes the specified permission from this attachment.
   * 
   * If the permission does not exist in this attachment, nothing will
   * happen.
   *
   * @param perm Permission to remove
  */
  unsetPermission(perm: Permission): void;
  /**
   * Removes this attachment from its registered {@link Permissible}
   *
   * @return true if the permissible was removed successfully, false if it
   *     did not exist
  */
  remove(): boolean;
}
/**
 * Represents an object that may become a server operator, such as a {@link
 * Player}
*/
export class ServerOperator {
  /**
   * Checks if this object is a server operator
   *
   * @return true if this is an operator, otherwise false
  */
  isOp(): boolean;
  /**
   * Sets the operator status of this object
   *
   * @param value New operator value
  */
  setOp(value: boolean): void;
}
/**
 * Represents the possible default values for permissions
*/
export class PermissionDefault extends Enum<PermissionDefault> {
  static readonly TRUE: PermissionDefault;
  static readonly FALSE: PermissionDefault;
  static readonly OP: PermissionDefault;
  static readonly NOT_OP: PermissionDefault;
  static valueOf(name: string): PermissionDefault;
  static values(): PermissionDefault[];
  /**
   * Calculates the value of this PermissionDefault for the given operator
   * value
   *
   * @param op If the target is op
   * @return True if the default should be true, or false
  */
  getValue(op: boolean): boolean;
  /**
   * Looks up a PermissionDefault by name
   *
   * @param name Name of the default
   * @return Specified value, or null if not found
  */
  static getByName(name: string): PermissionDefault | null;
  toString(): string;
}
/**
 * Represents a unique permission that may be attached to a {@link
 * Permissible}
*/
export class Permission {
  static readonly DEFAULT_PERMISSION: PermissionDefault;
  constructor(name: string);
  constructor(name: string, description: string | null);
  constructor(name: string, defaultValue: PermissionDefault | null);
  constructor(name: string, description: string | null, defaultValue: PermissionDefault | null);
  constructor(name: string, children: Map<string, boolean> | null);
  constructor(name: string, description: string | null, children: Map<string, boolean> | null);
  constructor(name: string, defaultValue: PermissionDefault | null, children: Map<string, boolean> | null);
  constructor(name: string, description: string | null, defaultValue: PermissionDefault | null, children: Map<string, boolean> | null);
  /**
   * Returns the unique fully qualified name of this Permission
   *
   * @return Fully qualified name
  */
  getName(): string;
  /**
   * Gets the children of this permission.
   * 
   * If you change this map in any form, you must call {@link
   * #recalculatePermissibles()} to recalculate all {@link Permissible}s
   *
   * @return Permission children
  */
  getChildren(): Map<string, boolean>;
  /**
   * Gets the default value of this permission.
   *
   * @return Default value of this permission.
  */
  getDefault(): PermissionDefault;
  /**
   * Sets the default value of this permission.
   * 
   * This will not be saved to disk, and is a temporary operation until the
   * server reloads permissions. Changing this default will cause all {@link
   * Permissible}s that contain this permission to recalculate their
   * permissions
   *
   * @param value The new default to set
  */
  setDefault(default_: PermissionDefault);
  /**
   * Gets a brief description of this permission, may be empty
   *
   * @return Brief description of this permission
  */
  getDescription(): string;
  /**
   * Sets the description of this permission.
   * 
   * This will not be saved to disk, and is a temporary operation until the
   * server reloads permissions.
   *
   * @param value The new description to set
  */
  setDescription(description: string | null);
  /**
   * Gets a set containing every {@link Permissible} that has this
   * permission.
   * 
   * This set cannot be modified.
   *
   * @return Set containing permissibles with this permission
  */
  getPermissibles(): Set<Permissible>;
  /**
   * Recalculates all {@link Permissible}s that contain this permission.
   * 
   * This should be called after modifying the children, and is
   * automatically called after modifying the default value
  */
  recalculatePermissibles(): void;
  /**
   * Adds this permission to the specified parent permission.
   * 
   * If the parent permission does not exist, it will be created and
   * registered.
   *
   * @param name Name of the parent permission
   * @param value The value to set this permission to
   * @return Parent permission it created or loaded
  */
  addParent(name: string, value: boolean): Permission;
  /**
   * Adds this permission to the specified parent permission.
   *
   * @param perm Parent permission to register with
   * @param value The value to set this permission to
  */
  addParent(perm: Permission, value: boolean): void;
  /**
   * Loads a list of Permissions from a map of data, usually used from
   * retrieval from a yaml file.
   * 
   * The data may contain a list of name:data, where the data contains the
   * following keys:
   * 
   * default: Boolean true or false. If not specified, false.
   * children: `Map` of child permissions. If not
   *     specified, empty list.
   * description: Short string containing a very small description of
   *     this description. If not specified, empty string.
   * 
   *
   * @param data Map of permissions
   * @param error An error message to show if a permission is invalid. May contain "%s" format tag, which will be replaced with the name of invalid permission.
   * @param def Default permission value to use if missing
   * @return Permission object
  */
  static loadPermissions(data: Map<any, any>, error: string, def: PermissionDefault | null): Permission[];
  /**
   * Loads a Permission from a map of data, usually used from retrieval from
   * a yaml file.
   * 
   * The data may contain the following keys:
   * 
   * default: Boolean true or false. If not specified, false.
   * children: `Map` of child permissions. If not
   *     specified, empty list.
   * description: Short string containing a very small description of
   *     this description. If not specified, empty string.
   * 
   *
   * @param name Name of the permission
   * @param data Map of keys
   * @return Permission object
  */
  static loadPermission(name: string, data: Map<string, any>): Permission;
  /**
   * Loads a Permission from a map of data, usually used from retrieval from
   * a yaml file.
   * 
   * The data may contain the following keys:
   * 
   * default: Boolean true or false. If not specified, false.
   * children: `Map` of child permissions. If not
   *     specified, empty list.
   * description: Short string containing a very small description of
   *     this description. If not specified, empty string.
   * 
   *
   * @param name Name of the permission
   * @param data Map of keys
   * @param def Default permission value to use if not set
   * @param output A list to append any created child-Permissions to, may be null
   * @return Permission object
  */
  static loadPermission(name: string, data: Map<any, any>, def: PermissionDefault | null, output: Permission[] | null): Permission;
}
/**
 * Base Permissible for use in any Permissible object via proxy or extension
*/
export class PermissibleBase extends Permissible {
  constructor(opable: ServerOperator | null);
  /**
   * Checks if this object is a server operator
   *
   * @return true if this is an operator, otherwise false
  */
  isOp(): boolean;
  /**
   * Sets the operator status of this object
   *
   * @param value New operator value
  */
  setOp(value: boolean): void;
  /**
   * Checks if this object contains an override for the specified
   * permission, by fully qualified name
   *
   * @param name Name of the permission
   * @return true if the permission is set, otherwise false
  */
  isPermissionSet(name: string): boolean;
  /**
   * Checks if this object contains an override for the specified
   * permission, by fully qualified name
   *
   * @param name Name of the permission
   * @return true if the permission is set, otherwise false
  */
  isPermissionSet(perm: Permission): boolean;
  /**
   * Gets the value of the specified permission, if set.
   * 
   * If a permission override is not set on this object, the default value
   * of the permission will be returned.
   *
   * @param name Name of the permission
   * @return Value of the permission
  */
  hasPermission(inName: string): boolean;
  /**
   * Gets the value of the specified permission, if set.
   * 
   * If a permission override is not set on this object, the default value
   * of the permission will be returned.
   *
   * @param name Name of the permission
   * @return Value of the permission
  */
  hasPermission(perm: Permission): boolean;
  /**
   * Adds a new {@link PermissionAttachment} with a single permission by
   * name and value
   *
   * @param plugin Plugin responsible for this attachment, may not be null
   *     or disabled
   * @param name Name of the permission to attach
   * @param value Value of the permission
   * @return The PermissionAttachment that was just created
  */
  addAttachment(plugin: Plugin, name: string, value: boolean): PermissionAttachment;
  /**
   * Adds a new {@link PermissionAttachment} with a single permission by
   * name and value
   *
   * @param plugin Plugin responsible for this attachment, may not be null
   *     or disabled
   * @param name Name of the permission to attach
   * @param value Value of the permission
   * @return The PermissionAttachment that was just created
  */
  addAttachment(plugin: Plugin): PermissionAttachment;
  /**
   * Removes the given {@link PermissionAttachment} from this object
   *
   * @param attachment Attachment to remove
   * @throws IllegalArgumentException Thrown when the specified attachment
   *     isn't part of this object
  */
  removeAttachment(attachment: PermissionAttachment): void;
  /**
   * Recalculates the permissions for this object, if the attachments have
   * changed values.
   * 
   * This should very rarely need to be called from a plugin.
  */
  recalculatePermissions(): void;
  clearPermissions(): void;
  /**
   * Adds a new {@link PermissionAttachment} with a single permission by
   * name and value
   *
   * @param plugin Plugin responsible for this attachment, may not be null
   *     or disabled
   * @param name Name of the permission to attach
   * @param value Value of the permission
   * @return The PermissionAttachment that was just created
  */
  addAttachment(plugin: Plugin, name: string, value: boolean, ticks: number): PermissionAttachment | null;
  /**
   * Adds a new {@link PermissionAttachment} with a single permission by
   * name and value
   *
   * @param plugin Plugin responsible for this attachment, may not be null
   *     or disabled
   * @param name Name of the permission to attach
   * @param value Value of the permission
   * @return The PermissionAttachment that was just created
  */
  addAttachment(plugin: Plugin, ticks: number): PermissionAttachment | null;
  /**
   * Gets a set containing all of the permissions currently in effect by
   * this object
   *
   * @return Set of currently effective permissions
  */
  getEffectivePermissions(): Set<PermissionAttachmentInfo>;
}
/**
 * Holds information on a permission and which {@link PermissionAttachment}
 * provides it
*/
export class PermissionAttachmentInfo {
  constructor(permissible: Permissible, permission: string, attachment: PermissionAttachment | null, value: boolean);
  /**
   * Gets the permissible this is attached to
   *
   * @return Permissible this permission is for
  */
  getPermissible(): Permissible;
  /**
   * Gets the permission being set
   *
   * @return Name of the permission
  */
  getPermission(): string;
  /**
   * Gets the attachment providing this permission. This may be null for
   * default permissions (usually parent permissions).
   *
   * @return Attachment
  */
  getAttachment(): PermissionAttachment | null;
  /**
   * Gets the value of this permission
   *
   * @return Value of the permission
  */
  getValue(): boolean;
}
/**
 * Represents an object that may be assigned permissions
*/
export class Permissible extends ServerOperator {
  /**
   * Checks if this object contains an override for the specified
   * permission, by fully qualified name
   *
   * @param name Name of the permission
   * @return true if the permission is set, otherwise false
  */
  isPermissionSet(name: string): boolean;
  /**
   * Checks if this object contains an override for the specified {@link
   * Permission}
   *
   * @param perm Permission to check
   * @return true if the permission is set, otherwise false
  */
  isPermissionSet(perm: Permission): boolean;
  /**
   * Gets the value of the specified permission, if set.
   * 
   * If a permission override is not set on this object, the default value
   * of the permission will be returned.
   *
   * @param name Name of the permission
   * @return Value of the permission
  */
  hasPermission(name: string): boolean;
  /**
   * Gets the value of the specified permission, if set.
   * 
   * If a permission override is not set on this object, the default value
   * of the permission will be returned
   *
   * @param perm Permission to get
   * @return Value of the permission
  */
  hasPermission(perm: Permission): boolean;
  /**
   * Adds a new {@link PermissionAttachment} with a single permission by
   * name and value
   *
   * @param plugin Plugin responsible for this attachment, may not be null
   *     or disabled
   * @param name Name of the permission to attach
   * @param value Value of the permission
   * @return The PermissionAttachment that was just created
  */
  addAttachment(plugin: Plugin, name: string, value: boolean): PermissionAttachment;
  /**
   * Adds a new empty {@link PermissionAttachment} to this object
   *
   * @param plugin Plugin responsible for this attachment, may not be null
   *     or disabled
   * @return The PermissionAttachment that was just created
  */
  addAttachment(plugin: Plugin): PermissionAttachment;
  /**
   * Temporarily adds a new {@link PermissionAttachment} with a single
   * permission by name and value
   *
   * @param plugin Plugin responsible for this attachment, may not be null
   *     or disabled
   * @param name Name of the permission to attach
   * @param value Value of the permission
   * @param ticks Amount of ticks to automatically remove this attachment
   *     after
   * @return The PermissionAttachment that was just created
  */
  addAttachment(plugin: Plugin, name: string, value: boolean, ticks: number): PermissionAttachment | null;
  /**
   * Temporarily adds a new empty {@link PermissionAttachment} to this
   * object
   *
   * @param plugin Plugin responsible for this attachment, may not be null
   *     or disabled
   * @param ticks Amount of ticks to automatically remove this attachment
   *     after
   * @return The PermissionAttachment that was just created
  */
  addAttachment(plugin: Plugin, ticks: number): PermissionAttachment | null;
  /**
   * Removes the given {@link PermissionAttachment} from this object
   *
   * @param attachment Attachment to remove
   * @throws IllegalArgumentException Thrown when the specified attachment
   *     isn't part of this object
  */
  removeAttachment(attachment: PermissionAttachment): void;
  /**
   * Recalculates the permissions for this object, if the attachments have
   * changed values.
   * 
   * This should very rarely need to be called from a plugin.
  */
  recalculatePermissions(): void;
  /**
   * Gets a set containing all of the permissions currently in effect by
   * this object
   *
   * @return Set of currently effective permissions
  */
  getEffectivePermissions(): Set<PermissionAttachmentInfo>;
  /**
   * Checks if this object has a permission set and, if it is set, the value of the permission.
   *
   * @param permission the permission to check
   * @return a tri-state of if the permission is set and, if it is set, it's value
  */
  permissionValue(permission: Permission): TriState;
  /**
   * Checks if this object has a permission set and, if it is set, the value of the permission.
   *
   * @param permission the permission to check
   * @return a tri-state of if the permission is set and, if it is set, it's value
  */
  permissionValue(permission: string): TriState;
}

}
declare module 'org.bukkit.Particle' {
import { Color } from 'org.bukkit';
/**
 * Options which can be applied to redstone dust particles - a particle
 * color and size.
*/
export class DustOptions {
  constructor(color: Color, size: number);
  /**
   * The color of the particles to be displayed.
   *
   * @return particle color
  */
  getColor(): Color;
  /**
   * Relative size of the particle.
   *
   * @return relative particle size
  */
  getSize(): number;
}
/**
 * Options which can be applied to a color transitioning dust particles.
*/
export class DustTransition extends DustOptions {
  constructor(fromColor: Color, toColor: Color, size: number);
  /**
   * The final of the particles to be displayed.
   *
   * @return final particle color
  */
  getToColor(): Color;
}

}
declare module 'org.bukkit.block.data.type.BigDripleaf' {
import { Enum } from 'java.lang';
/**
 * The tilt of a leaf.
*/
export class Tilt extends Enum<Tilt> {
  /**
   * No tilt.
  */
  static readonly NONE: Tilt;
  /**
   * Unstable tilt.
  */
  static readonly UNSTABLE: Tilt;
  /**
   * Partial tilt.
  */
  static readonly PARTIAL: Tilt;
  /**
   * Pinball.
  */
  static readonly FULL: Tilt;
  static valueOf(name: string): Tilt;
  static values(): Tilt[];
}

}
declare module 'org.bukkit.block.data.type.RedstoneWire' {
import { Enum } from 'java.lang';
/**
 * The way in which a redstone wire can connect to an adjacent block face.
*/
export class Connection extends Enum<Connection> {
  /**
   * The wire travels up the side of the block adjacent to this face.
  */
  static readonly UP: Connection;
  /**
   * The wire travels flat from this face and into the adjacent block.
  */
  static readonly SIDE: Connection;
  /**
   * The wire does not connect in this direction.
  */
  static readonly NONE: Connection;
  static valueOf(name: string): Connection;
  static values(): Connection[];
}

}
declare module 'org.bukkit.block.data' {
import { AttachedFace } from 'org.bukkit.block.data.FaceAttachable';
import { Set } from 'java.util';
import { Cloneable } from 'java.lang';
import { BlockFace } from 'org.bukkit.block';
import { Half } from 'org.bukkit.block.data.Bisected';
import { Shape } from 'org.bukkit.block.data.Rail';
import { SoundGroup, Material, Axis } from 'org.bukkit';
/**
 * 'lit' denotes whether this block (either a redstone torch or furnace) is
 * currently lit - that is not burned out.
*/
export class Lightable extends BlockData {
  /**
   * Gets the value of the 'lit' property.
   *
   * @return the 'lit' value
  */
  isLit(): boolean;
  /**
   * Sets the value of the 'lit' property.
   *
   * @param lit the new 'lit' value
  */
  setLit(lit: boolean): void;
}
/**
 * 'facing' represents the face towards which the block is pointing.
 * 
 * Some blocks may not be able to face in all directions, use
 * {@link #getFaces()} to get all possible directions for this block.
*/
export class Directional extends BlockData {
  /**
   * Gets the value of the 'facing' property.
   *
   * @return the 'facing' value
  */
  getFacing(): BlockFace;
  /**
   * Sets the value of the 'facing' property.
   *
   * @param facing the new 'facing' value
  */
  setFacing(facing: BlockFace);
  /**
   * Gets the faces which are applicable to this block.
   *
   * @return the allowed 'facing' values
  */
  getFaces(): Set<BlockFace>;
}
export class BlockData extends Cloneable {
  /**
   * Get the Material represented by this block data.
   *
   * @return the material
  */
  getMaterial(): Material;
  /**
   * Gets a string, which when passed into a method such as
   * {@link Server#createBlockData(java.lang.String)} will unambiguously
   * recreate this instance.
   *
   * @return serialized data string for this block
  */
  getAsString(): string;
  /**
   * Gets a string, which when passed into a method such as
   * {@link Server#createBlockData(java.lang.String)} will recreate this or a
   * similar instance where unspecified states (if any) may be optionally
   * omitted. If this instance was parsed and states are omitted, this exact
   * instance will be creatable when parsed again, else their equality cannot
   * be guaranteed.
   * 
   * This method will only take effect for BlockData instances created by
   * methods such as {@link Server#createBlockData(String)} or any similar
   * method whereby states are optionally defined. If otherwise, the result of
   * {@link #getAsString()} will be returned. The following behaviour would be
   * expected:
   * {@code
   * String dataString = "minecraft:chest[waterlogged=true]"
   * BlockData data = Bukkit.createBlockData(dataString);
   * dataString.equals(data.getAsString(true)); // This would return true
   * dataString.equals(data.getAsString(false)); // This would return false as all states are present
   * dataString.equals(data.getAsString()); // This is equivalent to the above, "getAsString(false)"
   * }
   *
   * @param hideUnspecified true if unspecified states should be omitted,
   * false if they are to be shown as performed by {@link #getAsString()}.
   *
   * @return serialized data string for this block
  */
  getAsString(hideUnspecified: boolean): string;
  /**
   * Merges all explicitly set states from the given data with this BlockData.
   * 
   * Note that the given data MUST have been created from one of the String
   * parse methods, e.g. {@link Server#createBlockData(java.lang.String)} and
   * not have been subsequently modified.
   * 
   * Note also that the block types must match identically.
   *
   * @param data the data to merge from
   * @return a new instance of this blockdata with the merged data
  */
  merge(data: BlockData): BlockData;
  /**
   * Checks if the specified BlockData matches this block data.
   * 
   * The semantics of this method are such that for manually created or
   * modified BlockData it has the same effect as
   * {@link Object#equals(java.lang.Object)}, whilst for parsed data (that to
   * which {@link #merge(org.bukkit.block.data.BlockData)} applies, it will
   * return true when the type and all explicitly set states match.
   * 
   * Note that these semantics mean that a.matches(b) may not be the same
   * as b.matches(a)
   *
   * @param data the data to match against (normally a parsed constant)
   * @return if there is a match
  */
  matches(data: BlockData | null): boolean;
  /**
   * Returns a copy of this BlockData.
   *
   * @return a copy of the block data
  */
  clone(): BlockData;
  /**
   * Gets the block's {@link SoundGroup} which can be used to get its step
   * sound, hit sound, and others.
   *
   * @return the sound effect group
  */
  getSoundGroup(): SoundGroup;
}
/**
 * 'half' denotes which half of a two block tall material this block is.
 * 
 * In game it may be referred to as either (top, bottom) or (upper, lower).
*/
export class Bisected extends BlockData {
  /**
   * Gets the value of the 'half' property.
   *
   * @return the 'half' value
  */
  getHalf(): Half;
  /**
   * Sets the value of the 'half' property.
   *
   * @param half the new 'half' value
  */
  setHalf(half: Half);
}
/**
 * 'rotation' represents the current rotation of this block.
*/
export class Rotatable extends BlockData {
  /**
   * Gets the value of the 'rotation' property.
   *
   * @return the 'rotation' value
  */
  getRotation(): BlockFace;
  /**
   * Sets the value of the 'rotation' property.
   *
   * @param rotation the new 'rotation' value
  */
  setRotation(rotation: BlockFace);
}
/**
 * 'face' represents the face to which a lever or button is stuck.
 * 
 * This is used in conjunction with {@link Directional} to compute the
 * orientation of these blocks.
*/
export class FaceAttachable extends BlockData {
  /**
   * Gets the value of the 'face' property.
   *
   * @return the 'face' value
  */
  getAttachedFace(): AttachedFace;
  /**
   * Sets the value of the 'face' property.
   *
   * @param face the new 'face' value
  */
  setAttachedFace(attachedFace: AttachedFace);
}
/**
 * 'age' represents the different growth stages that a crop-like block can go
 * through.
 * 
 * A value of 0 indicates that the crop was freshly planted, whilst a value
 * equal to {@link #getMaximumAge()} indicates that the crop is ripe and ready
 * to be harvested.
*/
export class Ageable extends BlockData {
  /**
   * Gets the value of the 'age' property.
   *
   * @return the 'age' value
  */
  getAge(): number;
  /**
   * Sets the value of the 'age' property.
   *
   * @param age the new 'age' value
  */
  setAge(age: number);
  /**
   * Gets the maximum allowed value of the 'age' property.
   *
   * @return the maximum 'age' value
  */
  getMaximumAge(): number;
}
/**
 * 'power' represents the redstone power level currently being emitted or
 * transmitted via this block.
 * 
 * May not be over 9000 or {@link #getMaximumPower()} (usually 15).
*/
export class AnaloguePowerable extends BlockData {
  /**
   * Gets the value of the 'power' property.
   *
   * @return the 'power' value
  */
  getPower(): number;
  /**
   * Sets the value of the 'power' property.
   *
   * @param power the new 'power' value
  */
  setPower(power: number);
  /**
   * Gets the maximum allowed value of the 'power' property.
   *
   * @return the maximum 'power' value
  */
  getMaximumPower(): number;
}
/**
 * 'axis' represents the axis along whilst this block is oriented.
 * 
 * Some blocks such as the portal block may not be able to be placed in all
 * orientations, use {@link #getAxes()} to retrieve all possible such
 * orientations.
*/
export class Orientable extends BlockData {
  /**
   * Gets the value of the 'axis' property.
   *
   * @return the 'axis' value
  */
  getAxis(): Axis;
  /**
   * Sets the value of the 'axis' property.
   *
   * @param axis the new 'axis' value
  */
  setAxis(axis: Axis);
  /**
   * Gets the axes which are applicable to this block.
   *
   * @return the allowed 'axis' values
  */
  getAxes(): Set<Axis>;
}
/**
 * 'waterlogged' denotes whether this block has fluid in it.
*/
export class Waterlogged extends BlockData {
  /**
   * Gets the value of the 'waterlogged' property.
   *
   * @return the 'waterlogged' value
  */
  isWaterlogged(): boolean;
  /**
   * Sets the value of the 'waterlogged' property.
   *
   * @param waterlogged the new 'waterlogged' value
  */
  setWaterlogged(waterlogged: boolean): void;
}
/**
 * 'attached' denotes whether a tripwire hook or string forms a complete
 * tripwire circuit and is ready to trigger.
 * 
 * Updating the property on a tripwire hook will change the texture to indicate
 * a connected string, but will not have any effect when used on the tripwire
 * string itself. It may however still be used to check whether the string forms
 * a circuit.
*/
export class Attachable extends BlockData {
  /**
   * Gets the value of the 'attached' property.
   *
   * @return the 'attached' value
  */
  isAttached(): boolean;
  /**
   * Sets the value of the 'attached' property.
   *
   * @param attached the new 'attached' value
  */
  setAttached(attached: boolean): void;
}
/**
 * 'shape' represents the current layout of a minecart rail.
 * 
 * Some types of rail may not be able to be laid out in all shapes, use
 * {@link #getShapes()} to get those applicable to this block.
*/
export class Rail extends Waterlogged {
  /**
   * Gets the value of the 'shape' property.
   *
   * @return the 'shape' value
  */
  getShape(): Shape;
  /**
   * Sets the value of the 'shape' property.
   *
   * @param shape the new 'shape' value
  */
  setShape(shape: Shape);
  /**
   * Gets the shapes which are applicable to this block.
   *
   * @return the allowed 'shape' values
  */
  getShapes(): Set<Shape>;
}
/**
 * 'powered' indicates whether this block is in the powered state or not, i.e.
 * receiving a redstone current of power > 0.
*/
export class Powerable extends BlockData {
  /**
   * Gets the value of the 'powered' property.
   *
   * @return the 'powered' value
  */
  isPowered(): boolean;
  /**
   * Sets the value of the 'powered' property.
   *
   * @param powered the new 'powered' value
  */
  setPowered(powered: boolean): void;
}
/**
 * 'snowy' denotes whether this block has a snow covered side and top texture
 * (normally because the block above is snow).
*/
export class Snowable extends BlockData {
  /**
   * Gets the value of the 'snowy' property.
   *
   * @return the 'snowy' value
  */
  isSnowy(): boolean;
  /**
   * Sets the value of the 'snowy' property.
   *
   * @param snowy the new 'snowy' value
  */
  setSnowy(snowy: boolean): void;
}
/**
 * 'level' represents the amount of fluid contained within this block, either by
 * itself or inside a cauldron.
 * 
 * In the case of water and lava blocks the levels have special meanings: a
 * level of 0 corresponds to a source block, 1-7 regular fluid heights, and 8-15
 * to "falling" fluids. All falling fluids have the same behaviour, but the
 * level corresponds to that of the block above them, equal to
 * this.level - 8
 * Note that counterintuitively, an adjusted level of 1 is the highest level,
 * whilst 7 is the lowest.
 * 
 * May not be higher than {@link #getMaximumLevel()}.
*/
export class Levelled extends BlockData {
  /**
   * Gets the value of the 'level' property.
   *
   * @return the 'level' value
  */
  getLevel(): number;
  /**
   * Sets the value of the 'level' property.
   *
   * @param level the new 'level' value
  */
  setLevel(level: number);
  /**
   * Gets the maximum allowed value of the 'level' property.
   *
   * @return the maximum 'level' value
  */
  getMaximumLevel(): number;
  /**
   * Gets the minimum allowed value of the 'level' property.
   *
   * @return the minimum 'level' value
  */
  getMinimumLevel(): number;
}
/**
 * This class encompasses the 'north', 'east', 'south', 'west', 'up', 'down'
 * boolean flags which are used to set which faces of the block textures are
 * displayed on.
 * 
 * Some blocks may not be able to have faces on all directions, use
 * {@link #getAllowedFaces()} to get all possible faces for this block. It is
 * not valid to call any methods on non-allowed faces.
*/
export class MultipleFacing extends BlockData {
  /**
   * Checks if this block has the specified face enabled.
   *
   * @param face to check
   * @return if face is enabled
  */
  hasFace(face: BlockFace): boolean;
  /**
   * Set whether this block has the specified face enabled.
   *
   * @param face to set
   * @param has the face
  */
  setFace(face: BlockFace, has: boolean): void;
  /**
   * Get all of the faces which are enabled on this block.
   *
   * @return all faces enabled
  */
  getFaces(): Set<BlockFace>;
  /**
   * Gets all of this faces which may be set on this block.
   *
   * @return all allowed faces
  */
  getAllowedFaces(): Set<BlockFace>;
}
/**
 * 'open' denotes whether this door-like block is currently opened.
*/
export class Openable extends BlockData {
  /**
   * Gets the value of the 'open' property.
   *
   * @return the 'open' value
  */
  isOpen(): boolean;
  /**
   * Sets the value of the 'open' property.
   *
   * @param open the new 'open' value
  */
  setOpen(open: boolean): void;
}

}
declare module 'org.bukkit.scheduler' {
import { Runnable, Thread } from 'java.lang';
import { List } from 'java.util';
import { Executor, Future, Callable } from 'java.util.concurrent';
import { Plugin } from 'org.bukkit.plugin';
import { Consumer } from 'java.util.function';
/**
 * Represents a task being executed by the scheduler
*/
export class BukkitTask {
  /**
   * Returns the taskId for the task.
   *
   * @return Task id number
  */
  getTaskId(): number;
  /**
   * Returns the Plugin that owns this task.
   *
   * @return The Plugin that owns the task
  */
  getOwner(): Plugin;
  /**
   * Returns true if the Task is a sync task.
   *
   * @return true if the task is run by main thread
  */
  isSync(): boolean;
  /**
   * Returns true if this task has been cancelled.
   *
   * @return true if the task has been cancelled
  */
  isCancelled(): boolean;
  /**
   * Will attempt to cancel this task.
  */
  cancel(): void;
}
export class BukkitScheduler {
  /**
   * Schedules a once off task to occur after a delay.
   * 
   * This task will be executed by the main server thread.
   *
   * @param plugin Plugin that owns the task
   * @param task Task to be executed
   * @param delay Delay in server ticks before executing task
   * @return Task id number (-1 if scheduling failed)
  */
  scheduleSyncDelayedTask(plugin: Plugin, task: Runnable, delay: number): number;
  /**
   * @param plugin Plugin that owns the task
   * @param task Task to be executed
   * @param delay Delay in server ticks before executing task
   * @return Task id number (-1 if scheduling failed)
   * @deprecated Use {@link BukkitRunnable#runTaskLater(Plugin, long)}
  */
  scheduleSyncDelayedTask(plugin: Plugin, task: BukkitRunnable, delay: number): number;
  /**
   * Schedules a once off task to occur as soon as possible.
   * 
   * This task will be executed by the main server thread.
   *
   * @param plugin Plugin that owns the task
   * @param task Task to be executed
   * @return Task id number (-1 if scheduling failed)
  */
  scheduleSyncDelayedTask(plugin: Plugin, task: Runnable): number;
  /**
   * @param plugin Plugin that owns the task
   * @param task Task to be executed
   * @return Task id number (-1 if scheduling failed)
   * @deprecated Use {@link BukkitRunnable#runTask(Plugin)}
  */
  scheduleSyncDelayedTask(plugin: Plugin, task: BukkitRunnable): number;
  /**
   * Schedules a repeating task.
   * 
   * This task will be executed by the main server thread.
   *
   * @param plugin Plugin that owns the task
   * @param task Task to be executed
   * @param delay Delay in server ticks before executing first repeat
   * @param period Period in server ticks of the task
   * @return Task id number (-1 if scheduling failed)
  */
  scheduleSyncRepeatingTask(plugin: Plugin, task: Runnable, delay: number, period: number): number;
  /**
   * @param plugin Plugin that owns the task
   * @param task Task to be executed
   * @param delay Delay in server ticks before executing first repeat
   * @param period Period in server ticks of the task
   * @return Task id number (-1 if scheduling failed)
   * @deprecated Use {@link BukkitRunnable#runTaskTimer(Plugin, long, long)}
  */
  scheduleSyncRepeatingTask(plugin: Plugin, task: BukkitRunnable, delay: number, period: number): number;
  /**
   * Asynchronous tasks should never access any API in Bukkit. Great care
   * should be taken to assure the thread-safety of asynchronous tasks.
   * 
   * Schedules a once off task to occur after a delay. This task will be
   * executed by a thread managed by the scheduler.
   *
   * @param plugin Plugin that owns the task
   * @param task Task to be executed
   * @param delay Delay in server ticks before executing task
   * @return Task id number (-1 if scheduling failed)
   * @deprecated This name is misleading, as it does not schedule "a sync"
   *     task, but rather, "an async" task
  */
  scheduleAsyncDelayedTask(plugin: Plugin, task: Runnable, delay: number): number;
  /**
   * Asynchronous tasks should never access any API in Bukkit. Great care
   * should be taken to assure the thread-safety of asynchronous tasks.
   * 
   * Schedules a once off task to occur as soon as possible. This task will
   * be executed by a thread managed by the scheduler.
   *
   * @param plugin Plugin that owns the task
   * @param task Task to be executed
   * @return Task id number (-1 if scheduling failed)
   * @deprecated This name is misleading, as it does not schedule "a sync"
   *     task, but rather, "an async" task
  */
  scheduleAsyncDelayedTask(plugin: Plugin, task: Runnable): number;
  /**
   * Asynchronous tasks should never access any API in Bukkit. Great care
   * should be taken to assure the thread-safety of asynchronous tasks.
   * 
   * Schedules a repeating task. This task will be executed by a thread
   * managed by the scheduler.
   *
   * @param plugin Plugin that owns the task
   * @param task Task to be executed
   * @param delay Delay in server ticks before executing first repeat
   * @param period Period in server ticks of the task
   * @return Task id number (-1 if scheduling failed)
   * @deprecated This name is misleading, as it does not schedule "a sync"
   *     task, but rather, "an async" task
  */
  scheduleAsyncRepeatingTask(plugin: Plugin, task: Runnable, delay: number, period: number): number;
  /**
   * Calls a method on the main thread and returns a Future object. This
   * task will be executed by the main server thread.
   * 
   * Note: The Future.get() methods must NOT be called from the main
   *     thread.
   * Note2: There is at least an average of 10ms latency until the
   *     isDone() method returns true.
   * 
   * @param  The callable's return type
   * @param plugin Plugin that owns the task
   * @param task Task to be executed
   * @return Future Future object related to the task
  */
  callSyncMethod<T>(plugin: Plugin, task: Callable<T>): Future<T>;
  /**
   * Removes task from scheduler.
   *
   * @param taskId Id number of task to be removed
  */
  cancelTask(taskId: number): void;
  /**
   * Removes all tasks associated with a particular plugin from the
   * scheduler.
   *
   * @param plugin Owner of tasks to be removed
  */
  cancelTasks(plugin: Plugin): void;
  /**
   * Check if the task currently running.
   * 
   * A repeating task might not be running currently, but will be running in
   * the future. A task that has finished, and does not repeat, will not be
   * running ever again.
   * 
   * Explicitly, a task is running if there exists a thread for it, and that
   * thread is alive.
   *
   * @param taskId The task to check.
   * 
   * @return If the task is currently running.
  */
  isCurrentlyRunning(taskId: number): boolean;
  /**
   * Check if the task queued to be run later.
   * 
   * If a repeating task is currently running, it might not be queued now
   * but could be in the future. A task that is not queued, and not running,
   * will not be queued again.
   *
   * @param taskId The task to check.
   * 
   * @return If the task is queued to be run.
  */
  isQueued(taskId: number): boolean;
  /**
   * Returns a list of all active workers.
   * 
   * This list contains asynch tasks that are being executed by separate
   * threads.
   *
   * @return Active workers
  */
  getActiveWorkers(): BukkitWorker[];
  /**
   * Returns a list of all pending tasks. The ordering of the tasks is not
   * related to their order of execution.
   *
   * @return Active workers
  */
  getPendingTasks(): BukkitTask[];
  /**
   * Returns a task that will run on the next server tick.
   *
   * @param plugin the reference to the plugin scheduling task
   * @param task the task to be run
   * @return a BukkitTask that contains the id number
   * @throws IllegalArgumentException if plugin is null
   * @throws IllegalArgumentException if task is null
  */
  runTask(plugin: Plugin, task: Runnable): BukkitTask;
  /**
   * Returns a task that will run on the next server tick.
   *
   * @param plugin the reference to the plugin scheduling task
   * @param task the task to be run
   * @throws IllegalArgumentException if plugin is null
   * @throws IllegalArgumentException if task is null
  */
  runTask(plugin: Plugin, task: Consumer<BukkitTask>): void;
  /**
   * @param plugin the reference to the plugin scheduling task
   * @param task the task to be run
   * @return a BukkitTask that contains the id number
   * @throws IllegalArgumentException if plugin is null
   * @throws IllegalArgumentException if task is null
   * @deprecated Use {@link BukkitRunnable#runTask(Plugin)}
  */
  runTask(plugin: Plugin, task: BukkitRunnable): BukkitTask;
  /**
   * Asynchronous tasks should never access any API in Bukkit. Great care
   * should be taken to assure the thread-safety of asynchronous tasks.
   * 
   * Returns a task that will run asynchronously.
   *
   * @param plugin the reference to the plugin scheduling task
   * @param task the task to be run
   * @return a BukkitTask that contains the id number
   * @throws IllegalArgumentException if plugin is null
   * @throws IllegalArgumentException if task is null
  */
  runTaskAsynchronously(plugin: Plugin, task: Runnable): BukkitTask;
  /**
   * Asynchronous tasks should never access any API in Bukkit. Great care
   * should be taken to assure the thread-safety of asynchronous tasks.
   * 
   * Returns a task that will run asynchronously.
   *
   * @param plugin the reference to the plugin scheduling task
   * @param task the task to be run
   * @throws IllegalArgumentException if plugin is null
   * @throws IllegalArgumentException if task is null
  */
  runTaskAsynchronously(plugin: Plugin, task: Consumer<BukkitTask>): void;
  /**
   * @param plugin the reference to the plugin scheduling task
   * @param task the task to be run
   * @return a BukkitTask that contains the id number
   * @throws IllegalArgumentException if plugin is null
   * @throws IllegalArgumentException if task is null
   * @deprecated Use {@link BukkitRunnable#runTaskAsynchronously(Plugin)}
  */
  runTaskAsynchronously(plugin: Plugin, task: BukkitRunnable): BukkitTask;
  /**
   * Returns a task that will run after the specified number of server
   * ticks.
   *
   * @param plugin the reference to the plugin scheduling task
   * @param task the task to be run
   * @param delay the ticks to wait before running the task
   * @return a BukkitTask that contains the id number
   * @throws IllegalArgumentException if plugin is null
   * @throws IllegalArgumentException if task is null
  */
  runTaskLater(plugin: Plugin, task: Runnable, delay: number): BukkitTask;
  /**
   * Returns a task that will run after the specified number of server
   * ticks.
   *
   * @param plugin the reference to the plugin scheduling task
   * @param task the task to be run
   * @param delay the ticks to wait before running the task
   * @throws IllegalArgumentException if plugin is null
   * @throws IllegalArgumentException if task is null
  */
  runTaskLater(plugin: Plugin, task: Consumer<BukkitTask>, delay: number): void;
  /**
   * @param plugin the reference to the plugin scheduling task
   * @param task the task to be run
   * @param delay the ticks to wait before running the task
   * @return a BukkitTask that contains the id number
   * @throws IllegalArgumentException if plugin is null
   * @throws IllegalArgumentException if task is null
   * @deprecated Use {@link BukkitRunnable#runTaskLater(Plugin, long)}
  */
  runTaskLater(plugin: Plugin, task: BukkitRunnable, delay: number): BukkitTask;
  /**
   * Asynchronous tasks should never access any API in Bukkit. Great care
   * should be taken to assure the thread-safety of asynchronous tasks.
   * 
   * Returns a task that will run asynchronously after the specified number
   * of server ticks.
   *
   * @param plugin the reference to the plugin scheduling task
   * @param task the task to be run
   * @param delay the ticks to wait before running the task
   * @return a BukkitTask that contains the id number
   * @throws IllegalArgumentException if plugin is null
   * @throws IllegalArgumentException if task is null
  */
  runTaskLaterAsynchronously(plugin: Plugin, task: Runnable, delay: number): BukkitTask;
  /**
   * Asynchronous tasks should never access any API in Bukkit. Great care
   * should be taken to assure the thread-safety of asynchronous tasks.
   * 
   * Returns a task that will run asynchronously after the specified number
   * of server ticks.
   *
   * @param plugin the reference to the plugin scheduling task
   * @param task the task to be run
   * @param delay the ticks to wait before running the task
   * @throws IllegalArgumentException if plugin is null
   * @throws IllegalArgumentException if task is null
  */
  runTaskLaterAsynchronously(plugin: Plugin, task: Consumer<BukkitTask>, delay: number): void;
  /**
   * @param plugin the reference to the plugin scheduling task
   * @param task the task to be run
   * @param delay the ticks to wait before running the task
   * @return a BukkitTask that contains the id number
   * @throws IllegalArgumentException if plugin is null
   * @throws IllegalArgumentException if task is null
   * @deprecated Use {@link BukkitRunnable#runTaskLaterAsynchronously(Plugin, long)}
  */
  runTaskLaterAsynchronously(plugin: Plugin, task: BukkitRunnable, delay: number): BukkitTask;
  /**
   * Returns a task that will repeatedly run until cancelled, starting after
   * the specified number of server ticks.
   *
   * @param plugin the reference to the plugin scheduling task
   * @param task the task to be run
   * @param delay the ticks to wait before running the task
   * @param period the ticks to wait between runs
   * @return a BukkitTask that contains the id number
   * @throws IllegalArgumentException if plugin is null
   * @throws IllegalArgumentException if task is null
  */
  runTaskTimer(plugin: Plugin, task: Runnable, delay: number, period: number): BukkitTask;
  /**
   * Returns a task that will repeatedly run until cancelled, starting after
   * the specified number of server ticks.
   *
   * @param plugin the reference to the plugin scheduling task
   * @param task the task to be run
   * @param delay the ticks to wait before running the task
   * @param period the ticks to wait between runs
   * @throws IllegalArgumentException if plugin is null
   * @throws IllegalArgumentException if task is null
  */
  runTaskTimer(plugin: Plugin, task: Consumer<BukkitTask>, delay: number, period: number): void;
  /**
   * @param plugin the reference to the plugin scheduling task
   * @param task the task to be run
   * @param delay the ticks to wait before running the task
   * @param period the ticks to wait between runs
   * @return a BukkitTask that contains the id number
   * @throws IllegalArgumentException if plugin is null
   * @throws IllegalArgumentException if task is null
   * @deprecated Use {@link BukkitRunnable#runTaskTimer(Plugin, long, long)}
  */
  runTaskTimer(plugin: Plugin, task: BukkitRunnable, delay: number, period: number): BukkitTask;
  /**
   * Asynchronous tasks should never access any API in Bukkit. Great care
   * should be taken to assure the thread-safety of asynchronous tasks.
   * 
   * Returns a task that will repeatedly run asynchronously until cancelled,
   * starting after the specified number of server ticks.
   *
   * @param plugin the reference to the plugin scheduling task
   * @param task the task to be run
   * @param delay the ticks to wait before running the task for the first
   *     time
   * @param period the ticks to wait between runs
   * @return a BukkitTask that contains the id number
   * @throws IllegalArgumentException if plugin is null
   * @throws IllegalArgumentException if task is null
  */
  runTaskTimerAsynchronously(plugin: Plugin, task: Runnable, delay: number, period: number): BukkitTask;
  /**
   * Asynchronous tasks should never access any API in Bukkit. Great care
   * should be taken to assure the thread-safety of asynchronous tasks.
   * 
   * Returns a task that will repeatedly run asynchronously until cancelled,
   * starting after the specified number of server ticks.
   *
   * @param plugin the reference to the plugin scheduling task
   * @param task the task to be run
   * @param delay the ticks to wait before running the task for the first
   *     time
   * @param period the ticks to wait between runs
   * @throws IllegalArgumentException if plugin is null
   * @throws IllegalArgumentException if task is null
  */
  runTaskTimerAsynchronously(plugin: Plugin, task: Consumer<BukkitTask>, delay: number, period: number): void;
  /**
   * @param plugin the reference to the plugin scheduling task
   * @param task the task to be run
   * @param delay the ticks to wait before running the task for the first
   *     time
   * @param period the ticks to wait between runs
   * @return a BukkitTask that contains the id number
   * @throws IllegalArgumentException if plugin is null
   * @throws IllegalArgumentException if task is null
   * @deprecated Use {@link BukkitRunnable#runTaskTimerAsynchronously(Plugin, long, long)}
  */
  runTaskTimerAsynchronously(plugin: Plugin, task: BukkitRunnable, delay: number, period: number): BukkitTask;
  /**
   * Returns an executor that will run tasks on the next server tick.
   *
   * @param plugin the reference to the plugin scheduling tasks
   * @return an executor associated with the given plugin
  */
  getMainThreadExecutor(plugin: Plugin): Executor;
}
/**
 * Represents a worker thread for the scheduler. This gives information about
 * the Thread object for the task, owner of the task and the taskId.
 * 
 * Workers are used to execute async tasks.
*/
export class BukkitWorker {
  /**
   * Returns the taskId for the task being executed by this worker.
   *
   * @return Task id number
  */
  getTaskId(): number;
  /**
   * Returns the Plugin that owns this task.
   *
   * @return The Plugin that owns the task
  */
  getOwner(): Plugin;
  /**
   * Returns the thread for the worker.
   *
   * @return The Thread object for the worker
  */
  getThread(): Thread;
}
/**
 * This class is provided as an easy way to handle scheduling tasks.
*/
export class BukkitRunnable extends Runnable {
  /**
   * Returns true if this task has been cancelled.
   *
   * @return true if the task has been cancelled
   * @throws IllegalStateException if task was not scheduled yet
  */
  isCancelled(): boolean;
  /**
   * Attempts to cancel this task.
   *
   * @throws IllegalStateException if task was not scheduled yet
  */
  cancel(): void;
  /**
   * Schedules this in the Bukkit scheduler to run on next tick.
   *
   * @param plugin the reference to the plugin scheduling task
   * @return a BukkitTask that contains the id number
   * @throws IllegalArgumentException if plugin is null
   * @throws IllegalStateException if this was already scheduled
   * @see BukkitScheduler#runTask(Plugin, Runnable)
  */
  runTask(plugin: Plugin): BukkitTask;
  /**
   * Asynchronous tasks should never access any API in Bukkit. Great care
   * should be taken to assure the thread-safety of asynchronous tasks.
   * 
   * Schedules this in the Bukkit scheduler to run asynchronously.
   *
   * @param plugin the reference to the plugin scheduling task
   * @return a BukkitTask that contains the id number
   * @throws IllegalArgumentException if plugin is null
   * @throws IllegalStateException if this was already scheduled
   * @see BukkitScheduler#runTaskAsynchronously(Plugin, Runnable)
  */
  runTaskAsynchronously(plugin: Plugin): BukkitTask;
  /**
   * Schedules this to run after the specified number of server ticks.
   *
   * @param plugin the reference to the plugin scheduling task
   * @param delay the ticks to wait before running the task
   * @return a BukkitTask that contains the id number
   * @throws IllegalArgumentException if plugin is null
   * @throws IllegalStateException if this was already scheduled
   * @see BukkitScheduler#runTaskLater(Plugin, Runnable, long)
  */
  runTaskLater(plugin: Plugin, delay: number): BukkitTask;
  /**
   * Asynchronous tasks should never access any API in Bukkit. Great care
   * should be taken to assure the thread-safety of asynchronous tasks.
   * 
   * Schedules this to run asynchronously after the specified number of
   * server ticks.
   *
   * @param plugin the reference to the plugin scheduling task
   * @param delay the ticks to wait before running the task
   * @return a BukkitTask that contains the id number
   * @throws IllegalArgumentException if plugin is null
   * @throws IllegalStateException if this was already scheduled
   * @see BukkitScheduler#runTaskLaterAsynchronously(Plugin, Runnable, long)
  */
  runTaskLaterAsynchronously(plugin: Plugin, delay: number): BukkitTask;
  /**
   * Schedules this to repeatedly run until cancelled, starting after the
   * specified number of server ticks.
   *
   * @param plugin the reference to the plugin scheduling task
   * @param delay the ticks to wait before running the task
   * @param period the ticks to wait between runs
   * @return a BukkitTask that contains the id number
   * @throws IllegalArgumentException if plugin is null
   * @throws IllegalStateException if this was already scheduled
   * @see BukkitScheduler#runTaskTimer(Plugin, Runnable, long, long)
  */
  runTaskTimer(plugin: Plugin, delay: number, period: number): BukkitTask;
  /**
   * Asynchronous tasks should never access any API in Bukkit. Great care
   * should be taken to assure the thread-safety of asynchronous tasks.
   * 
   * Schedules this to repeatedly run asynchronously until cancelled,
   * starting after the specified number of server ticks.
   *
   * @param plugin the reference to the plugin scheduling task
   * @param delay the ticks to wait before running the task for the first
   *     time
   * @param period the ticks to wait between runs
   * @return a BukkitTask that contains the id number
   * @throws IllegalArgumentException if plugin is null
   * @throws IllegalStateException if this was already scheduled
   * @see BukkitScheduler#runTaskTimerAsynchronously(Plugin, Runnable, long,
   *     long)
  */
  runTaskTimerAsynchronously(plugin: Plugin, delay: number, period: number): BukkitTask;
  /**
   * Gets the task id for this runnable.
   *
   * @return the task id that this runnable was scheduled as
   * @throws IllegalStateException if task was not scheduled yet
  */
  getTaskId(): number;
}

}
declare module 'org.bukkit.block.data.type.TechnicalPiston' {
import { Enum } from 'java.lang';
/**
 * Different piston variants.
*/
export class Type extends Enum<Type> {
  /**
   * A normal piston which does not pull connected blocks backwards on
   * retraction.
  */
  static readonly NORMAL: Type;
  /**
   * A sticky piston which will also retract connected blocks.
  */
  static readonly STICKY: Type;
  static valueOf(name: string): Type;
  static values(): Type[];
}

}
declare module 'org.bukkit.event.entity.EntityUnleashEvent' {
import { Enum } from 'java.lang';
export class UnleashReason extends Enum<UnleashReason> {
  /**
   * When the entity's leashholder has died or logged out, and so is
   * unleashed
  */
  static readonly HOLDER_GONE: UnleashReason;
  /**
   * When the entity's leashholder attempts to unleash it
  */
  static readonly PLAYER_UNLEASH: UnleashReason;
  /**
   * When the entity's leashholder is more than 10 blocks away
  */
  static readonly DISTANCE: UnleashReason;
  static readonly UNKNOWN: UnleashReason;
  static valueOf(name: string): UnleashReason;
  static values(): UnleashReason[];
}

}
declare module 'org.bukkit.event.player.AsyncPlayerPreLoginEvent' {
import { Enum } from 'java.lang';
/**
 * Basic kick reasons for communicating to plugins
*/
export class Result extends Enum<Result> {
  /**
   * The player is allowed to log in
  */
  static readonly ALLOWED: Result;
  /**
   * The player is not allowed to log in, due to the server being full
  */
  static readonly KICK_FULL: Result;
  /**
   * The player is not allowed to log in, due to them being banned
  */
  static readonly KICK_BANNED: Result;
  /**
   * The player is not allowed to log in, due to them not being on the
   * white list
  */
  static readonly KICK_WHITELIST: Result;
  /**
   * The player is not allowed to log in, for reasons undefined
  */
  static readonly KICK_OTHER: Result;
  static valueOf(name: string): Result;
  static values(): Result[];
}

}
declare module 'org.bukkit.block.data.type.Chest' {
import { Enum } from 'java.lang';
/**
 * Type of this chest block.
 * 
 * NB: Left and right are relative to the chest itself, i.e opposite to what
 * a player placing the appropriate block would see.
*/
export class Type extends Enum<Type> {
  /**
   * The chest is not linked to any others and contains only one 27 slot
   * inventory.
  */
  static readonly SINGLE: Type;
  /**
   * The chest is the left hand side of a double chest and shares a 54
   * block inventory with the chest to its right.
  */
  static readonly LEFT: Type;
  /**
   * The chest is the right hand side of a double chest and shares a 54
   * block inventory with the chest to its left.
  */
  static readonly RIGHT: Type;
  static valueOf(name: string): Type;
  static values(): Type[];
}

}
declare module 'org.bukkit.World' {
import { Map } from 'java.util';
import { Enum } from 'java.lang';
import { Consumer } from 'java.util.function';
import { Chunk, Location } from 'org.bukkit';
import { LightningStrike } from 'org.bukkit.entity';
/**
 * This is the Legacy API before Java 8 was supported. Java 8 Consumer is provided,
 * as well as future support
 *
 * Used by {@link World#getChunkAtAsync(Location,ChunkLoadCallback)} methods
 * to request a {@link Chunk} to be loaded, with this callback receiving
 * the chunk when it is finished.
 *
 * This callback will be executed on synchronously on the main thread.
 *
 * Timing and order this callback is fired is intentionally not defined and
 * and subject to change.
 *
 * @deprecated Use either the Future or the Consumer based methods
*/
export class ChunkLoadCallback extends Consumer<Chunk> {
  onLoad(chunk: Chunk): void;
  accept(chunk: Chunk): void;
}
export class Spigot {
  /**
   * Strikes lightning at the given {@link Location} and possibly without sound
   *
   * @param loc The location to strike lightning
   * @param isSilent Whether this strike makes no sound
   * @return The lightning entity.
  */
  strikeLightning(loc: Location, isSilent: boolean): LightningStrike;
  /**
   * Strikes lightning at the given {@link Location} without doing damage and possibly without sound
   *
   * @param loc The location to strike lightning
   * @param isSilent Whether this strike makes no sound
   * @return The lightning entity.
  */
  strikeLightningEffect(loc: Location, isSilent: boolean): LightningStrike;
}
/**
 * Represents various map environment types that a world may be
*/
export class Environment extends Enum<Environment> {
  /**
   * Represents the "normal"/"surface world" map
  */
  static readonly NORMAL: Environment;
  /**
   * Represents a nether based map ("hell")
  */
  static readonly NETHER: Environment;
  /**
   * Represents the "end" map
  */
  static readonly THE_END: Environment;
  /**
   * Represents a custom dimension
  */
  static readonly CUSTOM: Environment;
  static valueOf(name: string): Environment;
  static values(): Environment[];
  /**
   * Gets the dimension ID of this environment
   *
   * @return dimension ID
   * @deprecated Magic value
  */
  getId(): number;
  /**
   * Get an environment by ID
   *
   * @param id The ID of the environment
   * @return The environment
   * @deprecated Magic value
  */
  static getEnvironment(id: number): Environment | null;
}

}
declare module 'org.bukkit.configuration' {
import { Set, List, Map } from 'java.util';
import { Throwable, Class, Exception } from 'java.lang';
import { Vector } from 'org.bukkit.util';
import { ItemStack } from 'org.bukkit.inventory';
import { Color, OfflinePlayer, Location } from 'org.bukkit';
/**
 * Various settings for controlling the input and output of a {@link
 * Configuration}
*/
export class ConfigurationOptions {
  /**
   * Returns the {@link Configuration} that this object is responsible for.
   *
   * @return Parent configuration
  */
  configuration(): Configuration;
  /**
   * Gets the char that will be used to separate {@link
   * ConfigurationSection}s
   * 
   * This value does not affect how the {@link Configuration} is stored,
   * only in how you access the data. The default value is '.'.
   *
   * @return Path separator
  */
  pathSeparator(): string;
  /**
   * Sets the char that will be used to separate {@link
   * ConfigurationSection}s
   * 
   * This value does not affect how the {@link Configuration} is stored,
   * only in how you access the data. The default value is '.'.
   *
   * @param value Path separator
   * @return This object, for chaining
  */
  pathSeparator(value: string): ConfigurationOptions;
  /**
   * Checks if the {@link Configuration} should copy values from its default
   * {@link Configuration} directly.
   * 
   * If this is true, all values in the default Configuration will be
   * directly copied, making it impossible to distinguish between values
   * that were set and values that are provided by default. As a result,
   * {@link ConfigurationSection#contains(java.lang.String)} will always
   * return the same value as {@link
   * ConfigurationSection#isSet(java.lang.String)}. The default value is
   * false.
   *
   * @return Whether or not defaults are directly copied
  */
  copyDefaults(): boolean;
  /**
   * Sets if the {@link Configuration} should copy values from its default
   * {@link Configuration} directly.
   * 
   * If this is true, all values in the default Configuration will be
   * directly copied, making it impossible to distinguish between values
   * that were set and values that are provided by default. As a result,
   * {@link ConfigurationSection#contains(java.lang.String)} will always
   * return the same value as {@link
   * ConfigurationSection#isSet(java.lang.String)}. The default value is
   * false.
   *
   * @param value Whether or not defaults are directly copied
   * @return This object, for chaining
  */
  copyDefaults(value: boolean): ConfigurationOptions;
}
/**
 * Represents a section of a {@link Configuration}
*/
export class ConfigurationSection {
  /**
   * Gets a set containing all keys in this section.
   * 
   * If deep is set to true, then this will contain all the keys within any
   * child {@link ConfigurationSection}s (and their children, etc). These
   * will be in a valid path notation for you to use.
   * 
   * If deep is set to false, then this will contain only the keys of any
   * direct children, and not their own children.
   *
   * @param deep Whether or not to get a deep list, as opposed to a shallow
   *     list.
   * @return Set of keys contained within this ConfigurationSection.
  */
  getKeys(deep: boolean): Set<string>;
  /**
   * Gets a Map containing all keys and their values for this section.
   * 
   * If deep is set to true, then this will contain all the keys and values
   * within any child {@link ConfigurationSection}s (and their children,
   * etc). These keys will be in a valid path notation for you to use.
   * 
   * If deep is set to false, then this will contain only the keys and
   * values of any direct children, and not their own children.
   *
   * @param deep Whether or not to get a deep list, as opposed to a shallow
   *     list.
   * @return Map of keys and values of this section.
  */
  getValues(deep: boolean): Map<string, any>;
  /**
   * Checks if this {@link ConfigurationSection} contains the given path.
   * 
   * If the value for the requested path does not exist but a default value
   * has been specified, this will return true.
   *
   * @param path Path to check for existence.
   * @return True if this section contains the requested path, either via
   *     default or being set.
   * @throws IllegalArgumentException Thrown when path is null.
  */
  contains(path: string): boolean;
  /**
   * Checks if this {@link ConfigurationSection} contains the given path.
   * 
   * If the value for the requested path does not exist, the boolean parameter
   * of true has been specified, a default value for the path exists, this
   * will return true.
   * 
   * If a boolean parameter of false has been specified, true will only be
   * returned if there is a set value for the specified path.
   *
   * @param path Path to check for existence.
   * @param ignoreDefault Whether or not to ignore if a default value for the
   * specified path exists.
   * @return True if this section contains the requested path, or if a default
   * value exist and the boolean parameter for this method is true.
   * @throws IllegalArgumentException Thrown when path is null.
  */
  contains(path: string, ignoreDefault: boolean): boolean;
  /**
   * Checks if this {@link ConfigurationSection} has a value set for the
   * given path.
   * 
   * If the value for the requested path does not exist but a default value
   * has been specified, this will still return false.
   *
   * @param path Path to check for existence.
   * @return True if this section contains the requested path, regardless of
   *     having a default.
   * @throws IllegalArgumentException Thrown when path is null.
  */
  isSet(path: string): boolean;
  /**
   * Gets the path of this {@link ConfigurationSection} from its root {@link
   * Configuration}
   * 
   * For any {@link Configuration} themselves, this will return an empty
   * string.
   * 
   * If the section is no longer contained within its root for any reason,
   * such as being replaced with a different value, this may return null.
   * 
   * To retrieve the single name of this section, that is, the final part of
   * the path returned by this method, you may use {@link #getName()}.
   *
   * @return Path of this section relative to its root
  */
  getCurrentPath(): string | null;
  /**
   * Gets the name of this individual {@link ConfigurationSection}, in the
   * path.
   * 
   * This will always be the final part of {@link #getCurrentPath()}, unless
   * the section is orphaned.
   *
   * @return Name of this section
  */
  getName(): string;
  /**
   * Gets the root {@link Configuration} that contains this {@link
   * ConfigurationSection}
   * 
   * For any {@link Configuration} themselves, this will return its own
   * object.
   * 
   * If the section is no longer contained within its root for any reason,
   * such as being replaced with a different value, this may return null.
   *
   * @return Root configuration containing this section.
  */
  getRoot(): Configuration | null;
  /**
   * Gets the parent {@link ConfigurationSection} that directly contains
   * this {@link ConfigurationSection}.
   * 
   * For any {@link Configuration} themselves, this will return null.
   * 
   * If the section is no longer contained within its parent for any reason,
   * such as being replaced with a different value, this may return null.
   *
   * @return Parent section containing this section.
  */
  getParent(): ConfigurationSection | null;
  /**
   * Gets the requested Object by path.
   * 
   * If the Object does not exist but a default value has been specified,
   * this will return the default value. If the Object does not exist and no
   * default value was specified, this will return null.
   *
   * @param path Path of the Object to get.
   * @return Requested Object.
  */
  get(path: string): any | null;
  /**
   * Gets the requested Object by path, returning a default value if not
   * found.
   * 
   * If the Object does not exist then the specified default value will
   * returned regardless of if a default has been identified in the root
   * {@link Configuration}.
   *
   * @param path Path of the Object to get.
   * @param def The default value to return if the path is not found.
   * @return Requested Object.
  */
  get(path: string, def: any | null): any | null;
  /**
   * Sets the specified path to the given value.
   * 
   * If value is null, the entry will be removed. Any existing entry will be
   * replaced, regardless of what the new value is.
   * 
   * Some implementations may have limitations on what you may store. See
   * their individual javadocs for details. No implementations should allow
   * you to store {@link Configuration}s or {@link ConfigurationSection}s,
   * please use {@link #createSection(java.lang.String)} for that.
   *
   * @param path Path of the object to set.
   * @param value New value to set the path to.
  */
  set(path: string, value: any | null): void;
  /**
   * Creates an empty {@link ConfigurationSection} at the specified path.
   * 
   * Any value that was previously set at this path will be overwritten. If
   * the previous value was itself a {@link ConfigurationSection}, it will
   * be orphaned.
   *
   * @param path Path to create the section at.
   * @return Newly created section
  */
  createSection(path: string): ConfigurationSection;
  /**
   * Creates a {@link ConfigurationSection} at the specified path, with
   * specified values.
   * 
   * Any value that was previously set at this path will be overwritten. If
   * the previous value was itself a {@link ConfigurationSection}, it will
   * be orphaned.
   *
   * @param path Path to create the section at.
   * @param map The values to used.
   * @return Newly created section
  */
  createSection(path: string, map: Map<any, any>): ConfigurationSection;
  /**
   * Gets the requested String by path.
   * 
   * If the String does not exist but a default value has been specified,
   * this will return the default value. If the String does not exist and no
   * default value was specified, this will return null.
   *
   * @param path Path of the String to get.
   * @return Requested String.
  */
  getString(path: string): string | null;
  /**
   * Gets the requested String by path, returning a default value if not
   * found.
   * 
   * If the String does not exist then the specified default value will
   * returned regardless of if a default has been identified in the root
   * {@link Configuration}.
   *
   * @param path Path of the String to get.
   * @param def The default value to return if the path is not found or is
   *     not a String.
   * @return Requested String.
  */
  getString(path: string, def: string | null): string | null;
  /**
   * Checks if the specified path is a String.
   * 
   * If the path exists but is not a String, this will return false. If the
   * path does not exist, this will return false. If the path does not exist
   * but a default value has been specified, this will check if that default
   * value is a String and return appropriately.
   *
   * @param path Path of the String to check.
   * @return Whether or not the specified path is a String.
  */
  isString(path: string): boolean;
  /**
   * Gets the requested int by path.
   * 
   * If the int does not exist but a default value has been specified, this
   * will return the default value. If the int does not exist and no default
   * value was specified, this will return 0.
   *
   * @param path Path of the int to get.
   * @return Requested int.
  */
  getInt(path: string): number;
  /**
   * Gets the requested int by path, returning a default value if not found.
   * 
   * If the int does not exist then the specified default value will
   * returned regardless of if a default has been identified in the root
   * {@link Configuration}.
   *
   * @param path Path of the int to get.
   * @param def The default value to return if the path is not found or is
   *     not an int.
   * @return Requested int.
  */
  getInt(path: string, def: number): number;
  /**
   * Checks if the specified path is an int.
   * 
   * If the path exists but is not a int, this will return false. If the
   * path does not exist, this will return false. If the path does not exist
   * but a default value has been specified, this will check if that default
   * value is a int and return appropriately.
   *
   * @param path Path of the int to check.
   * @return Whether or not the specified path is an int.
  */
  isInt(path: string): boolean;
  /**
   * Gets the requested boolean by path.
   * 
   * If the boolean does not exist but a default value has been specified,
   * this will return the default value. If the boolean does not exist and
   * no default value was specified, this will return false.
   *
   * @param path Path of the boolean to get.
   * @return Requested boolean.
  */
  getBoolean(path: string): boolean;
  /**
   * Gets the requested boolean by path, returning a default value if not
   * found.
   * 
   * If the boolean does not exist then the specified default value will
   * returned regardless of if a default has been identified in the root
   * {@link Configuration}.
   *
   * @param path Path of the boolean to get.
   * @param def The default value to return if the path is not found or is
   *     not a boolean.
   * @return Requested boolean.
  */
  getBoolean(path: string, def: boolean): boolean;
  /**
   * Checks if the specified path is a boolean.
   * 
   * If the path exists but is not a boolean, this will return false. If the
   * path does not exist, this will return false. If the path does not exist
   * but a default value has been specified, this will check if that default
   * value is a boolean and return appropriately.
   *
   * @param path Path of the boolean to check.
   * @return Whether or not the specified path is a boolean.
  */
  isBoolean(path: string): boolean;
  /**
   * Gets the requested double by path.
   * 
   * If the double does not exist but a default value has been specified,
   * this will return the default value. If the double does not exist and no
   * default value was specified, this will return 0.
   *
   * @param path Path of the double to get.
   * @return Requested double.
  */
  getDouble(path: string): number;
  /**
   * Gets the requested double by path, returning a default value if not
   * found.
   * 
   * If the double does not exist then the specified default value will
   * returned regardless of if a default has been identified in the root
   * {@link Configuration}.
   *
   * @param path Path of the double to get.
   * @param def The default value to return if the path is not found or is
   *     not a double.
   * @return Requested double.
  */
  getDouble(path: string, def: number): number;
  /**
   * Checks if the specified path is a double.
   * 
   * If the path exists but is not a double, this will return false. If the
   * path does not exist, this will return false. If the path does not exist
   * but a default value has been specified, this will check if that default
   * value is a double and return appropriately.
   *
   * @param path Path of the double to check.
   * @return Whether or not the specified path is a double.
  */
  isDouble(path: string): boolean;
  /**
   * Gets the requested long by path.
   * 
   * If the long does not exist but a default value has been specified, this
   * will return the default value. If the long does not exist and no
   * default value was specified, this will return 0.
   *
   * @param path Path of the long to get.
   * @return Requested long.
  */
  getLong(path: string): number;
  /**
   * Gets the requested long by path, returning a default value if not
   * found.
   * 
   * If the long does not exist then the specified default value will
   * returned regardless of if a default has been identified in the root
   * {@link Configuration}.
   *
   * @param path Path of the long to get.
   * @param def The default value to return if the path is not found or is
   *     not a long.
   * @return Requested long.
  */
  getLong(path: string, def: number): number;
  /**
   * Checks if the specified path is a long.
   * 
   * If the path exists but is not a long, this will return false. If the
   * path does not exist, this will return false. If the path does not exist
   * but a default value has been specified, this will check if that default
   * value is a long and return appropriately.
   *
   * @param path Path of the long to check.
   * @return Whether or not the specified path is a long.
  */
  isLong(path: string): boolean;
  /**
   * Gets the requested List by path.
   * 
   * If the List does not exist but a default value has been specified, this
   * will return the default value. If the List does not exist and no
   * default value was specified, this will return null.
   *
   * @param path Path of the List to get.
   * @return Requested List.
  */
  getList(path: string): any[] | null;
  /**
   * Gets the requested List by path, returning a default value if not
   * found.
   * 
   * If the List does not exist then the specified default value will
   * returned regardless of if a default has been identified in the root
   * {@link Configuration}.
   *
   * @param path Path of the List to get.
   * @param def The default value to return if the path is not found or is
   *     not a List.
   * @return Requested List.
  */
  getList(path: string, def: any[] | null): any[] | null;
  /**
   * Checks if the specified path is a List.
   * 
   * If the path exists but is not a List, this will return false. If the
   * path does not exist, this will return false. If the path does not exist
   * but a default value has been specified, this will check if that default
   * value is a List and return appropriately.
   *
   * @param path Path of the List to check.
   * @return Whether or not the specified path is a List.
  */
  isList(path: string): boolean;
  /**
   * Gets the requested List of String by path.
   * 
   * If the List does not exist but a default value has been specified, this
   * will return the default value. If the List does not exist and no
   * default value was specified, this will return an empty List.
   * 
   * This method will attempt to cast any values into a String if possible,
   * but may miss any values out if they are not compatible.
   *
   * @param path Path of the List to get.
   * @return Requested List of String.
  */
  getStringList(path: string): string[];
  /**
   * Gets the requested List of Integer by path.
   * 
   * If the List does not exist but a default value has been specified, this
   * will return the default value. If the List does not exist and no
   * default value was specified, this will return an empty List.
   * 
   * This method will attempt to cast any values into a Integer if possible,
   * but may miss any values out if they are not compatible.
   *
   * @param path Path of the List to get.
   * @return Requested List of Integer.
  */
  getIntegerList(path: string): number[];
  /**
   * Gets the requested List of Boolean by path.
   * 
   * If the List does not exist but a default value has been specified, this
   * will return the default value. If the List does not exist and no
   * default value was specified, this will return an empty List.
   * 
   * This method will attempt to cast any values into a Boolean if possible,
   * but may miss any values out if they are not compatible.
   *
   * @param path Path of the List to get.
   * @return Requested List of Boolean.
  */
  getBooleanList(path: string): boolean[];
  /**
   * Gets the requested List of Double by path.
   * 
   * If the List does not exist but a default value has been specified, this
   * will return the default value. If the List does not exist and no
   * default value was specified, this will return an empty List.
   * 
   * This method will attempt to cast any values into a Double if possible,
   * but may miss any values out if they are not compatible.
   *
   * @param path Path of the List to get.
   * @return Requested List of Double.
  */
  getDoubleList(path: string): number[];
  /**
   * Gets the requested List of Float by path.
   * 
   * If the List does not exist but a default value has been specified, this
   * will return the default value. If the List does not exist and no
   * default value was specified, this will return an empty List.
   * 
   * This method will attempt to cast any values into a Float if possible,
   * but may miss any values out if they are not compatible.
   *
   * @param path Path of the List to get.
   * @return Requested List of Float.
  */
  getFloatList(path: string): number[];
  /**
   * Gets the requested List of Long by path.
   * 
   * If the List does not exist but a default value has been specified, this
   * will return the default value. If the List does not exist and no
   * default value was specified, this will return an empty List.
   * 
   * This method will attempt to cast any values into a Long if possible,
   * but may miss any values out if they are not compatible.
   *
   * @param path Path of the List to get.
   * @return Requested List of Long.
  */
  getLongList(path: string): number[];
  /**
   * Gets the requested List of Byte by path.
   * 
   * If the List does not exist but a default value has been specified, this
   * will return the default value. If the List does not exist and no
   * default value was specified, this will return an empty List.
   * 
   * This method will attempt to cast any values into a Byte if possible,
   * but may miss any values out if they are not compatible.
   *
   * @param path Path of the List to get.
   * @return Requested List of Byte.
  */
  getByteList(path: string): number[];
  /**
   * Gets the requested List of Character by path.
   * 
   * If the List does not exist but a default value has been specified, this
   * will return the default value. If the List does not exist and no
   * default value was specified, this will return an empty List.
   * 
   * This method will attempt to cast any values into a Character if
   * possible, but may miss any values out if they are not compatible.
   *
   * @param path Path of the List to get.
   * @return Requested List of Character.
  */
  getCharacterList(path: string): string[];
  /**
   * Gets the requested List of Short by path.
   * 
   * If the List does not exist but a default value has been specified, this
   * will return the default value. If the List does not exist and no
   * default value was specified, this will return an empty List.
   * 
   * This method will attempt to cast any values into a Short if possible,
   * but may miss any values out if they are not compatible.
   *
   * @param path Path of the List to get.
   * @return Requested List of Short.
  */
  getShortList(path: string): number[];
  /**
   * Gets the requested List of Maps by path.
   * 
   * If the List does not exist but a default value has been specified, this
   * will return the default value. If the List does not exist and no
   * default value was specified, this will return an empty List.
   * 
   * This method will attempt to cast any values into a Map if possible, but
   * may miss any values out if they are not compatible.
   *
   * @param path Path of the List to get.
   * @return Requested List of Maps.
  */
  getMapList(path: string): Map<any, any>[];
  /**
   * Gets the requested object at the given path.
   *
   * If the Object does not exist but a default value has been specified, this
   * will return the default value. If the Object does not exist and no
   * default value was specified, this will return null.
   *
   * Note: For example #getObject(path, String.class) is not
   * equivalent to {@link #getString(String) #getString(path)} because
   * {@link #getString(String) #getString(path)} converts internally all
   * Objects to Strings. However, #getObject(path, Boolean.class) is
   * equivalent to {@link #getBoolean(String) #getBoolean(path)} for example.
   *
   * @param  the type of the requested object
   * @param path the path to the object.
   * @param clazz the type of the requested object
   * @return Requested object
  */
  getObject<T>(path: string, clazz: Class<T>): T | null;
  /**
   * Gets the requested object at the given path, returning a default value if
   * not found
   *
   * If the Object does not exist then the specified default value will
   * returned regardless of if a default has been identified in the root
   * {@link Configuration}.
   *
   * Note: For example #getObject(path, String.class, def) is
   * not equivalent to
   * {@link #getString(String, String) #getString(path, def)} because
   * {@link #getString(String, String) #getString(path, def)} converts
   * internally all Objects to Strings. However, #getObject(path,
   * Boolean.class, def) is equivalent to {@link #getBoolean(String, boolean) #getBoolean(path,
   * def)} for example.
   *
   * @param  the type of the requested object
   * @param path the path to the object.
   * @param clazz the type of the requested object
   * @param def the default object to return if the object is not present at
   * the path
   * @return Requested object
  */
  getObject<T>(path: string, clazz: Class<T>, def: T | null): T | null;
  /**
   * Gets the requested {@link ConfigurationSerializable} object at the given
   * path.
   *
   * If the Object does not exist but a default value has been specified, this
   * will return the default value. If the Object does not exist and no
   * default value was specified, this will return null.
   *
   * @param  the type of {@link ConfigurationSerializable}
   * @param path the path to the object.
   * @param clazz the type of {@link ConfigurationSerializable}
   * @return Requested {@link ConfigurationSerializable} object
  */
  getSerializable<T>(path: string, clazz: Class<T>): T | null;
  /**
   * Gets the requested {@link ConfigurationSerializable} object at the given
   * path, returning a default value if not found
   *
   * If the Object does not exist then the specified default value will
   * returned regardless of if a default has been identified in the root
   * {@link Configuration}.
   *
   * @param  the type of {@link ConfigurationSerializable}
   * @param path the path to the object.
   * @param clazz the type of {@link ConfigurationSerializable}
   * @param def the default object to return if the object is not present at
   * the path
   * @return Requested {@link ConfigurationSerializable} object
  */
  getSerializable<T>(path: string, clazz: Class<T>, def: T | null): T | null;
  /**
   * Gets the requested Vector by path.
   * 
   * If the Vector does not exist but a default value has been specified,
   * this will return the default value. If the Vector does not exist and no
   * default value was specified, this will return null.
   *
   * @param path Path of the Vector to get.
   * @return Requested Vector.
  */
  getVector(path: string): Vector | null;
  /**
   * Gets the requested {@link Vector} by path, returning a default value if
   * not found.
   * 
   * If the Vector does not exist then the specified default value will
   * returned regardless of if a default has been identified in the root
   * {@link Configuration}.
   *
   * @param path Path of the Vector to get.
   * @param def The default value to return if the path is not found or is
   *     not a Vector.
   * @return Requested Vector.
  */
  getVector(path: string, def: Vector | null): Vector | null;
  /**
   * Checks if the specified path is a Vector.
   * 
   * If the path exists but is not a Vector, this will return false. If the
   * path does not exist, this will return false. If the path does not exist
   * but a default value has been specified, this will check if that default
   * value is a Vector and return appropriately.
   *
   * @param path Path of the Vector to check.
   * @return Whether or not the specified path is a Vector.
  */
  isVector(path: string): boolean;
  /**
   * Gets the requested OfflinePlayer by path.
   * 
   * If the OfflinePlayer does not exist but a default value has been
   * specified, this will return the default value. If the OfflinePlayer
   * does not exist and no default value was specified, this will return
   * null.
   *
   * @param path Path of the OfflinePlayer to get.
   * @return Requested OfflinePlayer.
  */
  getOfflinePlayer(path: string): OfflinePlayer | null;
  /**
   * Gets the requested {@link OfflinePlayer} by path, returning a default
   * value if not found.
   * 
   * If the OfflinePlayer does not exist then the specified default value
   * will returned regardless of if a default has been identified in the
   * root {@link Configuration}.
   *
   * @param path Path of the OfflinePlayer to get.
   * @param def The default value to return if the path is not found or is
   *     not an OfflinePlayer.
   * @return Requested OfflinePlayer.
  */
  getOfflinePlayer(path: string, def: OfflinePlayer | null): OfflinePlayer | null;
  /**
   * Checks if the specified path is an OfflinePlayer.
   * 
   * If the path exists but is not a OfflinePlayer, this will return false.
   * If the path does not exist, this will return false. If the path does
   * not exist but a default value has been specified, this will check if
   * that default value is a OfflinePlayer and return appropriately.
   *
   * @param path Path of the OfflinePlayer to check.
   * @return Whether or not the specified path is an OfflinePlayer.
  */
  isOfflinePlayer(path: string): boolean;
  /**
   * Gets the requested ItemStack by path.
   * 
   * If the ItemStack does not exist but a default value has been specified,
   * this will return the default value. If the ItemStack does not exist and
   * no default value was specified, this will return null.
   *
   * @param path Path of the ItemStack to get.
   * @return Requested ItemStack.
  */
  getItemStack(path: string): ItemStack | null;
  /**
   * Gets the requested {@link ItemStack} by path, returning a default value
   * if not found.
   * 
   * If the ItemStack does not exist then the specified default value will
   * returned regardless of if a default has been identified in the root
   * {@link Configuration}.
   *
   * @param path Path of the ItemStack to get.
   * @param def The default value to return if the path is not found or is
   *     not an ItemStack.
   * @return Requested ItemStack.
  */
  getItemStack(path: string, def: ItemStack | null): ItemStack | null;
  /**
   * Checks if the specified path is an ItemStack.
   * 
   * If the path exists but is not a ItemStack, this will return false. If
   * the path does not exist, this will return false. If the path does not
   * exist but a default value has been specified, this will check if that
   * default value is a ItemStack and return appropriately.
   *
   * @param path Path of the ItemStack to check.
   * @return Whether or not the specified path is an ItemStack.
  */
  isItemStack(path: string): boolean;
  /**
   * Gets the requested Color by path.
   * 
   * If the Color does not exist but a default value has been specified,
   * this will return the default value. If the Color does not exist and no
   * default value was specified, this will return null.
   *
   * @param path Path of the Color to get.
   * @return Requested Color.
  */
  getColor(path: string): Color | null;
  /**
   * Gets the requested {@link Color} by path, returning a default value if
   * not found.
   * 
   * If the Color does not exist then the specified default value will
   * returned regardless of if a default has been identified in the root
   * {@link Configuration}.
   *
   * @param path Path of the Color to get.
   * @param def The default value to return if the path is not found or is
   *     not a Color.
   * @return Requested Color.
  */
  getColor(path: string, def: Color | null): Color | null;
  /**
   * Checks if the specified path is a Color.
   * 
   * If the path exists but is not a Color, this will return false. If the
   * path does not exist, this will return false. If the path does not exist
   * but a default value has been specified, this will check if that default
   * value is a Color and return appropriately.
   *
   * @param path Path of the Color to check.
   * @return Whether or not the specified path is a Color.
  */
  isColor(path: string): boolean;
  /**
   * Gets the requested Location by path.
   * 
   * If the Location does not exist but a default value has been specified,
   * this will return the default value. If the Location does not exist and no
   * default value was specified, this will return null.
   *
   * @param path Path of the Location to get.
   * @return Requested Location.
  */
  getLocation(path: string): Location | null;
  /**
   * Gets the requested {@link Location} by path, returning a default value if
   * not found.
   * 
   * If the Location does not exist then the specified default value will
   * returned regardless of if a default has been identified in the root
   * {@link Configuration}.
   *
   * @param path Path of the Location to get.
   * @param def The default value to return if the path is not found or is not
   * a Location.
   * @return Requested Location.
  */
  getLocation(path: string, def: Location | null): Location | null;
  /**
   * Checks if the specified path is a Location.
   * 
   * If the path exists but is not a Location, this will return false. If the
   * path does not exist, this will return false. If the path does not exist
   * but a default value has been specified, this will check if that default
   * value is a Location and return appropriately.
   *
   * @param path Path of the Location to check.
   * @return Whether or not the specified path is a Location.
  */
  isLocation(path: string): boolean;
  /**
   * Gets the requested ConfigurationSection by path.
   * 
   * If the ConfigurationSection does not exist but a default value has been
   * specified, this will return the default value. If the
   * ConfigurationSection does not exist and no default value was specified,
   * this will return null.
   *
   * @param path Path of the ConfigurationSection to get.
   * @return Requested ConfigurationSection.
  */
  getConfigurationSection(path: string): ConfigurationSection | null;
  /**
   * Checks if the specified path is a ConfigurationSection.
   * 
   * If the path exists but is not a ConfigurationSection, this will return
   * false. If the path does not exist, this will return false. If the path
   * does not exist but a default value has been specified, this will check
   * if that default value is a ConfigurationSection and return
   * appropriately.
   *
   * @param path Path of the ConfigurationSection to check.
   * @return Whether or not the specified path is a ConfigurationSection.
  */
  isConfigurationSection(path: string): boolean;
  /**
   * Gets the equivalent {@link ConfigurationSection} from the default
   * {@link Configuration} defined in {@link #getRoot()}.
   * 
   * If the root contains no defaults, or the defaults doesn't contain a
   * value for this path, or the value at this path is not a {@link
   * ConfigurationSection} then this will return null.
   *
   * @return Equivalent section in root configuration
  */
  getDefaultSection(): ConfigurationSection | null;
  /**
   * Sets the default value in the root at the given path as provided.
   * 
   * If no source {@link Configuration} was provided as a default
   * collection, then a new {@link MemoryConfiguration} will be created to
   * hold the new default value.
   * 
   * If value is null, the value will be removed from the default
   * Configuration source.
   * 
   * If the value as returned by {@link #getDefaultSection()} is null, then
   * this will create a new section at the path, replacing anything that may
   * have existed there previously.
   *
   * @param path Path of the value to set.
   * @param value Value to set the default to.
   * @throws IllegalArgumentException Thrown if path is null.
  */
  addDefault(path: string, value: any | null): void;
  /**
   * Gets the requested comment list by path.
   * 
   * If no comments exist, an empty list will be returned. A null entry
   * represents an empty line and an empty String represents an empty comment
   * line.
   *
   * @param path Path of the comments to get.
   * @return A unmodifiable list of the requested comments, every entry
   * represents one line.
  */
  getComments(path: string): string[];
  /**
   * Gets the requested inline comment list by path.
   * 
   * If no comments exist, an empty list will be returned. A null entry
   * represents an empty line and an empty String represents an empty comment
   * line.
   *
   * @param path Path of the comments to get.
   * @return A unmodifiable list of the requested comments, every entry
   * represents one line.
  */
  getInlineComments(path: string): string[];
  /**
   * Sets the comment list at the specified path.
   * 
   * If value is null, the comments will be removed. A null entry is an empty
   * line and an empty String entry is an empty comment line. If the path does
   * not exist, no comments will be set. Any existing comments will be
   * replaced, regardless of what the new comments are.
   * 
   * Some implementations may have limitations on what persists. See their
   * individual javadocs for details.
   *
   * @param path Path of the comments to set.
   * @param comments New comments to set at the path, every entry represents
   * one line.
  */
  setComments(path: string, comments: string[] | null): void;
  /**
   * Sets the inline comment list at the specified path.
   * 
   * If value is null, the comments will be removed. A null entry is an empty
   * line and an empty String entry is an empty comment line. If the path does
   * not exist, no comment will be set. Any existing comments will be
   * replaced, regardless of what the new comments are.
   * 
   * Some implementations may have limitations on what persists. See their
   * individual javadocs for details.
   *
   * @param path Path of the comments to set.
   * @param comments New comments to set at the path, every entry represents
   * one line.
  */
  setInlineComments(path: string, comments: string[] | null): void;
}
/**
 * This is a {@link Configuration} implementation that does not save or load
 * from any source, and stores all values in memory only.
 * This is useful for temporary Configurations for providing defaults.
*/
export class MemoryConfiguration extends MemorySection {
  /**
   * Creates an empty {@link MemoryConfiguration} with no default values.
  */
  constructor();
  /**
   * Creates an empty {@link MemoryConfiguration} using the specified {@link
   * Configuration} as a source for all default values.
   *
   * @param defaults Default value provider
   * @throws IllegalArgumentException Thrown if defaults is null
  */
  constructor(defaults: Configuration | null);
  /**
   * Sets the default value of the given path as provided.
   * 
   * If no source {@link Configuration} was provided as a default
   * collection, then a new {@link MemoryConfiguration} will be created to
   * hold the new default value.
   * 
   * If value is null, the value will be removed from the default
   * Configuration source.
   *
   * @param path Path of the value to set.
   * @param value Value to set the default to.
   * @throws IllegalArgumentException Thrown if path is null.
  */
  addDefault(path: string, value: any | null): void;
  /**
   * Sets the default values of the given paths as provided.
   * 
   * If no source {@link Configuration} was provided as a default
   * collection, then a new {@link MemoryConfiguration} will be created to
   * hold the new default values.
   *
   * @param defaults A map of Path{@literal ->}Values to add to defaults.
   * @throws IllegalArgumentException Thrown if defaults is null.
  */
  addDefaults(defaults: Map<string, any>): void;
  /**
   * Sets the default values of the given paths as provided.
   * 
   * If no source {@link Configuration} was provided as a default
   * collection, then a new {@link MemoryConfiguration} will be created to
   * hold the new default values.
   *
   * @param defaults A map of Path{@literal ->}Values to add to defaults.
   * @throws IllegalArgumentException Thrown if defaults is null.
  */
  addDefaults(defaults: Configuration): void;
  /**
   * Sets the source of all default values for this {@link Configuration}.
   * 
   * If a previous source was set, or previous default values were defined,
   * then they will not be copied to the new source.
   *
   * @param defaults New source of default values for this configuration.
   * @throws IllegalArgumentException Thrown if defaults is null or this.
  */
  setDefaults(defaults: Configuration);
  /**
   * Gets the source {@link Configuration} for this configuration.
   * 
   * If no configuration source was set, but default values were added, then
   * a {@link MemoryConfiguration} will be returned. If no source was set
   * and no defaults were set, then this method will return null.
   *
   * @return Configuration source for default values, or null if none exist.
  */
  getDefaults(): Configuration | null;
  /**
   * Gets the parent {@link ConfigurationSection} that directly contains
   * this {@link ConfigurationSection}.
   * 
   * For any {@link Configuration} themselves, this will return null.
   * 
   * If the section is no longer contained within its parent for any reason,
   * such as being replaced with a different value, this may return null.
   *
   * @return Parent section containing this section.
  */
  getParent(): ConfigurationSection | null;
  /**
   * Gets the {@link ConfigurationOptions} for this {@link Configuration}.
   * 
   * All setters through this method are chainable.
   *
   * @return Options for this configuration
  */
  options(): MemoryConfigurationOptions;
}
export interface MemoryConfiguration extends MemorySection, Configuration {}
/**
 * Various settings for controlling the input and output of a {@link
 * MemoryConfiguration}
*/
export class MemoryConfigurationOptions extends ConfigurationOptions {
  configuration(): MemoryConfiguration;
  copyDefaults(value: boolean): MemoryConfigurationOptions;
  pathSeparator(value: string): MemoryConfigurationOptions;
  /**
   * Gets the char that will be used to separate {@link
   * ConfigurationSection}s
   * 
   * This value does not affect how the {@link Configuration} is stored,
   * only in how you access the data. The default value is '.'.
   *
   * @return Path separator
  */
  pathSeparator(): string;
  /**
   * Checks if the {@link Configuration} should copy values from its default
   * {@link Configuration} directly.
   * 
   * If this is true, all values in the default Configuration will be
   * directly copied, making it impossible to distinguish between values
   * that were set and values that are provided by default. As a result,
   * {@link ConfigurationSection#contains(java.lang.String)} will always
   * return the same value as {@link
   * ConfigurationSection#isSet(java.lang.String)}. The default value is
   * false.
   *
   * @return Whether or not defaults are directly copied
  */
  copyDefaults(): boolean;
}
/**
 * Exception thrown when attempting to load an invalid {@link Configuration}
*/
export class InvalidConfigurationException extends Exception {
  /**
   * Creates a new instance of InvalidConfigurationException without a
   * message or cause.
  */
  constructor();
  /**
   * Constructs an instance of InvalidConfigurationException with the
   * specified message.
   *
   * @param msg The details of the exception.
  */
  constructor(msg: string);
  /**
   * Constructs an instance of InvalidConfigurationException with the
   * specified cause.
   *
   * @param cause The cause of the exception.
  */
  constructor(cause: Throwable);
  /**
   * Constructs an instance of InvalidConfigurationException with the
   * specified message and cause.
   *
   * @param cause The cause of the exception.
   * @param msg The details of the exception.
  */
  constructor(msg: string, cause: Throwable);
}
/**
 * A type of {@link ConfigurationSection} that is stored in memory.
*/
export class MemorySection extends ConfigurationSection {
  /**
   * Gets a set containing all keys in this section.
   * 
   * If deep is set to true, then this will contain all the keys within any
   * child {@link ConfigurationSection}s (and their children, etc). These
   * will be in a valid path notation for you to use.
   * 
   * If deep is set to false, then this will contain only the keys of any
   * direct children, and not their own children.
   *
   * @param deep Whether or not to get a deep list, as opposed to a shallow
   *     list.
   * @return Set of keys contained within this ConfigurationSection.
  */
  getKeys(deep: boolean): Set<string>;
  /**
   * Gets a Map containing all keys and their values for this section.
   * 
   * If deep is set to true, then this will contain all the keys and values
   * within any child {@link ConfigurationSection}s (and their children,
   * etc). These keys will be in a valid path notation for you to use.
   * 
   * If deep is set to false, then this will contain only the keys and
   * values of any direct children, and not their own children.
   *
   * @param deep Whether or not to get a deep list, as opposed to a shallow
   *     list.
   * @return Map of keys and values of this section.
  */
  getValues(deep: boolean): Map<string, any>;
  /**
   * Checks if this {@link ConfigurationSection} contains the given path.
   * 
   * If the value for the requested path does not exist but a default value
   * has been specified, this will return true.
   *
   * @param path Path to check for existence.
   * @return True if this section contains the requested path, either via
   *     default or being set.
   * @throws IllegalArgumentException Thrown when path is null.
  */
  contains(path: string): boolean;
  /**
   * Checks if this {@link ConfigurationSection} contains the given path.
   * 
   * If the value for the requested path does not exist but a default value
   * has been specified, this will return true.
   *
   * @param path Path to check for existence.
   * @return True if this section contains the requested path, either via
   *     default or being set.
   * @throws IllegalArgumentException Thrown when path is null.
  */
  contains(path: string, ignoreDefault: boolean): boolean;
  /**
   * Checks if this {@link ConfigurationSection} has a value set for the
   * given path.
   * 
   * If the value for the requested path does not exist but a default value
   * has been specified, this will still return false.
   *
   * @param path Path to check for existence.
   * @return True if this section contains the requested path, regardless of
   *     having a default.
   * @throws IllegalArgumentException Thrown when path is null.
  */
  isSet(path: string): boolean;
  /**
   * Gets the path of this {@link ConfigurationSection} from its root {@link
   * Configuration}
   * 
   * For any {@link Configuration} themselves, this will return an empty
   * string.
   * 
   * If the section is no longer contained within its root for any reason,
   * such as being replaced with a different value, this may return null.
   * 
   * To retrieve the single name of this section, that is, the final part of
   * the path returned by this method, you may use {@link #getName()}.
   *
   * @return Path of this section relative to its root
  */
  getCurrentPath(): string;
  /**
   * Gets the name of this individual {@link ConfigurationSection}, in the
   * path.
   * 
   * This will always be the final part of {@link #getCurrentPath()}, unless
   * the section is orphaned.
   *
   * @return Name of this section
  */
  getName(): string;
  /**
   * Gets the root {@link Configuration} that contains this {@link
   * ConfigurationSection}
   * 
   * For any {@link Configuration} themselves, this will return its own
   * object.
   * 
   * If the section is no longer contained within its root for any reason,
   * such as being replaced with a different value, this may return null.
   *
   * @return Root configuration containing this section.
  */
  getRoot(): Configuration | null;
  /**
   * Gets the parent {@link ConfigurationSection} that directly contains
   * this {@link ConfigurationSection}.
   * 
   * For any {@link Configuration} themselves, this will return null.
   * 
   * If the section is no longer contained within its parent for any reason,
   * such as being replaced with a different value, this may return null.
   *
   * @return Parent section containing this section.
  */
  getParent(): ConfigurationSection | null;
  /**
   * Sets the default value in the root at the given path as provided.
   * 
   * If no source {@link Configuration} was provided as a default
   * collection, then a new {@link MemoryConfiguration} will be created to
   * hold the new default value.
   * 
   * If value is null, the value will be removed from the default
   * Configuration source.
   * 
   * If the value as returned by {@link #getDefaultSection()} is null, then
   * this will create a new section at the path, replacing anything that may
   * have existed there previously.
   *
   * @param path Path of the value to set.
   * @param value Value to set the default to.
   * @throws IllegalArgumentException Thrown if path is null.
  */
  addDefault(path: string, value: any | null): void;
  /**
   * Gets the equivalent {@link ConfigurationSection} from the default
   * {@link Configuration} defined in {@link #getRoot()}.
   * 
   * If the root contains no defaults, or the defaults doesn't contain a
   * value for this path, or the value at this path is not a {@link
   * ConfigurationSection} then this will return null.
   *
   * @return Equivalent section in root configuration
  */
  getDefaultSection(): ConfigurationSection | null;
  /**
   * Sets the specified path to the given value.
   * 
   * If value is null, the entry will be removed. Any existing entry will be
   * replaced, regardless of what the new value is.
   * 
   * Some implementations may have limitations on what you may store. See
   * their individual javadocs for details. No implementations should allow
   * you to store {@link Configuration}s or {@link ConfigurationSection}s,
   * please use {@link #createSection(java.lang.String)} for that.
   *
   * @param path Path of the object to set.
   * @param value New value to set the path to.
  */
  set(path: string, value: any | null): void;
  /**
   * Gets the requested Object by path.
   * 
   * If the Object does not exist but a default value has been specified,
   * this will return the default value. If the Object does not exist and no
   * default value was specified, this will return null.
   *
   * @param path Path of the Object to get.
   * @return Requested Object.
  */
  get(path: string): any | null;
  /**
   * Gets the requested Object by path.
   * 
   * If the Object does not exist but a default value has been specified,
   * this will return the default value. If the Object does not exist and no
   * default value was specified, this will return null.
   *
   * @param path Path of the Object to get.
   * @return Requested Object.
  */
  get(path: string, def: any | null): any | null;
  /**
   * Creates an empty {@link ConfigurationSection} at the specified path.
   * 
   * Any value that was previously set at this path will be overwritten. If
   * the previous value was itself a {@link ConfigurationSection}, it will
   * be orphaned.
   *
   * @param path Path to create the section at.
   * @return Newly created section
  */
  createSection(path: string): ConfigurationSection;
  /**
   * Creates an empty {@link ConfigurationSection} at the specified path.
   * 
   * Any value that was previously set at this path will be overwritten. If
   * the previous value was itself a {@link ConfigurationSection}, it will
   * be orphaned.
   *
   * @param path Path to create the section at.
   * @return Newly created section
  */
  createSection(path: string, map: Map<any, any>): ConfigurationSection;
  /**
   * Gets the requested String by path.
   * 
   * If the String does not exist but a default value has been specified,
   * this will return the default value. If the String does not exist and no
   * default value was specified, this will return null.
   *
   * @param path Path of the String to get.
   * @return Requested String.
  */
  getString(path: string): string | null;
  /**
   * Gets the requested String by path.
   * 
   * If the String does not exist but a default value has been specified,
   * this will return the default value. If the String does not exist and no
   * default value was specified, this will return null.
   *
   * @param path Path of the String to get.
   * @return Requested String.
  */
  getString(path: string, def: string | null): string | null;
  /**
   * Checks if the specified path is a String.
   * 
   * If the path exists but is not a String, this will return false. If the
   * path does not exist, this will return false. If the path does not exist
   * but a default value has been specified, this will check if that default
   * value is a String and return appropriately.
   *
   * @param path Path of the String to check.
   * @return Whether or not the specified path is a String.
  */
  isString(path: string): boolean;
  /**
   * Gets the requested int by path.
   * 
   * If the int does not exist but a default value has been specified, this
   * will return the default value. If the int does not exist and no default
   * value was specified, this will return 0.
   *
   * @param path Path of the int to get.
   * @return Requested int.
  */
  getInt(path: string): number;
  /**
   * Gets the requested int by path.
   * 
   * If the int does not exist but a default value has been specified, this
   * will return the default value. If the int does not exist and no default
   * value was specified, this will return 0.
   *
   * @param path Path of the int to get.
   * @return Requested int.
  */
  getInt(path: string, def: number): number;
  /**
   * Checks if the specified path is an int.
   * 
   * If the path exists but is not a int, this will return false. If the
   * path does not exist, this will return false. If the path does not exist
   * but a default value has been specified, this will check if that default
   * value is a int and return appropriately.
   *
   * @param path Path of the int to check.
   * @return Whether or not the specified path is an int.
  */
  isInt(path: string): boolean;
  /**
   * Gets the requested boolean by path.
   * 
   * If the boolean does not exist but a default value has been specified,
   * this will return the default value. If the boolean does not exist and
   * no default value was specified, this will return false.
   *
   * @param path Path of the boolean to get.
   * @return Requested boolean.
  */
  getBoolean(path: string): boolean;
  /**
   * Gets the requested boolean by path.
   * 
   * If the boolean does not exist but a default value has been specified,
   * this will return the default value. If the boolean does not exist and
   * no default value was specified, this will return false.
   *
   * @param path Path of the boolean to get.
   * @return Requested boolean.
  */
  getBoolean(path: string, def: boolean): boolean;
  /**
   * Checks if the specified path is a boolean.
   * 
   * If the path exists but is not a boolean, this will return false. If the
   * path does not exist, this will return false. If the path does not exist
   * but a default value has been specified, this will check if that default
   * value is a boolean and return appropriately.
   *
   * @param path Path of the boolean to check.
   * @return Whether or not the specified path is a boolean.
  */
  isBoolean(path: string): boolean;
  /**
   * Gets the requested double by path.
   * 
   * If the double does not exist but a default value has been specified,
   * this will return the default value. If the double does not exist and no
   * default value was specified, this will return 0.
   *
   * @param path Path of the double to get.
   * @return Requested double.
  */
  getDouble(path: string): number;
  /**
   * Gets the requested double by path.
   * 
   * If the double does not exist but a default value has been specified,
   * this will return the default value. If the double does not exist and no
   * default value was specified, this will return 0.
   *
   * @param path Path of the double to get.
   * @return Requested double.
  */
  getDouble(path: string, def: number): number;
  /**
   * Checks if the specified path is a double.
   * 
   * If the path exists but is not a double, this will return false. If the
   * path does not exist, this will return false. If the path does not exist
   * but a default value has been specified, this will check if that default
   * value is a double and return appropriately.
   *
   * @param path Path of the double to check.
   * @return Whether or not the specified path is a double.
  */
  isDouble(path: string): boolean;
  /**
   * Gets the requested long by path.
   * 
   * If the long does not exist but a default value has been specified, this
   * will return the default value. If the long does not exist and no
   * default value was specified, this will return 0.
   *
   * @param path Path of the long to get.
   * @return Requested long.
  */
  getLong(path: string): number;
  /**
   * Gets the requested long by path.
   * 
   * If the long does not exist but a default value has been specified, this
   * will return the default value. If the long does not exist and no
   * default value was specified, this will return 0.
   *
   * @param path Path of the long to get.
   * @return Requested long.
  */
  getLong(path: string, def: number): number;
  /**
   * Checks if the specified path is a long.
   * 
   * If the path exists but is not a long, this will return false. If the
   * path does not exist, this will return false. If the path does not exist
   * but a default value has been specified, this will check if that default
   * value is a long and return appropriately.
   *
   * @param path Path of the long to check.
   * @return Whether or not the specified path is a long.
  */
  isLong(path: string): boolean;
  /**
   * Gets the requested List by path.
   * 
   * If the List does not exist but a default value has been specified, this
   * will return the default value. If the List does not exist and no
   * default value was specified, this will return null.
   *
   * @param path Path of the List to get.
   * @return Requested List.
  */
  getList(path: string): any[] | null;
  /**
   * Gets the requested List by path.
   * 
   * If the List does not exist but a default value has been specified, this
   * will return the default value. If the List does not exist and no
   * default value was specified, this will return null.
   *
   * @param path Path of the List to get.
   * @return Requested List.
  */
  getList(path: string, def: any[] | null): any[] | null;
  /**
   * Checks if the specified path is a List.
   * 
   * If the path exists but is not a List, this will return false. If the
   * path does not exist, this will return false. If the path does not exist
   * but a default value has been specified, this will check if that default
   * value is a List and return appropriately.
   *
   * @param path Path of the List to check.
   * @return Whether or not the specified path is a List.
  */
  isList(path: string): boolean;
  /**
   * Gets the requested List of String by path.
   * 
   * If the List does not exist but a default value has been specified, this
   * will return the default value. If the List does not exist and no
   * default value was specified, this will return an empty List.
   * 
   * This method will attempt to cast any values into a String if possible,
   * but may miss any values out if they are not compatible.
   *
   * @param path Path of the List to get.
   * @return Requested List of String.
  */
  getStringList(path: string): string[];
  /**
   * Gets the requested List of Integer by path.
   * 
   * If the List does not exist but a default value has been specified, this
   * will return the default value. If the List does not exist and no
   * default value was specified, this will return an empty List.
   * 
   * This method will attempt to cast any values into a Integer if possible,
   * but may miss any values out if they are not compatible.
   *
   * @param path Path of the List to get.
   * @return Requested List of Integer.
  */
  getIntegerList(path: string): number[];
  /**
   * Gets the requested List of Boolean by path.
   * 
   * If the List does not exist but a default value has been specified, this
   * will return the default value. If the List does not exist and no
   * default value was specified, this will return an empty List.
   * 
   * This method will attempt to cast any values into a Boolean if possible,
   * but may miss any values out if they are not compatible.
   *
   * @param path Path of the List to get.
   * @return Requested List of Boolean.
  */
  getBooleanList(path: string): boolean[];
  /**
   * Gets the requested List of Double by path.
   * 
   * If the List does not exist but a default value has been specified, this
   * will return the default value. If the List does not exist and no
   * default value was specified, this will return an empty List.
   * 
   * This method will attempt to cast any values into a Double if possible,
   * but may miss any values out if they are not compatible.
   *
   * @param path Path of the List to get.
   * @return Requested List of Double.
  */
  getDoubleList(path: string): number[];
  /**
   * Gets the requested List of Float by path.
   * 
   * If the List does not exist but a default value has been specified, this
   * will return the default value. If the List does not exist and no
   * default value was specified, this will return an empty List.
   * 
   * This method will attempt to cast any values into a Float if possible,
   * but may miss any values out if they are not compatible.
   *
   * @param path Path of the List to get.
   * @return Requested List of Float.
  */
  getFloatList(path: string): number[];
  /**
   * Gets the requested List of Long by path.
   * 
   * If the List does not exist but a default value has been specified, this
   * will return the default value. If the List does not exist and no
   * default value was specified, this will return an empty List.
   * 
   * This method will attempt to cast any values into a Long if possible,
   * but may miss any values out if they are not compatible.
   *
   * @param path Path of the List to get.
   * @return Requested List of Long.
  */
  getLongList(path: string): number[];
  /**
   * Gets the requested List of Byte by path.
   * 
   * If the List does not exist but a default value has been specified, this
   * will return the default value. If the List does not exist and no
   * default value was specified, this will return an empty List.
   * 
   * This method will attempt to cast any values into a Byte if possible,
   * but may miss any values out if they are not compatible.
   *
   * @param path Path of the List to get.
   * @return Requested List of Byte.
  */
  getByteList(path: string): number[];
  /**
   * Gets the requested List of Character by path.
   * 
   * If the List does not exist but a default value has been specified, this
   * will return the default value. If the List does not exist and no
   * default value was specified, this will return an empty List.
   * 
   * This method will attempt to cast any values into a Character if
   * possible, but may miss any values out if they are not compatible.
   *
   * @param path Path of the List to get.
   * @return Requested List of Character.
  */
  getCharacterList(path: string): string[];
  /**
   * Gets the requested List of Short by path.
   * 
   * If the List does not exist but a default value has been specified, this
   * will return the default value. If the List does not exist and no
   * default value was specified, this will return an empty List.
   * 
   * This method will attempt to cast any values into a Short if possible,
   * but may miss any values out if they are not compatible.
   *
   * @param path Path of the List to get.
   * @return Requested List of Short.
  */
  getShortList(path: string): number[];
  /**
   * Gets the requested List of Maps by path.
   * 
   * If the List does not exist but a default value has been specified, this
   * will return the default value. If the List does not exist and no
   * default value was specified, this will return an empty List.
   * 
   * This method will attempt to cast any values into a Map if possible, but
   * may miss any values out if they are not compatible.
   *
   * @param path Path of the List to get.
   * @return Requested List of Maps.
  */
  getMapList(path: string): Map<any, any>[];
  /**
   * Gets the requested object at the given path.
   *
   * If the Object does not exist but a default value has been specified, this
   * will return the default value. If the Object does not exist and no
   * default value was specified, this will return null.
   *
   * Note: For example #getObject(path, String.class) is not
   * equivalent to {@link #getString(String) #getString(path)} because
   * {@link #getString(String) #getString(path)} converts internally all
   * Objects to Strings. However, #getObject(path, Boolean.class) is
   * equivalent to {@link #getBoolean(String) #getBoolean(path)} for example.
   *
   * @param  the type of the requested object
   * @param path the path to the object.
   * @param clazz the type of the requested object
   * @return Requested object
  */
  getObject<T>(path: string, clazz: Class<T>): T | null;
  /**
   * Gets the requested object at the given path.
   *
   * If the Object does not exist but a default value has been specified, this
   * will return the default value. If the Object does not exist and no
   * default value was specified, this will return null.
   *
   * Note: For example #getObject(path, String.class) is not
   * equivalent to {@link #getString(String) #getString(path)} because
   * {@link #getString(String) #getString(path)} converts internally all
   * Objects to Strings. However, #getObject(path, Boolean.class) is
   * equivalent to {@link #getBoolean(String) #getBoolean(path)} for example.
   *
   * @param  the type of the requested object
   * @param path the path to the object.
   * @param clazz the type of the requested object
   * @return Requested object
  */
  getObject<T>(path: string, clazz: Class<T>, def: T | null): T | null;
  /**
   * Gets the requested {@link ConfigurationSerializable} object at the given
   * path.
   *
   * If the Object does not exist but a default value has been specified, this
   * will return the default value. If the Object does not exist and no
   * default value was specified, this will return null.
   *
   * @param  the type of {@link ConfigurationSerializable}
   * @param path the path to the object.
   * @param clazz the type of {@link ConfigurationSerializable}
   * @return Requested {@link ConfigurationSerializable} object
  */
  getSerializable<T>(path: string, clazz: Class<T>): T | null;
  /**
   * Gets the requested {@link ConfigurationSerializable} object at the given
   * path.
   *
   * If the Object does not exist but a default value has been specified, this
   * will return the default value. If the Object does not exist and no
   * default value was specified, this will return null.
   *
   * @param  the type of {@link ConfigurationSerializable}
   * @param path the path to the object.
   * @param clazz the type of {@link ConfigurationSerializable}
   * @return Requested {@link ConfigurationSerializable} object
  */
  getSerializable<T>(path: string, clazz: Class<T>, def: T | null): T | null;
  /**
   * Gets the requested Vector by path.
   * 
   * If the Vector does not exist but a default value has been specified,
   * this will return the default value. If the Vector does not exist and no
   * default value was specified, this will return null.
   *
   * @param path Path of the Vector to get.
   * @return Requested Vector.
  */
  getVector(path: string): Vector | null;
  /**
   * Gets the requested Vector by path.
   * 
   * If the Vector does not exist but a default value has been specified,
   * this will return the default value. If the Vector does not exist and no
   * default value was specified, this will return null.
   *
   * @param path Path of the Vector to get.
   * @return Requested Vector.
  */
  getVector(path: string, def: Vector | null): Vector | null;
  /**
   * Checks if the specified path is a Vector.
   * 
   * If the path exists but is not a Vector, this will return false. If the
   * path does not exist, this will return false. If the path does not exist
   * but a default value has been specified, this will check if that default
   * value is a Vector and return appropriately.
   *
   * @param path Path of the Vector to check.
   * @return Whether or not the specified path is a Vector.
  */
  isVector(path: string): boolean;
  /**
   * Gets the requested OfflinePlayer by path.
   * 
   * If the OfflinePlayer does not exist but a default value has been
   * specified, this will return the default value. If the OfflinePlayer
   * does not exist and no default value was specified, this will return
   * null.
   *
   * @param path Path of the OfflinePlayer to get.
   * @return Requested OfflinePlayer.
  */
  getOfflinePlayer(path: string): OfflinePlayer | null;
  /**
   * Gets the requested OfflinePlayer by path.
   * 
   * If the OfflinePlayer does not exist but a default value has been
   * specified, this will return the default value. If the OfflinePlayer
   * does not exist and no default value was specified, this will return
   * null.
   *
   * @param path Path of the OfflinePlayer to get.
   * @return Requested OfflinePlayer.
  */
  getOfflinePlayer(path: string, def: OfflinePlayer | null): OfflinePlayer | null;
  /**
   * Checks if the specified path is an OfflinePlayer.
   * 
   * If the path exists but is not a OfflinePlayer, this will return false.
   * If the path does not exist, this will return false. If the path does
   * not exist but a default value has been specified, this will check if
   * that default value is a OfflinePlayer and return appropriately.
   *
   * @param path Path of the OfflinePlayer to check.
   * @return Whether or not the specified path is an OfflinePlayer.
  */
  isOfflinePlayer(path: string): boolean;
  /**
   * Gets the requested ItemStack by path.
   * 
   * If the ItemStack does not exist but a default value has been specified,
   * this will return the default value. If the ItemStack does not exist and
   * no default value was specified, this will return null.
   *
   * @param path Path of the ItemStack to get.
   * @return Requested ItemStack.
  */
  getItemStack(path: string): ItemStack | null;
  /**
   * Gets the requested ItemStack by path.
   * 
   * If the ItemStack does not exist but a default value has been specified,
   * this will return the default value. If the ItemStack does not exist and
   * no default value was specified, this will return null.
   *
   * @param path Path of the ItemStack to get.
   * @return Requested ItemStack.
  */
  getItemStack(path: string, def: ItemStack | null): ItemStack | null;
  /**
   * Checks if the specified path is an ItemStack.
   * 
   * If the path exists but is not a ItemStack, this will return false. If
   * the path does not exist, this will return false. If the path does not
   * exist but a default value has been specified, this will check if that
   * default value is a ItemStack and return appropriately.
   *
   * @param path Path of the ItemStack to check.
   * @return Whether or not the specified path is an ItemStack.
  */
  isItemStack(path: string): boolean;
  /**
   * Gets the requested Color by path.
   * 
   * If the Color does not exist but a default value has been specified,
   * this will return the default value. If the Color does not exist and no
   * default value was specified, this will return null.
   *
   * @param path Path of the Color to get.
   * @return Requested Color.
  */
  getColor(path: string): Color | null;
  /**
   * Gets the requested Color by path.
   * 
   * If the Color does not exist but a default value has been specified,
   * this will return the default value. If the Color does not exist and no
   * default value was specified, this will return null.
   *
   * @param path Path of the Color to get.
   * @return Requested Color.
  */
  getColor(path: string, def: Color | null): Color | null;
  /**
   * Checks if the specified path is a Color.
   * 
   * If the path exists but is not a Color, this will return false. If the
   * path does not exist, this will return false. If the path does not exist
   * but a default value has been specified, this will check if that default
   * value is a Color and return appropriately.
   *
   * @param path Path of the Color to check.
   * @return Whether or not the specified path is a Color.
  */
  isColor(path: string): boolean;
  /**
   * Gets the requested Location by path.
   * 
   * If the Location does not exist but a default value has been specified,
   * this will return the default value. If the Location does not exist and no
   * default value was specified, this will return null.
   *
   * @param path Path of the Location to get.
   * @return Requested Location.
  */
  getLocation(path: string): Location | null;
  /**
   * Gets the requested Location by path.
   * 
   * If the Location does not exist but a default value has been specified,
   * this will return the default value. If the Location does not exist and no
   * default value was specified, this will return null.
   *
   * @param path Path of the Location to get.
   * @return Requested Location.
  */
  getLocation(path: string, def: Location | null): Location | null;
  /**
   * Checks if the specified path is a Location.
   * 
   * If the path exists but is not a Location, this will return false. If the
   * path does not exist, this will return false. If the path does not exist
   * but a default value has been specified, this will check if that default
   * value is a Location and return appropriately.
   *
   * @param path Path of the Location to check.
   * @return Whether or not the specified path is a Location.
  */
  isLocation(path: string): boolean;
  /**
   * Gets the requested ConfigurationSection by path.
   * 
   * If the ConfigurationSection does not exist but a default value has been
   * specified, this will return the default value. If the
   * ConfigurationSection does not exist and no default value was specified,
   * this will return null.
   *
   * @param path Path of the ConfigurationSection to get.
   * @return Requested ConfigurationSection.
  */
  getConfigurationSection(path: string): ConfigurationSection | null;
  /**
   * Checks if the specified path is a ConfigurationSection.
   * 
   * If the path exists but is not a ConfigurationSection, this will return
   * false. If the path does not exist, this will return false. If the path
   * does not exist but a default value has been specified, this will check
   * if that default value is a ConfigurationSection and return
   * appropriately.
   *
   * @param path Path of the ConfigurationSection to check.
   * @return Whether or not the specified path is a ConfigurationSection.
  */
  isConfigurationSection(path: string): boolean;
  /**
   * Creates a full path to the given {@link ConfigurationSection} from its
   * root {@link Configuration}.
   * 
   * You may use this method for any given {@link ConfigurationSection}, not
   * only {@link MemorySection}.
   *
   * @param section Section to create a path for.
   * @param key Name of the specified section.
   * @return Full path of the section from its root.
  */
  static createPath(section: ConfigurationSection, key: string | null): string;
  /**
   * Creates a relative path to the given {@link ConfigurationSection} from
   * the given relative section.
   * 
   * You may use this method for any given {@link ConfigurationSection}, not
   * only {@link MemorySection}.
   *
   * @param section Section to create a path for.
   * @param key Name of the specified section.
   * @param relativeTo Section to create the path relative to.
   * @return Full path of the section from its root.
  */
  static createPath(section: ConfigurationSection, key: string | null, relativeTo: ConfigurationSection | null): string;
  /**
   * Gets the requested comment list by path.
   * 
   * If no comments exist, an empty list will be returned. A null entry
   * represents an empty line and an empty String represents an empty comment
   * line.
   *
   * @param path Path of the comments to get.
   * @return A unmodifiable list of the requested comments, every entry
   * represents one line.
  */
  getComments(path: string): string[];
  /**
   * Gets the requested inline comment list by path.
   * 
   * If no comments exist, an empty list will be returned. A null entry
   * represents an empty line and an empty String represents an empty comment
   * line.
   *
   * @param path Path of the comments to get.
   * @return A unmodifiable list of the requested comments, every entry
   * represents one line.
  */
  getInlineComments(path: string): string[];
  /**
   * Sets the comment list at the specified path.
   * 
   * If value is null, the comments will be removed. A null entry is an empty
   * line and an empty String entry is an empty comment line. If the path does
   * not exist, no comments will be set. Any existing comments will be
   * replaced, regardless of what the new comments are.
   * 
   * Some implementations may have limitations on what persists. See their
   * individual javadocs for details.
   *
   * @param path Path of the comments to set.
   * @param comments New comments to set at the path, every entry represents
   * one line.
  */
  setComments(path: string, comments: string[] | null): void;
  /**
   * Sets the inline comment list at the specified path.
   * 
   * If value is null, the comments will be removed. A null entry is an empty
   * line and an empty String entry is an empty comment line. If the path does
   * not exist, no comment will be set. Any existing comments will be
   * replaced, regardless of what the new comments are.
   * 
   * Some implementations may have limitations on what persists. See their
   * individual javadocs for details.
   *
   * @param path Path of the comments to set.
   * @param comments New comments to set at the path, every entry represents
   * one line.
  */
  setInlineComments(path: string, comments: string[] | null): void;
  toString(): string;
}
/**
 * Represents a source of configurable options and settings
*/
export class Configuration extends ConfigurationSection {
  /**
   * Sets the default value of the given path as provided.
   * 
   * If no source {@link Configuration} was provided as a default
   * collection, then a new {@link MemoryConfiguration} will be created to
   * hold the new default value.
   * 
   * If value is null, the value will be removed from the default
   * Configuration source.
   *
   * @param path Path of the value to set.
   * @param value Value to set the default to.
   * @throws IllegalArgumentException Thrown if path is null.
  */
  addDefault(path: string, value: any | null): void;
  /**
   * Sets the default values of the given paths as provided.
   * 
   * If no source {@link Configuration} was provided as a default
   * collection, then a new {@link MemoryConfiguration} will be created to
   * hold the new default values.
   *
   * @param defaults A map of Path{@literal ->}Values to add to defaults.
   * @throws IllegalArgumentException Thrown if defaults is null.
  */
  addDefaults(defaults: Map<string, any>): void;
  /**
   * Sets the default values of the given paths as provided.
   * 
   * If no source {@link Configuration} was provided as a default
   * collection, then a new {@link MemoryConfiguration} will be created to
   * hold the new default value.
   * 
   * This method will not hold a reference to the specified Configuration,
   * nor will it automatically update if that Configuration ever changes. If
   * you require this, you should set the default source with {@link
   * #setDefaults(org.bukkit.configuration.Configuration)}.
   *
   * @param defaults A configuration holding a list of defaults to copy.
   * @throws IllegalArgumentException Thrown if defaults is null or this.
  */
  addDefaults(defaults: Configuration): void;
  /**
   * Sets the source of all default values for this {@link Configuration}.
   * 
   * If a previous source was set, or previous default values were defined,
   * then they will not be copied to the new source.
   *
   * @param defaults New source of default values for this configuration.
   * @throws IllegalArgumentException Thrown if defaults is null or this.
  */
  setDefaults(defaults: Configuration);
  /**
   * Gets the source {@link Configuration} for this configuration.
   * 
   * If no configuration source was set, but default values were added, then
   * a {@link MemoryConfiguration} will be returned. If no source was set
   * and no defaults were set, then this method will return null.
   *
   * @return Configuration source for default values, or null if none exist.
  */
  getDefaults(): Configuration | null;
  /**
   * Gets the {@link ConfigurationOptions} for this {@link Configuration}.
   * 
   * All setters through this method are chainable.
   *
   * @return Options for this configuration
  */
  options(): ConfigurationOptions;
}

}
declare module 'org.bukkit.plugin' {
import { LogRecord, Logger } from 'java.util.logging';
import { Method } from 'java.lang.reflect';
import { Yaml } from 'org.yaml.snakeyaml';
import { Set, Collection, List, Map } from 'java.util';
import { Logger as org_slf4j_Logger } from 'org.slf4j';
import { MutableGraph } from 'com.google.common.graph';
import { SimpleCommandMap, TabExecutor } from 'org.bukkit.command';
import { FileConfiguration } from 'org.bukkit.configuration.file';
import { ConcurrentMap } from 'java.util.concurrent';
import { ComponentLogger } from 'net.kyori.adventure.text.logger.slf4j';
import { BiomeProvider, ChunkGenerator } from 'org.bukkit.generator';
import { Server } from 'org.bukkit';
import { PermissionDefault, Permissible, Permission } from 'org.bukkit.permissions';
import { Enum, Comparable, RuntimeException, ThreadLocal, Throwable, Class, Exception } from 'java.lang';
import { Pattern } from 'java.util.regex';
import { Logger as org_apache_logging_log4j_Logger } from 'org.apache.logging.log4j';
import { InputStream, Reader, File, Writer } from 'java.io';
import { Listener, Event, EventPriority } from 'org.bukkit.event';
export class AuthorNagException extends RuntimeException {
  /**
   * Constructs a new AuthorNagException based on the given Exception
   *
   * @param message Brief message explaining the cause of the exception
  */
  constructor(message: string);
  getMessage(): string;
}
/**
 * Manages services and service providers. Services are an interface
 * specifying a list of methods that a provider must implement. Providers are
 * implementations of these services. A provider can be queried from the
 * services manager in order to use a service (if one is available). If
 * multiple plugins register a service, then the service with the highest
 * priority takes precedence.
*/
export class ServicesManager {
  /**
   * Register a provider of a service.
   *
   * @param  Provider
   * @param service service class
   * @param provider provider to register
   * @param plugin plugin with the provider
   * @param priority priority of the provider
  */
  register<T>(service: Class<T>, provider: T, plugin: Plugin, priority: ServicePriority): void;
  /**
   * Unregister all the providers registered by a particular plugin.
   *
   * @param plugin The plugin
  */
  unregisterAll(plugin: Plugin): void;
  /**
   * Unregister a particular provider for a particular service.
   *
   * @param service The service interface
   * @param provider The service provider implementation
  */
  unregister(service: Class<any>, provider: any): void;
  /**
   * Unregister a particular provider.
   *
   * @param provider The service provider implementation
  */
  unregister(provider: any): void;
  /**
   * Queries for a provider. This may return null if no provider has been
   * registered for a service. The highest priority provider is returned.
   *
   * @param  The service interface
   * @param service The service interface
   * @return provider or null
  */
  load<T>(service: Class<T>): T | null;
  /**
   * Queries for a provider registration. This may return null if no provider
   * has been registered for a service.
   *
   * @param  The service interface
   * @param service The service interface
   * @return provider registration or null
  */
  getRegistration<T>(service: Class<T>): RegisteredServiceProvider<T> | null;
  /**
   * Get registrations of providers for a plugin.
   *
   * @param plugin The plugin
   * @return provider registrations
  */
  getRegistrations(plugin: Plugin): RegisteredServiceProvider<any>[];
  /**
   * Get registrations of providers for a service. The returned list is
   * unmodifiable.
   *
   * @param  The service interface
   * @param service The service interface
   * @return list of registrations
  */
  getRegistrations<T>(service: Class<T>): Collection<RegisteredServiceProvider<T>>;
  /**
   * Get a list of known services. A service is known if it has registered
   * providers for it.
   *
   * @return list of known services
  */
  getKnownServices(): Collection<Class<any>>;
  /**
   * Returns whether a provider has been registered for a service. Do not
   * check this first only to call load(service) later, as that
   * would be a non-thread safe situation.
   *
   * @param  service
   * @param service service to check
   * @return whether there has been a registered provider
  */
  isProvidedFor<T>(service: Class<T>): boolean;
}
/**
 * This type is the runtime-container for the information in the plugin.yml.
 * All plugins must have a respective plugin.yml. For plugins written in java
 * using the standard plugin loader, this file must be in the root of the jar
 * file.
 * 
 * When Bukkit loads a plugin, it needs to know some basic information about
 * it. It reads this information from a YAML file, 'plugin.yml'. This file
 * consists of a set of attributes, each defined on a new line and with no
 * indentation.
 * 
 * Every (almost* every) method corresponds with a specific entry in the
 * plugin.yml. These are the required entries for every plugin.yml:
 * 
 * {@link #getName()} - name
 * {@link #getVersion()} - version
 * {@link #getMain()} - main
 * 
 * 
 * Failing to include any of these items will throw an exception and cause the
 * server to ignore your plugin.
 * 
 * This is a list of the possible yaml keys, with specific details included in
 * the respective method documentations:
 * 
 * The description of the plugin.yml layout
 * 
 *     Node
 *     Method
 *     Summary
 * 
 *     name
 *     {@link #getName()}
 *     The unique name of plugin
 * 
 *     provides
 *     {@link #getProvides()}
 *     The plugin APIs which this plugin provides
 * 
 *     version
 *     {@link #getVersion()}
 *     A plugin revision identifier
 * 
 *     main
 *     {@link #getMain()}
 *     The plugin's initial class file
 * 
 *     authorauthors
 *     {@link #getAuthors()}
 *     The plugin authors
 * 
 *     contributors
 *     {@link #getContributors()}
 *     The plugin contributors
 * 
 *     description
 *     {@link #getDescription()}
 *     Human readable plugin summary
 * 
 *     website
 *     {@link #getWebsite()}
 *     The URL to the plugin's site
 * 
 *     prefix
 *     {@link #getPrefix()}
 *     The token to prefix plugin log entries
 * 
 *     load
 *     {@link #getLoad()}
 *     The phase of server-startup this plugin will load during
 * 
 *     depend
 *     {@link #getDepend()}
 *     Other required plugins
 * 
 *     softdepend
 *     {@link #getSoftDepend()}
 *     Other plugins that add functionality
 * 
 *     loadbefore
 *     {@link #getLoadBefore()}
 *     The inverse softdepend
 * 
 *     commands
 *     {@link #getCommands()}
 *     The commands the plugin will register
 * 
 *     permissions
 *     {@link #getPermissions()}
 *     The permissions the plugin will register
 * 
 *     default-permission
 *     {@link #getPermissionDefault()}
 *     The default {@link Permission#getDefault() default} permission
 *         state for defined {@link #getPermissions() permissions} the plugin
 *         will register
 * 
 *     awareness
 *     {@link #getAwareness()}
 *     The concepts that the plugin acknowledges
 * 
 *     api-version
 *     {@link #getAPIVersion()}
 *     The API version which this plugin was programmed against
 * 
 *     libraries
 *     {@link #getLibraries() ()}
 *     The libraries to be linked with this plugin
 * 
 * 
 * 
 * A plugin.yml example: *name: Inferno
 *provides: [Hell]
 *version: 1.4.1
 *description: This plugin is so 31337. You can set yourself on fire.
 *# We could place every author in the authors list, but chose not to for illustrative purposes
 *# Also, having an author distinguishes that person as the project lead, and ensures their
 *# name is displayed first
 *author: CaptainInflamo
 *authors: [Cogito, verrier, EvilSeph]
 *contributors: [Choco, md_5]
 *website: http://www.curse.com/server-mods/minecraft/myplugin
 *
 *main: com.captaininflamo.bukkit.inferno.Inferno
 *depend: [NewFire, FlameWire]
 *api-version: 1.13
 *libraries:
 - com.squareup.okhttp3:okhttp:4.9.0
 *
 *commands:
 *  flagrate:
 *    description: Set yourself on fire.
 *    aliases: [combust_me, combustMe]
 *    permission: inferno.flagrate
 *    usage: Syntax error! Simply type /<command> to ignite yourself.
 *  burningdeaths:
 *    description: List how many times you have died by fire.
 *    aliases: [burning_deaths, burningDeaths]
 *    permission: inferno.burningdeaths
 *    usage: |
 *      /<command> [player]
 *      Example: /<command> - see how many times you have burned to death
 *      Example: /<command> CaptainIce - see how many times CaptainIce has burned to death
 *
 *permissions:
 *  inferno.*:
 *    description: Gives access to all Inferno commands
 *    children:
 *      inferno.flagrate: true
 *      inferno.burningdeaths: true
 *      inferno.burningdeaths.others: true
 *  inferno.flagrate:
 *    description: Allows you to ignite yourself
 *    default: true
 *  inferno.burningdeaths:
 *    description: Allows you to see how many times you have burned to death
 *    default: true
 *  inferno.burningdeaths.others:
 *    description: Allows you to see how many times others have burned to death
 *    default: op
 *    children:
 *      inferno.burningdeaths: true
 *
*/
export class PluginDescriptionFile {
  constructor(stream: InputStream);
  /**
   * Loads a PluginDescriptionFile from the specified reader
   *
   * @param reader The reader
   * @throws InvalidDescriptionException If the PluginDescriptionFile is
   *     invalid
  */
  constructor(reader: Reader);
  /**
   * Creates a new PluginDescriptionFile with the given detailed
   *
   * @param pluginName Name of this plugin
   * @param pluginVersion Version of this plugin
   * @param mainClass Full location of the main class of this plugin
  */
  constructor(pluginName: string, pluginVersion: string, mainClass: string);
  /**
   * Gives the name of the plugin. This name is a unique identifier for
   * plugins.
   * 
   * Must consist of all alphanumeric characters, underscores, hyphon,
   *     and period (a-z,A-Z,0-9, _.-). Any other character will cause the
   *     plugin.yml to fail loading.
   * Used to determine the name of the plugin's data folder. Data
   *     folders are placed in the ./plugins/ directory by default, but this
   *     behavior should not be relied on. {@link Plugin#getDataFolder()}
   *     should be used to reference the data folder.
   * It is good practice to name your jar the same as this, for example
   *     'MyPlugin.jar'.
   * Case sensitive.
   * The is the token referenced in {@link #getDepend()}, {@link
   *     #getSoftDepend()}, and {@link #getLoadBefore()}.
   * Using spaces in the plugin's name is deprecated.
   * 
   * 
   * In the plugin.yml, this entry is named name.
   * 
   * Example:name: MyPlugin
   *
   * @return the name of the plugin
  */
  getName(): string;
  /**
   * Gives the list of other plugin APIs which this plugin provides.
   * These are usable for other plugins to depend on.
   * 
   * Must consist of all alphanumeric characters, underscores, hyphon,
   *     and period (a-z,A-Z,0-9, _.-). Any other character will cause the
   *     plugin.yml to fail loading.
   * A different plugin providing the same one or using it as their name
   *     will not result in the plugin to fail loading.
   * Case sensitive.
   * An entry of this list can be referenced in {@link #getDepend()},
   *    {@link #getSoftDepend()}, and {@link #getLoadBefore()}.
   * provides must be in YAML list
   *     format.
   * 
   * 
   * In the plugin.yml, this entry is named provides.
   * 
   * Example:
   * provides:
   *- OtherPluginName
   *- OldPluginName
   *
   * @return immutable list of the plugin APIs which this plugin provides
  */
  getProvides(): string[];
  /**
   * Gives the version of the plugin.
   * 
   * Version is an arbitrary string, however the most common format is
   *     MajorRelease.MinorRelease.Build (eg: 1.4.1).
   * Typically you will increment this every time you release a new
   *     feature or bug fix.
   * Displayed when a user types /version PluginName
   * 
   * 
   * In the plugin.yml, this entry is named version.
   * 
   * Example:version: 1.4.1
   *
   * @return the version of the plugin
  */
  getVersion(): string;
  /**
   * Gives the fully qualified name of the main class for a plugin. The
   * format should follow the {@link ClassLoader#loadClass(String)} syntax
   * to successfully be resolved at runtime. For most plugins, this is the
   * class that extends {@link JavaPlugin}.
   * 
   * This must contain the full namespace including the class file
   *     itself.
   * If your namespace is org.bukkit.plugin, and your class
   *     file is called MyPlugin then this must be
   *     org.bukkit.plugin.MyPlugin
   * No plugin can use org.bukkit. as a base package for
   *     any class, including the main class.
   * 
   * 
   * In the plugin.yml, this entry is named main.
   * 
   * Example:
   * main: org.bukkit.plugin.MyPlugin
   *
   * @return the fully qualified main class for the plugin
  */
  getMain(): string;
  /**
   * Gives a human-friendly description of the functionality the plugin
   * provides.
   * 
   * The description can have multiple lines.
   * Displayed when a user types /version PluginName
   * 
   * 
   * In the plugin.yml, this entry is named description.
   * 
   * Example:
   * description: This plugin is so 31337. You can set yourself on fire.
   *
   * @return description of this plugin, or null if not specified
  */
  getDescription(): string | null;
  /**
   * Gives the phase of server startup that the plugin should be loaded.
   * 
   * Possible values are in {@link PluginLoadOrder}.
   * Defaults to {@link PluginLoadOrder#POSTWORLD}.
   * Certain caveats apply to each phase.
   * When different, {@link #getDepend()}, {@link #getSoftDepend()}, and
   *     {@link #getLoadBefore()} become relative in order loaded per-phase.
   *     If a plugin loads at STARTUP, but a dependency loads
   *     at POSTWORLD, the dependency will not be loaded before
   *     the plugin is loaded.
   * 
   * 
   * In the plugin.yml, this entry is named load.
   * 
   * Example:load: STARTUP
   *
   * @return the phase when the plugin should be loaded
  */
  getLoad(): PluginLoadOrder;
  /**
   * Gives the list of authors for the plugin.
   * 
   * Gives credit to the developer.
   * Used in some server error messages to provide helpful feedback on
   *     who to contact when an error occurs.
   * A SpigotMC forum handle or email address is recommended.
   * Is displayed when a user types /version PluginName
   * authors must be in YAML list
   *     format.
   * 
   * 
   * In the plugin.yml, this has two entries, author and
   * authors.
   * 
   * Single author example:
   * author: CaptainInflamo
   * Multiple author example:
   * authors: [Cogito, verrier, EvilSeph]
   * When both are specified, author will be the first entry in the list, so
   * this example:
   * author: Grum
   *authors:
   *- feildmaster
   *- amaranth
   * Is equivilant to this example:
   * authors: [Grum, feildmaster, aramanth]
   *
   * @return an immutable list of the plugin's authors
  */
  getAuthors(): string[];
  /**
   * Gives the list of contributors for the plugin.
   * 
   * Gives credit to those that have contributed to the plugin, though
   *     not enough so to warrant authorship.
   * Unlike {@link #getAuthors()}, contributors will not be mentioned in
   * server error messages as a means of contact.
   * A SpigotMC forum handle or email address is recommended.
   * Is displayed when a user types /version PluginName
   * contributors must be in YAML list
   *     format.
   * 
   * 
   * Example:
   * authors: [Choco, md_5]
   *
   * @return an immutable list of the plugin's contributors
  */
  getContributors(): string[];
  /**
   * Gives the plugin's or plugin's author's website.
   * 
   * A link to the Curse page that includes documentation and downloads
   *     is highly recommended.
   * Displayed when a user types /version PluginName
   * 
   * 
   * In the plugin.yml, this entry is named website.
   * 
   * Example:
   * website: http://www.curse.com/server-mods/minecraft/myplugin
   *
   * @return description of this plugin, or null if not specified
  */
  getWebsite(): string | null;
  /**
   * Gives a list of other plugins that the plugin requires.
   * 
   * Use the value in the {@link #getName()} of the target plugin to
   *     specify the dependency.
   * If any plugin listed here is not found, your plugin will fail to
   *     load at startup.
   * If multiple plugins list each other in depend,
   *     creating a network with no individual plugin does not list another
   *     plugin in the network,
   *     all plugins in that network will fail.
   * depend must be in YAML list
   *     format.
   * 
   * 
   * In the plugin.yml, this entry is named depend.
   * 
   * Example:
   * depend:
   *- OnePlugin
   *- AnotherPlugin
   *
   * @return immutable list of the plugin's dependencies
  */
  getDepend(): string[];
  /**
   * Gives a list of other plugins that the plugin requires for full
   * functionality. The {@link PluginManager} will make best effort to treat
   * all entries here as if they were a {@link #getDepend() dependency}, but
   * will never fail because of one of these entries.
   * 
   * Use the value in the {@link #getName()} of the target plugin to
   *     specify the dependency.
   * When an unresolvable plugin is listed, it will be ignored and does
   *     not affect load order.
   * When a circular dependency occurs (a network of plugins depending
   *     or soft-dependending each other), it will arbitrarily choose a
   *     plugin that can be resolved when ignoring soft-dependencies.
   * softdepend must be in YAML list
   *     format.
   * 
   * 
   * In the plugin.yml, this entry is named softdepend.
   * 
   * Example:
   * softdepend: [OnePlugin, AnotherPlugin]
   *
   * @return immutable list of the plugin's preferred dependencies
  */
  getSoftDepend(): string[];
  /**
   * Gets the list of plugins that should consider this plugin a
   * soft-dependency.
   * 
   * Use the value in the {@link #getName()} of the target plugin to
   *     specify the dependency.
   * The plugin should load before any other plugins listed here.
   * Specifying another plugin here is strictly equivalent to having the
   *     specified plugin's {@link #getSoftDepend()} include {@link
   *     #getName() this plugin}.
   * loadbefore must be in YAML list
   *     format.
   * 
   * 
   * In the plugin.yml, this entry is named loadbefore.
   * 
   * Example:
   * loadbefore:
   *- OnePlugin
   *- AnotherPlugin
   *
   * @return immutable list of plugins that should consider this plugin a
   *     soft-dependency
  */
  getLoadBefore(): string[];
  /**
   * Gives the token to prefix plugin-specific logging messages with.
   * 
   * This includes all messages using {@link Plugin#getLogger()}.
   * If not specified, the server uses the plugin's {@link #getName()
   *     name}.
   * This should clearly indicate what plugin is being logged.
   * 
   * 
   * In the plugin.yml, this entry is named prefix.
   * 
   * Example:prefix: ex-why-zee
   *
   * @return the prefixed logging token, or null if not specified
  */
  getPrefix(): string | null;
  /**
   * Gives the map of command-name to command-properties. Each entry in this
   * map corresponds to a single command and the respective values are the
   * properties of the command. Each property, with the exception of
   * aliases, can be defined at runtime using methods in {@link
   * PluginCommand} and are defined here only as a convenience.
   * 
   * The command section's description
   * 
   *     Node
   *     Method
   *     Type
   *     Description
   *     Example
   * 
   *     description
   *     {@link PluginCommand#setDescription(String)}
   *     String
   *     A user-friendly description for a command. It is useful for
   *         documentation purposes as well as in-game help.
   *     description: Set yourself on fire
   * 
   *     aliases
   *     {@link PluginCommand#setAliases(List)}
   *     String or List of
   *         strings
   *     Alternative command names, with special usefulness for commands
   *         that are already registered. Aliases are not effective when
   *         defined at runtime, so the plugin description file is the
   *         only way to have them properly defined.
   *         
   *         Note: Command aliases may not have a colon in them.
   *     Single alias format:
   *         aliases: combust_me or
   *         multiple alias format:
   *         aliases: [combust_me, combustMe]
   * 
   *     permission
   *     {@link PluginCommand#setPermission(String)}
   *     String
   *     The name of the {@link Permission} required to use the command.
   *         A user without the permission will receive the specified
   *         message (see {@linkplain
   *         PluginCommand#setPermissionMessage(String) below}), or a
   *         standard one if no specific message is defined. Without the
   *         permission node, no {@link
   *         PluginCommand#setExecutor(CommandExecutor) CommandExecutor} or
   *         {@link PluginCommand#setTabCompleter(TabCompleter)} will be called.
   *     permission: inferno.flagrate
   * 
   *     permission-message
   *     {@link PluginCommand#setPermissionMessage(String)}
   *     String
   *     
   *         Displayed to a player that attempts to use a command, but
   *             does not have the required permission. See {@link
   *             PluginCommand#getPermission() above}.
   *         <permission> is a macro that is replaced with the
   *             permission node required to use the command.
   *         Using empty quotes is a valid way to indicate nothing
   *             should be displayed to a player.
   *         
   *     permission-message: You do not have /<permission>
   * 
   *     usage
   *     {@link PluginCommand#setUsage(String)}
   *     String
   *     This message is displayed to a player when the {@link
   *         PluginCommand#setExecutor(CommandExecutor)} {@linkplain
   *         CommandExecutor#onCommand(CommandSender, Command, String, String[]) returns false}.
   *         <command> is a macro that is replaced the command issued.
   *     usage: Syntax error! Perhaps you meant /<command> PlayerName?
   *         It is worth noting that to use a colon in a yaml, like
   *         `usage: Usage: /god [player]', you need to
   *         surround
   *         the message with double-quote:
   *         usage: "Usage: /god [player]"
   * 
   * 
   * The commands are structured as a hiearchy of nested mappings.
   * The primary (top-level, no intendentation) node is
   * `commands', while each individual command name is
   * indented, indicating it maps to some value (in our case, the
   * properties of the table above).
   * 
   * Here is an example bringing together the piecemeal examples above, as
   * well as few more definitions:     *commands:
   *  flagrate:
   *    description: Set yourself on fire.
   *    aliases: [combust_me, combustMe]
   *    permission: inferno.flagrate
   *    permission-message: You do not have /<permission>
   *    usage: Syntax error! Perhaps you meant /<command> PlayerName?
   *  burningdeaths:
   *    description: List how many times you have died by fire.
   *    aliases:
   *    - burning_deaths
   *    - burningDeaths
   *    permission: inferno.burningdeaths
   *    usage: |
   *      /<command> [player]
   *      Example: /<command> - see how many times you have burned to death
   *      Example: /<command> CaptainIce - see how many times CaptainIce has burned to death
   *  # The next command has no description, aliases, etc. defined, but is still valid
   *  # Having an empty declaration is useful for defining the description, permission, and messages from a configuration dynamically
   *  apocalypse:
   *
   * Note: Command names may not have a colon in their name.
   *
   * @return the commands this plugin will register
  */
  getCommands(): Map<string, Map<string, any>>;
  /**
   * Gives the list of permissions the plugin will register at runtime,
   * immediately proceding enabling. The format for defining permissions is
   * a map from permission name to properties. To represent a map without
   * any specific property, empty curly-braces (
   * {} ) may be used (as a null value is not
   * accepted, unlike the {@link #getCommands() commands} above).
   * 
   * A list of optional properties for permissions:
   * 
   * The permission section's description
   * 
   *     Node
   *     Description
   *     Example
   * 
   *     description
   *     Plaintext (user-friendly) description of what the permission
   *         is for.
   *     description: Allows you to set yourself on fire
   * 
   *     default
   *     The default state for the permission, as defined by {@link
   *         Permission#getDefault()}. If not defined, it will be set to
   *         the value of {@link PluginDescriptionFile#getPermissionDefault()}.
   *         
   *         For reference:
   *         true - Represents a positive assignment to
   *             {@link Permissible permissibles}.
   *         false - Represents no assignment to {@link
   *             Permissible permissibles}.
   *         op - Represents a positive assignment to
   *             {@link Permissible#isOp() operator permissibles}.
   *         notop - Represents a positive assignment to
   *             {@link Permissible#isOp() non-operator permissibiles}.
   *         
   *     default: true
   * 
   *     children
   *     Allows other permissions to be set as a {@linkplain
   *         Permission#getChildren() relation} to the parent permission.
   *         When a parent permissions is assigned, child permissions are
   *         respectively assigned as well.
   *         
   *         When a parent permission is assigned negatively, child
   *             permissions are assigned based on an inversion of their
   *             association.
   *         When a parent permission is assigned positively, child
   *             permissions are assigned based on their association.
   *         
   *         
   *         Child permissions may be defined in a number of ways:
   *         Children may be defined as a list of
   *             names. Using a list will treat all children associated
   *             positively to their parent.
   *         Children may be defined as a map. Each permission name maps
   *             to either a boolean (representing the association), or a
   *             nested permission definition (just as another permission).
   *             Using a nested definition treats the child as a positive
   *             association.
   *         A nested permission definition must be a map of these same
   *             properties. To define a valid nested permission without
   *             defining any specific property, empty curly-braces (
   *             {} ) must be used.
   *          A nested permission may carry it's own nested permissions
   *              as children, as they may also have nested permissions, and
   *              so forth. There is no direct limit to how deep the
   *              permission tree is defined.
   *         
   *     As a list:
   *         children: [inferno.flagrate, inferno.burningdeaths]
   *         Or as a mapping:
   *         children:
   *  inferno.flagrate: true
   *  inferno.burningdeaths: true
   *         An additional example showing basic nested values can be seen
   *         here.
   *         
   * 
   * 
   * The permissions are structured as a hiearchy of nested mappings.
   * The primary (top-level, no intendentation) node is
   * `permissions', while each individual permission name is
   * indented, indicating it maps to some value (in our case, the
   * properties of the table above).
   * 
   * Here is an example using some of the properties:     *permissions:
   *  inferno.*:
   *    description: Gives access to all Inferno commands
   *    children:
   *      inferno.flagrate: true
   *      inferno.burningdeaths: true
   *  inferno.flagate:
   *    description: Allows you to ignite yourself
   *    default: true
   *  inferno.burningdeaths:
   *    description: Allows you to see how many times you have burned to death
   *    default: true
   *
   * Another example, with nested definitions, can be found here.
   *
   * @return the permissions this plugin will register
  */
  getPermissions(): Permission[];
  /**
   * Gives the default {@link Permission#getDefault() default} state of
   * {@link #getPermissions() permissions} registered for the plugin.
   * 
   * If not specified, it will be {@link PermissionDefault#OP}.
   * It is matched using {@link PermissionDefault#getByName(String)}
   * It only affects permissions that do not define the
   *     default node.
   * It may be any value in {@link PermissionDefault}.
   * 
   * 
   * In the plugin.yml, this entry is named default-permission.
   * 
   * Example:default-permission: NOT_OP
   *
   * @return the default value for the plugin's permissions
  */
  getPermissionDefault(): PermissionDefault;
  /**
   * Gives a set of every {@link PluginAwareness} for a plugin. An awareness
   * dictates something that a plugin developer acknowledges when the plugin
   * is compiled. Some implementions may define extra awarenesses that are
   * not included in the API. Any unrecognized
   * awareness (one unsupported or in a future version) will cause a dummy
   * object to be created instead of failing.
   *
   * 
   * Currently only supports the enumerated values in {@link
   *     PluginAwareness.Flags}.
   * Each awareness starts the identifier with bang-at
   *     (!@).
   * Unrecognized (future / unimplemented) entries are quietly replaced
   *     by a generic object that implements PluginAwareness.
   * A type of awareness must be defined by the runtime and acknowledged
   *     by the API, effectively discluding any derived type from any
   *     plugin's classpath.
   * awareness must be in YAML list
   *     format.
   * 
   * 
   * In the plugin.yml, this entry is named awareness.
   * 
   * Example:awareness:
   *- !@UTF8
   * 
   * Note: Although unknown versions of some future awareness are
   * gracefully substituted, previous versions of Bukkit (ones prior to the
   * first implementation of awareness) will fail to load a plugin that
   * defines any awareness.
   *
   * @return a set containing every awareness for the plugin
  */
  getAwareness(): Set<PluginAwareness>;
  /**
   * Returns the name of a plugin, including the version. This method is
   * provided for convenience; it uses the {@link #getName()} and {@link
   * #getVersion()} entries.
   *
   * @return a descriptive name of the plugin and respective version
  */
  getFullName(): string;
  /**
   * Gives the API version which this plugin is designed to support. No
   * specific format is guaranteed.
   * 
   * Refer to release notes for supported API versions.
   * 
   * 
   * In the plugin.yml, this entry is named api-version.
   * 
   * Example:api-version: 1.13
   *
   * @return the version of the plugin
  */
  getAPIVersion(): string | null;
  /**
   * Gets the libraries this plugin requires. This is a preview feature.
   * 
   * Libraries must be GAV specifiers and are loaded from Maven Central.
   * 
   * 
   * Example:libraries:
   *     - com.squareup.okhttp3:okhttp:4.9.0
   *
   * @return required libraries
  */
  getLibraries(): string[];
  /**
   * @return unused
   * @deprecated unused
  */
  getClassLoaderOf(): string | null;
  /**
   * Saves this PluginDescriptionFile to the given writer
   *
   * @param writer Writer to output this file to
  */
  save(writer: Writer): void;
  /**
   * @return internal use
   * @deprecated Internal use
  */
  getRawName(): string;
}
/**
 * The PluginLogger class is a modified {@link Logger} that prepends all
 * logging calls with the name of the plugin doing the logging. The API for
 * PluginLogger is exactly the same as {@link Logger}.
 *
 * @see Logger
*/
export class PluginLogger extends Logger {
  /**
   * Creates a new PluginLogger that extracts the name from a plugin.
   *
   * @param context A reference to the plugin
  */
  constructor(context: Plugin);
  log(logRecord: LogRecord): void;
}
/**
 * Represents a base {@link Plugin}
 * 
 * Extend this class if your plugin is not a {@link
 * org.bukkit.plugin.java.JavaPlugin}
*/
export class PluginBase extends Plugin {
  hashCode(): number;
  equals(obj: any): boolean;
  /**
   * Returns the name of the plugin.
   * 
   * This should return the bare name of the plugin and should be used for
   * comparison.
   *
   * @return name of the plugin
  */
  getName(): string;
}
/**
 * Thrown when attempting to load an invalid Plugin file
*/
export class InvalidPluginException extends Exception {
  /**
   * Constructs a new InvalidPluginException based on the given Exception
   *
   * @param cause Exception that triggered this Exception
  */
  constructor(cause: Throwable);
  /**
   * Constructs a new InvalidPluginException
  */
  constructor();
  /**
   * Constructs a new InvalidPluginException with the specified detail
   * message and cause.
   *
   * @param message the detail message (which is saved for later retrieval
   *     by the getMessage() method).
   * @param cause the cause (which is saved for later retrieval by the
   *     getCause() method). (A null value is permitted, and indicates that
   *     the cause is nonexistent or unknown.)
  */
  constructor(message: string, cause: Throwable);
  /**
   * Constructs a new InvalidPluginException with the specified detail
   * message
   *
   * @param message TThe detail message is saved for later retrieval by the
   *     getMessage() method.
  */
  constructor(message: string);
}
/**
 * Represents a Plugin
 * 
 * The use of {@link PluginBase} is recommended for actual Implementation
*/
export class Plugin extends TabExecutor {
  /**
   * Returns the folder that the plugin data's files are located in. The
   * folder may not yet exist.
   *
   * @return The folder
  */
  getDataFolder(): File;
  /**
   * Returns the plugin.yaml file containing the details for this plugin
   *
   * @return Contents of the plugin.yaml file
  */
  getDescription(): PluginDescriptionFile;
  /**
   * Gets a {@link FileConfiguration} for this plugin, read through
   * "config.yml"
   * 
   * If there is a default config.yml embedded in this plugin, it will be
   * provided as a default for this Configuration.
   *
   * @return Plugin configuration
  */
  getConfig(): FileConfiguration;
  /**
   * Gets an embedded resource in this plugin
   *
   * @param filename Filename of the resource
   * @return File if found, otherwise null
  */
  getResource(filename: string): InputStream | null;
  /**
   * Saves the {@link FileConfiguration} retrievable by {@link #getConfig()}.
  */
  saveConfig(): void;
  /**
   * Saves the raw contents of the default config.yml file to the location
   * retrievable by {@link #getConfig()}.
   * 
   * This should fail silently if the config.yml already exists.
  */
  saveDefaultConfig(): void;
  /**
   * Saves the raw contents of any resource embedded with a plugin's .jar
   * file assuming it can be found using {@link #getResource(String)}.
   * 
   * The resource is saved into the plugin's data folder using the same
   * hierarchy as the .jar file (subdirectories are preserved).
   *
   * @param resourcePath the embedded resource path to look for within the
   *     plugin's .jar file. (No preceding slash).
   * @param replace if true, the embedded resource will overwrite the
   *     contents of an existing file.
   * @throws IllegalArgumentException if the resource path is null, empty,
   *     or points to a nonexistent resource.
  */
  saveResource(resourcePath: string, replace: boolean): void;
  /**
   * Discards any data in {@link #getConfig()} and reloads from disk.
  */
  reloadConfig(): void;
  /**
   * Gets the associated PluginLoader responsible for this plugin
   *
   * @return PluginLoader that controls this plugin
  */
  getPluginLoader(): PluginLoader;
  /**
   * Returns the Server instance currently running this plugin
   *
   * @return Server running this plugin
  */
  getServer(): Server;
  /**
   * Returns a value indicating whether or not this plugin is currently
   * enabled
   *
   * @return true if this plugin is enabled, otherwise false
  */
  isEnabled(): boolean;
  /**
   * Called when this plugin is disabled
  */
  onDisable(): void;
  /**
   * Called after a plugin is loaded but before it has been enabled.
   * 
   * When multiple plugins are loaded, the onLoad() for all plugins is
   * called before any onEnable() is called.
  */
  onLoad(): void;
  /**
   * Called when this plugin is enabled
  */
  onEnable(): void;
  /**
   * Simple boolean if we can still nag to the logs about things
   *
   * @return boolean whether we can nag
  */
  isNaggable(): boolean;
  /**
   * Set naggable state
   *
   * @param canNag is this plugin still naggable?
  */
  setNaggable(canNag: boolean): void;
  /**
   * Gets a {@link ChunkGenerator} for use in a default world, as specified
   * in the server configuration
   *
   * @param worldName Name of the world that this will be applied to
   * @param id Unique ID, if any, that was specified to indicate which
   *     generator was requested
   * @return ChunkGenerator for use in the default world generation
  */
  getDefaultWorldGenerator(worldName: string, id: string | null): ChunkGenerator | null;
  /**
   * Gets a {@link BiomeProvider} for use in a default world, as specified
   * in the server configuration
   *
   * @param worldName Name of the world that this will be applied to
   * @param id Unique ID, if any, that was specified to indicate which
   *     biome provider was requested
   * @return BiomeProvider for use in the default world generation
  */
  getDefaultBiomeProvider(worldName: string, id: string | null): BiomeProvider | null;
  /**
   * Returns the plugin logger associated with this server's logger. The
   * returned logger automatically tags all log messages with the plugin's
   * name.
   *
   * @return Logger associated with this plugin
  */
  getLogger(): Logger;
  getComponentLogger(): ComponentLogger;
  getSLF4JLogger(): org_slf4j_Logger;
  /**
   * @deprecated use {@link #getSLF4JLogger()}
  */
  getLog4JLogger(): org_apache_logging_log4j_Logger;
  /**
   * Returns the name of the plugin.
   * 
   * This should return the bare name of the plugin and should be used for
   * comparison.
   *
   * @return name of the plugin
  */
  getName(): string;
}
/**
 * Thrown when attempting to load an invalid PluginDescriptionFile
*/
export class InvalidDescriptionException extends Exception {
  /**
   * Constructs a new InvalidDescriptionException based on the given
   * Exception
   *
   * @param message Brief message explaining the cause of the exception
   * @param cause Exception that triggered this Exception
  */
  constructor(cause: Throwable, message: string);
  /**
   * Constructs a new InvalidDescriptionException based on the given
   * Exception
   *
   * @param cause Exception that triggered this Exception
  */
  constructor(cause: Throwable);
  /**
   * Constructs a new InvalidDescriptionException with the given message
   *
   * @param message Brief message explaining the cause of the exception
  */
  constructor(message: string);
  /**
   * Constructs a new InvalidDescriptionException
  */
  constructor();
}
/**
 * Thrown when a plugin attempts to interact with the server when it is not
 * enabled
*/
export class IllegalPluginAccessException extends RuntimeException {
  /**
   * Creates a new instance of IllegalPluginAccessException
   * without detail message.
  */
  constructor();
  /**
   * Constructs an instance of IllegalPluginAccessException
   * with the specified detail message.
   *
   * @param msg the detail message.
  */
  constructor(msg: string);
}
/**
 * Thrown when attempting to load an invalid Plugin file
*/
export class UnknownDependencyException extends RuntimeException {
  /**
   * Constructs a new UnknownDependencyException based on the given
   * Exception
   *
   * @param throwable Exception that triggered this Exception
  */
  constructor(throwable: Throwable);
  /**
   * Constructs a new UnknownDependencyException with the given message
   *
   * @param message Brief message explaining the cause of the exception
  */
  constructor(message: string);
  /**
   * Create a new {@link UnknownDependencyException} with a message informing
   * about which dependencies are missing for what plugin.
   *
   * @param missingDependencies missing dependencies
   * @param pluginName plugin which is missing said dependencies
  */
  constructor(missingDependencies: Collection<string>, pluginName: string);
  /**
   * Constructs a new UnknownDependencyException based on the given
   * Exception
   *
   * @param message Brief message explaining the cause of the exception
   * @param throwable Exception that triggered this Exception
  */
  constructor(throwable: Throwable, message: string);
  /**
   * Constructs a new UnknownDependencyException
  */
  constructor();
}
/**
 * Represents a concept that a plugin is aware of.
 * 
 * The internal representation may be singleton, or be a parameterized
 * instance, but must be immutable.
*/
export class PluginAwareness {

}
/**
 * Stores relevant information for plugin listeners
*/
export class RegisteredListener {
  constructor(listener: Listener, executor: EventExecutor, priority: EventPriority, plugin: Plugin, ignoreCancelled: boolean);
  /**
   * Gets the listener for this registration
   *
   * @return Registered Listener
  */
  getListener(): Listener;
  /**
   * Gets the plugin for this registration
   *
   * @return Registered Plugin
  */
  getPlugin(): Plugin;
  /**
   * Gets the priority for this registration
   *
   * @return Registered Priority
  */
  getPriority(): EventPriority;
  /**
   * Calls the event executor
   *
   * @param event The event
   * @throws EventException If an event handler throws an exception.
  */
  callEvent(event: Event): void;
  /**
   * Whether this listener accepts cancelled events
   *
   * @return True when ignoring cancelled events
  */
  isIgnoringCancelled(): boolean;
}
/**
 * A simple services manager.
*/
export class SimpleServicesManager extends ServicesManager {
  /**
   * Register a provider of a service.
   *
   * @param  Provider
   * @param service service class
   * @param provider provider to register
   * @param plugin plugin with the provider
   * @param priority priority of the provider
  */
  register<T>(service: Class<T>, provider: T, plugin: Plugin, priority: ServicePriority): void;
  /**
   * Unregister all the providers registered by a particular plugin.
   *
   * @param plugin The plugin
  */
  unregisterAll(plugin: Plugin): void;
  /**
   * Unregister a particular provider for a particular service.
   *
   * @param service The service interface
   * @param provider The service provider implementation
  */
  unregister(service: Class<any>, provider: any): void;
  /**
   * Unregister a particular provider.
   *
   * @param provider The service provider implementation
  */
  unregister(provider: any): void;
  /**
   * Queries for a provider. This may return if no provider has been
   * registered for a service. The highest priority provider is returned.
   *
   * @param  The service interface
   * @param service The service interface
   * @return provider or null
  */
  load<T>(service: Class<T>): T | null;
  /**
   * Queries for a provider registration. This may return if no provider
   * has been registered for a service.
   *
   * @param  The service interface
   * @param service The service interface
   * @return provider registration or null
  */
  getRegistration<T>(service: Class<T>): RegisteredServiceProvider<T> | null;
  /**
   * Get registrations of providers for a plugin.
   *
   * @param plugin The plugin
   * @return provider registrations
  */
  getRegistrations(plugin: Plugin): RegisteredServiceProvider<any>[];
  /**
   * Get registrations of providers for a service. The returned list is
   * an unmodifiable copy.
   *
   * @param  The service interface
   * @param service The service interface
   * @return a copy of the list of registrations
  */
  getRegistrations<T>(service: Class<T>): RegisteredServiceProvider<T>[];
  /**
   * Get a list of known services. A service is known if it has registered
   * providers for it.
   *
   * @return a copy of the set of known services
  */
  getKnownServices(): Set<Class<any>>;
  /**
   * Returns whether a provider has been registered for a service.
   *
   * @param  service
   * @param service service to check
   * @return true if and only if there are registered providers
  */
  isProvidedFor<T>(service: Class<T>): boolean;
}
/**
 * A registered service provider.
 *
 * @param  Service
*/
export class RegisteredServiceProvider<T> extends Comparable<RegisteredServiceProvider<any>> {
  constructor(service: Class<T>, provider: T, priority: ServicePriority, plugin: Plugin);
  getService(): Class<T>;
  getPlugin(): Plugin;
  getProvider(): T;
  getPriority(): ServicePriority;
  compareTo(other: RegisteredServiceProvider<any>): number;
}
/**
 * Handles all plugin management from the Server
*/
export class PluginManager {
  /**
   * Registers the specified plugin loader
   *
   * @param loader Class name of the PluginLoader to register
   * @throws IllegalArgumentException Thrown when the given Class is not a
   *     valid PluginLoader
  */
  registerInterface(loader: Class<PluginLoader>): void;
  /**
   * Checks if the given plugin is loaded and returns it when applicable
   * 
   * Please note that the name of the plugin is case-sensitive
   *
   * @param name Name of the plugin to check
   * @return Plugin if it exists, otherwise null
  */
  getPlugin(name: string): Plugin | null;
  /**
   * Gets a list of all currently loaded plugins
   *
   * @return Array of Plugins
  */
  getPlugins(): Plugin[];
  /**
   * Checks if the given plugin is enabled or not
   * 
   * Please note that the name of the plugin is case-sensitive.
   *
   * @param name Name of the plugin to check
   * @return true if the plugin is enabled, otherwise false
  */
  isPluginEnabled(name: string): boolean;
  /**
   * Checks if the given plugin is enabled or not
   *
   * @param plugin Plugin to check
   * @return true if the plugin is enabled, otherwise false
  */
  isPluginEnabled(plugin: Plugin | null): boolean;
  /**
   * Loads the plugin in the specified file
   * 
   * File must be valid according to the current enabled Plugin interfaces
   *
   * @param file File containing the plugin to load
   * @return The Plugin loaded, or null if it was invalid
   * @throws InvalidPluginException Thrown when the specified file is not a
   *     valid plugin
   * @throws InvalidDescriptionException Thrown when the specified file
   *     contains an invalid description
   * @throws UnknownDependencyException If a required dependency could not
   *     be resolved
  */
  loadPlugin(file: File): Plugin | null;
  /**
   * Loads the plugins contained within the specified directory
   *
   * @param directory Directory to check for plugins
   * @return A list of all plugins loaded
  */
  loadPlugins(directory: File): Plugin[];
  /**
   * Disables all the loaded plugins
  */
  disablePlugins(): void;
  /**
   * Disables and removes all plugins
  */
  clearPlugins(): void;
  /**
   * Calls an event with the given details
   *
   * @param event Event details
   * @throws IllegalStateException Thrown when an asynchronous event is
   *     fired from synchronous code.
   *     
   *     Note: This is best-effort basis, and should not be used to test
   *     synchronized state. This is an indicator for flawed flow logic.
  */
  callEvent(event: Event): void;
  /**
   * Registers all the events in the given listener class
   *
   * @param listener Listener to register
   * @param plugin Plugin to register
  */
  registerEvents(listener: Listener, plugin: Plugin): void;
  /**
   * Registers the specified executor to the given event class
   *
   * @param event Event type to register
   * @param listener Listener to register
   * @param priority Priority to register this event at
   * @param executor EventExecutor to register
   * @param plugin Plugin to register
  */
  registerEvent(event: Class<Event>, listener: Listener, priority: EventPriority, executor: EventExecutor, plugin: Plugin): void;
  /**
   * Registers the specified executor to the given event class
   *
   * @param event Event type to register
   * @param listener Listener to register
   * @param priority Priority to register this event at
   * @param executor EventExecutor to register
   * @param plugin Plugin to register
   * @param ignoreCancelled Whether to pass cancelled events or not
  */
  registerEvent(event: Class<Event>, listener: Listener, priority: EventPriority, executor: EventExecutor, plugin: Plugin, ignoreCancelled: boolean): void;
  /**
   * Enables the specified plugin
   * 
   * Attempting to enable a plugin that is already enabled will have no
   * effect
   *
   * @param plugin Plugin to enable
  */
  enablePlugin(plugin: Plugin): void;
  /**
   * Disables the specified plugin
   * 
   * Attempting to disable a plugin that is not enabled will have no effect
   *
   * @param plugin Plugin to disable
  */
  disablePlugin(plugin: Plugin): void;
  /**
   * This method is no longer useful as upstream has
   * made it so plugin classloaders are always closed on disable.
   * Use {@link #disablePlugin(Plugin)} instead.
   *
   * @param plugin Plugin to disable
   * @param closeClassloader unused
   * @deprecated Classloader is always closed by upstream now.
  */
  disablePlugin(plugin: Plugin, closeClassloader: boolean): void;
  /**
   * Gets a {@link Permission} from its fully qualified name
   *
   * @param name Name of the permission
   * @return Permission, or null if none
  */
  getPermission(name: string): Permission | null;
  /**
   * Adds a {@link Permission} to this plugin manager.
   * 
   * If a permission is already defined with the given name of the new
   * permission, an exception will be thrown.
   *
   * @param perm Permission to add
   * @throws IllegalArgumentException Thrown when a permission with the same
   *     name already exists
  */
  addPermission(perm: Permission): void;
  /**
   * Removes a {@link Permission} registration from this plugin manager.
   * 
   * If the specified permission does not exist in this plugin manager,
   * nothing will happen.
   * 
   * Removing a permission registration will not remove the
   * permission from any {@link Permissible}s that have it.
   *
   * @param perm Permission to remove
  */
  removePermission(perm: Permission): void;
  /**
   * Removes a {@link Permission} registration from this plugin manager.
   * 
   * If the specified permission does not exist in this plugin manager,
   * nothing will happen.
   * 
   * Removing a permission registration will not remove the
   * permission from any {@link Permissible}s that have it.
   *
   * @param name Permission to remove
  */
  removePermission(name: string): void;
  /**
   * Gets the default permissions for the given op status
   *
   * @param op Which set of default permissions to get
   * @return The default permissions
  */
  getDefaultPermissions(op: boolean): Set<Permission>;
  /**
   * Recalculates the defaults for the given {@link Permission}.
   * 
   * This will have no effect if the specified permission is not registered
   * here.
   *
   * @param perm Permission to recalculate
  */
  recalculatePermissionDefaults(perm: Permission): void;
  /**
   * Subscribes the given Permissible for information about the requested
   * Permission, by name.
   * 
   * If the specified Permission changes in any form, the Permissible will
   * be asked to recalculate.
   *
   * @param permission Permission to subscribe to
   * @param permissible Permissible subscribing
  */
  subscribeToPermission(permission: string, permissible: Permissible): void;
  /**
   * Unsubscribes the given Permissible for information about the requested
   * Permission, by name.
   *
   * @param permission Permission to unsubscribe from
   * @param permissible Permissible subscribing
  */
  unsubscribeFromPermission(permission: string, permissible: Permissible): void;
  /**
   * Gets a set containing all subscribed {@link Permissible}s to the given
   * permission, by name
   *
   * @param permission Permission to query for
   * @return Set containing all subscribed permissions
  */
  getPermissionSubscriptions(permission: string): Set<Permissible>;
  /**
   * Subscribes to the given Default permissions by operator status
   * 
   * If the specified defaults change in any form, the Permissible will be
   * asked to recalculate.
   *
   * @param op Default list to subscribe to
   * @param permissible Permissible subscribing
  */
  subscribeToDefaultPerms(op: boolean, permissible: Permissible): void;
  /**
   * Unsubscribes from the given Default permissions by operator status
   *
   * @param op Default list to unsubscribe from
   * @param permissible Permissible subscribing
  */
  unsubscribeFromDefaultPerms(op: boolean, permissible: Permissible): void;
  /**
   * Gets a set containing all subscribed {@link Permissible}s to the given
   * default list, by op status
   *
   * @param op Default list to query for
   * @return Set containing all subscribed permissions
  */
  getDefaultPermSubscriptions(op: boolean): Set<Permissible>;
  /**
   * Gets a set of all registered permissions.
   * 
   * This set is a copy and will not be modified live.
   *
   * @return Set containing all current registered permissions
  */
  getPermissions(): Set<Permission>;
  /**
   * Returns whether or not timing code should be used for event calls
   *
   * @return True if event timings are to be used
  */
  useTimings(): boolean;
}
/**
 * Extends RegisteredListener to include timing information
*/
export class TimedRegisteredListener extends RegisteredListener {
  constructor(pluginListener: Listener, eventExecutor: EventExecutor, eventPriority: EventPriority, registeredPlugin: Plugin, listenCancelled: boolean);
  callEvent(event: Event): void;
  /**
   * Resets the call count and total time for this listener
  */
  reset(): void;
  /**
   * Gets the total times this listener has been called
   *
   * @return Times this listener has been called
  */
  getCount(): number;
  /**
   * Gets the total time calls to this listener have taken
   *
   * @return Total time for all calls of this listener
  */
  getTotalTime(): number;
  /**
   * Gets the class of the events this listener handled. If it handled
   * multiple classes of event, the closest shared superclass will be
   * returned, such that for any event this listener has handled,
   * this.getEventClass().isAssignableFrom(event.getClass())
   * and no class this.getEventClass().isAssignableFrom(clazz)
   * {@literal && this.getEventClass() != clazz &&}
   * event.getClass().isAssignableFrom(clazz) for all handled events.
   *
   * @return the event class handled by this RegisteredListener
  */
  getEventClass(): Class<Event> | null;
  /**
   * Gets whether this listener has handled multiple events, such that for
   * some two events, eventA.getClass() != eventB.getClass().
   *
   * @return true if this listener has handled multiple events
  */
  hasMultiple(): boolean;
}
/**
 * Represents the order in which a plugin should be initialized and enabled
*/
export class PluginLoadOrder extends Enum<PluginLoadOrder> {
  /**
   * Indicates that the plugin will be loaded at startup
  */
  static readonly STARTUP: PluginLoadOrder;
  /**
   * Indicates that the plugin will be loaded after the first/default world
   * was created
  */
  static readonly POSTWORLD: PluginLoadOrder;
  static valueOf(name: string): PluginLoadOrder;
  static values(): PluginLoadOrder[];
}
/**
 * Interface which defines the class for event call backs to plugins
*/
export class EventExecutor {
  execute(listener: Listener, event: Event): void;
  static readonly eventExecutorMap: ConcurrentMap<Method, Class<EventExecutor>>;
  static create(m: Method, eventClass: Class<Event>): EventExecutor;
}
/**
 * Represents a plugin loader, which handles direct access to specific types
 * of plugins
*/
export class PluginLoader {
  /**
   * Loads the plugin contained in the specified file
   *
   * @param file File to attempt to load
   * @return Plugin that was contained in the specified file, or null if
   *     unsuccessful
   * @throws InvalidPluginException Thrown when the specified file is not a
   *     plugin
   * @throws UnknownDependencyException If a required dependency could not
   *     be found
  */
  loadPlugin(file: File): Plugin;
  /**
   * Loads a PluginDescriptionFile from the specified file
   *
   * @param file File to attempt to load from
   * @return A new PluginDescriptionFile loaded from the plugin.yml in the
   *     specified file
   * @throws InvalidDescriptionException If the plugin description file
   *     could not be created
  */
  getPluginDescription(file: File): PluginDescriptionFile;
  /**
   * Returns a list of all filename filters expected by this PluginLoader
   *
   * @return The filters
  */
  getPluginFileFilters(): Pattern[];
  /**
   * Creates and returns registered listeners for the event classes used in
   * this listener
   *
   * @param listener The object that will handle the eventual call back
   * @param plugin The plugin to use when creating registered listeners
   * @return The registered listeners.
  */
  createRegisteredListeners(listener: Listener, plugin: Plugin): Map<Class<Event>, Set<RegisteredListener>>;
  /**
   * Enables the specified plugin
   * 
   * Attempting to enable a plugin that is already enabled will have no
   * effect
   *
   * @param plugin Plugin to enable
  */
  enablePlugin(plugin: Plugin): void;
  /**
   * Disables the specified plugin
   * 
   * Attempting to disable a plugin that is not enabled will have no effect
   *
   * @param plugin Plugin to disable
  */
  disablePlugin(plugin: Plugin): void;
  /**
   * This method is no longer useful as upstream has
   * made it so plugin classloaders are always closed on disable.
   * Use {@link #disablePlugin(Plugin)} instead.
   *
   * @param plugin Plugin to disable
   * @param closeClassloader unused
   * @deprecated Classloader is always closed by upstream now.
  */
  disablePlugin(plugin: Plugin, closeClassloader: boolean): void;
}
/**
 * Represents various priorities of a provider.
*/
export class ServicePriority extends Enum<ServicePriority> {
  static readonly Lowest: ServicePriority;
  static readonly Low: ServicePriority;
  static readonly Normal: ServicePriority;
  static readonly High: ServicePriority;
  static readonly Highest: ServicePriority;
  static valueOf(name: string): ServicePriority;
  static values(): ServicePriority[];
}
/**
 * Handles all plugin management from the Server
*/
export class SimplePluginManager extends PluginManager {
  constructor(instance: Server, commandMap: SimpleCommandMap);
  /**
   * Registers the specified plugin loader
   *
   * @param loader Class name of the PluginLoader to register
   * @throws IllegalArgumentException Thrown when the given Class is not a
   *     valid PluginLoader
  */
  registerInterface(loader: Class<PluginLoader>): void;
  /**
   * Loads the plugins contained within the specified directory
   *
   * @param directory Directory to check for plugins
   * @return A list of all plugins loaded
  */
  loadPlugins(directory: File): Plugin[];
  loadPlugins(directory: File, extraPluginJars: File[]): Plugin[];
  /**
   * Loads the plugin in the specified file
   * 
   * File must be valid according to the current enabled Plugin interfaces
   *
   * @param file File containing the plugin to load
   * @return The Plugin loaded, or null if it was invalid
   * @throws InvalidPluginException Thrown when the specified file is not a
   *     valid plugin
   * @throws UnknownDependencyException If a required dependency could not
   *     be found
  */
  loadPlugin(file: File): Plugin | null;
  /**
   * Checks if the given plugin is loaded and returns it when applicable
   * 
   * Please note that the name of the plugin is case-sensitive
   *
   * @param name Name of the plugin to check
   * @return Plugin if it exists, otherwise null
  */
  getPlugin(name: string): Plugin | null;
  /**
   * Gets a list of all currently loaded plugins
   *
   * @return Array of Plugins
  */
  getPlugins(): Plugin[];
  /**
   * Checks if the given plugin is enabled or not
   * 
   * Please note that the name of the plugin is case-sensitive.
   *
   * @param name Name of the plugin to check
   * @return true if the plugin is enabled, otherwise false
  */
  isPluginEnabled(name: string): boolean;
  /**
   * Checks if the given plugin is enabled or not
   *
   * @param plugin Plugin to check
   * @return true if the plugin is enabled, otherwise false
  */
  isPluginEnabled(plugin: Plugin | null): boolean;
  /**
   * Enables the specified plugin
   * 
   * Attempting to enable a plugin that is already enabled will have no
   * effect
   *
   * @param plugin Plugin to enable
  */
  enablePlugin(plugin: Plugin): void;
  /**
   * Disables all the loaded plugins
  */
  disablePlugins(): void;
  /**
   * This method is no longer useful as upstream has
   * made it so plugin classloaders are always closed on disable.
   * Use {@link #disablePlugins()} instead.
   *
   * @param closeClassloaders unused
   * @deprecated Classloader is always closed by upstream now.
  */
  disablePlugins(closeClassloaders: boolean): void;
  /**
   * Disables the specified plugin
   * 
   * Attempting to disable a plugin that is not enabled will have no effect
   *
   * @param plugin Plugin to disable
  */
  disablePlugin(plugin: Plugin): void;
  /**
   * Disables and removes all plugins
  */
  clearPlugins(): void;
  /**
   * Calls an event with the given details.
   *
   * @param event Event details
  */
  callEvent(event: Event): void;
  /**
   * Registers all the events in the given listener class
   *
   * @param listener Listener to register
   * @param plugin Plugin to register
  */
  registerEvents(listener: Listener, plugin: Plugin): void;
  /**
   * Registers the specified executor to the given event class
   *
   * @param event Event type to register
   * @param listener Listener to register
   * @param priority Priority to register this event at
   * @param executor EventExecutor to register
   * @param plugin Plugin to register
  */
  registerEvent(event: Class<Event>, listener: Listener, priority: EventPriority, executor: EventExecutor, plugin: Plugin): void;
  /**
   * Registers the given event to the specified listener using a directly
   * passed EventExecutor
   *
   * @param event Event class to register
   * @param listener PlayerListener to register
   * @param priority Priority of this event
   * @param executor EventExecutor to register
   * @param plugin Plugin to register
   * @param ignoreCancelled Do not call executor if event was already
   *     cancelled
  */
  registerEvent(event: Class<Event>, listener: Listener, priority: EventPriority, executor: EventExecutor, plugin: Plugin, ignoreCancelled: boolean): void;
  /**
   * Gets a {@link Permission} from its fully qualified name
   *
   * @param name Name of the permission
   * @return Permission, or null if none
  */
  getPermission(name: string): Permission | null;
  /**
   * Adds a {@link Permission} to this plugin manager.
   * 
   * If a permission is already defined with the given name of the new
   * permission, an exception will be thrown.
   *
   * @param perm Permission to add
   * @throws IllegalArgumentException Thrown when a permission with the same
   *     name already exists
  */
  addPermission(perm: Permission): void;
  addPermission(perm: Permission, dirty: boolean): void;
  /**
   * Gets the default permissions for the given op status
   *
   * @param op Which set of default permissions to get
   * @return The default permissions
  */
  getDefaultPermissions(op: boolean): Set<Permission>;
  /**
   * Removes a {@link Permission} registration from this plugin manager.
   * 
   * If the specified permission does not exist in this plugin manager,
   * nothing will happen.
   * 
   * Removing a permission registration will not remove the
   * permission from any {@link Permissible}s that have it.
   *
   * @param perm Permission to remove
  */
  removePermission(perm: Permission): void;
  /**
   * Removes a {@link Permission} registration from this plugin manager.
   * 
   * If the specified permission does not exist in this plugin manager,
   * nothing will happen.
   * 
   * Removing a permission registration will not remove the
   * permission from any {@link Permissible}s that have it.
   *
   * @param perm Permission to remove
  */
  removePermission(name: string): void;
  /**
   * Recalculates the defaults for the given {@link Permission}.
   * 
   * This will have no effect if the specified permission is not registered
   * here.
   *
   * @param perm Permission to recalculate
  */
  recalculatePermissionDefaults(perm: Permission): void;
  dirtyPermissibles(): void;
  /**
   * Subscribes the given Permissible for information about the requested
   * Permission, by name.
   * 
   * If the specified Permission changes in any form, the Permissible will
   * be asked to recalculate.
   *
   * @param permission Permission to subscribe to
   * @param permissible Permissible subscribing
  */
  subscribeToPermission(permission: string, permissible: Permissible): void;
  /**
   * Unsubscribes the given Permissible for information about the requested
   * Permission, by name.
   *
   * @param permission Permission to unsubscribe from
   * @param permissible Permissible subscribing
  */
  unsubscribeFromPermission(permission: string, permissible: Permissible): void;
  /**
   * Gets a set containing all subscribed {@link Permissible}s to the given
   * permission, by name
   *
   * @param permission Permission to query for
   * @return Set containing all subscribed permissions
  */
  getPermissionSubscriptions(permission: string): Set<Permissible>;
  /**
   * Subscribes to the given Default permissions by operator status
   * 
   * If the specified defaults change in any form, the Permissible will be
   * asked to recalculate.
   *
   * @param op Default list to subscribe to
   * @param permissible Permissible subscribing
  */
  subscribeToDefaultPerms(op: boolean, permissible: Permissible): void;
  /**
   * Unsubscribes from the given Default permissions by operator status
   *
   * @param op Default list to unsubscribe from
   * @param permissible Permissible subscribing
  */
  unsubscribeFromDefaultPerms(op: boolean, permissible: Permissible): void;
  /**
   * Gets a set containing all subscribed {@link Permissible}s to the given
   * default list, by op status
   *
   * @param op Default list to query for
   * @return Set containing all subscribed permissions
  */
  getDefaultPermSubscriptions(op: boolean): Set<Permissible>;
  /**
   * Gets a set of all registered permissions.
   * 
   * This set is a copy and will not be modified live.
   *
   * @return Set containing all current registered permissions
  */
  getPermissions(): Set<Permission>;
  isTransitiveDepend(plugin: PluginDescriptionFile, depend: PluginDescriptionFile): boolean;
  /**
   * Returns whether or not timing code should be used for event calls
   *
   * @return True if event timings are to be used
  */
  useTimings(): boolean;
  /**
   * Sets whether or not per event timing code should be used
   *
   * @param use True if per event timing code should be used
  */
  useTimings(use: boolean): void;
  clearPermissions(): void;
  /**
   * This method is no longer useful as upstream has
   * made it so plugin classloaders are always closed on disable.
   * Use {@link #disablePlugin(Plugin)} instead.
   *
   * @param plugin Plugin to disable
   * @param closeClassloader unused
   * @deprecated Classloader is always closed by upstream now.
  */
  disablePlugin(plugin: Plugin, closeClassloader: boolean): void;
}

}
declare module 'org.bukkit.command.CommandSender' {
export class Spigot {

}

}
declare module 'org.bukkit.entity.Rabbit' {
import { Enum } from 'java.lang';
/**
 * Represents the various types a Rabbit might be.
*/
export class Type extends Enum<Type> {
  /**
   * Chocolate colored rabbit.
  */
  static readonly BROWN: Type;
  /**
   * Pure white rabbit.
  */
  static readonly WHITE: Type;
  /**
   * Black rabbit.
  */
  static readonly BLACK: Type;
  /**
   * Black with white patches, or white with black patches?
  */
  static readonly BLACK_AND_WHITE: Type;
  /**
   * Golden bunny.
  */
  static readonly GOLD: Type;
  /**
   * Salt and pepper colored, whatever that means.
  */
  static readonly SALT_AND_PEPPER: Type;
  /**
   * Rabbit with pure white fur, blood red horizontal eyes, and is hostile to players.
  */
  static readonly THE_KILLER_BUNNY: Type;
  static valueOf(name: string): Type;
  static values(): Type[];
}

}
declare module 'org.bukkit.event.player.PlayerLoginEvent' {
import { Enum } from 'java.lang';
/**
 * Basic kick reasons for communicating to plugins
*/
export class Result extends Enum<Result> {
  /**
   * The player is allowed to log in
  */
  static readonly ALLOWED: Result;
  /**
   * The player is not allowed to log in, due to the server being full
  */
  static readonly KICK_FULL: Result;
  /**
   * The player is not allowed to log in, due to them being banned
  */
  static readonly KICK_BANNED: Result;
  /**
   * The player is not allowed to log in, due to them not being on the
   * white list
  */
  static readonly KICK_WHITELIST: Result;
  /**
   * The player is not allowed to log in, for reasons undefined
  */
  static readonly KICK_OTHER: Result;
  static valueOf(name: string): Result;
  static values(): Result[];
}

}
declare module 'org.bukkit.event.entity.VillagerCareerChangeEvent' {
import { Enum } from 'java.lang';
/**
 * Reasons for the villager's profession changing.
*/
export class ChangeReason extends Enum<ChangeReason> {
  /**
   * Villager lost their job due to too little experience.
  */
  static readonly LOSING_JOB: ChangeReason;
  /**
   * Villager gained employment.
  */
  static readonly EMPLOYED: ChangeReason;
  static valueOf(name: string): ChangeReason;
  static values(): ChangeReason[];
}

}
declare module 'org.bukkit.entity.Cat' {
import { Enum } from 'java.lang';
/**
 * Represents the various different cat types there are.
*/
export class Type extends Enum<Type> {
  static readonly TABBY: Type;
  static readonly BLACK: Type;
  static readonly RED: Type;
  static readonly SIAMESE: Type;
  static readonly BRITISH_SHORTHAIR: Type;
  static readonly CALICO: Type;
  static readonly PERSIAN: Type;
  static readonly RAGDOLL: Type;
  static readonly WHITE: Type;
  static readonly JELLIE: Type;
  static readonly ALL_BLACK: Type;
  static valueOf(name: string): Type;
  static values(): Type[];
}

}
declare module 'org.bukkit.map.MapCursor' {
import { Enum } from 'java.lang';
/**
 * Represents the standard types of map cursors. More may be made
 * available by resource packs - the value is used by the client as an
 * index in the file './misc/mapicons.png' from minecraft.jar or from a
 * resource pack.
*/
export class Type extends Enum<Type> {
  static readonly WHITE_POINTER: Type;
  static readonly GREEN_POINTER: Type;
  static readonly RED_POINTER: Type;
  static readonly BLUE_POINTER: Type;
  static readonly WHITE_CROSS: Type;
  static readonly RED_MARKER: Type;
  static readonly WHITE_CIRCLE: Type;
  static readonly SMALL_WHITE_CIRCLE: Type;
  static readonly MANSION: Type;
  static readonly TEMPLE: Type;
  static readonly BANNER_WHITE: Type;
  static readonly BANNER_ORANGE: Type;
  static readonly BANNER_MAGENTA: Type;
  static readonly BANNER_LIGHT_BLUE: Type;
  static readonly BANNER_YELLOW: Type;
  static readonly BANNER_LIME: Type;
  static readonly BANNER_PINK: Type;
  static readonly BANNER_GRAY: Type;
  static readonly BANNER_LIGHT_GRAY: Type;
  static readonly BANNER_CYAN: Type;
  static readonly BANNER_PURPLE: Type;
  static readonly BANNER_BLUE: Type;
  static readonly BANNER_BROWN: Type;
  static readonly BANNER_GREEN: Type;
  static readonly BANNER_RED: Type;
  static readonly BANNER_BLACK: Type;
  static readonly RED_X: Type;
  static valueOf(name: string): Type;
  static values(): Type[];
  /**
   * Gets the internal value of the cursor.
   *
   * @return the value
   * @deprecated Magic value
  */
  getValue(): number;
  /**
   * Get a cursor by its internal value.
   *
   * @param value the value
   * @return the matching type
   * @deprecated Magic value
  */
  static byValue(value: number): Type | null;
}

}
declare module 'org.bukkit.Vibration.Destination' {
import { Block } from 'org.bukkit.block';
import { Destination } from 'org.bukkit.Vibration';
import { Location } from 'org.bukkit';
import { Entity } from 'org.bukkit.entity';
export class EntityDestination extends Destination {
  constructor(entity: Entity);
  getEntity(): Entity;
}
export class BlockDestination extends Destination {
  constructor(block: Location);
  constructor(block: Block);
  getLocation(): Location;
  getBlock(): Block;
}

}
declare module 'org.bukkit.entity.FishHook' {
import { Enum } from 'java.lang';
/**
 * Represents a state in which a fishing hook may be.
*/
export class HookState extends Enum<HookState> {
  /**
   * The fishing hook has been cast and is either in the air or resting
   * against a block on the ground.
  */
  static readonly UNHOOKED: HookState;
  /**
   * The fishing hook has hooked an entity.
  */
  static readonly HOOKED_ENTITY: HookState;
  /**
   * The fishing hook is bobbing in the water, waiting for a bite.
  */
  static readonly BOBBING: HookState;
  static valueOf(name: string): HookState;
  static values(): HookState[];
}

}
declare module 'org.bukkit.map.MapFont' {
/**
 * Represents the graphics for a single character in a MapFont.
*/
export class CharacterSprite {
  constructor(width: number, height: number, data: boolean[]);
  /**
   * Get the value of a pixel of the character.
   *
   * @param row The row, in the range [0,8).
   * @param col The column, in the range [0,8).
   * @return True if the pixel is solid, false if transparent.
  */
  get(row: number, col: number): boolean;
  /**
   * Get the width of the character sprite.
   *
   * @return The width of the character.
  */
  getWidth(): number;
  /**
   * Get the height of the character sprite.
   *
   * @return The height of the character.
  */
  getHeight(): number;
}

}
declare module 'org.bukkit.block.data.Bisected' {
import { Enum } from 'java.lang';
/**
 * The half of a vertically bisected block.
*/
export class Half extends Enum<Half> {
  /**
   * The top half of the block, normally with the higher y coordinate.
  */
  static readonly TOP: Half;
  /**
   * The bottom half of the block, normally with the lower y coordinate.
  */
  static readonly BOTTOM: Half;
  static valueOf(name: string): Half;
  static values(): Half[];
}

}
declare module 'org.bukkit.potion.PotionEffectType' {
import { Enum } from 'java.lang';
import { TextColor } from 'net.kyori.adventure.text.format';
/**
 * Category of {@link PotionEffectType}s
*/
export class Category extends Enum<Category> {
  static readonly BENEFICIAL: Category;
  static readonly HARMFUL: Category;
  static readonly NEUTRAL: Category;
  static valueOf(name: string): Category;
  static values(): Category[];
  /**
   * Gets the text color used when displaying potions
   * of this category.
   *
   * @return the text color
  */
  getColor(): TextColor;
}

}
declare module 'org.bukkit.Registry' {
import { Iterator, Map } from 'java.util';
import { NamespacedKey, Registry } from 'org.bukkit';
export class SimpleRegistry<T> extends Registry<T> {
  /**
   * Get the object by its key.
   *
   * @param key non-null key
   * @return item or null if does not exist
  */
  get(key: NamespacedKey): T | null;
  iterator(): Iterator<T>;
}

}
declare module 'org.bukkit.inventory.meta.tags.ItemTagType' {
import { Class } from 'java.lang';
import { ItemTagType, ItemTagAdapterContext } from 'org.bukkit.inventory.meta.tags';
/**
 * A default implementation that simply exists to pass on the retrieved or
 * inserted value to the next layer.
 *
 * This implementation does not add any kind of logic, but is used to
 * provide default implementations for the primitive types.
 *
 * @param  the generic type of the primitive objects
*/
export class PrimitiveTagType<T> extends ItemTagType<T, T> {
  /**
   * Returns the primitive data type of this tag.
   *
   * @return the class
  */
  getPrimitiveType(): Class<T>;
  /**
   * Returns the complex object type the primitive value resembles.
   *
   * @return the class type
  */
  getComplexType(): Class<T>;
  /**
   * Returns the primitive data that resembles the complex object passed to
   * this method.
   *
   * @param complex the complex object instance
   * @param context the context this operation is running in
   * @return the primitive value
  */
  toPrimitive(complex: T, context: ItemTagAdapterContext): T;
  /**
   * Creates a complex object based of the passed primitive value
   *
   * @param primitive the primitive value
   * @param context the context this operation is running in
   * @return the complex object instance
  */
  fromPrimitive(primitive: T, context: ItemTagAdapterContext): T;
}

}
declare module 'org.bukkit.event.player.PlayerRespawnEvent' {
import { Enum } from 'java.lang';
export class RespawnFlag extends Enum<RespawnFlag> {
  /**
   * Will use the bed spawn location
  */
  static readonly BED_SPAWN: RespawnFlag;
  /**
   * Will use the respawn anchor location
  */
  static readonly ANCHOR_SPAWN: RespawnFlag;
  /**
   * Is caused by going to the end portal in the end.
  */
  static readonly END_PORTAL: RespawnFlag;
  static valueOf(name: string): RespawnFlag;
  static values(): RespawnFlag[];
}

}
declare module 'org.bukkit.event.inventory.InventoryCloseEvent' {
import { Enum } from 'java.lang';
export class Reason extends Enum<Reason> {
  /**
   * Unknown reason
  */
  static readonly UNKNOWN: Reason;
  /**
   * Player is teleporting
  */
  static readonly TELEPORT: Reason;
  /**
   * Player is no longer permitted to use this inventory
  */
  static readonly CANT_USE: Reason;
  /**
   * The chunk the inventory was in was unloaded
  */
  static readonly UNLOADED: Reason;
  /**
   * Opening new inventory instead
  */
  static readonly OPEN_NEW: Reason;
  /**
   * Closed
  */
  static readonly PLAYER: Reason;
  /**
   * Closed due to disconnect
  */
  static readonly DISCONNECT: Reason;
  /**
   * The player died
  */
  static readonly DEATH: Reason;
  /**
   * Closed by Bukkit API
  */
  static readonly PLUGIN: Reason;
  static valueOf(name: string): Reason;
  static values(): Reason[];
}

}
declare module 'org.bukkit.loot.LootContext' {
import { LootContext } from 'org.bukkit.loot';
import { Location } from 'org.bukkit';
import { Entity, HumanEntity } from 'org.bukkit.entity';
/**
 * Utility class to make building {@link LootContext} easier. The only
 * required argument is {@link Location} with a valid (non-null)
 * {@link org.bukkit.World}.
*/
export class Builder {
  /**
   * Creates a new LootContext.Builder instance to facilitate easy
   * creation of {@link LootContext}s.
   *
   * @param location the location the LootContext should use
  */
  constructor(location: Location);
  /**
   * Set how much luck to have when generating loot.
   *
   * @param luck the luck level
   * @return the Builder
  */
  luck(luck: number): Builder;
  /**
   * Set the {@link org.bukkit.enchantments.Enchantment#LOOT_BONUS_MOBS}
   * level equivalent to use when generating loot. Values less than or
   * equal to 0 will force the {@link LootTable} to only return a single
   * {@link org.bukkit.inventory.ItemStack} per pool.
   *
   * @param modifier the looting level modifier
   * @return the Builder
  */
  lootingModifier(modifier: number): Builder;
  /**
   * The entity that was killed.
   *
   * @param lootedEntity the looted entity
   * @return the Builder
  */
  lootedEntity(lootedEntity: Entity | null): Builder;
  /**
   * Set the {@link org.bukkit.entity.HumanEntity} that killed
   * {@link #getLootedEntity()}. This entity will be used to get the
   * looting level if {@link #lootingModifier(int)} is not set.
   *
   * @param killer the killer entity
   * @return the Builder
  */
  killer(killer: HumanEntity | null): Builder;
  /**
   * Create a new {@link LootContext} instance using the supplied
   * parameters.
   *
   * @return a new {@link LootContext} instance
  */
  build(): LootContext;
}

}
declare module 'org.bukkit.material' {
import { Cloneable } from 'java.lang';
import { Set, EnumSet, List } from 'java.util';
import { CocoaPlantSize } from 'org.bukkit.material.CocoaPlant';
import { BlockFace } from 'org.bukkit.block';
import { ItemStack } from 'org.bukkit.inventory';
import { EntityType } from 'org.bukkit.entity';
import { MushroomBlockTexture } from 'org.bukkit.material.types';
import { GrassSpecies, CoalType, CropState, NetherWartsState, TreeSpecies, Material, DyeColor, SandstoneType } from 'org.bukkit';
/**
 * Represents a diode/repeater in the on or off state, with a delay and facing
 * in a specific direction.
 *
 * @see Material#LEGACY_DIODE_BLOCK_OFF
 * @see Material#LEGACY_DIODE_BLOCK_ON
 *
 * @deprecated all usage of MaterialData is deprecated and subject to removal.
 * Use {@link org.bukkit.block.data.BlockData}.
*/
export class Diode extends MaterialData {
  /**
   * Constructs a diode switched on, with a delay of 1 and facing the default
   * direction (north).
   *
   * By default this constructor creates a diode that is switched on for
   * backwards compatibility with past implementations.
  */
  constructor();
  /**
   * Constructs a diode switched off, with a delay of 1 and facing the
   * specified direction.
   *
   * @param facingDirection the direction the diode is facing
   *
   * @see BlockFace
  */
  constructor(facingDirection: BlockFace);
  /**
   * Constructs a diode switched off, with the specified delay and facing the
   * specified direction.
   *
   * @param facingDirection the direction the diode is facing
   * @param delay The number of ticks (1-4) before the diode turns on after
   * being powered
   *
   * @see BlockFace
  */
  constructor(facingDirection: BlockFace, delay: number);
  /**
   * Constructs a diode switched on or off, with the specified delay and
   * facing the specified direction.
   *
   * @param facingDirection the direction the diode is facing
   * @param delay The number of ticks (1-4) before the diode turns on after
   * being powered
   * @param state True if the diode is in the on state
   *
   * @see BlockFace
  */
  constructor(facingDirection: BlockFace, delay: number, state: boolean);
  constructor(type: Material);
  /**
   * @param type the type
   * @param data the raw data value
   * @deprecated Magic value
  */
  constructor(type: Material, data: number);
  /**
   * Sets the delay of the repeater.
   *
   * @param delay The new delay (1-4)
  */
  setDelay(delay: number);
  /**
   * Gets the delay of the repeater in ticks.
   *
   * @return The delay (1-4)
  */
  getDelay(): number;
  /**
   * Sets the direction this diode is facing.
   *
   * @param face The direction to set this diode to
   *
   * @see BlockFace
  */
  setFacingDirection(facingDirection: BlockFace);
  /**
   * Gets the direction this diode is facing
   *
   * @return The direction this diode is facing
   *
   * @see BlockFace
  */
  getFacing(): BlockFace;
  toString(): string;
  clone(): Diode;
  /**
   * Checks if the diode is powered.
   *
   * @return true if the diode is powered
  */
  isPowered(): boolean;
}
export interface Diode extends MaterialData, Directional, Redstone {}
/**
 * Represents a pressure plate
 *
 * @deprecated all usage of MaterialData is deprecated and subject to removal.
 * Use {@link org.bukkit.block.data.BlockData}.
*/
export class PressurePlate extends MaterialData {
  constructor();
  constructor(type: Material);
  /**
   * @param type the type
   * @param data the raw data value
   * @deprecated Magic value
  */
  constructor(type: Material, data: number);
  isPressed(): boolean;
  toString(): string;
  clone(): PressurePlate;
}
export interface PressurePlate extends MaterialData, PressureSensor {}
/**
 * Represents a trap door
 *
 * @deprecated all usage of MaterialData is deprecated and subject to removal.
 * Use {@link org.bukkit.block.data.BlockData}.
*/
export class TrapDoor extends SimpleAttachableMaterialData {
  constructor();
  constructor(type: Material);
  /**
   * @param type the type
   * @param data the raw data value
   * @deprecated Magic value
  */
  constructor(type: Material, data: number);
  /**
   * Check to see if the door is open.
   *
   * @return true if the door has swung counterclockwise around its hinge.
  */
  isOpen(): boolean;
  /**
   * Configure this door to be either open or closed;
   *
   * @param isOpen True to open the door.
  */
  setOpen(isOpen: boolean): void;
  /**
   * Test if trapdoor is inverted
   *
   * @return true if inverted (top half), false if normal (bottom half)
  */
  isInverted(): boolean;
  /**
   * Set trapdoor inverted state
   *
   * @param inv - true if inverted (top half), false if normal (bottom half)
  */
  setInverted(inv: boolean): void;
  getAttachedFace(): BlockFace;
  setFacingDirection(facingDirection: BlockFace);
  toString(): string;
  clone(): TrapDoor;
}
export interface TrapDoor extends SimpleAttachableMaterialData, Openable {}
/**
 * Represents a hopper in an active or deactivated state and facing in a
 * specific direction.
 *
 * @see Material#HOPPER
 *
 * @deprecated all usage of MaterialData is deprecated and subject to removal.
 * Use {@link org.bukkit.block.data.BlockData}.
*/
export class Hopper extends MaterialData {
  /**
   * Constructs a hopper facing the default direction (down) and initially
   * active.
  */
  constructor();
  /**
   * Constructs a hopper facing the specified direction and initially active.
   *
   * @param facingDirection the direction the hopper is facing
   *
   * @see BlockFace
  */
  constructor(facingDirection: BlockFace);
  /**
   * Constructs a hopper facing the specified direction and either active or
   * not.
   *
   * @param facingDirection the direction the hopper is facing
   * @param isActive True if the hopper is initially active, false if
   * deactivated
   *
   * @see BlockFace
  */
  constructor(facingDirection: BlockFace, isActive: boolean);
  constructor(type: Material);
  /**
   * @param type the type
   * @param data the raw data value
   * @deprecated Magic value
  */
  constructor(type: Material, data: number);
  /**
   * Sets whether the hopper is active or not.
   *
   * @param isActive True if the hopper is active, false if deactivated as if
   * powered by redstone
  */
  setActive(isActive: boolean): void;
  /**
   * Checks whether the hopper is active or not.
   *
   * @return True if the hopper is active, false if deactivated
  */
  isActive(): boolean;
  /**
   * Sets the direction this hopper is facing
   *
   * @param face The direction to set this hopper to
   *
   * @see BlockFace
  */
  setFacingDirection(facingDirection: BlockFace);
  /**
   * Gets the direction this hopper is facing
   *
   * @return The direction this hopper is facing
   *
   * @see BlockFace
  */
  getFacing(): BlockFace;
  toString(): string;
  clone(): Hopper;
  /**
   * Checks if the hopper is powered.
   *
   * @return true if the hopper is powered
  */
  isPowered(): boolean;
}
export interface Hopper extends MaterialData, Directional, Redstone {}
/**
 * Represents the tripwire
 *
 * @deprecated all usage of MaterialData is deprecated and subject to removal.
 * Use {@link org.bukkit.block.data.BlockData}.
*/
export class Tripwire extends MaterialData {
  constructor();
  /**
   * @param type the type
   * @param data the raw data value
   * @deprecated Magic value
  */
  constructor(type: Material, data: number);
  /**
   * Test if tripwire is currently activated
   *
   * @return true if activated, false if not
  */
  isActivated(): boolean;
  /**
   * Set tripwire activated state
   *
   * @param act - true if activated, false if not
  */
  setActivated(act: boolean): void;
  /**
   * Test if object triggering this tripwire directly
   *
   * @return true if object activating tripwire, false if not
  */
  isObjectTriggering(): boolean;
  /**
   * Set object triggering state for this tripwire
   *
   * @param trig - true if object activating tripwire, false if not
  */
  setObjectTriggering(trig: boolean): void;
  clone(): Tripwire;
  toString(): string;
}
/**
 * Represents the different types of steps.
 *
 * @deprecated all usage of MaterialData is deprecated and subject to removal.
 * Use {@link org.bukkit.block.data.BlockData}.
*/
export class Step extends TexturedMaterial {
  constructor();
  constructor(type: Material);
  /**
   * @param type the type
   * @param data the raw data value
   * @deprecated Magic value
  */
  constructor(type: Material, data: number);
  getTextures(): Material[];
  /**
   * Test if step is inverted
   *
   * @return true if inverted (top half), false if normal (bottom half)
  */
  isInverted(): boolean;
  /**
   * Set step inverted state
   *
   * @param inv - true if step is inverted (top half), false if step is
   *     normal (bottom half)
  */
  setInverted(inv: boolean): void;
  clone(): Step;
  toString(): string;
}
/**
 * Indicated a Material that may carry or create a Redstone current
*/
export class Redstone {
  /**
   * Gets the current state of this Material, indicating if it's powered or
   * unpowered
   *
   * @return true if powered, otherwise false
  */
  isPowered(): boolean;
}
/**
 * Represents minecart rails.
 *
 * @deprecated all usage of MaterialData is deprecated and subject to removal.
 * Use {@link org.bukkit.block.data.BlockData}.
*/
export class Rails extends MaterialData {
  constructor();
  constructor(type: Material);
  /**
   * @param type the type
   * @param data the raw data value
   * @deprecated Magic value
  */
  constructor(type: Material, data: number);
  /**
   * @return the whether this track is set on a slope
  */
  isOnSlope(): boolean;
  /**
   * @return the whether this track is set as a curve
  */
  isCurve(): boolean;
  /**
   * @return the direction these tracks are set
   *     
   *     Note that tracks are bidirectional and that the direction returned
   *     is the ascending direction if the track is set on a slope. If it is
   *     set as a curve, the corner of the track is returned.
  */
  getDirection(): BlockFace;
  toString(): string;
  /**
   * Set the direction of these tracks
   * 
   * Note that tracks are bidirectional and that the direction returned is
   * the ascending direction if the track is set on a slope. If it is set as
   * a curve, the corner of the track should be supplied.
   *
   * @param face the direction the track should be facing
   * @param isOnSlope whether or not the track should be on a slope
  */
  setDirection(face: BlockFace, isOnSlope: boolean): void;
  clone(): Rails;
}
/**
 * Represents a skull.
 *
 * @deprecated all usage of MaterialData is deprecated and subject to removal.
 * Use {@link org.bukkit.block.data.BlockData}.
*/
export class Skull extends MaterialData {
  constructor();
  /**
   * Instantiate a skull facing in a particular direction.
   *
   * @param direction the direction the skull's face is facing
  */
  constructor(direction: BlockFace);
  constructor(type: Material);
  /**
   * @param type the type
   * @param data the raw data value
   * @deprecated Magic value
  */
  constructor(type: Material, data: number);
  /**
   * Sets the direction that this block is facing in
   *
   * @param face The facing direction
  */
  setFacingDirection(facingDirection: BlockFace);
  /**
   * Gets the direction this block is facing
   *
   * @return the direction this block is facing
  */
  getFacing(): BlockFace;
  toString(): string;
  clone(): Skull;
}
export interface Skull extends MaterialData, Directional {}
export class PressureSensor {
  isPressed(): boolean;
}
/**
 * Represents a Wool/Cloth block
 * @deprecated all usage of MaterialData is deprecated and subject to removal.
 * Use {@link org.bukkit.block.data.BlockData}.
*/
export class Wool extends MaterialData {
  constructor();
  constructor(color: DyeColor);
  constructor(type: Material);
  /**
   * @param type the type
   * @param data the raw data value
   * @deprecated Magic value
  */
  constructor(type: Material, data: number);
  /**
   * Gets the current color of this dye
   *
   * @return DyeColor of this dye
  */
  getColor(): DyeColor;
  /**
   * Sets the color of this dye
   *
   * @param color New color of this dye
  */
  setColor(color: DyeColor);
  toString(): string;
  clone(): Wool;
}
export interface Wool extends MaterialData, Colorable {}
/**
 * Represents wood blocks of different species.
 *
 * @see Material#LEGACY_WOOD
 * @see Material#LEGACY_SAPLING
 * @see Material#LEGACY_WOOD_DOUBLE_STEP
 *
 * @deprecated all usage of MaterialData is deprecated and subject to removal.
 * Use {@link org.bukkit.block.data.BlockData}.
*/
export class Wood extends MaterialData {
  /**
   * Constructs a wood block.
  */
  constructor();
  /**
   * Constructs a wood block of the given tree species.
   *
   * @param species the species of the wood block
  */
  constructor(species: TreeSpecies);
  /**
   * Constructs a wood block of the given type.
   *
   * @param type the type of wood block
  */
  constructor(type: Material);
  /**
   * Constructs a wood block of the given type and tree species.
   *
   * @param type the type of wood block
   * @param species the species of the wood block
  */
  constructor(type: Material, species: TreeSpecies);
  /**
   * @param type the type
   * @param data the raw data value
   * @deprecated Magic value
  */
  constructor(type: Material, data: number);
  /**
   * Gets the current species of this wood block
   *
   * @return TreeSpecies of this wood block
  */
  getSpecies(): TreeSpecies;
  /**
   * Sets the species of this wood block
   *
   * @param species New species of this wood block
  */
  setSpecies(species: TreeSpecies);
  toString(): string;
  clone(): Wood;
}
/**
 * Represents a command block
 *
 * @deprecated all usage of MaterialData is deprecated and subject to removal.
 * Use {@link org.bukkit.block.data.BlockData}.
*/
export class Command extends MaterialData {
  constructor();
  constructor(type: Material);
  /**
   * @param type the type
   * @param data the raw data value
   * @deprecated Magic value
  */
  constructor(type: Material, data: number);
  /**
   * Gets the current state of this Material, indicating if it's powered or
   * unpowered
   *
   * @return true if powered, otherwise false
  */
  isPowered(): boolean;
  /**
   * Sets the current state of this Material
   *
   * @param bool
   *            whether or not the command block is powered
  */
  setPowered(bool: boolean): void;
  toString(): string;
  clone(): Command;
}
export interface Command extends MaterialData, Redstone {}
/**
 * Represents the different types of monster eggs
 *
 * @deprecated all usage of MaterialData is deprecated and subject to removal.
 * Use {@link org.bukkit.block.data.BlockData}.
*/
export class MonsterEggs extends TexturedMaterial {
  constructor();
  constructor(type: Material);
  /**
   * @param type the type
   * @param data the raw data value
   * @deprecated Magic value
  */
  constructor(type: Material, data: number);
  getTextures(): Material[];
  clone(): MonsterEggs;
}
/**
 * Represents the different types of sandstone.
 *
 * @deprecated all usage of MaterialData is deprecated and subject to removal.
 * Use {@link org.bukkit.block.data.BlockData}.
*/
export class Sandstone extends MaterialData {
  constructor();
  constructor(type: SandstoneType);
  constructor(type: Material);
  /**
   * @param type the type
   * @param data the raw data value
   * @deprecated Magic value
  */
  constructor(type: Material, data: number);
  /**
   * Gets the current type of this sandstone
   *
   * @return SandstoneType of this sandstone
  */
  getType(): SandstoneType;
  /**
   * Sets the type of this sandstone
   *
   * @param type New type of this sandstone
  */
  setType(type: SandstoneType);
  toString(): string;
  clone(): Sandstone;
}
/**
 * Represents stairs.
 *
 * @deprecated all usage of MaterialData is deprecated and subject to removal.
 * Use {@link org.bukkit.block.data.BlockData}.
*/
export class Stairs extends MaterialData {
  constructor(type: Material);
  /**
   * @param type the type
   * @param data the raw data value
   * @deprecated Magic value
  */
  constructor(type: Material, data: number);
  /**
   * @return the direction the stairs ascend towards
  */
  getAscendingDirection(): BlockFace;
  /**
   * @return the direction the stairs descend towards
  */
  getDescendingDirection(): BlockFace;
  /**
   * Set the direction the stair part of the block is facing
  */
  setFacingDirection(facingDirection: BlockFace);
  /**
   * @return the direction the stair part of the block is facing
  */
  getFacing(): BlockFace;
  /**
   * Test if step is inverted
   *
   * @return true if inverted (top half), false if normal (bottom half)
  */
  isInverted(): boolean;
  /**
   * Set step inverted state
   *
   * @param inv - true if step is inverted (top half), false if step is
   *     normal (bottom half)
  */
  setInverted(inv: boolean): void;
  toString(): string;
  clone(): Stairs;
}
export interface Stairs extends MaterialData, Directional {}
/**
 * Represents a furnace or dispenser, two types of directional containers
 *
 * @deprecated all usage of MaterialData is deprecated and subject to removal.
 * Use {@link org.bukkit.block.data.BlockData}.
*/
export class FurnaceAndDispenser extends DirectionalContainer {
  constructor(type: Material);
  /**
   * @param type the type
   * @param data the raw data value
   * @deprecated Magic value
  */
  constructor(type: Material, data: number);
  clone(): FurnaceAndDispenser;
}
/**
 * Represents the cocoa plant
 *
 * @deprecated all usage of MaterialData is deprecated and subject to removal.
 * Use {@link org.bukkit.block.data.BlockData}.
*/
export class CocoaPlant extends MaterialData {
  constructor();
  /**
   * @param type the type
   * @param data the raw data value
   * @deprecated Magic value
  */
  constructor(type: Material, data: number);
  constructor(sz: CocoaPlantSize);
  constructor(sz: CocoaPlantSize, dir: BlockFace);
  /**
   * Get size of plant
   *
   * @return size
  */
  getSize(): CocoaPlantSize;
  /**
   * Set size of plant
   *
   * @param sz - size of plant
  */
  setSize(size: CocoaPlantSize);
  /**
   * Gets the face that this block is attached on
   *
   * @return BlockFace attached to
  */
  getAttachedFace(): BlockFace;
  /**
   * Sets the direction that this block is facing in
   *
   * @param face The facing direction
  */
  setFacingDirection(facingDirection: BlockFace);
  /**
   * Gets the direction this block is facing
   *
   * @return the direction this block is facing
  */
  getFacing(): BlockFace;
  clone(): CocoaPlant;
  toString(): string;
}
export interface CocoaPlant extends MaterialData, Directional, Attachable {}
/**
 * MaterialData for signs
 *
 * @deprecated all usage of MaterialData is deprecated and subject to removal.
 * Use {@link org.bukkit.block.data.BlockData}.
*/
export class Sign extends MaterialData {
  constructor();
  constructor(type: Material);
  /**
   * @param type the raw type id
   * @param data the raw data value
   * @deprecated Magic value
  */
  constructor(type: Material, data: number);
  /**
   * Check if this sign is attached to a wall
   *
   * @return true if this sign is attached to a wall, false if set on top of
   *     a block
  */
  isWallSign(): boolean;
  /**
   * Gets the face that this block is attached on
   *
   * @return BlockFace attached to
  */
  getAttachedFace(): BlockFace;
  /**
   * Gets the direction that this sign is currently facing
   *
   * @return BlockFace indicating where this sign is facing
  */
  getFacing(): BlockFace;
  /**
   * Sets the direction that this block is facing in
   *
   * @param face The facing direction
  */
  setFacingDirection(facingDirection: BlockFace);
  toString(): string;
  clone(): Sign;
}
export interface Sign extends MaterialData, Attachable {}
/**
 * Represents the different types of coals.
 *
 * @deprecated all usage of MaterialData is deprecated and subject to removal.
 * Use {@link org.bukkit.block.data.BlockData}.
*/
export class Coal extends MaterialData {
  constructor();
  constructor(type: CoalType);
  constructor(type: Material);
  /**
   * @param type the type
   * @param data the raw data value
   * @deprecated Magic value
  */
  constructor(type: Material, data: number);
  /**
   * Gets the current type of this coal
   *
   * @return CoalType of this coal
  */
  getType(): CoalType;
  /**
   * Sets the type of this coal
   *
   * @param type New type of this coal
  */
  setType(type: CoalType);
  toString(): string;
  clone(): Coal;
}
/**
 * Represents an ender chest
 *
 * @deprecated all usage of MaterialData is deprecated and subject to removal.
 * Use {@link org.bukkit.block.data.BlockData}.
*/
export class EnderChest extends DirectionalContainer {
  constructor();
  /**
   * Instantiate an ender chest facing in a particular direction.
   *
   * @param direction the direction the ender chest's lid opens towards
  */
  constructor(direction: BlockFace);
  constructor(type: Material);
  /**
   * @param type the type
   * @param data the raw data value
   * @deprecated Magic value
  */
  constructor(type: Material, data: number);
  clone(): EnderChest;
}
/**
 * Represents the different types of smooth bricks.
 *
 * @deprecated all usage of MaterialData is deprecated and subject to removal.
 * Use {@link org.bukkit.block.data.BlockData}.
*/
export class SmoothBrick extends TexturedMaterial {
  constructor();
  constructor(type: Material);
  /**
   * @param type the type
   * @param data the raw data value
   * @deprecated Magic value
  */
  constructor(type: Material, data: number);
  getTextures(): Material[];
  clone(): SmoothBrick;
}
/**
 * Represents a fence gate
 *
 * @deprecated all usage of MaterialData is deprecated and subject to removal.
 * Use {@link org.bukkit.block.data.BlockData}.
*/
export class Gate extends MaterialData {
  constructor();
  /**
   * @param type the type
   * @param data the raw data value
   * @deprecated Magic value
  */
  constructor(type: Material, data: number);
  constructor(data: number);
  /**
   * Sets the direction that this block is facing in
   *
   * @param face The facing direction
  */
  setFacingDirection(facingDirection: BlockFace);
  /**
   * Gets the direction this block is facing
   *
   * @return the direction this block is facing
  */
  getFacing(): BlockFace;
  /**
   * Check to see if the door is open.
   *
   * @return true if the door has swung counterclockwise around its hinge.
  */
  isOpen(): boolean;
  /**
   * Configure this door to be either open or closed;
   *
   * @param isOpen True to open the door.
  */
  setOpen(isOpen: boolean): void;
  toString(): string;
  clone(): Gate;
}
export interface Gate extends MaterialData, Directional, Openable {}
/**
 * Represents the different types of crops in different states of growth.
 *
 * @see Material#LEGACY_CROPS
 * @see Material#LEGACY_CARROT
 * @see Material#LEGACY_POTATO
 * @see Material#LEGACY_BEETROOT_BLOCK
 * @see Material#LEGACY_NETHER_WARTS
 *
 * @deprecated all usage of MaterialData is deprecated and subject to removal.
 * Use {@link org.bukkit.block.data.BlockData}.
*/
export class Crops extends MaterialData {
  /**
   * Constructs a wheat crop block in the seeded state.
  */
  constructor();
  /**
   * Constructs a wheat crop block in the given growth state
   *
   * @param state The growth state of the crops
  */
  constructor(state: CropState);
  /**
   * Constructs a crop block of the given type and in the given growth state
   *
   * @param type The type of crops
   * @param state The growth state of the crops
  */
  constructor(type: Material, state: CropState);
  /**
   * Constructs a crop block of the given type and in the seeded state
   *
   * @param type The type of crops
  */
  constructor(type: Material);
  /**
   * @param type the type
   * @param data the raw data value
   * @deprecated Magic value
  */
  constructor(type: Material, data: number);
  /**
   * Gets the current growth state of this crop
   *
   * For crops with only four growth states such as beetroot, only the values SEEDED, SMALL, TALL and RIPE will be
   * returned.
   *
   * @return CropState of this crop
  */
  getState(): CropState;
  /**
   * Sets the growth state of this crop
   *
   * For crops with only four growth states such as beetroot, the 8 CropStates are mapped into four states:
   *
   * SEEDED, SMALL, TALL and RIPE
   *
   * GERMINATED will change to SEEDED
   * VERY_SMALL will change to SMALL
   * MEDIUM will change to TALL
   * VERY_TALL will change to RIPE
   *
   * @param state New growth state of this crop
  */
  setState(state: CropState);
  toString(): string;
  clone(): Crops;
}
/**
 * This is the superclass for the {@link DetectorRail} and {@link PoweredRail}
 * classes
 *
 * @deprecated all usage of MaterialData is deprecated and subject to removal.
 * Use {@link org.bukkit.block.data.BlockData}.
*/
export class ExtendedRails extends Rails {
  constructor(type: Material);
  /**
   * @param type the type
   * @param data the raw data value
   * @deprecated Magic value
  */
  constructor(type: Material, data: number);
  isCurve(): boolean;
  setDirection(face: BlockFace, isOnSlope: boolean): void;
  clone(): ExtendedRails;
}
/**
 * Represents a bed.
 *
 * @deprecated all usage of MaterialData is deprecated and subject to removal.
 * Use {@link org.bukkit.block.data.BlockData}.
*/
export class Bed extends MaterialData {
  /**
   * Default constructor for a bed.
  */
  constructor();
  /**
   * Instantiate a bed facing in a particular direction.
   *
   * @param direction the direction the bed's head is facing
  */
  constructor(direction: BlockFace);
  constructor(type: Material);
  /**
   * @param type the type
   * @param data the raw data value
   * @deprecated Magic value
  */
  constructor(type: Material, data: number);
  /**
   * Determine if this block represents the head of the bed
   *
   * @return true if this is the head of the bed, false if it is the foot
  */
  isHeadOfBed(): boolean;
  /**
   * Configure this to be either the head or the foot of the bed
   *
   * @param isHeadOfBed True to make it the head.
  */
  setHeadOfBed(isHeadOfBed: boolean): void;
  /**
   * Set which direction the head of the bed is facing. Note that this will
   * only affect one of the two blocks the bed is made of.
  */
  setFacingDirection(facingDirection: BlockFace);
  /**
   * Get the direction that this bed's head is facing toward
   *
   * @return the direction the head of the bed is facing
  */
  getFacing(): BlockFace;
  toString(): string;
  clone(): Bed;
}
export interface Bed extends MaterialData, Directional {}
/**
 * Represents textured materials like steps and smooth bricks
 *
 * @deprecated all usage of MaterialData is deprecated and subject to removal.
 * Use {@link org.bukkit.block.data.BlockData}.
*/
export class TexturedMaterial extends MaterialData {
  constructor(m: Material);
  /**
   * @param type the type
   * @param data the raw data value
   * @deprecated Magic value
  */
  constructor(type: Material, data: number);
  /**
   * Retrieve a list of possible textures. The first element of the list
   * will be used as a default.
   *
   * @return a list of possible textures for this block
  */
  getTextures(): Material[];
  /**
   * Gets the current Material this block is made of
   *
   * @return Material of this block
  */
  getMaterial(): Material;
  /**
   * Sets the material this block is made of
   *
   * @param material
   *            New material of this block
  */
  setMaterial(material: Material);
  toString(): string;
  clone(): TexturedMaterial;
}
/**
 * Represents a flower pot.
 *
 * @deprecated all usage of MaterialData is deprecated and subject to removal.
 * Use {@link org.bukkit.block.data.BlockData}.
*/
export class FlowerPot extends MaterialData {
  /**
   * Default constructor for a flower pot.
  */
  constructor();
  constructor(type: Material);
  /**
   * @param type the type
   * @param data the raw data value
   * @deprecated Magic value
  */
  constructor(type: Material, data: number);
  /**
   * Get the material in the flower pot
   *
   * @return material MaterialData for the block currently in the flower pot
   *     or null if empty
  */
  getContents(): MaterialData;
  /**
   * Set the contents of the flower pot
   *
   * @param materialData MaterialData of the block to put in the flower pot.
  */
  setContents(contents: MaterialData);
  toString(): string;
  clone(): FlowerPot;
}
/**
 * Represents a powered rail
 *
 * @deprecated all usage of MaterialData is deprecated and subject to removal.
 * Use {@link org.bukkit.block.data.BlockData}.
*/
export class PoweredRail extends ExtendedRails {
  constructor();
  constructor(type: Material);
  /**
   * @param type the type
   * @param data the raw data value
   * @deprecated Magic value
  */
  constructor(type: Material, data: number);
  /**
   * Gets the current state of this Material, indicating if it's powered or
   * unpowered
   *
   * @return true if powered, otherwise false
  */
  isPowered(): boolean;
  /**
   * Set whether this PoweredRail should be powered or not.
   *
   * @param isPowered whether or not the rail is powered
  */
  setPowered(isPowered: boolean): void;
  clone(): PoweredRail;
}
export interface PoweredRail extends ExtendedRails, Redstone {}
/**
 * Represents a chest
 *
 * @deprecated all usage of MaterialData is deprecated and subject to removal.
 * Use {@link org.bukkit.block.data.BlockData}.
*/
export class Chest extends DirectionalContainer {
  constructor();
  /**
   * Instantiate a chest facing in a particular direction.
   *
   * @param direction the direction the chest's lit opens towards
  */
  constructor(direction: BlockFace);
  constructor(type: Material);
  /**
   * @param type the type
   * @param data the raw data value
   * @deprecated Magic value
  */
  constructor(type: Material, data: number);
  clone(): Chest;
}
/**
 * Represents a furnace.
 *
 * @deprecated all usage of MaterialData is deprecated and subject to removal.
 * Use {@link org.bukkit.block.data.BlockData}.
*/
export class Furnace extends FurnaceAndDispenser {
  constructor();
  /**
   * Instantiate a furnace facing in a particular direction.
   *
   * @param direction the direction the furnace's "opening" is facing
  */
  constructor(direction: BlockFace);
  constructor(type: Material);
  /**
   * @param type the type
   * @param data the raw data value
   * @deprecated Magic value
  */
  constructor(type: Material, data: number);
  clone(): Furnace;
}
/**
 * Represents redstone wire
 *
 * @deprecated all usage of MaterialData is deprecated and subject to removal.
 * Use {@link org.bukkit.block.data.BlockData}.
*/
export class RedstoneWire extends MaterialData {
  constructor();
  constructor(type: Material);
  /**
   * @param type the type
   * @param data the raw data value
   * @deprecated Magic value
  */
  constructor(type: Material, data: number);
  /**
   * Gets the current state of this Material, indicating if it's powered or
   * unpowered
   *
   * @return true if powered, otherwise false
  */
  isPowered(): boolean;
  toString(): string;
  clone(): RedstoneWire;
}
export interface RedstoneWire extends MaterialData, Redstone {}
/**
 * Represents a door.
 *
 * This class was previously deprecated, but has been retrofitted to
 * work with modern doors. Some methods are undefined dependant on isTopHalf()
 * due to Minecraft's internal representation of doors.
 *
 * @see Material#LEGACY_WOODEN_DOOR
 * @see Material#LEGACY_IRON_DOOR_BLOCK
 * @see Material#LEGACY_SPRUCE_DOOR
 * @see Material#LEGACY_BIRCH_DOOR
 * @see Material#LEGACY_JUNGLE_DOOR
 * @see Material#LEGACY_ACACIA_DOOR
 * @see Material#LEGACY_DARK_OAK_DOOR
 *
 * @deprecated all usage of MaterialData is deprecated and subject to removal.
 * Use {@link org.bukkit.block.data.BlockData}.
*/
export class Door extends MaterialData {
  /**
   * @deprecated Artifact of old API, equivalent to new Door(Material.LEGACY_WOODEN_DOOR);
  */
  constructor();
  constructor(type: Material);
  /**
   * Constructs the bottom half of a door of the given material type, facing the specified direction and set to closed
   *
   * @param type The type of material this door is made of. This must match the type of the block above.
   * @param face The direction the door is facing.
   *
   * @see Material#LEGACY_WOODEN_DOOR
   * @see Material#LEGACY_IRON_DOOR_BLOCK
   * @see Material#LEGACY_SPRUCE_DOOR
   * @see Material#LEGACY_BIRCH_DOOR
   * @see Material#LEGACY_JUNGLE_DOOR
   * @see Material#LEGACY_ACACIA_DOOR
   * @see Material#LEGACY_DARK_OAK_DOOR
   *
   * @see BlockFace#WEST
   * @see BlockFace#NORTH
   * @see BlockFace#EAST
   * @see BlockFace#SOUTH
  */
  constructor(type: Material, face: BlockFace);
  /**
   * Constructs the bottom half of a door of the given material type, facing the specified direction and set to open
   * or closed
   *
   * @param type The type of material this door is made of. This must match the type of the block above.
   * @param face The direction the door is facing.
   * @param isOpen Whether the door is currently opened.
   *
   * @see Material#LEGACY_WOODEN_DOOR
   * @see Material#LEGACY_IRON_DOOR_BLOCK
   * @see Material#LEGACY_SPRUCE_DOOR
   * @see Material#LEGACY_BIRCH_DOOR
   * @see Material#LEGACY_JUNGLE_DOOR
   * @see Material#LEGACY_ACACIA_DOOR
   * @see Material#LEGACY_DARK_OAK_DOOR
   *
   * @see BlockFace#WEST
   * @see BlockFace#NORTH
   * @see BlockFace#EAST
   * @see BlockFace#SOUTH
  */
  constructor(type: Material, face: BlockFace, isOpen: boolean);
  /**
   * Constructs the top half of door of the given material type and with the hinge on the left or right
   *
   * @param type The type of material this door is made of. This must match the type of the block below.
   * @param isHingeRight True if the hinge is on the right hand side, false if the hinge is on the left hand side.
   *
   * @see Material#LEGACY_WOODEN_DOOR
   * @see Material#LEGACY_IRON_DOOR_BLOCK
   * @see Material#LEGACY_SPRUCE_DOOR
   * @see Material#LEGACY_BIRCH_DOOR
   * @see Material#LEGACY_JUNGLE_DOOR
   * @see Material#LEGACY_ACACIA_DOOR
   * @see Material#LEGACY_DARK_OAK_DOOR
  */
  constructor(type: Material, isHingeRight: boolean);
  /**
   * Constructs the bottom half of a wooden door of the given species, facing the specified direction and set to
   * closed
   *
   * @param species The species this wooden door is made of. This must match the species of the block above.
   * @param face The direction the door is facing.
   *
   * @see TreeSpecies
   *
   * @see BlockFace#WEST
   * @see BlockFace#NORTH
   * @see BlockFace#EAST
   * @see BlockFace#SOUTH
  */
  constructor(species: TreeSpecies, face: BlockFace);
  /**
   * Constructs the bottom half of a wooden door of the given species, facing the specified direction and set to open
   * or closed
   *
   * @param species The species this wooden door is made of. This must match the species of the block above.
   * @param face The direction the door is facing.
   * @param isOpen Whether the door is currently opened.
   *
   * @see TreeSpecies
   *
   * @see BlockFace#WEST
   * @see BlockFace#NORTH
   * @see BlockFace#EAST
   * @see BlockFace#SOUTH
  */
  constructor(species: TreeSpecies, face: BlockFace, isOpen: boolean);
  /**
   * Constructs the top half of a wooden door of the given species and with the hinge on the left or right
   *
   * @param species The species this wooden door is made of. This must match the species of the block below.
   * @param isHingeRight True if the hinge is on the right hand side, false if the hinge is on the left hand side.
   *
   * @see TreeSpecies
  */
  constructor(species: TreeSpecies, isHingeRight: boolean);
  /**
   * @param type the type
   * @param data the raw data value
   * @deprecated Magic value
  */
  constructor(type: Material, data: number);
  /**
   * Returns the item type of a wooden door for the given tree species.
   *
   * @param species The species of wood door required.
   * @return The item type for the given species.
   *
   * @see Material#LEGACY_WOODEN_DOOR
   * @see Material#LEGACY_SPRUCE_DOOR
   * @see Material#LEGACY_BIRCH_DOOR
   * @see Material#LEGACY_JUNGLE_DOOR
   * @see Material#LEGACY_ACACIA_DOOR
   * @see Material#LEGACY_DARK_OAK_DOOR
  */
  static getWoodDoorOfSpecies(species: TreeSpecies): Material;
  /**
   * Result is undefined if isTopHalf() is true.
  */
  isOpen(): boolean;
  /**
   * Set whether the door is open. Undefined if isTopHalf() is true.
  */
  setOpen(isOpen: boolean): void;
  /**
   * @return whether this is the top half of the door
  */
  isTopHalf(): boolean;
  /**
   * Configure this part of the door to be either the top or the bottom half
   *
   * @param isTopHalf True to make it the top half.
  */
  setTopHalf(isTopHalf: boolean): void;
  /**
   * @return BlockFace.SELF
   * @deprecated This method should not be used; use hinge and facing accessors instead.
  */
  getHingeCorner(): BlockFace;
  toString(): string;
  /**
   * Set the direction that this door should is facing.
   *
   * Undefined if isTopHalf() is true.
   *
   * @param face the direction
  */
  setFacingDirection(facingDirection: BlockFace);
  /**
   * Get the direction that this door is facing.
   *
   * Undefined if isTopHalf() is true.
   *
   * @return the direction
  */
  getFacing(): BlockFace;
  /**
   * Returns the side of the door the hinge is on.
   *
   * Undefined if isTopHalf() is false.
   *
   * @return false for left hinge, true for right hinge
  */
  getHinge(): boolean;
  /**
   * Set whether the hinge is on the left or right side. Left is false, right is true.
   *
   * Undefined if isTopHalf() is false.
   *
   * @param isHingeRight True if the hinge is on the right hand side, false if the hinge is on the left hand side.
  */
  setHinge(isHingeRight: boolean): void;
  clone(): Door;
}
export interface Door extends MaterialData, Directional, Openable {}
/**
 * Represents the different types of leaf block that may be permanent or can
 * decay when too far from a log.
 *
 * @see Material#LEGACY_LEAVES
 * @see Material#LEGACY_LEAVES_2
 *
 * @deprecated all usage of MaterialData is deprecated and subject to removal.
 * Use {@link org.bukkit.block.data.BlockData}.
*/
export class Leaves extends Wood {
  /**
   * Constructs a leaf block.
  */
  constructor();
  /**
   * Constructs a leaf block of the given tree species.
   *
   * @param species the species of the wood block
  */
  constructor(species: TreeSpecies);
  /**
   * Constructs a leaf block of the given tree species and flag for whether
   * this leaf block will disappear when too far from a log.
   *
   * @param species the species of the wood block
   * @param isDecayable whether the block is permanent or can disappear
  */
  constructor(species: TreeSpecies, isDecayable: boolean);
  /**
   * Constructs a leaf block of the given type.
   *
   * @param type the type of leaf block
  */
  constructor(type: Material);
  /**
   * Constructs a leaf block of the given type and tree species.
   *
   * @param type the type of leaf block
   * @param species the species of the wood block
  */
  constructor(type: Material, species: TreeSpecies);
  /**
   * Constructs a leaf block of the given type and tree species and flag for
   * whether this leaf block will disappear when too far from a log.
   *
   * @param type the type of leaf block
   * @param species the species of the wood block
   * @param isDecayable whether the block is permanent or can disappear
  */
  constructor(type: Material, species: TreeSpecies, isDecayable: boolean);
  /**
   * @param type the type
   * @param data the raw data value
   * @deprecated Magic value
  */
  constructor(type: Material, data: number);
  /**
   * Checks if this leaf block is in the process of decaying
   *
   * @return true if the leaf block is in the process of decaying
  */
  isDecaying(): boolean;
  /**
   * Set whether this leaf block is in the process of decaying
   *
   * @param isDecaying whether the block is decaying or not
  */
  setDecaying(isDecaying: boolean): void;
  /**
   * Checks if this leaf block is permanent or can decay when too far from a
   * log
   *
   * @return true if the leaf block is permanent or can decay when too far
   * from a log
  */
  isDecayable(): boolean;
  /**
   * Set whether this leaf block will disappear when too far from a log
   *
   * @param isDecayable whether the block is permanent or can disappear
  */
  setDecayable(isDecayable: boolean): void;
  toString(): string;
  clone(): Leaves;
}
/**
 * Represents a vine
 *
 * @deprecated all usage of MaterialData is deprecated and subject to removal.
 * Use {@link org.bukkit.block.data.BlockData}.
*/
export class Vine extends MaterialData {
  constructor();
  /**
   * @param type the type
   * @param data the raw data value
   * @deprecated Magic value
  */
  constructor(type: Material, data: number);
  /**
   * @param data the raw data value
   * @deprecated Magic value
  */
  constructor(data: number);
  constructor(...faces: BlockFace[]);
  constructor(faces: EnumSet<BlockFace>);
  /**
   * Check if the vine is attached to the specified face of an adjacent
   * block. You can check two faces at once by passing e.g. {@link
   * BlockFace#NORTH_EAST}.
   *
   * @param face The face to check.
   * @return Whether it is attached to that face.
  */
  isOnFace(face: BlockFace): boolean;
  /**
   * Attach the vine to the specified face of an adjacent block.
   *
   * @param face The face to attach.
  */
  putOnFace(face: BlockFace): void;
  /**
   * Detach the vine from the specified face of an adjacent block.
   *
   * @param face The face to detach.
  */
  removeFromFace(face: BlockFace): void;
  toString(): string;
  clone(): Vine;
}
/**
 * Represents the different types of Tree block that face a direction.
 *
 * @see Material#LEGACY_LOG
 * @see Material#LEGACY_LOG_2
 *
 * @deprecated all usage of MaterialData is deprecated and subject to removal.
 * Use {@link org.bukkit.block.data.BlockData}.
*/
export class Tree extends Wood {
  /**
   * Constructs a tree block.
  */
  constructor();
  /**
   * Constructs a tree block of the given tree species.
   *
   * @param species the species of the tree block
  */
  constructor(species: TreeSpecies);
  /**
   * Constructs a tree block of the given tree species, and facing the given
   * direction.
   *
   * @param species the species of the tree block
   * @param dir the direction the tree block is facing
  */
  constructor(species: TreeSpecies, dir: BlockFace);
  /**
   * Constructs a tree block of the given type.
   *
   * @param type the type of tree block
  */
  constructor(type: Material);
  /**
   * Constructs a tree block of the given type and tree species.
   *
   * @param type the type of tree block
   * @param species the species of the tree block
  */
  constructor(type: Material, species: TreeSpecies);
  /**
   * Constructs a tree block of the given type and tree species, and facing
   * the given direction.
   *
   * @param type the type of tree block
   * @param species the species of the tree block
   * @param dir the direction the tree block is facing
  */
  constructor(type: Material, species: TreeSpecies, dir: BlockFace);
  /**
   * @param type the type
   * @param data the raw data value
   * @deprecated Magic value
  */
  constructor(type: Material, data: number);
  /**
   * Get direction of the log
   *
   * @return one of:
   * 
   * BlockFace.TOP for upright (default)
   * BlockFace.NORTH (east-west)
   * BlockFace.WEST (north-south)
   * BlockFace.SELF (directionless)
   * 
  */
  getDirection(): BlockFace;
  /**
   * Set direction of the log
   *
   * @param dir - direction of end of log (BlockFace.SELF for no direction)
  */
  setDirection(direction: BlockFace);
  toString(): string;
  clone(): Tree;
}
/**
 * Material data for the piston extension block
 *
 * @deprecated all usage of MaterialData is deprecated and subject to removal.
 * Use {@link org.bukkit.block.data.BlockData}.
*/
export class PistonExtensionMaterial extends MaterialData {
  constructor(type: Material);
  /**
   * @param type the type
   * @param data the raw data value
   * @deprecated Magic value
  */
  constructor(type: Material, data: number);
  /**
   * Sets the direction that this block is facing in
   *
   * @param face The facing direction
  */
  setFacingDirection(facingDirection: BlockFace);
  /**
   * Gets the direction this block is facing
   *
   * @return the direction this block is facing
  */
  getFacing(): BlockFace;
  /**
   * Checks if this piston extension is sticky, and returns true if so
   *
   * @return true if this piston is "sticky", or false
  */
  isSticky(): boolean;
  /**
   * Sets whether or not this extension is sticky
   *
   * @param sticky true if sticky, otherwise false
  */
  setSticky(sticky: boolean): void;
  /**
   * Gets the face that this block is attached on
   *
   * @return BlockFace attached to
  */
  getAttachedFace(): BlockFace;
  clone(): PistonExtensionMaterial;
}
export interface PistonExtensionMaterial extends MaterialData, Attachable {}
export class Directional {
  /**
   * Sets the direction that this block is facing in
   *
   * @param face The facing direction
  */
  setFacingDirection(facingDirection: BlockFace);
  /**
   * Gets the direction this block is facing
   *
   * @return the direction this block is facing
  */
  getFacing(): BlockFace;
}
/**
 * Represents a lever
 *
 * @deprecated all usage of MaterialData is deprecated and subject to removal.
 * Use {@link org.bukkit.block.data.BlockData}.
*/
export class Lever extends SimpleAttachableMaterialData {
  constructor();
  constructor(type: Material);
  /**
   * @param type the type
   * @param data the raw data value
   * @deprecated Magic value
  */
  constructor(type: Material, data: number);
  /**
   * Gets the current state of this Material, indicating if it's powered or
   * unpowered
   *
   * @return true if powered, otherwise false
  */
  isPowered(): boolean;
  /**
   * Set this lever to be powered or not.
   *
   * @param isPowered whether the lever should be powered or not
  */
  setPowered(isPowered: boolean): void;
  /**
   * Gets the face that this block is attached on
   *
   * @return BlockFace attached to
  */
  getAttachedFace(): BlockFace;
  /**
   * Sets the direction this lever is pointing in
  */
  setFacingDirection(facingDirection: BlockFace);
  toString(): string;
  clone(): Lever;
}
export interface Lever extends SimpleAttachableMaterialData, Redstone {}
/**
 * Represents a furnace or a dispenser.
 *
 * @deprecated all usage of MaterialData is deprecated and subject to removal.
 * Use {@link org.bukkit.block.data.BlockData}.
*/
export class DirectionalContainer extends MaterialData {
  constructor(type: Material);
  /**
   * @param type the type
   * @param data the raw data value
   * @deprecated Magic value
  */
  constructor(type: Material, data: number);
  /**
   * Sets the direction that this block is facing in
   *
   * @param face The facing direction
  */
  setFacingDirection(facingDirection: BlockFace);
  /**
   * Gets the direction this block is facing
   *
   * @return the direction this block is facing
  */
  getFacing(): BlockFace;
  toString(): string;
  clone(): DirectionalContainer;
}
export interface DirectionalContainer extends MaterialData, Directional {}
/**
 * Simple utility class for attachable MaterialData subclasses
 *
 * @deprecated all usage of MaterialData is deprecated and subject to removal.
 * Use {@link org.bukkit.block.data.BlockData}.
*/
export class SimpleAttachableMaterialData extends MaterialData {
  constructor(type: Material, direction: BlockFace);
  constructor(type: Material);
  /**
   * @param type the type
   * @param data the raw data value
   * @deprecated Magic value
  */
  constructor(type: Material, data: number);
  /**
   * Gets the direction this block is facing
   *
   * @return the direction this block is facing
  */
  getFacing(): BlockFace;
  toString(): string;
  clone(): SimpleAttachableMaterialData;
}
export interface SimpleAttachableMaterialData extends MaterialData, Attachable {}
export class Openable {
  /**
   * Check to see if the door is open.
   *
   * @return true if the door has swung counterclockwise around its hinge.
  */
  isOpen(): boolean;
  /**
   * Configure this door to be either open or closed;
   *
   * @param isOpen True to open the door.
  */
  setOpen(isOpen: boolean): void;
}
/**
 * Represents dye
 *
 * @deprecated all usage of MaterialData is deprecated and subject to removal.
 * Use {@link org.bukkit.block.data.BlockData}.
*/
export class Dye extends MaterialData {
  constructor();
  constructor(type: Material);
  /**
   * @param type the type
   * @param data the raw data value
   * @deprecated Magic value
  */
  constructor(type: Material, data: number);
  /**
   * @param color color of the dye
  */
  constructor(color: DyeColor);
  /**
   * Gets the current color of this dye
   *
   * @return DyeColor of this dye
  */
  getColor(): DyeColor;
  /**
   * Sets the color of this dye
   *
   * @param color New color of this dye
  */
  setColor(color: DyeColor);
  toString(): string;
  clone(): Dye;
}
export interface Dye extends MaterialData, Colorable {}
/**
 * Represents a dispenser.
 *
 * @deprecated all usage of MaterialData is deprecated and subject to removal.
 * Use {@link org.bukkit.block.data.BlockData}.
*/
export class Dispenser extends FurnaceAndDispenser {
  constructor();
  constructor(direction: BlockFace);
  constructor(type: Material);
  /**
   * @param type the type
   * @param data the raw data value
   * @deprecated Magic value
  */
  constructor(type: Material, data: number);
  setFacingDirection(facingDirection: BlockFace);
  getFacing(): BlockFace;
  clone(): Dispenser;
}
/**
 * Represents a button
 *
 * @deprecated all usage of MaterialData is deprecated and subject to removal.
 * Use {@link org.bukkit.block.data.BlockData}.
*/
export class Button extends SimpleAttachableMaterialData {
  constructor();
  constructor(type: Material);
  /**
   * @param type the type
   * @param data the raw data value
   * @deprecated Magic value
  */
  constructor(type: Material, data: number);
  /**
   * Gets the current state of this Material, indicating if it's powered or
   * unpowered
   *
   * @return true if powered, otherwise false
  */
  isPowered(): boolean;
  /**
   * Sets the current state of this button
   *
   * @param bool
   *            whether or not the button is powered
  */
  setPowered(bool: boolean): void;
  /**
   * Gets the face that this block is attached on
   *
   * @return BlockFace attached to
  */
  getAttachedFace(): BlockFace;
  /**
   * Sets the direction this button is pointing toward
  */
  setFacingDirection(facingDirection: BlockFace);
  toString(): string;
  clone(): Button;
}
export interface Button extends SimpleAttachableMaterialData, Redstone {}
/**
 * An object that can be colored.
*/
export class Colorable {
  /**
   * Gets the color of this object.
   * 
   * This may be null to represent the default color of an object, if the
   * object has a special default color (e.g Shulkers).
   *
   * @return The DyeColor of this object.
  */
  getColor(): DyeColor | null;
  /**
   * Sets the color of this object to the specified DyeColor.
   * 
   * This may be null to represent the default color of an object, if the
   * object has a special default color (e.g Shulkers).
   *
   * @param color The color of the object, as a DyeColor.
   * @throws NullPointerException if argument is null and this implementation does not support null
  */
  setColor(color: DyeColor);
}
/**
 * @deprecated all usage of MaterialData is deprecated and subject to removal.
 * Use {@link org.bukkit.block.data.BlockData}.
*/
export class Cake extends MaterialData {
  constructor();
  constructor(type: Material);
  /**
   * @param type the type
   * @param data the raw data value
   * @deprecated Magic value
  */
  constructor(type: Material, data: number);
  /**
   * Gets the number of slices eaten from this cake
   *
   * @return The number of slices eaten
  */
  getSlicesEaten(): number;
  /**
   * Gets the number of slices remaining on this cake
   *
   * @return The number of slices remaining
  */
  getSlicesRemaining(): number;
  /**
   * Sets the number of slices eaten from this cake
   *
   * @param n The number of slices eaten
  */
  setSlicesEaten(slicesEaten: number);
  /**
   * Sets the number of slices remaining on this cake
   *
   * @param n The number of slices remaining
  */
  setSlicesRemaining(slicesRemaining: number);
  toString(): string;
  clone(): Cake;
}
/**
 * Represents a cauldron
 *
 * @deprecated all usage of MaterialData is deprecated and subject to removal.
 * Use {@link org.bukkit.block.data.BlockData}.
*/
export class Cauldron extends MaterialData {
  constructor();
  /**
   * @param type the type
   * @param data the raw data value
   * @deprecated Magic value
  */
  constructor(type: Material, data: number);
  /**
   * @param data the raw data value
   * @deprecated Magic value
  */
  constructor(data: number);
  /**
   * Check if the cauldron is full.
   *
   * @return True if it is full.
  */
  isFull(): boolean;
  /**
   * Check if the cauldron is empty.
   *
   * @return True if it is empty.
  */
  isEmpty(): boolean;
  toString(): string;
  clone(): Cauldron;
}
/**
 * MaterialData for torches
 *
 * @deprecated all usage of MaterialData is deprecated and subject to removal.
 * Use {@link org.bukkit.block.data.BlockData}.
*/
export class Torch extends SimpleAttachableMaterialData {
  constructor();
  constructor(type: Material);
  /**
   * @param type the type
   * @param data the raw data value
   * @deprecated Magic value
  */
  constructor(type: Material, data: number);
  /**
   * Gets the face that this block is attached on
   *
   * @return BlockFace attached to
  */
  getAttachedFace(): BlockFace;
  setFacingDirection(facingDirection: BlockFace);
  clone(): Torch;
}
/**
 * Represents a spawn egg that can be used to spawn mobs
 * @deprecated use {@link SpawnEggMeta}
*/
export class SpawnEgg extends MaterialData {
  constructor();
  /**
   * @param type the type
   * @param data the raw data value
   * @deprecated Magic value
  */
  constructor(type: Material, data: number);
  /**
   * @param data the raw data value
   * @deprecated Magic value
  */
  constructor(data: number);
  constructor(type: EntityType);
  /**
   * Get the type of entity this egg will spawn.
   *
   * @return The entity type.
   * @deprecated This is now stored in {@link SpawnEggMeta}.
  */
  getSpawnedType(): EntityType;
  /**
   * Set the type of entity this egg will spawn.
   *
   * @param type The entity type.
   * @deprecated This is now stored in {@link SpawnEggMeta}.
  */
  setSpawnedType(spawnedType: EntityType);
  toString(): string;
  clone(): SpawnEgg;
}
/**
 * Represents a detector rail
 *
 * @deprecated all usage of MaterialData is deprecated and subject to removal.
 * Use {@link org.bukkit.block.data.BlockData}.
*/
export class DetectorRail extends ExtendedRails {
  constructor();
  constructor(type: Material);
  /**
   * @param type the type
   * @param data the raw data value
   * @deprecated Magic value
  */
  constructor(type: Material, data: number);
  isPressed(): boolean;
  setPressed(isPressed: boolean): void;
  clone(): DetectorRail;
}
export interface DetectorRail extends ExtendedRails, PressureSensor {}
/**
 * Represents a comparator in the on or off state, in normal or subtraction mode and facing in a specific direction.
 *
 * @see Material#LEGACY_REDSTONE_COMPARATOR_OFF
 * @see Material#LEGACY_REDSTONE_COMPARATOR_ON
 *
 * @deprecated all usage of MaterialData is deprecated and subject to removal.
 * Use {@link org.bukkit.block.data.BlockData}.
*/
export class Comparator extends MaterialData {
  /**
   * Constructs a comparator switched off, with the default mode (normal) and facing the default direction (north).
  */
  constructor();
  /**
   * Constructs a comparator switched off, with the default mode (normal) and facing the specified direction.
   *
   * @param facingDirection the direction the comparator is facing
   *
   * @see BlockFace
  */
  constructor(facingDirection: BlockFace);
  /**
   * Constructs a comparator switched off, with the specified mode and facing the specified direction.
   *
   * @param facingDirection the direction the comparator is facing
   * @param isSubtraction True if the comparator is in subtraction mode, false for normal comparator operation
   *
   * @see BlockFace
  */
  constructor(facingDirection: BlockFace, isSubtraction: boolean);
  /**
   * Constructs a comparator switched on or off, with the specified mode and facing the specified direction.
   *
   * @param facingDirection the direction the comparator is facing
   * @param isSubtraction True if the comparator is in subtraction mode, false for normal comparator operation
   * @param state True if the comparator is in the on state
   *
   * @see BlockFace
  */
  constructor(facingDirection: BlockFace, isSubtraction: boolean, state: boolean);
  constructor(type: Material);
  /**
   * @param type the type
   * @param data the raw data value
   * @deprecated Magic value
  */
  constructor(type: Material, data: number);
  /**
   * Sets whether the comparator is in subtraction mode.
   *
   * @param isSubtraction True if the comparator is in subtraction mode, false for normal comparator operation
  */
  setSubtractionMode(isSubtraction: boolean): void;
  /**
   * Checks whether the comparator is in subtraction mode
   *
   * @return True if the comparator is in subtraction mode, false if normal comparator operation
  */
  isSubtractionMode(): boolean;
  /**
   * Sets the direction this comparator is facing
   *
   * @param face The direction to set this comparator to
   *
   * @see BlockFace
  */
  setFacingDirection(facingDirection: BlockFace);
  /**
   * Gets the direction this comparator is facing
   *
   * @return The direction this comparator is facing
   *
   * @see BlockFace
  */
  getFacing(): BlockFace;
  toString(): string;
  clone(): Comparator;
  /**
   * Checks if the comparator is powered
   *
   * @return true if the comparator is powered
  */
  isPowered(): boolean;
  /**
   * Checks if the comparator is being powered
   *
   * @return true if the comparator is being powered
  */
  isBeingPowered(): boolean;
}
export interface Comparator extends MaterialData, Directional, Redstone {}
/**
 * Represents Ladder data
 *
 * @deprecated all usage of MaterialData is deprecated and subject to removal.
 * Use {@link org.bukkit.block.data.BlockData}.
*/
export class Ladder extends SimpleAttachableMaterialData {
  constructor();
  constructor(type: Material);
  /**
   * @param type the type
   * @param data the raw data value
   * @deprecated Magic value
  */
  constructor(type: Material, data: number);
  /**
   * Gets the face that this block is attached on
   *
   * @return BlockFace attached to
  */
  getAttachedFace(): BlockFace;
  /**
   * Sets the direction this ladder is facing
  */
  setFacingDirection(facingDirection: BlockFace);
  clone(): Ladder;
}
/**
 * Handles specific metadata for certain items or blocks
 *
 * @deprecated all usage of MaterialData is deprecated and subject to removal.
 * Use {@link org.bukkit.block.data.BlockData}.
*/
export class MaterialData extends Cloneable {
  constructor(type: Material);
  /**
   * @param type the type
   * @param data the raw data value
   * @deprecated Magic value
  */
  constructor(type: Material, data: number);
  /**
   * Gets the raw data in this material
   *
   * @return Raw data
   * @deprecated Magic value
  */
  getData(): number;
  /**
   * Sets the raw data of this material
   *
   * @param data New raw data
   * @deprecated Magic value
  */
  setData(data: number);
  /**
   * Gets the Material that this MaterialData represents
   *
   * @return Material represented by this MaterialData
  */
  getItemType(): Material;
  /**
   * Creates a new ItemStack based on this MaterialData
   *
   * @return New ItemStack containing a copy of this MaterialData
   * @deprecated this method creates an ItemStack of size 0 which is not
   * generally useful. Consider {@link #toItemStack(int)}.
  */
  toItemStack(): ItemStack;
  /**
   * Creates a new ItemStack based on this MaterialData
   *
   * @param amount The stack size of the new stack
   * @return New ItemStack containing a copy of this MaterialData
  */
  toItemStack(amount: number): ItemStack;
  toString(): string;
  hashCode(): number;
  equals(obj: any): boolean;
  clone(): MaterialData;
}
/**
 * Represents an observer.
 *
 * @deprecated all usage of MaterialData is deprecated and subject to removal.
 * Use {@link org.bukkit.block.data.BlockData}.
*/
export class Observer extends MaterialData {
  constructor();
  constructor(direction: BlockFace);
  constructor(type: Material);
  /**
   * @param type the type
   * @param data the raw data value
   * @deprecated Magic value
  */
  constructor(type: Material, data: number);
  /**
   * Gets the current state of this Material, indicating if it's powered or
   * unpowered
   *
   * @return true if powered, otherwise false
  */
  isPowered(): boolean;
  /**
   * Sets the direction that this block is facing in
   *
   * @param face The facing direction
  */
  setFacingDirection(facingDirection: BlockFace);
  /**
   * Gets the direction this block is facing
   *
   * @return the direction this block is facing
  */
  getFacing(): BlockFace;
  toString(): string;
  clone(): Observer;
}
export interface Observer extends MaterialData, Directional, Redstone {}
/**
 * Represents a huge mushroom block with certain combinations of faces set to
 * cap, pores or stem.
 *
 * @see Material#LEGACY_HUGE_MUSHROOM_1
 * @see Material#LEGACY_HUGE_MUSHROOM_2
 *
 * @deprecated all usage of MaterialData is deprecated and subject to removal.
 * Use {@link org.bukkit.block.data.BlockData}.
*/
export class Mushroom extends MaterialData {
  /**
   * Constructs a brown/red mushroom block with all sides set to pores.
   *
   * @param shroom A brown or red mushroom material type.
   *
   * @see Material#LEGACY_HUGE_MUSHROOM_1
   * @see Material#LEGACY_HUGE_MUSHROOM_2
  */
  constructor(shroom: Material);
  /**
   * Constructs a brown/red mushroom cap block with the specified face or
   * faces set to cap texture.
   *
   * Setting any of the four sides will also set the top to cap.
   *
   * To set two side faces at once use e.g. north-west.
   *
   * Specify self to set all six faces at once.
   *
   * @param shroom A brown or red mushroom material type.
   * @param capFace The face or faces to set to mushroom cap texture.
   *
   * @see Material#LEGACY_HUGE_MUSHROOM_1
   * @see Material#LEGACY_HUGE_MUSHROOM_2
   * @see BlockFace
  */
  constructor(shroom: Material, capFace: BlockFace);
  /**
   * Constructs a brown/red mushroom block with the specified textures.
   *
   * @param shroom A brown or red mushroom material type.
   * @param texture The textured mushroom faces.
   *
   * @see Material#LEGACY_HUGE_MUSHROOM_1
   * @see Material#LEGACY_HUGE_MUSHROOM_2
  */
  constructor(shroom: Material, texture: MushroomBlockTexture);
  /**
   * @param shroom the type
   * @param data the raw data value
   * @deprecated Magic value
  */
  constructor(shroom: Material, data: number);
  /**
   * @return Whether this is a mushroom stem.
  */
  isStem(): boolean;
  /**
   * Sets this to be a mushroom stem.
   *
   * @see MushroomBlockTexture#STEM_SIDES
   * @see MushroomBlockTexture#ALL_STEM
   *
   * @deprecated Use
   * {@link #setBlockTexture(org.bukkit.material.types.MushroomBlockTexture)}
   * with {@link MushroomBlockTexture#STEM_SIDES } or
   * {@link MushroomBlockTexture#ALL_STEM}
  */
  setStem(): void;
  /**
   * Gets the mushroom texture of this block.
   *
   * @return The mushroom texture of this block
  */
  getBlockTexture(): MushroomBlockTexture;
  /**
   * Sets the mushroom texture of this block.
   *
   * @param texture The mushroom texture to set
  */
  setBlockTexture(blockTexture: MushroomBlockTexture);
  /**
   * Checks whether a face of the block is painted with cap texture.
   *
   * @param face The face to check.
   * @return True if it is painted.
  */
  isFacePainted(face: BlockFace): boolean;
  /**
   * Set a face of the block to be painted or not. Note that due to the
   * nature of how the data is stored, setting a face painted or not is not
   * guaranteed to leave the other faces unchanged.
   *
   * @param face The face to paint or unpaint.
   * @param painted True if you want to paint it, false if you want the
   *     pores to show.
   *
   * @deprecated Use MushroomBlockType cap options
  */
  setFacePainted(face: BlockFace, painted: boolean): void;
  /**
   * @return A set of all faces that are currently painted (an empty set if
   *     it is a stem)
  */
  getPaintedFaces(): Set<BlockFace>;
  toString(): string;
  clone(): Mushroom;
}
/**
 * Represents the different types of long grasses.
 *
 * @deprecated all usage of MaterialData is deprecated and subject to removal.
 * Use {@link org.bukkit.block.data.BlockData}.
*/
export class LongGrass extends MaterialData {
  constructor();
  constructor(species: GrassSpecies);
  constructor(type: Material);
  /**
   * @param type the type
   * @param data the raw data value
   * @deprecated Magic value
  */
  constructor(type: Material, data: number);
  /**
   * Gets the current species of this grass
   *
   * @return GrassSpecies of this grass
  */
  getSpecies(): GrassSpecies;
  /**
   * Sets the species of this grass
   *
   * @param species New species of this grass
  */
  setSpecies(species: GrassSpecies);
  toString(): string;
  clone(): LongGrass;
}
/**
 * @deprecated all usage of MaterialData is deprecated and subject to removal.
 * Use {@link org.bukkit.block.data.BlockData}.
*/
export class Banner extends MaterialData {
  constructor();
  constructor(type: Material);
  /**
   * @param type the type
   * @param data the raw data value
   * @deprecated Magic value
  */
  constructor(type: Material, data: number);
  isWallBanner(): boolean;
  /**
   * Gets the face that this block is attached on
   *
   * @return BlockFace attached to
  */
  getAttachedFace(): BlockFace;
  /**
   * Gets the direction this block is facing
   *
   * @return the direction this block is facing
  */
  getFacing(): BlockFace;
  /**
   * Sets the direction that this block is facing in
   *
   * @param face The facing direction
  */
  setFacingDirection(facingDirection: BlockFace);
  toString(): string;
  clone(): Banner;
}
export interface Banner extends MaterialData, Attachable {}
/**
 * Represents the tripwire hook
 *
 * @deprecated all usage of MaterialData is deprecated and subject to removal.
 * Use {@link org.bukkit.block.data.BlockData}.
*/
export class TripwireHook extends SimpleAttachableMaterialData {
  constructor();
  /**
   * @param type the type
   * @param data the raw data value
   * @deprecated Magic value
  */
  constructor(type: Material, data: number);
  constructor(dir: BlockFace);
  /**
   * Test if tripwire is connected
   *
   * @return true if connected, false if not
  */
  isConnected(): boolean;
  /**
   * Set tripwire connection state
   *
   * @param connected - true if connected, false if not
  */
  setConnected(connected: boolean): void;
  /**
   * Test if hook is currently activated
   *
   * @return true if activated, false if not
  */
  isActivated(): boolean;
  /**
   * Set hook activated state
   *
   * @param act - true if activated, false if not
  */
  setActivated(act: boolean): void;
  setFacingDirection(facingDirection: BlockFace);
  getAttachedFace(): BlockFace;
  /**
   * Gets the current state of this Material, indicating if it's powered or
   * unpowered
   *
   * @return true if powered, otherwise false
  */
  isPowered(): boolean;
  clone(): TripwireHook;
  toString(): string;
}
export interface TripwireHook extends SimpleAttachableMaterialData, Redstone {}
/**
 * Represents the different types of wooden steps.
 *
 * @see Material#LEGACY_WOOD_STEP
 *
 * @deprecated all usage of MaterialData is deprecated and subject to removal.
 * Use {@link org.bukkit.block.data.BlockData}.
*/
export class WoodenStep extends Wood {
  /**
   * Constructs a wooden step.
  */
  constructor();
  /**
   * Constructs a wooden step of the given tree species.
   *
   * @param species the species of the wooden step
  */
  constructor(species: TreeSpecies);
  /**
   * Constructs a wooden step of the given type and tree species, either
   * inverted or not.
   *
   * @param species the species of the wooden step
   * @param inv true the step is at the top of the block
  */
  constructor(species: TreeSpecies, inv: boolean);
  /**
   * @param type the type
   * @param data the raw data value
   * @deprecated Magic value
  */
  constructor(type: Material, data: number);
  /**
   * Test if step is inverted
   *
   * @return true if inverted (top half), false if normal (bottom half)
  */
  isInverted(): boolean;
  /**
   * Set step inverted state
   *
   * @param inv - true if step is inverted (top half), false if step is normal
   * (bottom half)
  */
  setInverted(inv: boolean): void;
  clone(): WoodenStep;
  toString(): string;
}
/**
 * Represents the different types of Tree block that face a direction.
 *
 * @see Material#LEGACY_SAPLING
 *
 * @deprecated all usage of MaterialData is deprecated and subject to removal.
 * Use {@link org.bukkit.block.data.BlockData}.
*/
export class Sapling extends Wood {
  /**
   * Constructs a sapling.
  */
  constructor();
  /**
   * Constructs a sapling of the given tree species.
   *
   * @param species the species of the sapling
  */
  constructor(species: TreeSpecies);
  /**
   * Constructs a sapling of the given tree species and if is it instant
   * growable
   *
   * @param species the species of the tree block
   * @param isInstantGrowable true if the Sapling should grow when next ticked with bonemeal
  */
  constructor(species: TreeSpecies, isInstantGrowable: boolean);
  /**
   * Constructs a sapling of the given type.
   *
   * @param type the type of tree block
  */
  constructor(type: Material);
  /**
   * Constructs a sapling of the given type and tree species.
   *
   * @param type the type of sapling
   * @param species the species of the sapling
  */
  constructor(type: Material, species: TreeSpecies);
  /**
   * Constructs a sapling of the given type and tree species and if is it
   * instant growable
   *
   * @param type the type of sapling
   * @param species the species of the sapling
   * @param isInstantGrowable true if the Sapling should grow when next ticked
   * with bonemeal
  */
  constructor(type: Material, species: TreeSpecies, isInstantGrowable: boolean);
  /**
   * @param type the type
   * @param data the raw data value
   * @deprecated Magic value
  */
  constructor(type: Material, data: number);
  /**
   * Checks if the Sapling would grow when next ticked with bonemeal
   *
   * @return true if the Sapling would grow when next ticked with bonemeal
  */
  isInstantGrowable(): boolean;
  /**
   * Set whether this sapling will grow when next ticked with bonemeal
   *
   * @param isInstantGrowable true if the Sapling should grow when next ticked
   * with bonemeal
  */
  setIsInstantGrowable(isInstantGrowable: boolean): void;
  toString(): string;
  clone(): Sapling;
}
/**
 * Represents a pumpkin.
 *
 * @deprecated all usage of MaterialData is deprecated and subject to removal.
 * Use {@link org.bukkit.block.data.BlockData}.
*/
export class Pumpkin extends MaterialData {
  constructor();
  /**
   * Instantiate a pumpkin facing in a particular direction.
   *
   * @param direction the direction the pumkin's face is facing
  */
  constructor(direction: BlockFace);
  constructor(type: Material);
  /**
   * @param type the type
   * @param data the raw data value
   * @deprecated Magic value
  */
  constructor(type: Material, data: number);
  isLit(): boolean;
  /**
   * Sets the direction that this block is facing in
   *
   * @param face The facing direction
  */
  setFacingDirection(facingDirection: BlockFace);
  /**
   * Gets the direction this block is facing
   *
   * @return the direction this block is facing
  */
  getFacing(): BlockFace;
  toString(): string;
  clone(): Pumpkin;
}
export interface Pumpkin extends MaterialData, Directional {}
/**
 * Indicates that a block can be attached to another block
*/
export class Attachable extends Directional {
  /**
   * Gets the face that this block is attached on
   *
   * @return BlockFace attached to
  */
  getAttachedFace(): BlockFace;
}
/**
 * Represents nether wart
 *
 * @deprecated all usage of MaterialData is deprecated and subject to removal.
 * Use {@link org.bukkit.block.data.BlockData}.
*/
export class NetherWarts extends MaterialData {
  constructor();
  constructor(state: NetherWartsState);
  constructor(type: Material);
  /**
   * @param type the type
   * @param data the raw data value
   * @deprecated Magic value
  */
  constructor(type: Material, data: number);
  /**
   * Gets the current growth state of this nether wart
   *
   * @return NetherWartsState of this nether wart
  */
  getState(): NetherWartsState;
  /**
   * Sets the growth state of this nether wart
   *
   * @param state New growth state of this nether wart
  */
  setState(state: NetherWartsState);
  toString(): string;
  clone(): NetherWarts;
}
/**
 * Material data for the piston base block
 *
 * @deprecated all usage of MaterialData is deprecated and subject to removal.
 * Use {@link org.bukkit.block.data.BlockData}.
*/
export class PistonBaseMaterial extends MaterialData {
  constructor(type: Material);
  /**
   * Constructs a PistonBaseMaterial.
   *
   * @param type the material type to use
   * @param data the raw data value
   * @deprecated Magic value
  */
  constructor(type: Material, data: number);
  /**
   * Sets the direction that this block is facing in
   *
   * @param face The facing direction
  */
  setFacingDirection(facingDirection: BlockFace);
  /**
   * Gets the direction this block is facing
   *
   * @return the direction this block is facing
  */
  getFacing(): BlockFace;
  /**
   * Gets the current state of this Material, indicating if it's powered or
   * unpowered
   *
   * @return true if powered, otherwise false
  */
  isPowered(): boolean;
  /**
   * Sets the current state of this piston
   *
   * @param powered true if the piston is extended {@literal &} powered, or false
  */
  setPowered(powered: boolean): void;
  /**
   * Checks if this piston base is sticky, and returns true if so
   *
   * @return true if this piston is "sticky", or false
  */
  isSticky(): boolean;
  clone(): PistonBaseMaterial;
}
export interface PistonBaseMaterial extends MaterialData, Directional, Redstone {}
/**
 * Represents a redstone torch
 *
 * @deprecated all usage of MaterialData is deprecated and subject to removal.
 * Use {@link org.bukkit.block.data.BlockData}.
*/
export class RedstoneTorch extends Torch {
  constructor();
  constructor(type: Material);
  /**
   * @param type the type
   * @param data the raw data value
   * @deprecated Magic value
  */
  constructor(type: Material, data: number);
  /**
   * Gets the current state of this Material, indicating if it's powered or
   * unpowered
   *
   * @return true if powered, otherwise false
  */
  isPowered(): boolean;
  toString(): string;
  clone(): RedstoneTorch;
}
export interface RedstoneTorch extends Torch, Redstone {}

}
declare module 'org.bukkit.Server' {
import { YamlConfiguration } from 'org.bukkit.configuration.file';
export class Spigot {
  getConfig(): YamlConfiguration;
  getBukkitConfig(): YamlConfiguration;
  getSpigotConfig(): YamlConfiguration;
  getPaperConfig(): YamlConfiguration;
  /**
   * Restart the server. If the server administrator has not configured restarting, the server will stop.
  */
  restart(): void;
}

}
declare module 'org.bukkit.block.data.type' {
import { Shape } from 'org.bukkit.block.data.type.Stairs';
import { Type } from 'org.bukkit.block.data.type.TechnicalPiston';
import { Set } from 'java.util';
import { Thickness } from 'org.bukkit.block.data.type.PointedDripstone';
import { Face } from 'org.bukkit.block.data.type.Switch';
import { Hinge } from 'org.bukkit.block.data.type.Door';
import { Attachment } from 'org.bukkit.block.data.type.Bell';
import { Part } from 'org.bukkit.block.data.type.Bed';
import { Height } from 'org.bukkit.block.data.type.Wall';
import { Note, Instrument } from 'org.bukkit';
import { Type as org_bukkit_block_data_type_Chest_Type } from 'org.bukkit.block.data.type.Chest';
import { BlockFace } from 'org.bukkit.block';
import { Tilt } from 'org.bukkit.block.data.type.BigDripleaf';
import { Orientation } from 'org.bukkit.block.data.type.Jigsaw';
import { Type as org_bukkit_block_data_type_Slab_Type } from 'org.bukkit.block.data.type.Slab';
import { Mode as org_bukkit_block_data_type_Comparator_Mode } from 'org.bukkit.block.data.type.Comparator';
import { Connection } from 'org.bukkit.block.data.type.RedstoneWire';
import { Lightable, Orientable, Powerable, FaceAttachable, Levelled, Ageable, MultipleFacing, Directional, Openable, Rotatable, Rail, Waterlogged, BlockData, Attachable, AnaloguePowerable, Bisected } from 'org.bukkit.block.data';
import { Phase } from 'org.bukkit.block.data.type.SculkSensor';
import { Leaves } from 'org.bukkit.block.data.type.Bamboo';
import { Mode } from 'org.bukkit.block.data.type.StructureBlock';
/**
 * 'shape' represents the texture and bounding box shape of these stairs.
*/
export class Stairs extends Bisected {
  /**
   * Gets the value of the 'shape' property.
   *
   * @return the 'shape' value
  */
  getShape(): Shape;
  /**
   * Sets the value of the 'shape' property.
   *
   * @param shape the new 'shape' value
  */
  setShape(shape: Shape);
}
export interface Stairs extends Bisected, Directional, Waterlogged {}
/**
 * 'layers' represents the amount of layers of snow which are present in this
 * block.
 * 
 * May not be lower than {@link #getMinimumLayers()} or higher than
 * {@link #getMaximumLayers()}.
*/
export class Snow extends BlockData {
  /**
   * Gets the value of the 'layers' property.
   *
   * @return the 'layers' value
  */
  getLayers(): number;
  /**
   * Sets the value of the 'layers' property.
   *
   * @param layers the new 'layers' value
  */
  setLayers(layers: number);
  /**
   * Gets the minimum allowed value of the 'layers' property.
   *
   * @return the minimum 'layers' value
  */
  getMinimumLayers(): number;
  /**
   * Gets the maximum allowed value of the 'layers' property.
   *
   * @return the maximum 'layers' value
  */
  getMaximumLayers(): number;
}
/**
 * This class encompasses the 'north', 'east', 'south', 'west', height flags
 * which are used to set the height of a wall.
 *
 * 'up' denotes whether the well has a center post.
*/
export class Wall extends Waterlogged {
  /**
   * Gets the value of the 'up' property.
   *
   * @return the 'up' value
  */
  isUp(): boolean;
  /**
   * Sets the value of the 'up' property.
   *
   * @param up the new 'up' value
  */
  setUp(up: boolean): void;
  /**
   * Gets the height of the specified face.
   *
   * @param face to check
   * @return if face is enabled
  */
  getHeight(face: BlockFace): Height;
  /**
   * Set the height of the specified face.
   *
   * @param face to set
   * @param height the height
  */
  setHeight(face: BlockFace, height: Height): void;
}
export class TripwireHook extends Attachable {

}
export interface TripwireHook extends Attachable, Directional, Powerable {}
/**
 * 'north', 'east', 'south', 'west' represent the types of connections this
 * redstone wire has to adjacent blocks.
*/
export class RedstoneWire extends AnaloguePowerable {
  /**
   * Checks the type of connection on the specified face.
   *
   * @param face to check
   * @return connection type
  */
  getFace(face: BlockFace): Connection;
  /**
   * Sets the type of connection on the specified face.
   *
   * @param face to set
   * @param connection the connection type
  */
  setFace(face: BlockFace, connection: Connection): void;
  /**
   * Gets all of this faces which may be set on this block.
   *
   * @return all allowed faces
  */
  getAllowedFaces(): Set<BlockFace>;
}
export class Furnace extends Directional {

}
export interface Furnace extends Directional, Lightable {}
/**
 * 'type' represents the type of piston which this (technical) block corresponds
 * to.
*/
export class TechnicalPiston extends Directional {
  /**
   * Gets the value of the 'type' property.
   *
   * @return the 'type' value
  */
  getType(): Type;
  /**
   * Sets the value of the 'type' property.
   *
   * @param type the new 'type' value
  */
  setType(type: Type);
}
/**
 * 'charges' represents the amount of times the anchor may still be used.
*/
export class RespawnAnchor extends BlockData {
  /**
   * Gets the value of the 'charges' property.
   *
   * @return the 'charges' value
  */
  getCharges(): number;
  /**
   * Sets the value of the 'charges' property.
   *
   * @param charges the new 'charges' value
  */
  setCharges(charges: number);
  /**
   * Gets the maximum allowed value of the 'charges' property.
   *
   * @return the maximum 'charges' value
  */
  getMaximumCharges(): number;
}
/**
 * 'type' represents which part of a double chest this block is, or if it is a
 * single chest.
*/
export class Chest extends Directional {
  /**
   * Gets the value of the 'type' property.
   *
   * @return the 'type' value
  */
  getType(): org_bukkit_block_data_type_Chest_Type;
  /**
   * Sets the value of the 'type' property.
   *
   * @param type the new 'type' value
  */
  setType(type: org_bukkit_block_data_type_Chest_Type);
}
export interface Chest extends Directional, Waterlogged {}
/**
 * 'stage' represents the growth stage of a sapling.
 * 
 * When the sapling reaches {@link #getMaximumStage()} it will attempt to grow
 * into a tree as the next stage.
*/
export class Sapling extends BlockData {
  /**
   * Gets the value of the 'stage' property.
   *
   * @return the 'stage' value
  */
  getStage(): number;
  /**
   * Sets the value of the 'stage' property.
   *
   * @param stage the new 'stage' value
  */
  setStage(stage: number);
  /**
   * Gets the maximum allowed value of the 'stage' property.
   *
   * @return the maximum 'stage' value
  */
  getMaximumStage(): number;
}
export class CaveVines extends Ageable {

}
export interface CaveVines extends Ageable, CaveVinesPlant {}
/**
 * 'bites' represents the amount of bites which have been taken from this slice
 * of cake.
 * 
 * A value of 0 indicates that the cake has not been eaten, whilst a value of
 * {@link #getMaximumBites()} indicates that it is all gone :(
*/
export class Cake extends BlockData {
  /**
   * Gets the value of the 'bites' property.
   *
   * @return the 'bites' value
  */
  getBites(): number;
  /**
   * Sets the value of the 'bites' property.
   *
   * @param bites the new 'bites' value
  */
  setBites(bites: number);
  /**
   * Gets the maximum allowed value of the 'bites' property.
   *
   * @return the maximum 'bites' value
  */
  getMaximumBites(): number;
}
/**
 * 'berries' indicates whether the block has berries.
*/
export class CaveVinesPlant extends BlockData {
  /**
   * Gets the value of the 'berries' property.
   *
   * @return the 'berries' value
  */
  isBerries(): boolean;
  /**
   * Sets the value of the 'berries' property.
   *
   * @param berries the new 'berries' value
  */
  setBerries(berries: boolean): void;
}
export class Chain extends Orientable {

}
export interface Chain extends Orientable, Waterlogged {}
/**
 * 'leaves' represents the size of the leaves on this bamboo block.
*/
export class Bamboo extends Ageable {
  /**
   * Gets the value of the 'leaves' property.
   *
   * @return the 'leaves' value
  */
  getLeaves(): Leaves;
  /**
   * Sets the value of the 'leaves' property.
   *
   * @param leaves the new 'leaves' value
  */
  setLeaves(leaves: Leaves);
}
export interface Bamboo extends Ageable, Sapling {}
/**
 * Similar to {@link Powerable}, 'enabled' indicates whether or not the hopper
 * is currently activated.
 * 
 * Unlike most other blocks, a hopper is only enabled when it is not
 * receiving any power.
*/
export class Hopper extends Directional {
  /**
   * Gets the value of the 'enabled' property.
   *
   * @return the 'enabled' value
  */
  isEnabled(): boolean;
  /**
   * Sets the value of the 'enabled' property.
   *
   * @param enabled the new 'enabled' value
  */
  setEnabled(enabled: boolean): void;
}
export class EnderChest extends Directional {

}
export interface EnderChest extends Directional, Waterlogged {}
export class SmallDripleaf extends Dripleaf {

}
export interface SmallDripleaf extends Dripleaf, Bisected {}
/**
 * 'mode' represents the different modes in which this structure block may
 * operate.
*/
export class StructureBlock extends BlockData {
  /**
   * Gets the value of the 'mode' property.
   *
   * @return the 'mode' value
  */
  getMode(): Mode;
  /**
   * Sets the value of the 'mode' property.
   *
   * @param mode the new 'mode' value
  */
  setMode(mode: Mode);
}
/**
 * 'hanging' denotes whether the lantern is hanging from a block.
*/
export class Lantern extends Waterlogged {
  /**
   * Gets the value of the 'hanging' property.
   *
   * @return the 'hanging' value
  */
  isHanging(): boolean;
  /**
   * Sets the value of the 'hanging' property.
   *
   * @param hanging the new 'hanging' value
  */
  setHanging(hanging: boolean): void;
}
/**
 * 'orientation' is the direction the block is facing.
*/
export class Jigsaw extends BlockData {
  /**
   * Gets the value of the 'orientation' property.
   *
   * @return the 'orientation' value
  */
  getOrientation(): Orientation;
  /**
   * Sets the value of the 'orientation' property.
   *
   * @param orientation the new 'orientation' value
  */
  setOrientation(orientation: Orientation);
}
/**
 * 'has_book' is a quick flag to check whether this lectern has a book inside
 * it.
*/
export class Lectern extends Directional {
  /**
   * Gets the value of the 'has_book' property.
   *
   * @return the 'has_book' value
  */
  hasBook(): boolean;
}
export interface Lectern extends Directional, Powerable {}
export class Cocoa extends Ageable {

}
export interface Cocoa extends Ageable, Directional {}
/**
 * 'short' denotes this piston head is shorter than the usual amount because it
 * is currently retracting.
*/
export class PistonHead extends TechnicalPiston {
  /**
   * Gets the value of the 'short' property.
   *
   * @return the 'short' value
  */
  isShort(): boolean;
  /**
   * Sets the value of the 'short' property.
   *
   * @param _short the new 'short' value
  */
  setShort(_short: boolean): void;
}
/**
 * 'hinge' indicates which hinge this door is attached to and will rotate around
 * when opened.
*/
export class Door extends Bisected {
  /**
   * Gets the value of the 'hinge' property.
   *
   * @return the 'hinge' value
  */
  getHinge(): Hinge;
  /**
   * Sets the value of the 'hinge' property.
   *
   * @param hinge the new 'hinge' value
  */
  setHinge(hinge: Hinge);
}
export interface Door extends Bisected, Directional, Openable, Powerable {}
/**
 * 'tilt' indicates how far the leaf is tilted.
*/
export class BigDripleaf extends Dripleaf {
  /**
   * Gets the value of the 'tilt' property.
   *
   * @return the 'tilt' value
  */
  getTilt(): Tilt;
  /**
   * Sets the value of the 'tilt' property.
   *
   * @param tilt the new 'tilt' value
  */
  setTilt(tilt: Tilt);
}
export class GlowLichen extends MultipleFacing {

}
export interface GlowLichen extends MultipleFacing, Waterlogged {}
export class TrapDoor extends Bisected {

}
export interface TrapDoor extends Bisected, Directional, Openable, Powerable, Waterlogged {}
/**
 * Interface to the 'has_bottle_0', 'has_bottle_1', 'has_bottle_2' flags on a
 * brewing stand which indicate which bottles are rendered on the outside.
 * 
 * Stand may have 0, 1... {@link #getMaximumBottles()}-1 bottles.
*/
export class BrewingStand extends BlockData {
  /**
   * Checks if the stand has the following bottle
   *
   * @param bottle to check
   * @return if bottle is present
  */
  hasBottle(bottle: number): boolean;
  /**
   * Set whether the stand has this bottle present.
   *
   * @param bottle to set
   * @param has bottle
  */
  setBottle(bottle: number, has: boolean): void;
  /**
   * Get the indexes of all the bottles present on this block.
   *
   * @return set of all bottles
  */
  getBottles(): Set<number>;
  /**
   * Get the maximum amount of bottles present on this stand.
   *
   * @return maximum bottle count
  */
  getMaximumBottles(): number;
}
/**
 * 'persistent' indicates whether or not leaves will be checked by the server to
 * see if they are subject to decay or not.
 * 
 * 'distance' denotes how far the block is from a tree and is used in
 * conjunction with 'persistent' flag to determine if the leaves will decay or
 * not.
*/
export class Leaves extends BlockData {
  /**
   * Gets the value of the 'persistent' property.
   *
   * @return the persistent value
  */
  isPersistent(): boolean;
  /**
   * Sets the value of the 'persistent' property.
   *
   * @param persistent the new 'persistent' value
  */
  setPersistent(persistent: boolean): void;
  /**
   * Gets the value of the 'distance' property.
   *
   * @return the 'distance' value
  */
  getDistance(): number;
  /**
   * Sets the value of the 'distance' property.
   *
   * @param distance the new 'distance' value
  */
  setDistance(distance: number);
  /**
   * Gets the maximum allowed value of the 'distance' property.
   *
   * @return the maximum 'distance' value
  */
  getMaximumDistance(): number;
  /**
   * Gets the minimum allowed value of the 'distance' property.
   *
   * @return the minimum 'distance' value
  */
  getMinimumDistance(): number;
}
/**
 * 'extended' denotes whether the piston head is currently extended or not.
*/
export class Piston extends Directional {
  /**
   * Gets the value of the 'extended' property.
   *
   * @return the 'extended' value
  */
  isExtended(): boolean;
  /**
   * Sets the value of the 'extended' property.
   *
   * @param extended the new 'extended' value
  */
  setExtended(extended: boolean): void;
}
/**
 * 'in_wall" indicates if the fence gate is attached to a wall, and if true the
 * texture is lowered by a small amount to blend in better.
*/
export class Gate extends Directional {
  /**
   * Gets the value of the 'in_wall' property.
   *
   * @return the 'in_wall' value
  */
  isInWall(): boolean;
  /**
   * Sets the value of the 'in_wall' property.
   *
   * @param inWall the new 'in_wall' value
  */
  setInWall(inWall: boolean): void;
}
export interface Gate extends Directional, Openable, Powerable {}
export class WallSign extends Directional {

}
export interface WallSign extends Directional, Waterlogged {}
/**
 * 'eye' denotes whether this end portal frame has been activated by having an
 * eye of ender placed in it.
*/
export class EndPortalFrame extends Directional {
  /**
   * Gets the value of the 'eye' property.
   *
   * @return the 'eye' value
  */
  hasEye(): boolean;
  /**
   * Sets the value of the 'eye' property.
   *
   * @param eye the new 'eye' value
  */
  setEye(eye: boolean): void;
}
/**
 * 'attachment' denotes how the bell is attached to its block.
*/
export class Bell extends Directional {
  /**
   * Gets the value of the 'attachment' property.
   *
   * @return the 'attachment' value
  */
  getAttachment(): Attachment;
  /**
   * Sets the value of the 'attachment' property.
   *
   * @param attachment the new 'attachment' value
  */
  setAttachment(attachment: Attachment);
}
export interface Bell extends Directional, Powerable {}
export class Dripleaf extends Directional {

}
export interface Dripleaf extends Directional, Waterlogged {}
/**
 * 'drag' indicates whether a force will be applied on entities moving through
 * this block.
*/
export class BubbleColumn extends BlockData {
  /**
   * Gets the value of the 'drag' property.
   *
   * @return the 'drag' value
  */
  isDrag(): boolean;
  /**
   * Sets the value of the 'drag' property.
   *
   * @param drag the new 'drag' value
  */
  setDrag(drag: boolean): void;
}
/**
 * 'honey_level' represents the amount of honey stored in the hive.
*/
export class Beehive extends Directional {
  /**
   * Gets the value of the 'honey_level' property.
   *
   * @return the 'honey_level' value
  */
  getHoneyLevel(): number;
  /**
   * Sets the value of the 'honey_level' property.
   *
   * @param honeyLevel the new 'honey_level' value
  */
  setHoneyLevel(honeyLevel: number);
  /**
   * Gets the maximum allowed value of the 'honey_level' property.
   *
   * @return the maximum 'honey_level' value
  */
  getMaximumHoneyLevel(): number;
}
export class Light extends Levelled {

}
export interface Light extends Levelled, Waterlogged {}
/**
 * The 'moisture' level of farmland indicates how close it is to a water source
 * (if any).
 * 
 * A higher moisture level leads, to faster growth of crops on this block, but
 * cannot be higher than {@link #getMaximumMoisture()}.
*/
export class Farmland extends BlockData {
  /**
   * Gets the value of the 'moisture' property.
   *
   * @return the 'moisture' value
  */
  getMoisture(): number;
  /**
   * Sets the value of the 'moisture' property.
   *
   * @param moisture the new 'moisture' value
  */
  setMoisture(moisture: number);
  /**
   * Gets the maximum allowed value of the 'moisture' property.
   *
   * @return the maximum 'moisture' value
  */
  getMaximumMoisture(): number;
}
export class Sign extends Rotatable {

}
export interface Sign extends Rotatable, Waterlogged {}
export class Grindstone extends Directional {

}
export interface Grindstone extends Directional, FaceAttachable {}
export class Observer extends Directional {

}
export interface Observer extends Directional, Powerable {}
/**
 * 'disarmed' denotes that the tripwire was broken with shears and will not
 * subsequently produce a current when destroyed.
*/
export class Tripwire extends Attachable {
  /**
   * Gets the value of the 'disarmed' property.
   *
   * @return the 'disarmed' value
  */
  isDisarmed(): boolean;
  /**
   * Sets the value of the 'disarmed' property.
   *
   * @param disarmed the new 'disarmed' value
  */
  setDisarmed(disarmed: boolean): void;
}
export interface Tripwire extends Attachable, MultipleFacing, Powerable {}
/**
 * Similar to {@link Powerable}, 'triggered' indicates whether or not the
 * dispenser is currently activated.
*/
export class Dispenser extends Directional {
  /**
   * Gets the value of the 'triggered' property.
   *
   * @return the 'triggered' value
  */
  isTriggered(): boolean;
  /**
   * Sets the value of the 'triggered' property.
   *
   * @param triggered the new 'triggered' value
  */
  setTriggered(triggered: boolean): void;
}
/**
 * md_5's mixtape.
*/
export class Fire extends Ageable {

}
export interface Fire extends Ageable, MultipleFacing {}
/**
 * 'signal_fire' denotes whether the fire is extra smokey due to having a hay
 * bale placed beneath it.
*/
export class Campfire extends Directional {
  /**
   * Gets the value of the 'signal_fire' property.
   *
   * @return the 'signal_fire' value
  */
  isSignalFire(): boolean;
  /**
   * Sets the value of the 'signal_fire' property.
   *
   * @param signalFire the new 'signal_fire' value
  */
  setSignalFire(signalFire: boolean): void;
}
export interface Campfire extends Directional, Lightable, Waterlogged {}
/**
 * 'hatch' is the number of turtles which may hatch from these eggs.
 * 
 * 'eggs' is the number of eggs which appear in this block.
*/
export class TurtleEgg extends BlockData {
  /**
   * Gets the value of the 'eggs' property.
   *
   * @return the 'eggs' value
  */
  getEggs(): number;
  /**
   * Sets the value of the 'eggs' property.
   *
   * @param eggs the new 'eggs' value
  */
  setEggs(eggs: number);
  /**
   * Gets the minimum allowed value of the 'eggs' property.
   *
   * @return the minimum 'eggs' value
  */
  getMinimumEggs(): number;
  /**
   * Gets the maximum allowed value of the 'eggs' property.
   *
   * @return the maximum 'eggs' value
  */
  getMaximumEggs(): number;
  /**
   * Gets the value of the 'hatch' property.
   *
   * @return the 'hatch' value
  */
  getHatch(): number;
  /**
   * Sets the value of the 'hatch' property.
   *
   * @param hatch the new 'hatch' value
  */
  setHatch(hatch: number);
  /**
   * Gets the maximum allowed value of the 'hatch' property.
   *
   * @return the maximum 'hatch' value
  */
  getMaximumHatch(): number;
}
/**
 * 'instrument' is the type of sound made when this note block is activated.
 * 
 * 'note' is the specified tuned pitch that the instrument will be played in.
*/
export class NoteBlock extends Powerable {
  /**
   * Gets the value of the 'instrument' property.
   *
   * @return the 'instrument' value
  */
  getInstrument(): Instrument;
  /**
   * Sets the value of the 'instrument' property.
   *
   * @param instrument the new 'instrument' value
  */
  setInstrument(instrument: Instrument);
  /**
   * Gets the value of the 'note' property.
   *
   * @return the 'note' value
  */
  getNote(): Note;
  /**
   * Sets the value of the 'note' property.
   *
   * @param note the new 'note' value
  */
  setNote(note: Note);
}
/**
 * A type of minecart rail which interacts with redstone in one way or another.
*/
export class RedstoneRail extends Powerable {

}
export interface RedstoneRail extends Powerable, Rail {}
/**
 * 'sculk_sensor_phase' indicates the current operational phase of the sensor.
*/
export class SculkSensor extends AnaloguePowerable {
  /**
   * Gets the value of the 'sculk_sensor_phase' property.
   *
   * @return the 'sculk_sensor_phase' value
  */
  getPhase(): Phase;
  /**
   * Sets the value of the 'sculk_sensor_phase' property.
   *
   * @param phase the new 'sculk_sensor_phase' value
  */
  setPhase(phase: Phase);
}
export interface SculkSensor extends AnaloguePowerable, Waterlogged {}
/**
 * 'thickness' represents the dripstone thickness.
 * 
 * 'vertical_direction' represents the dripstone orientation.
 * 
 * Some blocks may not be able to face in all directions, use
 * {@link #getVerticalDirections()} to get all possible directions for this
 * block.
*/
export class PointedDripstone extends Waterlogged {
  /**
   * Gets the value of the 'vertical_direction' property.
   *
   * @return the 'vertical_direction' value
  */
  getVerticalDirection(): BlockFace;
  /**
   * Sets the value of the 'vertical_direction' property.
   *
   * @param direction the new 'vertical_direction' value
  */
  setVerticalDirection(verticalDirection: BlockFace);
  /**
   * Gets the faces which are applicable to this block.
   *
   * @return the allowed 'vertical_direction' values
  */
  getVerticalDirections(): Set<BlockFace>;
  /**
   * Gets the value of the 'thickness' property.
   *
   * @return the 'thickness' value
  */
  getThickness(): Thickness;
  /**
   * Sets the value of the 'thickness' property.
   *
   * @param thickness the new 'thickness' value
  */
  setThickness(thickness: Thickness);
}
/**
 * 'has_record' is a quick flag to check whether this jukebox has a record
 * inside it.
*/
export class Jukebox extends BlockData {
  /**
   * Gets the value of the 'has_record' property.
   *
   * @return the 'has_record' value
  */
  hasRecord(): boolean;
}
export class LightningRod extends Directional {

}
export interface LightningRod extends Directional, Powerable, Waterlogged {}
export class GlassPane extends MultipleFacing {

}
export interface GlassPane extends MultipleFacing, Waterlogged {}
/**
 * 'conditional' denotes whether this command block is conditional or not, i.e.
 * will only execute if the preceeding command block also executed successfully.
*/
export class CommandBlock extends Directional {
  /**
   * Gets the value of the 'conditional' property.
   *
   * @return the 'conditional' value
  */
  isConditional(): boolean;
  /**
   * Sets the value of the 'conditional' property.
   *
   * @param conditional the new 'conditional' value
  */
  setConditional(conditional: boolean): void;
}
/**
 * 'candles' represents the number of candles which are present.
*/
export class Candle extends Lightable {
  /**
   * Gets the value of the 'candles' property.
   *
   * @return the 'candles' value
  */
  getCandles(): number;
  /**
   * Sets the value of the 'candles' property.
   *
   * @param candles the new 'candles' value
  */
  setCandles(candles: number);
  /**
   * Gets the maximum allowed value of the 'candles' property.
   *
   * @return the maximum 'candles' value
  */
  getMaximumCandles(): number;
  /**
   * Gets the minimum allowed value of the 'candles' property.
   *
   * @return the minimum 'candles' value
  */
  getMinimumCandles(): number;
}
export interface Candle extends Lightable, Waterlogged {}
export class AmethystCluster extends Directional {

}
export interface AmethystCluster extends Directional, Waterlogged {}
/**
 * Similar to {@link Bisected}, 'part' denotes which half of the bed this block
 * corresponds to.
 * 
 * 'occupied' property is a quick flag to check if a player is currently
 * sleeping in this bed block.
*/
export class Bed extends Directional {
  /**
   * Gets the value of the 'part' property.
   *
   * @return the 'part' value
  */
  getPart(): Part;
  /**
   * Sets the value of the 'part' property.
   *
   * @param part the new 'part' value
  */
  setPart(part: Part);
  /**
   * Gets the value of the 'occupied' property.
   *
   * @return the 'occupied' value
  */
  isOccupied(): boolean;
}
/**
 * 'inverted' denotes whether this daylight detector is in the inverted mode,
 * i.e. activates in the absence of light rather than presence."
*/
export class DaylightDetector extends AnaloguePowerable {
  /**
   * Gets the value of the 'inverted' property.
   *
   * @return the 'inverted' value
  */
  isInverted(): boolean;
  /**
   * Sets the value of the 'inverted' property.
   *
   * @param inverted the new 'inverted' value
  */
  setInverted(inverted: boolean): void;
}
export class RedstoneWallTorch extends Directional {

}
export interface RedstoneWallTorch extends Directional, Lightable {}
/**
 * 'unstable' indicates whether this TNT will explode on punching.
*/
export class TNT extends BlockData {
  /**
   * Gets the value of the 'unstable' property.
   *
   * @return the 'unstable' value
  */
  isUnstable(): boolean;
  /**
   * Sets the value of the 'unstable' property.
   *
   * @param unstable the new 'unstable' value
  */
  setUnstable(unstable: boolean): void;
}
/**
 * 'pickles' indicates the number of pickles in this block.
*/
export class SeaPickle extends Waterlogged {
  /**
   * Gets the value of the 'pickles' property.
   *
   * @return the 'pickles' value
  */
  getPickles(): number;
  /**
   * Sets the value of the 'pickles' property.
   *
   * @param pickles the new 'pickles' value
  */
  setPickles(pickles: number);
  /**
   * Gets the minimum allowed value of the 'pickles' property.
   *
   * @return the minimum 'pickles' value
  */
  getMinimumPickles(): number;
  /**
   * Gets the maximum allowed value of the 'pickles' property.
   *
   * @return the maximum 'pickles' value
  */
  getMaximumPickles(): number;
}
export class Ladder extends Directional {

}
export interface Ladder extends Directional, Waterlogged {}
/**
 * 'type' represents what state the slab is in - either top, bottom, or a double
 * slab occupying the full block.
*/
export class Slab extends Waterlogged {
  /**
   * Gets the value of the 'type' property.
   *
   * @return the 'type' value
  */
  getType(): org_bukkit_block_data_type_Slab_Type;
  /**
   * Sets the value of the 'type' property.
   *
   * @param type the new 'type' value
  */
  setType(type: org_bukkit_block_data_type_Slab_Type);
}
/**
 * 'delay' is the propagation delay of a repeater, i.e. how many ticks before it
 * will be activated from a current change and propagate it to the next block.
 * 
 * Delay may not be lower than {@link #getMinimumDelay()} or higher than
 * {@link #getMaximumDelay()}.
 * 
 * 'locked' denotes whether the repeater is in the locked state or not.
 * 
 * A locked repeater will not change its output until it is unlocked. In game, a
 * locked repeater is created by having a constant current perpendicularly
 * entering the block.
*/
export class Repeater extends Directional {
  /**
   * Gets the value of the 'delay' property.
   *
   * @return the 'delay' value
  */
  getDelay(): number;
  /**
   * Sets the value of the 'delay' property.
   *
   * @param delay the new 'delay' value
  */
  setDelay(delay: number);
  /**
   * Gets the minimum allowed value of the 'delay' property.
   *
   * @return the minimum 'delay' value
  */
  getMinimumDelay(): number;
  /**
   * Gets the maximum allowed value of the 'delay' property.
   *
   * @return the maximum 'delay' value
  */
  getMaximumDelay(): number;
  /**
   * Gets the value of the 'locked' property.
   *
   * @return the 'locked' value
  */
  isLocked(): boolean;
  /**
   * Sets the value of the 'locked' property.
   *
   * @param locked the new 'locked' value
  */
  setLocked(locked: boolean): void;
}
export interface Repeater extends Directional, Powerable {}
export class CoralWallFan extends Directional {

}
export interface CoralWallFan extends Directional, Waterlogged {}
export class Switch extends Directional {
  /**
   * Gets the value of the 'face' property.
   *
   * @return the 'face' value
   * @deprecated use {@link #getAttachedFace()}
  */
  getFace(): Face;
  /**
   * Sets the value of the 'face' property.
   *
   * @param face the new 'face' value
   * @deprecated use {@link #getAttachedFace()}
  */
  setFace(face: Face);
}
export interface Switch extends Directional, FaceAttachable, Powerable {}
/**
 * 'mode' indicates what mode this comparator will operate in.
*/
export class Comparator extends Directional {
  /**
   * Gets the value of the 'mode' property.
   *
   * @return the 'mode' value
  */
  getMode(): org_bukkit_block_data_type_Comparator_Mode;
  /**
   * Sets the value of the 'mode' property.
   *
   * @param mode the new 'mode' value
  */
  setMode(mode: org_bukkit_block_data_type_Comparator_Mode);
}
export interface Comparator extends Directional, Powerable {}
/**
 * 'bottom' indicates whether the scaffolding is floating or not.
 * 
 * 'distance' indicates the distance from a scaffolding block placed above a
 * 'bottom' scaffold.
 * 
 * When 'distance' reaches {@link #getMaximumDistance()} the block will drop.
*/
export class Scaffolding extends Waterlogged {
  /**
   * Gets the value of the 'bottom' property.
   *
   * @return the 'bottom' value
  */
  isBottom(): boolean;
  /**
   * Sets the value of the 'bottom' property.
   *
   * @param bottom the new 'bottom' value
  */
  setBottom(bottom: boolean): void;
  /**
   * Gets the value of the 'distance' property.
   *
   * @return the 'distance' value
  */
  getDistance(): number;
  /**
   * Sets the value of the 'distance' property.
   *
   * @param distance the new 'distance' value
  */
  setDistance(distance: number);
  /**
   * Gets the maximum allowed value of the 'distance' property.
   *
   * @return the maximum 'distance' value
  */
  getMaximumDistance(): number;
}
export class Fence extends MultipleFacing {

}
export interface Fence extends MultipleFacing, Waterlogged {}

}
declare module 'org.bukkit.event' {
import { ArrayList, Collection, EnumMap } from 'java.util';
import { Enum, Throwable, Exception } from 'java.lang';
import { RegisteredListener, Plugin } from 'org.bukkit.plugin';
export class EventException extends Exception {
  /**
   * Constructs a new EventException based on the given Exception
   *
   * @param throwable Exception that triggered this Exception
  */
  constructor(throwable: Throwable);
  /**
   * Constructs a new EventException
  */
  constructor();
  /**
   * Constructs a new EventException with the given message
   *
   * @param cause The exception that caused this
   * @param message The message
  */
  constructor(cause: Throwable, message: string);
  /**
   * Constructs a new EventException with the given message
   *
   * @param message The message
  */
  constructor(message: string);
  /**
   * If applicable, returns the Exception that triggered this Exception
   *
   * @return Inner exception, or null if one does not exist
  */
  getCause(): Throwable;
}
/**
 * An annotation to mark methods as being event handler methods
*/
export class EventHandler {

}
/**
 * Represents an event.
 *
 * All events require a static method named getHandlerList() which returns the same {@link HandlerList} as {@link #getHandlers()}.
 *
 * @see PluginManager#callEvent(Event)
 * @see PluginManager#registerEvents(Listener,Plugin)
*/
export class Event {
  /**
   * The default constructor is defined for cleaner code. This constructor
   * assumes the event is synchronous.
  */
  constructor();
  /**
   * This constructor is used to explicitly declare an event as synchronous
   * or asynchronous.
   *
   * @param isAsync true indicates the event will fire asynchronously, false
   *     by default from default constructor
  */
  constructor(isAsync: boolean);
  /**
   * Calls the event and tests if cancelled.
   *
   * @return false if event was cancelled, if cancellable. otherwise true.
  */
  callEvent(): boolean;
  /**
   * Convenience method for providing a user-friendly identifier. By
   * default, it is the event's class's {@linkplain Class#getSimpleName()
   * simple name}.
   *
   * @return name of this event
  */
  getEventName(): string;
  getHandlers(): HandlerList;
  /**
   * Any custom event that should not by synchronized with other events must
   * use the specific constructor. These are the caveats of using an
   * asynchronous event:
   * 
   * The event is never fired from inside code triggered by a
   *     synchronous event. Attempting to do so results in an {@link
   *     java.lang.IllegalStateException}.
   * However, asynchronous event handlers may fire synchronous or
   *     asynchronous events
   * The event may be fired multiple times simultaneously and in any
   *     order.
   * Any newly registered or unregistered handler is ignored after an
   *     event starts execution.
   * The handlers for this event may block for any length of time.
   * Some implementations may selectively declare a specific event use
   *     as asynchronous. This behavior should be clearly defined.
   * Asynchronous calls are not calculated in the plugin timing system.
   * 
   *
   * @return false by default, true if the event fires asynchronously
  */
  isAsynchronous(): boolean;
}
/**
 * Simple interface for tagging all EventListeners
*/
export class Listener {

}
/**
 * A list of event handlers, stored per-event. Based on lahwran's fevents.
*/
export class HandlerList {
  /**
   * Bake all handler lists. Best used just after all normal event
   * registration is complete, ie just after all plugins are loaded if
   * you're using fevents in a plugin system.
  */
  static bakeAll(): void;
  /**
   * Unregister all listeners from all handler lists.
  */
  static unregisterAll(): void;
  /**
   * Unregister a specific plugin's listeners from all handler lists.
   *
   * @param plugin plugin to unregister
  */
  static unregisterAll(plugin: Plugin): void;
  /**
   * Unregister a specific listener from all handler lists.
   *
   * @param listener listener to unregister
  */
  static unregisterAll(listener: Listener): void;
  /**
   * Create a new handler list and initialize using EventPriority.
   * 
   * The HandlerList is then added to meta-list for use in bakeAll()
  */
  constructor();
  /**
   * Register a new listener in this handler list
   *
   * @param listener listener to register
  */
  register(listener: RegisteredListener): void;
  /**
   * Register a collection of new listeners in this handler list
   *
   * @param listeners listeners to register
  */
  registerAll(listeners: Collection<RegisteredListener>): void;
  /**
   * Remove a listener from a specific order slot
   *
   * @param listener listener to remove
  */
  unregister(listener: RegisteredListener): void;
  /**
   * Remove a specific plugin's listeners from this handler
   *
   * @param plugin plugin to remove
  */
  unregister(plugin: Plugin): void;
  /**
   * Remove a specific listener from this handler
   *
   * @param listener listener to remove
  */
  unregister(listener: Listener): void;
  /**
   * Bake HashMap and ArrayLists to 2d array - does nothing if not necessary
  */
  bake(): void;
  /**
   * Get the baked registered listeners associated with this handler list
   *
   * @return the array of registered listeners
  */
  getRegisteredListeners(): RegisteredListener[];
  /**
   * Get a specific plugin's registered listeners associated with this
   * handler list
   *
   * @param plugin the plugin to get the listeners of
   * @return the list of registered listeners
  */
  static getRegisteredListeners(plugin: Plugin): ArrayList<RegisteredListener>;
  /**
   * Get a list of all handler lists for every event type
   *
   * @return the list of all handler lists
  */
  static getHandlerLists(): ArrayList<HandlerList>;
}
/**
 * Represents an event's priority in execution.
 * 
 * Listeners with lower priority are called first
 * will listeners with higher priority are called last.
 * 
 * Listeners are called in following order:
 * {@link #LOWEST} -> {@link #LOW} -> {@link #NORMAL} -> {@link #HIGH} -> {@link #HIGHEST} -> {@link #MONITOR}
*/
export class EventPriority extends Enum<EventPriority> {
  /**
   * Event call is of very low importance and should be run first, to allow
   * other plugins to further customise the outcome
  */
  static readonly LOWEST: EventPriority;
  /**
   * Event call is of low importance
  */
  static readonly LOW: EventPriority;
  /**
   * Event call is neither important nor unimportant, and may be run
   * normally
  */
  static readonly NORMAL: EventPriority;
  /**
   * Event call is of high importance
  */
  static readonly HIGH: EventPriority;
  /**
   * Event call is critical and must have the final say in what happens
   * to the event
  */
  static readonly HIGHEST: EventPriority;
  /**
   * Event is listened to purely for monitoring the outcome of an event.
   * 
   * No modifications to the event should be made under this priority
  */
  static readonly MONITOR: EventPriority;
  static valueOf(name: string): EventPriority;
  static values(): EventPriority[];
  getSlot(): number;
}
export class Cancellable {
  /**
   * Gets the cancellation state of this event. A cancelled event will not
   * be executed in the server, but will still pass to other plugins
   *
   * @return true if this event is cancelled
  */
  isCancelled(): boolean;
  /**
   * Sets the cancellation state of this event. A cancelled event will not
   * be executed in the server, but will still pass to other plugins.
   *
   * @param cancel true if you wish to cancel this event
  */
  setCancelled(cancel: boolean): void;
}

}
declare module 'org.bukkit.block.data.type.Bamboo' {
import { Enum } from 'java.lang';
/**
 * Bamboo leaf size.
*/
export class Leaves extends Enum<Leaves> {
  /**
   * No leaves.
  */
  static readonly NONE: Leaves;
  /**
   * Small leaves.
  */
  static readonly SMALL: Leaves;
  /**
   * Large leaves.
  */
  static readonly LARGE: Leaves;
  static valueOf(name: string): Leaves;
  static values(): Leaves[];
}

}
declare module 'org.bukkit.Raid' {
import { Enum } from 'java.lang';
/**
 * Represents the status of a {@link Raid}.
*/
export class RaidStatus extends Enum<RaidStatus> {
  /**
   * The raid is in progress.
  */
  static readonly ONGOING: RaidStatus;
  /**
   * The raid was beaten by heroes.
  */
  static readonly VICTORY: RaidStatus;
  /**
   * The village has fallen (i.e. all villagers died).
  */
  static readonly LOSS: RaidStatus;
  /**
   * The raid was terminated.
  */
  static readonly STOPPED: RaidStatus;
  static valueOf(name: string): RaidStatus;
  static values(): RaidStatus[];
}

}
declare module 'org.bukkit.material.types' {
import { Map } from 'java.util';
import { Enum } from 'java.lang';
import { BlockFace } from 'org.bukkit.block';
/**
 * Represents the different textured blocks of mushroom.
 * @deprecated use BlockData
*/
export class MushroomBlockTexture extends Enum<MushroomBlockTexture> {
  /**
   * Pores on all faces.
  */
  static readonly ALL_PORES: MushroomBlockTexture;
  /**
   * Cap texture on the top, north and west faces, pores on remaining sides.
  */
  static readonly CAP_NORTH_WEST: MushroomBlockTexture;
  /**
   * Cap texture on the top and north faces, pores on remaining sides.
  */
  static readonly CAP_NORTH: MushroomBlockTexture;
  /**
   * Cap texture on the top, north and east faces, pores on remaining sides.
  */
  static readonly CAP_NORTH_EAST: MushroomBlockTexture;
  /**
   * Cap texture on the top and west faces, pores on remaining sides.
  */
  static readonly CAP_WEST: MushroomBlockTexture;
  /**
   * Cap texture on the top face, pores on remaining sides.
  */
  static readonly CAP_TOP: MushroomBlockTexture;
  /**
   * Cap texture on the top and east faces, pores on remaining sides.
  */
  static readonly CAP_EAST: MushroomBlockTexture;
  /**
   * Cap texture on the top, south and west faces, pores on remaining sides.
  */
  static readonly CAP_SOUTH_WEST: MushroomBlockTexture;
  /**
   * Cap texture on the top and south faces, pores on remaining sides.
  */
  static readonly CAP_SOUTH: MushroomBlockTexture;
  /**
   * Cap texture on the top, south and east faces, pores on remaining sides.
  */
  static readonly CAP_SOUTH_EAST: MushroomBlockTexture;
  /**
   * Stem texture on the north, east, south and west faces, pores on top and
   * bottom.
  */
  static readonly STEM_SIDES: MushroomBlockTexture;
  /**
   * Cap texture on all faces.
  */
  static readonly ALL_CAP: MushroomBlockTexture;
  /**
   * Stem texture on all faces.
  */
  static readonly ALL_STEM: MushroomBlockTexture;
  static valueOf(name: string): MushroomBlockTexture;
  static values(): MushroomBlockTexture[];
  /**
   * Gets the associated data value representing this mushroom block face.
   *
   * @return A byte containing the data value of this mushroom block face
   * @deprecated Magic value
  */
  getData(): number;
  /**
   * Gets the face that has cap texture.
   *
   * @return The cap face
  */
  getCapFace(): BlockFace | null;
  /**
   * Gets the MushroomBlockType with the given data value.
   *
   * @param data Data value to fetch
   * @return The {@link MushroomBlockTexture} representing the given value, or
   * null if it doesn't exist
   * @deprecated Magic value
  */
  static getByData(data: number): MushroomBlockTexture | null;
  /**
   * Gets the MushroomBlockType with cap texture on the given block face.
   *
   * @param face the required block face with cap texture
   * @return The {@link MushroomBlockTexture} representing the given block
   * face, or null if it doesn't exist
   *
   * @see BlockFace
  */
  static getCapByFace(face: BlockFace | null): MushroomBlockTexture | null;
}

}
declare module 'org.bukkit.map' {
import { Component } from 'net.kyori.adventure.text';
import { Type } from 'org.bukkit.map.MapCursor';
import { Color, Image } from 'java.awt';
import { HashMap, List } from 'java.util';
import { BufferedImage } from 'java.awt.image';
import { CharacterSprite } from 'org.bukkit.map.MapFont';
import { Scale } from 'org.bukkit.map.MapView';
import { World } from 'org.bukkit';
import { Player } from 'org.bukkit.entity';
/**
 * Represents a map item.
*/
export class MapView {
  /**
   * Get the ID of this map item for use with {@link MapMeta}.
   *
   * @return The ID of the map.
  */
  getId(): number;
  /**
   * Check whether this map is virtual. A map is virtual if its lowermost
   * MapRenderer is plugin-provided.
   *
   * @return Whether the map is virtual.
  */
  isVirtual(): boolean;
  /**
   * Get the scale of this map.
   *
   * @return The scale of the map.
  */
  getScale(): Scale;
  /**
   * Set the scale of this map.
   *
   * @param scale The scale to set.
  */
  setScale(scale: Scale);
  /**
   * Get the center X position of this map.
   *
   * @return The center X position.
  */
  getCenterX(): number;
  /**
   * Get the center Z position of this map.
   *
   * @return The center Z position.
  */
  getCenterZ(): number;
  /**
   * Set the center X position of this map.
   *
   * @param x The center X position.
  */
  setCenterX(centerX: number);
  /**
   * Set the center Z position of this map.
   *
   * @param z The center Z position.
  */
  setCenterZ(centerZ: number);
  /**
   * Get the world that this map is associated with. Primarily used by the
   * internal renderer, but may be used by external renderers. May return
   * null if the world the map is associated with is not loaded.
   *
   * @return The World this map is associated with.
  */
  getWorld(): World | null;
  /**
   * Set the world that this map is associated with. The world is used by
   * the internal renderer, and may also be used by external renderers.
   *
   * @param world The World to associate this map with.
  */
  setWorld(world: World);
  /**
   * Get a list of MapRenderers currently in effect.
   *
   * @return A `List` containing each map renderer.
  */
  getRenderers(): MapRenderer[];
  /**
   * Add a renderer to this map.
   *
   * @param renderer The MapRenderer to add.
  */
  addRenderer(renderer: MapRenderer): void;
  /**
   * Remove a renderer from this map.
   *
   * @param renderer The MapRenderer to remove.
   * @return True if the renderer was successfully removed.
  */
  removeRenderer(renderer: MapRenderer | null): boolean;
  /**
   * Gets whether a position cursor should be shown when the map is near its
   * center.
   *
   * @return tracking status
  */
  isTrackingPosition(): boolean;
  /**
   * Sets whether a position cursor should be shown when the map is near its
   * center.
   *
   * @param trackingPosition tracking status
  */
  setTrackingPosition(trackingPosition: boolean): void;
  /**
   * Whether the map will show a smaller position cursor (true), or no
   * position cursor (false) when cursor is outside of map's range.
   *
   * @return unlimited tracking state
  */
  isUnlimitedTracking(): boolean;
  /**
   * Whether the map will show a smaller position cursor (true), or no
   * position cursor (false) when cursor is outside of map's range.
   *
   * @param unlimited tracking state
  */
  setUnlimitedTracking(unlimited: boolean): void;
  /**
   * Gets whether the map is locked or not.
   *
   * A locked map may not be explored further.
   *
   * @return lock status
  */
  isLocked(): boolean;
  /**
   * Gets whether the map is locked or not.
   *
   * A locked map may not be explored further.
   *
   * @param locked status
  */
  setLocked(locked: boolean): void;
}
/**
 * Represents a bitmap font drawable to a map.
*/
export class MapFont {
  /**
   * Set the sprite for a given character.
   *
   * @param ch The character to set the sprite for.
   * @param sprite The CharacterSprite to set.
   * @throws IllegalStateException if this font is static.
  */
  setChar(ch: string, sprite: CharacterSprite): void;
  /**
   * Get the sprite for a given character.
   *
   * @param ch The character to get the sprite for.
   * @return The CharacterSprite associated with the character, or null if
   *     there is none.
  */
  getChar(ch: string): CharacterSprite | null;
  /**
   * Get the width of the given text as it would be rendered using this
   * font.
   *
   * @param text The text.
   * @return The width in pixels.
  */
  getWidth(text: string): number;
  /**
   * Get the height of this font.
   *
   * @return The height of the font.
  */
  getHeight(): number;
  /**
   * Check whether the given text is valid.
   *
   * @param text The text.
   * @return True if the string contains only defined characters, false
   *     otherwise.
  */
  isValid(text: string): boolean;
}
/**
 * Represents a renderer for a map.
*/
export class MapRenderer {
  /**
   * Initialize the map renderer base to be non-contextual. See {@link
   * #isContextual()}.
  */
  constructor();
  /**
   * Initialize the map renderer base with the given contextual status.
   *
   * @param contextual Whether the renderer is contextual. See {@link
   *     #isContextual()}.
  */
  constructor(contextual: boolean);
  /**
   * Get whether the renderer is contextual, i.e. has different canvases for
   * different players.
   *
   * @return True if contextual, false otherwise.
  */
  isContextual(): boolean;
  /**
   * Initialize this MapRenderer for the given map.
   *
   * @param map The MapView being initialized.
  */
  initialize(map: MapView): void;
  /**
   * Render to the given map.
   *
   * @param map The MapView being rendered to.
   * @param canvas The canvas to use for rendering.
   * @param player The player who triggered the rendering.
  */
  render(map: MapView, canvas: MapCanvas, player: Player): void;
}
/**
 * Represents all the map cursors on a {@link MapCanvas}. Like MapCanvas, a
 * MapCursorCollection is linked to a specific {@link MapRenderer}.
*/
export class MapCursorCollection {
  /**
   * Get the amount of cursors in this collection.
   *
   * @return The size of this collection.
  */
  size(): number;
  /**
   * Get a cursor from this collection.
   *
   * @param index The index of the cursor.
   * @return The MapCursor.
  */
  getCursor(index: number): MapCursor;
  /**
   * Remove a cursor from the collection.
   *
   * @param cursor The MapCursor to remove.
   * @return Whether the cursor was removed successfully.
  */
  removeCursor(cursor: MapCursor): boolean;
  /**
   * Add a cursor to the collection.
   *
   * @param cursor The MapCursor to add.
   * @return The MapCursor that was passed.
  */
  addCursor(cursor: MapCursor): MapCursor;
  /**
   * Add a cursor to the collection.
   *
   * @param x The x coordinate, from -128 to 127.
   * @param y The y coordinate, from -128 to 127.
   * @param direction The facing of the cursor, from 0 to 15.
   * @return The newly added MapCursor.
  */
  addCursor(x: number, y: number, direction: number): MapCursor;
  /**
   * Add a cursor to the collection.
   *
   * @param x The x coordinate, from -128 to 127.
   * @param y The y coordinate, from -128 to 127.
   * @param direction The facing of the cursor, from 0 to 15.
   * @param type The type (color/style) of the map cursor.
   * @return The newly added MapCursor.
   * @deprecated Magic value
  */
  addCursor(x: number, y: number, direction: number, type: number): MapCursor;
  /**
   * Add a cursor to the collection.
   *
   * @param x The x coordinate, from -128 to 127.
   * @param y The y coordinate, from -128 to 127.
   * @param direction The facing of the cursor, from 0 to 15.
   * @param type The type (color/style) of the map cursor.
   * @param visible Whether the cursor is visible.
   * @return The newly added MapCursor.
   * @deprecated Magic value
  */
  addCursor(x: number, y: number, direction: number, type: number, visible: boolean): MapCursor;
  /**
   * Add a cursor to the collection.
   *
   * @param x The x coordinate, from -128 to 127.
   * @param y The y coordinate, from -128 to 127.
   * @param direction The facing of the cursor, from 0 to 15.
   * @param type The type (color/style) of the map cursor.
   * @param visible Whether the cursor is visible.
   * @param caption banner caption
   * @return The newly added MapCursor.
   * @deprecated Magic value
  */
  addCursor(x: number, y: number, direction: number, type: number, visible: boolean, caption: string | null): MapCursor;
  /**
   * Add a cursor to the collection.
   *
   * @param x The x coordinate, from -128 to 127.
   * @param y The y coordinate, from -128 to 127.
   * @param direction The facing of the cursor, from 0 to 15.
   * @param type The type (color/style) of the map cursor.
   * @param visible Whether the cursor is visible.
   * @param caption banner caption
   * @return The newly added MapCursor.
   * @deprecated Magic value
  */
  addCursor(x: number, y: number, direction: number, type: number, visible: boolean, caption: Component | null): MapCursor;
}
/**
 * Represents the palette that map items use.
 * 
 * These fields are hee base color ranges. Each entry corresponds to four
 * colors of varying shades with values entry to entry + 3.
*/
export class MapPalette {
  /**
   * @deprecated Magic value
  */
  static readonly TRANSPARENT: number;
  /**
   * @deprecated Magic value
  */
  static readonly LIGHT_GREEN: number;
  /**
   * @deprecated Magic value
  */
  static readonly LIGHT_BROWN: number;
  /**
   * @deprecated Magic value
  */
  static readonly GRAY_1: number;
  /**
   * @deprecated Magic value
  */
  static readonly RED: number;
  /**
   * @deprecated Magic value
  */
  static readonly PALE_BLUE: number;
  /**
   * @deprecated Magic value
  */
  static readonly GRAY_2: number;
  /**
   * @deprecated Magic value
  */
  static readonly DARK_GREEN: number;
  /**
   * @deprecated Magic value
  */
  static readonly WHITE: number;
  /**
   * @deprecated Magic value
  */
  static readonly LIGHT_GRAY: number;
  /**
   * @deprecated Magic value
  */
  static readonly BROWN: number;
  /**
   * @deprecated Magic value
  */
  static readonly DARK_GRAY: number;
  /**
   * @deprecated Magic value
  */
  static readonly BLUE: number;
  /**
   * @deprecated Magic value
  */
  static readonly DARK_BROWN: number;
  /**
   * Resize an image to 128x128.
   *
   * @param image The image to resize.
   * @return The resized image.
  */
  static resizeImage(image: Image | null): BufferedImage;
  /**
   * Convert an Image to a byte[] using the palette.
   *
   * @param image The image to convert.
   * @return A byte[] containing the pixels of the image.
   * @deprecated Magic value
  */
  static imageToBytes(image: Image): number[];
  /**
   * Get the index of the closest matching color in the palette to the given
   * color.
   *
   * @param r The red component of the color.
   * @param b The blue component of the color.
   * @param g The green component of the color.
   * @return The index in the palette.
   * @deprecated Magic value
  */
  static matchColor(r: number, g: number, b: number): number;
  /**
   * Get the index of the closest matching color in the palette to the given
   * color.
   *
   * @param color The Color to match.
   * @return The index in the palette.
   * @deprecated Magic value
  */
  static matchColor(color: Color): number;
  /**
   * Get the value of the given color in the palette.
   *
   * @param index The index in the palette.
   * @return The Color of the palette entry.
   * @deprecated Magic value
  */
  static getColor(index: number): Color;
}
/**
 * Represents a canvas for drawing to a map. Each canvas is associated with a
 * specific {@link MapRenderer} and represents that renderer's layer on the
 * map.
*/
export class MapCanvas {
  /**
   * Get the map this canvas is attached to.
   *
   * @return The MapView this canvas is attached to.
  */
  getMapView(): MapView;
  /**
   * Get the cursor collection associated with this canvas.
   *
   * @return The MapCursorCollection associated with this canvas.
  */
  getCursors(): MapCursorCollection;
  /**
   * Set the cursor collection associated with this canvas. This does not
   * usually need to be called since a MapCursorCollection is already
   * provided.
   *
   * @param cursors The MapCursorCollection to associate with this canvas.
  */
  setCursors(cursors: MapCursorCollection);
  /**
   * Draw a pixel to the canvas.
   *
   * @param x The x coordinate, from 0 to 127.
   * @param y The y coordinate, from 0 to 127.
   * @param color The color. See {@link MapPalette}.
  */
  setPixel(x: number, y: number, color: number): void;
  /**
   * Get a pixel from the canvas.
   *
   * @param x The x coordinate, from 0 to 127.
   * @param y The y coordinate, from 0 to 127.
   * @return The color. See {@link MapPalette}.
  */
  getPixel(x: number, y: number): number;
  /**
   * Get a pixel from the layers below this canvas.
   *
   * @param x The x coordinate, from 0 to 127.
   * @param y The y coordinate, from 0 to 127.
   * @return The color. See {@link MapPalette}.
  */
  getBasePixel(x: number, y: number): number;
  /**
   * Draw an image to the map. The image will be clipped if necessary.
   *
   * @param x The x coordinate of the image.
   * @param y The y coordinate of the image.
   * @param image The Image to draw.
  */
  drawImage(x: number, y: number, image: Image): void;
  /**
   * Render text to the map using fancy formatting. Newline (\n) characters
   * will move down one line and return to the original column, and the text
   * color can be changed using sequences such as "12;", replacing 12 with
   * the palette index of the color (see {@link MapPalette}).
   *
   * @param x The column to start rendering on.
   * @param y The row to start rendering on.
   * @param font The font to use.
   * @param text The formatted text to render.
  */
  drawText(x: number, y: number, font: MapFont, text: string): void;
}
/**
 * Represents the built-in Minecraft font.
*/
export class MinecraftFont extends MapFont {
  /**
   * A static non-malleable MinecraftFont.
  */
  static readonly Font: MinecraftFont;
  /**
   * Initialize a new MinecraftFont.
  */
  constructor();
}
/**
 * Represents a cursor on a map.
*/
export class MapCursor {
  /**
   * Initialize the map cursor.
   *
   * @param x The x coordinate, from -128 to 127.
   * @param y The y coordinate, from -128 to 127.
   * @param direction The facing of the cursor, from 0 to 15.
   * @param type The type (color/style) of the map cursor.
   * @param visible Whether the cursor is visible by default.
   * @deprecated Magic value
  */
  constructor(x: number, y: number, direction: number, type: number, visible: boolean);
  /**
   * Initialize the map cursor.
   *
   * @param x The x coordinate, from -128 to 127.
   * @param y The y coordinate, from -128 to 127.
   * @param direction The facing of the cursor, from 0 to 15.
   * @param type The type (color/style) of the map cursor.
   * @param visible Whether the cursor is visible by default.
  */
  constructor(x: number, y: number, direction: number, type: Type, visible: boolean);
  /**
   * Initialize the map cursor.
   *
   * @param x The x coordinate, from -128 to 127.
   * @param y The y coordinate, from -128 to 127.
   * @param direction The facing of the cursor, from 0 to 15.
   * @param type The type (color/style) of the map cursor.
   * @param visible Whether the cursor is visible by default.
   * @param caption cursor caption
   * @deprecated Magic value. Use {@link #MapCursor(byte, byte, byte, byte, boolean, net.kyori.adventure.text.Component)}
  */
  constructor(x: number, y: number, direction: number, type: number, visible: boolean, caption: string | null);
  /**
   * Initialize the map cursor.
   *
   * @param x The x coordinate, from -128 to 127.
   * @param y The y coordinate, from -128 to 127.
   * @param direction The facing of the cursor, from 0 to 15.
   * @param type The type (color/style) of the map cursor.
   * @param visible Whether the cursor is visible by default.
   * @param caption cursor caption
   * @deprecated Magic value
  */
  constructor(x: number, y: number, direction: number, type: number, visible: boolean, caption: Component | null);
  /**
   * Initialize the map cursor.
   *
   * @param x The x coordinate, from -128 to 127.
   * @param y The y coordinate, from -128 to 127.
   * @param direction The facing of the cursor, from 0 to 15.
   * @param type The type (color/style) of the map cursor.
   * @param visible Whether the cursor is visible by default.
   * @param caption cursor caption
  */
  constructor(x: number, y: number, direction: number, type: Type, visible: boolean, caption: Component | null);
  /**
   * Initialize the map cursor.
   *
   * @param x The x coordinate, from -128 to 127.
   * @param y The y coordinate, from -128 to 127.
   * @param direction The facing of the cursor, from 0 to 15.
   * @param type The type (color/style) of the map cursor.
   * @param visible Whether the cursor is visible by default.
   * @param caption cursor caption
  */
  constructor(x: number, y: number, direction: number, type: Type, visible: boolean, caption: string | null);
  /**
   * Get the X position of this cursor.
   *
   * @return The X coordinate.
  */
  getX(): number;
  /**
   * Get the Y position of this cursor.
   *
   * @return The Y coordinate.
  */
  getY(): number;
  /**
   * Get the direction of this cursor.
   *
   * @return The facing of the cursor, from 0 to 15.
  */
  getDirection(): number;
  /**
   * Get the type of this cursor.
   *
   * @return The type (color/style) of the map cursor.
  */
  getType(): Type;
  /**
   * Get the type of this cursor.
   *
   * @return The type (color/style) of the map cursor.
   * @deprecated Magic value
  */
  getRawType(): number;
  /**
   * Get the visibility status of this cursor.
   *
   * @return True if visible, false otherwise.
  */
  isVisible(): boolean;
  /**
   * Set the X position of this cursor.
   *
   * @param x The X coordinate.
  */
  setX(x: number);
  /**
   * Set the Y position of this cursor.
   *
   * @param y The Y coordinate.
  */
  setY(y: number);
  /**
   * Set the direction of this cursor.
   *
   * @param direction The facing of the cursor, from 0 to 15.
  */
  setDirection(direction: number);
  /**
   * Set the type of this cursor.
   *
   * @param type The type (color/style) of the map cursor.
  */
  setType(type: Type);
  /**
   * Set the type of this cursor.
   *
   * @param type The type (color/style) of the map cursor.
   * @deprecated Magic value
  */
  setRawType(rawType: number);
  /**
   * Set the visibility status of this cursor.
   *
   * @param visible True if visible.
  */
  setVisible(visible: boolean): void;
  /**
   * Gets the caption on this cursor.
   *
   * @return caption
  */
  caption(): Component | null;
  /**
   * Sets the caption on this cursor.
   *
   * @param caption new caption
  */
  caption(caption: Component | null): void;
  /**
   * Sets the caption on this cursor.
   *
   * @param caption new caption
   * @deprecated in favour of {@link #caption(net.kyori.adventure.text.Component)}
  */
  setCaption(caption: string | null): void;
}

}
declare module 'org.bukkit.entity.Skeleton' {
import { Enum } from 'java.lang';
/**
 * A legacy enum that defines the different variances of skeleton-like
 * entities on the server.
 *
 * @deprecated classes are different types. This interface only remains in
 *     the Skeleton interface to preserve backwards compatibility.
*/
export class SkeletonType extends Enum<SkeletonType> {
  /**
   * Standard skeleton type.
  */
  static readonly NORMAL: SkeletonType;
  /**
   * Wither skeleton. Generally found in Nether fortresses.
  */
  static readonly WITHER: SkeletonType;
  /**
   * Stray skeleton. Generally found in ice biomes. Shoots tipped arrows.
  */
  static readonly STRAY: SkeletonType;
  static valueOf(name: string): SkeletonType;
  static values(): SkeletonType[];
}

}
declare module 'org.bukkit.event.entity.EntityRegainHealthEvent' {
import { Enum } from 'java.lang';
/**
 * An enum to specify the type of health regaining that is occurring
*/
export class RegainReason extends Enum<RegainReason> {
  /**
   * When a player regains health from regenerating due to Peaceful mode
   * (difficulty=0)
  */
  static readonly REGEN: RegainReason;
  /**
   * When a player regains health from regenerating due to their hunger
   * being satisfied
  */
  static readonly SATIATED: RegainReason;
  /**
   * When a player regains health from eating consumables
  */
  static readonly EATING: RegainReason;
  /**
   * When an ender dragon regains health from an ender crystal
  */
  static readonly ENDER_CRYSTAL: RegainReason;
  /**
   * When a player is healed by a potion or spell
  */
  static readonly MAGIC: RegainReason;
  /**
   * When a player is healed over time by a potion or spell
  */
  static readonly MAGIC_REGEN: RegainReason;
  /**
   * When a wither is filling its health during spawning
  */
  static readonly WITHER_SPAWN: RegainReason;
  /**
   * When an entity is damaged by the Wither potion effect
  */
  static readonly WITHER: RegainReason;
  /**
   * Any other reason not covered by the reasons above
  */
  static readonly CUSTOM: RegainReason;
  static valueOf(name: string): RegainReason;
  static values(): RegainReason[];
}

}
declare module 'org.bukkit.metadata.LazyMetadataValue' {
import { Enum } from 'java.lang';
/**
 * Describes possible caching strategies for metadata.
*/
export class CacheStrategy extends Enum<CacheStrategy> {
  /**
   * Once the metadata value has been evaluated, do not re-evaluate the
   * value until it is manually invalidated.
  */
  static readonly CACHE_AFTER_FIRST_EVAL: CacheStrategy;
  /**
   * Re-evaluate the metadata item every time it is requested
  */
  static readonly NEVER_CACHE: CacheStrategy;
  /**
   * Once the metadata value has been evaluated, do not re-evaluate the
   * value in spite of manual invalidation.
  */
  static readonly CACHE_ETERNALLY: CacheStrategy;
  static valueOf(name: string): CacheStrategy;
  static values(): CacheStrategy[];
}

}
declare module 'org.bukkit.block.data.type.Slab' {
import { Enum } from 'java.lang';
/**
 * The type of the slab.
*/
export class Type extends Enum<Type> {
  /**
   * The slab occupies the upper y half of the block.
  */
  static readonly TOP: Type;
  /**
   * The slab occupies the lower y half of the block.
  */
  static readonly BOTTOM: Type;
  /**
   * The slab occupies the entire block.
  */
  static readonly DOUBLE: Type;
  static valueOf(name: string): Type;
  static values(): Type[];
}

}
declare module 'org.bukkit.entity.ArmorStand' {
import { Enum } from 'java.lang';
/**
 * Represents types of locking mechanisms for ArmorStand equipment.
*/
export class LockType extends Enum<LockType> {
  /**
   * Prevents adding or changing the respective equipment - players cannot
   * replace the empty slot with a new item or swap the items between
   * themselves and the ArmorStand.
  */
  static readonly ADDING_OR_CHANGING: LockType;
  /**
   * Prevents removing or changing the respective equipment - players
   * cannot take an item from the slot or swap the items between
   * themselves and the ArmorStand.
  */
  static readonly REMOVING_OR_CHANGING: LockType;
  /**
   * Prevents adding the respective equipment - players cannot replace the
   * empty slot with a new item, but can swap items between themselves and
   * the ArmorStand.
  */
  static readonly ADDING: LockType;
  static valueOf(name: string): LockType;
  static values(): LockType[];
}

}
declare module 'org.bukkit.attribute.AttributeModifier' {
import { Enum } from 'java.lang';
/**
 * Enumerable operation to be applied.
*/
export class Operation extends Enum<Operation> {
  /**
   * Adds (or subtracts) the specified amount to the base value.
  */
  static readonly ADD_NUMBER: Operation;
  /**
   * Adds this scalar of amount to the base value.
  */
  static readonly ADD_SCALAR: Operation;
  /**
   * Multiply amount by this value, after adding 1 to it.
  */
  static readonly MULTIPLY_SCALAR_1: Operation;
  static valueOf(name: string): Operation;
  static values(): Operation[];
}

}
declare module 'org.bukkit.help.HelpTopicComparator' {
import { Comparator } from 'java.util';
export class TopicNameComparator extends Comparator<string> {
  compare(lhs: string, rhs: string): number;
}

}
declare module 'org.bukkit.Statistic' {
import { Enum } from 'java.lang';
/**
 * The type of statistic.
 *
*/
export class Type extends Enum<Type> {
  /**
   * Statistics of this type do not require a qualifier.
  */
  static readonly UNTYPED: Type;
  /**
   * Statistics of this type require an Item Material qualifier.
  */
  static readonly ITEM: Type;
  /**
   * Statistics of this type require a Block Material qualifier.
  */
  static readonly BLOCK: Type;
  /**
   * Statistics of this type require an EntityType qualifier.
  */
  static readonly ENTITY: Type;
  static valueOf(name: string): Type;
  static values(): Type[];
}

}
declare module 'org.bukkit.event.player.PlayerBedEnterEvent' {
import { Enum } from 'java.lang';
/**
 * Represents the default possible outcomes of this event.
*/
export class BedEnterResult extends Enum<BedEnterResult> {
  /**
   * The player will enter the bed.
  */
  static readonly OK: BedEnterResult;
  /**
   * The world doesn't allow sleeping or saving the spawn point (eg,
   * Nether, The End or Custom Worlds). This is based on
   * {@link World#isBedWorks()} and {@link World#isNatural()}.
   *
   * Entering the bed is prevented and if {@link World#isBedWorks()} is
   * false then the bed explodes.
  */
  static readonly NOT_POSSIBLE_HERE: BedEnterResult;
  /**
   * Entering the bed is prevented due to it not being night nor
   * thundering currently.
   * 
   * If the event is forcefully allowed during daytime, the player will
   * enter the bed (and set its bed location), but might get immediately
   * thrown out again.
  */
  static readonly NOT_POSSIBLE_NOW: BedEnterResult;
  /**
   * Entering the bed is prevented due to the player being too far away.
  */
  static readonly TOO_FAR_AWAY: BedEnterResult;
  /**
   * Bed was obstructed.
  */
  static readonly OBSTRUCTED: BedEnterResult;
  /**
   * Entering the bed is prevented due to there being monsters nearby.
  */
  static readonly NOT_SAFE: BedEnterResult;
  /**
   * Entering the bed is prevented due to there being some other problem.
  */
  static readonly OTHER_PROBLEM: BedEnterResult;
  static valueOf(name: string): BedEnterResult;
  static values(): BedEnterResult[];
}

}
declare module 'org.bukkit.structure' {
import { Random, List, Map } from 'java.util';
import { BlockState } from 'org.bukkit.block';
import { InputStream, OutputStream, File } from 'java.io';
import { StructureRotation, Mirror } from 'org.bukkit.block.structure';
import { BlockVector } from 'org.bukkit.util';
import { PersistentDataHolder } from 'org.bukkit.persistence';
import { NamespacedKey, RegionAccessor, Location } from 'org.bukkit';
import { Entity } from 'org.bukkit.entity';
/**
 * Represents a structure.
 * 
 * A structure is a mutable template of captured blocks and entities that can be
 * copied back into the world. The {@link StructureManager}, retrieved via
 * {@link org.bukkit.Server#getStructureManager()}, allows you to create new
 * structures, load existing structures, and save structures.
 * 
 * In order for a structure to be usable by structure blocks, it needs to be
 * null {@link StructureManager#registerStructure(org.bukkit.NamespacedKey, Structure)
 * registered} with the {@link StructureManager}, or located in the primary
 * world folder, a DataPack, or the server's own default resources, so that the
 * StructureManager can find it.
*/
export class Structure extends PersistentDataHolder {
  /**
   * Gets the current size of the structure.
   * 
   * The size of the structure may not be fixed.
   *
   * @return A new vector that represents the size of the structure along each
   * axis.
  */
  getSize(): BlockVector;
  /**
   * Gets a list of available block palettes.
   *
   * @return a list of available variants of this structure.
  */
  getPalettes(): Palette[];
  /**
   * Gets the number of palettes in this structure.
   *
   * @return The number of palettes in this structure
  */
  getPaletteCount(): number;
  /**
   * Gets a list of entities that have been included in the Structure.
   *
   * The entity positions are offsets relative to the structure's position
   * that is provided once the structure is placed into the world.
   *
   * @return a list of Entities included in the Structure.
  */
  getEntities(): Entity[];
  /**
   * Gets the number of entities in this structure.
   *
   * @return The number of entities in this structure
  */
  getEntityCount(): number;
  /**
   * Place a structure in the world.
   *
   * @param location The location to place the structure at.
   * @param includeEntities If the entities present in the structure should be
   * spawned.
   * @param structureRotation The rotation of the structure.
   * @param mirror The mirror settings of the structure.
   * @param palette The palette index of the structure to use, starting at
   * `0`, or `-1` to pick a random palette.
   * @param integrity Determines how damaged the building should look by
   * randomly skipping blocks to place. This value can range from 0 to 1. With
   * 0 removing all blocks and 1 spawning the structure in pristine condition.
   * @param random The randomizer used for setting the structure's
   * {@link org.bukkit.loot.LootTable}s and integrity.
  */
  place(location: Location, includeEntities: boolean, structureRotation: StructureRotation, mirror: Mirror, palette: number, integrity: number, random: Random): void;
  /**
   * Place a structure in the world.
   *
   * @param regionAccessor The world to place the structure in.
   * @param location The location to place the structure at.
   * @param includeEntities If the entities present in the structure should be
   * spawned.
   * @param structureRotation The rotation of the structure.
   * @param mirror The mirror settings of the structure.
   * @param palette The palette index of the structure to use, starting at
   * `0`, or `-1` to pick a random palette.
   * @param integrity Determines how damaged the building should look by
   * randomly skipping blocks to place. This value can range from 0 to 1. With
   * 0 removing all blocks and 1 spawning the structure in pristine condition.
   * @param random The randomizer used for setting the structure's
   * {@link org.bukkit.loot.LootTable}s and integrity.
  */
  place(regionAccessor: RegionAccessor, location: BlockVector, includeEntities: boolean, structureRotation: StructureRotation, mirror: Mirror, palette: number, integrity: number, random: Random): void;
  /**
   * Fills the structure from an area in a world. The origin and size will be
   * calculated automatically from the two corners provided.
   * 
   * Be careful as this will override the current data of the structure.
   * 
   * Be aware that this method allows for creating structures larger than the
   * 48x48x48 size that Minecraft's Structure blocks support. Any structures
   * saved this way can not be loaded by using a structure block. Using the
   * API however will still work.
   *
   * @param corner1 A corner of the structure.
   * @param corner2 The corner opposite from corner1.
   * @param includeEntities true if entities should be included in the saved
   * structure.
  */
  fill(corner1: Location, corner2: Location, includeEntities: boolean): void;
  /**
   * Fills the Structure from an area in a world, starting at the specified
   * origin and extending in each axis according to the specified size vector.
   * 
   * Be careful as this will override the current data of the structure.
   * 
   * Be aware that this method allows for saving structures larger than the
   * 48x48x48 size that Minecraft's Structure blocks support. Any structures
   * saved this way can not be loaded by using a structure block. Using the
   * API however will still work.
   *
   * @param origin The origin of the structure.
   * @param size The size of the structure, must be at least 1x1x1.
   * @param includeEntities true if entities should be included in the saved
   * structure.
   * @throws IllegalArgumentException Thrown if size is smaller than 1x1x1
  */
  fill(origin: Location, size: BlockVector, includeEntities: boolean): void;
}
/**
 * Represent a variation of a structure.
 *
 * Most structures, like the ones generated with structure blocks, only have a
 * single variant.
*/
export class Palette {
  /**
   * Gets a copy of the blocks this Palette is made of.
   *
   * The {@link BlockState#getLocation() positions} of the returned block
   * states are offsets relative to the structure's position that is provided
   * once the structure is placed into the world.
   *
   * @return The blocks in this palette
  */
  getBlocks(): BlockState[];
  /**
   * Gets the number of blocks stored in this palette.
   *
   * @return The number of blocks in this palette
  */
  getBlockCount(): number;
}
export class StructureManager {
  /**
   * Gets the currently registered structures.
   * 
   * These are the currently loaded structures that the StructureManager is
   * aware of. When a structure block refers to a structure, these structures
   * are checked first. If the specified structure is not found among the
   * currently registered structures, the StructureManager may dynamically
   * read the structure from the primary world folder, DataPacks, or the
   * server's own resources. Structures can be registered via {@link
   * #registerStructure(NamespacedKey, Structure)}
   *
   * @return an unmodifiable shallow copy of the currently registered
   * structures
  */
  getStructures(): Map<NamespacedKey, Structure>;
  /**
   * Gets a registered Structure.
   *
   * @param structureKey The key for which to get the structure
   * @return The structure that belongs to the structureKey or
   * null if there is none registered for that key.
  */
  getStructure(structureKey: NamespacedKey): Structure | null;
  /**
   * Registers the given structure. See {@link #getStructures()}.
   *
   * @param structureKey The key for which to register the structure
   * @param structure The structure to register
   * @return The structure for the specified key, or null if the
   * structure could not be found.
  */
  registerStructure(structureKey: NamespacedKey, structure: Structure): Structure | null;
  /**
   * Unregisters a structure. Unregisters the specified structure. If the
   * structure still exists in the primary world folder, a DataPack, or is
   * part of the server's own resources, it may be loaded and registered again
   * when it is requested by a plugin or the server itself.
   *
   * @param structureKey The key for which to save the structure for
   * @return The structure that was registered for that key or
   * null if there was none
  */
  unregisterStructure(structureKey: NamespacedKey): Structure | null;
  /**
   * Loads a structure for the specified key and optionally {@link
   * #registerStructure(NamespacedKey, Structure) registers} it.
   * 
   * This will first check the already loaded {@link #getStructures()
   * registered structures}, and otherwise load the structure from the primary
   * world folder, DataPacks, and the server's own resources (in this order).
   * 
   * When loading the structure from the primary world folder, the given key
   * is translated to a file as specified by
   * {@link #getStructureFile(NamespacedKey)}.
   *
   * @param structureKey The key for which to load the structure
   * @param register true to register the loaded structure.
   * @return The structure, or null if no structure was found for
   * the specified key
  */
  loadStructure(structureKey: NamespacedKey, register: boolean): Structure | null;
  /**
   * Loads the structure for the specified key and automatically registers it.
   * See {@link #loadStructure(NamespacedKey, boolean)}.
   *
   * @param structureKey The key for which to load the structure
   * @return The structure for the specified key, or null if the
   * structure could not be found.
  */
  loadStructure(structureKey: NamespacedKey): Structure | null;
  /**
   * Saves the currently {@link #getStructures() registered structure} for the
   * specified {@link NamespacedKey key} to the primary world folder as
   * specified by {#getStructureFile(NamespacedKey}.
   *
   * @param structureKey The key for which to save the structure for
  */
  saveStructure(structureKey: NamespacedKey): void;
  /**
   * Saves a structure with a given key to the primary world folder.
   *
   * @param structureKey The key for which to save the structure for
   * @param structure The structure to save for this structureKey
  */
  saveStructure(structureKey: NamespacedKey, structure: Structure): void;
  /**
   * Unregisters the specified structure and deletes its {@link
   * #getStructureFile(NamespacedKey) structure file} from the primary world
   * folder. Note that this method cannot be used to delete vanilla Minecraft
   * structures, or structures from DataPacks. Unregistering these structures
   * will however work fine.
   *
   * @param structureKey The key of the structure to remove
   * @throws IOException If the file could not be removed for some reason.
  */
  deleteStructure(structureKey: NamespacedKey): void;
  /**
   * Deletes the {@link #getStructureFile(NamespacedKey) structure file} for
   * the specified structure from the primary world folder. Note that this
   * method cannot be used to delete vanilla Minecraft structures, or
   * structures from DataPacks. Unregistering these structures will however
   * work fine.
   *
   * @param structureKey The key of the structure to remove
   * @param unregister Whether to also unregister the specified structure if
   * it is currently loaded.
   * @throws IOException If the file could not be removed for some reason.
  */
  deleteStructure(structureKey: NamespacedKey, unregister: boolean): void;
  /**
   * Gets the location where a structure file would exist in the primary world
   * directory based on the NamespacedKey using the format
   * world/generated/{NAMESPACE}/structures/{KEY}.nbt. This method will always
   * return a file, even if none exists at the moment.
   *
   * @param structureKey The key to build the filepath from.
   * @return The location where a file with this key would be.
  */
  getStructureFile(structureKey: NamespacedKey): File;
  /**
   * Reads a Structure from disk.
   *
   * @param file The file of the structure
   * @return The read structure
   * @throws IOException when the given file can not be read from
  */
  loadStructure(file: File): Structure;
  /**
   * Reads a Structure from a stream.
   *
   * @param inputStream The file of the structure
   * @return The read Structure
  */
  loadStructure(inputStream: InputStream): Structure;
  /**
   * Save a structure to a file. This will overwrite a file if it already
   * exists.
   *
   * @param file the target to save to.
   * @param structure the Structure to save.
   * @throws IOException when the given file can not be written to.
  */
  saveStructure(file: File, structure: Structure): void;
  /**
   * Save a structure to a stream.
   *
   * @param outputStream the stream to write to.
   * @param structure the Structure to save.
   * @throws IOException when the given file can not be written to.
  */
  saveStructure(outputStream: OutputStream, structure: Structure): void;
  /**
   * Creates a new empty structure.
   *
   * @return an empty structure.
  */
  createStructure(): Structure;
  /**
   * Creates a copy of this structure.
   *
   * @param structure The structure to copy
   * @return a copy of the structure
  */
  copy(structure: Structure): Structure;
}

}
declare module 'org.bukkit.event.player.PlayerFishEvent' {
import { Enum } from 'java.lang';
/**
 * An enum to specify the state of the fishing
*/
export class State extends Enum<State> {
  /**
   * When a player is fishing, ie casting the line out.
  */
  static readonly FISHING: State;
  /**
   * When a player has successfully caught a fish and is reeling it in. In
   * this instance, a "fish" is any item retrieved from water as a result
   * of fishing, ie an item, but not necessarily a fish.
  */
  static readonly CAUGHT_FISH: State;
  /**
   * When a player has successfully caught an entity. This refers to any
   * already spawned entity in the world that has been hooked directly by
   * the rod.
  */
  static readonly CAUGHT_ENTITY: State;
  /**
   * When a bobber is stuck in the ground.
  */
  static readonly IN_GROUND: State;
  /**
   * When a player fails to catch a bite while fishing usually due to
   * poor timing.
  */
  static readonly FAILED_ATTEMPT: State;
  /**
   * When a player reels in their hook without receiving any bites.
  */
  static readonly REEL_IN: State;
  /**
   * Called when there is a bite on the hook and it is ready to be reeled
   * in.
  */
  static readonly BITE: State;
  static valueOf(name: string): State;
  static values(): State[];
}

}
declare module 'org.bukkit.conversations.Conversation' {
import { Enum } from 'java.lang';
export class ConversationState extends Enum<ConversationState> {
  static readonly UNSTARTED: ConversationState;
  static readonly STARTED: ConversationState;
  static readonly ABANDONED: ConversationState;
  static valueOf(name: string): ConversationState;
  static values(): ConversationState[];
}

}
declare module 'org.bukkit.block.banner' {
import { Map } from 'java.util';
import { Enum } from 'java.lang';
import { ConfigurationSerializable } from 'org.bukkit.configuration.serialization';
import { DyeColor } from 'org.bukkit';
export class PatternType extends Enum<PatternType> {
  static readonly BASE: PatternType;
  static readonly SQUARE_BOTTOM_LEFT: PatternType;
  static readonly SQUARE_BOTTOM_RIGHT: PatternType;
  static readonly SQUARE_TOP_LEFT: PatternType;
  static readonly SQUARE_TOP_RIGHT: PatternType;
  static readonly STRIPE_BOTTOM: PatternType;
  static readonly STRIPE_TOP: PatternType;
  static readonly STRIPE_LEFT: PatternType;
  static readonly STRIPE_RIGHT: PatternType;
  static readonly STRIPE_CENTER: PatternType;
  static readonly STRIPE_MIDDLE: PatternType;
  static readonly STRIPE_DOWNRIGHT: PatternType;
  static readonly STRIPE_DOWNLEFT: PatternType;
  static readonly STRIPE_SMALL: PatternType;
  static readonly CROSS: PatternType;
  static readonly STRAIGHT_CROSS: PatternType;
  static readonly TRIANGLE_BOTTOM: PatternType;
  static readonly TRIANGLE_TOP: PatternType;
  static readonly TRIANGLES_BOTTOM: PatternType;
  static readonly TRIANGLES_TOP: PatternType;
  static readonly DIAGONAL_LEFT: PatternType;
  static readonly DIAGONAL_RIGHT: PatternType;
  static readonly DIAGONAL_LEFT_MIRROR: PatternType;
  static readonly DIAGONAL_RIGHT_MIRROR: PatternType;
  static readonly CIRCLE_MIDDLE: PatternType;
  static readonly RHOMBUS_MIDDLE: PatternType;
  static readonly HALF_VERTICAL: PatternType;
  static readonly HALF_HORIZONTAL: PatternType;
  static readonly HALF_VERTICAL_MIRROR: PatternType;
  static readonly HALF_HORIZONTAL_MIRROR: PatternType;
  static readonly BORDER: PatternType;
  static readonly CURLY_BORDER: PatternType;
  static readonly CREEPER: PatternType;
  static readonly GRADIENT: PatternType;
  static readonly GRADIENT_UP: PatternType;
  static readonly BRICKS: PatternType;
  static readonly SKULL: PatternType;
  static readonly FLOWER: PatternType;
  static readonly MOJANG: PatternType;
  static readonly GLOBE: PatternType;
  static readonly PIGLIN: PatternType;
  static valueOf(name: string): PatternType;
  static values(): PatternType[];
  /**
   * Returns the identifier used to represent
   * this pattern type
   *
   * @return the pattern's identifier
  */
  getIdentifier(): string;
  /**
   * Returns the pattern type which matches the passed
   * identifier or null if no matches are found
   *
   * @param identifier the identifier
   * @return the matched pattern type or null
  */
  static getByIdentifier(identifier: string | null): PatternType | null;
}
export class Pattern extends ConfigurationSerializable {
  /**
   * Creates a new pattern from the specified color and
   * pattern type
   *
   * @param color   the pattern color
   * @param pattern the pattern type
  */
  constructor(color: DyeColor, pattern: PatternType);
  /**
   * Constructor for deserialization.
   *
   * @param map the map to deserialize from
  */
  constructor(map: Map<string, any>);
  /**
   * Creates a Map representation of this class.
   * 
   * This class must provide a method to restore this class, as defined in
   * the {@link ConfigurationSerializable} interface javadocs.
   *
   * @return Map containing the current state of this class
  */
  serialize(): Map<string, any>;
  /**
   * Returns the color of the pattern
   *
   * @return the color of the pattern
  */
  getColor(): DyeColor;
  /**
   * Returns the type of pattern
   *
   * @return the pattern type
  */
  getPattern(): PatternType;
  hashCode(): number;
  equals(obj: any): boolean;
}

}
declare module 'org.bukkit.block' {
import { Component } from 'net.kyori.adventure.text';
import { LootableBlockInventory } from 'com.destroystokyo.paper.loottable';
import { CommandBlockHolder } from 'io.papermc.paper.command';
import { Collection, List, Map } from 'java.util';
import { Metadatable } from 'org.bukkit.metadata';
import { BlockProjectileSource } from 'org.bukkit.projectiles';
import { PlayerProfile as org_bukkit_profile_PlayerProfile } from 'org.bukkit.profile';
import { BlockSoundGroup } from 'com.destroystokyo.paper.block';
import { Nameable, SoundGroup, NamespacedKey, OfflinePlayer, Material, SkullType, World, Chunk, DyeColor, FluidCollisionMode, Location } from 'org.bukkit';
import { DoubleChestInventory, BlockInventoryHolder, FurnaceInventory, CookingRecipe, BrewerInventory, ItemStack, InventoryHolder, Inventory } from 'org.bukkit.inventory';
import { PotionEffect, PotionEffectType } from 'org.bukkit.potion';
import { Pattern } from 'org.bukkit.block.banner';
import { Enum } from 'java.lang';
import { Lootable } from 'org.bukkit.loot';
import { Colorable, MaterialData } from 'org.bukkit.material';
import { StructureRotation, UsageMode, Mirror } from 'org.bukkit.block.structure';
import { VoxelShape, BoundingBox, RayTraceResult, BlockVector, Vector } from 'org.bukkit.util';
import { BlockData } from 'org.bukkit.block.data';
import { PlayerProfile } from 'com.destroystokyo.paper.profile';
import { PersistentDataHolder, PersistentDataContainer } from 'org.bukkit.persistence';
import { Translatable } from 'net.kyori.adventure.translation';
import { LivingEntity, EntityType, Entity, Player, Bee } from 'org.bukkit.entity';
/**
 * Represents a captured state of a (possibly inverted) daylight detector.
*/
export class DaylightDetector extends TileState {

}
/**
 * Represents a captured state of a jigsaw.
*/
export class Jigsaw extends TileState {

}
/**
 * Represents a captured state of either a SignPost or a WallSign.
*/
export class Sign extends TileState {
  /**
   * Gets all the lines of text currently on this sign.
   *
   * @return Array of Strings containing each line of text
  */
  lines(): Component[];
  /**
   * Gets the line of text at the specified index.
   * 
   * For example, getLine(0) will return the first line of text.
   *
   * @param index Line number to get the text from, starting at 0
   * @throws IndexOutOfBoundsException Thrown when the line does not exist
   * @return Text on the given line
  */
  line(index: number): Component;
  /**
   * Sets the line of text at the specified index.
   * 
   * For example, setLine(0, "Line One") will set the first line of text to
   * "Line One".
   *
   * @param index Line number to set the text at, starting from 0
   * @param line New text to set at the specified index
   * @throws IndexOutOfBoundsException If the index is out of the range 0..3
  */
  line(index: number, line: Component): void;
  /**
   * Gets the line of text at the specified index.
   * 
   * For example, getLine(0) will return the first line of text.
   *
   * @param index Line number to get the text from, starting at 0
   * @return Text on the given line
   * @throws IndexOutOfBoundsException Thrown when the line does not exist
   * @deprecated in favour of {@link #line(int)}
  */
  getLine(index: number): string;
  /**
   * Sets the line of text at the specified index.
   * 
   * For example, setLine(0, "Line One") will set the first line of text to
   * "Line One".
   *
   * @param index Line number to set the text at, starting from 0
   * @param line New text to set at the specified index
   * @throws IndexOutOfBoundsException If the index is out of the range 0..3
   * @deprecated in favour of {@link #line(int, net.kyori.adventure.text.Component)}
  */
  setLine(index: number, line: string): void;
  /**
   * Marks whether this sign can be edited by players.
   * 
   * This is a special value, which is not persisted. It should only be set if
   * a placed sign is manipulated during the BlockPlaceEvent. Behaviour
   * outside of this event is undefined.
   *
   * @return if this sign is currently editable
  */
  isEditable(): boolean;
  /**
   * Marks whether this sign can be edited by players.
   * 
   * This is a special value, which is not persisted. It should only be set if
   * a placed sign is manipulated during the BlockPlaceEvent. Behaviour
   * outside of this event is undefined.
   *
   * @param editable if this sign is currently editable
  */
  setEditable(editable: boolean): void;
  /**
   * Gets whether this sign has glowing text.
   *
   * @return if this sign has glowing text
  */
  isGlowingText(): boolean;
  /**
   * Sets whether this sign has glowing text.
   *
   * @param glowing if this sign has glowing text
  */
  setGlowingText(glowing: boolean): void;
}
export interface Sign extends TileState, Colorable {}
/**
 * Represents a captured state of a sculk sensor
*/
export class SculkSensor extends TileState {
  /**
   * Gets the last vibration frequency of this sensor.
   *
   * Different activities detected by the sensor will produce different
   * frequencies and dictate the output of connected comparators.
   *
   * @return frequency between 0-15.
  */
  getLastVibrationFrequency(): number;
  /**
   * Sets the last vibration frequency of this sensor.
   *
   * Different activities detected by the sensor will produce different
   * frequencies and dictate the output of connected comparators.
   *
   * @param lastVibrationFrequency frequency between 0-15.
  */
  setLastVibrationFrequency(lastVibrationFrequency: number);
  /**
   * Gets the range this sensor listens to events at.
   *
   * @return the range (defaults to 8)
  */
  getListenerRange(): number;
  /**
   * Sets the range this sensor will listen to events from.
   *
   * @param range the range (must be greater than 0)
  */
  setListenerRange(listenerRange: number);
}
/**
 * Represents a block (usually a container) that may be locked. When a lock is
 * active an item with a name corresponding to the key will be required to open
 * this block.
*/
export class Lockable {
  /**
   * Checks if the container has a valid (non empty) key.
   *
   * @return true if the key is valid.
  */
  isLocked(): boolean;
  /**
   * Gets the key needed to access the container.
   *
   * @return the key needed.
  */
  getLock(): string;
  /**
   * Sets the key required to access this container. Set to null (or empty
   * string) to remove key.
   *
   * @param key the key required to access the container.
  */
  setLock(lock: string | null);
}
/**
 * Represents a captured state of a ShulkerBox.
*/
export class ShulkerBox extends Container {
  /**
   * Get the {@link DyeColor} corresponding to this ShulkerBox
   *
   * @return the {@link DyeColor} of this ShulkerBox, or null if default
  */
  getColor(): DyeColor | null;
}
export interface ShulkerBox extends Container, LootableBlockInventory, Lidded {}
export class EnderChest extends TileState {

}
export interface EnderChest extends TileState, Lidded {}
/**
 * Represents a captured state of a skull block.
*/
export class Skull extends TileState {
  /**
   * Checks to see if the skull has an owner
   *
   * @return true if the skull has an owner
  */
  hasOwner(): boolean;
  /**
   * Gets the owner of the skull, if one exists
   *
   * @return the owner of the skull or null if the skull does not have an owner
   * @deprecated See {@link #getOwningPlayer()}.
  */
  getOwner(): string | null;
  /**
   * Sets the owner of the skull
   * 
   * Involves a potentially blocking web request to acquire the profile data for
   * the provided name.
   *
   * @param name the new owner of the skull
   * @return true if the owner was successfully set
   * @deprecated see {@link #setOwningPlayer(org.bukkit.OfflinePlayer)}.
  */
  setOwner(owner: string | null);
  /**
   * Get the player which owns the skull. This player may appear as the
   * texture depending on skull type.
   *
   * @return owning player
  */
  getOwningPlayer(): OfflinePlayer | null;
  /**
   * Set the player which owns the skull. This player may appear as the
   * texture depending on skull type.
   *
   * @param player the owning player
  */
  setOwningPlayer(owningPlayer: OfflinePlayer);
  /**
   * Sets this skull to use the supplied Player Profile, which can include textures already prefilled.
   * @param profile The profile to set this Skull to use, may not be null
  */
  setPlayerProfile(playerProfile: PlayerProfile);
  /**
   * If the skull has an owner, per {@link #hasOwner()}, return the owners {@link com.destroystokyo.paper.profile.PlayerProfile}
   * @return The profile of the owner, if set
  */
  getPlayerProfile(): PlayerProfile | null;
  /**
   * Gets the profile of the player who owns the skull. This player profile
   * may appear as the texture depending on skull type.
   *
   * @return the profile of the owning player
  */
  getOwnerProfile(): org_bukkit_profile_PlayerProfile | null;
  /**
   * Sets the profile of the player who owns the skull. This player profile
   * may appear as the texture depending on skull type.
   * 
   * The profile must contain both a unique id and a skin texture. If either
   * of these is missing, the profile must contain a name by which the server
   * will then attempt to look up the unique id and skin texture.
   *
   * @param profile the profile of the owning player
   * @throws IllegalArgumentException if the profile does not contain the
   * necessary information
  */
  setOwnerProfile(ownerProfile: org_bukkit_profile_PlayerProfile | null);
  /**
   * Gets the rotation of the skull in the world (or facing direction if this
   * is a wall mounted skull).
   *
   * @return the rotation of the skull
   * @deprecated use {@link BlockData}
  */
  getRotation(): BlockFace;
  /**
   * Sets the rotation of the skull in the world (or facing direction if this
   * is a wall mounted skull).
   *
   * @param rotation the rotation of the skull
   * @deprecated use {@link BlockData}
  */
  setRotation(rotation: BlockFace);
  /**
   * Gets the type of skull
   *
   * @return the type of skull
   * @deprecated check {@link Material} instead
  */
  getSkullType(): SkullType;
  /**
   * Sets the type of skull
   *
   * @param skullType the type of skull
   * @deprecated check {@link Material} instead
  */
  setSkullType(skullType: SkullType);
}
/**
 * Represents a block. This is a live object, and only one Block may exist for
 * any given location in a world. The state of the block may change
 * concurrently to your own handling of it; use block.getState() to get a
 * snapshot state of a block which will not be modified.
 *
 * 
 * Note that parts of this class which require access to the world at large
 * (i.e. lighting and power) may not be able to be safely accessed during world
 * generation when used in cases like BlockPhysicsEvent!!!!
*/
export class Block extends Metadatable {
  /**
   * Gets the metadata for this block
   *
   * @return block specific metadata
   * @deprecated Magic value
  */
  getData(): number;
  /**
   * Gets the complete block data for this block
   *
   * @return block specific data
  */
  getBlockData(): BlockData;
  /**
   * Gets the block at the given offsets
   *
   * @param modX X-coordinate offset
   * @param modY Y-coordinate offset
   * @param modZ Z-coordinate offset
   * @return Block at the given offsets
  */
  getRelative(modX: number, modY: number, modZ: number): Block;
  /**
   * Gets the block at the given face
   * 
   * This method is equal to getRelative(face, 1)
   *
   * @param face Face of this block to return
   * @return Block at the given face
   * @see #getRelative(BlockFace, int)
  */
  getRelative(face: BlockFace): Block;
  /**
   * Gets the block at the given distance of the given face
   * 
   * For example, the following method places water at 100,102,100; two
   * blocks above 100,100,100.
   *
   *      * Block block = world.getBlockAt(100, 100, 100);
   * Block shower = block.getRelative(BlockFace.UP, 2);
   * shower.setType(Material.WATER);
   * 
   *
   * @param face Face of this block to return
   * @param distance Distance to get the block at
   * @return Block at the given face
  */
  getRelative(face: BlockFace, distance: number): Block;
  /**
   * Gets the type of this block
   *
   * @return block type
  */
  getType(): Material;
  /**
   * Gets the light level between 0-15
   *
   * @return light level
  */
  getLightLevel(): number;
  /**
   * Get the amount of light at this block from the sky.
   * 
   * Any light given from other sources (such as blocks like torches) will
   * be ignored.
   *
   * @return Sky light level
  */
  getLightFromSky(): number;
  /**
   * Get the amount of light at this block from nearby blocks.
   * 
   * Any light given from other sources (such as the sun) will be ignored.
   *
   * @return Block light level
  */
  getLightFromBlocks(): number;
  /**
   * Gets the world which contains this Block
   *
   * @return World containing this block
  */
  getWorld(): World;
  /**
   * Gets the x-coordinate of this block
   *
   * @return x-coordinate
  */
  getX(): number;
  /**
   * Gets the y-coordinate of this block
   *
   * @return y-coordinate
  */
  getY(): number;
  /**
   * Gets the z-coordinate of this block
   *
   * @return z-coordinate
  */
  getZ(): number;
  /**
   * Returns this block's coordinates packed into a long value.
   * Computed via: `Block.getBlockKey(this.getX(), this.getY(), this.getZ())`
   * @see Block#getBlockKey(int, int, int)
   * @return This block's x, y, and z coordinates packed into a long value
   * @deprecated see {@link #getBlockKey(int, int, int)}
  */
  getBlockKey(): number;
  /**
   * Returns the specified block coordinates packed into a long value
   * 
   * The return value can be computed as follows:
   * 
   * `long value = ((long)x & 0x7FFFFFF) | (((long)z & 0x7FFFFFF) << 27) | ((long)y << 54);`
   * 
   *
   * 
   * And may be unpacked as follows:
   * 
   * `int x = (int) ((packed << 37) >> 37);`
   * 
   * `int y = (int) (packed >> 54);`
   * 
   * `int z = (int) ((packed << 10) >> 37);`
   * 
   *
   * @return This block's x, y, and z coordinates packed into a long value
   * @deprecated only encodes y block ranges from -512 to 511 and represents an already changed implementation detail
  */
  static getBlockKey(x: number, y: number, z: number): number;
  /**
   * Returns the x component from the packed value.
   * @param packed The packed value, as computed by {@link Block#getBlockKey(int, int, int)}
   * @see Block#getBlockKey(int, int, int)
   * @return The x component from the packed value.
   * @deprecated see {@link #getBlockKey(int, int, int)}
  */
  static getBlockKeyX(packed: number): number;
  /**
   * Returns the y component from the packed value.
   * @param packed The packed value, as computed by {@link Block#getBlockKey(int, int, int)}
   * @see Block#getBlockKey(int, int, int)
   * @return The y component from the packed value.
   * @deprecated see {@link #getBlockKey(int, int, int)}
  */
  static getBlockKeyY(packed: number): number;
  /**
   * Returns the z component from the packed value.
   * @param packed The packed value, as computed by {@link Block#getBlockKey(int, int, int)}
   * @see Block#getBlockKey(int, int, int)
   * @return The z component from the packed value.
   * @deprecated see {@link #getBlockKey(int, int, int)}
  */
  static getBlockKeyZ(packed: number): number;
  /**
   * Checks if the itemstack is a valid tool to
   * break the block with
   *
   * @param itemStack The (tool) itemstack
   * @return whether the block will drop items
  */
  isValidTool(itemStack: ItemStack): boolean;
  /**
   * Gets the Location of the block
   *
   * @return Location of block
  */
  getLocation(): Location;
  /**
   * Stores the location of the block in the provided Location object.
   * 
   * If the provided Location is null this method does nothing and returns
   * null.
   *
   * @param loc the location to copy into
   * @return The Location object provided or null
  */
  getLocation(loc: Location | null): Location | null;
  /**
   * Gets the chunk which contains this block
   *
   * @return Containing Chunk
  */
  getChunk(): Chunk;
  /**
   * Sets the complete data for this block
   *
   * @param data new block specific data
  */
  setBlockData(blockData: BlockData);
  /**
   * Sets the complete data for this block
   *
   * 
   * Note that applyPhysics = false is not in general safe. It should only be
   * used when you need to avoid triggering a physics update of neighboring
   * blocks, for example when creating a {@link Bisected} block. If you are
   * using a custom populator, then this parameter may also be required to
   * prevent triggering infinite chunk loads on border blocks. This method
   * should NOT be used to "hack" physics by placing blocks in impossible
   * locations. Such blocks are liable to be removed on various events such as
   * world upgrades. Furthermore setting large amounts of such blocks in close
   * proximity may overload the server physics engine if an update is
   * triggered at a later point. If this occurs, the resulting behavior is
   * undefined.
   *
   * @param data new block specific data
   * @param applyPhysics false to cancel physics from the changed block
  */
  setBlockData(data: BlockData, applyPhysics: boolean): void;
  /**
   * Sets the type of this block
   *
   * @param type Material to change this block to
  */
  setType(type: Material);
  /**
   * Sets the type of this block
   *
   * 
   * Note that applyPhysics = false is not in general safe. It should only be
   * used when you need to avoid triggering a physics update of neighboring
   * blocks, for example when creating a {@link Bisected} block. If you are
   * using a custom populator, then this parameter may also be required to
   * prevent triggering infinite chunk loads on border blocks. This method
   * should NOT be used to "hack" physics by placing blocks in impossible
   * locations. Such blocks are liable to be removed on various events such as
   * world upgrades. Furthermore setting large amounts of such blocks in close
   * proximity may overload the server physics engine if an update is
   * triggered at a later point. If this occurs, the resulting behavior is
   * undefined.
   *
   * @param type Material to change this block to
   * @param applyPhysics False to cancel physics on the changed block.
  */
  setType(type: Material, applyPhysics: boolean): void;
  /**
   * Gets the face relation of this block compared to the given block.
   * 
   * For example:
   * {@code
   * Block current = world.getBlockAt(100, 100, 100);
   * Block target = world.getBlockAt(100, 101, 100);
   *
   * current.getFace(target) == BlockFace.Up;
   * }
   * 
   * If the given block is not connected to this block, null may be returned
   *
   * @param block Block to compare against this block
   * @return BlockFace of this block which has the requested block, or null
  */
  getFace(block: Block): BlockFace | null;
  /**
   * Captures the current state of this block. You may then cast that state
   * into any accepted type, such as Furnace or Sign.
   * 
   * The returned object will never be updated, and you are not guaranteed
   * that (for example) a sign is still a sign after you capture its state.
   *
   * @return BlockState with the current state of this block.
  */
  getState(): BlockState;
  /**
   * @see #getState() optionally disables use of snapshot, to operate on real block data
   * @param useSnapshot if this block is a TE, should we create a fully copy of the TileEntity
   * @return BlockState with the current state of this block
  */
  getState(useSnapshot: boolean): BlockState;
  /**
   * Returns the biome that this block resides in
   *
   * @return Biome type containing this block
   * @see #getComputedBiome()
  */
  getBiome(): Biome;
  /**
   * Gets the computed biome at the location of this Block.
   *
   * @return computed biome at the location of this Block.
   * @see org.bukkit.RegionAccessor#getComputedBiome(int, int, int)
  */
  getComputedBiome(): Biome;
  /**
   * Sets the biome that this block resides in
   *
   * @param bio new Biome type for this block
  */
  setBiome(biome: Biome);
  /**
   * Returns true if the block is being powered by Redstone.
   *
   * @return True if the block is powered.
  */
  isBlockPowered(): boolean;
  /**
   * Returns true if the block is being indirectly powered by Redstone.
   *
   * @return True if the block is indirectly powered.
  */
  isBlockIndirectlyPowered(): boolean;
  /**
   * Returns true if the block face is being powered by Redstone.
   *
   * @param face The block face
   * @return True if the block face is powered.
  */
  isBlockFacePowered(face: BlockFace): boolean;
  /**
   * Returns true if the block face is being indirectly powered by Redstone.
   *
   * @param face The block face
   * @return True if the block face is indirectly powered.
  */
  isBlockFaceIndirectlyPowered(face: BlockFace): boolean;
  /**
   * Returns the redstone power being provided to this block face
   *
   * @param face the face of the block to query or BlockFace.SELF for the
   *     block itself
   * @return The power level.
  */
  getBlockPower(face: BlockFace): number;
  /**
   * Returns the redstone power being provided to this block
   *
   * @return The power level.
  */
  getBlockPower(): number;
  /**
   * Checks if this block is empty.
   * 
   * A block is considered empty when {@link #getType()} returns {@link
   * Material#AIR}.
   *
   * @return true if this block is empty
  */
  isEmpty(): boolean;
  /**
   * Checks if this block is liquid.
   * 
   * A block is considered liquid when {@link #getType()} returns {@link
   * Material#WATER} or {@link Material#LAVA}.
   *
   * @return true if this block is liquid
  */
  isLiquid(): boolean;
  /**
   * Check if this block is solid
   * 
   * Determined by Minecraft, typically a block a player can use to place a new block to build things.
   * An example of a non buildable block would be liquids, flowers, or fire
   *
   * @return true if block is buildable
  */
  isBuildable(): boolean;
  /**
   * Check if this block is burnable
   * 
   * Determined by Minecraft, typically a block that fire can destroy (Wool, Wood)
   *
   * @return true if block is burnable
  */
  isBurnable(): boolean;
  /**
   * Check if this block is replaceable
   * 
   * Determined by Minecraft, representing a block that is not AIR that you can still place a new block at, such as flowers.
   * @return true if block is replaceable
  */
  isReplaceable(): boolean;
  /**
   * Check if this block is solid
   * 
   * Determined by Minecraft, typically a block a player can stand on and can't be passed through.
   *
   * This API is faster than accessing Material#isSolid as it avoids a material lookup and switch statement.
   * @return true if block is solid
  */
  isSolid(): boolean;
  /**
   * Checks if this block is collidable.
   *
   * @return true if collidable
  */
  isCollidable(): boolean;
  /**
   * Gets the temperature of this block.
   * 
   * If the raw biome temperature without adjusting for height effects is
   * required then please use {@link World#getTemperature(int, int)}.
   *
   * @return Temperature of this block
  */
  getTemperature(): number;
  /**
   * Gets the humidity of the biome of this block
   *
   * @return Humidity of this block
  */
  getHumidity(): number;
  /**
   * Returns the reaction of the block when moved by a piston
   *
   * @return reaction
  */
  getPistonMoveReaction(): PistonMoveReaction;
  /**
   * Breaks the block and spawns items as if a player had digged it regardless
   * of the tool.
   *
   * @return true if the block was destroyed
  */
  breakNaturally(): boolean;
  /**
   * Breaks the block and spawns items as if a player had digged it with a
   * specific tool
   *
   * @param tool The tool or item in hand used for digging
   * @return true if the block was destroyed
  */
  breakNaturally(tool: ItemStack | null): boolean;
  /**
   * Breaks the block and spawns item drops as if a player had broken it
   *
   * @param triggerEffect Play the block break particle effect and sound
   * @return true if the block was destroyed
  */
  breakNaturally(triggerEffect: boolean): boolean;
  /**
   * Breaks the block and spawns item drops as if a player had broken it
   * with a specific tool
   *
   * @param tool The tool or item in hand used for digging
   * @param triggerEffect Play the block break particle effect and sound
   * @return true if the block was destroyed
  */
  breakNaturally(tool: ItemStack, triggerEffect: boolean): boolean;
  /**
   * Simulate bone meal application to this block (if possible).
   *
   * @param face the face on which bonemeal should be applied
   *
   * @return true if the block was bonemealed, false otherwise
  */
  applyBoneMeal(face: BlockFace): boolean;
  /**
   * Returns a list of items which would drop by destroying this block
   *
   * @return a list of dropped items for this type of block
  */
  getDrops(): Collection<ItemStack>;
  /**
   * Returns a list of items which would drop by destroying this block with
   * a specific tool
   *
   * @param tool The tool or item in hand used for digging
   * @return a list of dropped items for this type of block
  */
  getDrops(tool: ItemStack | null): Collection<ItemStack>;
  /**
   * Returns a list of items which would drop by the entity destroying this
   * block with a specific tool
   *
   * @param tool The tool or item in hand used for digging
   * @param entity the entity destroying the block
   * @return a list of dropped items for this type of block
  */
  getDrops(tool: ItemStack, entity: Entity | null): Collection<ItemStack>;
  /**
   * Returns if the given item is a preferred choice to break this Block.
   *
   * In some cases this determines if a block will drop anything or extra
   * loot.
   *
   * @param tool The tool or item used for breaking this block
   * @return true if the tool is preferred for breaking this block.
  */
  isPreferredTool(tool: ItemStack): boolean;
  /**
   * Gets the speed at which the given player would break this block, taking
   * into account tools, potion effects, whether or not the player is in
   * water, enchantments, etc.
   *
   * The returned value is the amount of progress made in breaking the block
   * each tick. When the total breaking progress reaches `1.0f`, the
   * block is broken. Note that the break speed can change in the course of
   * breaking a block, e.g. if a potion effect is applied or expires, or the
   * player jumps/enters water.
   *
   * @param player player breaking the block
   * @return the speed at which the player breaks this block
  */
  getBreakSpeed(player: Player): number;
  /**
   * Checks if this block is passable.
   * 
   * A block is passable if it has no colliding parts that would prevent
   * players from moving through it.
   * 
   * Examples: Tall grass, flowers, signs, etc. are passable, but open doors,
   * fence gates, trap doors, etc. are not because they still have parts that
   * can be collided with.
   *
   * @return true if passable
  */
  isPassable(): boolean;
  /**
   * Performs a ray trace that checks for collision with this specific block
   * in its current state using its precise collision shape.
   *
   * @param start the start location
   * @param direction the ray direction
   * @param maxDistance the maximum distance
   * @param fluidCollisionMode the fluid collision mode
   * @return the ray trace hit result, or null if there is no hit
  */
  rayTrace(start: Location, direction: Vector, maxDistance: number, fluidCollisionMode: FluidCollisionMode): RayTraceResult | null;
  /**
   * Gets the approximate bounding box for this block.
   * 
   * This isn't exact as some blocks {@link org.bukkit.block.data.type.Stairs}
   * contain many bounding boxes to establish their complete form.
   *
   * Also, the box may not be exactly the same as the collision shape (such as
   * cactus, which is 16/16 of a block with 15/16 collisional bounds).
   *
   * This method will return an empty bounding box if the geometric shape of
   * the block is empty (such as air blocks).
   *
   * @return the approximate bounding box of the block
  */
  getBoundingBox(): BoundingBox;
  /**
   * Gets the collision shape of this block.
   *
   * @return a {@link VoxelShape} representing the collision shape of this
   * block.
  */
  getCollisionShape(): VoxelShape;
  /**
   * Checks if this block is a valid placement location for the specified
   * block data.
   *
   * @param data the block data to check
   * @return true if the block data can be placed here
  */
  canPlace(data: BlockData): boolean;
  /**
   * Gets the {@link com.destroystokyo.paper.block.BlockSoundGroup} for this block.
   * 
   * This object contains the block, step, place, hit, and fall sounds.
   *
   * @return the sound group for this block
   * @deprecated use {@link #getBlockSoundGroup()}
  */
  getSoundGroup(): BlockSoundGroup;
  /**
   * Gets the {@link org.bukkit.SoundGroup} for this block.
   *
   * @return the sound group for this block
  */
  getBlockSoundGroup(): SoundGroup;
  /**
   * Return the translation key for the Block, so the client can translate it into the active
   * locale when using a TranslatableComponent.
   * @return the translation key
   * @deprecated use {@link #translationKey()}
  */
  getTranslationKey(): string;
  /**
   * Gets the speed at which this block will be destroyed by a given {@link ItemStack}
   *
   * Default value is 1.0
   *
   * @param itemStack {@link ItemStack} used to mine this Block
   * @return the speed that this Block will be mined by the given {@link ItemStack}
  */
  getDestroySpeed(itemStack: ItemStack): number;
  /**
   * Gets the speed at which this blook will be destroyed by a given {@link org.bukkit.inventory.ItemStack}
   * 
   * Default value is 1.0
   * @param itemStack {@link org.bukkit.inventory.ItemStack} used to mine this Block
   * @param considerEnchants true to look at enchants on the itemstack
   * @return the speed that this Block will be mined by the given {@link org.bukkit.inventory.ItemStack}
  */
  getDestroySpeed(itemStack: ItemStack, considerEnchants: boolean): number;
}
export interface Block extends Metadatable, Translatable {}
/**
 * Represents a double chest.
*/
export class DoubleChest extends InventoryHolder {
  constructor(chest: DoubleChestInventory);
  /**
   * Get the object's inventory.
   *
   * @return The inventory.
  */
  getInventory(): Inventory;
  getLeftSide(): InventoryHolder | null;
  getRightSide(): InventoryHolder | null;
  getLeftSide(useSnapshot: boolean): InventoryHolder | null;
  getRightSide(useSnapshot: boolean): InventoryHolder | null;
  getLocation(): Location;
  getWorld(): World | null;
  getX(): number;
  getY(): number;
  getZ(): number;
}
export class Lidded {
  /**
   * Sets the block's animated state to open and prevents it from being closed
   * until {@link #close()} is called.
  */
  open(): void;
  /**
   * Sets the block's animated state to closed even if a player is currently
   * viewing this block.
  */
  close(): void;
  /**
   * Checks if the block's animation state.
   *
   * @return true if the block's animation state is set to open.
  */
  isOpen(): boolean;
}
/**
 * Represents a block state that also hosts a tile entity at the given location.
 *
 * This interface alone is merely a marker that does not provide any data.
 *
 * Data about the tile entities is provided by the respective interface for each
 * tile entity type.
 *
 * After modifying the data provided by a TileState, {@link #update()} needs to
 * be called to store the data.
*/
export class TileState extends BlockState {
  /**
   * Returns a custom tag container capable of storing tags on the object.
   *
   * Note that the tags stored on this container are all stored under their
   * own custom namespace therefore modifying default tags using this
   * {@link PersistentDataHolder} is impossible.
   * 
   * This {@link PersistentDataHolder} is only linked to the snapshot instance
   * stored by the {@link BlockState}.
   *
   * When storing changes on the {@link PersistentDataHolder}, the updated
   * content will only be applied to the actual tile entity after one of the
   * {@link #update()} methods is called.
   *
   * @return the custom tag container
  */
  getPersistentDataContainer(): PersistentDataContainer;
  /**
   * Checks if this TileState is a snapshot or a live
   * representation of the underlying tile entity.
   * 
   * NOTE: You may still have to call {@link BlockState#update()} on
   * live representations to update any visuals on the block.
   *
   * @return true if this is a snapshot
   * @see Block#getState(boolean)
  */
  isSnapshot(): boolean;
}
export interface TileState extends BlockState, PersistentDataHolder {}
/**
 * Represents a captured state of a block, which will not change
 * automatically.
 * 
 * Unlike Block, which only one object can exist per coordinate, BlockState
 * can exist multiple times for any given Block. Note that another plugin may
 * change the state of the block and you will not know, or they may change the
 * block to another type entirely, causing your BlockState to become invalid.
*/
export class BlockState extends Metadatable {
  /**
   * Gets the block represented by this block state.
   *
   * @return the block represented by this block state
   * @throws IllegalStateException if this block state is not placed
  */
  getBlock(): Block;
  /**
   * Gets the metadata for this block state.
   *
   * @return block specific metadata
   * @deprecated use {@link #getBlockData()}
  */
  getData(): MaterialData;
  /**
   * Gets the data for this block state.
   *
   * @return block specific data
  */
  getBlockData(): BlockData;
  /**
   * Gets the type of this block state.
   *
   * @return block type
  */
  getType(): Material;
  /**
   * Gets the current light level of the block represented by this block state.
   *
   * @return the light level between 0-15
   * @throws IllegalStateException if this block state is not placed
  */
  getLightLevel(): number;
  /**
   * Gets the world which contains the block represented by this block state.
   *
   * @return the world containing the block represented by this block state
   * @throws IllegalStateException if this block state is not placed
  */
  getWorld(): World;
  /**
   * Gets the x-coordinate of this block state.
   *
   * @return x-coordinate
  */
  getX(): number;
  /**
   * Gets the y-coordinate of this block state.
   *
   * @return y-coordinate
  */
  getY(): number;
  /**
   * Gets the z-coordinate of this block state.
   *
   * @return z-coordinate
  */
  getZ(): number;
  /**
   * Gets the location of this block state.
   * 
   * If this block state is not placed the location's world will be null!
   *
   * @return the location
  */
  getLocation(): Location;
  /**
   * Stores the location of this block state in the provided Location object.
   * 
   * If the provided Location is null this method does nothing and returns
   * null.
   * 
   * If this block state is not placed the location's world will be null!
   *
   * @param loc the location to copy into
   * @return The Location object provided or null
  */
  getLocation(loc: Location | null): Location | null;
  /**
   * Gets the chunk which contains the block represented by this block state.
   *
   * @return the containing Chunk
   * @throws IllegalStateException if this block state is not placed
  */
  getChunk(): Chunk;
  /**
   * Sets the metadata for this block state.
   *
   * @param data New block specific metadata
   * @deprecated use {@link #setBlockData(BlockData)}
  */
  setData(data: MaterialData);
  /**
   * Sets the data for this block state.
   *
   * @param data New block specific data
  */
  setBlockData(blockData: BlockData);
  /**
   * Sets the type of this block state.
   *
   * @param type Material to change this block state to
  */
  setType(type: Material);
  /**
   * Attempts to update the block represented by this state, setting it to
   * the new values as defined by this state.
   * 
   * This has the same effect as calling update(false). That is to say,
   * this will not modify the state of a block if it is no longer the same
   * type as it was when this state was taken. It will return false in this
   * eventuality.
   *
   * @return true if the update was successful, otherwise false
   * @see #update(boolean)
  */
  update(): boolean;
  /**
   * Attempts to update the block represented by this state, setting it to
   * the new values as defined by this state.
   * 
   * This has the same effect as calling update(force, true). That is to
   * say, this will trigger a physics update to surrounding blocks.
   *
   * @param force true to forcefully set the state
   * @return true if the update was successful, otherwise false
  */
  update(force: boolean): boolean;
  /**
   * Attempts to update the block represented by this state, setting it to
   * the new values as defined by this state.
   * 
   * If this state is not placed, this will have no effect and return true.
   * 
   * Unless force is true, this will not modify the state of a block if it
   * is no longer the same type as it was when this state was taken. It will
   * return false in this eventuality.
   * 
   * If force is true, it will set the type of the block to match the new
   * state, set the state data and then return true.
   * 
   * If applyPhysics is true, it will trigger a physics update on
   * surrounding blocks which could cause them to update or disappear.
   *
   * @param force true to forcefully set the state
   * @param applyPhysics false to cancel updating physics on surrounding
   *     blocks
   * @return true if the update was successful, otherwise false
  */
  update(force: boolean, applyPhysics: boolean): boolean;
  /**
   * @return The data as a raw byte.
   * @deprecated Magic value
  */
  getRawData(): number;
  /**
   * @param data The new data value for the block.
   * @deprecated Magic value
  */
  setRawData(rawData: number);
  /**
   * Returns whether this state is placed in the world.
   * 
   * Some methods will not work if the block state isn't
   * placed in the world.
   *
   * @return whether the state is placed in the world
   *         or 'virtual' (e.g. on an itemstack)
  */
  isPlaced(): boolean;
  /**
   * Checks if this block state is collidable.
   *
   * @return true if collidable
  */
  isCollidable(): boolean;
}
/**
 * Represents a captured state of a brewing stand.
*/
export class BrewingStand extends Container {
  /**
   * How much time is left in the brewing cycle.
   *
   * @return Brew Time
  */
  getBrewingTime(): number;
  /**
   * Set the time left before brewing completes.
   *
   * @param brewTime Brewing time
  */
  setBrewingTime(brewingTime: number);
  /**
   * Get the level of current fuel for brewing.
   *
   * @return The fuel level
  */
  getFuelLevel(): number;
  /**
   * Set the level of current fuel for brewing.
   *
   * @param level fuel level
  */
  setFuelLevel(fuelLevel: number);
  getInventory(): BrewerInventory;
  getSnapshotInventory(): BrewerInventory;
}
/**
 * Represents a captured state of a beacon.
*/
export class Beacon extends TileState {
  /**
   * Returns the list of players within the beacon's range of effect.
   * 
   * This will return an empty list if the block represented by this state is
   * no longer a beacon.
   *
   * @return the players in range
   * @throws IllegalStateException if this block state is not placed
  */
  getEntitiesInRange(): Collection<LivingEntity>;
  /**
   * Returns the tier of the beacon pyramid (0-4). The tier refers to the
   * beacon's power level, based on how many layers of blocks are in the
   * pyramid. Tier 1 refers to a beacon with one layer of 9 blocks under it.
   *
   * @return the beacon tier
  */
  getTier(): number;
  /**
   * Returns the primary effect set on the beacon
   *
   * @return the primary effect or null if not set
  */
  getPrimaryEffect(): PotionEffect | null;
  /**
   * Set the primary effect on this beacon, or null to clear.
   *
   * @param effect new primary effect
  */
  setPrimaryEffect(primaryEffect: PotionEffectType | null);
  /**
   * Returns the secondary effect set on the beacon.
   *
   * @return the secondary effect or null if no secondary effect
  */
  getSecondaryEffect(): PotionEffect | null;
  /**
   * Set the secondary effect on this beacon, or null to clear. Note that tier
   * must be >= 4 for this effect to be active.
   *
   * @param effect desired secondary effect
  */
  setSecondaryEffect(secondaryEffect: PotionEffectType | null);
  /**
   * Gets the effect range of this beacon.
   * A negative range value means the beacon is using its default range based on tier.
   * @return Either the custom range set with {@link #setEffectRange(double)} or the range based on the beacon tier.
  */
  getEffectRange(): number;
  /**
   * Sets the effect range of the beacon
   * A negative range value means the beacon is using its default range based on tier.
   * @param range Radius of effect range.
  */
  setEffectRange(effectRange: number);
  /**
   * Resets the custom range from this beacon and falls back to the range based on the the beacon tier.
   * Shortcut for setting the effect range to a negative number.
  */
  resetEffectRange(): void;
}
export interface Beacon extends TileState, Lockable, Nameable {}
/**
 * Represents a captured state of a blast furnace.
*/
export class BlastFurnace extends Furnace {

}
/**
 * Represents a captured state of a smoker.
*/
export class Smoker extends Furnace {

}
/**
 * Represents a captured state of a conduit.
*/
export class Conduit extends TileState {

}
/**
 * Represents how a block or entity will react when interacting with a piston
 * when it is extending or retracting.
*/
export class PistonMoveReaction extends Enum<PistonMoveReaction> {
  /**
   * Indicates that the block can be pushed or pulled.
  */
  static readonly MOVE: PistonMoveReaction;
  /**
   * Indicates the block is fragile and will break if pushed on.
  */
  static readonly BREAK: PistonMoveReaction;
  /**
   * Indicates that the block will resist being pushed or pulled.
  */
  static readonly BLOCK: PistonMoveReaction;
  /**
   * Indicates that the entity will ignore any interaction(s) with
   * pistons.
   * 
   * Blocks should use {@link PistonMoveReaction#BLOCK}.
  */
  static readonly IGNORE: PistonMoveReaction;
  /**
   * Indicates that the block can only be pushed by pistons, not pulled.
  */
  static readonly PUSH_ONLY: PistonMoveReaction;
  static valueOf(name: string): PistonMoveReaction;
  static values(): PistonMoveReaction[];
  /**
   * @return The ID of the move reaction
   * @deprecated Magic value
  */
  getId(): number;
  /**
   * @param id An ID
   * @return The move reaction with that ID
   * @deprecated Magic value
  */
  static getById(id: number): PistonMoveReaction | null;
}
/**
 * Represents a captured state of a dropper.
*/
export class Dropper extends Container {
  /**
   * Tries to drop a randomly selected item from the dropper's inventory,
   * following the normal behavior of a dropper.
   * 
   * Normal behavior of a dropper is as follows:
   * 
   * If the block that the dropper is facing is an InventoryHolder,
   * the randomly selected ItemStack is placed within that
   * Inventory in the first slot that's available, starting with 0 and
   * counting up.  If the inventory is full, nothing happens.
   * 
   * If the block that the dropper is facing is not an InventoryHolder,
   * the randomly selected ItemStack is dropped on
   * the ground in the form of an {@link org.bukkit.entity.Item Item}.
   * 
   * If the block represented by this state is no longer a dropper, this will
   * do nothing.
   *
   * @throws IllegalStateException if this block state is not placed
  */
  drop(): void;
}
export interface Dropper extends Container, LootableBlockInventory {}
/**
 * Represents a captured state of a dispenser.
*/
export class Dispenser extends Container {
  /**
   * Gets the BlockProjectileSource object for the dispenser.
   * 
   * If the block represented by this state is no longer a dispenser, this
   * will return null.
   *
   * @return a BlockProjectileSource if valid, otherwise null
   * @throws IllegalStateException if this block state is not placed
  */
  getBlockProjectileSource(): BlockProjectileSource | null;
  /**
   * Attempts to dispense the contents of the dispenser.
   * 
   * If the block represented by this state is no longer a dispenser, this
   * will return false.
   *
   * @return true if successful, otherwise false
   * @throws IllegalStateException if this block state is not placed
  */
  dispense(): boolean;
}
export interface Dispenser extends Container, Nameable, LootableBlockInventory {}
/**
 * Represents a captured state of a creature spawner.
*/
export class CreatureSpawner extends TileState {
  /**
   * Get the spawner's creature type.
   *
   * @return The creature type.
  */
  getSpawnedType(): EntityType;
  /**
   * Set the spawner's creature type.
   *
   * @param creatureType The creature type.
  */
  setSpawnedType(spawnedType: EntityType);
  /**
   * Set the spawner mob type.
   *
   * @param creatureType The creature type's name.
   * @deprecated magic value, use
   * {@link #setSpawnedType(org.bukkit.entity.EntityType)}.
  */
  setCreatureTypeByName(creatureTypeByName: string);
  /**
   * Get the spawner's creature type.
   *
   * @return The creature type's name.
   * @deprecated magic value, use {@link #getSpawnedType()}.
  */
  getCreatureTypeName(): string;
  /**
   * Get the spawner's delay.
   * 
   * This is the delay, in ticks, until the spawner will spawn its next mob.
   *
   * @return The delay.
  */
  getDelay(): number;
  /**
   * Set the spawner's delay.
   * 
   * If set to -1, the spawn delay will be reset to a random value between
   * {@link #getMinSpawnDelay} and {@link #getMaxSpawnDelay()}.
   *
   * @param delay The delay.
  */
  setDelay(delay: number);
  /**
   * The minimum spawn delay amount (in ticks).
   * 
   * This value is used when the spawner resets its delay (for any reason).
   * It will choose a random number between {@link #getMinSpawnDelay()}
   * and {@link #getMaxSpawnDelay()} for its next {@link #getDelay()}.
   *
   * Default value is 200 ticks.
   *
   * @return the minimum spawn delay amount
  */
  getMinSpawnDelay(): number;
  /**
   * Set the minimum spawn delay amount (in ticks).
   *
   * @param delay the minimum spawn delay amount
   * @see #getMinSpawnDelay()
  */
  setMinSpawnDelay(minSpawnDelay: number);
  /**
   * The maximum spawn delay amount (in ticks).
   * 
   * This value is used when the spawner resets its delay (for any reason).
   * It will choose a random number between {@link #getMinSpawnDelay()}
   * and {@link #getMaxSpawnDelay()} for its next {@link #getDelay()}.
   * 
   * This value must be greater than 0 and less than or equal to
   * {@link #getMaxSpawnDelay()}.
   *
   * Default value is 800 ticks.
   *
   * @return the maximum spawn delay amount
  */
  getMaxSpawnDelay(): number;
  /**
   * Set the maximum spawn delay amount (in ticks).
   * 
   * This value must be greater than 0, as well as greater than or
   * equal to {@link #getMinSpawnDelay()}
   *
   * @param delay the new maximum spawn delay amount
   * @see #getMaxSpawnDelay()
  */
  setMaxSpawnDelay(maxSpawnDelay: number);
  /**
   * Get how many mobs attempt to spawn.
   * 
   * Default value is 4.
   *
   * @return the current spawn count
  */
  getSpawnCount(): number;
  /**
   * Set how many mobs attempt to spawn.
   *
   * @param spawnCount the new spawn count
  */
  setSpawnCount(spawnCount: number);
  /**
   * Set the new maximum amount of similar entities that are allowed to be
   * within spawning range of this spawner.
   * 
   * If more than the maximum number of entities are within range, the spawner
   * will not spawn and try again with a new {@link #getDelay()}.
   * 
   * Default value is 16.
   *
   * @return the maximum number of nearby, similar, entities
  */
  getMaxNearbyEntities(): number;
  /**
   * Set the maximum number of similar entities that are allowed to be within
   * spawning range of this spawner.
   * 
   * Similar entities are entities that are of the same {@link EntityType}
   *
   * @param maxNearbyEntities the maximum number of nearby, similar, entities
  */
  setMaxNearbyEntities(maxNearbyEntities: number);
  /**
   * Get the maximum distance(squared) a player can be in order for this
   * spawner to be active.
   * 
   * If this value is less than or equal to 0, this spawner is always active
   * (given that there are players online).
   * 
   * Default value is 16.
   *
   * @return the maximum distance(squared) a player can be in order for this
   * spawner to be active.
  */
  getRequiredPlayerRange(): number;
  /**
   * Set the maximum distance (squared) a player can be in order for this
   * spawner to be active.
   * 
   * Setting this value to less than or equal to 0 will make this spawner
   * always active (given that there are players online).
   *
   * @param requiredPlayerRange the maximum distance (squared) a player can be
   * in order for this spawner to be active.
  */
  setRequiredPlayerRange(requiredPlayerRange: number);
  /**
   * Get the radius around which the spawner will attempt to spawn mobs in.
   * 
   * This area is square, includes the block the spawner is in, and is
   * centered on the spawner's x,z coordinates - not the spawner itself.
   * 
   * It is 2 blocks high, centered on the spawner's y-coordinate (its bottom);
   * thus allowing mobs to spawn as high as its top surface and as low
   * as 1 block below its bottom surface.
   * 
   * Default value is 4.
   *
   * @return the spawn range
  */
  getSpawnRange(): number;
  /**
   * Set the new spawn range.
   * 
   *
   * @param spawnRange the new spawn range
   * @see #getSpawnRange()
  */
  setSpawnRange(spawnRange: number);
  /**
   * Check if spawner is activated (a player is close enough)
   *
   * @return True if a player is close enough to activate it
  */
  isActivated(): boolean;
  /**
   * Resets the spawn delay timer within the min/max range
  */
  resetTimer(): void;
  /**
   * Sets the {@link EntityType} to {@link EntityType#DROPPED_ITEM} and sets the data to the given
   * {@link org.bukkit.inventory.ItemStack ItemStack}.
   * 
   * {@link #setSpawnCount(int)} does not dictate the amount of items in the stack spawned, but rather how many
   * stacks should be spawned.
   *
   * @param itemStack The item to spawn. Must not {@link org.bukkit.Material#isAir be air}.
   * @see #setSpawnedType(EntityType)
  */
  setSpawnedItem(spawnedItem: ItemStack);
}
/**
 * Represents a captured state of an end gateway.
*/
export class EndGateway extends TileState {
  /**
   * Gets the location that entities are teleported to when
   * entering the gateway portal.
   * 
   * If this block state is not placed the location's world will be null.
   *
   * @return the gateway exit location
  */
  getExitLocation(): Location | null;
  /**
   * Sets the exit location that entities are teleported to when
   * they enter the gateway portal.
   * 
   * If this block state is not placed the location's world has to be null.
   *
   * @param location the new exit location
   * @throws IllegalArgumentException for differing worlds
  */
  setExitLocation(exitLocation: Location | null);
  /**
   * Gets whether this gateway will teleport entities directly to
   * the exit location instead of finding a nearby location.
   *
   * @return true if the gateway is teleporting to the exact location
  */
  isExactTeleport(): boolean;
  /**
   * Sets whether this gateway will teleport entities directly to
   * the exit location instead of finding a nearby location.
   *
   * @param exact whether to teleport to the exact location
  */
  setExactTeleport(exact: boolean): void;
  /**
   * Gets the age in ticks of the gateway.
   * 
   * If the age is less than 200 ticks a magenta beam will be emitted, whilst
   * if it is a multiple of 2400 ticks a purple beam will be emitted.
   *
   * @return age in ticks
  */
  getAge(): number;
  /**
   * Sets the age in ticks of the gateway.
   * 
   * If the age is less than 200 ticks a magenta beam will be emitted, whilst
   * if it is a multiple of 2400 ticks a purple beam will be emitted.
   *
   * @param age new age in ticks
  */
  setAge(age: number);
}
/**
 * Represents a captured state of a lectern.
*/
export class Lectern extends TileState {
  /**
   * Get the current lectern page.
   *
   * @return current page
  */
  getPage(): number;
  /**
   * Set the current lectern page.
   *
   * If the page is greater than the number of pages of the book currently in
   * the inventory, then behavior is undefined.
   *
   * @param page new page
  */
  setPage(page: number);
  /**
   * @return inventory
   * @see Container#getInventory()
  */
  getInventory(): Inventory;
  /**
   * @return snapshot inventory
   * @see Container#getSnapshotInventory()
  */
  getSnapshotInventory(): Inventory;
}
export interface Lectern extends TileState, BlockInventoryHolder {}
/**
 * Represents a captured state of an enchanting table.
*/
export class EnchantingTable extends TileState {

}
export interface EnchantingTable extends TileState, Nameable {}
/**
 * Represents a structure block that can save and load blocks from a file. They
 * can only be used by OPs, and are not obtainable in survival.
*/
export class Structure extends TileState {
  /**
   * The name of this structure.
   *
   * @return structure name
  */
  getStructureName(): string;
  /**
   * Set the name of this structure. This is case-sensitive. The name of the
   * structure in the {@link UsageMode#SAVE} structure block MUST match the
   * name within the {@link UsageMode#CORNER} block or the size calculation
   * will fail.
   *
   * @param name the case-sensitive name of this structure
  */
  setStructureName(structureName: string);
  /**
   * Get the name of who created this structure.
   *
   * @return the name of whoever created this structure.
  */
  getAuthor(): string;
  /**
   * Set the name of whoever created this structure.
   *
   * @param author whoever created this structure (not empty)
  */
  setAuthor(author: string): void;
  /**
   * Set the name of whoever created this structure using a
   * {@link LivingEntity}.
   *
   * @param livingEntity the entity who created this structure
  */
  setAuthor(author: LivingEntity): void;
  /**
   * The relative position of the structure outline based on the position of
   * the structure block. Maximum allowed distance is 48 blocks in any
   * direction.
   *
   * @return a Location which contains the relative distance this structure is
   * from the structure block.
  */
  getRelativePosition(): BlockVector;
  /**
   * Set the relative position from the structure block. Maximum allowed
   * distance is 48 blocks in any direction.
   *
   * @param vector the {@link BlockVector} containing the relative origin
   * coordinates of this structure.
  */
  setRelativePosition(relativePosition: BlockVector);
  /**
   * The distance to the opposite corner of this structure. The maximum
   * structure size is 48x48x48. When a structure has successfully been
   * calculated (i.e. it is within the maximum allowed distance) a white
   * border surrounds the structure.
   *
   * @return a {@link BlockVector} which contains the total size of the
   * structure.
  */
  getStructureSize(): BlockVector;
  /**
   * Set the maximum size of this structure from the origin point. Maximum
   * allowed size is 48x48x48.
   *
   * @param vector the {@link BlockVector} containing the size of this
   * structure, based off of the origin coordinates.
  */
  setStructureSize(structureSize: BlockVector);
  /**
   * Sets the mirroring of the structure.
   *
   * @param mirror the new mirroring method
  */
  setMirror(mirror: Mirror);
  /**
   * How this structure is mirrored.
   *
   * @return the current mirroring method
  */
  getMirror(): Mirror;
  /**
   * Set how this structure is rotated.
   *
   * @param rotation the new rotation
  */
  setRotation(rotation: StructureRotation);
  /**
   * Get how this structure is rotated.
   *
   * @return the new rotation
  */
  getRotation(): StructureRotation;
  /**
   * Set the {@link UsageMode} of this structure block.
   *
   * @param mode the new mode to set.
  */
  setUsageMode(usageMode: UsageMode);
  /**
   * Get the {@link UsageMode} of this structure block.
   *
   * @return the mode this block is currently in.
  */
  getUsageMode(): UsageMode;
  /**
   * While in {@link UsageMode#SAVE} mode, this will ignore any entities when
   * saving the structure.
   * 
   * While in {@link UsageMode#LOAD} mode this will ignore any entities that
   * were saved to file.
   *
   * @param ignoreEntities the flag to set
  */
  setIgnoreEntities(ignoreEntities: boolean): void;
  /**
   * Get if this structure block should ignore entities.
   *
   * @return true if the appropriate {@link UsageMode} should ignore entities.
  */
  isIgnoreEntities(): boolean;
  /**
   * Set if the structure outline should show air blocks.
   *
   * @param showAir if the structure block should show air blocks
  */
  setShowAir(showAir: boolean): void;
  /**
   * Check if this structure block is currently showing all air blocks
   *
   * @return true if the structure block is showing all air blocks
  */
  isShowAir(): boolean;
  /**
   * Set if this structure box should show the bounding box.
   *
   * @param showBoundingBox if the structure box should be shown
  */
  setBoundingBoxVisible(showBoundingBox: boolean): void;
  /**
   * Get if this structure block is currently showing the bounding box.
   *
   * @return true if the bounding box is shown
  */
  isBoundingBoxVisible(): boolean;
  /**
   * Set the integrity of the structure. Integrity must be between 0.0 and 1.0
   * Lower integrity values will result in more blocks being removed when
   * loading a structure. Integrity and {@link #getSeed()} are used together
   * to determine which blocks are randomly removed to mimic "decay."
   *
   * @param integrity the integrity of this structure
  */
  setIntegrity(integrity: number);
  /**
   * Get the integrity of this structure.
   *
   * @return the integrity of this structure
  */
  getIntegrity(): number;
  /**
   * The seed used to determine which blocks will be removed upon loading.
   * {@link #getIntegrity()} and seed are used together to determine which
   * blocks are randomly removed to mimic "decay."
   *
   * @param seed the seed used to determine how many blocks will be removed
  */
  setSeed(seed: number);
  /**
   * The seed used to determine how many blocks are removed upon loading of
   * this structure.
   *
   * @return the seed used
  */
  getSeed(): number;
  /**
   * Only applicable while in {@link UsageMode#DATA}. Metadata are specific
   * functions that can be applied to the structure location. Consult the
   * Minecraft
   * wiki for more information.
   *
   * @param metadata the function to perform on the selected location
  */
  setMetadata(metadata: string);
  /**
   * Get the metadata function this structure block will perform when
   * activated. Consult the
   * Minecraft
   * Wiki for more information.
   *
   * @return the function that will be performed when this block is activated
  */
  getMetadata(): string;
}
/**
 * Represents a captured state of a container block.
*/
export class Container extends TileState {
  /**
   * Gets the inventory of the block represented by this block state.
   * 
   * If the block was changed to a different type in the meantime, the
   * returned inventory might no longer be valid.
   * 
   * If this block state is not placed this will return the captured inventory
   * snapshot instead.
   *
   * @return the inventory
  */
  getInventory(): Inventory;
  /**
   * Gets the captured inventory snapshot of this container.
   * 
   * The returned inventory is not linked to any block. Any modifications to
   * the returned inventory will not be applied to the block represented by
   * this block state up until {@link #update(boolean, boolean)} has been
   * called.
   *
   * @return the captured inventory snapshot
  */
  getSnapshotInventory(): Inventory;
}
export interface Container extends TileState, BlockInventoryHolder, Lockable, Nameable {}
/**
 * Represents a captured state of a campfire.
*/
export class Campfire extends TileState {
  /**
   * @return The size of the inventory
   * @see Inventory#getSize()
  */
  getSize(): number;
  /**
   * @param index The index of the Slot's ItemStack to return
   * @return The ItemStack in the slot
   * @see Inventory#getItem(int)
  */
  getItem(index: number): ItemStack | null;
  /**
   * @param index The index where to put the ItemStack
   * @param item The ItemStack to set
   * @see Inventory#setItem(int, org.bukkit.inventory.ItemStack)
  */
  setItem(index: number, item: ItemStack | null): void;
  /**
   * Get cook time.
   *
   * This is the amount of time the item has been cooking for.
   *
   * @param index item slot index
   * @return Cook time
  */
  getCookTime(index: number): number;
  /**
   * Set cook time.
   *
   * This is the amount of time the item has been cooking for.
   *
   * @param index item slot index
   * @param cookTime Cook time
  */
  setCookTime(index: number, cookTime: number): void;
  /**
   * Get cook time total.
   *
   * This is the amount of time the item is required to cook for.
   *
   * @param index item slot index
   * @return Cook time total
  */
  getCookTimeTotal(index: number): number;
  /**
   * Set cook time.
   *
   * This is the amount of time the item is required to cook for.
   *
   * @param index item slot index
   * @param cookTimeTotal Cook time total
  */
  setCookTimeTotal(index: number, cookTimeTotal: number): void;
  /**
   * Disable cooking in all slots.
  */
  stopCooking(): void;
  /**
   * Re-enable cooking in all slots.
  */
  startCooking(): void;
  /**
   * Disable cooking in the specified slot index.
   *
   * @param index item slot index
   * @return whether the slot had cooking enabled before this call
  */
  stopCooking(index: number): boolean;
  /**
   * Re-enable cooking in the specified slot index.
   *
   * @param index item slot index
   * @return whether the slot couldn't cook before this call
  */
  startCooking(index: number): boolean;
  /**
   * State of slot index.
   *
   * @param index item slot index
   * @return `true` if the specified slot index cannot cook
  */
  isCookingDisabled(index: number): boolean;
}
/**
 * Represents a captured state of a jukebox.
*/
export class Jukebox extends TileState {
  /**
   * Gets the record inserted into the jukebox.
   *
   * @return The record Material, or AIR if none is inserted
  */
  getPlaying(): Material;
  /**
   * Sets the record being played.
   *
   * @param record The record Material, or null/AIR to stop playing
  */
  setPlaying(playing: Material | null);
  /**
   * Gets the record item inserted into the jukebox.
   *
   * @return a copy of the inserted record, or an air stack if none
  */
  getRecord(): ItemStack;
  /**
   * Sets the record being played.
   *
   * @param record the record to insert or null/AIR to empty
  */
  setRecord(record: ItemStack | null);
  /**
   * Checks if the jukebox is playing a record.
   *
   * @return True if there is a record playing
  */
  isPlaying(): boolean;
  /**
   * Stops the jukebox playing without ejecting the record.
  */
  stopPlaying(): void;
  /**
   * Stops the jukebox playing and ejects the current record.
   * 
   * If the block represented by this state is no longer a jukebox, this will
   * do nothing and return false.
   *
   * @return True if a record was ejected; false if there was none playing
   * @throws IllegalStateException if this block state is not placed
  */
  eject(): boolean;
}
/**
 * Holds all accepted Biomes in the default server
*/
export class Biome extends Enum<Biome> {
  static readonly OCEAN: Biome;
  static readonly PLAINS: Biome;
  static readonly DESERT: Biome;
  static readonly WINDSWEPT_HILLS: Biome;
  static readonly FOREST: Biome;
  static readonly TAIGA: Biome;
  static readonly SWAMP: Biome;
  static readonly RIVER: Biome;
  static readonly NETHER_WASTES: Biome;
  static readonly THE_END: Biome;
  static readonly FROZEN_OCEAN: Biome;
  static readonly FROZEN_RIVER: Biome;
  static readonly SNOWY_PLAINS: Biome;
  static readonly MUSHROOM_FIELDS: Biome;
  static readonly BEACH: Biome;
  static readonly JUNGLE: Biome;
  static readonly SPARSE_JUNGLE: Biome;
  static readonly DEEP_OCEAN: Biome;
  static readonly STONY_SHORE: Biome;
  static readonly SNOWY_BEACH: Biome;
  static readonly BIRCH_FOREST: Biome;
  static readonly DARK_FOREST: Biome;
  static readonly SNOWY_TAIGA: Biome;
  static readonly OLD_GROWTH_PINE_TAIGA: Biome;
  static readonly WINDSWEPT_FOREST: Biome;
  static readonly SAVANNA: Biome;
  static readonly SAVANNA_PLATEAU: Biome;
  static readonly BADLANDS: Biome;
  static readonly WOODED_BADLANDS: Biome;
  static readonly SMALL_END_ISLANDS: Biome;
  static readonly END_MIDLANDS: Biome;
  static readonly END_HIGHLANDS: Biome;
  static readonly END_BARRENS: Biome;
  static readonly WARM_OCEAN: Biome;
  static readonly LUKEWARM_OCEAN: Biome;
  static readonly COLD_OCEAN: Biome;
  static readonly DEEP_LUKEWARM_OCEAN: Biome;
  static readonly DEEP_COLD_OCEAN: Biome;
  static readonly DEEP_FROZEN_OCEAN: Biome;
  static readonly THE_VOID: Biome;
  static readonly SUNFLOWER_PLAINS: Biome;
  static readonly WINDSWEPT_GRAVELLY_HILLS: Biome;
  static readonly FLOWER_FOREST: Biome;
  static readonly ICE_SPIKES: Biome;
  static readonly OLD_GROWTH_BIRCH_FOREST: Biome;
  static readonly OLD_GROWTH_SPRUCE_TAIGA: Biome;
  static readonly WINDSWEPT_SAVANNA: Biome;
  static readonly ERODED_BADLANDS: Biome;
  static readonly BAMBOO_JUNGLE: Biome;
  static readonly SOUL_SAND_VALLEY: Biome;
  static readonly CRIMSON_FOREST: Biome;
  static readonly WARPED_FOREST: Biome;
  static readonly BASALT_DELTAS: Biome;
  static readonly DRIPSTONE_CAVES: Biome;
  static readonly LUSH_CAVES: Biome;
  static readonly MEADOW: Biome;
  static readonly GROVE: Biome;
  static readonly SNOWY_SLOPES: Biome;
  static readonly FROZEN_PEAKS: Biome;
  static readonly JAGGED_PEAKS: Biome;
  static readonly STONY_PEAKS: Biome;
  /**
   * Represents a custom Biome
  */
  static readonly CUSTOM: Biome;
  static valueOf(name: string): Biome;
  static values(): Biome[];
  getKey(): NamespacedKey;
}
/**
 * Represents a captured state of a command block.
*/
export class CommandBlock extends TileState {
  /**
   * Gets the command that this CommandBlock will run when powered.
   * This will never return null.  If the CommandBlock does not have a
   * command, an empty String will be returned instead.
   *
   * @return Command that this CommandBlock will run when powered.
  */
  getCommand(): string;
  /**
   * Sets the command that this CommandBlock will run when powered.
   * Setting the command to null is the same as setting it to an empty
   * String.
   *
   * @param command Command that this CommandBlock will run when powered.
  */
  setCommand(command: string | null);
  /**
   * Gets the name of this CommandBlock.  The name is used with commands
   * that this CommandBlock executes.  This name will never be null, and
   * by default is "@".
   *
   * @return Name of this CommandBlock.
   * @deprecated in favour of {@link #name()}
  */
  getName(): string;
  /**
   * Sets the name of this CommandBlock.  The name is used with commands
   * that this CommandBlock executes.  Setting the name to null is the
   * same as setting it to "@".
   *
   * @param name New name for this CommandBlock.
   * @deprecated in favour of {@link #name(net.kyori.adventure.text.Component)}
  */
  setName(name: string | null): void;
  /**
   * Sets the name of this CommandBlock.  The name is used with commands
   * that this CommandBlock executes.  Setting the name to null is the
   * same as setting it to a {@link net.kyori.adventure.text.TextComponent} containing `@`.
   *
   * @param name New name for this CommandBlock.
  */
  name(name: Component | null): void;
}
export interface CommandBlock extends TileState, CommandBlockHolder {}
/**
 * Represents a captured state of a bee hive.
*/
export class Beehive extends EntityBlockStorage<Bee> {
  /**
   * Get the hive's flower location.
   *
   * @return flower location or null
  */
  getFlower(): Location | null;
  /**
   * Set the hive's flower location.
   *
   * @param location or null
  */
  setFlower(flower: Location | null);
  /**
   * Check if the hive is sedated due to smoke from a nearby campfire.
   *
   * @return True if hive is sedated
  */
  isSedated(): boolean;
}
/**
 * Represents a captured state of a bed.
 * @deprecated does not provide useful information beyond the material itself
*/
export class Bed extends TileState {

}
export interface Bed extends TileState, Colorable {}
/**
 * Represents a captured state of a furnace.
*/
export class Furnace extends Container {
  /**
   * Get burn time.
   *
   * @return Burn time
  */
  getBurnTime(): number;
  /**
   * Set burn time.
   *
   * A burn time greater than 0 will cause this block to be lit, whilst a time
   * less than 0 will extinguish it.
   *
   * @param burnTime Burn time
  */
  setBurnTime(burnTime: number);
  /**
   * Get cook time.
   *
   * This is the amount of time the item has been cooking for.
   *
   * @return Cook time
  */
  getCookTime(): number;
  /**
   * Set cook time.
   *
   * This is the amount of time the item has been cooking for.
   *
   * @param cookTime Cook time
  */
  setCookTime(cookTime: number);
  /**
   * Get cook time total.
   *
   * This is the amount of time the item is required to cook for.
   *
   * @return Cook time total
  */
  getCookTimeTotal(): number;
  /**
   * Set cook time.
   *
   * This is the amount of time the item is required to cook for.
   *
   * @param cookTimeTotal Cook time total
  */
  setCookTimeTotal(cookTimeTotal: number);
  /**
   * Get the recipes used in this furnace.
   *
   * Note: These recipes used are reset when the result item is
   * manually taken from the furnace.
   *
   * @return An immutable map with the recipes used and the times used
  */
  getRecipesUsed(): Map<CookingRecipe<any>, number>;
  /**
   * Gets the cook speed multiplier that this {@link Furnace} will cook
   * compared to vanilla.
   *
   * @return the multiplier, a value between 0 and 200
  */
  getCookSpeedMultiplier(): number;
  /**
   * Sets the speed multiplier that this {@link Furnace} will cook
   * compared to vanilla.
   *
   * @param multiplier the multiplier to set, a value between 0 and 200
   * @throws IllegalArgumentException if value is less than 0
   * @throws IllegalArgumentException if value is more than 200
  */
  setCookSpeedMultiplier(cookSpeedMultiplier: number);
  /**
   * Gets the number of times a recipe has been used since the
   * last player removed items from the result slot. This is used
   * to calculate experience rewards when withdrawing items from furnaces.
   *
   * @param furnaceRecipe the recipe to query the count for
   * @return the count or 0 if none found
  */
  getRecipeUsedCount(furnaceRecipe: NamespacedKey): number;
  /**
   * Checks if the recipe has a used count present on this furnace.
   *
   * @param furnaceRecipe the recipe to check if a count exists for
   * @return true if there is a positive count, else false
  */
  hasRecipeUsedCount(furnaceRecipe: NamespacedKey): boolean;
  /**
   * Sets the number of times a recipe has been used. This is used
   * to calculate experience rewards when withdrawing items from furnaces.
   *
   * @param furnaceRecipe the recipe to set the count for
   * @param count the count, a non-positive number will remove the recipe
  */
  setRecipeUsedCount(furnaceRecipe: CookingRecipe<any>, count: number): void;
  /**
   * Sets all recipes used by this furnace.
   *
   * @param recipesUsed the recipes used
  */
  setRecipesUsed(recipesUsed: Map<CookingRecipe<any>, number>);
  getInventory(): FurnaceInventory;
  getSnapshotInventory(): FurnaceInventory;
}
export class Hopper extends Container {

}
export interface Hopper extends Container, LootableBlockInventory {}
/**
 * Represents a captured state of a banner.
*/
export class Banner extends TileState {
  /**
   * Returns the base color for this banner
   *
   * @return the base color
  */
  getBaseColor(): DyeColor;
  /**
   * Sets the base color for this banner.
   * Only valid for shield pseudo banners, otherwise base depends on block
   * type
   *
   * @param color the base color
  */
  setBaseColor(baseColor: DyeColor);
  /**
   * Returns a list of patterns on this banner
   *
   * @return the patterns
  */
  getPatterns(): Pattern[];
  /**
   * Sets the patterns used on this banner
   *
   * @param patterns the new list of patterns
  */
  setPatterns(patterns: Pattern[]);
  /**
   * Adds a new pattern on top of the existing
   * patterns
   *
   * @param pattern the new pattern to add
  */
  addPattern(pattern: Pattern): void;
  /**
   * Returns the pattern at the specified index
   *
   * @param i the index
   * @return the pattern
  */
  getPattern(i: number): Pattern;
  /**
   * Removes the pattern at the specified index
   *
   * @param i the index
   * @return the removed pattern
  */
  removePattern(i: number): Pattern;
  /**
   * Sets the pattern at the specified index
   *
   * @param i       the index
   * @param pattern the new pattern
  */
  setPattern(i: number, pattern: Pattern): void;
  /**
   * Returns the number of patterns on this
   * banner
   *
   * @return the number of patterns
  */
  numberOfPatterns(): number;
}
/**
 * Represents a captured state of a block which stores entities.
 *
 * @param  Entity this block can store
*/
export class EntityBlockStorage<T> extends TileState {
  /**
   * Check if the block is completely full of entities.
   *
   * @return True if block is full
  */
  isFull(): boolean;
  /**
   * Get the amount of entities currently in this block.
   *
   * @return Amount of entities currently in this block
  */
  getEntityCount(): number;
  /**
   * Get the maximum amount of entities this block can hold.
   *
   * @return Maximum amount of entities this block can hold
  */
  getMaxEntities(): number;
  /**
   * Set the maximum amount of entities this block can hold.
   *
   * @param max Maximum amount of entities this block can hold
  */
  setMaxEntities(maxEntities: number);
  /**
   * Release all the entities currently stored in the block.
   *
   * @return List of all entities which were released
  */
  releaseEntities(): T[];
  /**
   * Add an entity to the block.
   *
   * @param entity Entity to add to the block
  */
  addEntity(entity: T): void;
  /**
   * Clear all currently stored entities in the block.
  */
  clearEntities(): void;
}
/**
 * Represents the face of a block
*/
export class BlockFace extends Enum<BlockFace> {
  static readonly NORTH: BlockFace;
  static readonly EAST: BlockFace;
  static readonly SOUTH: BlockFace;
  static readonly WEST: BlockFace;
  static readonly UP: BlockFace;
  static readonly DOWN: BlockFace;
  static readonly NORTH_EAST: BlockFace;
  static readonly NORTH_WEST: BlockFace;
  static readonly SOUTH_EAST: BlockFace;
  static readonly SOUTH_WEST: BlockFace;
  static readonly WEST_NORTH_WEST: BlockFace;
  static readonly NORTH_NORTH_WEST: BlockFace;
  static readonly NORTH_NORTH_EAST: BlockFace;
  static readonly EAST_NORTH_EAST: BlockFace;
  static readonly EAST_SOUTH_EAST: BlockFace;
  static readonly SOUTH_SOUTH_EAST: BlockFace;
  static readonly SOUTH_SOUTH_WEST: BlockFace;
  static readonly WEST_SOUTH_WEST: BlockFace;
  static readonly SELF: BlockFace;
  static valueOf(name: string): BlockFace;
  static values(): BlockFace[];
  /**
   * Get the amount of X-coordinates to modify to get the represented block
   *
   * @return Amount of X-coordinates to modify
  */
  getModX(): number;
  /**
   * Get the amount of Y-coordinates to modify to get the represented block
   *
   * @return Amount of Y-coordinates to modify
  */
  getModY(): number;
  /**
   * Get the amount of Z-coordinates to modify to get the represented block
   *
   * @return Amount of Z-coordinates to modify
  */
  getModZ(): number;
  /**
   * Gets the normal vector corresponding to this block face.
   *
   * @return the normal vector
  */
  getDirection(): Vector;
  /**
   * Returns true if this face is aligned with one of the unit axes in 3D
   * Cartesian space (ie NORTH, SOUTH, EAST, WEST, UP, DOWN).
   *
   * @return Cartesian status
  */
  isCartesian(): boolean;
  getOppositeFace(): BlockFace;
}
/**
 * Represents a captured state of Bell.
*/
export class Bell extends TileState {

}
/**
 * Represents a captured state of an on / off comparator.
*/
export class Comparator extends TileState {

}
/**
 * Represents a captured state of a Barrel.
*/
export class Barrel extends Container {

}
export interface Barrel extends Container, Lootable, Lidded {}
/**
 * Represents a captured state of a chest.
*/
export class Chest extends Container {
  /**
   * Gets the inventory of the chest block represented by this block state.
   * 
   * If the chest is a double chest, it returns just the portion of the
   * inventory linked to the half of the chest corresponding to this block state.
   * 
   * If the block was changed to a different type in the meantime, the
   * returned inventory might no longer be valid.
   * 
   * If this block state is not placed this will return the captured
   * inventory snapshot instead.
   *
   * @return the inventory
  */
  getBlockInventory(): Inventory;
}
export interface Chest extends Container, LootableBlockInventory, Lidded {}

}
declare module 'org.bukkit.entity.Ocelot' {
import { Enum } from 'java.lang';
/**
 * Represents the various different cat types there are.
 *
 * @deprecated Cats are now a separate entity.
*/
export class Type extends Enum<Type> {
  static readonly WILD_OCELOT: Type;
  static readonly BLACK_CAT: Type;
  static readonly RED_CAT: Type;
  static readonly SIAMESE_CAT: Type;
  static valueOf(name: string): Type;
  static values(): Type[];
  /**
   * Gets the ID of this cat type.
   *
   * @return Type ID.
   * @deprecated Magic value
  */
  getId(): number;
  /**
   * Gets a cat type by its ID.
   *
   * @param id ID of the cat type to get.
   * @return Resulting type, or null if not found.
   * @deprecated Magic value
  */
  static getType(id: number): Type | null;
}

}
declare module 'org.bukkit.event.entity.CreatureSpawnEvent' {
import { Enum } from 'java.lang';
/**
 * An enum to specify the type of spawning
*/
export class SpawnReason extends Enum<SpawnReason> {
  /**
   * When something spawns from natural means
  */
  static readonly NATURAL: SpawnReason;
  /**
   * When an entity spawns as a jockey of another entity (mostly spider
   * jockeys)
  */
  static readonly JOCKEY: SpawnReason;
  /**
   * When a creature spawns due to chunk generation
   *
   * @deprecated no longer called, chunks are generated with entities
   * already existing. Consider using {@link ChunkLoadEvent},
   * {@link ChunkLoadEvent#isNewChunk()} and {@link Chunk#getEntities()}
   * for similar effect.
  */
  static readonly CHUNK_GEN: SpawnReason;
  /**
   * When a creature spawns from a spawner
  */
  static readonly SPAWNER: SpawnReason;
  /**
   * When a creature spawns from an egg
  */
  static readonly EGG: SpawnReason;
  /**
   * When a creature spawns from a Spawner Egg
  */
  static readonly SPAWNER_EGG: SpawnReason;
  /**
   * When a creature spawns because of a lightning strike
  */
  static readonly LIGHTNING: SpawnReason;
  /**
   * When a snowman is spawned by being built
  */
  static readonly BUILD_SNOWMAN: SpawnReason;
  /**
   * When an iron golem is spawned by being built
  */
  static readonly BUILD_IRONGOLEM: SpawnReason;
  /**
   * When a wither boss is spawned by being built
  */
  static readonly BUILD_WITHER: SpawnReason;
  /**
   * When an iron golem is spawned to defend a village
  */
  static readonly VILLAGE_DEFENSE: SpawnReason;
  /**
   * When a zombie is spawned to invade a village
  */
  static readonly VILLAGE_INVASION: SpawnReason;
  /**
   * When an animal breeds to create a child
  */
  static readonly BREEDING: SpawnReason;
  /**
   * When a slime splits
  */
  static readonly SLIME_SPLIT: SpawnReason;
  /**
   * When an entity calls for reinforcements
  */
  static readonly REINFORCEMENTS: SpawnReason;
  /**
   * When a creature is spawned by nether portal
  */
  static readonly NETHER_PORTAL: SpawnReason;
  /**
   * When a creature is spawned by a dispenser dispensing an egg
  */
  static readonly DISPENSE_EGG: SpawnReason;
  /**
   * When a zombie infects a villager
  */
  static readonly INFECTION: SpawnReason;
  /**
   * When a villager is cured from infection
  */
  static readonly CURED: SpawnReason;
  /**
   * When an ocelot has a baby spawned along with them
  */
  static readonly OCELOT_BABY: SpawnReason;
  /**
   * When a silverfish spawns from a block
  */
  static readonly SILVERFISH_BLOCK: SpawnReason;
  /**
   * When an entity spawns as a mount of another entity (mostly chicken
   * jockeys)
  */
  static readonly MOUNT: SpawnReason;
  /**
   * When an entity spawns as a trap for players approaching
  */
  static readonly TRAP: SpawnReason;
  /**
   * When an entity is spawned as a result of ender pearl usage
  */
  static readonly ENDER_PEARL: SpawnReason;
  /**
   * When an entity is spawned as a result of the entity it is being
   * perched on jumping or being damaged
  */
  static readonly SHOULDER_ENTITY: SpawnReason;
  /**
   * When a creature is spawned by another entity drowning
  */
  static readonly DROWNED: SpawnReason;
  /**
   * When an cow is spawned by shearing a mushroom cow
  */
  static readonly SHEARED: SpawnReason;
  /**
   * When eg an effect cloud is spawned as a result of a creeper exploding
  */
  static readonly EXPLOSION: SpawnReason;
  /**
   * When an entity is spawned as part of a raid
  */
  static readonly RAID: SpawnReason;
  /**
   * When an entity is spawned as part of a patrol
  */
  static readonly PATROL: SpawnReason;
  /**
   * When a bee is released from a beehive/bee nest
  */
  static readonly BEEHIVE: SpawnReason;
  /**
   * When a piglin is converted to a zombified piglin.
  */
  static readonly PIGLIN_ZOMBIFIED: SpawnReason;
  /**
   * When an entity is created by a cast spell.
  */
  static readonly SPELL: SpawnReason;
  /**
   * When an entity is shaking in Powder Snow and a new entity spawns.
  */
  static readonly FROZEN: SpawnReason;
  /**
   * When a creature is spawned by the "/summon" command
  */
  static readonly COMMAND: SpawnReason;
  /**
   * When a creature is spawned by plugins
  */
  static readonly CUSTOM: SpawnReason;
  /**
   * When an entity is missing a SpawnReason
  */
  static readonly DEFAULT: SpawnReason;
  static valueOf(name: string): SpawnReason;
  static values(): SpawnReason[];
}

}
declare module 'org.bukkit.profile' {
import { UUID } from 'java.util';
import { Cloneable } from 'java.lang';
import { URL } from 'java.net';
import { CompletableFuture } from 'java.util.concurrent';
import { ConfigurationSerializable } from 'org.bukkit.configuration.serialization';
import { SkinModel } from 'org.bukkit.profile.PlayerTextures';
/**
 * Provides access to the textures stored inside a {@link PlayerProfile}.
 * 
 * Modifying the textures immediately invalidates and clears any previously
 * present attributes that are specific to official player profiles, such as the
 * {@link #getTimestamp() timestamp} and {@link #isSigned() signature}.
*/
export class PlayerTextures {
  /**
   * Checks if the profile stores no textures.
   *
   * @return true if the profile stores no textures
  */
  isEmpty(): boolean;
  /**
   * Clears the textures.
  */
  clear(): void;
  /**
   * Gets the URL that points to the player's skin.
   *
   * @return the URL of the player's skin, or null if not set
  */
  getSkin(): URL | null;
  /**
   * Sets the player's skin to the specified URL, and the skin model to
   * {@link SkinModel#CLASSIC}.
   * 
   * The URL must point to the Minecraft texture server. Example URL:
   *      * http://textures.minecraft.net/texture/b3fbd454b599df593f57101bfca34e67d292a8861213d2202bb575da7fd091ac
   * 
   *
   * @param skinUrl the URL of the player's skin, or null to
   * unset it
  */
  setSkin(skin: URL | null);
  /**
   * Sets the player's skin and {@link SkinModel}.
   * 
   * The URL must point to the Minecraft texture server. Example URL:
   *      * http://textures.minecraft.net/texture/b3fbd454b599df593f57101bfca34e67d292a8861213d2202bb575da7fd091ac
   * 
   * 
   * A skin model of null results in {@link SkinModel#CLASSIC} to
   * be used.
   *
   * @param skinUrl the URL of the player's skin, or null to
   * unset it
   * @param skinModel the skin model, ignored if the skin URL is
   * null
  */
  setSkin(skinUrl: URL | null, skinModel: SkinModel | null): void;
  /**
   * Gets the model of the player's skin.
   * 
   * This returns {@link SkinModel#CLASSIC} if no skin is set.
   *
   * @return the model of the player's skin
  */
  getSkinModel(): SkinModel;
  /**
   * Gets the URL that points to the player's cape.
   *
   * @return the URL of the player's cape, or null if not set
  */
  getCape(): URL | null;
  /**
   * Sets the URL that points to the player's cape.
   * 
   * The URL must point to the Minecraft texture server. Example URL:
   *      * http://textures.minecraft.net/texture/2340c0e03dd24a11b15a8b33c2a7e9e32abb2051b2481d0ba7defd635ca7a933
   * 
   *
   * @param capeUrl the URL of the player's cape, or null to
   * unset it
  */
  setCape(cape: URL | null);
  /**
   * Gets the timestamp at which the profile was last updated.
   *
   * @return the timestamp, or 0 if unknown
  */
  getTimestamp(): number;
  /**
   * Checks if the textures are signed and the signature is valid.
   *
   * @return true if the textures are signed and the signature is
   * valid
  */
  isSigned(): boolean;
}
/**
 * A player profile.
 * 
 * A player profile always provides a unique id, a non-empty name, or both. Its
 * unique id and name are immutable, but other properties (such as its textures)
 * can be altered.
 * 
 * New profiles can be created via
 * {@link Server#createPlayerProfile(UUID, String)}.
 * @deprecated see {@link com.destroystokyo.paper.profile.PlayerProfile}
*/
export class PlayerProfile extends Cloneable {
  /**
   * Gets the player's unique id.
   *
   * @return the player's unique id, or null if not available
  */
  getUniqueId(): UUID | null;
  /**
   * Gets the player name.
   *
   * @return the player name, or null if not available
  */
  getName(): string | null;
  /**
   * Gets the {@link PlayerTextures} of this profile.
   *
   * @return the textures, not null
  */
  getTextures(): PlayerTextures;
  /**
   * Copies the given textures.
   *
   * @param textures the textures to copy, or null to clear the
   * textures
  */
  setTextures(textures: PlayerTextures | null);
  /**
   * Checks whether this profile is complete.
   * 
   * A profile is currently considered complete if it has a name, a unique id,
   * and textures.
   *
   * @return true if this profile is complete
  */
  isComplete(): boolean;
  /**
   * Produces an updated player profile based on this profile.
   * 
   * This tries to produce a completed profile by filling in missing
   * properties (name, unique id, textures, etc.), and updates existing
   * properties (e.g. name, textures, etc.) to their official and up-to-date
   * values. This operation does not alter the current profile, but produces a
   * new updated {@link PlayerProfile}.
   * 
   * If no player exists for the unique id or name of this profile, this
   * operation yields a profile that is equal to the current profile, which
   * might not be complete.
   * 
   * This is an asynchronous operation: Updating the profile can result in an
   * outgoing connection in another thread in order to fetch the latest
   * profile properties. The returned {@link CompletableFuture} will be
   * completed once the updated profile is available. In order to not block
   * the server's main thread, you should not wait for the result of the
   * returned CompletableFuture on the server's main thread. Instead, if you
   * want to do something with the updated player profile on the server's main
   * thread once it is available, you could do something like this:
   *      * profile.update().thenAcceptAsync(updatedProfile -> {
   *     // Do something with the updated profile:
   *     // ...
   * }, runnable -> Bukkit.getScheduler().runTask(plugin, runnable));
   * 
   *
   * @return a completable future that gets completed with the updated
   * PlayerProfile once it is available
  */
  update(): CompletableFuture<PlayerProfile>;
  clone(): PlayerProfile;
}
export interface PlayerProfile extends Cloneable, ConfigurationSerializable {}

}
declare module 'org.bukkit.generator' {
import { Random, List, UUID } from 'java.util';
import { BlockState, Biome } from 'org.bukkit.block';
import { Environment } from 'org.bukkit.World';
import { Vector } from 'org.bukkit.util';
import { BlockData } from 'org.bukkit.block.data';
import { ChunkData, BiomeGrid } from 'org.bukkit.generator.ChunkGenerator';
import { HeightMap, RegionAccessor, World, Chunk, Location } from 'org.bukkit';
/**
 * A chunk generator is responsible for the initial shaping of an entire
 * chunk. For example, the nether chunk generator should shape netherrack and
 * soulsand.
 *
 * A chunk is generated in multiple steps, those steps are always in the same
 * order. Between those steps however an unlimited time may pass. This means, a
 * chunk may generated until the surface step and continue with the bedrock step
 * after one or multiple server restarts or even after multiple Minecraft
 * versions.
 *
 * The order of generation is as follows
 * 
 * {@link #generateNoise(WorldInfo, Random, int, int, ChunkData)}
 * {@link #generateSurface(WorldInfo, Random, int, int, ChunkData)}
 * {@link #generateBedrock(WorldInfo, Random, int, int, ChunkData)}
 * {@link #generateCaves(WorldInfo, Random, int, int, ChunkData)}
 * 
 *
 * Every method listed above as well as
 * {@link #getBaseHeight(WorldInfo, Random, int, int, HeightMap)}
 * must be completely thread safe and able to handle multiple concurrent
 * callers.
 *
 * Some aspects of world generation can be delegated to the Vanilla generator.
 * The following methods can be overridden to enable this:
 * 
 * {@link ChunkGenerator#shouldGenerateNoise()}
 * {@link ChunkGenerator#shouldGenerateSurface()}
 * {@link ChunkGenerator#shouldGenerateBedrock()}
 * {@link ChunkGenerator#shouldGenerateCaves()}
 * {@link ChunkGenerator#shouldGenerateDecorations()}
 * {@link ChunkGenerator#shouldGenerateMobs()}
 * {@link ChunkGenerator#shouldGenerateStructures()}
 * 
*/
export class ChunkGenerator {
  /**
   * Shapes the Chunk noise for the given coordinates.
   * 
   * Notes:
   * 
   * This method should never attempt to get the Chunk at the passed
   * coordinates, as doing so may cause an infinite loop.
   * 
   * This method should never modify the {@link ChunkData} at a later
   * point of time.
   * 
   * The Y-coordinate range should never be hardcoded, to get the
   * Y-coordinate range use the methods {@link ChunkData#getMinHeight()} and
   * {@link ChunkData#getMaxHeight()}.
   * 
   * If {@link #shouldGenerateNoise()} is set to true, the given
   * {@link ChunkData} contains already the Vanilla noise generation.
   *
   * @param worldInfo The world info of the world this chunk will be used for
   * @param random The random generator to use
   * @param chunkX The X-coordinate of the chunk
   * @param chunkZ The Z-coordinate of the chunk
   * @param chunkData To modify
  */
  generateNoise(worldInfo: WorldInfo, random: Random, chunkX: number, chunkZ: number, chunkData: ChunkData): void;
  /**
   * Shapes the Chunk surface for the given coordinates.
   * 
   * Notes:
   * 
   * This method should never attempt to get the Chunk at the passed
   * coordinates, as doing so may cause an infinite loop.
   * 
   * This method should never modify the {@link ChunkData} at a later
   * point of time.
   * 
   * The Y-coordinate range should never be hardcoded, to get the
   * Y-coordinate range use the methods {@link ChunkData#getMinHeight()} and
   * {@link ChunkData#getMaxHeight()}.
   * 
   * If {@link #shouldGenerateSurface()} is set to true, the given
   * {@link ChunkData} contains already the Vanilla surface generation.
   *
   * @param worldInfo The world info of the world this chunk will be used for
   * @param random The random generator to use
   * @param chunkX The X-coordinate of the chunk
   * @param chunkZ The Z-coordinate of the chunk
   * @param chunkData To modify
  */
  generateSurface(worldInfo: WorldInfo, random: Random, chunkX: number, chunkZ: number, chunkData: ChunkData): void;
  /**
   * Shapes the Chunk bedrock layer for the given coordinates.
   * 
   * Notes:
   * 
   * This method should never attempt to get the Chunk at the passed
   * coordinates, as doing so may cause an infinite loop.
   * 
   * This method should never modify the {@link ChunkData} at a later
   * point of time.
   * 
   * The Y-coordinate range should never be hardcoded, to get the
   * Y-coordinate range use the methods {@link ChunkData#getMinHeight()} and
   * {@link ChunkData#getMaxHeight()}.
   * 
   * If {@link #shouldGenerateBedrock()} is set to true, the given
   * {@link ChunkData} contains already the Vanilla bedrock generation.
   *
   * @param worldInfo The world info of the world this chunk will be used for
   * @param random The random generator to use
   * @param chunkX The X-coordinate of the chunk
   * @param chunkZ The Z-coordinate of the chunk
   * @param chunkData To modify
  */
  generateBedrock(worldInfo: WorldInfo, random: Random, chunkX: number, chunkZ: number, chunkData: ChunkData): void;
  /**
   * Shapes the Chunk caves for the given coordinates.
   * 
   * Notes:
   * 
   * This method should never attempt to get the Chunk at the passed
   * coordinates, as doing so may cause an infinite loop.
   * 
   * This method should never modify the {@link ChunkData} at a later
   * point of time.
   * 
   * The Y-coordinate range should never be hardcoded, to get the
   * Y-coordinate range use the methods {@link ChunkData#getMinHeight()} and
   * {@link ChunkData#getMaxHeight()}.
   * 
   * If {@link #shouldGenerateCaves()} is set to true, the given
   * {@link ChunkData} contains already the Vanilla cave generation.
   *
   * @param worldInfo The world info of the world this chunk will be used for
   * @param random The random generator to use
   * @param chunkX The X-coordinate of the chunk
   * @param chunkZ The Z-coordinate of the chunk
   * @param chunkData To modify
  */
  generateCaves(worldInfo: WorldInfo, random: Random, chunkX: number, chunkZ: number, chunkData: ChunkData): void;
  /**
   * Gets called when no {@link BiomeProvider} is set in
   * {@link org.bukkit.WorldCreator} or via the server configuration files. It
   * is therefore possible that one plugin can provide the Biomes and another
   * one the generation.
   * 
   * Notes:
   * 
   * If null is returned, than Vanilla biomes are used.
   * 
   * This method only gets called once when the world is loaded. Returning
   * another {@link BiomeProvider} later one is not respected.
   *
   * @param worldInfo The world info of the world the biome provider will be
   * used for
   * @return BiomeProvider to use to fill the biomes of a chunk
  */
  getDefaultBiomeProvider(worldInfo: WorldInfo): BiomeProvider | null;
  /**
   * This method is similar to
   * {@link World#getHighestBlockAt(int, int, HeightMap)}. With the difference
   * being, that the highest y coordinate should be the block before any
   * surface, bedrock, caves or decoration is applied. Or in other words the
   * highest block when only the noise is present at the chunk.
   * 
   * Notes:
   * 
   * When this method is not overridden, the Vanilla base height is used.
   * 
   * This method should never attempt to get the Chunk at the passed
   * coordinates, or use the method
   * {@link World#getHighestBlockAt(int, int, HeightMap)}, as doing so may
   * cause an infinite loop.
   *
   * @param worldInfo The world info of the world this chunk will be used for
   * @param random The random generator to use
   * @param x The X-coordinate from world origin
   * @param z The Z-coordinate from world origin
   * @param heightMap From the highest block should be get
   * @return The y coordinate of the highest block at the given location
  */
  getBaseHeight(worldInfo: WorldInfo, random: Random, x: number, z: number, heightMap: HeightMap): number;
  /**
   * Shapes the chunk for the given coordinates.
   *
   * This method must return a ChunkData.
   * 
   * Notes:
   * 
   * This method should never attempt to get the Chunk at
   * the passed coordinates, as doing so may cause an infinite loop
   * 
   * This method should never modify a ChunkData after it has
   * been returned.
   * 
   * This method must return a ChunkData returned by {@link ChunkGenerator#createChunkData(org.bukkit.World)}
   *
   * @param world The world this chunk will be used for
   * @param random The random generator to use
   * @param x The X-coordinate of the chunk
   * @param z The Z-coordinate of the chunk
   * @param biome Proposed biome values for chunk - can be updated by
   *     generator
   * @return ChunkData containing the types for each block created by this
   *     generator
   * @deprecated The generation is now split up and the new methods should be used, see {@link ChunkGenerator}
  */
  generateChunkData(world: World, random: Random, x: number, z: number, biome: BiomeGrid): ChunkData;
  /**
   * Tests if the specified location is valid for a natural spawn position
   *
   * @param world The world we're testing on
   * @param x X-coordinate of the block to test
   * @param z Z-coordinate of the block to test
   * @return true if the location is valid, otherwise false
  */
  canSpawn(world: World, x: number, z: number): boolean;
  /**
   * Gets a list of default {@link BlockPopulator}s to apply to a given
   * world
   *
   * @param world World to apply to
   * @return List containing any amount of BlockPopulators
  */
  getDefaultPopulators(world: World): BlockPopulator[];
  /**
   * Gets a fixed spawn location to use for a given world.
   * 
   * A null value is returned if a world should not use a fixed spawn point,
   * and will instead attempt to find one randomly.
   *
   * @param world The world to locate a spawn point for
   * @param random Random generator to use in the calculation
   * @return Location containing a new spawn point, otherwise null
  */
  getFixedSpawnLocation(world: World, random: Random): Location | null;
  /**
   * Gets if this ChunkGenerator is parallel capable.
   *
   * See {@link ChunkGenerator} for more information.
   *
   * @return parallel capable status
   * @deprecated the chunk generation code should be thread safe
  */
  isParallelCapable(): boolean;
  /**
   * Gets if the server should generate Vanilla noise.
   * 
   * The Vanilla noise is generated before
   * {@link #generateNoise(WorldInfo, Random, int, int, ChunkData)} is called.
   *
   * @return true if the server should generate Vanilla noise
  */
  shouldGenerateNoise(): boolean;
  /**
   * Gets if the server should generate Vanilla surface.
   * 
   * The Vanilla surface is generated before
   * {@link #generateSurface(WorldInfo, Random, int, int, ChunkData)} is
   * called.
   *
   * @return true if the server should generate Vanilla surface
  */
  shouldGenerateSurface(): boolean;
  /**
   * Gets if the server should generate Vanilla bedrock.
   * 
   * The Vanilla bedrock is generated before
   * {@link #generateBedrock(WorldInfo, Random, int, int, ChunkData)} is
   * called.
   *
   * @return true if the server should generate Vanilla bedrock
  */
  shouldGenerateBedrock(): boolean;
  /**
   * Gets if the server should generate Vanilla caves.
   * 
   * The Vanilla caves are generated before
   * {@link #generateCaves(WorldInfo, Random, int, int, ChunkData)} is called.
   *
   * @return true if the server should generate Vanilla caves
  */
  shouldGenerateCaves(): boolean;
  /**
   * Gets if the server should generate Vanilla decorations after this
   * ChunkGenerator.
   * 
   * The Vanilla decoration are generated before any
   * {@link BlockPopulator} are called.
   *
   * @return true if the server should generate Vanilla decorations
  */
  shouldGenerateDecorations(): boolean;
  /**
   * Gets if the server should generate Vanilla mobs after this
   * ChunkGenerator.
   *
   * @return true if the server should generate Vanilla mobs
  */
  shouldGenerateMobs(): boolean;
  /**
   * Gets if the server should generate Vanilla structures after this
   * ChunkGenerator.
   *
   * @return true if the server should generate Vanilla structures
  */
  shouldGenerateStructures(): boolean;
  /**
   * Create a ChunkData for use in a generator, that is populated by the vanilla generator for that world
   *
   * @param world the world to create the ChunkData for
   * @param x the x coordinate of the chunk
   * @param z the z coordinate of the chunk
   * @return a new ChunkData for the world
   *
  */
  createVanillaChunkData(world: World, x: number, z: number): ChunkData;
}
/**
 * A limited region is used in world generation for features which are
 * going over a chunk. For example, trees or ores.
 *
 * Use {@link #getBuffer()} to know how much you can go beyond the central
 * chunk. The buffer zone may or may not be already populated.
 *
 * The coordinates are absolute from the world origin.
*/
export class LimitedRegion extends RegionAccessor {
  /**
   * Gets the buffer around the central chunk which is accessible.
   * The returned value is in normal world coordinate scale.
   * 
   * For example: If the method returns 16 you have a working area of 48x48.
   *
   * @return The buffer in X and Z direction
  */
  getBuffer(): number;
  /**
   * Checks if the given {@link Location} is in the region.
   *
   * @param location the location to check
   * @return true if the location is in the region, otherwise false.
  */
  isInRegion(location: Location): boolean;
  /**
   * Checks if the given coordinates are in the region.
   *
   * @param x X-coordinate to check
   * @param y Y-coordinate to check
   * @param z Z-coordinate to check
   * @return true if the coordinates are in the region, otherwise false.
  */
  isInRegion(x: number, y: number, z: number): boolean;
  /**
   * Gets a list of all tile entities in the limited region including the
   * buffer zone.
   *
   * @return a list of tile entities.
  */
  getTileEntities(): BlockState[];
  /**
   * Sets the block at a vector location to the provided {@link BlockData}.
   *
   * @param vector {@link Vector} representing the position of the block to set.
   * @param data   {@link BlockData} to set the block at the provided coordinates to.
  */
  setBlockData(vector: Vector, data: BlockData): void;
  /**
   * Sets the {@link BlockState} at a location.
   *
   * @param x X coordinate.
   * @param y Y coordinate.
   * @param z Z coordinate.
   * @param state The block state.
  */
  setBlockState(x: number, y: number, z: number, state: BlockState): void;
  /**
   * Sets the {@link BlockState} at a location.
   *
   * @param location Location to set block state.
   * @param state The block state.
  */
  setBlockState(location: Vector, state: BlockState): void;
  /**
   * Gets the {@link BlockState} at a location.
   *
   * @param location Location to get block state from.
   * @return The block state.
  */
  getBlockState(location: Vector): BlockState;
  /**
   * Schedules a block update at (x, y, z).
   *
   * @param x X coordinate
   * @param y Y coordinate
   * @param z Z coordinate
  */
  scheduleBlockUpdate(x: number, y: number, z: number): void;
  /**
   * Schedules a block update at a vector location.
   *
   * @param location {@link Vector} representing the position of the block to update.
  */
  scheduleBlockUpdate(location: Vector): void;
  /**
   * Schedules a fluid update at (x, y, z).
   *
   * @param x X coordinate
   * @param y Y coordinate
   * @param z Z coordinate
  */
  scheduleFluidUpdate(x: number, y: number, z: number): void;
  /**
   * Schedules a fluid update at a vector location.
   *
   * @param location {@link Vector} representing the position of the block to update.
  */
  scheduleFluidUpdate(location: Vector): void;
  /**
   * Gets the {@link World} object this region represents.
   * 
   * Do not attempt to read from/write to this world! Doing so during generation will cause a deadlock!
   *
   * @return The {@link World} object that this region represents.
  */
  getWorld(): World;
  /**
   * Gets the {@link BlockData} of the block at the provided coordinates.
   *
   * @param vector {@link Vector} representing the position of the block to get.
   * @return {@link BlockData} at the coordinates
  */
  getBlockData(vector: Vector): BlockData;
  /**
   * Gets the X-coordinate of the chunk in the center of the region.
   *
   * @return The center chunk's X coordinate.
  */
  getCenterChunkX(): number;
  /**
   * Gets the X-coordinate of the block in the center of the region.
   *
   * @return The center chunk's X coordinate.
  */
  getCenterBlockX(): number;
  /**
   * Gets the Z-coordinate of the chunk in the center of the region.
   *
   * @return The center chunk's Z coordinate.
  */
  getCenterChunkZ(): number;
  /**
   * Gets the Z-coordinate of the block in the center of the region.
   *
   * @return The center chunk's Z coordinate.
  */
  getCenterBlockZ(): number;
  /**
   * Gets the {@link BlockState} at the given {@link Location}.
   *
   * @param location The location of the block state
   * @return Block state at the given location
  */
  getBlockState(location: Location): BlockState;
  /**
   * Gets the {@link BlockState} at the given coordinates.
   *
   * @param x X-coordinate of the block state
   * @param y Y-coordinate of the block state
   * @param z Z-coordinate of the block state
   * @return Block state at the given coordinates
  */
  getBlockState(x: number, y: number, z: number): BlockState;
  /**
   * Gets the {@link BlockData} at the given {@link Location}.
   *
   * @param location The location of the block data
   * @return Block data at the given location
  */
  getBlockData(location: Location): BlockData;
  /**
   * Gets the {@link BlockData} at the given coordinates.
   *
   * @param x X-coordinate of the block data
   * @param y Y-coordinate of the block data
   * @param z Z-coordinate of the block data
   * @return Block data at the given coordinates
  */
  getBlockData(x: number, y: number, z: number): BlockData;
  /**
   * Sets the {@link BlockData} at the given {@link Location}.
   *
   * @param location The location of the block
   * @param blockData The block data to set the block to
  */
  setBlockData(location: Location, blockData: BlockData): void;
  /**
   * Sets the {@link BlockData} at the given coordinates.
   *
   * @param x X-coordinate of the block
   * @param y Y-coordinate of the block
   * @param z Z-coordinate of the block
   * @param blockData The block data to set the block to
  */
  setBlockData(x: number, y: number, z: number, blockData: BlockData): void;
}
/**
 * A block populator is responsible for generating a small area of blocks.
 * 
 * For example, generating glowstone inside the nether or generating dungeons
 * full of treasure
 * 
 * A BlockPopulator can be used in combination with a custom {@link ChunkGenerator}
 * by returning it in the method {@link ChunkGenerator#getDefaultPopulators(World)}
 * or by adding it manually to the worlds populator list returned by {@link World#getPopulators()}.
 * 
 * When adding a BlockPopulator manually to a world it is recommended to do so during
 * the {@link WorldInitEvent}.
*/
export class BlockPopulator {
  /**
   * Populates an area of blocks at or around the given chunk.
   * 
   * The chunks on each side of the specified chunk must already exist; that
   * is, there must be one north, east, south and west of the specified
   * chunk. The "corner" chunks may not exist, in which scenario the
   * populator should record any changes required for those chunks and
   * perform the changes when they are ready.
   *
   * @param world The world to generate in
   * @param random The random generator to use
   * @param source The chunk to generate for
   * @deprecated Use {@link #populate(WorldInfo, Random, int, int, LimitedRegion)}
  */
  populate(world: World, random: Random, source: Chunk): void;
  /**
   * Populates an area of blocks at or around the given chunk.
   * 
   * Notes:
   * 
   * This method should never attempt to get the Chunk at the passed
   * coordinates, as doing so may cause an infinite loop
   * 
   * This method should never modify a {@link LimitedRegion} at a later
   * point of time.
   * 
   * This method must be completely thread safe and able to handle
   * multiple concurrent callers.
   * 
   * No physics are applied, whether or not it is set to true in
   * {@link org.bukkit.block.BlockState#update(boolean, boolean)}
   * 
   * Only use the {@link org.bukkit.block.BlockState} returned by
   * {@link LimitedRegion},
   * never use methods from a {@link World} to modify the chunk.
   *
   * @param worldInfo The world info of the world to generate in
   * @param random The random generator to use
   * @param chunkX The X-coordinate of the chunk
   * @param chunkZ The Z-coordinate of the chunk
   * @param limitedRegion The chunk region to populate
  */
  populate(worldInfo: WorldInfo, random: Random, chunkX: number, chunkZ: number, limitedRegion: LimitedRegion): void;
}
/**
 * Class for providing biomes.
*/
export class BiomeProvider {
  /**
   * Return the Biome which should be present at the provided location.
   * 
   * Notes:
   * 
   * This method must be completely thread safe and able to handle
   * multiple concurrent callers.
   * 
   * This method should only return biomes which are present in the list
   * returned by {@link #getBiomes(WorldInfo)}
   * 
   * This method should never return {@link Biome#CUSTOM}.
   *
   * @param worldInfo The world info of the world the biome will be used for
   * @param x The X-coordinate from world origin
   * @param y The Y-coordinate from world origin
   * @param z The Z-coordinate from world origin
   * @return Biome for the given location
  */
  getBiome(worldInfo: WorldInfo, x: number, y: number, z: number): Biome;
  /**
   * Returns a list with every biome the {@link BiomeProvider} will use for
   * the given world.
   * 
   * Notes:
   * 
   * This method only gets called once, when the world is loaded. Returning
   * another list or modifying the values from the initial returned list later
   * one, are not respected.
   * 
   * This method should never return a list which contains
   * {@link Biome#CUSTOM}.
   *
   * @param worldInfo The world info of the world the list will be used for
   * @return A list with every biome the {@link BiomeProvider} uses
  */
  getBiomes(worldInfo: WorldInfo): Biome[];
}
/**
 * Holds various information of a World
*/
export class WorldInfo {
  /**
   * Gets the unique name of this world
   *
   * @return Name of this world
  */
  getName(): string;
  /**
   * Gets the Unique ID of this world
   *
   * @return Unique ID of this world.
  */
  getUID(): UUID;
  /**
   * Gets the {@link World.Environment} type of this world
   *
   * @return This worlds Environment type
  */
  getEnvironment(): Environment;
  /**
   * Gets the Seed for this world.
   *
   * @return This worlds Seed
  */
  getSeed(): number;
  /**
   * Gets the minimum height of this world.
   * 
   * If the min height is 0, there are only blocks from y=0.
   *
   * @return Minimum height of the world
  */
  getMinHeight(): number;
  /**
   * Gets the maximum height of this world.
   * 
   * If the max height is 100, there are only blocks from y=0 to y=99.
   *
   * @return Maximum height of the world
  */
  getMaxHeight(): number;
  /**
   * Get the vanilla {@link BiomeProvider} for this world.
   *
   * @return vanilla biome provider
  */
  vanillaBiomeProvider(): BiomeProvider;
}

}
declare module 'org.bukkit.event.block.BlockIgniteEvent' {
import { Enum } from 'java.lang';
/**
 * An enum to specify the cause of the ignite
*/
export class IgniteCause extends Enum<IgniteCause> {
  /**
   * Block ignition caused by lava.
  */
  static readonly LAVA: IgniteCause;
  /**
   * Block ignition caused by a player or dispenser using flint-and-steel.
  */
  static readonly FLINT_AND_STEEL: IgniteCause;
  /**
   * Block ignition caused by dynamic spreading of fire.
  */
  static readonly SPREAD: IgniteCause;
  /**
   * Block ignition caused by lightning.
  */
  static readonly LIGHTNING: IgniteCause;
  /**
   * Block ignition caused by an entity using a fireball.
  */
  static readonly FIREBALL: IgniteCause;
  /**
   * Block ignition caused by an Ender Crystal.
  */
  static readonly ENDER_CRYSTAL: IgniteCause;
  /**
   * Block ignition caused by explosion.
  */
  static readonly EXPLOSION: IgniteCause;
  /**
   * Block ignition caused by a flaming arrow.
  */
  static readonly ARROW: IgniteCause;
  static valueOf(name: string): IgniteCause;
  static values(): IgniteCause[];
}

}
declare module 'org.bukkit.plugin.java' {
import { Logger } from 'java.util.logging';
import { Enumeration, Set, List, Map } from 'java.util';
import { Command, CommandSender, PluginCommand } from 'org.bukkit.command';
import { FileConfiguration } from 'org.bukkit.configuration.file';
import { BiomeProvider, ChunkGenerator } from 'org.bukkit.generator';
import { Server } from 'org.bukkit';
import { ReentrantReadWriteLock } from 'java.util.concurrent.locks';
import { IllegalStateException, ClassLoader, Class } from 'java.lang';
import { Pattern } from 'java.util.regex';
import { URLClassLoader, URL } from 'java.net';
import { InputStream, File } from 'java.io';
import { Listener, Event } from 'org.bukkit.event';
import { Manifest, JarFile } from 'java.util.jar';
import { PluginBase, PluginDescriptionFile, PluginLoader, RegisteredListener, Plugin } from 'org.bukkit.plugin';
/**
 * A ClassLoader for plugins, to allow shared classes across multiple plugins
*/
export class PluginClassLoader extends URLClassLoader {
  getPlugin(): JavaPlugin;
  getResource(name: string): URL;
  getResources(name: string): Enumeration<URL>;
  close(): void;
  toString(): string;
}
/**
 * Represents a Java plugin loader, allowing plugins in the form of .jar
*/
export class JavaPluginLoader extends PluginLoader {
  /**
   * This class was not meant to be constructed explicitly
   *
   * @param instance the server instance
  */
  constructor(instance: Server);
  /**
   * Loads the plugin contained in the specified file
   *
   * @param file File to attempt to load
   * @return Plugin that was contained in the specified file, or null if
   *     unsuccessful
   * @throws InvalidPluginException Thrown when the specified file is not a
   *     plugin
   * @throws UnknownDependencyException If a required dependency could not
   *     be found
  */
  loadPlugin(file: File): Plugin;
  /**
   * Loads a PluginDescriptionFile from the specified file
   *
   * @param file File to attempt to load from
   * @return A new PluginDescriptionFile loaded from the plugin.yml in the
   *     specified file
   * @throws InvalidDescriptionException If the plugin description file
   *     could not be created
  */
  getPluginDescription(file: File): PluginDescriptionFile;
  /**
   * Returns a list of all filename filters expected by this PluginLoader
   *
   * @return The filters
  */
  getPluginFileFilters(): Pattern[];
  /**
   * Creates and returns registered listeners for the event classes used in
   * this listener
   *
   * @param listener The object that will handle the eventual call back
   * @param plugin The plugin to use when creating registered listeners
   * @return The registered listeners.
  */
  createRegisteredListeners(listener: Listener, plugin: Plugin): Map<Class<Event>, Set<RegisteredListener>>;
  /**
   * Enables the specified plugin
   * 
   * Attempting to enable a plugin that is already enabled will have no
   * effect
   *
   * @param plugin Plugin to enable
  */
  enablePlugin(plugin: Plugin): void;
  /**
   * Disables the specified plugin
   * 
   * Attempting to disable a plugin that is not enabled will have no effect
   *
   * @param plugin Plugin to disable
  */
  disablePlugin(plugin: Plugin): void;
  /**
   * This method is no longer useful as upstream has
   * made it so plugin classloaders are always closed on disable.
   * Use {@link #disablePlugin(Plugin)} instead.
   *
   * @param plugin Plugin to disable
   * @param closeClassloader unused
   * @deprecated Classloader is always closed by upstream now.
  */
  disablePlugin(plugin: Plugin, closeClassloader: boolean): void;
}
/**
 * Represents a Java plugin
*/
export class JavaPlugin extends PluginBase {
  constructor();
  /**
   * Returns the folder that the plugin data's files are located in. The
   * folder may not yet exist.
   *
   * @return The folder.
  */
  getDataFolder(): File;
  /**
   * Gets the associated PluginLoader responsible for this plugin
   *
   * @return PluginLoader that controls this plugin
  */
  getPluginLoader(): PluginLoader;
  /**
   * Returns the Server instance currently running this plugin
   *
   * @return Server running this plugin
  */
  getServer(): Server;
  /**
   * Returns a value indicating whether or not this plugin is currently
   * enabled
   *
   * @return true if this plugin is enabled, otherwise false
  */
  isEnabled(): boolean;
  /**
   * Returns the plugin.yaml file containing the details for this plugin
   *
   * @return Contents of the plugin.yaml file
  */
  getDescription(): PluginDescriptionFile;
  getConfig(): FileConfiguration;
  reloadConfig(): void;
  saveConfig(): void;
  saveDefaultConfig(): void;
  saveResource(resourcePath: string, replace: boolean): void;
  getResource(filename: string): InputStream | null;
  /**
   * {@inheritDoc}
  */
  onCommand(sender: CommandSender, command: Command, label: string, args: string[]): boolean;
  /**
   * {@inheritDoc}
  */
  onTabComplete(sender: CommandSender, command: Command, alias: string, args: string[]): string[] | null;
  /**
   * Gets the command with the given name, specific to this plugin. Commands
   * need to be registered in the {@link PluginDescriptionFile#getCommands()
   * PluginDescriptionFile} to exist at runtime.
   *
   * @param name name or alias of the command
   * @return the plugin command if found, otherwise null
  */
  getCommand(name: string): PluginCommand | null;
  onLoad(): void;
  onDisable(): void;
  onEnable(): void;
  getDefaultWorldGenerator(worldName: string, id: string | null): ChunkGenerator | null;
  getDefaultBiomeProvider(worldName: string, id: string | null): BiomeProvider | null;
  isNaggable(): boolean;
  setNaggable(canNag: boolean): void;
  getLogger(): Logger;
  toString(): string;
  /**
   * This method provides fast access to the plugin that has {@link
   * #getProvidingPlugin(Class) provided} the given plugin class, which is
   * usually the plugin that implemented it.
   * 
   * An exception to this would be if plugin's jar that contained the class
   * does not extend the class, where the intended plugin would have
   * resided in a different jar / classloader.
   *
   * @param  a class that extends JavaPlugin
   * @param clazz the class desired
   * @return the plugin that provides and implements said class
   * @throws IllegalArgumentException if clazz is null
   * @throws IllegalArgumentException if clazz does not extend {@link
   *     JavaPlugin}
   * @throws IllegalStateException if clazz was not provided by a plugin,
   *     for example, if called with
   *     JavaPlugin.getPlugin(JavaPlugin.class)
   * @throws IllegalStateException if called from the static initializer for
   *     given JavaPlugin
   * @throws ClassCastException if plugin that provided the class does not
   *     extend the class
  */
  static getPlugin<T>(clazz: Class<T>): T;
  /**
   * This method provides fast access to the plugin that has provided the
   * given class.
   *
   * @param clazz a class belonging to a plugin
   * @return the plugin that provided the class
   * @throws IllegalArgumentException if the class is not provided by a
   *     JavaPlugin
   * @throws IllegalArgumentException if class is null
   * @throws IllegalStateException if called from the static initializer for
   *     given JavaPlugin
  */
  static getProvidingPlugin(clazz: Class<any>): JavaPlugin;
}

}
declare module 'org.bukkit.entity.Horse' {
import { Enum } from 'java.lang';
/**
 * @deprecated different variants are differing classes
*/
export class Variant extends Enum<Variant> {
  /**
   * A normal horse
  */
  static readonly HORSE: Variant;
  /**
   * A donkey
  */
  static readonly DONKEY: Variant;
  /**
   * A mule
  */
  static readonly MULE: Variant;
  /**
   * An undead horse
  */
  static readonly UNDEAD_HORSE: Variant;
  /**
   * A skeleton horse
  */
  static readonly SKELETON_HORSE: Variant;
  /**
   * Not really a horse :)
  */
  static readonly LLAMA: Variant;
  static valueOf(name: string): Variant;
  static values(): Variant[];
}
/**
 * Represents the base color that the horse has.
*/
export class Color extends Enum<Color> {
  /**
   * Snow white
  */
  static readonly WHITE: Color;
  /**
   * Very light brown
  */
  static readonly CREAMY: Color;
  /**
   * Chestnut
  */
  static readonly CHESTNUT: Color;
  /**
   * Light brown
  */
  static readonly BROWN: Color;
  /**
   * Pitch black
  */
  static readonly BLACK: Color;
  /**
   * Gray
  */
  static readonly GRAY: Color;
  /**
   * Dark brown
  */
  static readonly DARK_BROWN: Color;
  static valueOf(name: string): Color;
  static values(): Color[];
}
/**
 * Represents the style, or markings, that the horse has.
*/
export class Style extends Enum<Style> {
  /**
   * No markings
  */
  static readonly NONE: Style;
  /**
   * White socks or stripes
  */
  static readonly WHITE: Style;
  /**
   * Milky splotches
  */
  static readonly WHITEFIELD: Style;
  /**
   * Round white dots
  */
  static readonly WHITE_DOTS: Style;
  /**
   * Small black dots
  */
  static readonly BLACK_DOTS: Style;
  static valueOf(name: string): Style;
  static values(): Style[];
}

}
declare module 'org.bukkit.event.inventory' {
import { Component } from 'net.kyori.adventure.text';
import { Set, List, Map } from 'java.util';
import { SlotType } from 'org.bukkit.event.inventory.InventoryType';
import { Result } from 'org.bukkit.event.Event';
import { Reason } from 'org.bukkit.event.inventory.InventoryCloseEvent';
import { BlockExpEvent, BlockCookEvent, BlockEvent } from 'org.bukkit.event.block';
import { Material } from 'org.bukkit';
import { CraftingInventory, InventoryView, MerchantInventory, Merchant, Recipe, CookingRecipe, BrewerInventory, SmithingInventory, AnvilInventory, ItemStack, Inventory } from 'org.bukkit.inventory';
import { Enum } from 'java.lang';
import { Block } from 'org.bukkit.block';
import { HandlerList, Cancellable, Event } from 'org.bukkit.event';
import { PrepareResultEvent } from 'com.destroystokyo.paper.event.inventory';
import { Item, Player, HumanEntity } from 'org.bukkit.entity';
/**
 * Called when an ItemStack is successfully burned as fuel in a furnace.
*/
export class FurnaceBurnEvent extends BlockEvent {
  constructor(furnace: Block, fuel: ItemStack, burnTime: number);
  /**
   * Gets the fuel ItemStack for this event
   *
   * @return the fuel ItemStack
  */
  getFuel(): ItemStack;
  /**
   * Gets the burn time for this fuel
   *
   * @return the burn time for this fuel
  */
  getBurnTime(): number;
  /**
   * Sets the burn time for this fuel
   *
   * @param burnTime the burn time for this fuel
  */
  setBurnTime(burnTime: number);
  /**
   * Gets whether the furnace's fuel is burning or not.
   *
   * @return whether the furnace's fuel is burning or not.
  */
  isBurning(): boolean;
  /**
   * Sets whether the furnace's fuel is burning or not.
   *
   * @param burning true if the furnace's fuel is burning
  */
  setBurning(burning: boolean): void;
  /**
   * Gets whether the furnace's fuel will be consumed or not.
   *
   * @return whether the furnace's fuel will be consumed
  */
  willConsumeFuel(): boolean;
  /**
   * Sets whether the furnace's fuel will be consumed or not.
   *
   * @param consumeFuel true to consume the fuel
  */
  setConsumeFuel(consumeFuel: boolean): void;
  /**
   * Gets the cancellation state of this event. A cancelled event will not
   * be executed in the server, but will still pass to other plugins
   *
   * @return true if this event is cancelled
  */
  isCancelled(): boolean;
  /**
   * Sets the cancellation state of this event. A cancelled event will not
   * be executed in the server, but will still pass to other plugins.
   *
   * @param cancel true if you wish to cancel this event
  */
  setCancelled(cancel: boolean): void;
  getHandlers(): HandlerList;
  static getHandlerList(): HandlerList;
}
export interface FurnaceBurnEvent extends BlockEvent, Cancellable {}
/**
 * Represents a player related inventory event
*/
export class InventoryOpenEvent extends InventoryEvent {
  constructor(transaction: InventoryView);
  /**
   * Returns the player involved in this event
   *
   * @return Player who is involved in this event
  */
  getPlayer(): HumanEntity;
  /**
   * Gets the cancellation state of this event. A cancelled event will not
   * be executed in the server, but will still pass to other plugins.
   * 
   * If an inventory open event is cancelled, the inventory screen will not
   * show.
   *
   * @return true if this event is cancelled
  */
  isCancelled(): boolean;
  /**
   * Sets the cancellation state of this event. A cancelled event will not
   * be executed in the server, but will still pass to other plugins.
   * 
   * If an inventory open event is cancelled, the inventory screen will not
   * show.
   *
   * @param cancel true if you wish to cancel this event
  */
  setCancelled(cancel: boolean): void;
  getHandlers(): HandlerList;
  static getHandlerList(): HandlerList;
}
export interface InventoryOpenEvent extends InventoryEvent, Cancellable {}
/**
 * This event is called when a player in creative mode puts down or picks up
 * an item in their inventory / hotbar and when they drop items from their
 * Inventory while in creative mode.
*/
export class InventoryCreativeEvent extends InventoryClickEvent {
  constructor(what: InventoryView, type: SlotType, slot: number, newItem: ItemStack);
  getCursor(): ItemStack;
  setCursor(cursor: ItemStack);
}
/**
 * Called when a hopper or hopper minecart picks up a dropped item.
*/
export class InventoryPickupItemEvent extends Event {
  constructor(inventory: Inventory, item: Item);
  /**
   * Gets the Inventory that picked up the item
   *
   * @return Inventory
  */
  getInventory(): Inventory;
  /**
   * Gets the Item entity that was picked up
   *
   * @return Item
  */
  getItem(): Item;
  /**
   * Gets the cancellation state of this event. A cancelled event will not
   * be executed in the server, but will still pass to other plugins
   *
   * @return true if this event is cancelled
  */
  isCancelled(): boolean;
  /**
   * Sets the cancellation state of this event. A cancelled event will not
   * be executed in the server, but will still pass to other plugins.
   *
   * @param cancel true if you wish to cancel this event
  */
  setCancelled(cancel: boolean): void;
  getHandlers(): HandlerList;
  static getHandlerList(): HandlerList;
}
export interface InventoryPickupItemEvent extends Event, Cancellable {}
/**
 * Called when the recipe of an Item is completed inside a crafting matrix.
*/
export class CraftItemEvent extends InventoryClickEvent {
  constructor(recipe: Recipe, what: InventoryView, type: SlotType, slot: number, click: ClickType, action: InventoryAction);
  constructor(recipe: Recipe, what: InventoryView, type: SlotType, slot: number, click: ClickType, action: InventoryAction, key: number);
  /**
   * @return A copy of the current recipe on the crafting matrix.
  */
  getRecipe(): Recipe;
  getInventory(): CraftingInventory;
}
export class FurnaceStartSmeltEvent extends BlockEvent {
  constructor(furnace: Block, source: ItemStack, recipe: CookingRecipe<any>);
  constructor(furnace: Block, source: ItemStack, recipe: CookingRecipe<any>, cookingTime: number);
  /**
   * Gets the source ItemStack for this event
   *
   * @return the source ItemStack
  */
  getSource(): ItemStack;
  /**
   * Gets the FurnaceRecipe associated with this event
   *
   * @return the FurnaceRecipe being cooked
  */
  getRecipe(): CookingRecipe<any>;
  /**
   * Gets the total cook time associated with this event
   *
   * @return the total cook time
  */
  getTotalCookTime(): number;
  /**
   * Sets the total cook time for this event
   *
   * @param cookTime the new total cook time
  */
  setTotalCookTime(totalCookTime: number);
  getHandlers(): HandlerList;
  static getHandlerList(): HandlerList;
}
/**
 * Represents a player related inventory event
*/
export class InventoryCloseEvent extends InventoryEvent {
  getReason(): Reason;
  constructor(transaction: InventoryView);
  constructor(transaction: InventoryView, reason: Reason);
  /**
   * Returns the player involved in this event
   *
   * @return Player who is involved in this event
  */
  getPlayer(): HumanEntity;
  getHandlers(): HandlerList;
  static getHandlerList(): HandlerList;
}
/**
 * Called when an ItemStack is successfully smelted in a furnace.
*/
export class FurnaceSmeltEvent extends BlockCookEvent {
  constructor(furnace: Block, source: ItemStack, result: ItemStack);
  constructor(furnace: Block, source: ItemStack, result: ItemStack, recipe: CookingRecipe<any> | null);
}
/**
 * Represents a player related inventory event
*/
export class InventoryEvent extends Event {
  constructor(transaction: InventoryView);
  /**
   * Gets the primary Inventory involved in this transaction
   *
   * @return The upper inventory.
  */
  getInventory(): Inventory;
  /**
   * Gets the list of players viewing the primary (upper) inventory involved
   * in this event
   *
   * @return A list of people viewing.
  */
  getViewers(): HumanEntity[];
  /**
   * Gets the view object itself
   *
   * @return InventoryView
  */
  getView(): InventoryView;
  getHandlers(): HandlerList;
  static getHandlerList(): HandlerList;
}
/**
 * This event is called when a player takes items out of the furnace
*/
export class FurnaceExtractEvent extends BlockExpEvent {
  constructor(player: Player, block: Block, itemType: Material, itemAmount: number, exp: number);
  /**
   * Get the player that triggered the event
   *
   * @return the relevant player
  */
  getPlayer(): Player;
  /**
   * Get the Material of the item being retrieved
   *
   * @return the material of the item
  */
  getItemType(): Material;
  /**
   * Get the item count being retrieved
   *
   * @return the amount of the item
  */
  getItemAmount(): number;
}
/**
 * An abstract base class for events that describe an interaction between a
 * HumanEntity and the contents of an Inventory.
*/
export class InventoryInteractEvent extends InventoryEvent {
  constructor(transaction: InventoryView);
  /**
   * Gets the player who performed the click.
   *
   * @return The clicking player.
  */
  getWhoClicked(): HumanEntity;
  /**
   * Sets the result of this event. This will change whether or not this
   * event is considered cancelled.
   *
   * @param newResult the new {@link org.bukkit.event.Event.Result} for this event
   * @see #isCancelled()
  */
  setResult(result: Result);
  /**
   * Gets the {@link org.bukkit.event.Event.Result} of this event. The Result describes the
   * behavior that will be applied to the inventory in relation to this
   * event.
   *
   * @return the Result of this event.
  */
  getResult(): Result;
  /**
   * Gets whether or not this event is cancelled. This is based off of the
   * Result value returned by {@link #getResult()}.  Result.ALLOW and
   * Result.DEFAULT will result in a returned value of false, but
   * Result.DENY will result in a returned value of true.
   * 
   * {@inheritDoc}
   *
   * @return whether the event is cancelled
  */
  isCancelled(): boolean;
  /**
   * Proxy method to {@link #setResult(org.bukkit.event.Event.Result)} for the Cancellable
   * interface. {@link #setResult(org.bukkit.event.Event.Result)} is preferred, as it allows
   * you to specify the Result beyond Result.DENY and Result.ALLOW.
   * 
   * {@inheritDoc}
   *
   * @param toCancel result becomes DENY if true, ALLOW if false
  */
  setCancelled(toCancel: boolean): void;
}
export interface InventoryInteractEvent extends InventoryEvent, Cancellable {}
/**
 * Called when the brewing of the contents inside the Brewing Stand is
 * complete.
*/
export class BrewEvent extends BlockEvent {
  constructor(brewer: Block, contents: BrewerInventory, results: ItemStack[], fuelLevel: number);
  /**
   * Gets the contents of the Brewing Stand.
   *
   * Note: The brewer inventory still holds the items found prior to
   * the finalization of the brewing process, e.g. the plain water bottles.
   *
   * @return the contents
  */
  getContents(): BrewerInventory;
  /**
   * Gets the remaining fuel level.
   *
   * @return the remaining fuel
  */
  getFuelLevel(): number;
  /**
   * Gets the resulting items in the Brewing Stand.
   *
   * The returned list, in case of a server-created event instance, is
   * mutable. Any changes in the returned list will reflect in the brewing
   * result if the event is not cancelled. If the size of the list is reduced,
   * remaining items will be set to air.
   *
   * @return List of {@link ItemStack} resulting for this operation
  */
  getResults(): ItemStack[];
  /**
   * Gets the cancellation state of this event. A cancelled event will not
   * be executed in the server, but will still pass to other plugins
   *
   * @return true if this event is cancelled
  */
  isCancelled(): boolean;
  /**
   * Sets the cancellation state of this event. A cancelled event will not
   * be executed in the server, but will still pass to other plugins.
   *
   * @param cancel true if you wish to cancel this event
  */
  setCancelled(cancel: boolean): void;
  getHandlers(): HandlerList;
  static getHandlerList(): HandlerList;
}
export interface BrewEvent extends BlockEvent, Cancellable {}
/**
 * Represents the effect of a drag that will be applied to an Inventory in an
 * InventoryDragEvent.
*/
export class DragType extends Enum<DragType> {
  /**
   * One item from the cursor is placed in each selected slot.
  */
  static readonly SINGLE: DragType;
  /**
   * The cursor is split evenly across all selected slots, not to exceed the
   * Material's max stack size, with the remainder going to the cursor.
  */
  static readonly EVEN: DragType;
  static valueOf(name: string): DragType;
  static values(): DragType[];
}
export class PrepareItemCraftEvent extends InventoryEvent {
  constructor(what: CraftingInventory, view: InventoryView, isRepair: boolean);
  /**
   * Get the recipe that has been formed. If this event was triggered by a
   * tool repair, this will be a temporary shapeless recipe representing the
   * repair.
   *
   * @return The recipe being crafted.
  */
  getRecipe(): Recipe | null;
  /**
   * @return The crafting inventory on which the recipe was formed.
  */
  getInventory(): CraftingInventory;
  /**
   * Check if this event was triggered by a tool repair operation rather
   * than a crafting recipe.
   *
   * @return True if this is a repair.
  */
  isRepair(): boolean;
  getHandlers(): HandlerList;
  static getHandlerList(): HandlerList;
}
/**
 * An estimation of what the result will be.
*/
export class InventoryAction extends Enum<InventoryAction> {
  /**
   * Nothing will happen from the click.
   * 
   * There may be cases where nothing will happen and this is value is not
   * provided, but it is guaranteed that this value is accurate when given.
  */
  static readonly NOTHING: InventoryAction;
  /**
   * All of the items on the clicked slot are moved to the cursor.
  */
  static readonly PICKUP_ALL: InventoryAction;
  /**
   * Some of the items on the clicked slot are moved to the cursor.
  */
  static readonly PICKUP_SOME: InventoryAction;
  /**
   * Half of the items on the clicked slot are moved to the cursor.
  */
  static readonly PICKUP_HALF: InventoryAction;
  /**
   * One of the items on the clicked slot are moved to the cursor.
  */
  static readonly PICKUP_ONE: InventoryAction;
  /**
   * All of the items on the cursor are moved to the clicked slot.
  */
  static readonly PLACE_ALL: InventoryAction;
  /**
   * Some of the items from the cursor are moved to the clicked slot
   * (usually up to the max stack size).
  */
  static readonly PLACE_SOME: InventoryAction;
  /**
   * A single item from the cursor is moved to the clicked slot.
  */
  static readonly PLACE_ONE: InventoryAction;
  /**
   * The clicked item and the cursor are exchanged.
  */
  static readonly SWAP_WITH_CURSOR: InventoryAction;
  /**
   * The entire cursor item is dropped.
  */
  static readonly DROP_ALL_CURSOR: InventoryAction;
  /**
   * One item is dropped from the cursor.
  */
  static readonly DROP_ONE_CURSOR: InventoryAction;
  /**
   * The entire clicked slot is dropped.
  */
  static readonly DROP_ALL_SLOT: InventoryAction;
  /**
   * One item is dropped from the clicked slot.
  */
  static readonly DROP_ONE_SLOT: InventoryAction;
  /**
   * The item is moved to the opposite inventory if a space is found.
  */
  static readonly MOVE_TO_OTHER_INVENTORY: InventoryAction;
  /**
   * The clicked item is moved to the hotbar, and the item currently there
   * is re-added to the player's inventory.
   *
   * The hotbar includes the player's off hand.
  */
  static readonly HOTBAR_MOVE_AND_READD: InventoryAction;
  /**
   * The clicked slot and the picked hotbar slot are swapped.
   *
   * The hotbar includes the player's off hand.
  */
  static readonly HOTBAR_SWAP: InventoryAction;
  /**
   * A max-size stack of the clicked item is put on the cursor.
  */
  static readonly CLONE_STACK: InventoryAction;
  /**
   * The inventory is searched for the same material, and they are put on
   * the cursor up to {@link org.bukkit.Material#getMaxStackSize()}.
  */
  static readonly COLLECT_TO_CURSOR: InventoryAction;
  /**
   * An unrecognized ClickType.
  */
  static readonly UNKNOWN: InventoryAction;
  static valueOf(name: string): InventoryAction;
  static values(): InventoryAction[];
}
/**
 * Represents the different kinds of inventories available in Bukkit.
 * 
 * Only InventoryTypes marked {@link #isCreatable()} can be created.
 * 
 * The current list of inventories that cannot be created via
 * {@link org.bukkit.Bukkit#createInventory} are:
 * 
 *     {@link InventoryType#CREATIVE}, {@link InventoryType#CRAFTING} and
 *     {@link InventoryType#MERCHANT}
 * 
 *
 * See {@link org.bukkit.Bukkit#createInventory} for more information.
 *
 * @see org.bukkit.Bukkit#createInventory(InventoryHolder, InventoryType)
*/
export class InventoryType extends Enum<InventoryType> {
  /**
   * A chest inventory, with 0, 9, 18, 27, 36, 45, or 54 slots of type
   * CONTAINER.
  */
  static readonly CHEST: InventoryType;
  /**
   * A dispenser inventory, with 9 slots of type CONTAINER.
  */
  static readonly DISPENSER: InventoryType;
  /**
   * A dropper inventory, with 9 slots of type CONTAINER.
  */
  static readonly DROPPER: InventoryType;
  /**
   * A furnace inventory, with a RESULT slot, a CRAFTING slot, and a FUEL
   * slot.
  */
  static readonly FURNACE: InventoryType;
  /**
   * A workbench inventory, with 9 CRAFTING slots and a RESULT slot.
  */
  static readonly WORKBENCH: InventoryType;
  /**
   * A player's crafting inventory, with 4 CRAFTING slots and a RESULT slot.
   * Also implies that the 4 ARMOR slots are accessible.
  */
  static readonly CRAFTING: InventoryType;
  /**
   * An enchantment table inventory, with two CRAFTING slots and three
   * enchanting buttons.
  */
  static readonly ENCHANTING: InventoryType;
  /**
   * A brewing stand inventory, with one FUEL slot and four CRAFTING slots.
  */
  static readonly BREWING: InventoryType;
  /**
   * A player's inventory, with 9 QUICKBAR slots, 27 CONTAINER slots, 4 ARMOR
   * slots and 1 offhand slot. The ARMOR and offhand slots may not be visible
   * to the player, though.
  */
  static readonly PLAYER: InventoryType;
  /**
   * The creative mode inventory, with only 9 QUICKBAR slots and nothing
   * else. (The actual creative interface with the items is client-side and
   * cannot be altered by the server.)
  */
  static readonly CREATIVE: InventoryType;
  /**
   * The merchant inventory, with 2 CRAFTING slots, and 1 RESULT slot.
  */
  static readonly MERCHANT: InventoryType;
  /**
   * The ender chest inventory, with 27 slots.
  */
  static readonly ENDER_CHEST: InventoryType;
  /**
   * An anvil inventory, with 2 CRAFTING slots and 1 RESULT slot
  */
  static readonly ANVIL: InventoryType;
  /**
   * A smithing inventory, with 2 CRAFTING slots and 1 RESULT slot
  */
  static readonly SMITHING: InventoryType;
  /**
   * A beacon inventory, with 1 CRAFTING slot
  */
  static readonly BEACON: InventoryType;
  /**
   * A hopper inventory, with 5 slots of type CONTAINER.
  */
  static readonly HOPPER: InventoryType;
  /**
   * A shulker box inventory, with 27 slots of type CONTAINER.
  */
  static readonly SHULKER_BOX: InventoryType;
  /**
   * A barrel box inventory, with 27 slots of type CONTAINER.
  */
  static readonly BARREL: InventoryType;
  /**
   * A blast furnace inventory, with a RESULT slot, a CRAFTING slot, and a
   * FUEL slot.
  */
  static readonly BLAST_FURNACE: InventoryType;
  /**
   * A lectern inventory, with 1 BOOK slot.
  */
  static readonly LECTERN: InventoryType;
  /**
   * A smoker inventory, with a RESULT slot, a CRAFTING slot, and a FUEL slot.
  */
  static readonly SMOKER: InventoryType;
  /**
   * Loom inventory, with 3 CRAFTING slots, and 1 RESULT slot.
  */
  static readonly LOOM: InventoryType;
  /**
   * Cartography inventory with 2 CRAFTING slots, and 1 RESULT slot.
  */
  static readonly CARTOGRAPHY: InventoryType;
  /**
   * Grindstone inventory with 2 CRAFTING slots, and 1 RESULT slot.
  */
  static readonly GRINDSTONE: InventoryType;
  /**
   * Stonecutter inventory with 1 CRAFTING slot, and 1 RESULT slot.
  */
  static readonly STONECUTTER: InventoryType;
  /**
   * Pseudo composter inventory with 0 or 1 slots of undefined type.
  */
  static readonly COMPOSTER: InventoryType;
  static valueOf(name: string): InventoryType;
  static values(): InventoryType[];
  /**
   * Gets the inventory's default title.
   *
   * @return the inventory's default title
  */
  defaultTitle(): Component;
  getDefaultSize(): number;
  /**
   * Denotes that this InventoryType can be created via the normal
   * {@link org.bukkit.Bukkit#createInventory} methods.
   *
   * @return if this InventoryType can be created and shown to a player
  */
  isCreatable(): boolean;
}
/**
 * Called when an ItemStack is about to increase the fuel level of a brewing
 * stand.
*/
export class BrewingStandFuelEvent extends BlockEvent {
  constructor(brewingStand: Block, fuel: ItemStack, fuelPower: number);
  /**
   * Gets the ItemStack of the fuel before the amount was subtracted.
   *
   * @return the fuel ItemStack
  */
  getFuel(): ItemStack;
  /**
   * Gets the fuel power for this fuel. Each unit of power can fuel one
   * brewing operation.
   *
   * @return the fuel power for this fuel
  */
  getFuelPower(): number;
  /**
   * Sets the fuel power for this fuel. Each unit of power can fuel one
   * brewing operation.
   *
   * @param fuelPower the fuel power for this fuel
  */
  setFuelPower(fuelPower: number);
  /**
   * Gets whether the brewing stand's fuel will be reduced / consumed or not.
   *
   * @return whether the fuel will be reduced or not
  */
  isConsuming(): boolean;
  /**
   * Sets whether the brewing stand's fuel will be reduced / consumed or not.
   *
   * @param consuming whether the fuel will be reduced or not
  */
  setConsuming(consuming: boolean): void;
  /**
   * Gets the cancellation state of this event. A cancelled event will not
   * be executed in the server, but will still pass to other plugins
   *
   * @return true if this event is cancelled
  */
  isCancelled(): boolean;
  /**
   * Sets the cancellation state of this event. A cancelled event will not
   * be executed in the server, but will still pass to other plugins.
   *
   * @param cancel true if you wish to cancel this event
  */
  setCancelled(cancel: boolean): void;
  getHandlers(): HandlerList;
  static getHandlerList(): HandlerList;
}
export interface BrewingStandFuelEvent extends BlockEvent, Cancellable {}
/**
 * This event is called when a player clicks in an inventory.
 * 
 * Because InventoryClickEvent occurs within a modification of the Inventory,
 * not all Inventory related methods are safe to use.
 * 
 * The following should never be invoked by an EventHandler for
 * InventoryClickEvent using the HumanEntity or InventoryView associated with
 * this event:
 * 
 * {@link HumanEntity#closeInventory()}
 * {@link HumanEntity#openInventory(Inventory)}
 * {@link HumanEntity#openWorkbench(Location, boolean)}
 * {@link HumanEntity#openEnchanting(Location, boolean)}
 * {@link InventoryView#close()}
 * 
 * To invoke one of these methods, schedule a task using
 * {@link BukkitScheduler#runTask(Plugin, Runnable)}, which will run the task
 * on the next tick. Also be aware that this is not an exhaustive list, and
 * other methods could potentially create issues as well.
 * 
 * Assuming the EntityHuman associated with this event is an instance of a
 * Player, manipulating the MaxStackSize or contents of an Inventory will
 * require an Invocation of {@link Player#updateInventory()}.
 * 
 * Modifications to slots that are modified by the results of this
 * InventoryClickEvent can be overwritten. To change these slots, this event
 * should be cancelled and all desired changes to the inventory applied.
 * Alternatively, scheduling a task using {@link BukkitScheduler#runTask(
 * Plugin, Runnable)}, which would execute the task on the next tick, would
 * work as well.
*/
export class InventoryClickEvent extends InventoryInteractEvent {
  constructor(view: InventoryView, type: SlotType, slot: number, click: ClickType, action: InventoryAction);
  constructor(view: InventoryView, type: SlotType, slot: number, click: ClickType, action: InventoryAction, key: number);
  /**
   * Gets the type of slot that was clicked.
   *
   * @return the slot type
  */
  getSlotType(): SlotType;
  /**
   * Gets the current ItemStack on the cursor.
   *
   * @return the cursor ItemStack
  */
  getCursor(): ItemStack | null;
  /**
   * Gets the ItemStack currently in the clicked slot.
   *
   * @return the item in the clicked
  */
  getCurrentItem(): ItemStack | null;
  /**
   * Gets whether or not the ClickType for this event represents a right
   * click.
   *
   * @return true if the ClickType uses the right mouse button.
   * @see ClickType#isRightClick()
  */
  isRightClick(): boolean;
  /**
   * Gets whether or not the ClickType for this event represents a left
   * click.
   *
   * @return true if the ClickType uses the left mouse button.
   * @see ClickType#isLeftClick()
  */
  isLeftClick(): boolean;
  /**
   * Gets whether the ClickType for this event indicates that the key was
   * pressed down when the click was made.
   *
   * @return true if the ClickType uses Shift or Ctrl.
   * @see ClickType#isShiftClick()
  */
  isShiftClick(): boolean;
  /**
   * Sets the item on the cursor.
   *
   * @param stack the new cursor item
   * @deprecated This changes the ItemStack in their hand before any
   *     calculations are applied to the Inventory, which has a tendency to
   *     create inconsistencies between the Player and the server, and to
   *     make unexpected changes in the behavior of the clicked Inventory.
  */
  setCursor(cursor: ItemStack | null);
  /**
   * Sets the ItemStack currently in the clicked slot.
   *
   * @param stack the item to be placed in the current slot
  */
  setCurrentItem(currentItem: ItemStack | null);
  /**
   * Gets the inventory corresponding to the clicked slot.
   *
   * @return inventory, or null if clicked outside
   * @see InventoryView#getInventory(int)
  */
  getClickedInventory(): Inventory | null;
  /**
   * The slot number that was clicked, ready for passing to
   * {@link Inventory#getItem(int)}. Note that there may be two slots with
   * the same slot number, since a view links two different inventories.
   *
   * @return The slot number.
  */
  getSlot(): number;
  /**
   * The raw slot number clicked, ready for passing to {@link InventoryView
   * #getItem(int)} This slot number is unique for the view.
   *
   * @return the slot number
  */
  getRawSlot(): number;
  /**
   * If the ClickType is NUMBER_KEY, this method will return the index of
   * the pressed key (0-8).
   *
   * @return the number on the key minus 1 (range 0-8); or -1 if not
   *     a NUMBER_KEY action
  */
  getHotbarButton(): number;
  /**
   * Gets the InventoryAction that triggered this event.
   * 
   * This action cannot be changed, and represents what the normal outcome
   * of the event will be. To change the behavior of this
   * InventoryClickEvent, changes must be manually applied.
   *
   * @return the InventoryAction that triggered this event.
  */
  getAction(): InventoryAction;
  /**
   * Gets the ClickType for this event.
   * 
   * This is insulated against changes to the inventory by other plugins.
   *
   * @return the type of inventory click
  */
  getClick(): ClickType;
  getHandlers(): HandlerList;
  static getHandlerList(): HandlerList;
}
/**
 * What the client did to trigger this action (not the result).
*/
export class ClickType extends Enum<ClickType> {
  /**
   * The left (or primary) mouse button.
  */
  static readonly LEFT: ClickType;
  /**
   * Holding shift while pressing the left mouse button.
  */
  static readonly SHIFT_LEFT: ClickType;
  /**
   * The right mouse button.
  */
  static readonly RIGHT: ClickType;
  /**
   * Holding shift while pressing the right mouse button.
  */
  static readonly SHIFT_RIGHT: ClickType;
  /**
   * Clicking the left mouse button on the grey area around the inventory.
  */
  static readonly WINDOW_BORDER_LEFT: ClickType;
  /**
   * Clicking the right mouse button on the grey area around the inventory.
  */
  static readonly WINDOW_BORDER_RIGHT: ClickType;
  /**
   * The middle mouse button, or a "scrollwheel click".
  */
  static readonly MIDDLE: ClickType;
  /**
   * One of the number keys 1-9, correspond to slots on the hotbar.
  */
  static readonly NUMBER_KEY: ClickType;
  /**
   * Pressing the left mouse button twice in quick succession.
  */
  static readonly DOUBLE_CLICK: ClickType;
  /**
   * The "Drop" key (defaults to Q).
  */
  static readonly DROP: ClickType;
  /**
   * Holding Ctrl while pressing the "Drop" key (defaults to Q).
  */
  static readonly CONTROL_DROP: ClickType;
  /**
   * Any action done with the Creative inventory open.
  */
  static readonly CREATIVE: ClickType;
  /**
   * The "swap item with offhand" key (defaults to F).
  */
  static readonly SWAP_OFFHAND: ClickType;
  /**
   * A type of inventory manipulation not yet recognized by Bukkit.
   * 
   * This is only for transitional purposes on a new Minecraft update, and
   * should never be relied upon.
   * 
   * Any ClickType.UNKNOWN is called on a best-effort basis.
  */
  static readonly UNKNOWN: ClickType;
  static valueOf(name: string): ClickType;
  static values(): ClickType[];
  /**
   * Gets whether this ClickType represents the pressing of a key on a
   * keyboard.
   *
   * @return true if this ClickType represents the pressing of a key
  */
  isKeyboardClick(): boolean;
  /**
   * Gets whether this ClickType represents an action that can only be
   * performed by a Player in creative mode.
   *
   * @return true if this action requires Creative mode
  */
  isCreativeAction(): boolean;
  /**
   * Gets whether this ClickType represents a right click.
   *
   * @return true if this ClickType represents a right click
  */
  isRightClick(): boolean;
  /**
   * Gets whether this ClickType represents a left click.
   *
   * @return true if this ClickType represents a left click
  */
  isLeftClick(): boolean;
  /**
   * Gets whether this ClickType indicates that the shift key was pressed
   * down when the click was made.
   *
   * @return true if the action uses Shift.
  */
  isShiftClick(): boolean;
}
export class PrepareSmithingEvent extends PrepareResultEvent {
  constructor(inventory: InventoryView, result: ItemStack | null);
  getInventory(): SmithingInventory;
  /**
   * Get result item, may be null.
   *
   * @return result item
  */
  getResult(): ItemStack | null;
  setResult(result: ItemStack | null);
}
/**
 * This event is called when the player drags an item in their cursor across
 * the inventory. The ItemStack is distributed across the slots the
 * HumanEntity dragged over. The method of distribution is described by the
 * DragType returned by {@link #getType()}.
 * 
 * Canceling this event will result in none of the changes described in
 * {@link #getNewItems()} being applied to the Inventory.
 * 
 * Because InventoryDragEvent occurs within a modification of the Inventory,
 * not all Inventory related methods are safe to use.
 * 
 * The following should never be invoked by an EventHandler for
 * InventoryDragEvent using the HumanEntity or InventoryView associated with
 * this event.
 * 
 * {@link HumanEntity#closeInventory()}
 * {@link HumanEntity#openInventory(Inventory)}
 * {@link HumanEntity#openWorkbench(Location, boolean)}
 * {@link HumanEntity#openEnchanting(Location, boolean)}
 * {@link InventoryView#close()}
 * 
 * To invoke one of these methods, schedule a task using
 * {@link BukkitScheduler#runTask(Plugin, Runnable)}, which will run the task
 * on the next tick.  Also be aware that this is not an exhaustive list, and
 * other methods could potentially create issues as well.
 * 
 * Assuming the EntityHuman associated with this event is an instance of a
 * Player, manipulating the MaxStackSize or contents of an Inventory will
 * require an Invocation of {@link Player#updateInventory()}.
 * 
 * Any modifications to slots that are modified by the results of this
 * InventoryDragEvent will be overwritten. To change these slots, this event
 * should be cancelled and the changes applied. Alternatively, scheduling a
 * task using {@link BukkitScheduler#runTask(Plugin, Runnable)}, which would
 * execute the task on the next tick, would work as well.
*/
export class InventoryDragEvent extends InventoryInteractEvent {
  constructor(what: InventoryView, newCursor: ItemStack | null, oldCursor: ItemStack, right: boolean, slots: Map<number, ItemStack>);
  /**
   * Gets all items to be added to the inventory in this drag.
   *
   * @return map from raw slot id to new ItemStack
  */
  getNewItems(): Map<number, ItemStack>;
  /**
   * Gets the raw slot ids to be changed in this drag.
   *
   * @return list of raw slot ids, suitable for getView().getItem(int)
  */
  getRawSlots(): Set<number>;
  /**
   * Gets the slots to be changed in this drag.
   *
   * @return list of converted slot ids, suitable for {@link
   *     org.bukkit.inventory.Inventory#getItem(int)}.
  */
  getInventorySlots(): Set<number>;
  /**
   * Gets the result cursor after the drag is done. The returned value is
   * mutable.
   *
   * @return the result cursor
  */
  getCursor(): ItemStack | null;
  /**
   * Sets the result cursor after the drag is done.
   * 
   * Changing this item stack changes the cursor item. Note that changing
   * the affected "dragged" slots does not change this ItemStack, nor does
   * changing this ItemStack affect the "dragged" slots.
   *
   * @param newCursor the new cursor ItemStack
  */
  setCursor(cursor: ItemStack | null);
  /**
   * Gets an ItemStack representing the cursor prior to any modifications
   * as a result of this drag.
   *
   * @return the original cursor
  */
  getOldCursor(): ItemStack;
  /**
   * Gets the DragType that describes the behavior of ItemStacks placed
   * after this InventoryDragEvent.
   * 
   * The ItemStacks and the raw slots that they're being applied to can be
   * found using {@link #getNewItems()}.
   *
   * @return the DragType of this InventoryDragEvent
  */
  getType(): DragType;
  getHandlers(): HandlerList;
  static getHandlerList(): HandlerList;
}
export class PrepareAnvilEvent extends PrepareResultEvent {
  constructor(inventory: InventoryView, result: ItemStack | null);
  getInventory(): AnvilInventory;
  /**
   * Get result item, may be null.
   *
   * @return result item
  */
  getResult(): ItemStack | null;
  setResult(result: ItemStack | null);
}
/**
 * This event is called whenever a player clicks a new trade on the trades
 * sidebar.
 * 
 * This event allows the user to get the index of the trade, letting them get
 * the MerchantRecipe via the Merchant.
*/
export class TradeSelectEvent extends InventoryInteractEvent {
  constructor(transaction: InventoryView, newIndex: number);
  /**
   * Used to get the index of the trade the player clicked on.
   *
   * @return The index of the trade clicked by the player
  */
  getIndex(): number;
  getInventory(): MerchantInventory;
  /**
   * Get the Merchant involved.
   *
   * @return the Merchant
  */
  getMerchant(): Merchant;
  getHandlers(): HandlerList;
  static getHandlerList(): HandlerList;
}
/**
 * Called when the recipe of an Item is completed inside a smithing table.
*/
export class SmithItemEvent extends InventoryClickEvent {
  constructor(view: InventoryView, type: SlotType, slot: number, click: ClickType, action: InventoryAction);
  constructor(view: InventoryView, type: SlotType, slot: number, click: ClickType, action: InventoryAction, key: number);
  getInventory(): SmithingInventory;
}
/**
 * Called when some entity or block (e.g. hopper) tries to move items directly
 * from one inventory to another.
 * 
 * When this event is called, the initiator may already have removed the item
 * from the source inventory and is ready to move it into the destination
 * inventory.
 * 
 * If this event is cancelled, the items will be returned to the source
 * inventory, if needed.
 * 
 * If this event is not cancelled, the initiator will try to put the ItemStack
 * into the destination inventory. If this is not possible and the ItemStack
 * has not been modified, the source inventory slot will be restored to its
 * former state. Otherwise any additional items will be discarded.
*/
export class InventoryMoveItemEvent extends Event {
  calledGetItem: boolean;
  calledSetItem: boolean;
  constructor(sourceInventory: Inventory, itemStack: ItemStack, destinationInventory: Inventory, didSourceInitiate: boolean);
  /**
   * Gets the Inventory that the ItemStack is being taken from
   *
   * @return Inventory that the ItemStack is being taken from
  */
  getSource(): Inventory;
  /**
   * Gets the ItemStack being moved; if modified, the original item will not
   * be removed from the source inventory.
   *
   * @return ItemStack
  */
  getItem(): ItemStack;
  /**
   * Sets the ItemStack being moved; if this is different from the original
   * ItemStack, the original item will not be removed from the source
   * inventory.
   *
   * @param itemStack The ItemStack
  */
  setItem(item: ItemStack);
  /**
   * Gets the Inventory that the ItemStack is being put into
   *
   * @return Inventory that the ItemStack is being put into
  */
  getDestination(): Inventory;
  /**
   * Gets the Inventory that initiated the transfer. This will always be
   * either the destination or source Inventory.
   *
   * @return Inventory that initiated the transfer
  */
  getInitiator(): Inventory;
  /**
   * Gets the cancellation state of this event. A cancelled event will not
   * be executed in the server, but will still pass to other plugins
   *
   * @return true if this event is cancelled
  */
  isCancelled(): boolean;
  /**
   * Sets the cancellation state of this event. A cancelled event will not
   * be executed in the server, but will still pass to other plugins.
   *
   * @param cancel true if you wish to cancel this event
  */
  setCancelled(cancel: boolean): void;
  getHandlers(): HandlerList;
  static getHandlerList(): HandlerList;
}
export interface InventoryMoveItemEvent extends Event, Cancellable {}

}
declare module 'org.bukkit.block.structure' {
import { Enum } from 'java.lang';
/**
 * Represents how a {@link org.bukkit.block.Structure} can be used.
*/
export class UsageMode extends Enum<UsageMode> {
  /**
   * The mode used when saving a structure.
  */
  static readonly SAVE: UsageMode;
  /**
   * The mode used when loading a structure.
  */
  static readonly LOAD: UsageMode;
  /**
   * Used when saving a structure for easy size calculation. When using this
   * mode, the Structure name MUST match the name in the second Structure
   * block that is in {@link UsageMode#SAVE}.
  */
  static readonly CORNER: UsageMode;
  /**
   * Used to run specific custom functions, which can only be used for certain
   * Structures. The structure block is removed after this function completes.
   * The data tags (functions) can be found on the
   * wiki.
  */
  static readonly DATA: UsageMode;
  static valueOf(name: string): UsageMode;
  static values(): UsageMode[];
}
/**
 * Represents how a {@link org.bukkit.block.Structure} can be rotated.
*/
export class StructureRotation extends Enum<StructureRotation> {
  /**
   * No rotation.
  */
  static readonly NONE: StructureRotation;
  /**
   * Rotated clockwise 90 degrees.
  */
  static readonly CLOCKWISE_90: StructureRotation;
  /**
   * Rotated clockwise 180 degrees.
  */
  static readonly CLOCKWISE_180: StructureRotation;
  /**
   * Rotated counter clockwise 90 degrees.
   * 
   * Equivalent to rotating clockwise 270 degrees.
  */
  static readonly COUNTERCLOCKWISE_90: StructureRotation;
  static valueOf(name: string): StructureRotation;
  static values(): StructureRotation[];
}
/**
 * Represents how a {@link org.bukkit.block.Structure} can be mirrored upon
 * being loaded.
*/
export class Mirror extends Enum<Mirror> {
  /**
   * No mirroring.
   * 
   * Positive X to Positive Z
  */
  static readonly NONE: Mirror;
  /**
   * Structure is mirrored left to right.
   * 
   * Similar to looking in a mirror. Positive X to Negative Z
  */
  static readonly LEFT_RIGHT: Mirror;
  /**
   * Structure is mirrored front to back.
   * 
   * Positive Z to Negative X
  */
  static readonly FRONT_BACK: Mirror;
  static valueOf(name: string): Mirror;
  static values(): Mirror[];
}

}
declare module 'org.bukkit.event.player.PlayerGameModeChangeEvent' {
import { Enum } from 'java.lang';
export class Cause extends Enum<Cause> {
  /**
   * A plugin changed the player's gamemode with
   * {@link Player#setGameMode(GameMode)}.
  */
  static readonly PLUGIN: Cause;
  /**
   * The `/gamemode` command was used.
  */
  static readonly COMMAND: Cause;
  /**
   * A player had their gamemode changed as a result of
   * the `/defaultgamemode` command, or they joined
   * with a gamemode that was not the default gamemode and
   * `force-gamemode` in `server.properties` is set to true.
  */
  static readonly DEFAULT_GAMEMODE: Cause;
  /**
   * When the player dies in a hardcore world and has their gamemode
   * changed to {@link GameMode#SPECTATOR}.
  */
  static readonly HARDCORE_DEATH: Cause;
  /**
   * This cause is only used if a plugin fired their own
   * {@link PlayerGameModeChangeEvent} and did not include a
   * cause. Can usually be ignored.
  */
  static readonly UNKNOWN: Cause;
  static valueOf(name: string): Cause;
  static values(): Cause[];
}

}
declare module 'org.bukkit.material.CocoaPlant' {
import { Enum } from 'java.lang';
export class CocoaPlantSize extends Enum<CocoaPlantSize> {
  static readonly SMALL: CocoaPlantSize;
  static readonly MEDIUM: CocoaPlantSize;
  static readonly LARGE: CocoaPlantSize;
  static valueOf(name: string): CocoaPlantSize;
  static values(): CocoaPlantSize[];
}

}
declare module 'org.bukkit.block.data.type.Switch' {
import { Enum } from 'java.lang';
/**
 * The face to which a switch type block is stuck.
 *
 * @deprecated use {@link AttachedFace}
*/
export class Face extends Enum<Face> {
  /**
   * The switch is mounted to the floor and pointing upwards.
  */
  static readonly FLOOR: Face;
  /**
   * The switch is mounted to the wall.
  */
  static readonly WALL: Face;
  /**
   * The switch is mounted to the ceiling and pointing dowanrds.
  */
  static readonly CEILING: Face;
  static valueOf(name: string): Face;
  static values(): Face[];
}

}
declare module 'org.bukkit.entity.TropicalFish' {
import { Enum } from 'java.lang';
/**
 * Enumeration of all different fish patterns. Refer to the
 * Minecraft Wiki
 * for pictures.
*/
export class Pattern extends Enum<Pattern> {
  static readonly KOB: Pattern;
  static readonly SUNSTREAK: Pattern;
  static readonly SNOOPER: Pattern;
  static readonly DASHER: Pattern;
  static readonly BRINELY: Pattern;
  static readonly SPOTTY: Pattern;
  static readonly FLOPPER: Pattern;
  static readonly STRIPEY: Pattern;
  static readonly GLITTER: Pattern;
  static readonly BLOCKFISH: Pattern;
  static readonly BETTY: Pattern;
  static readonly CLAYFISH: Pattern;
  static valueOf(name: string): Pattern;
  static values(): Pattern[];
}

}
declare module 'org.bukkit.event.entity.EntityTargetEvent' {
import { Enum } from 'java.lang';
/**
 * An enum to specify the reason for the targeting
*/
export class TargetReason extends Enum<TargetReason> {
  /**
   * When the entity's target has died, and so it no longer targets it
  */
  static readonly TARGET_DIED: TargetReason;
  /**
   * When the entity doesn't have a target, so it attacks the nearest
   * player
  */
  static readonly CLOSEST_PLAYER: TargetReason;
  /**
   * When the target attacks the entity, so entity targets it
  */
  static readonly TARGET_ATTACKED_ENTITY: TargetReason;
  /**
   * When the target attacks a fellow pig zombie, so the whole group
   * will target him with this reason.
   *
   * @deprecated obsoleted by {@link #TARGET_ATTACKED_NEARBY_ENTITY}
  */
  static readonly PIG_ZOMBIE_TARGET: TargetReason;
  /**
   * When the target is forgotten for whatever reason.
  */
  static readonly FORGOT_TARGET: TargetReason;
  /**
   * When the target attacks the owner of the entity, so the entity
   * targets it.
  */
  static readonly TARGET_ATTACKED_OWNER: TargetReason;
  /**
   * When the owner of the entity attacks the target attacks, so the
   * entity targets it.
  */
  static readonly OWNER_ATTACKED_TARGET: TargetReason;
  /**
   * When the entity has no target, so the entity randomly chooses one.
  */
  static readonly RANDOM_TARGET: TargetReason;
  /**
   * When an entity selects a target while defending a village.
  */
  static readonly DEFEND_VILLAGE: TargetReason;
  /**
   * When the target attacks a nearby entity of the same type, so the entity targets it
  */
  static readonly TARGET_ATTACKED_NEARBY_ENTITY: TargetReason;
  /**
   * When a zombie targeting an entity summons reinforcements, so the reinforcements target the same entity
  */
  static readonly REINFORCEMENT_TARGET: TargetReason;
  /**
   * When an entity targets another entity after colliding with it.
  */
  static readonly COLLISION: TargetReason;
  /**
   * For custom calls to the event.
  */
  static readonly CUSTOM: TargetReason;
  /**
   * When the entity doesn't have a target, so it attacks the nearest
   * entity
  */
  static readonly CLOSEST_ENTITY: TargetReason;
  /**
   * When a raiding entity selects the same target as one of its compatriots.
  */
  static readonly FOLLOW_LEADER: TargetReason;
  /**
   * When another entity tempts this entity by having a desired item such
   * as wheat in it's hand.
  */
  static readonly TEMPT: TargetReason;
  static readonly TARGET_OTHER_LEVEL: TargetReason;
  static readonly TARGET_INVALID: TargetReason;
  /**
   * A currently unknown reason for the entity changing target.
  */
  static readonly UNKNOWN: TargetReason;
  static valueOf(name: string): TargetReason;
  static values(): TargetReason[];
}

}
declare module 'org.bukkit.inventory.RecipeChoice' {
import { List } from 'java.util';
import { RecipeChoice, ItemStack } from 'org.bukkit.inventory';
import { Material, Tag } from 'org.bukkit';
/**
 * Represents a choice of multiple matching Materials.
*/
export class MaterialChoice extends RecipeChoice {
  constructor(choice: Material);
  constructor(...choices: Material[]);
  /**
   * Constructs a MaterialChoice with the current values of the specified
   * tag.
   *
   * @param choices the tag
  */
  constructor(choices: Tag<Material>);
  constructor(choices: Material[]);
  test(t: ItemStack): boolean;
  /**
   * Gets a single item stack representative of this stack choice.
   *
   * @return a single representative item
   * @deprecated for compatibility only
  */
  getItemStack(): ItemStack;
  getChoices(): Material[];
  clone(): MaterialChoice;
  hashCode(): number;
  equals(obj: any): boolean;
  toString(): string;
}
/**
 * Represents a choice that will be valid only one of the stacks is exactly
 * matched (aside from stack size).
 * 
 * Only valid for shaped recipes
*/
export class ExactChoice extends RecipeChoice {
  constructor(stack: ItemStack);
  constructor(...stacks: ItemStack[]);
  constructor(choices: ItemStack[]);
  /**
   * Gets a single item stack representative of this stack choice.
   *
   * @return a single representative item
   * @deprecated for compatibility only
  */
  getItemStack(): ItemStack;
  getChoices(): ItemStack[];
  clone(): ExactChoice;
  test(t: ItemStack): boolean;
  hashCode(): number;
  equals(obj: any): boolean;
  toString(): string;
}

}
declare module 'org.bukkit.potion' {
import { Enum } from 'java.lang';
import { Collection, Map } from 'java.util';
import { PotionMix } from 'io.papermc.paper.potion';
import { Attribute, AttributeModifier } from 'org.bukkit.attribute';
import { ConfigurationSerializable } from 'org.bukkit.configuration.serialization';
import { Translatable } from 'net.kyori.adventure.translation';
import { Category } from 'org.bukkit.potion.PotionEffectType';
import { ItemStack } from 'org.bukkit.inventory';
import { LivingEntity } from 'org.bukkit.entity';
import { NamespacedKey, Color, Keyed } from 'org.bukkit';
/**
 * Represents a brewer that can create {@link PotionEffect}s.
*/
export class PotionBrewer {
  /**
   * Creates a {@link PotionEffect} from the given {@link PotionEffectType},
   * applying duration modifiers and checks.
   *
   * @param potion The type of potion
   * @param duration The duration in ticks
   * @param amplifier The amplifier of the effect
   * @return The resulting potion effect
  */
  createEffect(potion: PotionEffectType, duration: number, amplifier: number): PotionEffect;
  /**
   * Returns a collection of {@link PotionEffect} that would be applied from
   * a potion with the given data value.
   *
   * @param damage The data value of the potion
   * @return The list of effects
   * @deprecated Non-Functional
  */
  getEffectsFromDamage(damage: number): Collection<PotionEffect>;
  /**
   * Returns a collection of {@link PotionEffect} that would be applied from
   * a potion with the given type.
   *
   * @param type The type of the potion
   * @param upgraded Whether the potion is upgraded
   * @param extended Whether the potion is extended
   * @return The list of effects
  */
  getEffects(type: PotionType, upgraded: boolean, extended: boolean): Collection<PotionEffect>;
  /**
   * Adds a new potion mix recipe.
   *
   * @param potionMix the potion mix to add
  */
  addPotionMix(potionMix: PotionMix): void;
  /**
   * Removes a potion mix recipe.
   *
   * @param key the key of the mix to remove
  */
  removePotionMix(key: NamespacedKey): void;
  /**
   * Resets potion mixes to their default, removing all custom ones.
  */
  resetPotionMixes(): void;
}
/**
 * Potion Adapter for pre-1.9 data values
 * see @PotionMeta for 1.9+
*/
export class Potion {
  /**
   * Construct a new potion of the given type. Unless the type is {@link
   * PotionType#WATER}, it will be level one, without extended duration.
   * Don't use this constructor to create a no-effect potion other than
   * water bottle.
   *
   * @param type The potion type
  */
  constructor(type: PotionType);
  /**
   * Create a new potion of the given type and level.
   *
   * @param type The type of potion.
   * @param level The potion's level.
  */
  constructor(type: PotionType, level: number);
  /**
   * Create a new potion of the given type and level.
   *
   * @param type The type of potion.
   * @param level The potion's level.
   * @param splash Whether it is a splash potion.
   * @deprecated In favour of using {@link #Potion(PotionType)} with {@link
   *     #splash()}.
  */
  constructor(type: PotionType, level: number, splash: boolean);
  /**
   * Create a new potion of the given type and level.
   *
   * @param type The type of potion.
   * @param level The potion's level.
   * @param splash Whether it is a splash potion.
   * @param extended Whether it has an extended duration.
   * @deprecated In favour of using {@link #Potion(PotionType)} with {@link
   *     #extend()} and possibly {@link #splash()}.
  */
  constructor(type: PotionType, level: number, splash: boolean, extended: boolean);
  /**
   * Chain this to the constructor to make the potion a splash potion.
   *
   * @return The potion.
  */
  splash(): Potion;
  /**
   * Chain this to the constructor to extend the potion's duration.
   *
   * @return The potion.
  */
  extend(): Potion;
  /**
   * Applies the effects of this potion to the given {@link ItemStack}. The
   * ItemStack must be a potion.
   *
   * @param to The itemstack to apply to
  */
  apply(to: ItemStack): void;
  /**
   * Applies the effects that would be applied by this potion to the given
   * {@link LivingEntity}.
   *
   * @param to The entity to apply the effects to
   * @see LivingEntity#addPotionEffects(Collection)
  */
  apply(to: LivingEntity): void;
  equals(obj: any): boolean;
  /**
   * Returns a collection of {@link PotionEffect}s that this {@link Potion}
   * would confer upon a {@link LivingEntity}.
   *
   * @return The effects that this potion applies
   * @see PotionBrewer#getEffectsFromDamage(int)
   * @see Potion#toDamageValue()
  */
  getEffects(): Collection<PotionEffect>;
  /**
   * Returns the level of this potion.
   *
   * @return The level of this potion
  */
  getLevel(): number;
  /**
   * Returns the {@link PotionType} of this potion.
   *
   * @return The type of this potion
  */
  getType(): PotionType;
  /**
   * Returns whether this potion has an extended duration.
   *
   * @return Whether this potion has extended duration
  */
  hasExtendedDuration(): boolean;
  hashCode(): number;
  /**
   * Returns whether this potion is a splash potion.
   *
   * @return Whether this is a splash potion
  */
  isSplash(): boolean;
  /**
   * Set whether this potion has extended duration. This will cause the
   * potion to have roughly 8/3 more duration than a regular potion.
   *
   * @param isExtended Whether the potion should have extended duration
  */
  setHasExtendedDuration(isExtended: boolean): void;
  /**
   * Sets whether this potion is a splash potion. Splash potions can be
   * thrown for a radius effect.
   *
   * @param isSplash Whether this is a splash potion
  */
  setSplash(isSplash: boolean): void;
  /**
   * Sets the {@link PotionType} of this potion.
   *
   * @param type The new type of this potion
  */
  setType(type: PotionType);
  /**
   * Sets the level of this potion.
   *
   * @param level The new level of this potion
  */
  setLevel(level: number);
  /**
   * Converts this potion to a valid potion damage short, usable for potion
   * item stacks.
   *
   * @return The damage value of this potion
   * @deprecated Non-functional
  */
  toDamageValue(): number;
  /**
   * Converts this potion to an {@link ItemStack} with the specified amount
   * and a correct damage value.
   *
   * @param amount The amount of the ItemStack
   * @return The created ItemStack
  */
  toItemStack(amount: number): ItemStack;
  /**
   * Gets the potion from its damage value.
   *
   * @param damage the damage value
   * @return the produced potion
  */
  static fromDamage(damage: number): Potion;
  static fromItemStack(item: ItemStack): Potion;
  /**
   * Returns an instance of {@link PotionBrewer}.
   *
   * @return An instance of PotionBrewer
  */
  static getBrewer(): PotionBrewer;
  /**
   * Sets the current instance of {@link PotionBrewer}. Generally not to be
   * used from within a plugin.
   *
   * @param other The new PotionBrewer
  */
  static setPotionBrewer(potionBrewer: PotionBrewer);
  /**
   * Gets the potion from its name id.
   *
   * @return the name id
   * @deprecated Non-functional
  */
  getNameId(): number;
}
/**
 * This enum reflects and matches each potion state that can be obtained from
 * the Creative mode inventory
*/
export class PotionType extends Enum<PotionType> {
  static readonly UNCRAFTABLE: PotionType;
  static readonly WATER: PotionType;
  static readonly MUNDANE: PotionType;
  static readonly THICK: PotionType;
  static readonly AWKWARD: PotionType;
  static readonly NIGHT_VISION: PotionType;
  static readonly INVISIBILITY: PotionType;
  static readonly JUMP: PotionType;
  static readonly FIRE_RESISTANCE: PotionType;
  static readonly SPEED: PotionType;
  static readonly SLOWNESS: PotionType;
  static readonly WATER_BREATHING: PotionType;
  static readonly INSTANT_HEAL: PotionType;
  static readonly INSTANT_DAMAGE: PotionType;
  static readonly POISON: PotionType;
  static readonly REGEN: PotionType;
  static readonly STRENGTH: PotionType;
  static readonly WEAKNESS: PotionType;
  static readonly LUCK: PotionType;
  static readonly TURTLE_MASTER: PotionType;
  static readonly SLOW_FALLING: PotionType;
  static valueOf(name: string): PotionType;
  static values(): PotionType[];
  getEffectType(): PotionEffectType | null;
  isInstant(): boolean;
  /**
   * Checks if the potion type has an upgraded state.
   * This refers to whether or not the potion type can be Tier 2,
   * such as Potion of Fire Resistance II.
   *
   * @return true if the potion type can be upgraded;
  */
  isUpgradeable(): boolean;
  /**
   * Checks if the potion type has an extended state.
   * This refers to the extended duration potions
   *
   * @return true if the potion type can be extended
  */
  isExtendable(): boolean;
  getMaxLevel(): number;
  /**
   * @param effectType the effect to get by
   * @return the matching potion type
   * @deprecated Misleading
  */
  static getByEffect(effectType: PotionEffectType | null): PotionType | null;
}
export class PotionEffectTypeWrapper extends PotionEffectType {
  getDurationModifier(): number;
  getName(): string;
  /**
   * Get the potion type bound to this wrapper.
   *
   * @return The potion effect type
  */
  getType(): PotionEffectType;
  isInstant(): boolean;
  getColor(): Color;
  getKey(): NamespacedKey;
  getEffectAttributes(): Map<Attribute, AttributeModifier>;
  getAttributeModifierAmount(attribute: Attribute, effectAmplifier: number): number;
  getEffectCategory(): Category;
  translationKey(): string;
}
export class PotionData {
  /**
   * Instantiates a final PotionData object to contain information about a
   * Potion
   *
   * @param type the type of the Potion
   * @param extended whether the potion is extended PotionType#isExtendable()
   * must be true
   * @param upgraded whether the potion is upgraded PotionType#isUpgradable()
   * must be true
  */
  constructor(type: PotionType, extended: boolean, upgraded: boolean);
  constructor(type: PotionType);
  /**
   * Gets the type of the potion, Type matches up with each kind of craftable
   * potion
   *
   * @return the potion type
  */
  getType(): PotionType;
  /**
   * Checks if the potion is in an upgraded state. This refers to whether or
   * not the potion is Tier 2, such as Potion of Fire Resistance II.
   *
   * @return true if the potion is upgraded;
  */
  isUpgraded(): boolean;
  /**
   * Checks if the potion is in an extended state. This refers to the extended
   * duration potions
   *
   * @return true if the potion is extended
  */
  isExtended(): boolean;
  hashCode(): number;
  equals(obj: any): boolean;
}
/**
 * Represents a type of potion and its effect on an entity.
*/
export class PotionEffectType extends Keyed {
  /**
   * Increases movement speed.
  */
  static readonly SPEED: PotionEffectType;
  /**
   * Decreases movement speed.
  */
  static readonly SLOW: PotionEffectType;
  /**
   * Increases dig speed.
  */
  static readonly FAST_DIGGING: PotionEffectType;
  /**
   * Decreases dig speed.
  */
  static readonly SLOW_DIGGING: PotionEffectType;
  /**
   * Increases damage dealt.
  */
  static readonly INCREASE_DAMAGE: PotionEffectType;
  /**
   * Heals an entity.
  */
  static readonly HEAL: PotionEffectType;
  /**
   * Hurts an entity.
  */
  static readonly HARM: PotionEffectType;
  /**
   * Increases jump height.
  */
  static readonly JUMP: PotionEffectType;
  /**
   * Warps vision on the client.
  */
  static readonly CONFUSION: PotionEffectType;
  /**
   * Regenerates health.
  */
  static readonly REGENERATION: PotionEffectType;
  /**
   * Decreases damage dealt to an entity.
  */
  static readonly DAMAGE_RESISTANCE: PotionEffectType;
  /**
   * Stops fire damage.
  */
  static readonly FIRE_RESISTANCE: PotionEffectType;
  /**
   * Allows breathing underwater.
  */
  static readonly WATER_BREATHING: PotionEffectType;
  /**
   * Grants invisibility.
  */
  static readonly INVISIBILITY: PotionEffectType;
  /**
   * Blinds an entity.
  */
  static readonly BLINDNESS: PotionEffectType;
  /**
   * Allows an entity to see in the dark.
  */
  static readonly NIGHT_VISION: PotionEffectType;
  /**
   * Increases hunger.
  */
  static readonly HUNGER: PotionEffectType;
  /**
   * Decreases damage dealt by an entity.
  */
  static readonly WEAKNESS: PotionEffectType;
  /**
   * Deals damage to an entity over time.
  */
  static readonly POISON: PotionEffectType;
  /**
   * Deals damage to an entity over time and gives the health to the
   * shooter.
  */
  static readonly WITHER: PotionEffectType;
  /**
   * Increases the maximum health of an entity.
  */
  static readonly HEALTH_BOOST: PotionEffectType;
  /**
   * Increases the maximum health of an entity with health that cannot be
   * regenerated, but is refilled every 30 seconds.
  */
  static readonly ABSORPTION: PotionEffectType;
  /**
   * Increases the food level of an entity each tick.
  */
  static readonly SATURATION: PotionEffectType;
  /**
   * Outlines the entity so that it can be seen from afar.
  */
  static readonly GLOWING: PotionEffectType;
  /**
   * Causes the entity to float into the air.
  */
  static readonly LEVITATION: PotionEffectType;
  /**
   * Loot table luck.
  */
  static readonly LUCK: PotionEffectType;
  /**
   * Loot table unluck.
  */
  static readonly UNLUCK: PotionEffectType;
  /**
   * Slows entity fall rate.
  */
  static readonly SLOW_FALLING: PotionEffectType;
  /**
   * Effects granted by a nearby conduit. Includes enhanced underwater abilities.
  */
  static readonly CONDUIT_POWER: PotionEffectType;
  /**
   * Increses underwater movement speed.
   * Squee'ek uh'k kk'kkkk squeek eee'eek.
  */
  static readonly DOLPHINS_GRACE: PotionEffectType;
  /**
   * Triggers a raid when the player enters a village.
   * oof.
  */
  static readonly BAD_OMEN: PotionEffectType;
  /**
   * Reduces the cost of villager trades.
   * \o/.
  */
  static readonly HERO_OF_THE_VILLAGE: PotionEffectType;
  /**
   * Creates a PotionEffect from this PotionEffectType, applying duration
   * modifiers and checks.
   *
   * @param duration time in ticks
   * @param amplifier the effect's amplifier
   * @return a resulting potion effect
   * @see PotionBrewer#createEffect(PotionEffectType, int, int)
  */
  createEffect(duration: number, amplifier: number): PotionEffect;
  /**
   * Returns the duration modifier applied to effects of this type.
   *
   * @return duration modifier
   * @deprecated unused, always 1.0
  */
  getDurationModifier(): number;
  /**
   * Returns the unique ID of this type.
   *
   * @return Unique ID
   * @deprecated Magic value
  */
  getId(): number;
  /**
   * Return the namespaced identifier for this object.
   *
   * @return this object's key
  */
  getKey(): NamespacedKey;
  /**
   * Returns the name of this effect type.
   *
   * @return The name of this effect type
  */
  getName(): string;
  /**
   * Returns whether the effect of this type happens once, immediately.
   *
   * @return whether this type is normally instant
  */
  isInstant(): boolean;
  /**
   * Returns the color of this effect type.
   *
   * @return the color
  */
  getColor(): Color;
  equals(obj: any): boolean;
  hashCode(): number;
  toString(): string;
  /**
   * Gets the PotionEffectType at the specified key
   *
   * @param key key to fetch
   * @return Resulting PotionEffectType, or null if not found
  */
  static getByKey(key: NamespacedKey | null): PotionEffectType | null;
  /**
   * Gets the effect type specified by the unique id.
   *
   * @param id Unique ID to fetch
   * @return Resulting type, or null if not found.
   * @deprecated Magic value
  */
  static getById(id: number): PotionEffectType | null;
  /**
   * Gets the effect type specified by the given name.
   *
   * @param name Name of PotionEffectType to fetch
   * @return Resulting PotionEffectType, or null if not found.
  */
  static getByName(name: string): PotionEffectType | null;
  /**
   * Registers an effect type with the given object.
   * 
   * Generally not to be used from within a plugin.
   *
   * @param type PotionType to register
  */
  static registerPotionEffectType(type: PotionEffectType): void;
  /**
   * Stops accepting any effect type registrations.
  */
  static stopAcceptingRegistrations(): void;
  /**
   * Returns an array of all the registered {@link PotionEffectType}s.
   * This array is not necessarily in any particular order.
   *
   * @return Array of types.
  */
  static values(): PotionEffectType[];
  /**
   * Gets the effect attributes in an immutable map.
   *
   * @return the attribute map
  */
  getEffectAttributes(): Map<Attribute, AttributeModifier>;
  /**
   * Gets the true modifier amount based on the effect amplifier.
   *
   * @param attribute the attribute
   * @param effectAmplifier the effect amplifier (0 indexed)
   * @return the modifier amount
   * @throws IllegalArgumentException if the supplied attribute is not present in the map from {@link #getEffectAttributes()}
  */
  getAttributeModifierAmount(attribute: Attribute, effectAmplifier: number): number;
  /**
   * Gets the category of this effect
   *
   * @return the category
  */
  getEffectCategory(): Category;
}
export interface PotionEffectType extends Keyed, Translatable {}
/**
 * Represents a potion effect, that can be added to a {@link LivingEntity}. A
 * potion effect has a duration that it will last for, an amplifier that will
 * enhance its effects, and a {@link PotionEffectType}, that represents its
 * effect on an entity.
*/
export class PotionEffect extends ConfigurationSerializable {
  /**
   * Creates a potion effect.
   * @param type effect type
   * @param duration measured in ticks, see {@link
   *     PotionEffect#getDuration()}
   * @param amplifier the amplifier, see {@link PotionEffect#getAmplifier()}
   * @param ambient the ambient status, see {@link PotionEffect#isAmbient()}
   * @param particles the particle status, see {@link PotionEffect#hasParticles()}
   * @param icon the icon status, see {@link PotionEffect#hasIcon()}
  */
  constructor(type: PotionEffectType, duration: number, amplifier: number, ambient: boolean, particles: boolean, icon: boolean);
  /**
   * Creates a potion effect with no defined color.
   *
   * @param type effect type
   * @param duration measured in ticks, see {@link
   *     PotionEffect#getDuration()}
   * @param amplifier the amplifier, see {@link PotionEffect#getAmplifier()}
   * @param ambient the ambient status, see {@link PotionEffect#isAmbient()}
   * @param particles the particle status, see {@link PotionEffect#hasParticles()}
  */
  constructor(type: PotionEffectType, duration: number, amplifier: number, ambient: boolean, particles: boolean);
  /**
   * Creates a potion effect. Assumes that particles are visible
   *
   * @param type effect type
   * @param duration measured in ticks, see {@link
   *     PotionEffect#getDuration()}
   * @param amplifier the amplifier, see {@link PotionEffect#getAmplifier()}
   * @param ambient the ambient status, see {@link PotionEffect#isAmbient()}
  */
  constructor(type: PotionEffectType, duration: number, amplifier: number, ambient: boolean);
  /**
   * Creates a potion effect. Assumes ambient is true.
   *
   * @param type Effect type
   * @param duration measured in ticks
   * @param amplifier the amplifier for the effect
   * @see PotionEffect#PotionEffect(PotionEffectType, int, int, boolean)
  */
  constructor(type: PotionEffectType, duration: number, amplifier: number);
  /**
   * Constructor for deserialization.
   *
   * @param map the map to deserialize from
  */
  constructor(map: Map<string, any>);
  withType(type: PotionEffectType): PotionEffect;
  withDuration(duration: number): PotionEffect;
  withAmplifier(amplifier: number): PotionEffect;
  withAmbient(ambient: boolean): PotionEffect;
  withParticles(particles: boolean): PotionEffect;
  withIcon(icon: boolean): PotionEffect;
  /**
   * Creates a Map representation of this class.
   * 
   * This class must provide a method to restore this class, as defined in
   * the {@link ConfigurationSerializable} interface javadocs.
   *
   * @return Map containing the current state of this class
  */
  serialize(): Map<string, any>;
  /**
   * Attempts to add the effect represented by this object to the given
   * {@link LivingEntity}.
   *
   * @param entity The entity to add this effect to
   * @return Whether the effect could be added
   * @see LivingEntity#addPotionEffect(PotionEffect)
  */
  apply(entity: LivingEntity): boolean;
  equals(obj: any): boolean;
  /**
   * Returns the amplifier of this effect. A higher amplifier means the
   * potion effect happens more often over its duration and in some cases
   * has more effect on its target.
   *
   * @return The effect amplifier
  */
  getAmplifier(): number;
  /**
   * Returns the duration (in ticks) that this effect will run for when
   * applied to a {@link LivingEntity}.
   *
   * @return The duration of the effect
  */
  getDuration(): number;
  /**
   * Returns the {@link PotionEffectType} of this effect.
   *
   * @return The potion type of this effect
  */
  getType(): PotionEffectType;
  /**
   * Makes potion effect produce more, translucent, particles.
   *
   * @return if this effect is ambient
  */
  isAmbient(): boolean;
  /**
   * @return whether this effect has particles or not
  */
  hasParticles(): boolean;
  /**
   * @return color of this potion's particles. May be null if the potion has no particles or defined color.
   * @deprecated color is not part of potion effects
  */
  getColor(): Color | null;
  /**
   * @return whether this effect has an icon or not
  */
  hasIcon(): boolean;
  hashCode(): number;
  toString(): string;
}

}
declare module 'org.bukkit.event.entity.EntityTransformEvent' {
import { Enum } from 'java.lang';
export class TransformReason extends Enum<TransformReason> {
  /**
   * When a zombie gets cured and a villager is spawned.
  */
  static readonly CURED: TransformReason;
  /**
   * When an entity is shaking in Powder Snow and a new entity spawns.
  */
  static readonly FROZEN: TransformReason;
  /**
   * When a villager gets infected and a zombie villager spawns.
  */
  static readonly INFECTION: TransformReason;
  /**
   * When an entity drowns in water and a new entity spawns.
  */
  static readonly DROWNED: TransformReason;
  /**
   * When a mooshroom (or MUSHROOM_COW) is sheared and a cow spawns.
  */
  static readonly SHEARED: TransformReason;
  /**
   * When lightning strikes a entity.
  */
  static readonly LIGHTNING: TransformReason;
  /**
   * When a slime splits into multiple smaller slimes.
  */
  static readonly SPLIT: TransformReason;
  /**
   * When a piglin converts to a zombified piglin.
  */
  static readonly PIGLIN_ZOMBIFIED: TransformReason;
  /**
   * When reason is unknown.
  */
  static readonly UNKNOWN: TransformReason;
  static valueOf(name: string): TransformReason;
  static values(): TransformReason[];
}

}
declare module 'org.bukkit.block.data.FaceAttachable' {
import { Enum } from 'java.lang';
/**
 * The face to which a switch type block is stuck.
*/
export class AttachedFace extends Enum<AttachedFace> {
  /**
   * The switch is mounted to the floor and pointing upwards.
  */
  static readonly FLOOR: AttachedFace;
  /**
   * The switch is mounted to the wall.
  */
  static readonly WALL: AttachedFace;
  /**
   * The switch is mounted to the ceiling and pointing dowanrds.
  */
  static readonly CEILING: AttachedFace;
  static valueOf(name: string): AttachedFace;
  static values(): AttachedFace[];
}

}
declare module 'org.bukkit.Effect' {
import { Enum } from 'java.lang';
/**
 * Represents the type of an effect.
*/
export class Type extends Enum<Type> {
  static readonly SOUND: Type;
  static readonly VISUAL: Type;
  static valueOf(name: string): Type;
  static values(): Type[];
}

}
declare module 'org.bukkit.block.data.type.Comparator' {
import { Enum } from 'java.lang';
/**
 * The mode in which a comparator will operate in.
*/
export class Mode extends Enum<Mode> {
  /**
   * The default mode, similar to a transistor. The comparator will turn
   * off if either side input is greater than the rear input.
  */
  static readonly COMPARE: Mode;
  /**
   * Alternate subtraction mode. The output signal strength will be equal
   * to max(rear-max(left,right),0).
  */
  static readonly SUBTRACT: Mode;
  static valueOf(name: string): Mode;
  static values(): Mode[];
}

}
declare module 'org.bukkit.block.data.type.StructureBlock' {
import { Enum } from 'java.lang';
/**
 * Operating mode of a structure block.
*/
export class Mode extends Enum<Mode> {
  /**
   * Allows selection and saving of a structure.
  */
  static readonly SAVE: Mode;
  /**
   * Allows loading of a structure.
  */
  static readonly LOAD: Mode;
  /**
   * Used for detection of two opposite corners of a structure.
  */
  static readonly CORNER: Mode;
  /**
   * Dummy block used to run a custom function during world generation
   * before being removed.
  */
  static readonly DATA: Mode;
  static valueOf(name: string): Mode;
  static values(): Mode[];
}

}
declare module 'org.bukkit.event.entity.EntityDamageEvent' {
import { Enum } from 'java.lang';
/**
 * An enum to specify the types of modifier
 *
 * @deprecated This API is responsible for a large number of implementation
 * problems and is in general unsustainable to maintain. It is likely to be
 * removed very soon in a subsequent release. Please see
 * https://www.spigotmc.org/threads/194446/ for more information.
*/
export class DamageModifier extends Enum<DamageModifier> {
  /**
   * This represents the amount of damage being done, also known as the
   * raw {@link EntityDamageEvent#getDamage()}.
  */
  static readonly BASE: DamageModifier;
  /**
   * This represents the damage reduced by a wearing a helmet when hit
   * by a falling block.
  */
  static readonly HARD_HAT: DamageModifier;
  /**
   * This represents  the damage reduction caused by blocking, only present for
   * {@link Player Players}.
  */
  static readonly BLOCKING: DamageModifier;
  /**
   * This represents the damage reduction caused by wearing armor.
  */
  static readonly ARMOR: DamageModifier;
  /**
   * This represents the damage reduction caused by the Resistance potion effect.
  */
  static readonly RESISTANCE: DamageModifier;
  /**
   * This represents the damage reduction caused by the combination of:
   * 
   * 
   *     Armor enchantments
   * 
   *     Witch's potion resistance
   * 
   * 
  */
  static readonly MAGIC: DamageModifier;
  /**
   * This represents the damage reduction caused by the absorption potion
   * effect.
  */
  static readonly ABSORPTION: DamageModifier;
  static valueOf(name: string): DamageModifier;
  static values(): DamageModifier[];
}
/**
 * An enum to specify the cause of the damage
*/
export class DamageCause extends Enum<DamageCause> {
  /**
   * Damage caused when an entity contacts a block such as a Cactus,
   * Dripstone (Stalagmite) or Berry Bush.
   * 
   * Damage: variable
  */
  static readonly CONTACT: DamageCause;
  /**
   * Damage caused when an entity attacks another entity.
   * 
   * Damage: variable
  */
  static readonly ENTITY_ATTACK: DamageCause;
  /**
   * Damage caused when an entity attacks another entity in a sweep attack.
   * 
   * Damage: variable
  */
  static readonly ENTITY_SWEEP_ATTACK: DamageCause;
  /**
   * Damage caused when attacked by a projectile.
   * 
   * Damage: variable
  */
  static readonly PROJECTILE: DamageCause;
  /**
   * Damage caused by being put in a block
   * 
   * Damage: 1
  */
  static readonly SUFFOCATION: DamageCause;
  /**
   * Damage caused when an entity falls a distance greater than 3 blocks
   * 
   * Damage: fall height - 3.0
  */
  static readonly FALL: DamageCause;
  /**
   * Damage caused by direct exposure to fire
   * 
   * Damage: 1
  */
  static readonly FIRE: DamageCause;
  /**
   * Damage caused due to burns caused by fire
   * 
   * Damage: 1
  */
  static readonly FIRE_TICK: DamageCause;
  /**
   * Damage caused due to a snowman melting
   * 
   * Damage: 1
  */
  static readonly MELTING: DamageCause;
  /**
   * Damage caused by direct exposure to lava
   * 
   * Damage: 4
  */
  static readonly LAVA: DamageCause;
  /**
   * Damage caused by running out of air while in water
   * 
   * Damage: 2
  */
  static readonly DROWNING: DamageCause;
  /**
   * Damage caused by being in the area when a block explodes.
   * 
   * Damage: variable
  */
  static readonly BLOCK_EXPLOSION: DamageCause;
  /**
   * Damage caused by being in the area when an entity, such as a
   * Creeper, explodes.
   * 
   * Damage: variable
  */
  static readonly ENTITY_EXPLOSION: DamageCause;
  /**
   * Damage caused by falling into the void
   * 
   * Damage: 4 for players
  */
  static readonly VOID: DamageCause;
  /**
   * Damage caused by being struck by lightning
   * 
   * Damage: 5
  */
  static readonly LIGHTNING: DamageCause;
  /**
   * Damage caused by committing suicide.
   * 
   * Note: This is currently only used by plugins, default commands
   * like /minecraft:kill use {@link #VOID} to damage players.
   * 
   * Damage: variable
  */
  static readonly SUICIDE: DamageCause;
  /**
   * Damage caused by starving due to having an empty hunger bar
   * 
   * Damage: 1
  */
  static readonly STARVATION: DamageCause;
  /**
   * Damage caused due to an ongoing poison effect
   * 
   * Damage: 1
  */
  static readonly POISON: DamageCause;
  /**
   * Damage caused by being hit by a damage potion or spell
   * 
   * Damage: variable
  */
  static readonly MAGIC: DamageCause;
  /**
   * Damage caused by Wither potion effect
  */
  static readonly WITHER: DamageCause;
  /**
   * Damage caused by being hit by a falling block which deals damage
   * 
   * Note: Not every block deals damage
   * 
   * Damage: variable
  */
  static readonly FALLING_BLOCK: DamageCause;
  /**
   * Damage caused in retaliation to another attack by the Thorns
   * enchantment.
   * 
   * Damage: 1-4 (Thorns)
  */
  static readonly THORNS: DamageCause;
  /**
   * Damage caused by a dragon breathing fire.
   * 
   * Damage: variable
  */
  static readonly DRAGON_BREATH: DamageCause;
  /**
   * Custom damage.
   * 
   * Damage: variable
  */
  static readonly CUSTOM: DamageCause;
  /**
   * Damage caused when an entity runs into a wall.
   * 
   * Damage: variable
  */
  static readonly FLY_INTO_WALL: DamageCause;
  /**
   * Damage caused when an entity steps on {@link Material#MAGMA_BLOCK}.
   * 
   * Damage: 1
  */
  static readonly HOT_FLOOR: DamageCause;
  /**
   * Damage caused when an entity is colliding with too many entities due
   * to the maxEntityCramming game rule.
   * 
   * Damage: 6
  */
  static readonly CRAMMING: DamageCause;
  /**
   * Damage caused when an entity that should be in water is not.
   * 
   * Damage: 1
  */
  static readonly DRYOUT: DamageCause;
  /**
   * Damage caused from freezing.
   * 
   * Damage: 1 or 5
  */
  static readonly FREEZE: DamageCause;
  static valueOf(name: string): DamageCause;
  static values(): DamageCause[];
}

}
declare module 'org.bukkit.scoreboard.Team' {
import { Enum } from 'java.lang';
/**
 * Represents an option which may be applied to this team.
*/
export class Option extends Enum<Option> {
  /**
   * How to display the name tags of players on this team.
  */
  static readonly NAME_TAG_VISIBILITY: Option;
  /**
   * How to display the death messages for players on this team.
  */
  static readonly DEATH_MESSAGE_VISIBILITY: Option;
  /**
   * How players of this team collide with others.
  */
  static readonly COLLISION_RULE: Option;
  static valueOf(name: string): Option;
  static values(): Option[];
}
/**
 * How an option may be applied to members of this team.
*/
export class OptionStatus extends Enum<OptionStatus> {
  /**
   * Apply this option to everyone.
  */
  static readonly ALWAYS: OptionStatus;
  /**
   * Never apply this option.
  */
  static readonly NEVER: OptionStatus;
  /**
   * Apply this option only for opposing teams.
  */
  static readonly FOR_OTHER_TEAMS: OptionStatus;
  /**
   * Apply this option for only team members.
  */
  static readonly FOR_OWN_TEAM: OptionStatus;
  static valueOf(name: string): OptionStatus;
  static values(): OptionStatus[];
}

}
declare module 'org.bukkit.event.inventory.InventoryType' {
import { Enum } from 'java.lang';
export class SlotType extends Enum<SlotType> {
  /**
   * A result slot in a furnace or crafting inventory.
  */
  static readonly RESULT: SlotType;
  /**
   * A slot in the crafting matrix, or an 'input' slot.
  */
  static readonly CRAFTING: SlotType;
  /**
   * An armour slot in the player's inventory.
  */
  static readonly ARMOR: SlotType;
  /**
   * A regular slot in the container or the player's inventory; anything
   * not covered by the other enum values.
  */
  static readonly CONTAINER: SlotType;
  /**
   * A slot in the bottom row or quickbar.
  */
  static readonly QUICKBAR: SlotType;
  /**
   * A pseudo-slot representing the area outside the inventory window.
  */
  static readonly OUTSIDE: SlotType;
  /**
   * The fuel slot in a furnace inventory, or the ingredient slot in a
   * brewing stand inventory.
  */
  static readonly FUEL: SlotType;
  static valueOf(name: string): SlotType;
  static values(): SlotType[];
}

}
declare module 'org.bukkit.entity.minecart' {
import { Component } from 'net.kyori.adventure.text';
import { LootableEntityInventory } from 'com.destroystokyo.paper.loottable';
import { CommandBlockHolder } from 'io.papermc.paper.command';
import { Minecart } from 'org.bukkit.entity';
import { InventoryHolder } from 'org.bukkit.inventory';
/**
 * Represents a Minecart with TNT inside it that can explode when triggered.
*/
export class ExplosiveMinecart extends Minecart {

}
/**
 * Represents a powered minecart. A powered minecart moves on its own when a
 * player deposits {@link org.bukkit.Material#COAL fuel}.
*/
export class PoweredMinecart extends Minecart {
  /**
   * Get the number of ticks until the minecart runs out of fuel.
   *
   * @return Number of ticks until the minecart runs out of fuel
  */
  getFuel(): number;
  /**
   * Set the number of ticks until the minecart runs out of fuel.
   *
   * @param fuel Number of ticks until the minecart runs out of fuel
  */
  setFuel(fuel: number);
  /**
   * Get the x push of the minecart.
   *
   * @return The x push of the minecart
  */
  getPushX(): number;
  /**
   * Get the z push of the minecart.
   *
   * @return The z push of the minecart
  */
  getPushZ(): number;
  /**
   * Set the x push of the minecart.
   *
   * @param xPush The new x push of the minecart
  */
  setPushX(pushX: number);
  /**
   * Set the z push of the minecart.
   *
   * @param zPush The new z push of the minecart
  */
  setPushZ(pushZ: number);
}
export class CommandMinecart extends Minecart {
  /**
   * Gets the command that this CommandMinecart will run when activated.
   * This will never return null.  If the CommandMinecart does not have a
   * command, an empty String will be returned instead.
   *
   * @return Command that this CommandMinecart will run when powered.
  */
  getCommand(): string;
  /**
   * Sets the command that this CommandMinecart will run when activated.
   * Setting the command to null is the same as setting it to an empty
   * String.
   *
   * @param command Command that this CommandMinecart will run when
   *     activated.
  */
  setCommand(command: string | null);
  /**
   * Sets the name of this CommandMinecart.  The name is used with commands
   * that this CommandMinecart executes.  Setting the name to null is the
   * same as setting it to "@".
   *
   * @param name New name for this CommandMinecart.
   * @deprecated in favour of {@link #customName(net.kyori.adventure.text.Component)}
  */
  setName(name: string | null);
  /**
   * Gets the name of this command sender
   *
   * @return Name of the sender
  */
  getName(): string;
}
export interface CommandMinecart extends Minecart, CommandBlockHolder {}
/**
 * Represents a Minecart with a Hopper inside it
*/
export class HopperMinecart extends Minecart {
  /**
   * Checks whether or not this Minecart will pick up
   * items into its inventory.
   *
   * @return true if the Minecart will pick up items
  */
  isEnabled(): boolean;
  /**
   * Sets whether this Minecart will pick up items.
   *
   * @param enabled new enabled state
  */
  setEnabled(enabled: boolean): void;
}
export interface HopperMinecart extends Minecart, InventoryHolder, LootableEntityInventory {}
/**
 * Represents a minecart with a chest. These types of {@link Minecart
 * minecarts} have their own inventory that can be accessed using methods
 * from the {@link InventoryHolder} interface.
*/
export class StorageMinecart extends Minecart {

}
export interface StorageMinecart extends Minecart, InventoryHolder, LootableEntityInventory {}
/**
 * Represents a minecart that can have certain {@link
 * org.bukkit.entity.Entity entities} as passengers. Normal passengers
 * include all {@link org.bukkit.entity.LivingEntity living entities} with
 * the exception of {@link org.bukkit.entity.IronGolem iron golems}.
 * Non-player entities that meet normal passenger criteria automatically
 * mount these minecarts when close enough.
*/
export class RideableMinecart extends Minecart {

}
/**
 * Represents a Minecart with an {@link org.bukkit.block.CreatureSpawner
 * entity spawner} inside it.
*/
export class SpawnerMinecart extends Minecart {

}

}
declare module 'org.bukkit.metadata' {
import { SoftReference, WeakReference } from 'java.lang.ref';
import { List, Map } from 'java.util';
import { RuntimeException } from 'java.lang';
import { Callable } from 'java.util.concurrent';
import { CacheStrategy } from 'org.bukkit.metadata.LazyMetadataValue';
import { Plugin } from 'org.bukkit.plugin';
export class MetadataStore<T> {
  /**
   * Adds a metadata value to an object.
   *
   * @param subject The object receiving the metadata.
   * @param metadataKey A unique key to identify this metadata.
   * @param newMetadataValue The metadata value to apply.
   * @throws IllegalArgumentException If value is null, or the owning plugin
   *     is null
  */
  setMetadata(subject: T, metadataKey: string, newMetadataValue: MetadataValue): void;
  /**
   * Returns all metadata values attached to an object. If multiple plugins
   * have attached metadata, each will value will be included.
   *
   * @param subject the object being interrogated.
   * @param metadataKey the unique metadata key being sought.
   * @return A list of values, one for each plugin that has set the
   *     requested value.
  */
  getMetadata(subject: T, metadataKey: string): MetadataValue[];
  /**
   * Tests to see if a metadata attribute has been set on an object.
   *
   * @param subject the object upon which the has-metadata test is
   *     performed.
   * @param metadataKey the unique metadata key being queried.
   * @return the existence of the metadataKey within subject.
  */
  hasMetadata(subject: T, metadataKey: string): boolean;
  /**
   * Removes a metadata item owned by a plugin from a subject.
   *
   * @param subject the object to remove the metadata from.
   * @param metadataKey the unique metadata key identifying the metadata to
   *     remove.
   * @param owningPlugin the plugin attempting to remove a metadata item.
   * @throws IllegalArgumentException If plugin is null
  */
  removeMetadata(subject: T, metadataKey: string, owningPlugin: Plugin): void;
  /**
   * Invalidates all metadata in the metadata store that originates from the
   * given plugin. Doing this will force each invalidated metadata item to
   * be recalculated the next time it is accessed.
   *
   * @param owningPlugin the plugin requesting the invalidation.
   * @throws IllegalArgumentException If plugin is null
  */
  invalidateAll(owningPlugin: Plugin): void;
}
/**
 * The LazyMetadataValue class implements a type of metadata that is not
 * computed until another plugin asks for it.
 * 
 * By making metadata values lazy, no computation is done by the providing
 * plugin until absolutely necessary (if ever). Additionally,
 * LazyMetadataValue objects cache their values internally unless overridden
 * by a {@link CacheStrategy} or invalidated at the individual or plugin
 * level. Once invalidated, the LazyMetadataValue will recompute its value
 * when asked.
*/
export class LazyMetadataValue extends MetadataValueAdapter {
  /**
   * Initialized a LazyMetadataValue object with the default
   * CACHE_AFTER_FIRST_EVAL cache strategy.
   *
   * @param owningPlugin the {@link Plugin} that created this metadata
   *     value.
   * @param lazyValue the lazy value assigned to this metadata value.
  */
  constructor(owningPlugin: Plugin, lazyValue: Callable<any>);
  /**
   * Initializes a LazyMetadataValue object with a specific cache strategy.
   *
   * @param owningPlugin the {@link Plugin} that created this metadata
   *     value.
   * @param cacheStrategy determines the rules for caching this metadata
   *     value.
   * @param lazyValue the lazy value assigned to this metadata value.
  */
  constructor(owningPlugin: Plugin, cacheStrategy: CacheStrategy, lazyValue: Callable<any>);
  value(): any | null;
  invalidate(): void;
}
export class MetadataStoreBase<T> {
  /**
   * Adds a metadata value to an object. Each metadata value is owned by a
   * specific {@link Plugin}. If a plugin has already added a metadata value
   * to an object, that value will be replaced with the value of `     * newMetadataValue`. Multiple plugins can set independent values for the
   * same `metadataKey` without conflict.
   * 
   * Implementation note: I considered using a {@link
   * java.util.concurrent.locks.ReadWriteLock} for controlling access to
   * `metadataMap`, but decided that the added overhead wasn't worth
   * the finer grained access control.
   * 
   * Bukkit is almost entirely single threaded so locking overhead shouldn't
   * pose a problem.
   *
   * @param subject The object receiving the metadata.
   * @param metadataKey A unique key to identify this metadata.
   * @param newMetadataValue The metadata value to apply.
   * @throws IllegalArgumentException If value is null, or the owning plugin
   *     is null
   * @see MetadataStore#setMetadata(Object, String, MetadataValue)
  */
  setMetadata(subject: T, metadataKey: string, newMetadataValue: MetadataValue): void;
  /**
   * Returns all metadata values attached to an object. If multiple
   * have attached metadata, each will value will be included.
   *
   * @param subject the object being interrogated.
   * @param metadataKey the unique metadata key being sought.
   * @return A list of values, one for each plugin that has set the
   *     requested value.
   * @see MetadataStore#getMetadata(Object, String)
  */
  getMetadata(subject: T, metadataKey: string): MetadataValue[];
  /**
   * Tests to see if a metadata attribute has been set on an object.
   *
   * @param subject the object upon which the has-metadata test is
   *     performed.
   * @param metadataKey the unique metadata key being queried.
   * @return the existence of the metadataKey within subject.
  */
  hasMetadata(subject: T, metadataKey: string): boolean;
  /**
   * Removes a metadata item owned by a plugin from a subject.
   *
   * @param subject the object to remove the metadata from.
   * @param metadataKey the unique metadata key identifying the metadata to
   *     remove.
   * @param owningPlugin the plugin attempting to remove a metadata item.
   * @throws IllegalArgumentException If plugin is null
   * @see MetadataStore#removeMetadata(Object, String,
   *     org.bukkit.plugin.Plugin)
  */
  removeMetadata(subject: T, metadataKey: string, owningPlugin: Plugin): void;
  /**
   * Invalidates all metadata in the metadata store that originates from the
   * given plugin. Doing this will force each invalidated metadata item to
   * be recalculated the next time it is accessed.
   *
   * @param owningPlugin the plugin requesting the invalidation.
   * @throws IllegalArgumentException If plugin is null
   * @see MetadataStore#invalidateAll(org.bukkit.plugin.Plugin)
  */
  invalidateAll(owningPlugin: Plugin): void;
  /**
   * Removes all metadata in the metadata store that originates from the
   * given plugin.
   *
   * @param owningPlugin the plugin requesting the invalidation.
   * @throws IllegalArgumentException If plugin is null
  */
  removeAll(owningPlugin: Plugin): void;
}
export class MetadataValue {
  /**
   * Fetches the value of this metadata item.
   *
   * @return the metadata value.
  */
  value(): any | null;
  /**
   * Attempts to convert the value of this metadata item into an int.
   *
   * @return the value as an int.
  */
  asInt(): number;
  /**
   * Attempts to convert the value of this metadata item into a float.
   *
   * @return the value as a float.
  */
  asFloat(): number;
  /**
   * Attempts to convert the value of this metadata item into a double.
   *
   * @return the value as a double.
  */
  asDouble(): number;
  /**
   * Attempts to convert the value of this metadata item into a long.
   *
   * @return the value as a long.
  */
  asLong(): number;
  /**
   * Attempts to convert the value of this metadata item into a short.
   *
   * @return the value as a short.
  */
  asShort(): number;
  /**
   * Attempts to convert the value of this metadata item into a byte.
   *
   * @return the value as a byte.
  */
  asByte(): number;
  /**
   * Attempts to convert the value of this metadata item into a boolean.
   *
   * @return the value as a boolean.
  */
  asBoolean(): boolean;
  /**
   * Attempts to convert the value of this metadata item into a string.
   *
   * @return the value as a string.
  */
  asString(): string;
  /**
   * Returns the {@link Plugin} that created this metadata item.
   *
   * @return the plugin that owns this metadata value. Could be null if the plugin was already unloaded.
  */
  getOwningPlugin(): Plugin | null;
  /**
   * Invalidates this metadata item, forcing it to recompute when next
   * accessed.
  */
  invalidate(): void;
}
/**
 * This interface is implemented by all objects that can provide metadata
 * about themselves.
*/
export class Metadatable {
  /**
   * Sets a metadata value in the implementing object's metadata store.
   *
   * @param metadataKey A unique key to identify this metadata.
   * @param newMetadataValue The metadata value to apply.
   * @throws IllegalArgumentException If value is null, or the owning plugin
   *     is null
  */
  setMetadata(metadataKey: string, newMetadataValue: MetadataValue): void;
  /**
   * Returns a list of previously set metadata values from the implementing
   * object's metadata store.
   *
   * @param metadataKey the unique metadata key being sought.
   * @return A list of values, one for each plugin that has set the
   *     requested value.
  */
  getMetadata(metadataKey: string): MetadataValue[];
  /**
   * Tests to see whether the implementing object contains the given
   * metadata value in its metadata store.
   *
   * @param metadataKey the unique metadata key being queried.
   * @return the existence of the metadataKey within subject.
  */
  hasMetadata(metadataKey: string): boolean;
  /**
   * Removes the given metadata value from the implementing object's
   * metadata store.
   *
   * @param metadataKey the unique metadata key identifying the metadata to
   *     remove.
   * @param owningPlugin This plugin's metadata value will be removed. All
   *     other values will be left untouched.
   * @throws IllegalArgumentException If plugin is null
  */
  removeMetadata(metadataKey: string, owningPlugin: Plugin): void;
}
/**
 * A MetadataEvaluationException is thrown any time a {@link
 * LazyMetadataValue} fails to evaluate its value due to an exception. The
 * originating exception will be included as this exception's cause.
*/
export class MetadataEvaluationException extends RuntimeException {

}
/**
 * A FixedMetadataValue is a special case metadata item that contains the same
 * value forever after initialization. Invalidating a FixedMetadataValue has
 * no effect.
 * 
 * This class extends LazyMetadataValue for historical reasons, even though it
 * overrides all the implementation methods. it is possible that in the future
 * that the inheritance hierarchy may change.
*/
export class FixedMetadataValue extends LazyMetadataValue {
  /**
   * Initializes a FixedMetadataValue with an Object
   *
   * @param owningPlugin the {@link Plugin} that created this metadata value
   * @param value the value assigned to this metadata value
  */
  constructor(owningPlugin: Plugin, value: any | null);
  invalidate(): void;
  value(): any | null;
}
/**
 * A MetadataConversionException is thrown any time a {@link
 * LazyMetadataValue} attempts to convert a metadata value to an inappropriate
 * data type.
*/
export class MetadataConversionException extends RuntimeException {

}
/**
 * Optional base class for facilitating MetadataValue implementations.
 * 
 * This provides all the conversion functions for MetadataValue so that
 * writing an implementation of MetadataValue is as simple as implementing
 * value() and invalidate().
*/
export class MetadataValueAdapter extends MetadataValue {
  /**
   * Returns the {@link Plugin} that created this metadata item.
   *
   * @return the plugin that owns this metadata value. Could be null if the plugin was already unloaded.
  */
  getOwningPlugin(): Plugin | null;
  /**
   * Attempts to convert the value of this metadata item into an int.
   *
   * @return the value as an int.
  */
  asInt(): number;
  /**
   * Attempts to convert the value of this metadata item into a float.
   *
   * @return the value as a float.
  */
  asFloat(): number;
  /**
   * Attempts to convert the value of this metadata item into a double.
   *
   * @return the value as a double.
  */
  asDouble(): number;
  /**
   * Attempts to convert the value of this metadata item into a long.
   *
   * @return the value as a long.
  */
  asLong(): number;
  /**
   * Attempts to convert the value of this metadata item into a short.
   *
   * @return the value as a short.
  */
  asShort(): number;
  /**
   * Attempts to convert the value of this metadata item into a byte.
   *
   * @return the value as a byte.
  */
  asByte(): number;
  /**
   * Attempts to convert the value of this metadata item into a boolean.
   *
   * @return the value as a boolean.
  */
  asBoolean(): boolean;
  /**
   * Attempts to convert the value of this metadata item into a string.
   *
   * @return the value as a string.
  */
  asString(): string;
}

}
declare module 'org.bukkit.entity.memory' {
import { Class } from 'java.lang';
import { Set, UUID, Map } from 'java.util';
import { NamespacedKey, Keyed, Location } from 'org.bukkit';
/**
 * Represents a key used for accessing memory values of a
 * {@link org.bukkit.entity.LivingEntity}.
 *
 * @param  the class type of the memory value
*/
export class MemoryKey<T> extends Keyed {
  /**
   * Return the namespaced identifier for this object.
   *
   * @return this object's key
  */
  getKey(): NamespacedKey;
  /**
   * Gets the class of values associated with this memory.
   *
   * @return the class of value objects
  */
  getMemoryClass(): Class<T>;
  static readonly HOME: MemoryKey<Location>;
  static readonly POTENTIAL_JOB_SITE: MemoryKey<Location>;
  static readonly JOB_SITE: MemoryKey<Location>;
  static readonly MEETING_POINT: MemoryKey<Location>;
  static readonly GOLEM_DETECTED_RECENTLY: MemoryKey<boolean>;
  static readonly LAST_SLEPT: MemoryKey<number>;
  static readonly LAST_WOKEN: MemoryKey<number>;
  static readonly LAST_WORKED_AT_POI: MemoryKey<number>;
  static readonly UNIVERSAL_ANGER: MemoryKey<boolean>;
  static readonly ANGRY_AT: MemoryKey<UUID>;
  static readonly ADMIRING_ITEM: MemoryKey<boolean>;
  static readonly ADMIRING_DISABLED: MemoryKey<boolean>;
  static readonly HUNTED_RECENTLY: MemoryKey<boolean>;
  static readonly PLAY_DEAD_TICKS: MemoryKey<number>;
  static readonly TEMPTATION_COOLDOWN_TICKS: MemoryKey<number>;
  static readonly IS_TEMPTED: MemoryKey<boolean>;
  static readonly LONG_JUMP_COOLING_DOWN: MemoryKey<number>;
  static readonly HAS_HUNTING_COOLDOWN: MemoryKey<boolean>;
  static readonly RAM_COOLDOWN_TICKS: MemoryKey<number>;
  /**
   * Returns a {@link MemoryKey} by a {@link NamespacedKey}.
   *
   * @param namespacedKey the {@link NamespacedKey} referencing a
   * {@link MemoryKey}
   * @return the {@link MemoryKey} or null when no {@link MemoryKey} is
   * available under that key
  */
  static getByKey(namespacedKey: NamespacedKey): MemoryKey | null;
  /**
   * Returns the set of all MemoryKeys.
   *
   * @return the memoryKeys
  */
  static values(): Set<MemoryKey>;
}

}
declare module 'org.bukkit.event.entity.EntityPotionEffectEvent' {
import { Enum } from 'java.lang';
/**
 * An enum to specify the action to be performed.
*/
export class Action extends Enum<Action> {
  /**
   * When the potion effect is added because the entity didn't have it's
   * type.
  */
  static readonly ADDED: Action;
  /**
   * When the entity already had the potion effect type, but the effect is
   * changed.
  */
  static readonly CHANGED: Action;
  /**
   * When the effect is removed due to all effects being removed.
  */
  static readonly CLEARED: Action;
  /**
   * When the potion effect type is completely removed.
  */
  static readonly REMOVED: Action;
  static valueOf(name: string): Action;
  static values(): Action[];
}
/**
 * An enum to specify the cause why an effect was changed.
*/
export class Cause extends Enum<Cause> {
  /**
   * When the entity stands inside an area effect cloud.
  */
  static readonly AREA_EFFECT_CLOUD: Cause;
  /**
   * When the entity is hit by an spectral or tipped arrow.
  */
  static readonly ARROW: Cause;
  /**
   * When the entity is inflicted with a potion effect due to an entity
   * attack (e.g. a cave spider or a shulker bullet).
  */
  static readonly ATTACK: Cause;
  /**
   * When an entity gets the effect from an axolotl.
  */
  static readonly AXOLOTL: Cause;
  /**
   * When beacon effects get applied due to the entity being nearby.
  */
  static readonly BEACON: Cause;
  /**
   * When a potion effect is changed due to the /effect command.
  */
  static readonly COMMAND: Cause;
  /**
   * When the entity gets the effect from a conduit.
  */
  static readonly CONDUIT: Cause;
  /**
   * When a conversion from a villager zombie to a villager is started or
   * finished.
  */
  static readonly CONVERSION: Cause;
  /**
   * When all effects are removed due to death (Note: This is called on
   * respawn, so it's player only!)
  */
  static readonly DEATH: Cause;
  /**
   * When the entity gets the effect from a dolphin.
  */
  static readonly DOLPHIN: Cause;
  /**
   * When the effect was removed due to expiration.
  */
  static readonly EXPIRATION: Cause;
  /**
   * When an effect is inflicted due to food (e.g. when a player eats or a
   * cookie is given to a parrot).
  */
  static readonly FOOD: Cause;
  /**
   * When an illusion illager makes himself disappear.
  */
  static readonly ILLUSION: Cause;
  /**
   * When all effects are removed due to a bucket of milk.
  */
  static readonly MILK: Cause;
  /**
   * When a player gets bad omen after killing a patrol captain.
  */
  static readonly PATROL_CAPTAIN: Cause;
  /**
   * When a potion effect is modified through the plugin methods.
  */
  static readonly PLUGIN: Cause;
  /**
   * When the entity drinks a potion.
  */
  static readonly POTION_DRINK: Cause;
  /**
   * When the entity is inflicted with an effect due to a splash potion.
  */
  static readonly POTION_SPLASH: Cause;
  /**
   * When a spider gets effects when spawning on hard difficulty.
  */
  static readonly SPIDER_SPAWN: Cause;
  /**
   * When the entity gets effects from a totem item saving it's life.
  */
  static readonly TOTEM: Cause;
  /**
   * When the entity gets water breathing by wearing a turtle helmet.
  */
  static readonly TURTLE_HELMET: Cause;
  /**
   * When the Cause is missing.
  */
  static readonly UNKNOWN: Cause;
  /**
   * When a villager gets regeneration after a trade.
  */
  static readonly VILLAGER_TRADE: Cause;
  /**
   * When an entity comes in contact with a wither rose.
  */
  static readonly WITHER_ROSE: Cause;
  static valueOf(name: string): Cause;
  static values(): Cause[];
}

}
declare module 'org.bukkit.inventory.meta.tags' {
import { Class } from 'java.lang';
import { NamespacedKey } from 'org.bukkit';
/**
 * This interface represents a map like object, capable of storing custom tags
 * in it.
 *
 * @deprecated this API part has been replaced by the
 * {@link org.bukkit.persistence.PersistentDataHolder} API. Please use
 * {@link org.bukkit.persistence.PersistentDataHolder} instead of this.
*/
export class CustomItemTagContainer {
  /**
   * Stores a custom value on the {@link ItemMeta}.
   *
   * This API cannot be used to manipulate minecraft tags, as the values will
   * be stored using your namespace. This method will override any existing
   * value the meta may have stored under the provided key.
   *
   * @param key the key this value will be stored under
   * @param type the type this item tag uses
   * @param value the value stored in the tag
   * @param  the generic java type of the tag value
   * @param  the generic type of the object to store
   * @throws NullPointerException if the key is null
   * @throws NullPointerException if the type is null
   * @throws NullPointerException if the value is null. Removing a custom tag
   * should be done using {@link #removeCustomTag(org.bukkit.NamespacedKey)}
   * @throws IllegalArgumentException if no suitable adapter will be found for
   * the {@link ItemTagType#getPrimitiveType()}
  */
  setCustomTag<T, Z>(key: NamespacedKey, type: ItemTagType<T, Z>, value: Z): void;
  /**
   * Returns if the item meta has a custom tag registered matching the
   * provided parameters.
   *
   * This method will only return if the found value has the same primitive
   * data type as the provided key.
   *
   * Storing a value using a custom {@link ItemTagType} implementation will
   * not store the complex data type. Therefore storing a UUID (by storing a
   * byte[]) will match hasCustomTag("key" , {@link ItemTagType#BYTE_ARRAY}).
   * Likewise a stored byte[] will always match your UUID {@link ItemTagType}
   * even if it is not 16 bytes long.
   *
   * This method is only usable for custom object keys. Overwriting existing
   * tags, like the the display name, will not work as the values are stored
   * using your namespace.
   *
   * @param key the key the value is stored under
   * @param type the type which primitive storage type has to match the value
   * @param  the generic type of the stored primitive
   * @param  the generic type of the eventually created complex object
   * @return if a value
   * @throws NullPointerException if the key to look up is null
   * @throws NullPointerException if the type to cast the found object to is
   * null
  */
  hasCustomTag<T, Z>(key: NamespacedKey, type: ItemTagType<T, Z>): boolean;
  /**
   * Returns the custom tag's value that is stored on the item.
   *
   * @param key the key to look up in the custom tag map
   * @param type the type the value must have and will be casted to
   * @param  the generic type of the stored primitive
   * @param  the generic type of the eventually created complex object
   * @return the value or `null` if no value was mapped under the given
   * value
   * @throws NullPointerException if the key to look up is null
   * @throws NullPointerException if the type to cast the found object to is
   * null
   * @throws IllegalArgumentException if the value exists under the given key,
   * but cannot be access using the given type
   * @throws IllegalArgumentException if no suitable adapter will be found for
   * the {@link ItemTagType#getPrimitiveType()}
  */
  getCustomTag<T, Z>(key: NamespacedKey, type: ItemTagType<T, Z>): Z | null;
  /**
   * Removes a custom key from the item meta.
   *
   * @param key the key
   * @throws NullPointerException if the provided key is null
  */
  removeCustomTag(key: NamespacedKey): void;
  /**
   * Returns if the container instance is empty, therefore has no entries
   * inside it.
   *
   * @return the boolean
  */
  isEmpty(): boolean;
  /**
   * Returns the adapter context this tag container uses.
   *
   * @return the tag context
  */
  getAdapterContext(): ItemTagAdapterContext;
}
/**
 * This class represents an enum with a generic content type. It defines the
 * types a custom item tag can have.
 * 
 * This interface can be used to create your own custom {@link ItemTagType} with
 * different complex types. This may be useful for the likes of a
 * UUIDItemTagType:
 *  * {@code
 * public class UUIDItemTagType implements ItemTagType {
 *
 *         {@literal @Override}
 *         public Class getPrimitiveType() {
 *             return byte[].class;
 *         }
 *
 *         {@literal @Override}
 *         public Class getComplexType() {
 *             return UUID.class;
 *         }
 *
 *         {@literal @Override}
 *         public byte[] toPrimitive(UUID complex, ItemTagAdapterContext context) {
 *             ByteBuffer bb = ByteBuffer.wrap(new byte[16]);
 *             bb.putLong(complex.getMostSignificantBits());
 *             bb.putLong(complex.getLeastSignificantBits());
 *             return bb.array();
 *         }
 *
 *         {@literal @Override}
 *         public UUID fromPrimitive(byte[] primitive, ItemTagAdapterContext context) {
 *             ByteBuffer bb = ByteBuffer.wrap(primitive);
 *             long firstLong = bb.getLong();
 *             long secondLong = bb.getLong();
 *             return new UUID(firstLong, secondLong);
 *         }
 *     }}
 *
 * @param  the primary object type that is stored in the given tag
 * @param  the retrieved object type when applying this item tag type
 *
 * @deprecated please use {@link PersistentDataType} as this part of the api is being replaced
*/
export class ItemTagType<T, Z> {
  static readonly BYTE: ItemTagType<number, number>;
  static readonly SHORT: ItemTagType<number, number>;
  static readonly INTEGER: ItemTagType<number, number>;
  static readonly LONG: ItemTagType<number, number>;
  static readonly FLOAT: ItemTagType<number, number>;
  static readonly DOUBLE: ItemTagType<number, number>;
  static readonly STRING: ItemTagType<string, string>;
  static readonly BYTE_ARRAY: ItemTagType<number[], number[]>;
  static readonly INTEGER_ARRAY: ItemTagType<number[], number[]>;
  static readonly LONG_ARRAY: ItemTagType<number[], number[]>;
  static readonly TAG_CONTAINER: ItemTagType<CustomItemTagContainer, CustomItemTagContainer>;
  /**
   * Returns the primitive data type of this tag.
   *
   * @return the class
  */
  getPrimitiveType(): Class<T>;
  /**
   * Returns the complex object type the primitive value resembles.
   *
   * @return the class type
  */
  getComplexType(): Class<Z>;
  /**
   * Returns the primitive data that resembles the complex object passed to
   * this method.
   *
   * @param complex the complex object instance
   * @param context the context this operation is running in
   * @return the primitive value
  */
  toPrimitive(complex: Z, context: ItemTagAdapterContext): T;
  /**
   * Creates a complex object based of the passed primitive value
   *
   * @param primitive the primitive value
   * @param context the context this operation is running in
   * @return the complex object instance
  */
  fromPrimitive(primitive: T, context: ItemTagAdapterContext): Z;
}
/**
 * This interface represents the context in which the {@link ItemTagType} can
 * serialize and deserialize the passed values.
 *
 * @deprecated this API part has been replaced by {@link PersistentDataHolder}.
 * Please use {@link PersistentDataAdapterContext} instead of this.
*/
export class ItemTagAdapterContext {
  /**
   * Creates a new and empty tag container instance.
   *
   * @return the fresh container instance
  */
  newTagContainer(): CustomItemTagContainer;
}

}
declare module 'org.bukkit.entity.ExperienceOrb' {
import { Enum } from 'java.lang';
/**
 * Reasons for why this Experience Orb was spawned
*/
export class SpawnReason extends Enum<SpawnReason> {
  /**
   * Spawned by a player dying
  */
  static readonly PLAYER_DEATH: SpawnReason;
  /**
   * Spawned by an entity dying after being damaged by a player
  */
  static readonly ENTITY_DEATH: SpawnReason;
  /**
   * Spawned by player using a furnace
  */
  static readonly FURNACE: SpawnReason;
  /**
   * Spawned by player breeding animals
  */
  static readonly BREED: SpawnReason;
  /**
   * Spawned by player trading with a villager
  */
  static readonly VILLAGER_TRADE: SpawnReason;
  /**
   * Spawned by player fishing
  */
  static readonly FISHING: SpawnReason;
  /**
   * Spawned by player breaking a block that gives experience points such as Diamond Ore
  */
  static readonly BLOCK_BREAK: SpawnReason;
  /**
   * Spawned by Bukkit API
  */
  static readonly CUSTOM: SpawnReason;
  /**
   * Spawned by a player throwing an experience points bottle
  */
  static readonly EXP_BOTTLE: SpawnReason;
  /**
   * Spawned by a player using a grindstone
  */
  static readonly GRINDSTONE: SpawnReason;
  /**
   * We do not know why it was spawned
  */
  static readonly UNKNOWN: SpawnReason;
  static valueOf(name: string): SpawnReason;
  static values(): SpawnReason[];
}

}
declare module 'org.bukkit.Note' {
import { Map } from 'java.util';
import { Enum } from 'java.lang';
/**
 * An enum holding tones.
*/
export class Tone extends Enum<Tone> {
  static readonly G: Tone;
  static readonly A: Tone;
  static readonly B: Tone;
  static readonly C: Tone;
  static readonly D: Tone;
  static readonly E: Tone;
  static readonly F: Tone;
  static valueOf(name: string): Tone;
  static values(): Tone[];
  /**
   The number of tones including sharped tones. 
  */
  static readonly TONES_COUNT: number;
  /**
   * Returns the not sharped id of this tone.
   *
   * @return the not sharped id of this tone.
   * @deprecated Magic value
  */
  getId(): number;
  /**
   * Returns the id of this tone. These method allows to return the
   * sharped id of the tone. If the tone couldn't be sharped it always
   * return the not sharped id of this tone.
   *
   * @param sharped Set to true to return the sharped id.
   * @return the id of this tone.
   * @deprecated Magic value
  */
  getId(sharped: boolean): number;
  /**
   * Returns if this tone could be sharped.
   *
   * @return if this tone could be sharped.
  */
  isSharpable(): boolean;
  /**
   * Returns if this tone id is the sharped id of the tone.
   *
   * @param id the id of the tone.
   * @return if the tone id is the sharped id of the tone.
   * @throws IllegalArgumentException if neither the tone nor the
   *     semitone have the id.
   * @deprecated Magic value
  */
  isSharped(id: number): boolean;
  /**
   * Returns the tone to id. Also returning the semitones.
   *
   * @param id the id of the tone.
   * @return the tone to id.
   * @deprecated Magic value
  */
  static getById(id: number): Tone | null;
}

}
declare module 'org.bukkit.event.player.PlayerTeleportEvent' {
import { Enum } from 'java.lang';
export class TeleportCause extends Enum<TeleportCause> {
  /**
   * Indicates the teleporation was caused by a player throwing an Ender
   * Pearl
  */
  static readonly ENDER_PEARL: TeleportCause;
  /**
   * Indicates the teleportation was caused by a player executing a
   * command
  */
  static readonly COMMAND: TeleportCause;
  /**
   * Indicates the teleportation was caused by a plugin
  */
  static readonly PLUGIN: TeleportCause;
  /**
   * Indicates the teleportation was caused by a player entering a
   * Nether portal
  */
  static readonly NETHER_PORTAL: TeleportCause;
  /**
   * Indicates the teleportation was caused by a player entering an End
   * portal
  */
  static readonly END_PORTAL: TeleportCause;
  /**
   * Indicates the teleportation was caused by a player teleporting to a
   * Entity/Player via the spectator menu
  */
  static readonly SPECTATE: TeleportCause;
  /**
   * Indicates the teleportation was caused by a player entering an End
   * gateway
  */
  static readonly END_GATEWAY: TeleportCause;
  /**
   * Indicates the teleportation was caused by a player consuming chorus
   * fruit
  */
  static readonly CHORUS_FRUIT: TeleportCause;
  /**
   * Indicates the teleportation was caused by an event not covered by
   * this enum
  */
  static readonly UNKNOWN: TeleportCause;
  static valueOf(name: string): TeleportCause;
  static values(): TeleportCause[];
}

}
declare module 'org.bukkit.util' {
import { Iterable, Cloneable } from 'java.lang';
import { Random, Iterator, Collection, Map } from 'java.util';
import { BlockFace, Block } from 'org.bukkit.block';
import { File } from 'java.io';
import { ConfigurationSerializable } from 'org.bukkit.configuration.serialization';
import { ChatPage } from 'org.bukkit.util.ChatPaginator';
import { LivingEntity, Entity } from 'org.bukkit.entity';
import { World, Location } from 'org.bukkit';
/**
 * EulerAngle is used to represent 3 angles, one for each
 * axis (x, y, z). The angles are in radians
*/
export class EulerAngle {
  /**
   * A EulerAngle with every axis set to 0
  */
  static readonly ZERO: EulerAngle;
  /**
   * Creates a EularAngle with each axis set to the
   * passed angle in radians
   *
   * @param x the angle for the x axis in radians
   * @param y the angle for the y axis in radians
   * @param z the angle for the z axis in radians
  */
  constructor(x: number, y: number, z: number);
  /**
   * Returns the angle on the x axis in radians
   *
   * @return the angle in radians
  */
  getX(): number;
  /**
   * Returns the angle on the y axis in radians
   *
   * @return the angle in radians
  */
  getY(): number;
  /**
   * Returns the angle on the z axis in radians
   *
   * @return the angle in radians
  */
  getZ(): number;
  /**
   * Return a EulerAngle which is the result of changing
   * the x axis to the passed angle
   *
   * @param x the angle in radians
   * @return the resultant EulerAngle
  */
  setX(x: number);
  /**
   * Return a EulerAngle which is the result of changing
   * the y axis to the passed angle
   *
   * @param y the angle in radians
   * @return the resultant EulerAngle
  */
  setY(y: number);
  /**
   * Return a EulerAngle which is the result of changing
   * the z axis to the passed angle
   *
   * @param z the angle in radians
   * @return the resultant EulerAngle
  */
  setZ(z: number);
  /**
   * Creates a new EulerAngle which is the result of adding
   * the x, y, z components to this EulerAngle
   *
   * @param x the angle to add to the x axis in radians
   * @param y the angle to add to the y axis in radians
   * @param z the angle to add to the z axis in radians
   * @return the resultant EulerAngle
  */
  add(x: number, y: number, z: number): EulerAngle;
  /**
   * Creates a new EulerAngle which is the result of subtracting
   * the x, y, z components to this EulerAngle
   *
   * @param x the angle to subtract to the x axis in radians
   * @param y the angle to subtract to the y axis in radians
   * @param z the angle to subtract to the z axis in radians
   * @return the resultant EulerAngle
  */
  subtract(x: number, y: number, z: number): EulerAngle;
  equals(o: any): boolean;
  hashCode(): number;
}
/**
 * This is a cached version of a server-icon. It's internal representation
 * and implementation is undefined.
 *
 * @see Server#getServerIcon()
 * @see Server#loadServerIcon(java.awt.image.BufferedImage)
 * @see Server#loadServerIcon(java.io.File)
 * @see ServerListPingEvent#setServerIcon(CachedServerIcon)
*/
export class CachedServerIcon {
  getData(): string | null;
  isEmpty(): boolean;
}
/**
 * The ChatPaginator takes a raw string of arbitrary length and breaks it down
 * into an array of strings appropriate for displaying on the Minecraft player
 * console.
*/
export class ChatPaginator {
  static readonly GUARANTEED_NO_WRAP_CHAT_PAGE_WIDTH: number;
  static readonly AVERAGE_CHAT_PAGE_WIDTH: number;
  static readonly UNBOUNDED_PAGE_WIDTH: number;
  static readonly OPEN_CHAT_PAGE_HEIGHT: number;
  static readonly CLOSED_CHAT_PAGE_HEIGHT: number;
  static readonly UNBOUNDED_PAGE_HEIGHT: number;
  /**
   * Breaks a raw string up into pages using the default width and height.
   *
   * @param unpaginatedString The raw string to break.
   * @param pageNumber The page number to fetch.
   * @return A single chat page.
  */
  static paginate(unpaginatedString: string | null, pageNumber: number): ChatPage;
  /**
   * Breaks a raw string up into pages using a provided width and height.
   *
   * @param unpaginatedString The raw string to break.
   * @param pageNumber The page number to fetch.
   * @param lineLength The desired width of a chat line.
   * @param pageHeight The desired number of lines in a page.
   * @return A single chat page.
  */
  static paginate(unpaginatedString: string | null, pageNumber: number, lineLength: number, pageHeight: number): ChatPage;
  /**
   * Breaks a raw string up into a series of lines. Words are wrapped using
   * spaces as decimeters and the newline character is respected.
   *
   * @param rawString The raw string to break.
   * @param lineLength The length of a line of text.
   * @return An array of word-wrapped lines.
  */
  static wordWrap(rawString: string | null, lineLength: number): string[];
}
/**
 * Represents an operation that accepts a single input argument and returns no
 * result.
 *
 * @param  the type of the input to the operation
*/
export class Consumer<T> {
  /**
   * Performs this operation on the given argument.
   *
   * @param t the input argument
  */
  accept(t: T): void;
}
/**
 * A vector with a hash function that floors the X, Y, Z components, a la
 * BlockVector in WorldEdit. BlockVectors can be used in hash sets and
 * hash maps. Be aware that BlockVectors are mutable, but it is important
 * that BlockVectors are never changed once put into a hash set or hash map.
*/
export class BlockVector extends Vector {
  /**
   * Construct the vector with all components as 0.
  */
  constructor();
  /**
   * Construct the vector with another vector.
   *
   * @param vec The other vector.
  */
  constructor(vec: Vector);
  /**
   * Construct the vector with provided integer components.
   *
   * @param x X component
   * @param y Y component
   * @param z Z component
  */
  constructor(x: number, y: number, z: number);
  /**
   * Checks if another object is equivalent.
   *
   * @param obj The other object
   * @return whether the other object is equivalent
  */
  equals(obj: any): boolean;
  /**
   * Returns a hash code for this vector.
   *
   * @return hash code
  */
  hashCode(): number;
  /**
   * Get a new block vector.
   *
   * @return vector
  */
  clone(): BlockVector;
  static deserialize(args: Map<string, any>): BlockVector;
}
/**
 * The hit result of a ray trace.
 * 
 * Only the hit position is guaranteed to always be available. The availability
 * of the other attributes depends on what got hit and on the context in which
 * the ray trace was performed.
*/
export class RayTraceResult {
  /**
   * Creates a RayTraceResult.
   *
   * @param hitPosition the hit position
  */
  constructor(hitPosition: Vector);
  /**
   * Creates a RayTraceResult.
   *
   * @param hitPosition the hit position
   * @param hitBlockFace the hit block face
  */
  constructor(hitPosition: Vector, hitBlockFace: BlockFace | null);
  /**
   * Creates a RayTraceResult.
   *
   * @param hitPosition the hit position
   * @param hitBlock the hit block
   * @param hitBlockFace the hit block face
  */
  constructor(hitPosition: Vector, hitBlock: Block | null, hitBlockFace: BlockFace | null);
  /**
   * Creates a RayTraceResult.
   *
   * @param hitPosition the hit position
   * @param hitEntity the hit entity
  */
  constructor(hitPosition: Vector, hitEntity: Entity | null);
  /**
   * Creates a RayTraceResult.
   *
   * @param hitPosition the hit position
   * @param hitEntity the hit entity
   * @param hitBlockFace the hit block face
  */
  constructor(hitPosition: Vector, hitEntity: Entity | null, hitBlockFace: BlockFace | null);
  /**
   * Gets the exact position of the hit.
   *
   * @return a copy of the exact hit position
  */
  getHitPosition(): Vector;
  /**
   * Gets the hit block.
   *
   * @return the hit block, or null if not available
  */
  getHitBlock(): Block | null;
  /**
   * Gets the hit block face.
   *
   * @return the hit block face, or null if not available
  */
  getHitBlockFace(): BlockFace | null;
  /**
   * Gets the hit entity.
   *
   * @return the hit entity, or null if not available
  */
  getHitEntity(): Entity | null;
  hashCode(): number;
  equals(obj: any): boolean;
  toString(): string;
}
/**
 * Utils for casting number types to other number types
*/
export class NumberConversions {
  static floor(num: number): number;
  static ceil(num: number): number;
  static round(num: number): number;
  static square(num: number): number;
  static toInt(object: any | null): number;
  static toFloat(object: any | null): number;
  static toDouble(object: any | null): number;
  static toLong(object: any | null): number;
  static toShort(object: any | null): number;
  static toByte(object: any | null): number;
  static isFinite(d: number): boolean;
  static checkFinite(d: number, message: string): void;
}
/**
 * A mutable axis aligned bounding box (AABB).
 * 
 * This basically represents a rectangular box (specified by minimum and maximum
 * corners) that can for example be used to describe the position and extents of
 * an object (such as an entity, block, or rectangular region) in 3D space. Its
 * edges and faces are parallel to the axes of the cartesian coordinate system.
 * 
 * The bounding box may be degenerate (one or more sides having the length 0).
 * 
 * Because bounding boxes are mutable, storing them long term may be dangerous
 * if they get modified later. If you want to keep around a bounding box, it may
 * be wise to call {@link #clone()} in order to get a copy.
*/
export class BoundingBox extends Cloneable {
  /**
   * Creates a new bounding box using the coordinates of the given vectors as
   * corners.
   *
   * @param corner1 the first corner
   * @param corner2 the second corner
   * @return the bounding box
  */
  static of(corner1: Vector, corner2: Vector): BoundingBox;
  /**
   * Creates a new bounding box using the coordinates of the given locations
   * as corners.
   *
   * @param corner1 the first corner
   * @param corner2 the second corner
   * @return the bounding box
  */
  static of(corner1: Location, corner2: Location): BoundingBox;
  /**
   * Creates a new bounding box using the coordinates of the given blocks as
   * corners.
   * 
   * The bounding box will be sized to fully contain both blocks.
   *
   * @param corner1 the first corner block
   * @param corner2 the second corner block
   * @return the bounding box
  */
  static of(corner1: Block, corner2: Block): BoundingBox;
  /**
   * Creates a new 1x1x1 sized bounding box containing the given block.
   *
   * @param block the block
   * @return the bounding box
  */
  static of(block: Block): BoundingBox;
  /**
   * Creates a new bounding box using the given center and extents.
   *
   * @param center the center
   * @param x 1/2 the size of the bounding box along the x axis
   * @param y 1/2 the size of the bounding box along the y axis
   * @param z 1/2 the size of the bounding box along the z axis
   * @return the bounding box
  */
  static of(center: Vector, x: number, y: number, z: number): BoundingBox;
  /**
   * Creates a new bounding box using the given center and extents.
   *
   * @param center the center
   * @param x 1/2 the size of the bounding box along the x axis
   * @param y 1/2 the size of the bounding box along the y axis
   * @param z 1/2 the size of the bounding box along the z axis
   * @return the bounding box
  */
  static of(center: Location, x: number, y: number, z: number): BoundingBox;
  /**
   * Creates a new (degenerate) bounding box with all corner coordinates at
   * 0.
  */
  constructor();
  /**
   * Creates a new bounding box from the given corner coordinates.
   *
   * @param x1 the first corner's x value
   * @param y1 the first corner's y value
   * @param z1 the first corner's z value
   * @param x2 the second corner's x value
   * @param y2 the second corner's y value
   * @param z2 the second corner's z value
  */
  constructor(x1: number, y1: number, z1: number, x2: number, y2: number, z2: number);
  /**
   * Resizes this bounding box.
   *
   * @param x1 the first corner's x value
   * @param y1 the first corner's y value
   * @param z1 the first corner's z value
   * @param x2 the second corner's x value
   * @param y2 the second corner's y value
   * @param z2 the second corner's z value
   * @return this bounding box (resized)
  */
  resize(x1: number, y1: number, z1: number, x2: number, y2: number, z2: number): BoundingBox;
  /**
   * Gets the minimum x value.
   *
   * @return the minimum x value
  */
  getMinX(): number;
  /**
   * Gets the minimum y value.
   *
   * @return the minimum y value
  */
  getMinY(): number;
  /**
   * Gets the minimum z value.
   *
   * @return the minimum z value
  */
  getMinZ(): number;
  /**
   * Gets the minimum corner as vector.
   *
   * @return the minimum corner as vector
  */
  getMin(): Vector;
  /**
   * Gets the maximum x value.
   *
   * @return the maximum x value
  */
  getMaxX(): number;
  /**
   * Gets the maximum y value.
   *
   * @return the maximum y value
  */
  getMaxY(): number;
  /**
   * Gets the maximum z value.
   *
   * @return the maximum z value
  */
  getMaxZ(): number;
  /**
   * Gets the maximum corner as vector.
   *
   * @return the maximum corner vector
  */
  getMax(): Vector;
  /**
   * Gets the width of the bounding box in the x direction.
   *
   * @return the width in the x direction
  */
  getWidthX(): number;
  /**
   * Gets the width of the bounding box in the z direction.
   *
   * @return the width in the z direction
  */
  getWidthZ(): number;
  /**
   * Gets the height of the bounding box.
   *
   * @return the height
  */
  getHeight(): number;
  /**
   * Gets the volume of the bounding box.
   *
   * @return the volume
  */
  getVolume(): number;
  /**
   * Gets the x coordinate of the center of the bounding box.
   *
   * @return the center's x coordinate
  */
  getCenterX(): number;
  /**
   * Gets the y coordinate of the center of the bounding box.
   *
   * @return the center's y coordinate
  */
  getCenterY(): number;
  /**
   * Gets the z coordinate of the center of the bounding box.
   *
   * @return the center's z coordinate
  */
  getCenterZ(): number;
  /**
   * Gets the center of the bounding box.
   *
   * @return the center
  */
  getCenter(): Vector;
  /**
   * Copies another bounding box.
   *
   * @param other the other bounding box
   * @return this bounding box
  */
  copy(other: BoundingBox): BoundingBox;
  /**
   * Expands this bounding box by the given values in the corresponding
   * directions.
   * 
   * Negative values will shrink the bounding box in the corresponding
   * direction. Shrinking will be limited to the point where the affected
   * opposite faces would meet if the they shrank at uniform speeds.
   *
   * @param negativeX the amount of expansion in the negative x direction
   * @param negativeY the amount of expansion in the negative y direction
   * @param negativeZ the amount of expansion in the negative z direction
   * @param positiveX the amount of expansion in the positive x direction
   * @param positiveY the amount of expansion in the positive y direction
   * @param positiveZ the amount of expansion in the positive z direction
   * @return this bounding box (now expanded)
  */
  expand(negativeX: number, negativeY: number, negativeZ: number, positiveX: number, positiveY: number, positiveZ: number): BoundingBox;
  /**
   * Expands this bounding box uniformly by the given values in both positive
   * and negative directions.
   * 
   * Negative values will shrink the bounding box. Shrinking will be limited
   * to the bounding box's current size.
   *
   * @param x the amount of expansion in both positive and negative x
   * direction
   * @param y the amount of expansion in both positive and negative y
   * direction
   * @param z the amount of expansion in both positive and negative z
   * direction
   * @return this bounding box (now expanded)
  */
  expand(x: number, y: number, z: number): BoundingBox;
  /**
   * Expands this bounding box uniformly by the given values in both positive
   * and negative directions.
   * 
   * Negative values will shrink the bounding box. Shrinking will be limited
   * to the bounding box's current size.
   *
   * @param expansion the expansion values
   * @return this bounding box (now expanded)
  */
  expand(expansion: Vector): BoundingBox;
  /**
   * Expands this bounding box uniformly by the given value in all directions.
   * 
   * A negative value will shrink the bounding box. Shrinking will be limited
   * to the bounding box's current size.
   *
   * @param expansion the amount of expansion
   * @return this bounding box (now expanded)
  */
  expand(expansion: number): BoundingBox;
  /**
   * Expands this bounding box in the specified direction.
   * 
   * The magnitude of the direction will scale the expansion. A negative
   * expansion value will shrink the bounding box in this direction. Shrinking
   * will be limited to the bounding box's current size.
   *
   * @param dirX the x direction component
   * @param dirY the y direction component
   * @param dirZ the z direction component
   * @param expansion the amount of expansion
   * @return this bounding box (now expanded)
  */
  expand(dirX: number, dirY: number, dirZ: number, expansion: number): BoundingBox;
  /**
   * Expands this bounding box in the specified direction.
   * 
   * The magnitude of the direction will scale the expansion. A negative
   * expansion value will shrink the bounding box in this direction. Shrinking
   * will be limited to the bounding box's current size.
   *
   * @param direction the direction
   * @param expansion the amount of expansion
   * @return this bounding box (now expanded)
  */
  expand(direction: Vector, expansion: number): BoundingBox;
  /**
   * Expands this bounding box in the direction specified by the given block
   * face.
   * 
   * A negative expansion value will shrink the bounding box in this
   * direction. Shrinking will be limited to the bounding box's current size.
   *
   * @param blockFace the block face
   * @param expansion the amount of expansion
   * @return this bounding box (now expanded)
  */
  expand(blockFace: BlockFace, expansion: number): BoundingBox;
  /**
   * Expands this bounding box in the specified direction.
   * 
   * Negative values will expand the bounding box in the negative direction,
   * positive values will expand it in the positive direction. The magnitudes
   * of the direction components determine the corresponding amounts of
   * expansion.
   *
   * @param dirX the x direction component
   * @param dirY the y direction component
   * @param dirZ the z direction component
   * @return this bounding box (now expanded)
  */
  expandDirectional(dirX: number, dirY: number, dirZ: number): BoundingBox;
  /**
   * Expands this bounding box in the specified direction.
   * 
   * Negative values will expand the bounding box in the negative direction,
   * positive values will expand it in the positive direction. The magnitude
   * of the direction vector determines the amount of expansion.
   *
   * @param direction the direction and magnitude of the expansion
   * @return this bounding box (now expanded)
  */
  expandDirectional(direction: Vector): BoundingBox;
  /**
   * Expands this bounding box to contain (or border) the specified position.
   *
   * @param posX the x position value
   * @param posY the y position value
   * @param posZ the z position value
   * @return this bounding box (now expanded)
   * @see #contains(double, double, double)
  */
  union(posX: number, posY: number, posZ: number): BoundingBox;
  /**
   * Expands this bounding box to contain (or border) the specified position.
   *
   * @param position the position
   * @return this bounding box (now expanded)
   * @see #contains(double, double, double)
  */
  union(position: Vector): BoundingBox;
  /**
   * Expands this bounding box to contain (or border) the specified position.
   *
   * @param position the position
   * @return this bounding box (now expanded)
   * @see #contains(double, double, double)
  */
  union(position: Location): BoundingBox;
  /**
   * Expands this bounding box to contain both this and the given bounding
   * box.
   *
   * @param other the other bounding box
   * @return this bounding box (now expanded)
  */
  union(other: BoundingBox): BoundingBox;
  /**
   * Resizes this bounding box to represent the intersection of this and the
   * given bounding box.
   *
   * @param other the other bounding box
   * @return this bounding box (now representing the intersection)
   * @throws IllegalArgumentException if the bounding boxes don't overlap
  */
  intersection(other: BoundingBox): BoundingBox;
  /**
   * Shifts this bounding box by the given amounts.
   *
   * @param shiftX the shift in x direction
   * @param shiftY the shift in y direction
   * @param shiftZ the shift in z direction
   * @return this bounding box (now shifted)
  */
  shift(shiftX: number, shiftY: number, shiftZ: number): BoundingBox;
  /**
   * Shifts this bounding box by the given amounts.
   *
   * @param shift the shift
   * @return this bounding box (now shifted)
  */
  shift(shift: Vector): BoundingBox;
  /**
   * Shifts this bounding box by the given amounts.
   *
   * @param shift the shift
   * @return this bounding box (now shifted)
  */
  shift(shift: Location): BoundingBox;
  /**
   * Checks if this bounding box overlaps with the given bounding box.
   * 
   * Bounding boxes that are only intersecting at the borders are not
   * considered overlapping.
   *
   * @param other the other bounding box
   * @return true if overlapping
  */
  overlaps(other: BoundingBox): boolean;
  /**
   * Checks if this bounding box overlaps with the bounding box that is
   * defined by the given corners.
   * 
   * Bounding boxes that are only intersecting at the borders are not
   * considered overlapping.
   *
   * @param min the first corner
   * @param max the second corner
   * @return true if overlapping
  */
  overlaps(min: Vector, max: Vector): boolean;
  /**
   * Checks if this bounding box contains the specified position.
   * 
   * Positions exactly on the minimum borders of the bounding box are
   * considered to be inside the bounding box, while positions exactly on the
   * maximum borders are considered to be outside. This allows bounding boxes
   * to reside directly next to each other with positions always only residing
   * in exactly one of them.
   *
   * @param x the position's x coordinates
   * @param y the position's y coordinates
   * @param z the position's z coordinates
   * @return true if the bounding box contains the position
  */
  contains(x: number, y: number, z: number): boolean;
  /**
   * Checks if this bounding box contains the specified position.
   * 
   * Positions exactly on the minimum borders of the bounding box are
   * considered to be inside the bounding box, while positions exactly on the
   * maximum borders are considered to be outside. This allows bounding boxes
   * to reside directly next to each other with positions always only residing
   * in exactly one of them.
   *
   * @param position the position
   * @return true if the bounding box contains the position
  */
  contains(position: Vector): boolean;
  /**
   * Checks if this bounding box fully contains the given bounding box.
   *
   * @param other the other bounding box
   * @return true if the bounding box contains the given bounding
   * box
  */
  contains(other: BoundingBox): boolean;
  /**
   * Checks if this bounding box fully contains the bounding box that is
   * defined by the given corners.
   *
   * @param min the first corner
   * @param max the second corner
   * @return true if the bounding box contains the specified
   *     bounding box
  */
  contains(min: Vector, max: Vector): boolean;
  /**
   * Calculates the intersection of this bounding box with the specified line
   * segment.
   * 
   * Intersections at edges and corners yield one of the affected block faces
   * as hit result, but it is not defined which of them.
   *
   * @param start the start position
   * @param direction the ray direction
   * @param maxDistance the maximum distance
   * @return the ray trace hit result, or null if there is no hit
  */
  rayTrace(start: Vector, direction: Vector, maxDistance: number): RayTraceResult | null;
  hashCode(): number;
  equals(obj: any): boolean;
  toString(): string;
  /**
   * Creates a copy of this bounding box.
   *
   * @return the cloned bounding box
  */
  clone(): BoundingBox;
  /**
   * Creates a Map representation of this class.
   * 
   * This class must provide a method to restore this class, as defined in
   * the {@link ConfigurationSerializable} interface javadocs.
   *
   * @return Map containing the current state of this class
  */
  serialize(): Map<string, any>;
  static deserialize(args: Map<string, any>): BoundingBox;
}
export interface BoundingBox extends Cloneable, ConfigurationSerializable {}
/**
 * This class performs ray tracing and iterates along blocks on a line
*/
export class BlockIterator extends Iterator<Block> {
  /**
   * Constructs the BlockIterator.
   * 
   * This considers all blocks as 1x1x1 in size.
   *
   * @param world The world to use for tracing
   * @param start A Vector giving the initial location for the trace
   * @param direction A Vector pointing in the direction for the trace
   * @param yOffset The trace begins vertically offset from the start vector
   *     by this value
   * @param maxDistance This is the maximum distance in blocks for the
   *     trace. Setting this value above 140 may lead to problems with
   *     unloaded chunks. A value of 0 indicates no limit
   *
  */
  constructor(world: World, start: Vector, direction: Vector, yOffset: number, maxDistance: number);
  /**
   * Constructs the BlockIterator.
   * 
   * This considers all blocks as 1x1x1 in size.
   *
   * @param loc The location for the start of the ray trace
   * @param yOffset The trace begins vertically offset from the start vector
   *     by this value
   * @param maxDistance This is the maximum distance in blocks for the
   *     trace. Setting this value above 140 may lead to problems with
   *     unloaded chunks. A value of 0 indicates no limit
  */
  constructor(loc: Location, yOffset: number, maxDistance: number);
  constructor(loc: Location, yOffset: number);
  constructor(loc: Location);
  constructor(entity: LivingEntity, maxDistance: number);
  constructor(entity: LivingEntity);
  hasNext(): boolean;
  /**
   * Returns the next Block in the trace
   *
   * @return the next Block in the trace
  */
  next(): Block;
  remove(): void;
}
export class StringUtil {
  /**
   * Copies all elements from the iterable collection of originals to the
   * collection provided.
   *
   * @param  the collection of strings
   * @param token String to search for
   * @param originals An iterable collection of strings to filter.
   * @param collection The collection to add matches to
   * @return the collection provided that would have the elements copied
   *     into
   * @throws UnsupportedOperationException if the collection is immutable
   *     and originals contains a string which starts with the specified
   *     search string.
   * @throws IllegalArgumentException if any parameter is is null
   * @throws IllegalArgumentException if originals contains a null element.
   *     Note: the collection may be modified before this is thrown
  */
  static copyPartialMatches<T>(token: string, originals: Iterable<string>, collection: T): T;
  /**
   * This method uses a region to check case-insensitive equality. This
   * means the internal array does not need to be copied like a
   * toLowerCase() call would.
   *
   * @param string String to check
   * @param prefix Prefix of string to compare
   * @return true if provided string starts with, ignoring case, the prefix
   *     provided
   * @throws NullPointerException if prefix is null
   * @throws IllegalArgumentException if string is null
  */
  static startsWithIgnoreCase(string: string, prefix: string): boolean;
}
/**
 * Represents a mutable vector. Because the components of Vectors are mutable,
 * storing Vectors long term may be dangerous if passing code modifies the
 * Vector later. If you want to keep around a Vector, it may be wise to call
 * clone() in order to get a copy.
*/
export class Vector extends Cloneable {
  /**
   * Construct the vector with all components as 0.
  */
  constructor();
  /**
   * Construct the vector with provided integer components.
   *
   * @param x X component
   * @param y Y component
   * @param z Z component
  */
  constructor(x: number, y: number, z: number);
  /**
   * Adds a vector to this one
   *
   * @param vec The other vector
   * @return the same vector
  */
  add(vec: Vector): Vector;
  /**
   * Subtracts a vector from this one.
   *
   * @param vec The other vector
   * @return the same vector
  */
  subtract(vec: Vector): Vector;
  /**
   * Multiplies the vector by another.
   *
   * @param vec The other vector
   * @return the same vector
  */
  multiply(vec: Vector): Vector;
  /**
   * Divides the vector by another.
   *
   * @param vec The other vector
   * @return the same vector
  */
  divide(vec: Vector): Vector;
  /**
   * Copies another vector
   *
   * @param vec The other vector
   * @return the same vector
  */
  copy(vec: Vector): Vector;
  /**
   * Gets the magnitude of the vector, defined as sqrt(x^2+y^2+z^2). The
   * value of this method is not cached and uses a costly square-root
   * function, so do not repeatedly call this method to get the vector's
   * magnitude. NaN will be returned if the inner result of the sqrt()
   * function overflows, which will be caused if the length is too long.
   *
   * @return the magnitude
  */
  length(): number;
  /**
   * Gets the magnitude of the vector squared.
   *
   * @return the magnitude
  */
  lengthSquared(): number;
  /**
   * Get the distance between this vector and another. The value of this
   * method is not cached and uses a costly square-root function, so do not
   * repeatedly call this method to get the vector's magnitude. NaN will be
   * returned if the inner result of the sqrt() function overflows, which
   * will be caused if the distance is too long.
   *
   * @param o The other vector
   * @return the distance
  */
  distance(o: Vector): number;
  /**
   * Get the squared distance between this vector and another.
   *
   * @param o The other vector
   * @return the distance
  */
  distanceSquared(o: Vector): number;
  /**
   * Gets the angle between this vector and another in radians.
   *
   * @param other The other vector
   * @return angle in radians
  */
  angle(other: Vector): number;
  /**
   * Sets this vector to the midpoint between this vector and another.
   *
   * @param other The other vector
   * @return this same vector (now a midpoint)
  */
  midpoint(other: Vector): Vector;
  /**
   * Gets a new midpoint vector between this vector and another.
   *
   * @param other The other vector
   * @return a new midpoint vector
  */
  getMidpoint(other: Vector): Vector;
  /**
   * Performs scalar multiplication, multiplying all components with a
   * scalar.
   *
   * @param m The factor
   * @return the same vector
  */
  multiply(m: number): Vector;
  /**
   * Calculates the dot product of this vector with another. The dot product
   * is defined as x1*x2+y1*y2+z1*z2. The returned value is a scalar.
   *
   * @param other The other vector
   * @return dot product
  */
  dot(other: Vector): number;
  /**
   * Calculates the cross product of this vector with another. The cross
   * product is defined as:
   * 
   * x = y1 * z2 - y2 * z1
   * y = z1 * x2 - z2 * x1
   * z = x1 * y2 - x2 * y1
   * 
   *
   * @param o The other vector
   * @return the same vector
  */
  crossProduct(o: Vector): Vector;
  /**
   * Calculates the cross product of this vector with another without mutating
   * the original. The cross product is defined as:
   * 
   * x = y1 * z2 - y2 * z1
   * y = z1 * x2 - z2 * x1
   * z = x1 * y2 - x2 * y1
   * 
   *
   * @param o The other vector
   * @return a new vector
  */
  getCrossProduct(o: Vector): Vector;
  /**
   * Converts this vector to a unit vector (a vector with length of 1).
   *
   * @return the same vector
  */
  normalize(): Vector;
  /**
   * Zero this vector's components.
   *
   * @return the same vector
  */
  zero(): Vector;
  /**
   * Returns whether this vector is in an axis-aligned bounding box.
   * 
   * The minimum and maximum vectors given must be truly the minimum and
   * maximum X, Y and Z components.
   *
   * @param min Minimum vector
   * @param max Maximum vector
   * @return whether this vector is in the AABB
  */
  isInAABB(min: Vector, max: Vector): boolean;
  /**
   * Returns whether this vector is within a sphere.
   *
   * @param origin Sphere origin.
   * @param radius Sphere radius
   * @return whether this vector is in the sphere
  */
  isInSphere(origin: Vector, radius: number): boolean;
  /**
   * Returns if a vector is normalized
   *
   * @return whether the vector is normalised
  */
  isNormalized(): boolean;
  /**
   * Rotates the vector around the x axis.
   * 
   * This piece of math is based on the standard rotation matrix for vectors
   * in three dimensional space. This matrix can be found here:
   * Rotation
   * Matrix.
   *
   * @param angle the angle to rotate the vector about. This angle is passed
   * in radians
   * @return the same vector
  */
  rotateAroundX(angle: number): Vector;
  /**
   * Rotates the vector around the y axis.
   * 
   * This piece of math is based on the standard rotation matrix for vectors
   * in three dimensional space. This matrix can be found here:
   * Rotation
   * Matrix.
   *
   * @param angle the angle to rotate the vector about. This angle is passed
   * in radians
   * @return the same vector
  */
  rotateAroundY(angle: number): Vector;
  /**
   * Rotates the vector around the z axis
   * 
   * This piece of math is based on the standard rotation matrix for vectors
   * in three dimensional space. This matrix can be found here:
   * Rotation
   * Matrix.
   *
   * @param angle the angle to rotate the vector about. This angle is passed
   * in radians
   * @return the same vector
  */
  rotateAroundZ(angle: number): Vector;
  /**
   * Rotates the vector around a given arbitrary axis in 3 dimensional space.
   *
   * 
   * Rotation will follow the general Right-Hand-Rule, which means rotation
   * will be counterclockwise when the axis is pointing towards the observer.
   * 
   * This method will always make sure the provided axis is a unit vector, to
   * not modify the length of the vector when rotating. If you are experienced
   * with the scaling of a non-unit axis vector, you can use
   * {@link Vector#rotateAroundNonUnitAxis(Vector, double)}.
   *
   * @param axis the axis to rotate the vector around. If the passed vector is
   * not of length 1, it gets copied and normalized before using it for the
   * rotation. Please use {@link Vector#normalize()} on the instance before
   * passing it to this method
   * @param angle the angle to rotate the vector around the axis
   * @return the same vector
   * @throws IllegalArgumentException if the provided axis vector instance is
   * null
  */
  rotateAroundAxis(axis: Vector, angle: number): Vector;
  /**
   * Rotates the vector around a given arbitrary axis in 3 dimensional space.
   *
   * 
   * Rotation will follow the general Right-Hand-Rule, which means rotation
   * will be counterclockwise when the axis is pointing towards the observer.
   * 
   * Note that the vector length will change accordingly to the axis vector
   * length. If the provided axis is not a unit vector, the rotated vector
   * will not have its previous length. The scaled length of the resulting
   * vector will be related to the axis vector. If you are not perfectly sure
   * about the scaling of the vector, use
   * {@link Vector#rotateAroundAxis(Vector, double)}
   *
   * @param axis the axis to rotate the vector around.
   * @param angle the angle to rotate the vector around the axis
   * @return the same vector
   * @throws IllegalArgumentException if the provided axis vector instance is
   * null
  */
  rotateAroundNonUnitAxis(axis: Vector, angle: number): Vector;
  /**
   * Gets the X component.
   *
   * @return The X component.
  */
  getX(): number;
  /**
   * Gets the floored value of the X component, indicating the block that
   * this vector is contained with.
   *
   * @return block X
  */
  getBlockX(): number;
  /**
   * Gets the Y component.
   *
   * @return The Y component.
  */
  getY(): number;
  /**
   * Gets the floored value of the Y component, indicating the block that
   * this vector is contained with.
   *
   * @return block y
  */
  getBlockY(): number;
  /**
   * Gets the Z component.
   *
   * @return The Z component.
  */
  getZ(): number;
  /**
   * Gets the floored value of the Z component, indicating the block that
   * this vector is contained with.
   *
   * @return block z
  */
  getBlockZ(): number;
  /**
   * Set the X component.
   *
   * @param x The new X component.
   * @return This vector.
  */
  setX(x: number);
  /**
   * Set the Y component.
   *
   * @param y The new Y component.
   * @return This vector.
  */
  setY(y: number);
  /**
   * Set the Z component.
   *
   * @param z The new Z component.
   * @return This vector.
  */
  setZ(z: number);
  /**
   * Checks to see if two objects are equal.
   * 
   * Only two Vectors can ever return true. This method uses a fuzzy match
   * to account for floating point errors. The epsilon can be retrieved
   * with epsilon.
  */
  equals(obj: any): boolean;
  /**
   * Returns a hash code for this vector
   *
   * @return hash code
  */
  hashCode(): number;
  /**
   * Get a new vector.
   *
   * @return vector
  */
  clone(): Vector;
  /**
   * Returns this vector's components as x,y,z.
  */
  toString(): string;
  /**
   * Gets a Location version of this vector with yaw and pitch being 0.
   *
   * @param world The world to link the location to.
   * @return the location
  */
  toLocation(world: World): Location;
  /**
   * Gets a Location version of this vector.
   *
   * @param world The world to link the location to.
   * @param yaw The desired yaw.
   * @param pitch The desired pitch.
   * @return the location
  */
  toLocation(world: World, yaw: number, pitch: number): Location;
  /**
   * Get the block vector of this vector.
   *
   * @return A block vector.
  */
  toBlockVector(): BlockVector;
  /**
   * Check if each component of this Vector is finite.
   *
   * @throws IllegalArgumentException if any component is not finite
  */
  checkFinite(): void;
  /**
   * Get the threshold used for equals().
   *
   * @return The epsilon.
  */
  static getEpsilon(): number;
  /**
   * Gets the minimum components of two vectors.
   *
   * @param v1 The first vector.
   * @param v2 The second vector.
   * @return minimum
  */
  static getMinimum(v1: Vector, v2: Vector): Vector;
  /**
   * Gets the maximum components of two vectors.
   *
   * @param v1 The first vector.
   * @param v2 The second vector.
   * @return maximum
  */
  static getMaximum(v1: Vector, v2: Vector): Vector;
  /**
   * Gets a random vector with components having a random value between 0
   * and 1.
   *
   * @return A random vector.
  */
  static getRandom(): Vector;
  /**
   * Creates a Map representation of this class.
   * 
   * This class must provide a method to restore this class, as defined in
   * the {@link ConfigurationSerializable} interface javadocs.
   *
   * @return Map containing the current state of this class
  */
  serialize(): Map<string, any>;
  static deserialize(args: Map<string, any>): Vector;
}
export interface Vector extends Cloneable, ConfigurationSerializable {}
/**
 * Class containing file utilities
*/
export class FileUtil {
  /**
   * This method copies one file to another location
   *
   * @param inFile the source filename
   * @param outFile the target filename
   * @return true on success
  */
  static copy(inFile: File, outFile: File): boolean;
}
/**
 * A shape made out of voxels.
 *
 * For example, used to represent the detailed collision shape of blocks.
*/
export class VoxelShape {
  /**
   * Converts this shape into a collection of {@link BoundingBox} equivalent
   * to the shape: a bounding box intersects with this block shape if it
   * intersects with any of the shape's bounding boxes.
   *
   * @return shape converted to bounding boxes
  */
  getBoundingBoxes(): Collection<BoundingBox>;
  /**
   * Checks if the given bounding box intersects this block shape.
   *
   * @param other bounding box to test
   * @return true if other overlaps this, false otherwise
  */
  overlaps(other: BoundingBox): boolean;
}

}
declare module 'org.bukkit.entity.EnderDragon' {
import { Enum } from 'java.lang';
/**
 * Represents a phase or action that an Ender Dragon can perform.
*/
export class Phase extends Enum<Phase> {
  /**
   * The dragon will circle outside the ring of pillars if ender
   * crystals remain or inside the ring if not.
  */
  static readonly CIRCLING: Phase;
  /**
   * The dragon will fly towards a targeted player and shoot a
   * fireball when within 64 blocks.
  */
  static readonly STRAFING: Phase;
  /**
   * The dragon will fly towards the empty portal (approaching
   * from the other side, if applicable).
  */
  static readonly FLY_TO_PORTAL: Phase;
  /**
   * The dragon will land on on the portal. If the dragon is not near
   * the portal, it will fly to it before mounting.
  */
  static readonly LAND_ON_PORTAL: Phase;
  /**
   * The dragon will leave the portal.
  */
  static readonly LEAVE_PORTAL: Phase;
  /**
   * The dragon will attack with dragon breath at its current location.
  */
  static readonly BREATH_ATTACK: Phase;
  /**
   * The dragon will search for a player to attack with dragon breath.
   * If no player is close enough to the dragon for 5 seconds, the
   * dragon will charge at a player within 150 blocks or will take off
   * and begin circling if no player is found.
  */
  static readonly SEARCH_FOR_BREATH_ATTACK_TARGET: Phase;
  /**
   * The dragon will roar before performing a breath attack.
  */
  static readonly ROAR_BEFORE_ATTACK: Phase;
  /**
   * The dragon will charge a player.
  */
  static readonly CHARGE_PLAYER: Phase;
  /**
   * The dragon will fly to the vicinity of the portal and die.
  */
  static readonly DYING: Phase;
  /**
   * The dragon will hover at its current location, not performing any actions.
  */
  static readonly HOVER: Phase;
  static valueOf(name: string): Phase;
  static values(): Phase[];
}

}
declare module 'org.bukkit.block.data.type.SculkSensor' {
import { Enum } from 'java.lang';
/**
 * The Phase of the sensor.
*/
export class Phase extends Enum<Phase> {
  /**
   * The sensor is inactive.
  */
  static readonly INACTIVE: Phase;
  /**
   * The sensor is active.
  */
  static readonly ACTIVE: Phase;
  /**
   * The sensor is cooling down.
  */
  static readonly COOLDOWN: Phase;
  static valueOf(name: string): Phase;
  static values(): Phase[];
}

}
