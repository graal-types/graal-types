declare module 'java.util.Spliterators' {
import { Spliterator } from 'java.util';
import { OfInt, OfLong, OfDouble } from 'java.util.Spliterator';
/**
 * An abstract `Spliterator` that implements `trySplit` to
 * permit limited parallelism.
 *
 * An extending class need only
 * implement {@link #tryAdvance(java.util.function.Consumer) tryAdvance}.
 * The extending class should override
 * {@link #forEachRemaining(java.util.function.Consumer) forEachRemaining}
 * if it can provide a more performant implementation.
 *
 * @apiNote
 * This class is a useful aid for creating a spliterator when it is not
 * possible or difficult to efficiently partition elements in a manner
 * allowing balanced parallel computation.
 *
 * An alternative to using this class, that also permits limited
 * parallelism, is to create a spliterator from an iterator
 * (see {@link #spliterator(Iterator, long, int)}.  Depending on the
 * circumstances using an iterator may be easier or more convenient than
 * extending this class, such as when there is already an iterator
 * available to use.
 *
 * @see #spliterator(Iterator, long, int)
 * @since 1.8
*/
export class AbstractSpliterator<T> extends Spliterator<T> {
  /**
   * {@inheritDoc}
   *
   * This implementation permits limited parallelism.
  */
  trySplit(): Spliterator<T>;
  /**
   * {@inheritDoc}
   *
   * @implSpec
   * This implementation returns the estimated size as reported when
   * created and, if the estimate size is known, decreases in size when
   * split.
  */
  estimateSize(): number;
  /**
   * {@inheritDoc}
   *
   * @implSpec
   * This implementation returns the characteristics as reported when
   * created.
  */
  characteristics(): number;
}
/**
 * An abstract `Spliterator.OfInt` that implements `trySplit` to
 * permit limited parallelism.
 *
 * To implement a spliterator an extending class need only
 * implement {@link #tryAdvance(java.util.function.IntConsumer)
 * tryAdvance}.  The extending class should override
 * {@link #forEachRemaining(java.util.function.IntConsumer) forEachRemaining}
 * if it can provide a more performant implementation.
 *
 * @apiNote
 * This class is a useful aid for creating a spliterator when it is not
 * possible or difficult to efficiently partition elements in a manner
 * allowing balanced parallel computation.
 *
 * An alternative to using this class, that also permits limited
 * parallelism, is to create a spliterator from an iterator
 * (see {@link #spliterator(java.util.PrimitiveIterator.OfInt, long, int)}.
 * Depending on the circumstances using an iterator may be easier or more
 * convenient than extending this class. For example, if there is already an
 * iterator available to use then there is no need to extend this class.
 *
 * @see #spliterator(java.util.PrimitiveIterator.OfInt, long, int)
 * @since 1.8
*/
export class AbstractIntSpliterator extends OfInt {
  /**
   * {@inheritDoc}
   *
   * This implementation permits limited parallelism.
  */
  trySplit(): OfInt;
  /**
   * {@inheritDoc}
   *
   * @implSpec
   * This implementation returns the estimated size as reported when
   * created and, if the estimate size is known, decreases in size when
   * split.
  */
  estimateSize(): number;
  /**
   * {@inheritDoc}
   *
   * @implSpec
   * This implementation returns the characteristics as reported when
   * created.
  */
  characteristics(): number;
}
/**
 * An abstract `Spliterator.OfLong` that implements `trySplit`
 * to permit limited parallelism.
 *
 * To implement a spliterator an extending class need only
 * implement {@link #tryAdvance(java.util.function.LongConsumer)
 * tryAdvance}.  The extending class should override
 * {@link #forEachRemaining(java.util.function.LongConsumer) forEachRemaining}
 * if it can provide a more performant implementation.
 *
 * @apiNote
 * This class is a useful aid for creating a spliterator when it is not
 * possible or difficult to efficiently partition elements in a manner
 * allowing balanced parallel computation.
 *
 * An alternative to using this class, that also permits limited
 * parallelism, is to create a spliterator from an iterator
 * (see {@link #spliterator(java.util.PrimitiveIterator.OfLong, long, int)}.
 * Depending on the circumstances using an iterator may be easier or more
 * convenient than extending this class. For example, if there is already an
 * iterator available to use then there is no need to extend this class.
 *
 * @see #spliterator(java.util.PrimitiveIterator.OfLong, long, int)
 * @since 1.8
*/
export class AbstractLongSpliterator extends OfLong {
  /**
   * {@inheritDoc}
   *
   * This implementation permits limited parallelism.
  */
  trySplit(): OfLong;
  /**
   * {@inheritDoc}
   *
   * @implSpec
   * This implementation returns the estimated size as reported when
   * created and, if the estimate size is known, decreases in size when
   * split.
  */
  estimateSize(): number;
  /**
   * {@inheritDoc}
   *
   * @implSpec
   * This implementation returns the characteristics as reported when
   * created.
  */
  characteristics(): number;
}
/**
 * An abstract `Spliterator.OfDouble` that implements
 * `trySplit` to permit limited parallelism.
 *
 * To implement a spliterator an extending class need only
 * implement {@link #tryAdvance(java.util.function.DoubleConsumer)
 * tryAdvance}.  The extending class should override
 * {@link #forEachRemaining(java.util.function.DoubleConsumer) forEachRemaining}
 * if it can provide a more performant implementation.
 *
 * @apiNote
 * This class is a useful aid for creating a spliterator when it is not
 * possible or difficult to efficiently partition elements in a manner
 * allowing balanced parallel computation.
 *
 * An alternative to using this class, that also permits limited
 * parallelism, is to create a spliterator from an iterator
 * (see {@link #spliterator(java.util.PrimitiveIterator.OfDouble, long, int)}.
 * Depending on the circumstances using an iterator may be easier or more
 * convenient than extending this class. For example, if there is already an
 * iterator available to use then there is no need to extend this class.
 *
 * @see #spliterator(java.util.PrimitiveIterator.OfDouble, long, int)
 * @since 1.8
*/
export class AbstractDoubleSpliterator extends OfDouble {
  /**
   * {@inheritDoc}
   *
   * This implementation permits limited parallelism.
  */
  trySplit(): OfDouble;
  /**
   * {@inheritDoc}
   *
   * @implSpec
   * This implementation returns the estimated size as reported when
   * created and, if the estimate size is known, decreases in size when
   * split.
  */
  estimateSize(): number;
  /**
   * {@inheritDoc}
   *
   * @implSpec
   * This implementation returns the characteristics as reported when
   * created.
  */
  characteristics(): number;
}

}
declare module 'java.util.zip' {
import { XEntry } from 'java.util.zip.ZipOutputStream';
import { Cloneable, InternalError, Exception } from 'java.lang';
import { LocalDateTime } from 'java.time';
import { Enumeration, Vector, HashSet } from 'java.util';
import { FilterInputStream, InputStream, OutputStream, Closeable, IOException, FilterOutputStream, File } from 'java.io';
import { InflaterZStreamRef } from 'java.util.zip.Inflater';
import { Stream } from 'java.util.stream';
import { CleanableResource } from 'java.util.zip.ZipFile';
import { ByteBuffer } from 'java.nio';
import { DeflaterZStreamRef } from 'java.util.zip.Deflater';
import { Charset } from 'java.nio.charset';
import { FileTime } from 'java.nio.file.attribute';
/**
 * This class implements a stream filter for writing compressed data in
 * the GZIP file format.
 * @author      David Connelly
 * @since 1.1
 *
*/
export class GZIPOutputStream extends DeflaterOutputStream {
  /**
   * Creates a new output stream with the specified buffer size.
   *
   * The new output stream instance is created as if by invoking
   * the 3-argument constructor GZIPOutputStream(out, size, false).
   *
   * @param out the output stream
   * @param size the output buffer size
   * @throws    IOException If an I/O error has occurred.
   * @throws    IllegalArgumentException if `size <= 0`
  */
  constructor(out: OutputStream, size: number);
  /**
   * Creates a new output stream with the specified buffer size and
   * flush mode.
   *
   * @param out the output stream
   * @param size the output buffer size
   * @param syncFlush
   *        if `true` invocation of the inherited
   *        {@link DeflaterOutputStream#flush() flush()} method of
   *        this instance flushes the compressor with flush mode
   *        {@link Deflater#SYNC_FLUSH} before flushing the output
   *        stream, otherwise only flushes the output stream
   * @throws    IOException If an I/O error has occurred.
   * @throws    IllegalArgumentException if `size <= 0`
   *
   * @since 1.7
  */
  constructor(out: OutputStream, size: number, syncFlush: boolean);
  /**
   * Creates a new output stream with a default buffer size.
   *
   * The new output stream instance is created as if by invoking
   * the 2-argument constructor GZIPOutputStream(out, false).
   *
   * @param out the output stream
   * @throws    IOException If an I/O error has occurred.
  */
  constructor(out: OutputStream);
  /**
   * Creates a new output stream with a default buffer size and
   * the specified flush mode.
   *
   * @param out the output stream
   * @param syncFlush
   *        if `true` invocation of the inherited
   *        {@link DeflaterOutputStream#flush() flush()} method of
   *        this instance flushes the compressor with flush mode
   *        {@link Deflater#SYNC_FLUSH} before flushing the output
   *        stream, otherwise only flushes the output stream
   *
   * @throws    IOException If an I/O error has occurred.
   *
   * @since 1.7
  */
  constructor(out: OutputStream, syncFlush: boolean);
  /**
   * Writes array of bytes to the compressed output stream. This method
   * will block until all the bytes are written.
   * @param buf the data to be written
   * @param off the start offset of the data
   * @param len the length of the data
   * @throws    IOException If an I/O error has occurred.
  */
  write(buf: number[], off: number, len: number): void;
  /**
   * Finishes writing compressed data to the output stream without closing
   * the underlying stream. Use this method when applying multiple filters
   * in succession to the same output stream.
   * @throws    IOException if an I/O error has occurred
  */
  finish(): void;
  /**
   * Writes a byte to the compressed output stream. This method will
   * block until the byte can be written.
   * @param b the byte to be written
   * @throws    IOException if an I/O error has occurred
  */
  write(b: number): void;
  /**
   * Writes `b.length` bytes to this output stream.
   * 
   * The `write` method of `FilterOutputStream`
   * calls its `write` method of three arguments with the
   * arguments `b`, `0`, and
   * `b.length`.
   * 
   * Note that this method does not call the one-argument
   * `write` method of its underlying output stream with
   * the single argument `b`.
   *
   * @param      b   the data to be written.
   * @throws     IOException  if an I/O error occurs.
   * @see        java.io.FilterOutputStream#write(byte[], int, int)
  */
  write(b: number[]): void;
}
/**
 * Signals that an unrecoverable error has occurred.
 *
 * @author  Dave Bristor
 * @since   1.6
*/
export class ZipError extends InternalError {
  /**
   * Constructs a ZipError with the given detail message.
   * @param s the `String` containing a detail message
  */
  constructor(s: string);
}
/**
 * A class that can be used to compute the Adler-32 checksum of a data
 * stream. An Adler-32 checksum is almost as reliable as a CRC-32 but
 * can be computed much faster.
 *
 *  Passing a `null` argument to a method in this class will cause
 * a {@link NullPointerException} to be thrown.
 *
 * @author      David Connelly
 * @since 1.1
*/
export class Adler32 extends Checksum {
  /**
   * Creates a new Adler32 object.
  */
  constructor();
  /**
   * Updates the checksum with the specified byte (the low eight
   * bits of the argument b).
  */
  update(b: number): void;
  /**
   * Updates the checksum with the specified array of bytes.
   *
   * @throws ArrayIndexOutOfBoundsException
   *         if `off` is negative, or `len` is negative, or
   *         `off+len` is negative or greater than the length of
   *         the array `b`.
  */
  update(b: number[], off: number, len: number): void;
  /**
   * Updates the checksum with the bytes from the specified buffer.
   *
   * The checksum is updated with the remaining bytes in the buffer, starting
   * at the buffer's position. Upon return, the buffer's position will be
   * updated to its limit; its limit will not have been changed.
   *
   * @since 1.8
  */
  update(buffer: ByteBuffer): void;
  /**
   * Resets the checksum to initial value.
  */
  reset(): void;
  /**
   * Returns the checksum value.
  */
  getValue(): number;
  /**
   * Updates the current checksum with the specified array of bytes.
   *
   * @implSpec This default implementation is equal to calling
   * `update(b, 0, b.length)`.
   *
   * @param b the array of bytes to update the checksum with
   *
   * @throws NullPointerException
   *         if `b` is `null`
   *
   * @since 9
  */
  update(b: number[]): void;
}
/**
 * This class is used to read entries from a zip file.
 *
 *  Unless otherwise noted, passing a `null` argument to a constructor
 * or method in this class will cause a {@link NullPointerException} to be
 * thrown.
 *
 * @apiNote
 * To release resources used by this `ZipFile`, the {@link #close()} method
 * should be called explicitly or by try-with-resources. Subclasses are responsible
 * for the cleanup of resources acquired by the subclass. Subclasses that override
 * {@link #finalize()} in order to perform cleanup should be modified to use alternative
 * cleanup mechanisms such as {@link java.lang.ref.Cleaner} and remove the overriding
 * `finalize` method.
 *
 * @author      David Connelly
 * @since 1.1
*/
export class ZipFile extends Closeable {
  /**
   * Mode flag to open a zip file for reading.
  */
  static readonly OPEN_READ: number;
  /**
   * Mode flag to open a zip file and mark it for deletion.  The file will be
   * deleted some time between the moment that it is opened and the moment
   * that it is closed, but its contents will remain accessible via the
   * `ZipFile` object until either the close method is invoked or the
   * virtual machine exits.
  */
  static readonly OPEN_DELETE: number;
  /**
   * Opens a zip file for reading.
   *
   * First, if there is a security manager, its `checkRead`
   * method is called with the `name` argument as its argument
   * to ensure the read is allowed.
   *
   * The UTF-8 {@link java.nio.charset.Charset charset} is used to
   * decode the entry names and comments.
   *
   * @param name the name of the zip file
   * @throws ZipException if a ZIP format error has occurred
   * @throws IOException if an I/O error has occurred
   * @throws SecurityException if a security manager exists and its
   *         `checkRead` method doesn't allow read access to the file.
   *
   * @see SecurityManager#checkRead(java.lang.String)
  */
  constructor(name: string);
  /**
   * Opens a new `ZipFile` to read from the specified
   * `File` object in the specified mode.  The mode argument
   * must be either `OPEN_READ` or `OPEN_READ | OPEN_DELETE`.
   *
   * First, if there is a security manager, its `checkRead`
   * method is called with the `name` argument as its argument to
   * ensure the read is allowed.
   *
   * The UTF-8 {@link java.nio.charset.Charset charset} is used to
   * decode the entry names and comments
   *
   * @param file the ZIP file to be opened for reading
   * @param mode the mode in which the file is to be opened
   * @throws ZipException if a ZIP format error has occurred
   * @throws IOException if an I/O error has occurred
   * @throws SecurityException if a security manager exists and
   *         its `checkRead` method
   *         doesn't allow read access to the file,
   *         or its `checkDelete` method doesn't allow deleting
   *         the file when the `OPEN_DELETE` flag is set.
   * @throws IllegalArgumentException if the `mode` argument is invalid
   * @see SecurityManager#checkRead(java.lang.String)
   * @since 1.3
  */
  constructor(file: File, mode: number);
  /**
   * Opens a ZIP file for reading given the specified File object.
   *
   * The UTF-8 {@link java.nio.charset.Charset charset} is used to
   * decode the entry names and comments.
   *
   * @param file the ZIP file to be opened for reading
   * @throws ZipException if a ZIP format error has occurred
   * @throws IOException if an I/O error has occurred
  */
  constructor(file: File);
  /**
   * Opens a new `ZipFile` to read from the specified
   * `File` object in the specified mode.  The mode argument
   * must be either `OPEN_READ` or `OPEN_READ | OPEN_DELETE`.
   *
   * First, if there is a security manager, its `checkRead`
   * method is called with the `name` argument as its argument to
   * ensure the read is allowed.
   *
   * @param file the ZIP file to be opened for reading
   * @param mode the mode in which the file is to be opened
   * @param charset
   *        the {@linkplain java.nio.charset.Charset charset} to
   *        be used to decode the ZIP entry name and comment that are not
   *        encoded by using UTF-8 encoding (indicated by entry's general
   *        purpose flag).
   *
   * @throws ZipException if a ZIP format error has occurred
   * @throws IOException if an I/O error has occurred
   *
   * @throws SecurityException
   *         if a security manager exists and its `checkRead`
   *         method doesn't allow read access to the file,or its
   *         `checkDelete` method doesn't allow deleting the
   *         file when the `OPEN_DELETE` flag is set
   *
   * @throws IllegalArgumentException if the `mode` argument is invalid
   *
   * @see SecurityManager#checkRead(java.lang.String)
   *
   * @since 1.7
  */
  constructor(file: File, mode: number, charset: Charset);
  /**
   * Opens a zip file for reading.
   *
   * First, if there is a security manager, its `checkRead`
   * method is called with the `name` argument as its argument
   * to ensure the read is allowed.
   *
   * @param name the name of the zip file
   * @param charset
   *        the {@linkplain java.nio.charset.Charset charset} to
   *        be used to decode the ZIP entry name and comment that are not
   *        encoded by using UTF-8 encoding (indicated by entry's general
   *        purpose flag).
   *
   * @throws ZipException if a ZIP format error has occurred
   * @throws IOException if an I/O error has occurred
   * @throws SecurityException
   *         if a security manager exists and its `checkRead`
   *         method doesn't allow read access to the file
   *
   * @see SecurityManager#checkRead(java.lang.String)
   *
   * @since 1.7
  */
  constructor(name: string, charset: Charset);
  /**
   * Opens a ZIP file for reading given the specified File object.
   *
   * @param file the ZIP file to be opened for reading
   * @param charset
   *        The {@linkplain java.nio.charset.Charset charset} to be
   *        used to decode the ZIP entry name and comment (ignored if
   *        the  language
   *        encoding bit of the ZIP entry's general purpose bit
   *        flag is set).
   *
   * @throws ZipException if a ZIP format error has occurred
   * @throws IOException if an I/O error has occurred
   *
   * @since 1.7
  */
  constructor(file: File, charset: Charset);
  /**
   * Returns the zip file comment, or null if none.
   *
   * @return the comment string for the zip file, or null if none
   *
   * @throws IllegalStateException if the zip file has been closed
   *
   * @since 1.7
  */
  getComment(): string;
  /**
   * Returns the zip file entry for the specified name, or null
   * if not found.
   *
   * @param name the name of the entry
   * @return the zip file entry, or null if not found
   * @throws IllegalStateException if the zip file has been closed
  */
  getEntry(name: string): ZipEntry;
  /**
   * Returns an input stream for reading the contents of the specified
   * zip file entry.
   * 
   * Closing this ZIP file will, in turn, close all input streams that
   * have been returned by invocations of this method.
   *
   * @param entry the zip file entry
   * @return the input stream for reading the contents of the specified
   * zip file entry.
   * @throws ZipException if a ZIP format error has occurred
   * @throws IOException if an I/O error has occurred
   * @throws IllegalStateException if the zip file has been closed
  */
  getInputStream(entry: ZipEntry): InputStream;
  /**
   * Returns the path name of the ZIP file.
   * @return the path name of the ZIP file
  */
  getName(): string;
  /**
   * Returns an enumeration of the ZIP file entries.
   * @return an enumeration of the ZIP file entries
   * @throws IllegalStateException if the zip file has been closed
  */
  entries(): Enumeration<ZipEntry>;
  /**
   * Returns an ordered `Stream` over the ZIP file entries.
   *
   * Entries appear in the `Stream` in the order they appear in
   * the central directory of the ZIP file.
   *
   * @return an ordered `Stream` of entries in this ZIP file
   * @throws IllegalStateException if the zip file has been closed
   * @since 1.8
  */
  stream(): Stream<ZipEntry>;
  /**
   * Returns the number of entries in the ZIP file.
   *
   * @return the number of entries in the ZIP file
   * @throws IllegalStateException if the zip file has been closed
  */
  size(): number;
  /**
   * Closes the ZIP file.
   *
   *  Closing this ZIP file will close all of the input streams
   * previously returned by invocations of the {@link #getInputStream
   * getInputStream} method.
   *
   * @throws IOException if an I/O error has occurred
  */
  close(): void;
}
/**
 * This class implements an input stream filter for reading files in the
 * ZIP file format. Includes support for both compressed and uncompressed
 * entries.
 *
 * @author      David Connelly
 * @since 1.1
*/
export class ZipInputStream extends InflaterInputStream {
  /**
   * Creates a new ZIP input stream.
   *
   * The UTF-8 {@link java.nio.charset.Charset charset} is used to
   * decode the entry names.
   *
   * @param in the actual input stream
  */
  constructor(in_: InputStream);
  /**
   * Creates a new ZIP input stream.
   *
   * @param in the actual input stream
   *
   * @param charset
   *        The {@linkplain java.nio.charset.Charset charset} to be
   *        used to decode the ZIP entry name (ignored if the
   *         language
   *        encoding bit of the ZIP entry's general purpose bit
   *        flag is set).
   *
   * @since 1.7
  */
  constructor(in_: InputStream, charset: Charset);
  /**
   * Reads the next ZIP file entry and positions the stream at the
   * beginning of the entry data.
   * @return the next ZIP file entry, or null if there are no more entries
   * @throws    ZipException if a ZIP file error has occurred
   * @throws    IOException if an I/O error has occurred
  */
  getNextEntry(): ZipEntry;
  /**
   * Closes the current ZIP entry and positions the stream for reading the
   * next entry.
   * @throws    ZipException if a ZIP file error has occurred
   * @throws    IOException if an I/O error has occurred
  */
  closeEntry(): void;
  /**
   * Returns 0 after EOF has reached for the current entry data,
   * otherwise always return 1.
   * 
   * Programs should not count on this method to return the actual number
   * of bytes that could be read without blocking.
   *
   * @return     1 before EOF and 0 after EOF has reached for current entry.
   * @throws     IOException  if an I/O error occurs.
   *
  */
  available(): number;
  /**
   * Reads from the current ZIP entry into an array of bytes.
   * If `len` is not zero, the method
   * blocks until some input is available; otherwise, no
   * bytes are read and `0` is returned.
   * @param b the buffer into which the data is read
   * @param off the start offset in the destination array `b`
   * @param len the maximum number of bytes read
   * @return the actual number of bytes read, or -1 if the end of the
   *         entry is reached
   * @throws     NullPointerException if `b` is `null`.
   * @throws     IndexOutOfBoundsException if `off` is negative,
   * `len` is negative, or `len` is greater than
   * `b.length - off`
   * @throws    ZipException if a ZIP file error has occurred
   * @throws    IOException if an I/O error has occurred
  */
  read(b: number[], off: number, len: number): number;
  /**
   * Skips specified number of bytes in the current ZIP entry.
   * @param n the number of bytes to skip
   * @return the actual number of bytes skipped
   * @throws    ZipException if a ZIP file error has occurred
   * @throws    IOException if an I/O error has occurred
   * @throws    IllegalArgumentException if `n < 0`
  */
  skip(n: number): number;
  /**
   * Closes this input stream and releases any system resources associated
   * with the stream.
   * @throws    IOException if an I/O error has occurred
  */
  close(): void;
  /**
   * Reads a byte of uncompressed data. This method will block until
   * enough input is available for decompression.
   * @return the byte read, or -1 if end of compressed input is reached
   * @throws    IOException if an I/O error has occurred
  */
  read(): number;
  /**
   * Reads up to `b.length` bytes of data from this
   * input stream into an array of bytes. This method blocks until some
   * input is available.
   * 
   * This method simply performs the call
   * `read(b, 0, b.length)` and returns
   * the  result. It is important that it does
   * not do `in.read(b)` instead;
   * certain subclasses of  `FilterInputStream`
   * depend on the implementation strategy actually
   * used.
   *
   * @param      b   the buffer into which the data is read.
   * @return     the total number of bytes read into the buffer, or
   *             `-1` if there is no more data because the end of
   *             the stream has been reached.
   * @throws     IOException  if an I/O error occurs.
   * @see        java.io.FilterInputStream#read(byte[], int, int)
  */
  read(b: number[]): number;
}
export class InflaterOutputStream extends FilterOutputStream {
  /**
   * Creates a new output stream with a default decompressor and buffer
   * size.
   *
   * @param out output stream to write the uncompressed data to
   * @throws NullPointerException if `out` is null
  */
  constructor(out: OutputStream);
  /**
   * Creates a new output stream with the specified decompressor and a
   * default buffer size.
   *
   * @param out output stream to write the uncompressed data to
   * @param infl decompressor ("inflater") for this stream
   * @throws NullPointerException if `out` or `infl` is null
  */
  constructor(out: OutputStream, infl: Inflater);
  /**
   * Creates a new output stream with the specified decompressor and
   * buffer size.
   *
   * @param out output stream to write the uncompressed data to
   * @param infl decompressor ("inflater") for this stream
   * @param bufLen decompression buffer size
   * @throws IllegalArgumentException if `bufLen <= 0`
   * @throws NullPointerException if `out` or `infl` is null
  */
  constructor(out: OutputStream, infl: Inflater, bufLen: number);
  /**
   * Writes any remaining uncompressed data to the output stream and closes
   * the underlying output stream.
   *
   * @throws IOException if an I/O error occurs
  */
  close(): void;
  /**
   * Flushes this output stream, forcing any pending buffered output bytes to be
   * written.
   *
   * @throws IOException if an I/O error occurs or this stream is already
   * closed
  */
  flush(): void;
  /**
   * Finishes writing uncompressed data to the output stream without closing
   * the underlying stream.  Use this method when applying multiple filters in
   * succession to the same output stream.
   *
   * @throws IOException if an I/O error occurs or this stream is already
   * closed
  */
  finish(): void;
  /**
   * Writes a byte to the uncompressed output stream.
   *
   * @param b a single byte of compressed data to decompress and write to
   * the output stream
   * @throws IOException if an I/O error occurs or this stream is already
   * closed
   * @throws ZipException if a compression (ZIP) format error occurs
  */
  write(b: number): void;
  /**
   * Writes an array of bytes to the uncompressed output stream.
   *
   * @param b buffer containing compressed data to decompress and write to
   * the output stream
   * @param off starting offset of the compressed data within `b`
   * @param len number of bytes to decompress from `b`
   * @throws IndexOutOfBoundsException if `off < 0`, or if
   * `len < 0`, or if `len > b.length - off`
   * @throws IOException if an I/O error occurs or this stream is already
   * closed
   * @throws NullPointerException if `b` is null
   * @throws ZipException if a compression (ZIP) format error occurs
  */
  write(b: number[], off: number, len: number): void;
  /**
   * Writes `b.length` bytes to this output stream.
   * 
   * The `write` method of `FilterOutputStream`
   * calls its `write` method of three arguments with the
   * arguments `b`, `0`, and
   * `b.length`.
   * 
   * Note that this method does not call the one-argument
   * `write` method of its underlying output stream with
   * the single argument `b`.
   *
   * @param      b   the data to be written.
   * @throws     IOException  if an I/O error occurs.
   * @see        java.io.FilterOutputStream#write(byte[], int, int)
  */
  write(b: number[]): void;
}
/**
 * An output stream that also maintains a checksum of the data being
 * written. The checksum can then be used to verify the integrity of
 * the output data.
 *
 * @see         Checksum
 * @author      David Connelly
 * @since 1.1
*/
export class CheckedOutputStream extends FilterOutputStream {
  /**
   * Creates an output stream with the specified Checksum.
   * @param out the output stream
   * @param cksum the checksum
  */
  constructor(out: OutputStream, cksum: Checksum);
  /**
   * Writes a byte. Will block until the byte is actually written.
   * @param b the byte to be written
   * @throws    IOException if an I/O error has occurred
  */
  write(b: number): void;
  /**
   * Writes an array of bytes. Will block until the bytes are
   * actually written.
   * @param b the data to be written
   * @param off the start offset of the data
   * @param len the number of bytes to be written
   * @throws    IOException if an I/O error has occurred
  */
  write(b: number[], off: number, len: number): void;
  /**
   * Returns the Checksum for this output stream.
   * @return the Checksum
  */
  getChecksum(): Checksum;
  /**
   * Writes `b.length` bytes to this output stream.
   * 
   * The `write` method of `FilterOutputStream`
   * calls its `write` method of three arguments with the
   * arguments `b`, `0`, and
   * `b.length`.
   * 
   * Note that this method does not call the one-argument
   * `write` method of its underlying output stream with
   * the single argument `b`.
   *
   * @param      b   the data to be written.
   * @throws     IOException  if an I/O error occurs.
   * @see        java.io.FilterOutputStream#write(byte[], int, int)
  */
  write(b: number[]): void;
}
/**
 * This class implements a stream filter for reading compressed data in
 * the GZIP file format.
 *
 * @see         InflaterInputStream
 * @author      David Connelly
 * @since 1.1
 *
*/
export class GZIPInputStream extends InflaterInputStream {
  /**
   * Creates a new input stream with the specified buffer size.
   * @param in the input stream
   * @param size the input buffer size
   *
   * @throws    ZipException if a GZIP format error has occurred or the
   *                         compression method used is unsupported
   * @throws    IOException if an I/O error has occurred
   * @throws    IllegalArgumentException if `size <= 0`
  */
  constructor(in_: InputStream, size: number);
  /**
   * Creates a new input stream with a default buffer size.
   * @param in the input stream
   *
   * @throws    ZipException if a GZIP format error has occurred or the
   *                         compression method used is unsupported
   * @throws    IOException if an I/O error has occurred
  */
  constructor(in_: InputStream);
  /**
   * Reads uncompressed data into an array of bytes. If `len` is not
   * zero, the method will block until some input can be decompressed; otherwise,
   * no bytes are read and `0` is returned.
   * @param buf the buffer into which the data is read
   * @param off the start offset in the destination array `b`
   * @param len the maximum number of bytes read
   * @return  the actual number of bytes read, or -1 if the end of the
   *          compressed input stream is reached
   *
   * @throws     NullPointerException If `buf` is `null`.
   * @throws     IndexOutOfBoundsException If `off` is negative,
   * `len` is negative, or `len` is greater than
   * `buf.length - off`
   * @throws    ZipException if the compressed input data is corrupt.
   * @throws    IOException if an I/O error has occurred.
   *
  */
  read(buf: number[], off: number, len: number): number;
  /**
   * Closes this input stream and releases any system resources associated
   * with the stream.
   * @throws    IOException if an I/O error has occurred
  */
  close(): void;
  /**
   * GZIP header magic number.
  */
  static readonly GZIP_MAGIC: number;
  /**
   * Reads a byte of uncompressed data. This method will block until
   * enough input is available for decompression.
   * @return the byte read, or -1 if end of compressed input is reached
   * @throws    IOException if an I/O error has occurred
  */
  read(): number;
  /**
   * Reads up to `b.length` bytes of data from this
   * input stream into an array of bytes. This method blocks until some
   * input is available.
   * 
   * This method simply performs the call
   * `read(b, 0, b.length)` and returns
   * the  result. It is important that it does
   * not do `in.read(b)` instead;
   * certain subclasses of  `FilterInputStream`
   * depend on the implementation strategy actually
   * used.
   *
   * @param      b   the buffer into which the data is read.
   * @return     the total number of bytes read into the buffer, or
   *             `-1` if there is no more data because the end of
   *             the stream has been reached.
   * @throws     IOException  if an I/O error occurs.
   * @see        java.io.FilterInputStream#read(byte[], int, int)
  */
  read(b: number[]): number;
}
/**
 * A class that can be used to compute the CRC-32C of a data stream.
 *
 * 
 * CRC-32C is defined in RFC
 * 3720: Internet Small Computer Systems Interface (iSCSI).
 * 
 *
 * 
 * Passing a `null` argument to a method in this class will cause a
 * {@link NullPointerException} to be thrown.
 * 
 *
 * @since 9
*/
export class CRC32C extends Checksum {
  /**
   * Creates a new CRC32C object.
  */
  constructor();
  /**
   * Updates the CRC-32C checksum with the specified byte (the low eight bits
   * of the argument b).
  */
  update(b: number): void;
  /**
   * Updates the CRC-32C checksum with the specified array of bytes.
   *
   * @throws ArrayIndexOutOfBoundsException
   *         if `off` is negative, or `len` is negative, or
   *         `off+len` is negative or greater than the length of
   *         the array `b`.
  */
  update(b: number[], off: number, len: number): void;
  /**
   * Updates the CRC-32C checksum with the bytes from the specified buffer.
   *
   * The checksum is updated with the remaining bytes in the buffer, starting
   * at the buffer's position. Upon return, the buffer's position will be
   * updated to its limit; its limit will not have been changed.
  */
  update(buffer: ByteBuffer): void;
  /**
   * Resets CRC-32C to initial value.
  */
  reset(): void;
  /**
   * Returns CRC-32C value.
  */
  getValue(): number;
  /**
   * Updates the current checksum with the specified array of bytes.
   *
   * @implSpec This default implementation is equal to calling
   * `update(b, 0, b.length)`.
   *
   * @param b the array of bytes to update the checksum with
   *
   * @throws NullPointerException
   *         if `b` is `null`
   *
   * @since 9
  */
  update(b: number[]): void;
}
/**
 * This class implements an output stream filter for compressing data in
 * the "deflate" compression format. It is also used as the basis for other
 * types of compression filters, such as GZIPOutputStream.
 *
 * @see         Deflater
 * @author      David Connelly
 * @since 1.1
*/
export class DeflaterOutputStream extends FilterOutputStream {
  /**
   * Creates a new output stream with the specified compressor,
   * buffer size and flush mode.
   *
   * @param out the output stream
   * @param def the compressor ("deflater")
   * @param size the output buffer size
   * @param syncFlush
   *        if `true` the {@link #flush()} method of this
   *        instance flushes the compressor with flush mode
   *        {@link Deflater#SYNC_FLUSH} before flushing the output
   *        stream, otherwise only flushes the output stream
   *
   * @throws IllegalArgumentException if `size <= 0`
   *
   * @since 1.7
  */
  constructor(out: OutputStream, def: Deflater, size: number, syncFlush: boolean);
  /**
   * Creates a new output stream with the specified compressor and
   * buffer size.
   *
   * The new output stream instance is created as if by invoking
   * the 4-argument constructor DeflaterOutputStream(out, def, size, false).
   *
   * @param out the output stream
   * @param def the compressor ("deflater")
   * @param size the output buffer size
   * @throws    IllegalArgumentException if `size <= 0`
  */
  constructor(out: OutputStream, def: Deflater, size: number);
  /**
   * Creates a new output stream with the specified compressor, flush
   * mode and a default buffer size.
   *
   * @param out the output stream
   * @param def the compressor ("deflater")
   * @param syncFlush
   *        if `true` the {@link #flush()} method of this
   *        instance flushes the compressor with flush mode
   *        {@link Deflater#SYNC_FLUSH} before flushing the output
   *        stream, otherwise only flushes the output stream
   *
   * @since 1.7
  */
  constructor(out: OutputStream, def: Deflater, syncFlush: boolean);
  /**
   * Creates a new output stream with the specified compressor and
   * a default buffer size.
   *
   * The new output stream instance is created as if by invoking
   * the 3-argument constructor DeflaterOutputStream(out, def, false).
   *
   * @param out the output stream
   * @param def the compressor ("deflater")
  */
  constructor(out: OutputStream, def: Deflater);
  /**
   * Creates a new output stream with a default compressor, a default
   * buffer size and the specified flush mode.
   *
   * @param out the output stream
   * @param syncFlush
   *        if `true` the {@link #flush()} method of this
   *        instance flushes the compressor with flush mode
   *        {@link Deflater#SYNC_FLUSH} before flushing the output
   *        stream, otherwise only flushes the output stream
   *
   * @since 1.7
  */
  constructor(out: OutputStream, syncFlush: boolean);
  /**
   * Creates a new output stream with a default compressor and buffer size.
   *
   * The new output stream instance is created as if by invoking
   * the 2-argument constructor DeflaterOutputStream(out, false).
   *
   * @param out the output stream
  */
  constructor(out: OutputStream);
  /**
   * Writes a byte to the compressed output stream. This method will
   * block until the byte can be written.
   * @param b the byte to be written
   * @throws    IOException if an I/O error has occurred
  */
  write(b: number): void;
  /**
   * Writes an array of bytes to the compressed output stream. This
   * method will block until all the bytes are written.
   * @param b the data to be written
   * @param off the start offset of the data
   * @param len the length of the data
   * @throws    IOException if an I/O error has occurred
  */
  write(b: number[], off: number, len: number): void;
  /**
   * Finishes writing compressed data to the output stream without closing
   * the underlying stream. Use this method when applying multiple filters
   * in succession to the same output stream.
   * @throws    IOException if an I/O error has occurred
  */
  finish(): void;
  /**
   * Writes remaining compressed data to the output stream and closes the
   * underlying stream.
   * @throws    IOException if an I/O error has occurred
  */
  close(): void;
  /**
   * Flushes the compressed output stream.
   *
   * If {@link #DeflaterOutputStream(OutputStream, Deflater, int, boolean)
   * syncFlush} is `true` when this compressed output stream is
   * constructed, this method first flushes the underlying `compressor`
   * with the flush mode {@link Deflater#SYNC_FLUSH} to force
   * all pending data to be flushed out to the output stream and then
   * flushes the output stream. Otherwise this method only flushes the
   * output stream without flushing the `compressor`.
   *
   * @throws IOException if an I/O error has occurred
   *
   * @since 1.7
  */
  flush(): void;
  /**
   * Writes `b.length` bytes to this output stream.
   * 
   * The `write` method of `FilterOutputStream`
   * calls its `write` method of three arguments with the
   * arguments `b`, `0`, and
   * `b.length`.
   * 
   * Note that this method does not call the one-argument
   * `write` method of its underlying output stream with
   * the single argument `b`.
   *
   * @param      b   the data to be written.
   * @throws     IOException  if an I/O error occurs.
   * @see        java.io.FilterOutputStream#write(byte[], int, int)
  */
  write(b: number[]): void;
}
export class Inflater {
  /**
   * Creates a new decompressor. If the parameter 'nowrap' is true then
   * the ZLIB header and checksum fields will not be used. This provides
   * compatibility with the compression format used by both GZIP and PKZIP.
   * 
   * Note: When using the 'nowrap' option it is also necessary to provide
   * an extra "dummy" byte as input. This is required by the ZLIB native
   * library in order to support certain optimizations.
   *
   * @param nowrap if true then support GZIP compatible compression
  */
  constructor(nowrap: boolean);
  /**
   * Creates a new decompressor.
  */
  constructor();
  /**
   * Sets input data for decompression.
   * 
   * One of the `setInput()` methods should be called whenever
   * `needsInput()` returns true indicating that more input data
   * is required.
   *
   * @param input the input data bytes
   * @param off the start offset of the input data
   * @param len the length of the input data
   * @see Inflater#needsInput
  */
  setInput(input: number[], off: number, len: number): void;
  /**
   * Sets input data for decompression.
   * 
   * One of the `setInput()` methods should be called whenever
   * `needsInput()` returns true indicating that more input data
   * is required.
   *
   * @param input the input data bytes
   * @see Inflater#needsInput
  */
  setInput(input: number[]): void;
  /**
   * Sets input data for decompression.
   * 
   * One of the `setInput()` methods should be called whenever
   * `needsInput()` returns true indicating that more input data
   * is required.
   * 
   * The given buffer's position will be advanced as inflate
   * operations are performed, up to the buffer's limit.
   * The input buffer may be modified (refilled) between inflate
   * operations; doing so is equivalent to creating a new buffer
   * and setting it with this method.
   * 
   * Modifying the input buffer's contents, position, or limit
   * concurrently with an inflate operation will result in
   * undefined behavior, which may include incorrect operation
   * results or operation failure.
   *
   * @param input the input data bytes
   * @see Inflater#needsInput
   * @since 11
  */
  setInput(input: ByteBuffer): void;
  /**
   * Sets the preset dictionary to the given array of bytes. Should be
   * called when inflate() returns 0 and needsDictionary() returns true
   * indicating that a preset dictionary is required. The method getAdler()
   * can be used to get the Adler-32 value of the dictionary needed.
   * @param dictionary the dictionary data bytes
   * @param off the start offset of the data
   * @param len the length of the data
   * @see Inflater#needsDictionary
   * @see Inflater#getAdler
  */
  setDictionary(dictionary: number[], off: number, len: number): void;
  /**
   * Sets the preset dictionary to the given array of bytes. Should be
   * called when inflate() returns 0 and needsDictionary() returns true
   * indicating that a preset dictionary is required. The method getAdler()
   * can be used to get the Adler-32 value of the dictionary needed.
   * @param dictionary the dictionary data bytes
   * @see Inflater#needsDictionary
   * @see Inflater#getAdler
  */
  setDictionary(dictionary: number[]): void;
  /**
   * Sets the preset dictionary to the bytes in the given buffer. Should be
   * called when inflate() returns 0 and needsDictionary() returns true
   * indicating that a preset dictionary is required. The method getAdler()
   * can be used to get the Adler-32 value of the dictionary needed.
   * 
   * The bytes in given byte buffer will be fully consumed by this method.  On
   * return, its position will equal its limit.
   *
   * @param dictionary the dictionary data bytes
   * @see Inflater#needsDictionary
   * @see Inflater#getAdler
   * @since 11
  */
  setDictionary(dictionary: ByteBuffer): void;
  /**
   * Returns the total number of bytes remaining in the input buffer.
   * This can be used to find out what bytes still remain in the input
   * buffer after decompression has finished.
   * @return the total number of bytes remaining in the input buffer
  */
  getRemaining(): number;
  /**
   * Returns true if no data remains in the input buffer. This can
   * be used to determine if one of the `setInput()` methods should be
   * called in order to provide more input.
   *
   * @return true if no data remains in the input buffer
  */
  needsInput(): boolean;
  /**
   * Returns true if a preset dictionary is needed for decompression.
   * @return true if a preset dictionary is needed for decompression
   * @see Inflater#setDictionary
  */
  needsDictionary(): boolean;
  /**
   * Returns true if the end of the compressed data stream has been
   * reached.
   * @return true if the end of the compressed data stream has been
   * reached
  */
  finished(): boolean;
  /**
   * Uncompresses bytes into specified buffer. Returns actual number
   * of bytes uncompressed. A return value of 0 indicates that
   * needsInput() or needsDictionary() should be called in order to
   * determine if more input data or a preset dictionary is required.
   * In the latter case, getAdler() can be used to get the Adler-32
   * value of the dictionary required.
   * 
   * If the {@link #setInput(ByteBuffer)} method was called to provide a buffer
   * for input, the input buffer's position will be advanced by the number of bytes
   * consumed by this operation, even in the event that a {@link DataFormatException}
   * is thrown.
   * 
   * The {@linkplain #getRemaining() remaining byte count} will be reduced by
   * the number of consumed input bytes.  If the {@link #setInput(ByteBuffer)}
   * method was called to provide a buffer for input, the input buffer's position
   * will be advanced the number of consumed bytes.
   * 
   * These byte totals, as well as
   * the {@linkplain #getBytesRead() total bytes read}
   * and the {@linkplain #getBytesWritten() total bytes written}
   * values, will be updated even in the event that a {@link DataFormatException}
   * is thrown to reflect the amount of data consumed and produced before the
   * exception occurred.
   *
   * @param output the buffer for the uncompressed data
   * @param off the start offset of the data
   * @param len the maximum number of uncompressed bytes
   * @return the actual number of uncompressed bytes
   * @throws DataFormatException if the compressed data format is invalid
   * @see Inflater#needsInput
   * @see Inflater#needsDictionary
  */
  inflate(output: number[], off: number, len: number): number;
  /**
   * Uncompresses bytes into specified buffer. Returns actual number
   * of bytes uncompressed. A return value of 0 indicates that
   * needsInput() or needsDictionary() should be called in order to
   * determine if more input data or a preset dictionary is required.
   * In the latter case, getAdler() can be used to get the Adler-32
   * value of the dictionary required.
   * 
   * The {@linkplain #getRemaining() remaining byte count} will be reduced by
   * the number of consumed input bytes.  If the {@link #setInput(ByteBuffer)}
   * method was called to provide a buffer for input, the input buffer's position
   * will be advanced the number of consumed bytes.
   * 
   * These byte totals, as well as
   * the {@linkplain #getBytesRead() total bytes read}
   * and the {@linkplain #getBytesWritten() total bytes written}
   * values, will be updated even in the event that a {@link DataFormatException}
   * is thrown to reflect the amount of data consumed and produced before the
   * exception occurred.
   *
   * @param output the buffer for the uncompressed data
   * @return the actual number of uncompressed bytes
   * @throws DataFormatException if the compressed data format is invalid
   * @see Inflater#needsInput
   * @see Inflater#needsDictionary
  */
  inflate(output: number[]): number;
  /**
   * Uncompresses bytes into specified buffer. Returns actual number
   * of bytes uncompressed. A return value of 0 indicates that
   * needsInput() or needsDictionary() should be called in order to
   * determine if more input data or a preset dictionary is required.
   * In the latter case, getAdler() can be used to get the Adler-32
   * value of the dictionary required.
   * 
   * On success, the position of the given `output` byte buffer will be
   * advanced by as many bytes as were produced by the operation, which is equal
   * to the number returned by this method.  Note that the position of the
   * `output` buffer will be advanced even in the event that a
   * {@link DataFormatException} is thrown.
   * 
   * The {@linkplain #getRemaining() remaining byte count} will be reduced by
   * the number of consumed input bytes.  If the {@link #setInput(ByteBuffer)}
   * method was called to provide a buffer for input, the input buffer's position
   * will be advanced the number of consumed bytes.
   * 
   * These byte totals, as well as
   * the {@linkplain #getBytesRead() total bytes read}
   * and the {@linkplain #getBytesWritten() total bytes written}
   * values, will be updated even in the event that a {@link DataFormatException}
   * is thrown to reflect the amount of data consumed and produced before the
   * exception occurred.
   *
   * @param output the buffer for the uncompressed data
   * @return the actual number of uncompressed bytes
   * @throws DataFormatException if the compressed data format is invalid
   * @throws ReadOnlyBufferException if the given output buffer is read-only
   * @see Inflater#needsInput
   * @see Inflater#needsDictionary
   * @since 11
  */
  inflate(output: ByteBuffer): number;
  /**
   * Returns the ADLER-32 value of the uncompressed data.
   * @return the ADLER-32 value of the uncompressed data
  */
  getAdler(): number;
  /**
   * Returns the total number of compressed bytes input so far.
   *
   * Since the number of bytes may be greater than
   * Integer.MAX_VALUE, the {@link #getBytesRead()} method is now
   * the preferred means of obtaining this information.
   *
   * @return the total number of compressed bytes input so far
  */
  getTotalIn(): number;
  /**
   * Returns the total number of compressed bytes input so far.
   *
   * @return the total (non-negative) number of compressed bytes input so far
   * @since 1.5
  */
  getBytesRead(): number;
  /**
   * Returns the total number of uncompressed bytes output so far.
   *
   * Since the number of bytes may be greater than
   * Integer.MAX_VALUE, the {@link #getBytesWritten()} method is now
   * the preferred means of obtaining this information.
   *
   * @return the total number of uncompressed bytes output so far
  */
  getTotalOut(): number;
  /**
   * Returns the total number of uncompressed bytes output so far.
   *
   * @return the total (non-negative) number of uncompressed bytes output so far
   * @since 1.5
  */
  getBytesWritten(): number;
  /**
   * Resets inflater so that a new set of input data can be processed.
  */
  reset(): void;
  /**
   * Closes the decompressor and discards any unprocessed input.
   *
   * This method should be called when the decompressor is no longer
   * being used. Once this method is called, the behavior of the
   * Inflater object is undefined.
  */
  end(): void;
}
/**
 * This class implements a stream filter for uncompressing data in the
 * "deflate" compression format. It is also used as the basis for other
 * decompression filters, such as GZIPInputStream.
 *
 * @see         Inflater
 * @author      David Connelly
 * @since 1.1
*/
export class InflaterInputStream extends FilterInputStream {
  /**
   * Creates a new input stream with the specified decompressor and
   * buffer size.
   * @param in the input stream
   * @param inf the decompressor ("inflater")
   * @param size the input buffer size
   * @throws    IllegalArgumentException if `size <= 0`
  */
  constructor(in_: InputStream, inf: Inflater, size: number);
  /**
   * Creates a new input stream with the specified decompressor and a
   * default buffer size.
   * @param in the input stream
   * @param inf the decompressor ("inflater")
  */
  constructor(in_: InputStream, inf: Inflater);
  /**
   * Creates a new input stream with a default decompressor and buffer size.
   * @param in the input stream
  */
  constructor(in_: InputStream);
  /**
   * Reads a byte of uncompressed data. This method will block until
   * enough input is available for decompression.
   * @return the byte read, or -1 if end of compressed input is reached
   * @throws    IOException if an I/O error has occurred
  */
  read(): number;
  /**
   * Reads uncompressed data into an array of bytes. If `len` is not
   * zero, the method will block until some input can be decompressed; otherwise,
   * no bytes are read and `0` is returned.
   * @param b the buffer into which the data is read
   * @param off the start offset in the destination array `b`
   * @param len the maximum number of bytes read
   * @return the actual number of bytes read, or -1 if the end of the
   *         compressed input is reached or a preset dictionary is needed
   * @throws     NullPointerException If `b` is `null`.
   * @throws     IndexOutOfBoundsException If `off` is negative,
   * `len` is negative, or `len` is greater than
   * `b.length - off`
   * @throws    ZipException if a ZIP format error has occurred
   * @throws    IOException if an I/O error has occurred
  */
  read(b: number[], off: number, len: number): number;
  /**
   * Returns 0 after EOF has been reached, otherwise always return 1.
   * 
   * Programs should not count on this method to return the actual number
   * of bytes that could be read without blocking.
   *
   * @return     1 before EOF and 0 after EOF.
   * @throws     IOException  if an I/O error occurs.
   *
  */
  available(): number;
  /**
   * Skips specified number of bytes of uncompressed data.
   * @param n the number of bytes to skip
   * @return the actual number of bytes skipped.
   * @throws    IOException if an I/O error has occurred
   * @throws    IllegalArgumentException if `n < 0`
  */
  skip(n: number): number;
  /**
   * Closes this input stream and releases any system resources associated
   * with the stream.
   * @throws    IOException if an I/O error has occurred
  */
  close(): void;
  /**
   * Tests if this input stream supports the `mark` and
   * `reset` methods. The `markSupported`
   * method of `InflaterInputStream` returns
   * `false`.
   *
   * @return  a `boolean` indicating if this stream type supports
   *          the `mark` and `reset` methods.
   * @see     java.io.InputStream#mark(int)
   * @see     java.io.InputStream#reset()
  */
  markSupported(): boolean;
  /**
   * Marks the current position in this input stream.
   *
   *  The `mark` method of `InflaterInputStream`
   * does nothing.
   *
   * @param   readlimit   the maximum limit of bytes that can be read before
   *                      the mark position becomes invalid.
   * @see     java.io.InputStream#reset()
  */
  mark(readlimit: number): void;
  /**
   * Repositions this stream to the position at the time the
   * `mark` method was last called on this input stream.
   *
   *  The method `reset` for class
   * `InflaterInputStream` does nothing except throw an
   * `IOException`.
   *
   * @throws     IOException  if this method is invoked.
   * @see     java.io.InputStream#mark(int)
   * @see     java.io.IOException
  */
  reset(): void;
  /**
   * Reads up to `b.length` bytes of data from this
   * input stream into an array of bytes. This method blocks until some
   * input is available.
   * 
   * This method simply performs the call
   * `read(b, 0, b.length)` and returns
   * the  result. It is important that it does
   * not do `in.read(b)` instead;
   * certain subclasses of  `FilterInputStream`
   * depend on the implementation strategy actually
   * used.
   *
   * @param      b   the buffer into which the data is read.
   * @return     the total number of bytes read into the buffer, or
   *             `-1` if there is no more data because the end of
   *             the stream has been reached.
   * @throws     IOException  if an I/O error occurs.
   * @see        java.io.FilterInputStream#read(byte[], int, int)
  */
  read(b: number[]): number;
}
/**
 * This class implements an output stream filter for writing files in the
 * ZIP file format. Includes support for both compressed and uncompressed
 * entries.
 *
 * @author      David Connelly
 * @since 1.1
*/
export class ZipOutputStream extends DeflaterOutputStream {
  /**
   * Compression method for uncompressed (STORED) entries.
  */
  static readonly STORED: number;
  /**
   * Compression method for compressed (DEFLATED) entries.
  */
  static readonly DEFLATED: number;
  /**
   * Creates a new ZIP output stream.
   *
   * The UTF-8 {@link java.nio.charset.Charset charset} is used
   * to encode the entry names and comments.
   *
   * @param out the actual output stream
  */
  constructor(out: OutputStream);
  /**
   * Creates a new ZIP output stream.
   *
   * @param out the actual output stream
   *
   * @param charset the {@linkplain java.nio.charset.Charset charset}
   *                to be used to encode the entry names and comments
   *
   * @since 1.7
  */
  constructor(out: OutputStream, charset: Charset);
  /**
   * Sets the ZIP file comment.
   * @param     comment the comment string
   * @throws    IllegalArgumentException if the length of the specified
   *            ZIP file comment is greater than 0xFFFF bytes
  */
  setComment(comment: string);
  /**
   * Sets the default compression method for subsequent entries. This
   * default will be used whenever the compression method is not specified
   * for an individual ZIP file entry, and is initially set to DEFLATED.
   * @param     method the default compression method
   * @throws    IllegalArgumentException if the specified compression method
   *            is invalid
  */
  setMethod(method: number);
  /**
   * Sets the compression level for subsequent entries which are DEFLATED.
   * The default setting is DEFAULT_COMPRESSION.
   * @param     level the compression level (0-9)
   * @throws    IllegalArgumentException if the compression level is invalid
  */
  setLevel(level: number);
  /**
   * Begins writing a new ZIP file entry and positions the stream to the
   * start of the entry data. Closes the current entry if still active.
   * 
   * The default compression method will be used if no compression method
   * was specified for the entry. When writing a compressed (DEFLATED)
   * entry, and the compressed size has not been explicitly set with the
   * {@link ZipEntry#setCompressedSize(long)} method, then the compressed
   * size will be set to the actual compressed size after deflation.
   * 
   * The current time will be used if the entry has no set modification time.
   *
   * @param     e the ZIP entry to be written
   * @throws    ZipException if a ZIP format error has occurred
   * @throws    IOException if an I/O error has occurred
  */
  putNextEntry(e: ZipEntry): void;
  /**
   * Closes the current ZIP entry and positions the stream for writing
   * the next entry.
   * @throws    ZipException if a ZIP format error has occurred
   * @throws    IOException if an I/O error has occurred
  */
  closeEntry(): void;
  /**
   * Writes an array of bytes to the current ZIP entry data. This method
   * will block until all the bytes are written.
   * @param     b the data to be written
   * @param     off the start offset in the data
   * @param     len the number of bytes that are written
   * @throws    ZipException if a ZIP file error has occurred
   * @throws    IOException if an I/O error has occurred
  */
  write(b: number[], off: number, len: number): void;
  /**
   * Finishes writing the contents of the ZIP output stream without closing
   * the underlying stream. Use this method when applying multiple filters
   * in succession to the same output stream.
   * @throws    ZipException if a ZIP file error has occurred
   * @throws    IOException if an I/O exception has occurred
  */
  finish(): void;
  /**
   * Closes the ZIP output stream as well as the stream being filtered.
   * @throws    ZipException if a ZIP file error has occurred
   * @throws    IOException if an I/O error has occurred
  */
  close(): void;
  /**
   * Writes a byte to the compressed output stream. This method will
   * block until the byte can be written.
   * @param b the byte to be written
   * @throws    IOException if an I/O error has occurred
  */
  write(b: number): void;
  /**
   * Writes `b.length` bytes to this output stream.
   * 
   * The `write` method of `FilterOutputStream`
   * calls its `write` method of three arguments with the
   * arguments `b`, `0`, and
   * `b.length`.
   * 
   * Note that this method does not call the one-argument
   * `write` method of its underlying output stream with
   * the single argument `b`.
   *
   * @param      b   the data to be written.
   * @throws     IOException  if an I/O error occurs.
   * @see        java.io.FilterOutputStream#write(byte[], int, int)
  */
  write(b: number[]): void;
}
/**
 * A class that can be used to compute the CRC-32 of a data stream.
 *
 *  Passing a `null` argument to a method in this class will cause
 * a {@link NullPointerException} to be thrown.
 *
 * @author      David Connelly
 * @since 1.1
*/
export class CRC32 extends Checksum {
  /**
   * Creates a new CRC32 object.
  */
  constructor();
  /**
   * Updates the CRC-32 checksum with the specified byte (the low
   * eight bits of the argument b).
  */
  update(b: number): void;
  /**
   * Updates the CRC-32 checksum with the specified array of bytes.
   *
   * @throws ArrayIndexOutOfBoundsException
   *         if `off` is negative, or `len` is negative, or
   *         `off+len` is negative or greater than the length of
   *         the array `b`.
  */
  update(b: number[], off: number, len: number): void;
  /**
   * Updates the CRC-32 checksum with the bytes from the specified buffer.
   *
   * The checksum is updated with the remaining bytes in the buffer, starting
   * at the buffer's position. Upon return, the buffer's position will be
   * updated to its limit; its limit will not have been changed.
   *
   * @since 1.8
  */
  update(buffer: ByteBuffer): void;
  /**
   * Resets CRC-32 to initial value.
  */
  reset(): void;
  /**
   * Returns CRC-32 value.
  */
  getValue(): number;
  /**
   * Updates the current checksum with the specified array of bytes.
   *
   * @implSpec This default implementation is equal to calling
   * `update(b, 0, b.length)`.
   *
   * @param b the array of bytes to update the checksum with
   *
   * @throws NullPointerException
   *         if `b` is `null`
   *
   * @since 9
  */
  update(b: number[]): void;
}
/**
 * An input stream that also maintains a checksum of the data being read.
 * The checksum can then be used to verify the integrity of the input data.
 *
 * @see         Checksum
 * @author      David Connelly
 * @since 1.1
*/
export class CheckedInputStream extends FilterInputStream {
  /**
   * Creates an input stream using the specified Checksum.
   * @param in the input stream
   * @param cksum the Checksum
  */
  constructor(in_: InputStream, cksum: Checksum);
  /**
   * Reads a byte. Will block if no input is available.
   * @return the byte read, or -1 if the end of the stream is reached.
   * @throws    IOException if an I/O error has occurred
  */
  read(): number;
  /**
   * Reads into an array of bytes. If `len` is not zero, the method
   * blocks until some input is available; otherwise, no
   * bytes are read and `0` is returned.
   * @param buf the buffer into which the data is read
   * @param off the start offset in the destination array `b`
   * @param len the maximum number of bytes read
   * @return    the actual number of bytes read, or -1 if the end
   *            of the stream is reached.
   * @throws     NullPointerException If `buf` is `null`.
   * @throws     IndexOutOfBoundsException If `off` is negative,
   * `len` is negative, or `len` is greater than
   * `buf.length - off`
   * @throws    IOException if an I/O error has occurred
  */
  read(buf: number[], off: number, len: number): number;
  /**
   * Skips specified number of bytes of input.
   * @param n the number of bytes to skip
   * @return the actual number of bytes skipped
   * @throws    IOException if an I/O error has occurred
  */
  skip(n: number): number;
  /**
   * Returns the Checksum for this input stream.
   * @return the Checksum value
  */
  getChecksum(): Checksum;
  /**
   * Reads up to `b.length` bytes of data from this
   * input stream into an array of bytes. This method blocks until some
   * input is available.
   * 
   * This method simply performs the call
   * `read(b, 0, b.length)` and returns
   * the  result. It is important that it does
   * not do `in.read(b)` instead;
   * certain subclasses of  `FilterInputStream`
   * depend on the implementation strategy actually
   * used.
   *
   * @param      b   the buffer into which the data is read.
   * @return     the total number of bytes read into the buffer, or
   *             `-1` if there is no more data because the end of
   *             the stream has been reached.
   * @throws     IOException  if an I/O error occurs.
   * @see        java.io.FilterInputStream#read(byte[], int, int)
  */
  read(b: number[]): number;
}
/**
 * This class is used to represent a ZIP file entry.
 *
 * @author      David Connelly
 * @since 1.1
*/
export class ZipEntry extends Cloneable {
  /**
   * Compression method for uncompressed entries.
  */
  static readonly STORED: number;
  /**
   * Compression method for compressed (deflated) entries.
  */
  static readonly DEFLATED: number;
  /**
   * Creates a new zip entry with the specified name.
   *
   * @param  name
   *         The entry name
   *
   * @throws NullPointerException if the entry name is null
   * @throws IllegalArgumentException if the entry name is longer than
   *         0xFFFF bytes
  */
  constructor(name: string);
  /**
   * Creates a new zip entry with fields taken from the specified
   * zip entry.
   *
   * @param  e
   *         A zip Entry object
   *
   * @throws NullPointerException if the entry object is null
  */
  constructor(e: ZipEntry);
  /**
   * Returns the name of the entry.
   * @return the name of the entry
  */
  getName(): string;
  /**
   * Sets the last modification time of the entry.
   *
   *  If the entry is output to a ZIP file or ZIP file formatted
   * output stream the last modification time set by this method will
   * be stored into the `date and time fields` of the zip file
   * entry and encoded in standard `MS-DOS date and time format`.
   * The {@link java.util.TimeZone#getDefault() default TimeZone} is
   * used to convert the epoch time to the MS-DOS data and time.
   *
   * @param  time
   *         The last modification time of the entry in milliseconds
   *         since the epoch
   *
   * @see #getTime()
   * @see #getLastModifiedTime()
  */
  setTime(time: number);
  /**
   * Returns the last modification time of the entry.
   *
   *  If the entry is read from a ZIP file or ZIP file formatted
   * input stream, this is the last modification time from the `     * date and time fields` of the zip file entry. The
   * {@link java.util.TimeZone#getDefault() default TimeZone} is used
   * to convert the standard MS-DOS formatted date and time to the
   * epoch time.
   *
   * @return  The last modification time of the entry in milliseconds
   *          since the epoch, or -1 if not specified
   *
   * @see #setTime(long)
   * @see #setLastModifiedTime(FileTime)
  */
  getTime(): number;
  /**
   * Sets the last modification time of the entry in local date-time.
   *
   *  If the entry is output to a ZIP file or ZIP file formatted
   * output stream the last modification time set by this method will
   * be stored into the `date and time fields` of the zip file
   * entry and encoded in standard `MS-DOS date and time format`.
   * If the date-time set is out of the range of the standard `     * MS-DOS date and time format`, the time will also be stored into
   * zip file entry's extended timestamp fields in {@code optional
   * extra data} in UTC time. The {@link java.time.ZoneId#systemDefault()
   * system default TimeZone} is used to convert the local date-time
   * to UTC time.
   *
   *  `LocalDateTime` uses a precision of nanoseconds, whereas
   * this class uses a precision of milliseconds. The conversion will
   * truncate any excess precision information as though the amount in
   * nanoseconds was subject to integer division by one million.
   *
   * @param  time
   *         The last modification time of the entry in local date-time
   *
   * @see #getTimeLocal()
   * @since 9
  */
  setTimeLocal(timeLocal: LocalDateTime);
  /**
   * Returns the last modification time of the entry in local date-time.
   *
   *  If the entry is read from a ZIP file or ZIP file formatted
   * input stream, this is the last modification time from the zip
   * file entry's `optional extra data` if the extended timestamp
   * fields are present. Otherwise, the last modification time is read
   * from entry's standard MS-DOS formatted `date and time fields`.
   *
   *  The {@link java.time.ZoneId#systemDefault() system default TimeZone}
   * is used to convert the UTC time to local date-time.
   *
   * @return  The last modification time of the entry in local date-time
   *
   * @see #setTimeLocal(LocalDateTime)
   * @since 9
  */
  getTimeLocal(): LocalDateTime;
  /**
   * Sets the last modification time of the entry.
   *
   *  When output to a ZIP file or ZIP file formatted output stream
   * the last modification time set by this method will be stored into
   * zip file entry's `date and time fields` in {@code standard
   * MS-DOS date and time format}), and the extended timestamp fields
   * in `optional extra data` in UTC time.
   *
   * @param  time
   *         The last modification time of the entry
   * @return This zip entry
   *
   * @throws NullPointerException if the `time` is null
   *
   * @see #getLastModifiedTime()
   * @since 1.8
  */
  setLastModifiedTime(lastModifiedTime: FileTime);
  /**
   * Returns the last modification time of the entry.
   *
   *  If the entry is read from a ZIP file or ZIP file formatted
   * input stream, this is the last modification time from the zip
   * file entry's `optional extra data` if the extended timestamp
   * fields are present. Otherwise the last modification time is read
   * from the entry's `date and time fields`, the {@link
   * java.util.TimeZone#getDefault() default TimeZone} is used to convert
   * the standard MS-DOS formatted date and time to the epoch time.
   *
   * @return The last modification time of the entry, null if not specified
   *
   * @see #setLastModifiedTime(FileTime)
   * @since 1.8
  */
  getLastModifiedTime(): FileTime;
  /**
   * Sets the last access time of the entry.
   *
   *  If set, the last access time will be stored into the extended
   * timestamp fields of entry's `optional extra data`, when output
   * to a ZIP file or ZIP file formatted stream.
   *
   * @param  time
   *         The last access time of the entry
   * @return This zip entry
   *
   * @throws NullPointerException if the `time` is null
   *
   * @see #getLastAccessTime()
   * @since 1.8
  */
  setLastAccessTime(lastAccessTime: FileTime);
  /**
   * Returns the last access time of the entry.
   *
   *  The last access time is from the extended timestamp fields
   * of entry's `optional extra data` when read from a ZIP file
   * or ZIP file formatted stream.
   *
   * @return The last access time of the entry, null if not specified
   * @see #setLastAccessTime(FileTime)
   * @since 1.8
  */
  getLastAccessTime(): FileTime;
  /**
   * Sets the creation time of the entry.
   *
   *  If set, the creation time will be stored into the extended
   * timestamp fields of entry's `optional extra data`, when
   * output to a ZIP file or ZIP file formatted stream.
   *
   * @param  time
   *         The creation time of the entry
   * @return This zip entry
   *
   * @throws NullPointerException if the `time` is null
   *
   * @see #getCreationTime()
   * @since 1.8
  */
  setCreationTime(creationTime: FileTime);
  /**
   * Returns the creation time of the entry.
   *
   *  The creation time is from the extended timestamp fields of
   * entry's `optional extra data` when read from a ZIP file
   * or ZIP file formatted stream.
   *
   * @return the creation time of the entry, null if not specified
   * @see #setCreationTime(FileTime)
   * @since 1.8
  */
  getCreationTime(): FileTime;
  /**
   * Sets the uncompressed size of the entry data.
   *
   * @param size the uncompressed size in bytes
   *
   * @throws IllegalArgumentException if the specified size is less
   *         than 0, is greater than 0xFFFFFFFF when
   *         ZIP64 format is not supported,
   *         or is less than 0 when ZIP64 is supported
   * @see #getSize()
  */
  setSize(size: number);
  /**
   * Returns the uncompressed size of the entry data.
   *
   * @return the uncompressed size of the entry data, or -1 if not known
   * @see #setSize(long)
  */
  getSize(): number;
  /**
   * Returns the size of the compressed entry data.
   *
   *  In the case of a stored entry, the compressed size will be the same
   * as the uncompressed size of the entry.
   *
   * @return the size of the compressed entry data, or -1 if not known
   * @see #setCompressedSize(long)
  */
  getCompressedSize(): number;
  /**
   * Sets the size of the compressed entry data.
   *
   * @param csize the compressed size to set
   *
   * @see #getCompressedSize()
  */
  setCompressedSize(compressedSize: number);
  /**
   * Sets the CRC-32 checksum of the uncompressed entry data.
   *
   * @param crc the CRC-32 value
   *
   * @throws IllegalArgumentException if the specified CRC-32 value is
   *         less than 0 or greater than 0xFFFFFFFF
   * @see #getCrc()
  */
  setCrc(crc: number);
  /**
   * Returns the CRC-32 checksum of the uncompressed entry data.
   *
   * @return the CRC-32 checksum of the uncompressed entry data, or -1 if
   * not known
   *
   * @see #setCrc(long)
  */
  getCrc(): number;
  /**
   * Sets the compression method for the entry.
   *
   * @param method the compression method, either STORED or DEFLATED
   *
   * @throws  IllegalArgumentException if the specified compression
   *          method is invalid
   * @see #getMethod()
  */
  setMethod(method: number);
  /**
   * Returns the compression method of the entry.
   *
   * @return the compression method of the entry, or -1 if not specified
   * @see #setMethod(int)
  */
  getMethod(): number;
  /**
   * Sets the optional extra field data for the entry.
   *
   *  Invoking this method may change this entry's last modification
   * time, last access time and creation time, if the `extra` field
   * data includes the extensible timestamp fields, such as {@code NTFS tag
   * 0x0001} or `Info-ZIP Extended Timestamp`, as specified in
   * Info-ZIP
   * Application Note 970311.
   *
   * @param  extra
   *         The extra field data bytes
   *
   * @throws IllegalArgumentException if the length of the specified
   *         extra field data is greater than 0xFFFF bytes
   *
   * @see #getExtra()
  */
  setExtra(extra: number[]);
  /**
   * Returns the extra field data for the entry.
   *
   * @return the extra field data for the entry, or null if none
   *
   * @see #setExtra(byte[])
  */
  getExtra(): number[];
  /**
   * Sets the optional comment string for the entry.
   *
   * ZIP entry comments have maximum length of 0xffff. If the length of the
   * specified comment string is greater than 0xFFFF bytes after encoding, only
   * the first 0xFFFF bytes are output to the ZIP file entry.
   *
   * @param comment the comment string
   *
   * @see #getComment()
  */
  setComment(comment: string);
  /**
   * Returns the comment string for the entry.
   *
   * @return the comment string for the entry, or null if none
   *
   * @see #setComment(String)
  */
  getComment(): string;
  /**
   * Returns true if this is a directory entry. A directory entry is
   * defined to be one whose name ends with a '/'.
   * @return true if this is a directory entry
  */
  isDirectory(): boolean;
  /**
   * Returns a string representation of the ZIP entry.
  */
  toString(): string;
  /**
   * Returns the hash code value for this entry.
  */
  hashCode(): number;
  /**
   * Returns a copy of this entry.
  */
  clone(): any;
}
export class ZipException extends IOException {
  /**
   * Constructs a `ZipException` with `null`
   * as its error detail message.
  */
  constructor();
  constructor(s: string);
}
export class Deflater {
  /**
   * Compression method for the deflate algorithm (the only one currently
   * supported).
  */
  static readonly DEFLATED: number;
  /**
   * Compression level for no compression.
  */
  static readonly NO_COMPRESSION: number;
  /**
   * Compression level for fastest compression.
  */
  static readonly BEST_SPEED: number;
  /**
   * Compression level for best compression.
  */
  static readonly BEST_COMPRESSION: number;
  /**
   * Default compression level.
  */
  static readonly DEFAULT_COMPRESSION: number;
  /**
   * Compression strategy best used for data consisting mostly of small
   * values with a somewhat random distribution. Forces more Huffman coding
   * and less string matching.
  */
  static readonly FILTERED: number;
  /**
   * Compression strategy for Huffman coding only.
  */
  static readonly HUFFMAN_ONLY: number;
  /**
   * Default compression strategy.
  */
  static readonly DEFAULT_STRATEGY: number;
  /**
   * Compression flush mode used to achieve best compression result.
   *
   * @see Deflater#deflate(byte[], int, int, int)
   * @since 1.7
  */
  static readonly NO_FLUSH: number;
  /**
   * Compression flush mode used to flush out all pending output; may
   * degrade compression for some compression algorithms.
   *
   * @see Deflater#deflate(byte[], int, int, int)
   * @since 1.7
  */
  static readonly SYNC_FLUSH: number;
  /**
   * Compression flush mode used to flush out all pending output and
   * reset the deflater. Using this mode too often can seriously degrade
   * compression.
   *
   * @see Deflater#deflate(byte[], int, int, int)
   * @since 1.7
  */
  static readonly FULL_FLUSH: number;
  /**
   * Creates a new compressor using the specified compression level.
   * If 'nowrap' is true then the ZLIB header and checksum fields will
   * not be used in order to support the compression format used in
   * both GZIP and PKZIP.
   * @param level the compression level (0-9)
   * @param nowrap if true then use GZIP compatible compression
  */
  constructor(level: number, nowrap: boolean);
  /**
   * Creates a new compressor using the specified compression level.
   * Compressed data will be generated in ZLIB format.
   * @param level the compression level (0-9)
  */
  constructor(level: number);
  /**
   * Creates a new compressor with the default compression level.
   * Compressed data will be generated in ZLIB format.
  */
  constructor();
  /**
   * Sets input data for compression.
   * 
   * One of the `setInput()` methods should be called whenever
   * `needsInput()` returns true indicating that more input data
   * is required.
   * @param input the input data bytes
   * @param off the start offset of the data
   * @param len the length of the data
   * @see Deflater#needsInput
  */
  setInput(input: number[], off: number, len: number): void;
  /**
   * Sets input data for compression.
   * 
   * One of the `setInput()` methods should be called whenever
   * `needsInput()` returns true indicating that more input data
   * is required.
   * @param input the input data bytes
   * @see Deflater#needsInput
  */
  setInput(input: number[]): void;
  /**
   * Sets input data for compression.
   * 
   * One of the `setInput()` methods should be called whenever
   * `needsInput()` returns true indicating that more input data
   * is required.
   * 
   * The given buffer's position will be advanced as deflate
   * operations are performed, up to the buffer's limit.
   * The input buffer may be modified (refilled) between deflate
   * operations; doing so is equivalent to creating a new buffer
   * and setting it with this method.
   * 
   * Modifying the input buffer's contents, position, or limit
   * concurrently with an deflate operation will result in
   * undefined behavior, which may include incorrect operation
   * results or operation failure.
   *
   * @param input the input data bytes
   * @see Deflater#needsInput
   * @since 11
  */
  setInput(input: ByteBuffer): void;
  /**
   * Sets preset dictionary for compression. A preset dictionary is used
   * when the history buffer can be predetermined. When the data is later
   * uncompressed with Inflater.inflate(), Inflater.getAdler() can be called
   * in order to get the Adler-32 value of the dictionary required for
   * decompression.
   * @param dictionary the dictionary data bytes
   * @param off the start offset of the data
   * @param len the length of the data
   * @see Inflater#inflate
   * @see Inflater#getAdler
  */
  setDictionary(dictionary: number[], off: number, len: number): void;
  /**
   * Sets preset dictionary for compression. A preset dictionary is used
   * when the history buffer can be predetermined. When the data is later
   * uncompressed with Inflater.inflate(), Inflater.getAdler() can be called
   * in order to get the Adler-32 value of the dictionary required for
   * decompression.
   * @param dictionary the dictionary data bytes
   * @see Inflater#inflate
   * @see Inflater#getAdler
  */
  setDictionary(dictionary: number[]): void;
  /**
   * Sets preset dictionary for compression. A preset dictionary is used
   * when the history buffer can be predetermined. When the data is later
   * uncompressed with Inflater.inflate(), Inflater.getAdler() can be called
   * in order to get the Adler-32 value of the dictionary required for
   * decompression.
   * 
   * The bytes in given byte buffer will be fully consumed by this method.  On
   * return, its position will equal its limit.
   *
   * @param dictionary the dictionary data bytes
   * @see Inflater#inflate
   * @see Inflater#getAdler
  */
  setDictionary(dictionary: ByteBuffer): void;
  /**
   * Sets the compression strategy to the specified value.
   *
   *  If the compression strategy is changed, the next invocation
   * of `deflate` will compress the input available so far with
   * the old strategy (and may be flushed); the new strategy will take
   * effect only after that invocation.
   *
   * @param strategy the new compression strategy
   * @throws    IllegalArgumentException if the compression strategy is
   *                                     invalid
  */
  setStrategy(strategy: number);
  /**
   * Sets the compression level to the specified value.
   *
   *  If the compression level is changed, the next invocation
   * of `deflate` will compress the input available so far
   * with the old level (and may be flushed); the new level will
   * take effect only after that invocation.
   *
   * @param level the new compression level (0-9)
   * @throws    IllegalArgumentException if the compression level is invalid
  */
  setLevel(level: number);
  /**
   * Returns true if no data remains in the input buffer. This can
   * be used to determine if one of the `setInput()` methods should be
   * called in order to provide more input.
   *
   * @return true if the input data buffer is empty and setInput()
   * should be called in order to provide more input
  */
  needsInput(): boolean;
  /**
   * When called, indicates that compression should end with the current
   * contents of the input buffer.
  */
  finish(): void;
  /**
   * Returns true if the end of the compressed data output stream has
   * been reached.
   * @return true if the end of the compressed data output stream has
   * been reached
  */
  finished(): boolean;
  /**
   * Compresses the input data and fills specified buffer with compressed
   * data. Returns actual number of bytes of compressed data. A return value
   * of 0 indicates that {@link #needsInput() needsInput} should be called
   * in order to determine if more input data is required.
   *
   * This method uses {@link #NO_FLUSH} as its compression flush mode.
   * An invocation of this method of the form `deflater.deflate(b, off, len)`
   * yields the same result as the invocation of
   * `deflater.deflate(b, off, len, Deflater.NO_FLUSH)`.
   *
   * @param output the buffer for the compressed data
   * @param off the start offset of the data
   * @param len the maximum number of bytes of compressed data
   * @return the actual number of bytes of compressed data written to the
   *         output buffer
  */
  deflate(output: number[], off: number, len: number): number;
  /**
   * Compresses the input data and fills specified buffer with compressed
   * data. Returns actual number of bytes of compressed data. A return value
   * of 0 indicates that {@link #needsInput() needsInput} should be called
   * in order to determine if more input data is required.
   *
   * This method uses {@link #NO_FLUSH} as its compression flush mode.
   * An invocation of this method of the form `deflater.deflate(b)`
   * yields the same result as the invocation of
   * `deflater.deflate(b, 0, b.length, Deflater.NO_FLUSH)`.
   *
   * @param output the buffer for the compressed data
   * @return the actual number of bytes of compressed data written to the
   *         output buffer
  */
  deflate(output: number[]): number;
  /**
   * Compresses the input data and fills specified buffer with compressed
   * data. Returns actual number of bytes of compressed data. A return value
   * of 0 indicates that {@link #needsInput() needsInput} should be called
   * in order to determine if more input data is required.
   *
   * This method uses {@link #NO_FLUSH} as its compression flush mode.
   * An invocation of this method of the form `deflater.deflate(output)`
   * yields the same result as the invocation of
   * `deflater.deflate(output, Deflater.NO_FLUSH)`.
   *
   * @param output the buffer for the compressed data
   * @return the actual number of bytes of compressed data written to the
   *         output buffer
   * @since 11
  */
  deflate(output: ByteBuffer): number;
  /**
   * Compresses the input data and fills the specified buffer with compressed
   * data. Returns actual number of bytes of data compressed.
   *
   * Compression flush mode is one of the following three modes:
   *
   * 
   * {@link #NO_FLUSH}: allows the deflater to decide how much data
   * to accumulate, before producing output, in order to achieve the best
   * compression (should be used in normal use scenario). A return value
   * of 0 in this flush mode indicates that {@link #needsInput()} should
   * be called in order to determine if more input data is required.
   *
   * {@link #SYNC_FLUSH}: all pending output in the deflater is flushed,
   * to the specified output buffer, so that an inflater that works on
   * compressed data can get all input data available so far (In particular
   * the {@link #needsInput()} returns `true` after this invocation
   * if enough output space is provided). Flushing with {@link #SYNC_FLUSH}
   * may degrade compression for some compression algorithms and so it
   * should be used only when necessary.
   *
   * {@link #FULL_FLUSH}: all pending output is flushed out as with
   * {@link #SYNC_FLUSH}. The compression state is reset so that the inflater
   * that works on the compressed output data can restart from this point
   * if previous compressed data has been damaged or if random access is
   * desired. Using {@link #FULL_FLUSH} too often can seriously degrade
   * compression.
   * 
   *
   * In the case of {@link #FULL_FLUSH} or {@link #SYNC_FLUSH}, if
   * the return value is `len`, the space available in output
   * buffer `b`, this method should be invoked again with the same
   * `flush` parameter and more output space. Make sure that
   * `len` is greater than 6 to avoid flush marker (5 bytes) being
   * repeatedly output to the output buffer every time this method is
   * invoked.
   *
   * If the {@link #setInput(ByteBuffer)} method was called to provide a buffer
   * for input, the input buffer's position will be advanced by the number of bytes
   * consumed by this operation.
   *
   * @param output the buffer for the compressed data
   * @param off the start offset of the data
   * @param len the maximum number of bytes of compressed data
   * @param flush the compression flush mode
   * @return the actual number of bytes of compressed data written to
   *         the output buffer
   *
   * @throws IllegalArgumentException if the flush mode is invalid
   * @since 1.7
  */
  deflate(output: number[], off: number, len: number, flush: number): number;
  /**
   * Compresses the input data and fills the specified buffer with compressed
   * data. Returns actual number of bytes of data compressed.
   *
   * Compression flush mode is one of the following three modes:
   *
   * 
   * {@link #NO_FLUSH}: allows the deflater to decide how much data
   * to accumulate, before producing output, in order to achieve the best
   * compression (should be used in normal use scenario). A return value
   * of 0 in this flush mode indicates that {@link #needsInput()} should
   * be called in order to determine if more input data is required.
   *
   * {@link #SYNC_FLUSH}: all pending output in the deflater is flushed,
   * to the specified output buffer, so that an inflater that works on
   * compressed data can get all input data available so far (In particular
   * the {@link #needsInput()} returns `true` after this invocation
   * if enough output space is provided). Flushing with {@link #SYNC_FLUSH}
   * may degrade compression for some compression algorithms and so it
   * should be used only when necessary.
   *
   * {@link #FULL_FLUSH}: all pending output is flushed out as with
   * {@link #SYNC_FLUSH}. The compression state is reset so that the inflater
   * that works on the compressed output data can restart from this point
   * if previous compressed data has been damaged or if random access is
   * desired. Using {@link #FULL_FLUSH} too often can seriously degrade
   * compression.
   * 
   *
   * In the case of {@link #FULL_FLUSH} or {@link #SYNC_FLUSH}, if
   * the return value is equal to the {@linkplain ByteBuffer#remaining() remaining space}
   * of the buffer, this method should be invoked again with the same
   * `flush` parameter and more output space. Make sure that
   * the buffer has at least 6 bytes of remaining space to avoid the
   * flush marker (5 bytes) being repeatedly output to the output buffer
   * every time this method is invoked.
   *
   * On success, the position of the given `output` byte buffer will be
   * advanced by as many bytes as were produced by the operation, which is equal
   * to the number returned by this method.
   *
   * If the {@link #setInput(ByteBuffer)} method was called to provide a buffer
   * for input, the input buffer's position will be advanced by the number of bytes
   * consumed by this operation.
   *
   * @param output the buffer for the compressed data
   * @param flush the compression flush mode
   * @return the actual number of bytes of compressed data written to
   *         the output buffer
   *
   * @throws IllegalArgumentException if the flush mode is invalid
   * @since 11
  */
  deflate(output: ByteBuffer, flush: number): number;
  /**
   * Returns the ADLER-32 value of the uncompressed data.
   * @return the ADLER-32 value of the uncompressed data
  */
  getAdler(): number;
  /**
   * Returns the total number of uncompressed bytes input so far.
   *
   * Since the number of bytes may be greater than
   * Integer.MAX_VALUE, the {@link #getBytesRead()} method is now
   * the preferred means of obtaining this information.
   *
   * @return the total number of uncompressed bytes input so far
  */
  getTotalIn(): number;
  /**
   * Returns the total number of uncompressed bytes input so far.
   *
   * @return the total (non-negative) number of uncompressed bytes input so far
   * @since 1.5
  */
  getBytesRead(): number;
  /**
   * Returns the total number of compressed bytes output so far.
   *
   * Since the number of bytes may be greater than
   * Integer.MAX_VALUE, the {@link #getBytesWritten()} method is now
   * the preferred means of obtaining this information.
   *
   * @return the total number of compressed bytes output so far
  */
  getTotalOut(): number;
  /**
   * Returns the total number of compressed bytes output so far.
   *
   * @return the total (non-negative) number of compressed bytes output so far
   * @since 1.5
  */
  getBytesWritten(): number;
  /**
   * Resets deflater so that a new set of input data can be processed.
   * Keeps current compression level and strategy settings.
  */
  reset(): void;
  /**
   * Closes the compressor and discards any unprocessed input.
   *
   * This method should be called when the compressor is no longer
   * being used. Once this method is called, the behavior of the
   * Deflater object is undefined.
  */
  end(): void;
}
/**
 * Signals that a data format error has occurred.
 *
 * @author      David Connelly
 * @since 1.1
*/
export class DataFormatException extends Exception {
  /**
   * Constructs a DataFormatException with no detail message.
  */
  constructor();
  /**
   * Constructs a DataFormatException with the specified detail message.
   * A detail message is a String that describes this particular exception.
   * @param s the String containing a detail message
  */
  constructor(s: string);
}
export class DeflaterInputStream extends FilterInputStream {
  /**
   * Creates a new input stream with a default compressor and buffer
   * size.
   *
   * @param in input stream to read the uncompressed data to
   * @throws NullPointerException if `in` is null
  */
  constructor(in_: InputStream);
  /**
   * Creates a new input stream with the specified compressor and a
   * default buffer size.
   *
   * @param in input stream to read the uncompressed data to
   * @param defl compressor ("deflater") for this stream
   * @throws NullPointerException if `in` or `defl` is null
  */
  constructor(in_: InputStream, defl: Deflater);
  /**
   * Creates a new input stream with the specified compressor and buffer
   * size.
   *
   * @param in input stream to read the uncompressed data to
   * @param defl compressor ("deflater") for this stream
   * @param bufLen compression buffer size
   * @throws IllegalArgumentException if `bufLen <= 0`
   * @throws NullPointerException if `in` or `defl` is null
  */
  constructor(in_: InputStream, defl: Deflater, bufLen: number);
  /**
   * Closes this input stream and its underlying input stream, discarding
   * any pending uncompressed data.
   *
   * @throws IOException if an I/O error occurs
  */
  close(): void;
  /**
   * Reads a single byte of compressed data from the input stream.
   * This method will block until some input can be read and compressed.
   *
   * @return a single byte of compressed data, or -1 if the end of the
   * uncompressed input stream is reached
   * @throws IOException if an I/O error occurs or if this stream is
   * already closed
  */
  read(): number;
  /**
   * Reads compressed data into a byte array.
   * This method will block until some input can be read and compressed.
   *
   * @param b buffer into which the data is read
   * @param off starting offset of the data within `b`
   * @param len maximum number of compressed bytes to read into `b`
   * @return the actual number of bytes read, or -1 if the end of the
   * uncompressed input stream is reached
   * @throws IndexOutOfBoundsException  if `len > b.length - off`
   * @throws IOException if an I/O error occurs or if this input stream is
   * already closed
  */
  read(b: number[], off: number, len: number): number;
  /**
   * Skips over and discards data from the input stream.
   * This method may block until the specified number of bytes are read and
   * skipped. Note: While `n` is given as a `long`,
   * the maximum number of bytes which can be skipped is
   * `Integer.MAX_VALUE`.
   *
   * @param n number of bytes to be skipped
   * @return the actual number of bytes skipped
   * @throws IOException if an I/O error occurs or if this stream is
   * already closed
  */
  skip(n: number): number;
  /**
   * Returns 0 after EOF has been reached, otherwise always return 1.
   * 
   * Programs should not count on this method to return the actual number
   * of bytes that could be read without blocking
   * @return zero after the end of the underlying input stream has been
   * reached, otherwise always returns 1
   * @throws IOException if an I/O error occurs or if this stream is
   * already closed
  */
  available(): number;
  /**
   * Always returns `false` because this input stream does not support
   * the {@link #mark mark()} and {@link #reset reset()} methods.
   *
   * @return false, always
  */
  markSupported(): boolean;
  /**
   * This operation is not supported.
   *
   * @param limit maximum bytes that can be read before invalidating the position marker
  */
  mark(limit: number): void;
  /**
   * This operation is not supported.
   *
   * @throws IOException always thrown
  */
  reset(): void;
  /**
   * Reads up to `b.length` bytes of data from this
   * input stream into an array of bytes. This method blocks until some
   * input is available.
   * 
   * This method simply performs the call
   * `read(b, 0, b.length)` and returns
   * the  result. It is important that it does
   * not do `in.read(b)` instead;
   * certain subclasses of  `FilterInputStream`
   * depend on the implementation strategy actually
   * used.
   *
   * @param      b   the buffer into which the data is read.
   * @return     the total number of bytes read into the buffer, or
   *             `-1` if there is no more data because the end of
   *             the stream has been reached.
   * @throws     IOException  if an I/O error occurs.
   * @see        java.io.FilterInputStream#read(byte[], int, int)
  */
  read(b: number[]): number;
}
/**
 * An interface representing a data checksum.
 *
 * @author David Connelly
 * @since 1.1
*/
export class Checksum {
  /**
   * Updates the current checksum with the specified byte.
   *
   * @param b the byte to update the checksum with
  */
  update(b: number): void;
  /**
   * Updates the current checksum with the specified array of bytes.
   *
   * @implSpec This default implementation is equal to calling
   * `update(b, 0, b.length)`.
   *
   * @param b the array of bytes to update the checksum with
   *
   * @throws NullPointerException
   *         if `b` is `null`
   *
   * @since 9
  */
  update(b: number[]): void;
  /**
   * Updates the current checksum with the specified array of bytes.
   *
   * @param b the byte array to update the checksum with
   * @param off the start offset of the data
   * @param len the number of bytes to use for the update
  */
  update(b: number[], off: number, len: number): void;
  /**
   * Updates the current checksum with the bytes from the specified buffer.
   *
   * The checksum is updated with the remaining bytes in the buffer, starting
   * at the buffer's position. Upon return, the buffer's position will be
   * updated to its limit; its limit will not have been changed.
   *
   * @apiNote For best performance with DirectByteBuffer and other ByteBuffer
   * implementations without a backing array implementers of this interface
   * should override this method.
   *
   * @implSpec The default implementation has the following behavior.
   * For ByteBuffers backed by an accessible byte array.
   * {@code
   * update(buffer.array(),
   *        buffer.position() + buffer.arrayOffset(),
   *        buffer.remaining());
   * }
   * For ByteBuffers not backed by an accessible byte array.
   * {@code
   * byte[] b = new byte[Math.min(buffer.remaining(), 4096)];
   * while (buffer.hasRemaining()) {
   *     int length = Math.min(buffer.remaining(), b.length);
   *     buffer.get(b, 0, length);
   *     update(b, 0, length);
   * }
   * }
   *
   * @param buffer the ByteBuffer to update the checksum with
   *
   * @throws NullPointerException
   *         if `buffer` is `null`
   *
   * @since 9
  */
  update(buffer: ByteBuffer): void;
  /**
   * Returns the current checksum value.
   *
   * @return the current checksum value
  */
  getValue(): number;
  /**
   * Resets the checksum to its initial value.
  */
  reset(): void;
}

}
declare module 'java.util.Formatter' {
import { Enum } from 'java.lang';
/**
 * Enum for `BigDecimal` formatting.
*/
export class BigDecimalLayoutForm extends Enum<BigDecimalLayoutForm> {
  /**
   * Format the `BigDecimal` in computerized scientific notation.
  */
  static readonly SCIENTIFIC: BigDecimalLayoutForm;
  /**
   * Format the `BigDecimal` as a decimal number.
  */
  static readonly DECIMAL_FLOAT: BigDecimalLayoutForm;
  static valueOf(name: string): BigDecimalLayoutForm;
  static values(): BigDecimalLayoutForm[];
}

}
declare module 'java.util.regex' {
import { List, Map } from 'java.util';
import { StringBuffer, StringBuilder, CharSequence, IllegalArgumentException } from 'java.lang';
import { Serializable } from 'java.io';
import { Stream } from 'java.util.stream';
import { GroupHead, Node, CharPredicate } from 'java.util.regex.Pattern';
import { Function, Predicate } from 'java.util.function';
export class PatternSyntaxException extends IllegalArgumentException {
  /**
   * Constructs a new instance of this class.
   *
   * @param  desc
   *         A description of the error
   *
   * @param  regex
   *         The erroneous pattern
   *
   * @param  index
   *         The approximate index in the pattern of the error,
   *         or `-1` if the index is not known
  */
  constructor(desc: string, regex: string, index: number);
  /**
   * Retrieves the error index.
   *
   * @return  The approximate index in the pattern of the error,
   *         or `-1` if the index is not known
  */
  getIndex(): number;
  /**
   * Retrieves the description of the error.
   *
   * @return  The description of the error
  */
  getDescription(): string;
  /**
   * Retrieves the erroneous regular-expression pattern.
   *
   * @return  The erroneous pattern
  */
  getPattern(): string;
  /**
   * Returns a multi-line string containing the description of the syntax
   * error and its index, the erroneous regular-expression pattern, and a
   * visual indication of the error index within the pattern.
   *
   * @return  The full detail message
  */
  getMessage(): string;
}
export class Pattern extends Serializable {
  /**
   * Enables Unix lines mode.
   *
   *  In this mode, only the `'\n'` line terminator is recognized
   * in the behavior of `.`, `^`, and `$`.
   *
   *  Unix lines mode can also be enabled via the embedded flag
   * expression `(?d)`.
  */
  static readonly UNIX_LINES: number;
  /**
   * Enables case-insensitive matching.
   *
   *  By default, case-insensitive matching assumes that only characters
   * in the US-ASCII charset are being matched.  Unicode-aware
   * case-insensitive matching can be enabled by specifying the {@link
   * #UNICODE_CASE} flag in conjunction with this flag.
   *
   *  Case-insensitive matching can also be enabled via the embedded flag
   * expression `(?i)`.
   *
   *  Specifying this flag may impose a slight performance penalty.  
  */
  static readonly CASE_INSENSITIVE: number;
  /**
   * Permits whitespace and comments in pattern.
   *
   *  In this mode, whitespace is ignored, and embedded comments starting
   * with `#` are ignored until the end of a line.
   *
   *  Comments mode can also be enabled via the embedded flag
   * expression `(?x)`.
  */
  static readonly COMMENTS: number;
  /**
   * Enables multiline mode.
   *
   *  In multiline mode the expressions `^` and `$` match
   * just after or just before, respectively, a line terminator or the end of
   * the input sequence.  By default these expressions only match at the
   * beginning and the end of the entire input sequence.
   *
   *  Multiline mode can also be enabled via the embedded flag
   * expression `(?m)`.  
  */
  static readonly MULTILINE: number;
  /**
   * Enables literal parsing of the pattern.
   *
   *  When this flag is specified then the input string that specifies
   * the pattern is treated as a sequence of literal characters.
   * Metacharacters or escape sequences in the input sequence will be
   * given no special meaning.
   *
   * The flags CASE_INSENSITIVE and UNICODE_CASE retain their impact on
   * matching when used in conjunction with this flag. The other flags
   * become superfluous.
   *
   *  There is no embedded flag character for enabling literal parsing.
   * @since 1.5
  */
  static readonly LITERAL: number;
  /**
   * Enables dotall mode.
   *
   *  In dotall mode, the expression `.` matches any character,
   * including a line terminator.  By default this expression does not match
   * line terminators.
   *
   *  Dotall mode can also be enabled via the embedded flag
   * expression `(?s)`.  (The `s` is a mnemonic for
   * "single-line" mode, which is what this is called in Perl.)  
  */
  static readonly DOTALL: number;
  /**
   * Enables Unicode-aware case folding.
   *
   *  When this flag is specified then case-insensitive matching, when
   * enabled by the {@link #CASE_INSENSITIVE} flag, is done in a manner
   * consistent with the Unicode Standard.  By default, case-insensitive
   * matching assumes that only characters in the US-ASCII charset are being
   * matched.
   *
   *  Unicode-aware case folding can also be enabled via the embedded flag
   * expression `(?u)`.
   *
   *  Specifying this flag may impose a performance penalty.  
  */
  static readonly UNICODE_CASE: number;
  /**
   * Enables canonical equivalence.
   *
   *  When this flag is specified then two characters will be considered
   * to match if, and only if, their full canonical decompositions match.
   * The expression "a\u030A", for example, will match the
   * string "\u00E5" when this flag is specified.  By default,
   * matching does not take canonical equivalence into account.
   *
   *  There is no embedded flag character for enabling canonical
   * equivalence.
   *
   *  Specifying this flag may impose a performance penalty.  
  */
  static readonly CANON_EQ: number;
  /**
   * Enables the Unicode version of Predefined character classes and
   * POSIX character classes.
   *
   *  When this flag is specified then the (US-ASCII only)
   * Predefined character classes and POSIX character classes
   * are in conformance with
   * Unicode Technical
   * Standard #18: Unicode Regular Expression
   * Annex C: Compatibility Properties.
   * 
   * The UNICODE_CHARACTER_CLASS mode can also be enabled via the embedded
   * flag expression `(?U)`.
   * 
   * The flag implies UNICODE_CASE, that is, it enables Unicode-aware case
   * folding.
   * 
   * Specifying this flag may impose a performance penalty.  
   * @since 1.7
  */
  static readonly UNICODE_CHARACTER_CLASS: number;
  /**
   * Compiles the given regular expression into a pattern.
   *
   * @param  regex
   *         The expression to be compiled
   * @return the given regular expression compiled into a pattern
   * @throws  PatternSyntaxException
   *          If the expression's syntax is invalid
  */
  static compile(regex: string): Pattern;
  /**
   * Compiles the given regular expression into a pattern with the given
   * flags.
   *
   * @param  regex
   *         The expression to be compiled
   *
   * @param  flags
   *         Match flags, a bit mask that may include
   *         {@link #CASE_INSENSITIVE}, {@link #MULTILINE}, {@link #DOTALL},
   *         {@link #UNICODE_CASE}, {@link #CANON_EQ}, {@link #UNIX_LINES},
   *         {@link #LITERAL}, {@link #UNICODE_CHARACTER_CLASS}
   *         and {@link #COMMENTS}
   *
   * @return the given regular expression compiled into a pattern with the given flags
   * @throws  IllegalArgumentException
   *          If bit values other than those corresponding to the defined
   *          match flags are set in `flags`
   *
   * @throws  PatternSyntaxException
   *          If the expression's syntax is invalid
  */
  static compile(regex: string, flags: number): Pattern;
  /**
   * Returns the regular expression from which this pattern was compiled.
   *
   * @return  The source of this pattern
  */
  pattern(): string;
  /**
   * Returns the string representation of this pattern. This
   * is the regular expression from which this pattern was
   * compiled.
   *
   * @return  The string representation of this pattern
   * @since 1.5
  */
  toString(): string;
  /**
   * Creates a matcher that will match the given input against this pattern.
   *
   * @param  input
   *         The character sequence to be matched
   *
   * @return  A new matcher for this pattern
  */
  matcher(input: CharSequence): Matcher;
  /**
   * Returns this pattern's match flags.
   *
   * @return  The match flags specified when this pattern was compiled
  */
  flags(): number;
  /**
   * Compiles the given regular expression and attempts to match the given
   * input against it.
   *
   *  An invocation of this convenience method of the form
   *
   *      * Pattern.matches(regex, input);
   *
   * behaves in exactly the same way as the expression
   *
   *      * Pattern.compile(regex).matcher(input).matches()
   *
   *  If a pattern is to be used multiple times, compiling it once and reusing
   * it will be more efficient than invoking this method each time.  
   *
   * @param  regex
   *         The expression to be compiled
   *
   * @param  input
   *         The character sequence to be matched
   * @return whether or not the regular expression matches on the input
   * @throws  PatternSyntaxException
   *          If the expression's syntax is invalid
  */
  static matches(regex: string, input: CharSequence): boolean;
  /**
   * Splits the given input sequence around matches of this pattern.
   *
   *  The array returned by this method contains each substring of the
   * input sequence that is terminated by another subsequence that matches
   * this pattern or is terminated by the end of the input sequence.  The
   * substrings in the array are in the order in which they occur in the
   * input. If this pattern does not match any subsequence of the input then
   * the resulting array has just one element, namely the input sequence in
   * string form.
   *
   *  When there is a positive-width match at the beginning of the input
   * sequence then an empty leading substring is included at the beginning
   * of the resulting array. A zero-width match at the beginning however
   * never produces such empty leading substring.
   *
   *  The `limit` parameter controls the number of times the
   * pattern is applied and therefore affects the length of the resulting
   * array.
   * 
   *    
   *    If the limit is positive then the pattern will be applied
   *    at most limit - 1 times, the array's length will be
   *    no greater than limit, and the array's last entry will contain
   *    all input beyond the last matched delimiter.
   *
   *    
   *    If the limit is zero then the pattern will be applied as
   *    many times as possible, the array can have any length, and trailing
   *    empty strings will be discarded.
   *
   *    
   *    If the limit is negative then the pattern will be applied
   *    as many times as possible and the array can have any length.
   * 
   *
   *  The input `"boo:and:foo"`, for example, yields the following
   * results with these parameters:
   *
   * 
   * Split example showing regex, limit, and result
   * 
   * 
   *     Regex
   *     Limit
   *     Result
   * 
   * 
   * 
   * :
   *     2
   *     `{ "boo", "and:foo" `}
   * 
   *     5
   *     `{ "boo", "and", "foo" `}
   * 
   *     -2
   *     `{ "boo", "and", "foo" `}
   * o
   *     5
   *     `{ "b", "", ":and:f", "", "" `}
   * 
   *     -2
   *     `{ "b", "", ":and:f", "", "" `}
   * 
   *     0
   *     `{ "b", "", ":and:f" `}
   * 
   * 
   *
   * @param  input
   *         The character sequence to be split
   *
   * @param  limit
   *         The result threshold, as described above
   *
   * @return  The array of strings computed by splitting the input
   *          around matches of this pattern
  */
  split(input: CharSequence, limit: number): string[];
  /**
   * Splits the given input sequence around matches of this pattern.
   *
   *  This method works as if by invoking the two-argument {@link
   * #split(java.lang.CharSequence, int) split} method with the given input
   * sequence and a limit argument of zero.  Trailing empty strings are
   * therefore not included in the resulting array. 
   *
   *  The input `"boo:and:foo"`, for example, yields the following
   * results with these expressions:
   *
   * 
   * Split examples showing regex and result
   * 
   * 
   *  Regex
   *  Result
   * 
   * 
   * 
   * :
   *     `{ "boo", "and", "foo" `}
   * o
   *     `{ "b", "", ":and:f" `}
   * 
   * 
   *
   *
   * @param  input
   *         The character sequence to be split
   *
   * @return  The array of strings computed by splitting the input
   *          around matches of this pattern
  */
  split(input: CharSequence): string[];
  /**
   * Returns a literal pattern `String` for the specified
   * `String`.
   *
   * This method produces a `String` that can be used to
   * create a `Pattern` that would match the string
   * `s` as if it were a literal pattern. Metacharacters
   * or escape sequences in the input sequence will be given no special
   * meaning.
   *
   * @param  s The string to be literalized
   * @return  A literal string replacement
   * @since 1.5
  */
  static quote(s: string): string;
  /**
   * Creates a predicate that tests if this pattern is found in a given input
   * string.
   *
   * @apiNote
   * This method creates a predicate that behaves as if it creates a matcher
   * from the input sequence and then calls `find`, for example a
   * predicate of the form:
   * {@code
   *   s -> matcher(s).find();
   * }
   *
   * @return  The predicate which can be used for finding a match on a
   *          subsequence of a string
   * @since   1.8
   * @see     Matcher#find
  */
  asPredicate(): Predicate<string>;
  /**
   * Creates a predicate that tests if this pattern matches a given input string.
   *
   * @apiNote
   * This method creates a predicate that behaves as if it creates a matcher
   * from the input sequence and then calls `matches`, for example a
   * predicate of the form:
   * {@code
   *   s -> matcher(s).matches();
   * }
   *
   * @return  The predicate which can be used for matching an input string
   *          against this pattern.
   * @since   11
   * @see     Matcher#matches
  */
  asMatchPredicate(): Predicate<string>;
  /**
   * Creates a stream from the given input sequence around matches of this
   * pattern.
   *
   *  The stream returned by this method contains each substring of the
   * input sequence that is terminated by another subsequence that matches
   * this pattern or is terminated by the end of the input sequence.  The
   * substrings in the stream are in the order in which they occur in the
   * input. Trailing empty strings will be discarded and not encountered in
   * the stream.
   *
   *  If this pattern does not match any subsequence of the input then
   * the resulting stream has just one element, namely the input sequence in
   * string form.
   *
   *  When there is a positive-width match at the beginning of the input
   * sequence then an empty leading substring is included at the beginning
   * of the stream. A zero-width match at the beginning however never produces
   * such empty leading substring.
   *
   *  If the input sequence is mutable, it must remain constant during the
   * execution of the terminal stream operation.  Otherwise, the result of the
   * terminal stream operation is undefined.
   *
   * @param   input
   *          The character sequence to be split
   *
   * @return  The stream of strings computed by splitting the input
   *          around matches of this pattern
   * @see     #split(CharSequence)
   * @since   1.8
  */
  splitAsStream(input: CharSequence): Stream<string>;
}
export class Matcher extends MatchResult {
  /**
   * Returns the pattern that is interpreted by this matcher.
   *
   * @return  The pattern for which this matcher was created
  */
  pattern(): Pattern;
  /**
   * Returns the match state of this matcher as a {@link MatchResult}.
   * The result is unaffected by subsequent operations performed upon this
   * matcher.
   *
   * @return  a `MatchResult` with the state of this matcher
   * @since 1.5
  */
  toMatchResult(): MatchResult;
  /**
   * Changes the `Pattern` that this `Matcher` uses to
   * find matches with.
   *
   *  This method causes this matcher to lose information
   * about the groups of the last match that occurred. The
   * matcher's position in the input is maintained and its
   * last append position is unaffected.
   *
   * @param  newPattern
   *         The new pattern used by this matcher
   * @return  This matcher
   * @throws  IllegalArgumentException
   *          If newPattern is `null`
   * @since 1.5
  */
  usePattern(newPattern: Pattern): Matcher;
  /**
   * Resets this matcher.
   *
   *  Resetting a matcher discards all of its explicit state information
   * and sets its append position to zero. The matcher's region is set to the
   * default region, which is its entire character sequence. The anchoring
   * and transparency of this matcher's region boundaries are unaffected.
   *
   * @return  This matcher
  */
  reset(): Matcher;
  /**
   * Resets this matcher with a new input sequence.
   *
   *  Resetting a matcher discards all of its explicit state information
   * and sets its append position to zero.  The matcher's region is set to
   * the default region, which is its entire character sequence.  The
   * anchoring and transparency of this matcher's region boundaries are
   * unaffected.
   *
   * @param  input
   *         The new input character sequence
   *
   * @return  This matcher
  */
  reset(input: CharSequence): Matcher;
  /**
   * Returns the start index of the previous match.
   *
   * @return  The index of the first character matched
   *
   * @throws  IllegalStateException
   *          If no match has yet been attempted,
   *          or if the previous match operation failed
  */
  start(): number;
  /**
   * Returns the start index of the subsequence captured by the given group
   * during the previous match operation.
   *
   *  Capturing groups are indexed from left
   * to right, starting at one.  Group zero denotes the entire pattern, so
   * the expression m.`start(0)` is equivalent to
   * m.`start()`.  
   *
   * @param  group
   *         The index of a capturing group in this matcher's pattern
   *
   * @return  The index of the first character captured by the group,
   *          or `-1` if the match was successful but the group
   *          itself did not match anything
   *
   * @throws  IllegalStateException
   *          If no match has yet been attempted,
   *          or if the previous match operation failed
   *
   * @throws  IndexOutOfBoundsException
   *          If there is no capturing group in the pattern
   *          with the given index
  */
  start(group: number): number;
  /**
   * Returns the start index of the subsequence captured by the given
   * named-capturing group during the
   * previous match operation.
   *
   * @param  name
   *         The name of a named-capturing group in this matcher's pattern
   *
   * @return  The index of the first character captured by the group,
   *          or `-1` if the match was successful but the group
   *          itself did not match anything
   *
   * @throws  IllegalStateException
   *          If no match has yet been attempted,
   *          or if the previous match operation failed
   *
   * @throws  IllegalArgumentException
   *          If there is no capturing group in the pattern
   *          with the given name
   * @since 1.8
  */
  start(name: string): number;
  /**
   * Returns the offset after the last character matched.
   *
   * @return  The offset after the last character matched
   *
   * @throws  IllegalStateException
   *          If no match has yet been attempted,
   *          or if the previous match operation failed
  */
  end(): number;
  /**
   * Returns the offset after the last character of the subsequence
   * captured by the given group during the previous match operation.
   *
   *  Capturing groups are indexed from left
   * to right, starting at one.  Group zero denotes the entire pattern, so
   * the expression m.`end(0)` is equivalent to
   * m.`end()`.  
   *
   * @param  group
   *         The index of a capturing group in this matcher's pattern
   *
   * @return  The offset after the last character captured by the group,
   *          or `-1` if the match was successful
   *          but the group itself did not match anything
   *
   * @throws  IllegalStateException
   *          If no match has yet been attempted,
   *          or if the previous match operation failed
   *
   * @throws  IndexOutOfBoundsException
   *          If there is no capturing group in the pattern
   *          with the given index
  */
  end(group: number): number;
  /**
   * Returns the offset after the last character of the subsequence
   * captured by the given named-capturing
   * group during the previous match operation.
   *
   * @param  name
   *         The name of a named-capturing group in this matcher's pattern
   *
   * @return  The offset after the last character captured by the group,
   *          or `-1` if the match was successful
   *          but the group itself did not match anything
   *
   * @throws  IllegalStateException
   *          If no match has yet been attempted,
   *          or if the previous match operation failed
   *
   * @throws  IllegalArgumentException
   *          If there is no capturing group in the pattern
   *          with the given name
   * @since 1.8
  */
  end(name: string): number;
  /**
   * Returns the input subsequence matched by the previous match.
   *
   *  For a matcher m with input sequence s,
   * the expressions m.`group()` and
   * s.`substring(`m.`start(),` m.
   * `end())` are equivalent.  
   *
   *  Note that some patterns, for example `a*`, match the empty
   * string.  This method will return the empty string when the pattern
   * successfully matches the empty string in the input.  
   *
   * @return The (possibly empty) subsequence matched by the previous match,
   *         in string form
   *
   * @throws  IllegalStateException
   *          If no match has yet been attempted,
   *          or if the previous match operation failed
  */
  group(): string;
  /**
   * Returns the input subsequence captured by the given group during the
   * previous match operation.
   *
   *  For a matcher m, input sequence s, and group index
   * g, the expressions m.`group(`g`)` and
   * s.`substring(`m.`start(`g`     * ),` m.`end(`g`))`
   * are equivalent.  
   *
   *  Capturing groups are indexed from left
   * to right, starting at one.  Group zero denotes the entire pattern, so
   * the expression `m.group(0)` is equivalent to `m.group()`.
   * 
   *
   *  If the match was successful but the group specified failed to match
   * any part of the input sequence, then `null` is returned. Note
   * that some groups, for example `(a*)`, match the empty string.
   * This method will return the empty string when such a group successfully
   * matches the empty string in the input.  
   *
   * @param  group
   *         The index of a capturing group in this matcher's pattern
   *
   * @return  The (possibly empty) subsequence captured by the group
   *          during the previous match, or `null` if the group
   *          failed to match part of the input
   *
   * @throws  IllegalStateException
   *          If no match has yet been attempted,
   *          or if the previous match operation failed
   *
   * @throws  IndexOutOfBoundsException
   *          If there is no capturing group in the pattern
   *          with the given index
  */
  group(group: number): string;
  /**
   * Returns the input subsequence captured by the given
   * named-capturing group during the
   * previous match operation.
   *
   *  If the match was successful but the group specified failed to match
   * any part of the input sequence, then `null` is returned. Note
   * that some groups, for example `(a*)`, match the empty string.
   * This method will return the empty string when such a group successfully
   * matches the empty string in the input.  
   *
   * @param  name
   *         The name of a named-capturing group in this matcher's pattern
   *
   * @return  The (possibly empty) subsequence captured by the named group
   *          during the previous match, or `null` if the group
   *          failed to match part of the input
   *
   * @throws  IllegalStateException
   *          If no match has yet been attempted,
   *          or if the previous match operation failed
   *
   * @throws  IllegalArgumentException
   *          If there is no capturing group in the pattern
   *          with the given name
   * @since 1.7
  */
  group(name: string): string;
  /**
   * Returns the number of capturing groups in this matcher's pattern.
   *
   *  Group zero denotes the entire pattern by convention. It is not
   * included in this count.
   *
   *  Any non-negative integer smaller than or equal to the value
   * returned by this method is guaranteed to be a valid group index for
   * this matcher.  
   *
   * @return The number of capturing groups in this matcher's pattern
  */
  groupCount(): number;
  /**
   * Attempts to match the entire region against the pattern.
   *
   *  If the match succeeds then more information can be obtained via the
   * `start`, `end`, and `group` methods.  
   *
   * @return  `true` if, and only if, the entire region sequence
   *          matches this matcher's pattern
  */
  matches(): boolean;
  /**
   * Attempts to find the next subsequence of the input sequence that matches
   * the pattern.
   *
   *  This method starts at the beginning of this matcher's region, or, if
   * a previous invocation of the method was successful and the matcher has
   * not since been reset, at the first character not matched by the previous
   * match.
   *
   *  If the match succeeds then more information can be obtained via the
   * `start`, `end`, and `group` methods.  
   *
   * @return  `true` if, and only if, a subsequence of the input
   *          sequence matches this matcher's pattern
  */
  find(): boolean;
  /**
   * Resets this matcher and then attempts to find the next subsequence of
   * the input sequence that matches the pattern, starting at the specified
   * index.
   *
   *  If the match succeeds then more information can be obtained via the
   * `start`, `end`, and `group` methods, and subsequent
   * invocations of the {@link #find()} method will start at the first
   * character not matched by this match.  
   *
   * @param start the index to start searching for a match
   * @throws  IndexOutOfBoundsException
   *          If start is less than zero or if start is greater than the
   *          length of the input sequence.
   *
   * @return  `true` if, and only if, a subsequence of the input
   *          sequence starting at the given index matches this matcher's
   *          pattern
  */
  find(start: number): boolean;
  /**
   * Attempts to match the input sequence, starting at the beginning of the
   * region, against the pattern.
   *
   *  Like the {@link #matches matches} method, this method always starts
   * at the beginning of the region; unlike that method, it does not
   * require that the entire region be matched.
   *
   *  If the match succeeds then more information can be obtained via the
   * `start`, `end`, and `group` methods.  
   *
   * @return  `true` if, and only if, a prefix of the input
   *          sequence matches this matcher's pattern
  */
  lookingAt(): boolean;
  /**
   * Returns a literal replacement `String` for the specified
   * `String`.
   *
   * This method produces a `String` that will work
   * as a literal replacement `s` in the
   * `appendReplacement` method of the {@link Matcher} class.
   * The `String` produced will match the sequence of characters
   * in `s` treated as a literal sequence. Slashes ('\') and
   * dollar signs ('$') will be given no special meaning.
   *
   * @param  s The string to be literalized
   * @return  A literal string replacement
   * @since 1.5
  */
  static quoteReplacement(s: string): string;
  /**
   * Implements a non-terminal append-and-replace step.
   *
   *  This method performs the following actions: 
   *
   * 
   *
   *    It reads characters from the input sequence, starting at the
   *   append position, and appends them to the given string buffer.  It
   *   stops after reading the last character preceding the previous match,
   *   that is, the character at index {@link
   *   #start()} `-` `1`.  
   *
   *    It appends the given replacement string to the string buffer.
   *   
   *
   *    It sets the append position of this matcher to the index of
   *   the last character matched, plus one, that is, to {@link #end()}.
   *   
   *
   * 
   *
   *  The replacement string may contain references to subsequences
   * captured during the previous match: Each occurrence of
   * ${name} or `$`g
   * will be replaced by the result of evaluating the corresponding
   * {@link #group(String) group(name)} or {@link #group(int) group(g)}
   * respectively. For `$`g,
   * the first number after the `$` is always treated as part of
   * the group reference. Subsequent numbers are incorporated into g if
   * they would form a legal group reference. Only the numerals '0'
   * through '9' are considered as potential components of the group
   * reference. If the second group matched the string `"foo"`, for
   * example, then passing the replacement string `"$2bar"` would
   * cause `"foobar"` to be appended to the string buffer. A dollar
   * sign (`$`) may be included as a literal in the replacement
   * string by preceding it with a backslash (`\$`).
   *
   *  Note that backslashes (`\`) and dollar signs (`$`) in
   * the replacement string may cause the results to be different than if it
   * were being treated as a literal replacement string. Dollar signs may be
   * treated as references to captured subsequences as described above, and
   * backslashes are used to escape literal characters in the replacement
   * string.
   *
   *  This method is intended to be used in a loop together with the
   * {@link #appendTail(StringBuffer) appendTail} and {@link #find() find}
   * methods.  The following code, for example, writes {@code one dog two dogs
   * in the yard} to the standard-output stream: 
   *
   *      * Pattern p = Pattern.compile("cat");
   * Matcher m = p.matcher("one cat two cats in the yard");
   * StringBuffer sb = new StringBuffer();
   * while (m.find()) {
   *     m.appendReplacement(sb, "dog");
   * }
   * m.appendTail(sb);
   * System.out.println(sb.toString());
   *
   * @param  sb
   *         The target string buffer
   *
   * @param  replacement
   *         The replacement string
   *
   * @return  This matcher
   *
   * @throws  IllegalStateException
   *          If no match has yet been attempted,
   *          or if the previous match operation failed
   *
   * @throws  IllegalArgumentException
   *          If the replacement string refers to a named-capturing
   *          group that does not exist in the pattern
   *
   * @throws  IndexOutOfBoundsException
   *          If the replacement string refers to a capturing group
   *          that does not exist in the pattern
  */
  appendReplacement(sb: StringBuffer, replacement: string): Matcher;
  /**
   * Implements a non-terminal append-and-replace step.
   *
   *  This method performs the following actions: 
   *
   * 
   *
   *    It reads characters from the input sequence, starting at the
   *   append position, and appends them to the given string builder.  It
   *   stops after reading the last character preceding the previous match,
   *   that is, the character at index {@link
   *   #start()} `-` `1`.  
   *
   *    It appends the given replacement string to the string builder.
   *   
   *
   *    It sets the append position of this matcher to the index of
   *   the last character matched, plus one, that is, to {@link #end()}.
   *   
   *
   * 
   *
   *  The replacement string may contain references to subsequences
   * captured during the previous match: Each occurrence of
   * `$`g will be replaced by the result of
   * evaluating {@link #group(int) group}`(`g`)`.
   * The first number after the `$` is always treated as part of
   * the group reference. Subsequent numbers are incorporated into g if
   * they would form a legal group reference. Only the numerals '0'
   * through '9' are considered as potential components of the group
   * reference. If the second group matched the string `"foo"`, for
   * example, then passing the replacement string `"$2bar"` would
   * cause `"foobar"` to be appended to the string builder. A dollar
   * sign (`$`) may be included as a literal in the replacement
   * string by preceding it with a backslash (`\$`).
   *
   *  Note that backslashes (`\`) and dollar signs (`$`) in
   * the replacement string may cause the results to be different than if it
   * were being treated as a literal replacement string. Dollar signs may be
   * treated as references to captured subsequences as described above, and
   * backslashes are used to escape literal characters in the replacement
   * string.
   *
   *  This method is intended to be used in a loop together with the
   * {@link #appendTail(StringBuilder) appendTail} and
   * {@link #find() find} methods. The following code, for example, writes
   * `one dog two dogs in the yard` to the standard-output stream: 
   *
   *      * Pattern p = Pattern.compile("cat");
   * Matcher m = p.matcher("one cat two cats in the yard");
   * StringBuilder sb = new StringBuilder();
   * while (m.find()) {
   *     m.appendReplacement(sb, "dog");
   * }
   * m.appendTail(sb);
   * System.out.println(sb.toString());
   *
   * @param  sb
   *         The target string builder
   * @param  replacement
   *         The replacement string
   * @return  This matcher
   *
   * @throws  IllegalStateException
   *          If no match has yet been attempted,
   *          or if the previous match operation failed
   * @throws  IllegalArgumentException
   *          If the replacement string refers to a named-capturing
   *          group that does not exist in the pattern
   * @throws  IndexOutOfBoundsException
   *          If the replacement string refers to a capturing group
   *          that does not exist in the pattern
   * @since 9
  */
  appendReplacement(sb: StringBuilder, replacement: string): Matcher;
  /**
   * Implements a terminal append-and-replace step.
   *
   *  This method reads characters from the input sequence, starting at
   * the append position, and appends them to the given string buffer.  It is
   * intended to be invoked after one or more invocations of the {@link
   * #appendReplacement(StringBuffer, String) appendReplacement} method in
   * order to copy the remainder of the input sequence.  
   *
   * @param  sb
   *         The target string buffer
   *
   * @return  The target string buffer
  */
  appendTail(sb: StringBuffer): StringBuffer;
  /**
   * Implements a terminal append-and-replace step.
   *
   *  This method reads characters from the input sequence, starting at
   * the append position, and appends them to the given string builder.  It is
   * intended to be invoked after one or more invocations of the {@link
   * #appendReplacement(StringBuilder, String)
   * appendReplacement} method in order to copy the remainder of the input
   * sequence.  
   *
   * @param  sb
   *         The target string builder
   *
   * @return  The target string builder
   *
   * @since 9
  */
  appendTail(sb: StringBuilder): StringBuilder;
  /**
   * Replaces every subsequence of the input sequence that matches the
   * pattern with the given replacement string.
   *
   *  This method first resets this matcher.  It then scans the input
   * sequence looking for matches of the pattern.  Characters that are not
   * part of any match are appended directly to the result string; each match
   * is replaced in the result by the replacement string.  The replacement
   * string may contain references to captured subsequences as in the {@link
   * #appendReplacement appendReplacement} method.
   *
   *  Note that backslashes (`\`) and dollar signs (`$`) in
   * the replacement string may cause the results to be different than if it
   * were being treated as a literal replacement string. Dollar signs may be
   * treated as references to captured subsequences as described above, and
   * backslashes are used to escape literal characters in the replacement
   * string.
   *
   *  Given the regular expression `a*b`, the input
   * `"aabfooaabfooabfoob"`, and the replacement string
   * `"-"`, an invocation of this method on a matcher for that
   * expression would yield the string `"-foo-foo-foo-"`.
   *
   *  Invoking this method changes this matcher's state.  If the matcher
   * is to be used in further matching operations then it should first be
   * reset.  
   *
   * @param  replacement
   *         The replacement string
   *
   * @return  The string constructed by replacing each matching subsequence
   *          by the replacement string, substituting captured subsequences
   *          as needed
  */
  replaceAll(replacement: string): string;
  /**
   * Replaces every subsequence of the input sequence that matches the
   * pattern with the result of applying the given replacer function to the
   * match result of this matcher corresponding to that subsequence.
   * Exceptions thrown by the function are relayed to the caller.
   *
   *  This method first resets this matcher.  It then scans the input
   * sequence looking for matches of the pattern.  Characters that are not
   * part of any match are appended directly to the result string; each match
   * is replaced in the result by the applying the replacer function that
   * returns a replacement string.  Each replacement string may contain
   * references to captured subsequences as in the {@link #appendReplacement
   * appendReplacement} method.
   *
   *  Note that backslashes (`\`) and dollar signs (`$`) in
   * a replacement string may cause the results to be different than if it
   * were being treated as a literal replacement string. Dollar signs may be
   * treated as references to captured subsequences as described above, and
   * backslashes are used to escape literal characters in the replacement
   * string.
   *
   *  Given the regular expression `dog`, the input
   * `"zzzdogzzzdogzzz"`, and the function
   * `mr -> mr.group().toUpperCase()`, an invocation of this method on
   * a matcher for that expression would yield the string
   * `"zzzDOGzzzDOGzzz"`.
   *
   *  Invoking this method changes this matcher's state.  If the matcher
   * is to be used in further matching operations then it should first be
   * reset.  
   *
   *  The replacer function should not modify this matcher's state during
   * replacement.  This method will, on a best-effort basis, throw a
   * {@link java.util.ConcurrentModificationException} if such modification is
   * detected.
   *
   *  The state of each match result passed to the replacer function is
   * guaranteed to be constant only for the duration of the replacer function
   * call and only if the replacer function does not modify this matcher's
   * state.
   *
   * @implNote
   * This implementation applies the replacer function to this matcher, which
   * is an instance of `MatchResult`.
   *
   * @param  replacer
   *         The function to be applied to the match result of this matcher
   *         that returns a replacement string.
   * @return  The string constructed by replacing each matching subsequence
   *          with the result of applying the replacer function to that
   *          matched subsequence, substituting captured subsequences as
   *          needed.
   * @throws NullPointerException if the replacer function is null
   * @throws ConcurrentModificationException if it is detected, on a
   *         best-effort basis, that the replacer function modified this
   *         matcher's state
   * @since 9
  */
  replaceAll(replacer: Function<MatchResult, string>): string;
  /**
   * Returns a stream of match results for each subsequence of the input
   * sequence that matches the pattern.  The match results occur in the
   * same order as the matching subsequences in the input sequence.
   *
   *  Each match result is produced as if by {@link #toMatchResult()}.
   *
   *  This method does not reset this matcher.  Matching starts on
   * initiation of the terminal stream operation either at the beginning of
   * this matcher's region, or, if the matcher has not since been reset, at
   * the first character not matched by a previous match.
   *
   *  If the matcher is to be used for further matching operations after
   * the terminal stream operation completes then it should be first reset.
   *
   *  This matcher's state should not be modified during execution of the
   * returned stream's pipeline.  The returned stream's source
   * `Spliterator` is fail-fast and will, on a best-effort
   * basis, throw a {@link java.util.ConcurrentModificationException} if such
   * modification is detected.
   *
   * @return a sequential stream of match results.
   * @since 9
  */
  results(): Stream<MatchResult>;
  /**
   * Replaces the first subsequence of the input sequence that matches the
   * pattern with the given replacement string.
   *
   *  This method first resets this matcher.  It then scans the input
   * sequence looking for a match of the pattern.  Characters that are not
   * part of the match are appended directly to the result string; the match
   * is replaced in the result by the replacement string.  The replacement
   * string may contain references to captured subsequences as in the {@link
   * #appendReplacement appendReplacement} method.
   *
   * Note that backslashes (`\`) and dollar signs (`$`) in
   * the replacement string may cause the results to be different than if it
   * were being treated as a literal replacement string. Dollar signs may be
   * treated as references to captured subsequences as described above, and
   * backslashes are used to escape literal characters in the replacement
   * string.
   *
   *  Given the regular expression `dog`, the input
   * `"zzzdogzzzdogzzz"`, and the replacement string
   * `"cat"`, an invocation of this method on a matcher for that
   * expression would yield the string `"zzzcatzzzdogzzz"`.  
   *
   *  Invoking this method changes this matcher's state.  If the matcher
   * is to be used in further matching operations then it should first be
   * reset.  
   *
   * @param  replacement
   *         The replacement string
   * @return  The string constructed by replacing the first matching
   *          subsequence by the replacement string, substituting captured
   *          subsequences as needed
  */
  replaceFirst(replacement: string): string;
  /**
   * Replaces the first subsequence of the input sequence that matches the
   * pattern with the result of applying the given replacer function to the
   * match result of this matcher corresponding to that subsequence.
   * Exceptions thrown by the replace function are relayed to the caller.
   *
   *  This method first resets this matcher.  It then scans the input
   * sequence looking for a match of the pattern.  Characters that are not
   * part of the match are appended directly to the result string; the match
   * is replaced in the result by the applying the replacer function that
   * returns a replacement string.  The replacement string may contain
   * references to captured subsequences as in the {@link #appendReplacement
   * appendReplacement} method.
   *
   * Note that backslashes (`\`) and dollar signs (`$`) in
   * the replacement string may cause the results to be different than if it
   * were being treated as a literal replacement string. Dollar signs may be
   * treated as references to captured subsequences as described above, and
   * backslashes are used to escape literal characters in the replacement
   * string.
   *
   *  Given the regular expression `dog`, the input
   * `"zzzdogzzzdogzzz"`, and the function
   * `mr -> mr.group().toUpperCase()`, an invocation of this method on
   * a matcher for that expression would yield the string
   * `"zzzDOGzzzdogzzz"`.
   *
   *  Invoking this method changes this matcher's state.  If the matcher
   * is to be used in further matching operations then it should first be
   * reset.
   *
   *  The replacer function should not modify this matcher's state during
   * replacement.  This method will, on a best-effort basis, throw a
   * {@link java.util.ConcurrentModificationException} if such modification is
   * detected.
   *
   *  The state of the match result passed to the replacer function is
   * guaranteed to be constant only for the duration of the replacer function
   * call and only if the replacer function does not modify this matcher's
   * state.
   *
   * @implNote
   * This implementation applies the replacer function to this matcher, which
   * is an instance of `MatchResult`.
   *
   * @param  replacer
   *         The function to be applied to the match result of this matcher
   *         that returns a replacement string.
   * @return  The string constructed by replacing the first matching
   *          subsequence with the result of applying the replacer function to
   *          the matched subsequence, substituting captured subsequences as
   *          needed.
   * @throws NullPointerException if the replacer function is null
   * @throws ConcurrentModificationException if it is detected, on a
   *         best-effort basis, that the replacer function modified this
   *         matcher's state
   * @since 9
  */
  replaceFirst(replacer: Function<MatchResult, string>): string;
  /**
   * Sets the limits of this matcher's region. The region is the part of the
   * input sequence that will be searched to find a match. Invoking this
   * method resets the matcher, and then sets the region to start at the
   * index specified by the `start` parameter and end at the
   * index specified by the `end` parameter.
   *
   * Depending on the transparency and anchoring being used (see
   * {@link #useTransparentBounds(boolean) useTransparentBounds} and
   * {@link #useAnchoringBounds(boolean) useAnchoringBounds}), certain
   * constructs such as anchors may behave differently at or around the
   * boundaries of the region.
   *
   * @param  start
   *         The index to start searching at (inclusive)
   * @param  end
   *         The index to end searching at (exclusive)
   * @throws  IndexOutOfBoundsException
   *          If start or end is less than zero, if
   *          start is greater than the length of the input sequence, if
   *          end is greater than the length of the input sequence, or if
   *          start is greater than end.
   * @return  this matcher
   * @since 1.5
  */
  region(start: number, end: number): Matcher;
  /**
   * Reports the start index of this matcher's region. The
   * searches this matcher conducts are limited to finding matches
   * within {@link #regionStart() regionStart} (inclusive) and
   * {@link #regionEnd() regionEnd} (exclusive).
   *
   * @return  The starting point of this matcher's region
   * @since 1.5
  */
  regionStart(): number;
  /**
   * Reports the end index (exclusive) of this matcher's region.
   * The searches this matcher conducts are limited to finding matches
   * within {@link #regionStart() regionStart} (inclusive) and
   * {@link #regionEnd() regionEnd} (exclusive).
   *
   * @return  the ending point of this matcher's region
   * @since 1.5
  */
  regionEnd(): number;
  /**
   * Queries the transparency of region bounds for this matcher.
   *
   *  This method returns `true` if this matcher uses
   * transparent bounds, `false` if it uses opaque
   * bounds.
   *
   *  See {@link #useTransparentBounds(boolean) useTransparentBounds} for a
   * description of transparent and opaque bounds.
   *
   *  By default, a matcher uses opaque region boundaries.
   *
   * @return `true` iff this matcher is using transparent bounds,
   *         `false` otherwise.
   * @see java.util.regex.Matcher#useTransparentBounds(boolean)
   * @since 1.5
  */
  hasTransparentBounds(): boolean;
  /**
   * Sets the transparency of region bounds for this matcher.
   *
   *  Invoking this method with an argument of `true` will set this
   * matcher to use transparent bounds. If the boolean
   * argument is `false`, then opaque bounds will be used.
   *
   *  Using transparent bounds, the boundaries of this
   * matcher's region are transparent to lookahead, lookbehind,
   * and boundary matching constructs. Those constructs can see beyond the
   * boundaries of the region to see if a match is appropriate.
   *
   *  Using opaque bounds, the boundaries of this matcher's
   * region are opaque to lookahead, lookbehind, and boundary matching
   * constructs that may try to see beyond them. Those constructs cannot
   * look past the boundaries so they will fail to match anything outside
   * of the region.
   *
   *  By default, a matcher uses opaque bounds.
   *
   * @param  b a boolean indicating whether to use opaque or transparent
   *         regions
   * @return this matcher
   * @see java.util.regex.Matcher#hasTransparentBounds
   * @since 1.5
  */
  useTransparentBounds(b: boolean): Matcher;
  /**
   * Queries the anchoring of region bounds for this matcher.
   *
   *  This method returns `true` if this matcher uses
   * anchoring bounds, `false` otherwise.
   *
   *  See {@link #useAnchoringBounds(boolean) useAnchoringBounds} for a
   * description of anchoring bounds.
   *
   *  By default, a matcher uses anchoring region boundaries.
   *
   * @return `true` iff this matcher is using anchoring bounds,
   *         `false` otherwise.
   * @see java.util.regex.Matcher#useAnchoringBounds(boolean)
   * @since 1.5
  */
  hasAnchoringBounds(): boolean;
  /**
   * Sets the anchoring of region bounds for this matcher.
   *
   *  Invoking this method with an argument of `true` will set this
   * matcher to use anchoring bounds. If the boolean
   * argument is `false`, then non-anchoring bounds will be
   * used.
   *
   *  Using anchoring bounds, the boundaries of this
   * matcher's region match anchors such as ^ and $.
   *
   *  Without anchoring bounds, the boundaries of this
   * matcher's region will not match anchors such as ^ and $.
   *
   *  By default, a matcher uses anchoring region boundaries.
   *
   * @param  b a boolean indicating whether or not to use anchoring bounds.
   * @return this matcher
   * @see java.util.regex.Matcher#hasAnchoringBounds
   * @since 1.5
  */
  useAnchoringBounds(b: boolean): Matcher;
  /**
   * Returns the string representation of this matcher. The
   * string representation of a `Matcher` contains information
   * that may be useful for debugging. The exact format is unspecified.
   *
   * @return  The string representation of this matcher
   * @since 1.5
  */
  toString(): string;
  /**
   * Returns true if the end of input was hit by the search engine in
   * the last match operation performed by this matcher.
   *
   * When this method returns true, then it is possible that more input
   * would have changed the result of the last search.
   *
   * @return  true iff the end of input was hit in the last match; false
   *          otherwise
   * @since 1.5
  */
  hitEnd(): boolean;
  /**
   * Returns true if more input could change a positive match into a
   * negative one.
   *
   * If this method returns true, and a match was found, then more
   * input could cause the match to be lost. If this method returns false
   * and a match was found, then more input might change the match but the
   * match won't be lost. If a match was not found, then requireEnd has no
   * meaning.
   *
   * @return  true iff more input could change a positive match into a
   *          negative one.
   * @since 1.5
  */
  requireEnd(): boolean;
}
/**
 * The result of a match operation.
 *
 * This interface contains query methods used to determine the
 * results of a match against a regular expression. The match boundaries,
 * groups and group boundaries can be seen but not modified through
 * a `MatchResult`.
 *
 * @author  Michael McCloskey
 * @see Matcher
 * @since 1.5
*/
export class MatchResult {
  /**
   * Returns the start index of the match.
   *
   * @return  The index of the first character matched
   *
   * @throws  IllegalStateException
   *          If no match has yet been attempted,
   *          or if the previous match operation failed
  */
  start(): number;
  /**
   * Returns the start index of the subsequence captured by the given group
   * during this match.
   *
   *  Capturing groups are indexed from left
   * to right, starting at one.  Group zero denotes the entire pattern, so
   * the expression m.`start(0)` is equivalent to
   * m.`start()`.  
   *
   * @param  group
   *         The index of a capturing group in this matcher's pattern
   *
   * @return  The index of the first character captured by the group,
   *          or `-1` if the match was successful but the group
   *          itself did not match anything
   *
   * @throws  IllegalStateException
   *          If no match has yet been attempted,
   *          or if the previous match operation failed
   *
   * @throws  IndexOutOfBoundsException
   *          If there is no capturing group in the pattern
   *          with the given index
  */
  start(group: number): number;
  /**
   * Returns the offset after the last character matched.
   *
   * @return  The offset after the last character matched
   *
   * @throws  IllegalStateException
   *          If no match has yet been attempted,
   *          or if the previous match operation failed
  */
  end(): number;
  /**
   * Returns the offset after the last character of the subsequence
   * captured by the given group during this match.
   *
   *  Capturing groups are indexed from left
   * to right, starting at one.  Group zero denotes the entire pattern, so
   * the expression m.`end(0)` is equivalent to
   * m.`end()`.  
   *
   * @param  group
   *         The index of a capturing group in this matcher's pattern
   *
   * @return  The offset after the last character captured by the group,
   *          or `-1` if the match was successful
   *          but the group itself did not match anything
   *
   * @throws  IllegalStateException
   *          If no match has yet been attempted,
   *          or if the previous match operation failed
   *
   * @throws  IndexOutOfBoundsException
   *          If there is no capturing group in the pattern
   *          with the given index
  */
  end(group: number): number;
  /**
   * Returns the input subsequence matched by the previous match.
   *
   *  For a matcher m with input sequence s,
   * the expressions m.`group()` and
   * s.`substring(`m.`start(),` m.`end())`
   * are equivalent.  
   *
   *  Note that some patterns, for example `a*`, match the empty
   * string.  This method will return the empty string when the pattern
   * successfully matches the empty string in the input.  
   *
   * @return The (possibly empty) subsequence matched by the previous match,
   *         in string form
   *
   * @throws  IllegalStateException
   *          If no match has yet been attempted,
   *          or if the previous match operation failed
  */
  group(): string;
  /**
   * Returns the input subsequence captured by the given group during the
   * previous match operation.
   *
   *  For a matcher m, input sequence s, and group index
   * g, the expressions m.`group(`g`)` and
   * s.`substring(`m.`start(`g`     * ),` m.`end(`g`))`
   * are equivalent.  
   *
   *  Capturing groups are indexed from left
   * to right, starting at one.  Group zero denotes the entire pattern, so
   * the expression `m.group(0)` is equivalent to `m.group()`.
   * 
   *
   *  If the match was successful but the group specified failed to match
   * any part of the input sequence, then `null` is returned. Note
   * that some groups, for example `(a*)`, match the empty string.
   * This method will return the empty string when such a group successfully
   * matches the empty string in the input.  
   *
   * @param  group
   *         The index of a capturing group in this matcher's pattern
   *
   * @return  The (possibly empty) subsequence captured by the group
   *          during the previous match, or `null` if the group
   *          failed to match part of the input
   *
   * @throws  IllegalStateException
   *          If no match has yet been attempted,
   *          or if the previous match operation failed
   *
   * @throws  IndexOutOfBoundsException
   *          If there is no capturing group in the pattern
   *          with the given index
  */
  group(group: number): string;
  /**
   * Returns the number of capturing groups in this match result's pattern.
   *
   *  Group zero denotes the entire pattern by convention. It is not
   * included in this count.
   *
   *  Any non-negative integer smaller than or equal to the value
   * returned by this method is guaranteed to be a valid group index for
   * this matcher.  
   *
   * @return The number of capturing groups in this matcher's pattern
  */
  groupCount(): number;
}

}
declare module 'java.util.Locale' {
import { Enum } from 'java.lang';
import { Locale, Set, List, Map } from 'java.util';
/**
 * Enum for specifying the type defined in ISO 3166. This enum is used to
 * retrieve the two-letter ISO3166-1 alpha-2, three-letter ISO3166-1
 * alpha-3, four-letter ISO3166-3 country codes.
 *
 * @see #getISOCountries(Locale.IsoCountryCode)
 * @since 9
*/
export class IsoCountryCode extends Enum<IsoCountryCode> {
  /**
   * PART1_ALPHA2 is used to represent the ISO3166-1 alpha-2 two letter
   * country codes.
  */
  static readonly PART1_ALPHA2: IsoCountryCode;
  /**
   *
   * PART1_ALPHA3 is used to represent the ISO3166-1 alpha-3 three letter
   * country codes.
  */
  static readonly PART1_ALPHA3: IsoCountryCode;
  /**
   * PART3 is used to represent the ISO3166-3 four letter country codes.
  */
  static readonly PART3: IsoCountryCode;
  static valueOf(name: string): IsoCountryCode;
  static values(): IsoCountryCode[];
}
/**
 * Enum for locale categories.  These locale categories are used to get/set
 * the default locale for the specific functionality represented by the
 * category.
 *
 * @see #getDefault(Locale.Category)
 * @see #setDefault(Locale.Category, Locale)
 * @since 1.7
*/
export class Category extends Enum<Category> {
  /**
   * Category used to represent the default locale for
   * displaying user interfaces.
  */
  static readonly DISPLAY: Category;
  /**
   * Category used to represent the default locale for
   * formatting dates, numbers, and/or currencies.
  */
  static readonly FORMAT: Category;
  static valueOf(name: string): Category;
  static values(): Category[];
}
/**
 * `Builder` is used to build instances of `Locale`
 * from values configured by the setters.  Unlike the `Locale`
 * constructors, the `Builder` checks if a value configured by a
 * setter satisfies the syntax requirements defined by the `Locale`
 * class.  A `Locale` object created by a `Builder` is
 * well-formed and can be transformed to a well-formed IETF BCP 47 language tag
 * without losing information.
 *
 * Note: The `Locale` class does not provide any
 * syntactic restrictions on variant, while BCP 47 requires each variant
 * subtag to be 5 to 8 alphanumerics or a single numeric followed by 3
 * alphanumerics.  The method `setVariant` throws
 * `IllformedLocaleException` for a variant that does not satisfy
 * this restriction. If it is necessary to support such a variant, use a
 * Locale constructor.  However, keep in mind that a `Locale`
 * object created this way might lose the variant information when
 * transformed to a BCP 47 language tag.
 *
 * The following example shows how to create a `Locale` object
 * with the `Builder`.
 * 
 *      *     Locale aLocale = new Builder().setLanguage("sr").setScript("Latn").setRegion("RS").build();
 * 
 * 
 *
 * Builders can be reused; `clear()` resets all
 * fields to their default values.
 *
 * @see Locale#forLanguageTag
 * @since 1.7
*/
export class Builder {
  /**
   * Constructs an empty Builder. The default value of all
   * fields, extensions, and private use information is the
   * empty string.
  */
  constructor();
  /**
   * Resets the `Builder` to match the provided
   * `locale`.  Existing state is discarded.
   *
   * All fields of the locale must be well-formed, see {@link Locale}.
   *
   * Locales with any ill-formed fields cause
   * `IllformedLocaleException` to be thrown, except for the
   * following three cases which are accepted for compatibility
   * reasons:
   * Locale("ja", "JP", "JP") is treated as "ja-JP-u-ca-japanese"
   * Locale("th", "TH", "TH") is treated as "th-TH-u-nu-thai"
   * Locale("no", "NO", "NY") is treated as "nn-NO"
   *
   * @param locale the locale
   * @return This builder.
   * @throws IllformedLocaleException if `locale` has
   * any ill-formed fields.
   * @throws NullPointerException if `locale` is null.
  */
  setLocale(locale: Locale);
  /**
   * Resets the Builder to match the provided IETF BCP 47
   * language tag.  Discards the existing state.  Null and the
   * empty string cause the builder to be reset, like {@link
   * #clear}.  Grandfathered tags (see {@link
   * Locale#forLanguageTag}) are converted to their canonical
   * form before being processed.  Otherwise, the language tag
   * must be well-formed (see {@link Locale}) or an exception is
   * thrown (unlike `Locale.forLanguageTag`, which
   * just discards ill-formed and following portions of the
   * tag).
   *
   * @param languageTag the language tag
   * @return This builder.
   * @throws IllformedLocaleException if `languageTag` is ill-formed
   * @see Locale#forLanguageTag(String)
  */
  setLanguageTag(languageTag: string);
  /**
   * Sets the language.  If `language` is the empty string or
   * null, the language in this `Builder` is removed.  Otherwise,
   * the language must be well-formed
   * or an exception is thrown.
   *
   * The typical language value is a two or three-letter language
   * code as defined in ISO639.
   *
   * @param language the language
   * @return This builder.
   * @throws IllformedLocaleException if `language` is ill-formed
  */
  setLanguage(language: string);
  /**
   * Sets the script. If `script` is null or the empty string,
   * the script in this `Builder` is removed.
   * Otherwise, the script must be well-formed or an
   * exception is thrown.
   *
   * The typical script value is a four-letter script code as defined by ISO 15924.
   *
   * @param script the script
   * @return This builder.
   * @throws IllformedLocaleException if `script` is ill-formed
  */
  setScript(script: string);
  /**
   * Sets the region.  If region is null or the empty string, the region
   * in this `Builder` is removed.  Otherwise,
   * the region must be well-formed or an
   * exception is thrown.
   *
   * The typical region value is a two-letter ISO 3166 code or a
   * three-digit UN M.49 area code.
   *
   * The country value in the `Locale` created by the
   * `Builder` is always normalized to upper case.
   *
   * @param region the region
   * @return This builder.
   * @throws IllformedLocaleException if `region` is ill-formed
  */
  setRegion(region: string);
  /**
   * Sets the variant.  If variant is null or the empty string, the
   * variant in this `Builder` is removed.  Otherwise, it
   * must consist of one or more well-formed
   * subtags, or an exception is thrown.
   *
   * Note: This method checks if `variant`
   * satisfies the IETF BCP 47 variant subtag's syntax requirements,
   * and normalizes the value to lowercase letters.  However,
   * the `Locale` class does not impose any syntactic
   * restriction on variant, and the variant value in
   * `Locale` is case sensitive.  To set such a variant,
   * use a Locale constructor.
   *
   * @param variant the variant
   * @return This builder.
   * @throws IllformedLocaleException if `variant` is ill-formed
  */
  setVariant(variant: string);
  /**
   * Sets the extension for the given key. If the value is null or the
   * empty string, the extension is removed.  Otherwise, the extension
   * must be well-formed or an exception
   * is thrown.
   *
   * Note: The key {@link Locale#UNICODE_LOCALE_EXTENSION
   * UNICODE_LOCALE_EXTENSION} ('u') is used for the Unicode locale extension.
   * Setting a value for this key replaces any existing Unicode locale key/type
   * pairs with those defined in the extension.
   *
   * Note: The key {@link Locale#PRIVATE_USE_EXTENSION
   * PRIVATE_USE_EXTENSION} ('x') is used for the private use code. To be
   * well-formed, the value for this key needs only to have subtags of one to
   * eight alphanumeric characters, not two to eight as in the general case.
   *
   * @param key the extension key
   * @param value the extension value
   * @return This builder.
   * @throws IllformedLocaleException if `key` is illegal
   * or `value` is ill-formed
   * @see #setUnicodeLocaleKeyword(String, String)
  */
  setExtension(key: string, value: string): Builder;
  /**
   * Sets the Unicode locale keyword type for the given key.  If the type
   * is null, the Unicode keyword is removed.  Otherwise, the key must be
   * non-null and both key and type must be well-formed or an exception
   * is thrown.
   *
   * Keys and types are converted to lower case.
   *
   * Note:Setting the 'u' extension via {@link #setExtension}
   * replaces all Unicode locale keywords with those defined in the
   * extension.
   *
   * @param key the Unicode locale key
   * @param type the Unicode locale type
   * @return This builder.
   * @throws IllformedLocaleException if `key` or `type`
   * is ill-formed
   * @throws NullPointerException if `key` is null
   * @see #setExtension(char, String)
  */
  setUnicodeLocaleKeyword(key: string, type: string): Builder;
  /**
   * Adds a unicode locale attribute, if not already present, otherwise
   * has no effect.  The attribute must not be null and must be well-formed or an exception
   * is thrown.
   *
   * @param attribute the attribute
   * @return This builder.
   * @throws NullPointerException if `attribute` is null
   * @throws IllformedLocaleException if `attribute` is ill-formed
   * @see #setExtension(char, String)
  */
  addUnicodeLocaleAttribute(attribute: string): Builder;
  /**
   * Removes a unicode locale attribute, if present, otherwise has no
   * effect.  The attribute must not be null and must be well-formed or an exception
   * is thrown.
   *
   * Attribute comparison for removal is case-insensitive.
   *
   * @param attribute the attribute
   * @return This builder.
   * @throws NullPointerException if `attribute` is null
   * @throws IllformedLocaleException if `attribute` is ill-formed
   * @see #setExtension(char, String)
  */
  removeUnicodeLocaleAttribute(attribute: string): Builder;
  /**
   * Resets the builder to its initial, empty state.
   *
   * @return This builder.
  */
  clear(): Builder;
  /**
   * Resets the extensions to their initial, empty state.
   * Language, script, region and variant are unchanged.
   *
   * @return This builder.
   * @see #setExtension(char, String)
  */
  clearExtensions(): Builder;
  /**
   * Returns an instance of `Locale` created from the fields set
   * on this builder.
   *
   * This applies the conversions listed in {@link Locale#forLanguageTag}
   * when constructing a Locale. (Grandfathered tags are handled in
   * {@link #setLanguageTag}.)
   *
   * @return A Locale.
  */
  build(): Locale;
}
/**
 * This enum provides constants to select a filtering mode for locale
 * matching. Refer to RFC 4647
 * Matching of Language Tags for details.
 *
 * As an example, think of two Language Priority Lists each of which
 * includes only one language range and a set of following language tags:
 *
 *      *    de (German)
 *    de-DE (German, Germany)
 *    de-Deva (German, in Devanagari script)
 *    de-Deva-DE (German, in Devanagari script, Germany)
 *    de-DE-1996 (German, Germany, orthography of 1996)
 *    de-Latn-DE (German, in Latin script, Germany)
 *    de-Latn-DE-1996 (German, in Latin script, Germany, orthography of 1996)
 * 
 *
 * The filtering method will behave as follows:
 *
 * 
 * Filtering method behavior
 * 
 * 
 * Filtering Mode
 * Language Priority List: `"de-DE"`
 * Language Priority List: `"de-*-DE"`
 * 
 * 
 * 
 * 
 * 
 * {@link FilteringMode#AUTOSELECT_FILTERING AUTOSELECT_FILTERING}
 * 
 * 
 * Performs basic filtering and returns `"de-DE"` and
 * `"de-DE-1996"`.
 * 
 * 
 * Performs extended filtering and returns `"de-DE"`,
 * `"de-Deva-DE"`, `"de-DE-1996"`, `"de-Latn-DE"`, and
 * `"de-Latn-DE-1996"`.
 * 
 * 
 * 
 * 
 * {@link FilteringMode#EXTENDED_FILTERING EXTENDED_FILTERING}
 * 
 * 
 * Performs extended filtering and returns `"de-DE"`,
 * `"de-Deva-DE"`, `"de-DE-1996"`, `"de-Latn-DE"`, and
 * `"de-Latn-DE-1996"`.
 * 
 * Same as above.
 * 
 * 
 * 
 * {@link FilteringMode#IGNORE_EXTENDED_RANGES IGNORE_EXTENDED_RANGES}
 * 
 * 
 * Performs basic filtering and returns `"de-DE"` and
 * `"de-DE-1996"`.
 * 
 * 
 * Performs basic filtering and returns `null` because
 * nothing matches.
 * 
 * 
 * 
 * 
 * {@link FilteringMode#MAP_EXTENDED_RANGES MAP_EXTENDED_RANGES}
 * 
 * Same as above.
 * 
 * Performs basic filtering and returns `"de-DE"` and
 * `"de-DE-1996"` because `"de-*-DE"` is mapped to
 * `"de-DE"`.
 * 
 * 
 * 
 * 
 * {@link FilteringMode#REJECT_EXTENDED_RANGES REJECT_EXTENDED_RANGES}
 * 
 * Same as above.
 * 
 * Throws {@link IllegalArgumentException} because `"de-*-DE"` is
 * not a valid basic language range.
 * 
 * 
 * 
 * 
 *
 * @see #filter(List, Collection, FilteringMode)
 * @see #filterTags(List, Collection, FilteringMode)
 *
 * @since 1.8
*/
export class FilteringMode extends Enum<FilteringMode> {
  /**
   * Specifies automatic filtering mode based on the given Language
   * Priority List consisting of language ranges. If all of the ranges
   * are basic, basic filtering is selected. Otherwise, extended
   * filtering is selected.
  */
  static readonly AUTOSELECT_FILTERING: FilteringMode;
  /**
   * Specifies extended filtering.
  */
  static readonly EXTENDED_FILTERING: FilteringMode;
  /**
   * Specifies basic filtering: Note that any extended language ranges
   * included in the given Language Priority List are ignored.
  */
  static readonly IGNORE_EXTENDED_RANGES: FilteringMode;
  /**
   * Specifies basic filtering: If any extended language ranges are
   * included in the given Language Priority List, they are mapped to the
   * basic language range. Specifically, a language range starting with a
   * subtag `"*"` is treated as a language range `"*"`. For
   * example, `"*-US"` is treated as `"*"`. If `"*"` is
   * not the first subtag, `"*"` and extra `"-"` are removed.
   * For example, `"ja-*-JP"` is mapped to `"ja-JP"`.
  */
  static readonly MAP_EXTENDED_RANGES: FilteringMode;
  /**
   * Specifies basic filtering: If any extended language ranges are
   * included in the given Language Priority List, the list is rejected
   * and the filtering method throws {@link IllegalArgumentException}.
  */
  static readonly REJECT_EXTENDED_RANGES: FilteringMode;
  static valueOf(name: string): FilteringMode;
  static values(): FilteringMode[];
}
/**
 * This class expresses a Language Range defined in
 * RFC 4647 Matching of
 * Language Tags. A language range is an identifier which is used to
 * select language tag(s) meeting specific requirements by using the
 * mechanisms described in Locale
 * Matching. A list which represents a user's preferences and consists
 * of language ranges is called a Language Priority List.
 *
 * There are two types of language ranges: basic and extended. In RFC
 * 4647, the syntax of language ranges is expressed in
 * ABNF as follows:
 * 
 *      *     basic-language-range    = (1*8ALPHA *("-" 1*8alphanum)) / "*"
 *     extended-language-range = (1*8ALPHA / "*")
 *                               *("-" (1*8alphanum / "*"))
 *     alphanum                = ALPHA / DIGIT
 * 
 * 
 * For example, `"en"` (English), `"ja-JP"` (Japanese, Japan),
 * `"*"` (special language range which matches any language tag) are
 * basic language ranges, whereas `"*-CH"` (any languages,
 * Switzerland), `"es-*"` (Spanish, any regions), and
 * `"zh-Hant-*"` (Traditional Chinese, any regions) are extended
 * language ranges.
 *
 * @see #filter
 * @see #filterTags
 * @see #lookup
 * @see #lookupTag
 *
 * @since 1.8
*/
export class LanguageRange {
  /**
   * A constant holding the maximum value of weight, 1.0, which indicates
   * that the language range is a good fit for the user.
  */
  static readonly MAX_WEIGHT: number;
  /**
   * A constant holding the minimum value of weight, 0.0, which indicates
   * that the language range is not a good fit for the user.
  */
  static readonly MIN_WEIGHT: number;
  /**
   * Constructs a `LanguageRange` using the given `range`.
   * Note that no validation is done against the IANA Language Subtag
   * Registry at time of construction.
   *
   * This is equivalent to `LanguageRange(range, MAX_WEIGHT)`.
   *
   * @param range a language range
   * @throws NullPointerException if the given `range` is
   *     `null`
   * @throws IllegalArgumentException if the given `range` does not
   * comply with the syntax of the language range mentioned in RFC 4647
  */
  constructor(range: string);
  /**
   * Constructs a `LanguageRange` using the given `range` and
   * `weight`. Note that no validation is done against the IANA
   * Language Subtag Registry at time of construction.
   *
   * @param range  a language range
   * @param weight a weight value between `MIN_WEIGHT` and
   *     `MAX_WEIGHT`
   * @throws NullPointerException if the given `range` is
   *     `null`
   * @throws IllegalArgumentException if the given `range` does not
   * comply with the syntax of the language range mentioned in RFC 4647
   * or if the given `weight` is less than `MIN_WEIGHT`
   * or greater than `MAX_WEIGHT`
  */
  constructor(range: string, weight: number);
  /**
   * Returns the language range of this `LanguageRange`.
   *
   * @return the language range.
  */
  getRange(): string;
  /**
   * Returns the weight of this `LanguageRange`.
   *
   * @return the weight value.
  */
  getWeight(): number;
  /**
   * Parses the given `ranges` to generate a Language Priority List.
   *
   * This method performs a syntactic check for each language range in
   * the given `ranges` but doesn't do validation using the IANA
   * Language Subtag Registry.
   *
   * The `ranges` to be given can take one of the following
   * forms:
   *
   *          *   "Accept-Language: ja,en;q=0.4"  (weighted list with Accept-Language prefix)
   *   "ja,en;q=0.4"                   (weighted list)
   *   "ja,en"                         (prioritized list)
   * 
   *
   * In a weighted list, each language range is given a weight value.
   * The weight value is identical to the "quality value" in
   * RFC 2616, and it
   * expresses how much the user prefers  the language. A weight value is
   * specified after a corresponding language range followed by
   * `";q="`, and the default weight value is `MAX_WEIGHT`
   * when it is omitted.
   *
   * Unlike a weighted list, language ranges in a prioritized list
   * are sorted in the descending order based on its priority. The first
   * language range has the highest priority and meets the user's
   * preference most.
   *
   * In either case, language ranges are sorted in descending order in
   * the Language Priority List based on priority or weight. If a
   * language range appears in the given `ranges` more than once,
   * only the first one is included on the Language Priority List.
   *
   * The returned list consists of language ranges from the given
   * `ranges` and their equivalents found in the IANA Language
   * Subtag Registry. For example, if the given `ranges` is
   * `"Accept-Language: iw,en-us;q=0.7,en;q=0.3"`, the elements in
   * the list to be returned are:
   *
   *          *  Range                                   Weight
   *    "iw" (older tag for Hebrew)             1.0
   *    "he" (new preferred code for Hebrew)    1.0
   *    "en-us" (English, United States)        0.7
   *    "en" (English)                          0.3
   * 
   *
   * Two language ranges, `"iw"` and `"he"`, have the same
   * highest priority in the list. By adding `"he"` to the user's
   * Language Priority List, locale-matching method can find Hebrew as a
   * matching locale (or language tag) even if the application or system
   * offers only `"he"` as a supported locale (or language tag).
   *
   * @param ranges a list of comma-separated language ranges or a list of
   *     language ranges in the form of the "Accept-Language" header
   *     defined in RFC
   *     2616
   * @return a Language Priority List consisting of language ranges
   *     included in the given `ranges` and their equivalent
   *     language ranges if available. The list is modifiable.
   * @throws NullPointerException if `ranges` is null
   * @throws IllegalArgumentException if a language range or a weight
   *     found in the given `ranges` is ill-formed
  */
  static parse(ranges: string): LanguageRange[];
  /**
   * Parses the given `ranges` to generate a Language Priority
   * List, and then customizes the list using the given `map`.
   * This method is equivalent to
   * `mapEquivalents(parse(ranges), map)`.
   *
   * @param ranges a list of comma-separated language ranges or a list
   *     of language ranges in the form of the "Accept-Language" header
   *     defined in RFC
   *     2616
   * @param map a map containing information to customize language ranges
   * @return a Language Priority List with customization. The list is
   *     modifiable.
   * @throws NullPointerException if `ranges` is null
   * @throws IllegalArgumentException if a language range or a weight
   *     found in the given `ranges` is ill-formed
   * @see #parse(String)
   * @see #mapEquivalents
  */
  static parse(ranges: string, map: Map<string, string[]>): LanguageRange[];
  /**
   * Generates a new customized Language Priority List using the given
   * `priorityList` and `map`. If the given `map` is
   * empty, this method returns a copy of the given `priorityList`.
   *
   * In the map, a key represents a language range whereas a value is
   * a list of equivalents of it. `'*'` cannot be used in the map.
   * Each equivalent language range has the same weight value as its
   * original language range.
   *
   *          *  An example of map:
   *    Key                            Value
   *      "zh" (Chinese)                 "zh",
   *                                     "zh-Hans"(Simplified Chinese)
   *      "zh-HK" (Chinese, Hong Kong)   "zh-HK"
   *      "zh-TW" (Chinese, Taiwan)      "zh-TW"
   * 
   *
   * The customization is performed after modification using the IANA
   * Language Subtag Registry.
   *
   * For example, if a user's Language Priority List consists of five
   * language ranges (`"zh"`, `"zh-CN"`, `"en"`,
   * `"zh-TW"`, and `"zh-HK"`), the newly generated Language
   * Priority List which is customized using the above map example will
   * consists of `"zh"`, `"zh-Hans"`, `"zh-CN"`,
   * `"zh-Hans-CN"`, `"en"`, `"zh-TW"`, and
   * `"zh-HK"`.
   *
   * `"zh-HK"` and `"zh-TW"` aren't converted to
   * `"zh-Hans-HK"` nor `"zh-Hans-TW"` even if they are
   * included in the Language Priority List. In this example, mapping
   * is used to clearly distinguish Simplified Chinese and Traditional
   * Chinese.
   *
   * If the `"zh"`-to-`"zh"` mapping isn't included in the
   * map, a simple replacement will be performed and the customized list
   * won't include `"zh"` and `"zh-CN"`.
   *
   * @param priorityList user's Language Priority List
   * @param map a map containing information to customize language ranges
   * @return a new Language Priority List with customization. The list is
   *     modifiable.
   * @throws NullPointerException if `priorityList` is `null`
   * @see #parse(String, Map)
  */
  static mapEquivalents(priorityList: LanguageRange[], map: Map<string, string[]>): LanguageRange[];
  /**
   * Returns a hash code value for the object.
   *
   * @return  a hash code value for this object.
  */
  hashCode(): number;
  /**
   * Compares this object to the specified object. The result is true if
   * and only if the argument is not `null` and is a
   * `LanguageRange` object that contains the same `range`
   * and `weight` values as this object.
   *
   * @param obj the object to compare with
   * @return  `true` if this object's `range` and
   *     `weight` are the same as the `obj`'s; `false`
   *     otherwise.
  */
  equals(obj: any): boolean;
  /**
   * Returns an informative string representation of this `LanguageRange`
   * object, consisting of language range and weight if the range is
   * weighted and the weight is less than the max weight.
   *
   * @return a string representation of this `LanguageRange` object.
  */
  toString(): string;
}

}
declare module 'java.util.Map' {
import { Comparator } from 'java.util';
/**
 * A map entry (key-value pair).  The `Map.entrySet` method returns
 * a collection-view of the map, whose elements are of this class.  The
 * only way to obtain a reference to a map entry is from the
 * iterator of this collection-view.  These `Map.Entry` objects are
 * valid only for the duration of the iteration; more formally,
 * the behavior of a map entry is undefined if the backing map has been
 * modified after the entry was returned by the iterator, except through
 * the `setValue` operation on the map entry.
 *
 * @see Map#entrySet()
 * @since 1.2
*/
export class Entry<K, V> {
  /**
   * Returns the key corresponding to this entry.
   *
   * @return the key corresponding to this entry
   * @throws IllegalStateException implementations may, but are not
   *         required to, throw this exception if the entry has been
   *         removed from the backing map.
  */
  getKey(): K;
  /**
   * Returns the value corresponding to this entry.  If the mapping
   * has been removed from the backing map (by the iterator's
   * `remove` operation), the results of this call are undefined.
   *
   * @return the value corresponding to this entry
   * @throws IllegalStateException implementations may, but are not
   *         required to, throw this exception if the entry has been
   *         removed from the backing map.
  */
  getValue(): V;
  /**
   * Replaces the value corresponding to this entry with the specified
   * value (optional operation).  (Writes through to the map.)  The
   * behavior of this call is undefined if the mapping has already been
   * removed from the map (by the iterator's `remove` operation).
   *
   * @param value new value to be stored in this entry
   * @return old value corresponding to the entry
   * @throws UnsupportedOperationException if the `put` operation
   *         is not supported by the backing map
   * @throws ClassCastException if the class of the specified value
   *         prevents it from being stored in the backing map
   * @throws NullPointerException if the backing map does not permit
   *         null values, and the specified value is null
   * @throws IllegalArgumentException if some property of this value
   *         prevents it from being stored in the backing map
   * @throws IllegalStateException implementations may, but are not
   *         required to, throw this exception if the entry has been
   *         removed from the backing map.
  */
  setValue(value: V);
  /**
   * Compares the specified object with this entry for equality.
   * Returns `true` if the given object is also a map entry and
   * the two entries represent the same mapping.  More formally, two
   * entries `e1` and `e2` represent the same mapping
   * if         *     (e1.getKey()==null ?
   *      e2.getKey()==null : e1.getKey().equals(e2.getKey()))  &&
   *     (e1.getValue()==null ?
   *      e2.getValue()==null : e1.getValue().equals(e2.getValue()))
   * 
   * This ensures that the `equals` method works properly across
   * different implementations of the `Map.Entry` interface.
   *
   * @param o object to be compared for equality with this map entry
   * @return `true` if the specified object is equal to this map
   *         entry
  */
  equals(o: any): boolean;
  /**
   * Returns the hash code value for this map entry.  The hash code
   * of a map entry `e` is defined to be:          *     (e.getKey()==null   ? 0 : e.getKey().hashCode()) ^
   *     (e.getValue()==null ? 0 : e.getValue().hashCode())
   * 
   * This ensures that `e1.equals(e2)` implies that
   * `e1.hashCode()==e2.hashCode()` for any two Entries
   * `e1` and `e2`, as required by the general
   * contract of `Object.hashCode`.
   *
   * @return the hash code value for this map entry
   * @see Object#hashCode()
   * @see Object#equals(Object)
   * @see #equals(Object)
  */
  hashCode(): number;
  /**
   * Returns a comparator that compares {@link Map.Entry} in natural order on key.
   *
   * The returned comparator is serializable and throws {@link
   * NullPointerException} when comparing an entry with a null key.
   *
   * @param   the {@link Comparable} type of then map keys
   * @param   the type of the map values
   * @return a comparator that compares {@link Map.Entry} in natural order on key.
   * @see Comparable
   * @since 1.8
  */
  static comparingByKey<K, V>(): Comparator<Entry<K, V>>;
  /**
   * Returns a comparator that compares {@link Map.Entry} in natural order on value.
   *
   * The returned comparator is serializable and throws {@link
   * NullPointerException} when comparing an entry with null values.
   *
   * @param  the type of the map keys
   * @param  the {@link Comparable} type of the map values
   * @return a comparator that compares {@link Map.Entry} in natural order on value.
   * @see Comparable
   * @since 1.8
  */
  static comparingByValue<K, V>(): Comparator<Entry<K, V>>;
  /**
   * Returns a comparator that compares {@link Map.Entry} by key using the given
   * {@link Comparator}.
   *
   * The returned comparator is serializable if the specified comparator
   * is also serializable.
   *
   * @param   the type of the map keys
   * @param   the type of the map values
   * @param  cmp the key {@link Comparator}
   * @return a comparator that compares {@link Map.Entry} by the key.
   * @since 1.8
  */
  static comparingByKey<K, V>(cmp: Comparator<any>): Comparator<Entry<K, V>>;
  /**
   * Returns a comparator that compares {@link Map.Entry} by value using the given
   * {@link Comparator}.
   *
   * The returned comparator is serializable if the specified comparator
   * is also serializable.
   *
   * @param   the type of the map keys
   * @param   the type of the map values
   * @param  cmp the value {@link Comparator}
   * @return a comparator that compares {@link Map.Entry} by the value.
   * @since 1.8
  */
  static comparingByValue<K, V>(cmp: Comparator<any>): Comparator<Entry<K, V>>;
}

}
declare module 'java.util.stream.Collector' {
import { Enum } from 'java.lang';
/**
 * Characteristics indicating properties of a `Collector`, which can
 * be used to optimize reduction implementations.
*/
export class Characteristics extends Enum<Characteristics> {
  /**
   * Indicates that this collector is concurrent, meaning that
   * the result container can support the accumulator function being
   * called concurrently with the same result container from multiple
   * threads.
   *
   * If a `CONCURRENT` collector is not also `UNORDERED`,
   * then it should only be evaluated concurrently if applied to an
   * unordered data source.
  */
  static readonly CONCURRENT: Characteristics;
  /**
   * Indicates that the collection operation does not commit to preserving
   * the encounter order of input elements.  (This might be true if the
   * result container has no intrinsic order, such as a {@link Set}.)
  */
  static readonly UNORDERED: Characteristics;
  /**
   * Indicates that the finisher function is the identity function and
   * can be elided.  If set, it must be the case that an unchecked cast
   * from A to R will succeed.
  */
  static readonly IDENTITY_FINISH: Characteristics;
  static valueOf(name: string): Characteristics;
  static values(): Characteristics[];
}

}
declare module 'java.util.ServiceLoader' {
import { Class } from 'java.lang';
import { Supplier } from 'java.util.function';
/**
 * Represents a service provider located by `ServiceLoader`.
 *
 *  When using a loader's {@link ServiceLoader#stream() stream()} method
 * then the elements are of type `Provider`. This allows processing
 * to select or filter on the provider class without instantiating the
 * provider. 
 *
 * @param   The service type
 * @since 9
*/
export class Provider<S> extends Supplier<S> {
  /**
   * Returns the provider type. There is no guarantee that this type is
   * accessible or that it has a public no-args constructor. The {@link
   * #get() get()} method should be used to obtain the provider instance.
   *
   *  When a module declares that the provider class is created by a
   * provider factory then this method returns the return type of its
   * public static "`provider()`" method.
   *
   * @return The provider type
  */
  type(): Class<S>;
  /**
   * Returns an instance of the provider.
   *
   * @return An instance of the provider.
   *
   * @throws ServiceConfigurationError
   *         If the service provider cannot be instantiated, or in the
   *         case of a provider factory, the public static
   *         "`provider()`" method returns `null` or throws
   *         an error or exception. The `ServiceConfigurationError`
   *         will carry an appropriate cause where possible.
  */
  get(): S;
}

}
declare module 'java.util.jar.Attributes' {
import { Map } from 'java.util';
/**
 * The Attributes.Name class represents an attribute name stored in
 * this Map. Valid attribute names are case-insensitive, are restricted
 * to the ASCII characters in the set [0-9a-zA-Z_-], and cannot exceed
 * 70 characters in length. Attribute values can contain any characters
 * and will be UTF8-encoded when written to the output stream.  See the
 * JAR File Specification
 * for more information about valid attribute names and values.
*/
export class Name {
  /**
   * Constructs a new attribute name using the given string name.
   *
   * @param name the attribute string name
   * @throws    IllegalArgumentException if the attribute name was
   *            invalid
   * @throws    NullPointerException if the attribute name was null
  */
  constructor(name: string);
  /**
   * Compares this attribute name to another for equality.
   * @param o the object to compare
   * @return true if this attribute name is equal to the
   *         specified attribute object
  */
  equals(o: any): boolean;
  /**
   * Computes the hash value for this attribute name.
  */
  hashCode(): number;
  /**
   * Returns the attribute name as a String.
  */
  toString(): string;
  /**
   * `Name` object for `Manifest-Version`
   * manifest attribute. This attribute indicates the version number
   * of the manifest standard to which a JAR file's manifest conforms.
   * @see 
   *      Manifest and Signature Specification
  */
  static readonly MANIFEST_VERSION: Name;
  /**
   * `Name` object for `Signature-Version`
   * manifest attribute used when signing JAR files.
   * @see 
   *      Manifest and Signature Specification
  */
  static readonly SIGNATURE_VERSION: Name;
  /**
   * `Name` object for `Content-Type`
   * manifest attribute.
  */
  static readonly CONTENT_TYPE: Name;
  /**
   * `Name` object for `Class-Path`
   * manifest attribute.
   * @see 
   *      JAR file specification
  */
  static readonly CLASS_PATH: Name;
  /**
   * `Name` object for `Main-Class` manifest
   * attribute used for launching applications packaged in JAR files.
   * The `Main-Class` attribute is used in conjunction
   * with the `-jar` command-line option of the
   * `java` application launcher.
  */
  static readonly MAIN_CLASS: Name;
  /**
   * `Name` object for `Sealed` manifest attribute
   * used for sealing.
   * @see 
   *      Package Sealing
  */
  static readonly SEALED: Name;
  /**
   * `Name` object for `Extension-List` manifest attribute
   * used for the extension mechanism that is no longer supported.
  */
  static readonly EXTENSION_LIST: Name;
  /**
   * `Name` object for `Extension-Name` manifest attribute
   * used for the extension mechanism that is no longer supported.
  */
  static readonly EXTENSION_NAME: Name;
  /**
   * `Name` object for `Extension-Installation` manifest attribute.
   *
   * @deprecated Extension mechanism is no longer supported.
  */
  static readonly EXTENSION_INSTALLATION: Name;
  /**
   * `Name` object for `Implementation-Title`
   * manifest attribute used for package versioning.
  */
  static readonly IMPLEMENTATION_TITLE: Name;
  /**
   * `Name` object for `Implementation-Version`
   * manifest attribute used for package versioning.
  */
  static readonly IMPLEMENTATION_VERSION: Name;
  /**
   * `Name` object for `Implementation-Vendor`
   * manifest attribute used for package versioning.
  */
  static readonly IMPLEMENTATION_VENDOR: Name;
  /**
   * `Name` object for `Implementation-Vendor-Id`
   * manifest attribute.
   *
   * @deprecated Extension mechanism is no longer supported.
  */
  static readonly IMPLEMENTATION_VENDOR_ID: Name;
  /**
   * `Name` object for `Implementation-URL`
   * manifest attribute.
   *
   * @deprecated Extension mechanism is no longer supported.
  */
  static readonly IMPLEMENTATION_URL: Name;
  /**
   * `Name` object for `Specification-Title`
   * manifest attribute used for package versioning.
  */
  static readonly SPECIFICATION_TITLE: Name;
  /**
   * `Name` object for `Specification-Version`
   * manifest attribute used for package versioning.
  */
  static readonly SPECIFICATION_VERSION: Name;
  /**
   * `Name` object for `Specification-Vendor`
   * manifest attribute used for package versioning.
  */
  static readonly SPECIFICATION_VENDOR: Name;
  /**
   * `Name` object for `Multi-Release`
   * manifest attribute that indicates this is a multi-release JAR file.
   *
   * @since   9
  */
  static readonly MULTI_RELEASE: Name;
}

}
declare module 'java.util.stream.DoubleStream' {
import { DoubleStream } from 'java.util.stream';
import { DoubleConsumer } from 'java.util.function';
/**
 * A mutable builder for a `DoubleStream`.
 *
 * A stream builder has a lifecycle, which starts in a building
 * phase, during which elements can be added, and then transitions to a built
 * phase, after which elements may not be added.  The built phase
 * begins when the {@link #build()} method is called, which creates an
 * ordered stream whose elements are the elements that were added to the
 * stream builder, in the order they were added.
 *
 * @see DoubleStream#builder()
 * @since 1.8
*/
export class Builder extends DoubleConsumer {
  /**
   * Adds an element to the stream being built.
   *
   * @throws IllegalStateException if the builder has already transitioned
   * to the built state
  */
  accept(t: number): void;
  /**
   * Adds an element to the stream being built.
   *
   * @implSpec
   * The default implementation behaves as if:
   * {@code
   *     accept(t)
   *     return this;
   * }
   *
   * @param t the element to add
   * @return `this` builder
   * @throws IllegalStateException if the builder has already transitioned
   * to the built state
  */
  add(t: number): Builder;
  /**
   * Builds the stream, transitioning this builder to the built state.
   * An `IllegalStateException` is thrown if there are further
   * attempts to operate on the builder after it has entered the built
   * state.
   *
   * @return the built stream
   * @throws IllegalStateException if the builder has already transitioned
   * to the built state
  */
  build(): DoubleStream;
}
/**
 * Represents an operation that accepts a `double`-valued argument
 * and a DoubleConsumer, and returns no result. This functional interface is
 * used by {@link DoubleStream#mapMulti(DoubleMapMultiConsumer) DoubleStream.mapMulti}
 * to replace a double value with zero or more double values.
 *
 * This is a functional interface
 * whose functional method is {@link #accept(double, DoubleConsumer)}.
 *
 * @see DoubleStream#mapMulti(DoubleMapMultiConsumer)
 *
 * @since 16
*/
export class DoubleMapMultiConsumer {
  /**
   * Replaces the given `value` with zero or more values by feeding the mapped
   * values to the `dc` consumer.
   *
   * @param value the double value coming from upstream
   * @param dc a `DoubleConsumer` accepting the mapped values
  */
  accept(value: number, dc: DoubleConsumer): void;
}

}
declare module 'java.util.Base64' {
import { InputStream, OutputStream } from 'java.io';
import { ByteBuffer } from 'java.nio';
/**
 * This class implements an encoder for encoding byte data using
 * the Base64 encoding scheme as specified in RFC 4648 and RFC 2045.
 *
 *  Instances of {@link Encoder} class are safe for use by
 * multiple concurrent threads.
 *
 *  Unless otherwise noted, passing a `null` argument to
 * a method of this class will cause a
 * {@link java.lang.NullPointerException NullPointerException} to
 * be thrown.
 *  If the encoded byte output of the needed size can not
 *     be allocated, the encode methods of this class will
 *     cause an {@link java.lang.OutOfMemoryError OutOfMemoryError}
 *     to be thrown.
 *
 * @see     Decoder
 * @since   1.8
*/
export class Encoder {
  /**
   * Encodes all bytes from the specified byte array into a newly-allocated
   * byte array using the {@link Base64} encoding scheme. The returned byte
   * array is of the length of the resulting bytes.
   *
   * @param   src
   *          the byte array to encode
   * @return  A newly-allocated byte array containing the resulting
   *          encoded bytes.
  */
  encode(src: number[]): number[];
  /**
   * Encodes all bytes from the specified byte array using the
   * {@link Base64} encoding scheme, writing the resulting bytes to the
   * given output byte array, starting at offset 0.
   *
   *  It is the responsibility of the invoker of this method to make
   * sure the output byte array `dst` has enough space for encoding
   * all bytes from the input byte array. No bytes will be written to the
   * output byte array if the output byte array is not big enough.
   *
   * @param   src
   *          the byte array to encode
   * @param   dst
   *          the output byte array
   * @return  The number of bytes written to the output byte array
   *
   * @throws  IllegalArgumentException if `dst` does not have enough
   *          space for encoding all input bytes.
  */
  encode(src: number[], dst: number[]): number;
  /**
   * Encodes the specified byte array into a String using the {@link Base64}
   * encoding scheme.
   *
   *  This method first encodes all input bytes into a base64 encoded
   * byte array and then constructs a new String by using the encoded byte
   * array and the {@link java.nio.charset.StandardCharsets#ISO_8859_1
   * ISO-8859-1} charset.
   *
   *  In other words, an invocation of this method has exactly the same
   * effect as invoking
   * `new String(encode(src), StandardCharsets.ISO_8859_1)`.
   *
   * @param   src
   *          the byte array to encode
   * @return  A String containing the resulting Base64 encoded characters
  */
  encodeToString(src: number[]): string;
  /**
   * Encodes all remaining bytes from the specified byte buffer into
   * a newly-allocated ByteBuffer using the {@link Base64} encoding
   * scheme.
   *
   * Upon return, the source buffer's position will be updated to
   * its limit; its limit will not have been changed. The returned
   * output buffer's position will be zero and its limit will be the
   * number of resulting encoded bytes.
   *
   * @param   buffer
   *          the source ByteBuffer to encode
   * @return  A newly-allocated byte buffer containing the encoded bytes.
  */
  encode(buffer: ByteBuffer): ByteBuffer;
  /**
   * Wraps an output stream for encoding byte data using the {@link Base64}
   * encoding scheme.
   *
   *  It is recommended to promptly close the returned output stream after
   * use, during which it will flush all possible leftover bytes to the underlying
   * output stream. Closing the returned output stream will close the underlying
   * output stream.
   *
   * @param   os
   *          the output stream.
   * @return  the output stream for encoding the byte data into the
   *          specified Base64 encoded format
  */
  wrap(os: OutputStream): OutputStream;
  /**
   * Returns an encoder instance that encodes equivalently to this one,
   * but without adding any padding character at the end of the encoded
   * byte data.
   *
   *  The encoding scheme of this encoder instance is unaffected by
   * this invocation. The returned encoder instance should be used for
   * non-padding encoding operation.
   *
   * @return an equivalent encoder that encodes without adding any
   *         padding character at the end
  */
  withoutPadding(): Encoder;
}
/**
 * This class implements a decoder for decoding byte data using the
 * Base64 encoding scheme as specified in RFC 4648 and RFC 2045.
 *
 *  The Base64 padding character `'='` is accepted and
 * interpreted as the end of the encoded byte data, but is not
 * required. So if the final unit of the encoded byte data only has
 * two or three Base64 characters (without the corresponding padding
 * character(s) padded), they are decoded as if followed by padding
 * character(s). If there is a padding character present in the
 * final unit, the correct number of padding character(s) must be
 * present, otherwise `IllegalArgumentException` (
 * `IOException` when reading from a Base64 stream) is thrown
 * during decoding.
 *
 *  Instances of {@link Decoder} class are safe for use by
 * multiple concurrent threads.
 *
 *  Unless otherwise noted, passing a `null` argument to
 * a method of this class will cause a
 * {@link java.lang.NullPointerException NullPointerException} to
 * be thrown.
 *  If the decoded byte output of the needed size can not
 *     be allocated, the decode methods of this class will
 *     cause an {@link java.lang.OutOfMemoryError OutOfMemoryError}
 *     to be thrown.
 *
 * @see     Encoder
 * @since   1.8
*/
export class Decoder {
  /**
   * Decodes all bytes from the input byte array using the {@link Base64}
   * encoding scheme, writing the results into a newly-allocated output
   * byte array. The returned byte array is of the length of the resulting
   * bytes.
   *
   * @param   src
   *          the byte array to decode
   *
   * @return  A newly-allocated byte array containing the decoded bytes.
   *
   * @throws  IllegalArgumentException
   *          if `src` is not in valid Base64 scheme
  */
  decode(src: number[]): number[];
  /**
   * Decodes a Base64 encoded String into a newly-allocated byte array
   * using the {@link Base64} encoding scheme.
   *
   *  An invocation of this method has exactly the same effect as invoking
   * `decode(src.getBytes(StandardCharsets.ISO_8859_1))`
   *
   * @param   src
   *          the string to decode
   *
   * @return  A newly-allocated byte array containing the decoded bytes.
   *
   * @throws  IllegalArgumentException
   *          if `src` is not in valid Base64 scheme
  */
  decode(src: string): number[];
  /**
   * Decodes all bytes from the input byte array using the {@link Base64}
   * encoding scheme, writing the results into the given output byte array,
   * starting at offset 0.
   *
   *  It is the responsibility of the invoker of this method to make
   * sure the output byte array `dst` has enough space for decoding
   * all bytes from the input byte array. No bytes will be written to
   * the output byte array if the output byte array is not big enough.
   *
   *  If the input byte array is not in valid Base64 encoding scheme
   * then some bytes may have been written to the output byte array before
   * IllegalargumentException is thrown.
   *
   * @param   src
   *          the byte array to decode
   * @param   dst
   *          the output byte array
   *
   * @return  The number of bytes written to the output byte array
   *
   * @throws  IllegalArgumentException
   *          if `src` is not in valid Base64 scheme, or `dst`
   *          does not have enough space for decoding all input bytes.
  */
  decode(src: number[], dst: number[]): number;
  /**
   * Decodes all bytes from the input byte buffer using the {@link Base64}
   * encoding scheme, writing the results into a newly-allocated ByteBuffer.
   *
   *  Upon return, the source buffer's position will be updated to
   * its limit; its limit will not have been changed. The returned
   * output buffer's position will be zero and its limit will be the
   * number of resulting decoded bytes
   *
   *  `IllegalArgumentException` is thrown if the input buffer
   * is not in valid Base64 encoding scheme. The position of the input
   * buffer will not be advanced in this case.
   *
   * @param   buffer
   *          the ByteBuffer to decode
   *
   * @return  A newly-allocated byte buffer containing the decoded bytes
   *
   * @throws  IllegalArgumentException
   *          if `buffer` is not in valid Base64 scheme
  */
  decode(buffer: ByteBuffer): ByteBuffer;
  /**
   * Returns an input stream for decoding {@link Base64} encoded byte stream.
   *
   *  The `read`  methods of the returned `InputStream` will
   * throw `IOException` when reading bytes that cannot be decoded.
   *
   *  Closing the returned input stream will close the underlying
   * input stream.
   *
   * @param   is
   *          the input stream
   *
   * @return  the input stream for decoding the specified Base64 encoded
   *          byte stream
  */
  wrap(is: InputStream): InputStream;
}

}
declare module 'java.util.stream.Stream' {
import { Stream } from 'java.util.stream';
import { Consumer } from 'java.util.function';
/**
 * A mutable builder for a `Stream`.  This allows the creation of a
 * `Stream` by generating elements individually and adding them to the
 * `Builder` (without the copying overhead that comes from using
 * an `ArrayList` as a temporary buffer.)
 *
 * A stream builder has a lifecycle, which starts in a building
 * phase, during which elements can be added, and then transitions to a built
 * phase, after which elements may not be added.  The built phase begins
 * when the {@link #build()} method is called, which creates an ordered
 * `Stream` whose elements are the elements that were added to the stream
 * builder, in the order they were added.
 *
 * @param  the type of stream elements
 * @see Stream#builder()
 * @since 1.8
*/
export class Builder<T> extends Consumer<T> {
  /**
   * Adds an element to the stream being built.
   *
   * @throws IllegalStateException if the builder has already transitioned to
   * the built state
  */
  accept(t: T): void;
  /**
   * Adds an element to the stream being built.
   *
   * @implSpec
   * The default implementation behaves as if:
   * {@code
   *     accept(t)
   *     return this;
   * }
   *
   * @param t the element to add
   * @return `this` builder
   * @throws IllegalStateException if the builder has already transitioned to
   * the built state
  */
  add(t: T): Builder<T>;
  /**
   * Builds the stream, transitioning this builder to the built state.
   * An `IllegalStateException` is thrown if there are further attempts
   * to operate on the builder after it has entered the built state.
   *
   * @return the built stream
   * @throws IllegalStateException if the builder has already transitioned to
   * the built state
  */
  build(): Stream<T>;
}

}
declare module 'java.util.function' {
import { Comparator } from 'java.util';
/**
 * Represents an operation on a single `int`-valued operand that produces
 * an `int`-valued result.  This is the primitive type specialization of
 * {@link UnaryOperator} for `int`.
 *
 * This is a functional interface
 * whose functional method is {@link #applyAsInt(int)}.
 *
 * @see UnaryOperator
 * @since 1.8
*/
export class IntUnaryOperator {
  /**
   * Applies this operator to the given operand.
   *
   * @param operand the operand
   * @return the operator result
  */
  applyAsInt(operand: number): number;
  /**
   * Returns a composed operator that first applies the `before`
   * operator to its input, and then applies this operator to the result.
   * If evaluation of either operator throws an exception, it is relayed to
   * the caller of the composed operator.
   *
   * @param before the operator to apply before this operator is applied
   * @return a composed operator that first applies the `before`
   * operator and then applies this operator
   * @throws NullPointerException if before is null
   *
   * @see #andThen(IntUnaryOperator)
  */
  compose(before: IntUnaryOperator): IntUnaryOperator;
  /**
   * Returns a composed operator that first applies this operator to
   * its input, and then applies the `after` operator to the result.
   * If evaluation of either operator throws an exception, it is relayed to
   * the caller of the composed operator.
   *
   * @param after the operator to apply after this operator is applied
   * @return a composed operator that first applies this operator and then
   * applies the `after` operator
   * @throws NullPointerException if after is null
   *
   * @see #compose(IntUnaryOperator)
  */
  andThen(after: IntUnaryOperator): IntUnaryOperator;
  /**
   * Returns a unary operator that always returns its input argument.
   *
   * @return a unary operator that always returns its input argument
  */
  static identity(): IntUnaryOperator;
}
/**
 * Represents a function that produces a double-valued result.  This is the
 * `double`-producing primitive specialization for {@link Function}.
 *
 * This is a functional interface
 * whose functional method is {@link #applyAsDouble(Object)}.
 *
 * @param  the type of the input to the function
 *
 * @see Function
 * @since 1.8
*/
export class ToDoubleFunction<T> {
  /**
   * Applies this function to the given argument.
   *
   * @param value the function argument
   * @return the function result
  */
  applyAsDouble(value: T): number;
}
/**
 * Represents a supplier of results.
 *
 * There is no requirement that a new or distinct result be returned each
 * time the supplier is invoked.
 *
 * This is a functional interface
 * whose functional method is {@link #get()}.
 *
 * @param  the type of results supplied by this supplier
 *
 * @since 1.8
*/
export class Supplier<T> {
  /**
   * Gets a result.
   *
   * @return a result
  */
  get(): T;
}
/**
 * Represents a function that accepts two arguments and produces a long-valued
 * result.  This is the `long`-producing primitive specialization for
 * {@link BiFunction}.
 *
 * This is a functional interface
 * whose functional method is {@link #applyAsLong(Object, Object)}.
 *
 * @param  the type of the first argument to the function
 * @param  the type of the second argument to the function
 *
 * @see BiFunction
 * @since 1.8
*/
export class ToLongBiFunction<T, U> {
  /**
   * Applies this function to the given arguments.
   *
   * @param t the first function argument
   * @param u the second function argument
   * @return the function result
  */
  applyAsLong(t: T, u: U): number;
}
/**
 * Represents a function that produces an int-valued result.  This is the
 * `int`-producing primitive specialization for {@link Function}.
 *
 * This is a functional interface
 * whose functional method is {@link #applyAsInt(Object)}.
 *
 * @param  the type of the input to the function
 *
 * @see Function
 * @since 1.8
*/
export class ToIntFunction<T> {
  /**
   * Applies this function to the given argument.
   *
   * @param value the function argument
   * @return the function result
  */
  applyAsInt(value: T): number;
}
/**
 * Represents a function that accepts an int-valued argument and produces a
 * long-valued result.  This is the `int`-to-`long` primitive
 * specialization for {@link Function}.
 *
 * This is a functional interface
 * whose functional method is {@link #applyAsLong(int)}.
 *
 * @see Function
 * @since 1.8
*/
export class IntToLongFunction {
  /**
   * Applies this function to the given argument.
   *
   * @param value the function argument
   * @return the function result
  */
  applyAsLong(value: number): number;
}
/**
 * Represents a function that produces a long-valued result.  This is the
 * `long`-producing primitive specialization for {@link Function}.
 *
 * This is a functional interface
 * whose functional method is {@link #applyAsLong(Object)}.
 *
 * @param  the type of the input to the function
 *
 * @see Function
 * @since 1.8
*/
export class ToLongFunction<T> {
  /**
   * Applies this function to the given argument.
   *
   * @param value the function argument
   * @return the function result
  */
  applyAsLong(value: T): number;
}
/**
 * Represents a function that accepts a long-valued argument and produces a
 * double-valued result.  This is the `long`-to-`double` primitive
 * specialization for {@link Function}.
 *
 * This is a functional interface
 * whose functional method is {@link #applyAsDouble(long)}.
 *
 * @see Function
 * @since 1.8
*/
export class LongToDoubleFunction {
  /**
   * Applies this function to the given argument.
   *
   * @param value the function argument
   * @return the function result
  */
  applyAsDouble(value: number): number;
}
/**
 * Represents a function that accepts a double-valued argument and produces an
 * int-valued result.  This is the `double`-to-`int` primitive
 * specialization for {@link Function}.
 *
 * This is a functional interface
 * whose functional method is {@link #applyAsInt(double)}.
 *
 * @see Function
 * @since 1.8
*/
export class DoubleToIntFunction {
  /**
   * Applies this function to the given argument.
   *
   * @param value the function argument
   * @return the function result
  */
  applyAsInt(value: number): number;
}
/**
 * Represents a function that accepts one argument and produces a result.
 *
 * This is a functional interface
 * whose functional method is {@link #apply(Object)}.
 *
 * @param  the type of the input to the function
 * @param  the type of the result of the function
 *
 * @since 1.8
*/
export class Function<T, R> {
  /**
   * Applies this function to the given argument.
   *
   * @param t the function argument
   * @return the function result
  */
  apply(t: T): R;
  /**
   * Returns a composed function that first applies the `before`
   * function to its input, and then applies this function to the result.
   * If evaluation of either function throws an exception, it is relayed to
   * the caller of the composed function.
   *
   * @param  the type of input to the `before` function, and to the
   *           composed function
   * @param before the function to apply before this function is applied
   * @return a composed function that first applies the `before`
   * function and then applies this function
   * @throws NullPointerException if before is null
   *
   * @see #andThen(Function)
  */
  compose<V>(before: Function<any, T>): Function<V, R>;
  /**
   * Returns a composed function that first applies this function to
   * its input, and then applies the `after` function to the result.
   * If evaluation of either function throws an exception, it is relayed to
   * the caller of the composed function.
   *
   * @param  the type of output of the `after` function, and of the
   *           composed function
   * @param after the function to apply after this function is applied
   * @return a composed function that first applies this function and then
   * applies the `after` function
   * @throws NullPointerException if after is null
   *
   * @see #compose(Function)
  */
  andThen<V>(after: Function<any, V>): Function<T, V>;
  /**
   * Returns a function that always returns its input argument.
   *
   * @param  the type of the input and output objects to the function
   * @return a function that always returns its input argument
  */
  static identity<T>(): Function<T, T>;
}
/**
 * Represents a predicate (boolean-valued function) of two arguments.  This is
 * the two-arity specialization of {@link Predicate}.
 *
 * This is a functional interface
 * whose functional method is {@link #test(Object, Object)}.
 *
 * @param  the type of the first argument to the predicate
 * @param  the type of the second argument the predicate
 *
 * @see Predicate
 * @since 1.8
*/
export class BiPredicate<T, U> {
  /**
   * Evaluates this predicate on the given arguments.
   *
   * @param t the first input argument
   * @param u the second input argument
   * @return `true` if the input arguments match the predicate,
   * otherwise `false`
  */
  test(t: T, u: U): boolean;
  /**
   * Returns a composed predicate that represents a short-circuiting logical
   * AND of this predicate and another.  When evaluating the composed
   * predicate, if this predicate is `false`, then the `other`
   * predicate is not evaluated.
   *
   * Any exceptions thrown during evaluation of either predicate are relayed
   * to the caller; if evaluation of this predicate throws an exception, the
   * `other` predicate will not be evaluated.
   *
   * @param other a predicate that will be logically-ANDed with this
   *              predicate
   * @return a composed predicate that represents the short-circuiting logical
   * AND of this predicate and the `other` predicate
   * @throws NullPointerException if other is null
  */
  and(other: BiPredicate<any, any>): BiPredicate<T, U>;
  /**
   * Returns a predicate that represents the logical negation of this
   * predicate.
   *
   * @return a predicate that represents the logical negation of this
   * predicate
  */
  negate(): BiPredicate<T, U>;
  /**
   * Returns a composed predicate that represents a short-circuiting logical
   * OR of this predicate and another.  When evaluating the composed
   * predicate, if this predicate is `true`, then the `other`
   * predicate is not evaluated.
   *
   * Any exceptions thrown during evaluation of either predicate are relayed
   * to the caller; if evaluation of this predicate throws an exception, the
   * `other` predicate will not be evaluated.
   *
   * @param other a predicate that will be logically-ORed with this
   *              predicate
   * @return a composed predicate that represents the short-circuiting logical
   * OR of this predicate and the `other` predicate
   * @throws NullPointerException if other is null
  */
  or(other: BiPredicate<any, any>): BiPredicate<T, U>;
}
/**
 * Represents a function that accepts a long-valued argument and produces a
 * result.  This is the `long`-consuming primitive specialization for
 * {@link Function}.
 *
 * This is a functional interface
 * whose functional method is {@link #apply(long)}.
 *
 * @param  the type of the result of the function
 *
 * @see Function
 * @since 1.8
*/
export class LongFunction<R> {
  /**
   * Applies this function to the given argument.
   *
   * @param value the function argument
   * @return the function result
  */
  apply(value: number): R;
}
/**
 * Represents an operation that accepts a single `long`-valued argument and
 * returns no result.  This is the primitive type specialization of
 * {@link Consumer} for `long`.  Unlike most other functional interfaces,
 * `LongConsumer` is expected to operate via side-effects.
 *
 * This is a functional interface
 * whose functional method is {@link #accept(long)}.
 *
 * @see Consumer
 * @since 1.8
*/
export class LongConsumer {
  /**
   * Performs this operation on the given argument.
   *
   * @param value the input argument
  */
  accept(value: number): void;
  /**
   * Returns a composed `LongConsumer` that performs, in sequence, this
   * operation followed by the `after` operation. If performing either
   * operation throws an exception, it is relayed to the caller of the
   * composed operation.  If performing this operation throws an exception,
   * the `after` operation will not be performed.
   *
   * @param after the operation to perform after this operation
   * @return a composed `LongConsumer` that performs in sequence this
   * operation followed by the `after` operation
   * @throws NullPointerException if `after` is null
  */
  andThen(after: LongConsumer): LongConsumer;
}
/**
 * Represents an operation that accepts a single input argument and returns no
 * result. Unlike most other functional interfaces, `Consumer` is expected
 * to operate via side-effects.
 *
 * This is a functional interface
 * whose functional method is {@link #accept(Object)}.
 *
 * @param  the type of the input to the operation
 *
 * @since 1.8
*/
export class Consumer<T> {
  /**
   * Performs this operation on the given argument.
   *
   * @param t the input argument
  */
  accept(t: T): void;
  /**
   * Returns a composed `Consumer` that performs, in sequence, this
   * operation followed by the `after` operation. If performing either
   * operation throws an exception, it is relayed to the caller of the
   * composed operation.  If performing this operation throws an exception,
   * the `after` operation will not be performed.
   *
   * @param after the operation to perform after this operation
   * @return a composed `Consumer` that performs in sequence this
   * operation followed by the `after` operation
   * @throws NullPointerException if `after` is null
  */
  andThen(after: Consumer<any>): Consumer<T>;
}
/**
 * Represents a supplier of `boolean`-valued results.  This is the
 * `boolean`-producing primitive specialization of {@link Supplier}.
 *
 * There is no requirement that a new or distinct result be returned each
 * time the supplier is invoked.
 *
 * This is a functional interface
 * whose functional method is {@link #getAsBoolean()}.
 *
 * @see Supplier
 * @since 1.8
*/
export class BooleanSupplier {
  /**
   * Gets a result.
   *
   * @return a result
  */
  getAsBoolean(): boolean;
}
/**
 * Represents a function that accepts a long-valued argument and produces an
 * int-valued result.  This is the `long`-to-`int` primitive
 * specialization for {@link Function}.
 *
 * This is a functional interface
 * whose functional method is {@link #applyAsInt(long)}.
 *
 * @see Function
 * @since 1.8
*/
export class LongToIntFunction {
  /**
   * Applies this function to the given argument.
   *
   * @param value the function argument
   * @return the function result
  */
  applyAsInt(value: number): number;
}
/**
 * Represents a function that accepts two arguments and produces a double-valued
 * result.  This is the `double`-producing primitive specialization for
 * {@link BiFunction}.
 *
 * This is a functional interface
 * whose functional method is {@link #applyAsDouble(Object, Object)}.
 *
 * @param  the type of the first argument to the function
 * @param  the type of the second argument to the function
 *
 * @see BiFunction
 * @since 1.8
*/
export class ToDoubleBiFunction<T, U> {
  /**
   * Applies this function to the given arguments.
   *
   * @param t the first function argument
   * @param u the second function argument
   * @return the function result
  */
  applyAsDouble(t: T, u: U): number;
}
/**
 * Represents an operation that accepts an object-valued and a
 * `long`-valued argument, and returns no result.  This is the
 * `(reference, long)` specialization of {@link BiConsumer}.
 * Unlike most other functional interfaces, `ObjLongConsumer` is
 * expected to operate via side-effects.
 *
 * This is a functional interface
 * whose functional method is {@link #accept(Object, long)}.
 *
 * @param  the type of the object argument to the operation
 *
 * @see BiConsumer
 * @since 1.8
*/
export class ObjLongConsumer<T> {
  /**
   * Performs this operation on the given arguments.
   *
   * @param t the first input argument
   * @param value the second input argument
  */
  accept(t: T, value: number): void;
}
/**
 * Represents a function that accepts two arguments and produces an int-valued
 * result.  This is the `int`-producing primitive specialization for
 * {@link BiFunction}.
 *
 * This is a functional interface
 * whose functional method is {@link #applyAsInt(Object, Object)}.
 *
 * @param  the type of the first argument to the function
 * @param  the type of the second argument to the function
 *
 * @see BiFunction
 * @since 1.8
*/
export class ToIntBiFunction<T, U> {
  /**
   * Applies this function to the given arguments.
   *
   * @param t the first function argument
   * @param u the second function argument
   * @return the function result
  */
  applyAsInt(t: T, u: U): number;
}
/**
 * Represents a function that accepts a double-valued argument and produces a
 * long-valued result.  This is the `double`-to-`long` primitive
 * specialization for {@link Function}.
 *
 * This is a functional interface
 * whose functional method is {@link #applyAsLong(double)}.
 *
 * @see Function
 * @since 1.8
*/
export class DoubleToLongFunction {
  /**
   * Applies this function to the given argument.
   *
   * @param value the function argument
   * @return the function result
  */
  applyAsLong(value: number): number;
}
/**
 * Represents a predicate (boolean-valued function) of one `int`-valued
 * argument. This is the `int`-consuming primitive type specialization of
 * {@link Predicate}.
 *
 * This is a functional interface
 * whose functional method is {@link #test(int)}.
 *
 * @see Predicate
 * @since 1.8
*/
export class IntPredicate {
  /**
   * Evaluates this predicate on the given argument.
   *
   * @param value the input argument
   * @return `true` if the input argument matches the predicate,
   * otherwise `false`
  */
  test(value: number): boolean;
  /**
   * Returns a composed predicate that represents a short-circuiting logical
   * AND of this predicate and another.  When evaluating the composed
   * predicate, if this predicate is `false`, then the `other`
   * predicate is not evaluated.
   *
   * Any exceptions thrown during evaluation of either predicate are relayed
   * to the caller; if evaluation of this predicate throws an exception, the
   * `other` predicate will not be evaluated.
   *
   * @param other a predicate that will be logically-ANDed with this
   *              predicate
   * @return a composed predicate that represents the short-circuiting logical
   * AND of this predicate and the `other` predicate
   * @throws NullPointerException if other is null
  */
  and(other: IntPredicate): IntPredicate;
  /**
   * Returns a predicate that represents the logical negation of this
   * predicate.
   *
   * @return a predicate that represents the logical negation of this
   * predicate
  */
  negate(): IntPredicate;
  /**
   * Returns a composed predicate that represents a short-circuiting logical
   * OR of this predicate and another.  When evaluating the composed
   * predicate, if this predicate is `true`, then the `other`
   * predicate is not evaluated.
   *
   * Any exceptions thrown during evaluation of either predicate are relayed
   * to the caller; if evaluation of this predicate throws an exception, the
   * `other` predicate will not be evaluated.
   *
   * @param other a predicate that will be logically-ORed with this
   *              predicate
   * @return a composed predicate that represents the short-circuiting logical
   * OR of this predicate and the `other` predicate
   * @throws NullPointerException if other is null
  */
  or(other: IntPredicate): IntPredicate;
}
/**
 * Represents a predicate (boolean-valued function) of one argument.
 *
 * This is a functional interface
 * whose functional method is {@link #test(Object)}.
 *
 * @param  the type of the input to the predicate
 *
 * @since 1.8
*/
export class Predicate<T> {
  /**
   * Evaluates this predicate on the given argument.
   *
   * @param t the input argument
   * @return `true` if the input argument matches the predicate,
   * otherwise `false`
  */
  test(t: T): boolean;
  /**
   * Returns a composed predicate that represents a short-circuiting logical
   * AND of this predicate and another.  When evaluating the composed
   * predicate, if this predicate is `false`, then the `other`
   * predicate is not evaluated.
   *
   * Any exceptions thrown during evaluation of either predicate are relayed
   * to the caller; if evaluation of this predicate throws an exception, the
   * `other` predicate will not be evaluated.
   *
   * @param other a predicate that will be logically-ANDed with this
   *              predicate
   * @return a composed predicate that represents the short-circuiting logical
   * AND of this predicate and the `other` predicate
   * @throws NullPointerException if other is null
  */
  and(other: Predicate<any>): Predicate<T>;
  /**
   * Returns a predicate that represents the logical negation of this
   * predicate.
   *
   * @return a predicate that represents the logical negation of this
   * predicate
  */
  negate(): Predicate<T>;
  /**
   * Returns a composed predicate that represents a short-circuiting logical
   * OR of this predicate and another.  When evaluating the composed
   * predicate, if this predicate is `true`, then the `other`
   * predicate is not evaluated.
   *
   * Any exceptions thrown during evaluation of either predicate are relayed
   * to the caller; if evaluation of this predicate throws an exception, the
   * `other` predicate will not be evaluated.
   *
   * @param other a predicate that will be logically-ORed with this
   *              predicate
   * @return a composed predicate that represents the short-circuiting logical
   * OR of this predicate and the `other` predicate
   * @throws NullPointerException if other is null
  */
  or(other: Predicate<any>): Predicate<T>;
  /**
   * Returns a predicate that tests if two arguments are equal according
   * to {@link Objects#equals(Object, Object)}.
   *
   * @param  the type of arguments to the predicate
   * @param targetRef the object reference with which to compare for equality,
   *               which may be `null`
   * @return a predicate that tests if two arguments are equal according
   * to {@link Objects#equals(Object, Object)}
  */
  static isEqual<T>(targetRef: any): Predicate<T>;
  /**
   * Returns a predicate that is the negation of the supplied predicate.
   * This is accomplished by returning result of the calling
   * `target.negate()`.
   *
   * @param      the type of arguments to the specified predicate
   * @param target  predicate to negate
   *
   * @return a predicate that negates the results of the supplied
   *         predicate
   *
   * @throws NullPointerException if target is null
   *
   * @since 11
  */
  static not<T>(target: Predicate<any>): Predicate<T>;
}
/**
 * Represents an operation upon two `long`-valued operands and producing a
 * `long`-valued result.   This is the primitive type specialization of
 * {@link BinaryOperator} for `long`.
 *
 * This is a functional interface
 * whose functional method is {@link #applyAsLong(long, long)}.
 *
 * @see BinaryOperator
 * @see LongUnaryOperator
 * @since 1.8
*/
export class LongBinaryOperator {
  /**
   * Applies this operator to the given operands.
   *
   * @param left the first operand
   * @param right the second operand
   * @return the operator result
  */
  applyAsLong(left: number, right: number): number;
}
/**
 * Represents an operation that accepts a single `double`-valued argument and
 * returns no result.  This is the primitive type specialization of
 * {@link Consumer} for `double`.  Unlike most other functional interfaces,
 * `DoubleConsumer` is expected to operate via side-effects.
 *
 * This is a functional interface
 * whose functional method is {@link #accept(double)}.
 *
 * @see Consumer
 * @since 1.8
*/
export class DoubleConsumer {
  /**
   * Performs this operation on the given argument.
   *
   * @param value the input argument
  */
  accept(value: number): void;
  /**
   * Returns a composed `DoubleConsumer` that performs, in sequence, this
   * operation followed by the `after` operation. If performing either
   * operation throws an exception, it is relayed to the caller of the
   * composed operation.  If performing this operation throws an exception,
   * the `after` operation will not be performed.
   *
   * @param after the operation to perform after this operation
   * @return a composed `DoubleConsumer` that performs in sequence this
   * operation followed by the `after` operation
   * @throws NullPointerException if `after` is null
  */
  andThen(after: DoubleConsumer): DoubleConsumer;
}
/**
 * Represents an operation that accepts an object-valued and a
 * `double`-valued argument, and returns no result.  This is the
 * `(reference, double)` specialization of {@link BiConsumer}.
 * Unlike most other functional interfaces, `ObjDoubleConsumer` is
 * expected to operate via side-effects.
 *
 * This is a functional interface
 * whose functional method is {@link #accept(Object, double)}.
 *
 * @param  the type of the object argument to the operation
 *
 * @see BiConsumer
 * @since 1.8
*/
export class ObjDoubleConsumer<T> {
  /**
   * Performs this operation on the given arguments.
   *
   * @param t the first input argument
   * @param value the second input argument
  */
  accept(t: T, value: number): void;
}
/**
 * Represents a function that accepts a double-valued argument and produces a
 * result.  This is the `double`-consuming primitive specialization for
 * {@link Function}.
 *
 * This is a functional interface
 * whose functional method is {@link #apply(double)}.
 *
 * @param  the type of the result of the function
 *
 * @see Function
 * @since 1.8
*/
export class DoubleFunction<R> {
  /**
   * Applies this function to the given argument.
   *
   * @param value the function argument
   * @return the function result
  */
  apply(value: number): R;
}
/**
 * Represents a function that accepts an int-valued argument and produces a
 * result.  This is the `int`-consuming primitive specialization for
 * {@link Function}.
 *
 * This is a functional interface
 * whose functional method is {@link #apply(int)}.
 *
 * @param  the type of the result of the function
 *
 * @see Function
 * @since 1.8
*/
export class IntFunction<R> {
  /**
   * Applies this function to the given argument.
   *
   * @param value the function argument
   * @return the function result
  */
  apply(value: number): R;
}
/**
 * Represents an operation on a single `long`-valued operand that produces
 * a `long`-valued result.  This is the primitive type specialization of
 * {@link UnaryOperator} for `long`.
 *
 * This is a functional interface
 * whose functional method is {@link #applyAsLong(long)}.
 *
 * @see UnaryOperator
 * @since 1.8
*/
export class LongUnaryOperator {
  /**
   * Applies this operator to the given operand.
   *
   * @param operand the operand
   * @return the operator result
  */
  applyAsLong(operand: number): number;
  /**
   * Returns a composed operator that first applies the `before`
   * operator to its input, and then applies this operator to the result.
   * If evaluation of either operator throws an exception, it is relayed to
   * the caller of the composed operator.
   *
   * @param before the operator to apply before this operator is applied
   * @return a composed operator that first applies the `before`
   * operator and then applies this operator
   * @throws NullPointerException if before is null
   *
   * @see #andThen(LongUnaryOperator)
  */
  compose(before: LongUnaryOperator): LongUnaryOperator;
  /**
   * Returns a composed operator that first applies this operator to
   * its input, and then applies the `after` operator to the result.
   * If evaluation of either operator throws an exception, it is relayed to
   * the caller of the composed operator.
   *
   * @param after the operator to apply after this operator is applied
   * @return a composed operator that first applies this operator and then
   * applies the `after` operator
   * @throws NullPointerException if after is null
   *
   * @see #compose(LongUnaryOperator)
  */
  andThen(after: LongUnaryOperator): LongUnaryOperator;
  /**
   * Returns a unary operator that always returns its input argument.
   *
   * @return a unary operator that always returns its input argument
  */
  static identity(): LongUnaryOperator;
}
/**
 * Represents a function that accepts two arguments and produces a result.
 * This is the two-arity specialization of {@link Function}.
 *
 * This is a functional interface
 * whose functional method is {@link #apply(Object, Object)}.
 *
 * @param  the type of the first argument to the function
 * @param  the type of the second argument to the function
 * @param  the type of the result of the function
 *
 * @see Function
 * @since 1.8
*/
export class BiFunction<T, U, R> {
  /**
   * Applies this function to the given arguments.
   *
   * @param t the first function argument
   * @param u the second function argument
   * @return the function result
  */
  apply(t: T, u: U): R;
  /**
   * Returns a composed function that first applies this function to
   * its input, and then applies the `after` function to the result.
   * If evaluation of either function throws an exception, it is relayed to
   * the caller of the composed function.
   *
   * @param  the type of output of the `after` function, and of the
   *           composed function
   * @param after the function to apply after this function is applied
   * @return a composed function that first applies this function and then
   * applies the `after` function
   * @throws NullPointerException if after is null
  */
  andThen<V>(after: Function<any, V>): BiFunction<T, U, V>;
}
/**
 * Represents a predicate (boolean-valued function) of one `long`-valued
 * argument. This is the `long`-consuming primitive type specialization of
 * {@link Predicate}.
 *
 * This is a functional interface
 * whose functional method is {@link #test(long)}.
 *
 * @see Predicate
 * @since 1.8
*/
export class LongPredicate {
  /**
   * Evaluates this predicate on the given argument.
   *
   * @param value the input argument
   * @return `true` if the input argument matches the predicate,
   * otherwise `false`
  */
  test(value: number): boolean;
  /**
   * Returns a composed predicate that represents a short-circuiting logical
   * AND of this predicate and another.  When evaluating the composed
   * predicate, if this predicate is `false`, then the `other`
   * predicate is not evaluated.
   *
   * Any exceptions thrown during evaluation of either predicate are relayed
   * to the caller; if evaluation of this predicate throws an exception, the
   * `other` predicate will not be evaluated.
   *
   * @param other a predicate that will be logically-ANDed with this
   *              predicate
   * @return a composed predicate that represents the short-circuiting logical
   * AND of this predicate and the `other` predicate
   * @throws NullPointerException if other is null
  */
  and(other: LongPredicate): LongPredicate;
  /**
   * Returns a predicate that represents the logical negation of this
   * predicate.
   *
   * @return a predicate that represents the logical negation of this
   * predicate
  */
  negate(): LongPredicate;
  /**
   * Returns a composed predicate that represents a short-circuiting logical
   * OR of this predicate and another.  When evaluating the composed
   * predicate, if this predicate is `true`, then the `other`
   * predicate is not evaluated.
   *
   * Any exceptions thrown during evaluation of either predicate are relayed
   * to the caller; if evaluation of this predicate throws an exception, the
   * `other` predicate will not be evaluated.
   *
   * @param other a predicate that will be logically-ORed with this
   *              predicate
   * @return a composed predicate that represents the short-circuiting logical
   * OR of this predicate and the `other` predicate
   * @throws NullPointerException if other is null
  */
  or(other: LongPredicate): LongPredicate;
}
/**
 * Represents an operation upon two operands of the same type, producing a result
 * of the same type as the operands.  This is a specialization of
 * {@link BiFunction} for the case where the operands and the result are all of
 * the same type.
 *
 * This is a functional interface
 * whose functional method is {@link #apply(Object, Object)}.
 *
 * @param  the type of the operands and result of the operator
 *
 * @see BiFunction
 * @see UnaryOperator
 * @since 1.8
*/
export class BinaryOperator<T> extends BiFunction<T, T, T> {
  /**
   * Returns a {@link BinaryOperator} which returns the lesser of two elements
   * according to the specified `Comparator`.
   *
   * @param  the type of the input arguments of the comparator
   * @param comparator a `Comparator` for comparing the two values
   * @return a `BinaryOperator` which returns the lesser of its operands,
   *         according to the supplied `Comparator`
   * @throws NullPointerException if the argument is null
  */
  static minBy<T>(comparator: Comparator<any>): BinaryOperator<T>;
  /**
   * Returns a {@link BinaryOperator} which returns the greater of two elements
   * according to the specified `Comparator`.
   *
   * @param  the type of the input arguments of the comparator
   * @param comparator a `Comparator` for comparing the two values
   * @return a `BinaryOperator` which returns the greater of its operands,
   *         according to the supplied `Comparator`
   * @throws NullPointerException if the argument is null
  */
  static maxBy<T>(comparator: Comparator<any>): BinaryOperator<T>;
}
/**
 * Represents an operation on a single `double`-valued operand that produces
 * a `double`-valued result.  This is the primitive type specialization of
 * {@link UnaryOperator} for `double`.
 *
 * This is a functional interface
 * whose functional method is {@link #applyAsDouble(double)}.
 *
 * @see UnaryOperator
 * @since 1.8
*/
export class DoubleUnaryOperator {
  /**
   * Applies this operator to the given operand.
   *
   * @param operand the operand
   * @return the operator result
  */
  applyAsDouble(operand: number): number;
  /**
   * Returns a composed operator that first applies the `before`
   * operator to its input, and then applies this operator to the result.
   * If evaluation of either operator throws an exception, it is relayed to
   * the caller of the composed operator.
   *
   * @param before the operator to apply before this operator is applied
   * @return a composed operator that first applies the `before`
   * operator and then applies this operator
   * @throws NullPointerException if before is null
   *
   * @see #andThen(DoubleUnaryOperator)
  */
  compose(before: DoubleUnaryOperator): DoubleUnaryOperator;
  /**
   * Returns a composed operator that first applies this operator to
   * its input, and then applies the `after` operator to the result.
   * If evaluation of either operator throws an exception, it is relayed to
   * the caller of the composed operator.
   *
   * @param after the operator to apply after this operator is applied
   * @return a composed operator that first applies this operator and then
   * applies the `after` operator
   * @throws NullPointerException if after is null
   *
   * @see #compose(DoubleUnaryOperator)
  */
  andThen(after: DoubleUnaryOperator): DoubleUnaryOperator;
  /**
   * Returns a unary operator that always returns its input argument.
   *
   * @return a unary operator that always returns its input argument
  */
  static identity(): DoubleUnaryOperator;
}
/**
 * Represents a supplier of `int`-valued results.  This is the
 * `int`-producing primitive specialization of {@link Supplier}.
 *
 * There is no requirement that a distinct result be returned each
 * time the supplier is invoked.
 *
 * This is a functional interface
 * whose functional method is {@link #getAsInt()}.
 *
 * @see Supplier
 * @since 1.8
*/
export class IntSupplier {
  /**
   * Gets a result.
   *
   * @return a result
  */
  getAsInt(): number;
}
/**
 * Represents a supplier of `double`-valued results.  This is the
 * `double`-producing primitive specialization of {@link Supplier}.
 *
 * There is no requirement that a distinct result be returned each
 * time the supplier is invoked.
 *
 * This is a functional interface
 * whose functional method is {@link #getAsDouble()}.
 *
 * @see Supplier
 * @since 1.8
*/
export class DoubleSupplier {
  /**
   * Gets a result.
   *
   * @return a result
  */
  getAsDouble(): number;
}
/**
 * Represents a predicate (boolean-valued function) of one `double`-valued
 * argument. This is the `double`-consuming primitive type specialization
 * of {@link Predicate}.
 *
 * This is a functional interface
 * whose functional method is {@link #test(double)}.
 *
 * @see Predicate
 * @since 1.8
*/
export class DoublePredicate {
  /**
   * Evaluates this predicate on the given argument.
   *
   * @param value the input argument
   * @return `true` if the input argument matches the predicate,
   * otherwise `false`
  */
  test(value: number): boolean;
  /**
   * Returns a composed predicate that represents a short-circuiting logical
   * AND of this predicate and another.  When evaluating the composed
   * predicate, if this predicate is `false`, then the `other`
   * predicate is not evaluated.
   *
   * Any exceptions thrown during evaluation of either predicate are relayed
   * to the caller; if evaluation of this predicate throws an exception, the
   * `other` predicate will not be evaluated.
   *
   * @param other a predicate that will be logically-ANDed with this
   *              predicate
   * @return a composed predicate that represents the short-circuiting logical
   * AND of this predicate and the `other` predicate
   * @throws NullPointerException if other is null
  */
  and(other: DoublePredicate): DoublePredicate;
  /**
   * Returns a predicate that represents the logical negation of this
   * predicate.
   *
   * @return a predicate that represents the logical negation of this
   * predicate
  */
  negate(): DoublePredicate;
  /**
   * Returns a composed predicate that represents a short-circuiting logical
   * OR of this predicate and another.  When evaluating the composed
   * predicate, if this predicate is `true`, then the `other`
   * predicate is not evaluated.
   *
   * Any exceptions thrown during evaluation of either predicate are relayed
   * to the caller; if evaluation of this predicate throws an exception, the
   * `other` predicate will not be evaluated.
   *
   * @param other a predicate that will be logically-ORed with this
   *              predicate
   * @return a composed predicate that represents the short-circuiting logical
   * OR of this predicate and the `other` predicate
   * @throws NullPointerException if other is null
  */
  or(other: DoublePredicate): DoublePredicate;
}
/**
 * Represents a supplier of `long`-valued results.  This is the
 * `long`-producing primitive specialization of {@link Supplier}.
 *
 * There is no requirement that a distinct result be returned each
 * time the supplier is invoked.
 *
 * This is a functional interface
 * whose functional method is {@link #getAsLong()}.
 *
 * @see Supplier
 * @since 1.8
*/
export class LongSupplier {
  /**
   * Gets a result.
   *
   * @return a result
  */
  getAsLong(): number;
}
/**
 * Represents an operation upon two `int`-valued operands and producing an
 * `int`-valued result.   This is the primitive type specialization of
 * {@link BinaryOperator} for `int`.
 *
 * This is a functional interface
 * whose functional method is {@link #applyAsInt(int, int)}.
 *
 * @see BinaryOperator
 * @see IntUnaryOperator
 * @since 1.8
*/
export class IntBinaryOperator {
  /**
   * Applies this operator to the given operands.
   *
   * @param left the first operand
   * @param right the second operand
   * @return the operator result
  */
  applyAsInt(left: number, right: number): number;
}
/**
 * Represents an operation on a single operand that produces a result of the
 * same type as its operand.  This is a specialization of `Function` for
 * the case where the operand and result are of the same type.
 *
 * This is a functional interface
 * whose functional method is {@link #apply(Object)}.
 *
 * @param  the type of the operand and result of the operator
 *
 * @see Function
 * @since 1.8
*/
export class UnaryOperator<T> extends Function<T, T> {
  /**
   * Returns a unary operator that always returns its input argument.
   *
   * @param  the type of the input and output of the operator
   * @return a unary operator that always returns its input argument
  */
  static identity<T>(): UnaryOperator<T>;
}
/**
 * Represents an operation that accepts an object-valued and a
 * `int`-valued argument, and returns no result.  This is the
 * `(reference, int)` specialization of {@link BiConsumer}.
 * Unlike most other functional interfaces, `ObjIntConsumer` is
 * expected to operate via side-effects.
 *
 * This is a functional interface
 * whose functional method is {@link #accept(Object, int)}.
 *
 * @param  the type of the object argument to the operation
 *
 * @see BiConsumer
 * @since 1.8
*/
export class ObjIntConsumer<T> {
  /**
   * Performs this operation on the given arguments.
   *
   * @param t the first input argument
   * @param value the second input argument
  */
  accept(t: T, value: number): void;
}
/**
 * Represents an operation that accepts two input arguments and returns no
 * result.  This is the two-arity specialization of {@link Consumer}.
 * Unlike most other functional interfaces, `BiConsumer` is expected
 * to operate via side-effects.
 *
 * This is a functional interface
 * whose functional method is {@link #accept(Object, Object)}.
 *
 * @param  the type of the first argument to the operation
 * @param  the type of the second argument to the operation
 *
 * @see Consumer
 * @since 1.8
*/
export class BiConsumer<T, U> {
  /**
   * Performs this operation on the given arguments.
   *
   * @param t the first input argument
   * @param u the second input argument
  */
  accept(t: T, u: U): void;
  /**
   * Returns a composed `BiConsumer` that performs, in sequence, this
   * operation followed by the `after` operation. If performing either
   * operation throws an exception, it is relayed to the caller of the
   * composed operation.  If performing this operation throws an exception,
   * the `after` operation will not be performed.
   *
   * @param after the operation to perform after this operation
   * @return a composed `BiConsumer` that performs in sequence this
   * operation followed by the `after` operation
   * @throws NullPointerException if `after` is null
  */
  andThen(after: BiConsumer<any, any>): BiConsumer<T, U>;
}
/**
 * Represents a function that accepts an int-valued argument and produces a
 * double-valued result.  This is the `int`-to-`double` primitive
 * specialization for {@link Function}.
 *
 * This is a functional interface
 * whose functional method is {@link #applyAsDouble(int)}.
 *
 * @see Function
 * @since 1.8
*/
export class IntToDoubleFunction {
  /**
   * Applies this function to the given argument.
   *
   * @param value the function argument
   * @return the function result
  */
  applyAsDouble(value: number): number;
}
/**
 * Represents an operation that accepts a single `int`-valued argument and
 * returns no result.  This is the primitive type specialization of
 * {@link Consumer} for `int`.  Unlike most other functional interfaces,
 * `IntConsumer` is expected to operate via side-effects.
 *
 * This is a functional interface
 * whose functional method is {@link #accept(int)}.
 *
 * @see Consumer
 * @since 1.8
*/
export class IntConsumer {
  /**
   * Performs this operation on the given argument.
   *
   * @param value the input argument
  */
  accept(value: number): void;
  /**
   * Returns a composed `IntConsumer` that performs, in sequence, this
   * operation followed by the `after` operation. If performing either
   * operation throws an exception, it is relayed to the caller of the
   * composed operation.  If performing this operation throws an exception,
   * the `after` operation will not be performed.
   *
   * @param after the operation to perform after this operation
   * @return a composed `IntConsumer` that performs in sequence this
   * operation followed by the `after` operation
   * @throws NullPointerException if `after` is null
  */
  andThen(after: IntConsumer): IntConsumer;
}
/**
 * Represents an operation upon two `double`-valued operands and producing a
 * `double`-valued result.   This is the primitive type specialization of
 * {@link BinaryOperator} for `double`.
 *
 * This is a functional interface
 * whose functional method is {@link #applyAsDouble(double, double)}.
 *
 * @see BinaryOperator
 * @see DoubleUnaryOperator
 * @since 1.8
*/
export class DoubleBinaryOperator {
  /**
   * Applies this operator to the given operands.
   *
   * @param left the first operand
   * @param right the second operand
   * @return the operator result
  */
  applyAsDouble(left: number, right: number): number;
}

}
declare module 'java.util.Spliterator' {
import { Spliterator } from 'java.util';
import { LongConsumer, DoubleConsumer, Consumer, IntConsumer } from 'java.util.function';
/**
 * A Spliterator specialized for primitive values.
 *
 * @param  the type of elements returned by this Spliterator.  The
 * type must be a wrapper type for a primitive type, such as `Integer`
 * for the primitive `int` type.
 * @param  the type of primitive consumer.  The type must be a
 * primitive specialization of {@link java.util.function.Consumer} for
 * `T`, such as {@link java.util.function.IntConsumer} for
 * `Integer`.
 * @param  the type of primitive Spliterator.  The type must be
 * a primitive specialization of Spliterator for `T`, such as
 * {@link Spliterator.OfInt} for `Integer`.
 *
 * @see Spliterator.OfInt
 * @see Spliterator.OfLong
 * @see Spliterator.OfDouble
 * @since 1.8
*/
export class OfPrimitive<T, T_CONS, T_SPLITR> extends Spliterator<T> {
  trySplit(): T_SPLITR;
  /**
   * If a remaining element exists, performs the given action on it,
   * returning `true`; else returns `false`.  If this
   * Spliterator is {@link #ORDERED} the action is performed on the
   * next element in encounter order.  Exceptions thrown by the
   * action are relayed to the caller.
   *
   * @param action The action
   * @return `false` if no remaining elements existed
   * upon entry to this method, else `true`.
   * @throws NullPointerException if the specified action is null
  */
  tryAdvance(action: T_CONS): boolean;
  /**
   * Performs the given action for each remaining element, sequentially in
   * the current thread, until all elements have been processed or the
   * action throws an exception.  If this Spliterator is {@link #ORDERED},
   * actions are performed in encounter order.  Exceptions thrown by the
   * action are relayed to the caller.
   *
   * @implSpec
   * The default implementation repeatedly invokes {@link #tryAdvance}
   * until it returns `false`.  It should be overridden whenever
   * possible.
   *
   * @param action The action
   * @throws NullPointerException if the specified action is null
  */
  forEachRemaining(action: T_CONS): void;
}
/**
 * A Spliterator specialized for `int` values.
 * @since 1.8
*/
export class OfInt extends OfPrimitive<number, IntConsumer, OfInt> {
  trySplit(): OfInt;
  tryAdvance(action: IntConsumer): boolean;
  forEachRemaining(action: IntConsumer): void;
  /**
   * {@inheritDoc}
   * @implSpec
   * If the action is an instance of `IntConsumer` then it is cast
   * to `IntConsumer` and passed to
   * {@link #tryAdvance(java.util.function.IntConsumer)}; otherwise
   * the action is adapted to an instance of `IntConsumer`, by
   * boxing the argument of `IntConsumer`, and then passed to
   * {@link #tryAdvance(java.util.function.IntConsumer)}.
  */
  tryAdvance(action: Consumer<any>): boolean;
  /**
   * {@inheritDoc}
   * @implSpec
   * If the action is an instance of `IntConsumer` then it is cast
   * to `IntConsumer` and passed to
   * {@link #forEachRemaining(java.util.function.IntConsumer)}; otherwise
   * the action is adapted to an instance of `IntConsumer`, by
   * boxing the argument of `IntConsumer`, and then passed to
   * {@link #forEachRemaining(java.util.function.IntConsumer)}.
  */
  forEachRemaining(action: Consumer<any>): void;
}
/**
 * A Spliterator specialized for `long` values.
 * @since 1.8
*/
export class OfLong extends OfPrimitive<number, LongConsumer, OfLong> {
  trySplit(): OfLong;
  tryAdvance(action: LongConsumer): boolean;
  forEachRemaining(action: LongConsumer): void;
  /**
   * {@inheritDoc}
   * @implSpec
   * If the action is an instance of `LongConsumer` then it is cast
   * to `LongConsumer` and passed to
   * {@link #tryAdvance(java.util.function.LongConsumer)}; otherwise
   * the action is adapted to an instance of `LongConsumer`, by
   * boxing the argument of `LongConsumer`, and then passed to
   * {@link #tryAdvance(java.util.function.LongConsumer)}.
  */
  tryAdvance(action: Consumer<any>): boolean;
  /**
   * {@inheritDoc}
   * @implSpec
   * If the action is an instance of `LongConsumer` then it is cast
   * to `LongConsumer` and passed to
   * {@link #forEachRemaining(java.util.function.LongConsumer)}; otherwise
   * the action is adapted to an instance of `LongConsumer`, by
   * boxing the argument of `LongConsumer`, and then passed to
   * {@link #forEachRemaining(java.util.function.LongConsumer)}.
  */
  forEachRemaining(action: Consumer<any>): void;
}
/**
 * A Spliterator specialized for `double` values.
 * @since 1.8
*/
export class OfDouble extends OfPrimitive<number, DoubleConsumer, OfDouble> {
  trySplit(): OfDouble;
  tryAdvance(action: DoubleConsumer): boolean;
  forEachRemaining(action: DoubleConsumer): void;
  /**
   * {@inheritDoc}
   * @implSpec
   * If the action is an instance of `DoubleConsumer` then it is
   * cast to `DoubleConsumer` and passed to
   * {@link #tryAdvance(java.util.function.DoubleConsumer)}; otherwise
   * the action is adapted to an instance of `DoubleConsumer`, by
   * boxing the argument of `DoubleConsumer`, and then passed to
   * {@link #tryAdvance(java.util.function.DoubleConsumer)}.
  */
  tryAdvance(action: Consumer<any>): boolean;
  /**
   * {@inheritDoc}
   * @implSpec
   * If the action is an instance of `DoubleConsumer` then it is
   * cast to `DoubleConsumer` and passed to
   * {@link #forEachRemaining(java.util.function.DoubleConsumer)};
   * otherwise the action is adapted to an instance of
   * `DoubleConsumer`, by boxing the argument of
   * `DoubleConsumer`, and then passed to
   * {@link #forEachRemaining(java.util.function.DoubleConsumer)}.
  */
  forEachRemaining(action: Consumer<any>): void;
}

}
declare module 'java.util.stream.IntStream' {
import { IntStream } from 'java.util.stream';
import { IntConsumer } from 'java.util.function';
/**
 * A mutable builder for an `IntStream`.
 *
 * A stream builder has a lifecycle, which starts in a building
 * phase, during which elements can be added, and then transitions to a built
 * phase, after which elements may not be added.  The built phase
 * begins when the {@link #build()} method is called, which creates an
 * ordered stream whose elements are the elements that were added to the
 * stream builder, in the order they were added.
 *
 * @see IntStream#builder()
 * @since 1.8
*/
export class Builder extends IntConsumer {
  /**
   * Adds an element to the stream being built.
   *
   * @throws IllegalStateException if the builder has already transitioned
   * to the built state
  */
  accept(t: number): void;
  /**
   * Adds an element to the stream being built.
   *
   * @implSpec
   * The default implementation behaves as if:
   * {@code
   *     accept(t)
   *     return this;
   * }
   *
   * @param t the element to add
   * @return `this` builder
   * @throws IllegalStateException if the builder has already transitioned
   * to the built state
  */
  add(t: number): Builder;
  /**
   * Builds the stream, transitioning this builder to the built state.
   * An `IllegalStateException` is thrown if there are further
   * attempts to operate on the builder after it has entered the built
   * state.
   *
   * @return the built stream
   * @throws IllegalStateException if the builder has already transitioned to
   * the built state
  */
  build(): IntStream;
}
/**
 * Represents an operation that accepts an `int`-valued argument
 * and an IntConsumer, and returns no result. This functional interface is
 * used by {@link IntStream#mapMulti(IntMapMultiConsumer) IntStream.mapMulti}
 * to replace an int value with zero or more int values.
 *
 * This is a functional interface
 * whose functional method is {@link #accept(int, IntConsumer)}.
 *
 * @see IntStream#mapMulti(IntMapMultiConsumer)
 *
 * @since 16
*/
export class IntMapMultiConsumer {
  /**
   * Replaces the given `value` with zero or more values by feeding the mapped
   * values to the `ic` consumer.
   *
   * @param value the int value coming from upstream
   * @param ic an `IntConsumer` accepting the mapped values
  */
  accept(value: number, ic: IntConsumer): void;
}

}
declare module 'java.util' {
import { Stream, DoubleStream, LongStream, IntStream } from 'java.util.stream';
import { PatternLRUCache } from 'java.util.Scanner';
import { LongBuffer, CharBuffer, ByteBuffer } from 'java.nio';
import { Node as java_util_HashMap_Node } from 'java.util.HashMap';
import { ReadableByteChannel } from 'java.nio.channels';
import { OtherCurrencyEntry, SpecialCaseEntry } from 'java.util.Currency';
import { Path } from 'java.nio.file';
import { Charset } from 'java.nio.charset';
import { Entry } from 'java.util.LinkedHashMap';
import { ReferenceQueue } from 'java.lang.ref';
import { ZoneId, ZonedDateTime, Instant } from 'java.time';
import { Pattern, Matcher, MatchResult } from 'java.util.regex';
import { Control, BundleReference, CacheKey } from 'java.util.ResourceBundle';
import { FilteringMode, Category, LanguageRange, IsoCountryCode } from 'java.util.Locale';
import { Entry as java_util_Map_Entry } from 'java.util.Map';
import { Node } from 'java.util.LinkedList';
import { BigInteger, BigDecimal } from 'java.math';
import { Entry as java_util_WeakHashMap_Entry } from 'java.util.WeakHashMap';
import { Entry as java_util_Hashtable_Entry } from 'java.util.Hashtable';
import { BasicPermission, PermissionCollection, AccessControlContext, Permission } from 'java.security';
import { ConcurrentMap, ConcurrentHashMap } from 'java.util.concurrent';
import { AtomicLong, AtomicInteger } from 'java.util.concurrent.atomic';
import { Provider } from 'java.util.ServiceLoader';
import { OfInt as java_util_PrimitiveIterator_OfInt, OfLong as java_util_PrimitiveIterator_OfLong, OfDouble as java_util_PrimitiveIterator_OfDouble } from 'java.util.PrimitiveIterator';
import { Encoder, Decoder } from 'java.util.Base64';
import { Enum, IllegalStateException, Comparable, Iterable, Appendable, CharSequence, Error, Exception, RuntimeException, Runnable, ClassLoader, Throwable, Readable, Class, Cloneable, ModuleLayer, Module, IllegalArgumentException } from 'java.lang';
import { KeySet, Entry as java_util_TreeMap_Entry, EntrySet } from 'java.util.TreeMap';
import { PrintStream, Serializable, ObjectStreamField, InputStream, OutputStream, Closeable, Reader, IOException, Flushable, File, Writer, PrintWriter } from 'java.io';
import { LongBinaryOperator, IntSupplier, IntUnaryOperator, IntToDoubleFunction, IntConsumer, Predicate, Function, ToLongFunction, LongConsumer, DoubleConsumer, DoubleBinaryOperator, Consumer, BiFunction, DoubleSupplier, IntFunction, IntBinaryOperator, IntToLongFunction, Supplier, ToIntFunction, BinaryOperator, LongSupplier, UnaryOperator, BiConsumer, ToDoubleFunction } from 'java.util.function';
import { Cache } from 'java.util.SimpleTimeZone';
import { OfInt, OfLong, OfDouble } from 'java.util.Spliterator';
/**
 * An object that implements the Enumeration interface generates a
 * series of elements, one at a time. Successive calls to the
 * `nextElement` method return successive elements of the
 * series.
 * 
 * For example, to print all elements of a `Vector` v:
 *  *   for (Enumeration<E> e = v.elements(); e.hasMoreElements();)
 *       System.out.println(e.nextElement());
 * 
 * Methods are provided to enumerate through the elements of a
 * vector, the keys of a hashtable, and the values in a hashtable.
 * Enumerations are also used to specify the input streams to a
 * `SequenceInputStream`.
 *
 * @apiNote
 * The functionality of this interface is duplicated by the {@link Iterator}
 * interface.  In addition, `Iterator` adds an optional remove operation,
 * and has shorter method names.  New implementations should consider using
 * `Iterator` in preference to `Enumeration`. It is possible to
 * adapt an `Enumeration` to an `Iterator` by using the
 * {@link #asIterator} method.
 *
 * @see     java.util.Iterator
 * @see     java.io.SequenceInputStream
 * @see     java.util.Enumeration#nextElement()
 * @see     java.util.Hashtable
 * @see     java.util.Hashtable#elements()
 * @see     java.util.Hashtable#keys()
 * @see     java.util.Vector
 * @see     java.util.Vector#elements()
 *
 * @author  Lee Boynton
 * @since   1.0
*/
export class Enumeration<E> {
  /**
   * Tests if this enumeration contains more elements.
   *
   * @return  `true` if and only if this enumeration object
   *           contains at least one more element to provide;
   *          `false` otherwise.
  */
  hasMoreElements(): boolean;
  /**
   * Returns the next element of this enumeration if this enumeration
   * object has at least one more element to provide.
   *
   * @return     the next element of this enumeration.
   * @throws     NoSuchElementException  if no more elements exist.
  */
  nextElement(): E;
  /**
   * Returns an {@link Iterator} that traverses the remaining elements
   * covered by this enumeration. Traversal is undefined if any methods
   * are called on this enumeration after the call to `asIterator`.
   *
   * @apiNote
   * This method is intended to help adapt code that produces
   * `Enumeration` instances to code that consumes `Iterator`
   * instances. For example, the {@link java.util.jar.JarFile#entries()
   * JarFile.entries()} method returns an `Enumeration`.
   * This can be turned into an `Iterator`, and then the
   * `forEachRemaining()` method can be used:
   *
   * {@code
   *     JarFile jarFile = ... ;
   *     jarFile.entries().asIterator().forEachRemaining(entry -> { ... });
   * }
   *
   * (Note that there is also a {@link java.util.jar.JarFile#stream()
   * JarFile.stream()} method that returns a `Stream` of entries,
   * which may be more convenient in some cases.)
   *
   * @implSpec
   * The default implementation returns an `Iterator` whose
   * {@link Iterator#hasNext hasNext} method calls this Enumeration's
   * `hasMoreElements` method, whose {@link Iterator#next next}
   * method calls this Enumeration's `nextElement` method, and
   * whose {@link Iterator#remove remove} method throws
   * `UnsupportedOperationException`.
   *
   * @return an Iterator representing the remaining elements of this Enumeration
   *
   * @since 9
  */
  asIterator(): Iterator<E>;
}
/**
 * The `Vector` class implements a growable array of
 * objects. Like an array, it contains components that can be
 * accessed using an integer index. However, the size of a
 * `Vector` can grow or shrink as needed to accommodate
 * adding and removing items after the `Vector` has been created.
 *
 * Each vector tries to optimize storage management by maintaining a
 * `capacity` and a `capacityIncrement`. The
 * `capacity` is always at least as large as the vector
 * size; it is usually larger because as components are added to the
 * vector, the vector's storage increases in chunks the size of
 * `capacityIncrement`. An application can increase the
 * capacity of a vector before inserting a large number of
 * components; this reduces the amount of incremental reallocation.
 *
 * 
 * The iterators returned by this class's {@link #iterator() iterator} and
 * {@link #listIterator(int) listIterator} methods are fail-fast:
 * if the vector is structurally modified at any time after the iterator is
 * created, in any way except through the iterator's own
 * {@link ListIterator#remove() remove} or
 * {@link ListIterator#add(Object) add} methods, the iterator will throw a
 * {@link ConcurrentModificationException}.  Thus, in the face of
 * concurrent modification, the iterator fails quickly and cleanly, rather
 * than risking arbitrary, non-deterministic behavior at an undetermined
 * time in the future.  The {@link Enumeration Enumerations} returned by
 * the {@link #elements() elements} method are not fail-fast; if the
 * Vector is structurally modified at any time after the enumeration is
 * created then the results of enumerating are undefined.
 *
 * Note that the fail-fast behavior of an iterator cannot be guaranteed
 * as it is, generally speaking, impossible to make any hard guarantees in the
 * presence of unsynchronized concurrent modification.  Fail-fast iterators
 * throw `ConcurrentModificationException` on a best-effort basis.
 * Therefore, it would be wrong to write a program that depended on this
 * exception for its correctness:  the fail-fast behavior of iterators
 * should be used only to detect bugs.
 *
 * As of the Java 2 platform v1.2, this class was retrofitted to
 * implement the {@link List} interface, making it a member of the
 * 
 * Java Collections Framework.  Unlike the new collection
 * implementations, `Vector` is synchronized.  If a thread-safe
 * implementation is not needed, it is recommended to use {@link
 * ArrayList} in place of `Vector`.
 *
 * @param  Type of component elements
 *
 * @author  Lee Boynton
 * @author  Jonathan Payne
 * @see Collection
 * @see LinkedList
 * @since   1.0
*/
export class Vector<E> extends AbstractList<E> {
  /**
   * Constructs an empty vector with the specified initial capacity and
   * capacity increment.
   *
   * @param   initialCapacity     the initial capacity of the vector
   * @param   capacityIncrement   the amount by which the capacity is
   *                              increased when the vector overflows
   * @throws IllegalArgumentException if the specified initial capacity
   *         is negative
  */
  constructor(initialCapacity: number, capacityIncrement: number);
  /**
   * Constructs an empty vector with the specified initial capacity and
   * with its capacity increment equal to zero.
   *
   * @param   initialCapacity   the initial capacity of the vector
   * @throws IllegalArgumentException if the specified initial capacity
   *         is negative
  */
  constructor(initialCapacity: number);
  /**
   * Constructs an empty vector so that its internal data array
   * has size `10` and its standard capacity increment is
   * zero.
  */
  constructor();
  /**
   * Constructs a vector containing the elements of the specified
   * collection, in the order they are returned by the collection's
   * iterator.
   *
   * @param c the collection whose elements are to be placed into this
   *       vector
   * @throws NullPointerException if the specified collection is null
   * @since   1.2
  */
  constructor(c: Collection<E>);
  /**
   * Copies the components of this vector into the specified array.
   * The item at index `k` in this vector is copied into
   * component `k` of `anArray`.
   *
   * @param  anArray the array into which the components get copied
   * @throws NullPointerException if the given array is null
   * @throws IndexOutOfBoundsException if the specified array is not
   *         large enough to hold all the components of this vector
   * @throws ArrayStoreException if a component of this vector is not of
   *         a runtime type that can be stored in the specified array
   * @see #toArray(Object[])
  */
  copyInto(anArray: any[]): void;
  /**
   * Trims the capacity of this vector to be the vector's current
   * size. If the capacity of this vector is larger than its current
   * size, then the capacity is changed to equal the size by replacing
   * its internal data array, kept in the field `elementData`,
   * with a smaller one. An application can use this operation to
   * minimize the storage of a vector.
  */
  trimToSize(): void;
  /**
   * Increases the capacity of this vector, if necessary, to ensure
   * that it can hold at least the number of components specified by
   * the minimum capacity argument.
   *
   * If the current capacity of this vector is less than
   * `minCapacity`, then its capacity is increased by replacing its
   * internal data array, kept in the field `elementData`, with a
   * larger one.  The size of the new data array will be the old size plus
   * `capacityIncrement`, unless the value of
   * `capacityIncrement` is less than or equal to zero, in which case
   * the new capacity will be twice the old capacity; but if this new size
   * is still smaller than `minCapacity`, then the new capacity will
   * be `minCapacity`.
   *
   * @param minCapacity the desired minimum capacity
  */
  ensureCapacity(minCapacity: number): void;
  /**
   * Sets the size of this vector. If the new size is greater than the
   * current size, new `null` items are added to the end of
   * the vector. If the new size is less than the current size, all
   * components at index `newSize` and greater are discarded.
   *
   * @param  newSize   the new size of this vector
   * @throws ArrayIndexOutOfBoundsException if the new size is negative
  */
  setSize(size: number): void;
  /**
   * Returns the current capacity of this vector.
   *
   * @return  the current capacity (the length of its internal
   *          data array, kept in the field `elementData`
   *          of this vector)
  */
  capacity(): number;
  /**
   * Returns the number of components in this vector.
   *
   * @return  the number of components in this vector
  */
  size(): number;
  /**
   * Tests if this vector has no components.
   *
   * @return  `true` if and only if this vector has
   *          no components, that is, its size is zero;
   *          `false` otherwise.
  */
  isEmpty(): boolean;
  /**
   * Returns an enumeration of the components of this vector. The
   * returned `Enumeration` object will generate all items in
   * this vector. The first item generated is the item at index `0`,
   * then the item at index `1`, and so on. If the vector is
   * structurally modified while enumerating over the elements then the
   * results of enumerating are undefined.
   *
   * @return  an enumeration of the components of this vector
   * @see     Iterator
  */
  elements(): Enumeration<E>;
  /**
   * Returns `true` if this vector contains the specified element.
   * More formally, returns `true` if and only if this vector
   * contains at least one element `e` such that
   * `Objects.equals(o, e)`.
   *
   * @param o element whose presence in this vector is to be tested
   * @return `true` if this vector contains the specified element
  */
  contains(o: any): boolean;
  /**
   * Returns the index of the first occurrence of the specified element
   * in this vector, or -1 if this vector does not contain the element.
   * More formally, returns the lowest index `i` such that
   * `Objects.equals(o, get(i))`,
   * or -1 if there is no such index.
   *
   * @param o element to search for
   * @return the index of the first occurrence of the specified element in
   *         this vector, or -1 if this vector does not contain the element
  */
  indexOf(o: any): number;
  /**
   * Returns the index of the first occurrence of the specified element in
   * this vector, searching forwards from `index`, or returns -1 if
   * the element is not found.
   * More formally, returns the lowest index `i` such that
   * `(i >= index && Objects.equals(o, get(i)))`,
   * or -1 if there is no such index.
   *
   * @param o element to search for
   * @param index index to start searching from
   * @return the index of the first occurrence of the element in
   *         this vector at position `index` or later in the vector;
   *         `-1` if the element is not found.
   * @throws IndexOutOfBoundsException if the specified index is negative
   * @see     Object#equals(Object)
  */
  indexOf(o: any, index: number): number;
  /**
   * Returns the index of the last occurrence of the specified element
   * in this vector, or -1 if this vector does not contain the element.
   * More formally, returns the highest index `i` such that
   * `Objects.equals(o, get(i))`,
   * or -1 if there is no such index.
   *
   * @param o element to search for
   * @return the index of the last occurrence of the specified element in
   *         this vector, or -1 if this vector does not contain the element
  */
  lastIndexOf(o: any): number;
  /**
   * Returns the index of the last occurrence of the specified element in
   * this vector, searching backwards from `index`, or returns -1 if
   * the element is not found.
   * More formally, returns the highest index `i` such that
   * `(i <= index && Objects.equals(o, get(i)))`,
   * or -1 if there is no such index.
   *
   * @param o element to search for
   * @param index index to start searching backwards from
   * @return the index of the last occurrence of the element at position
   *         less than or equal to `index` in this vector;
   *         -1 if the element is not found.
   * @throws IndexOutOfBoundsException if the specified index is greater
   *         than or equal to the current size of this vector
  */
  lastIndexOf(o: any, index: number): number;
  /**
   * Returns the component at the specified index.
   *
   * This method is identical in functionality to the {@link #get(int)}
   * method (which is part of the {@link List} interface).
   *
   * @param      index   an index into this vector
   * @return     the component at the specified index
   * @throws ArrayIndexOutOfBoundsException if the index is out of range
   *         (`index < 0 || index >= size()`)
  */
  elementAt(index: number): E;
  /**
   * Returns the first component (the item at index `0`) of
   * this vector.
   *
   * @return     the first component of this vector
   * @throws NoSuchElementException if this vector has no components
  */
  firstElement(): E;
  /**
   * Returns the last component of the vector.
   *
   * @return  the last component of the vector, i.e., the component at index
   *          `size() - 1`
   * @throws NoSuchElementException if this vector is empty
  */
  lastElement(): E;
  /**
   * Sets the component at the specified `index` of this
   * vector to be the specified object. The previous component at that
   * position is discarded.
   *
   * The index must be a value greater than or equal to `0`
   * and less than the current size of the vector.
   *
   * This method is identical in functionality to the
   * {@link #set(int, Object) set(int, E)}
   * method (which is part of the {@link List} interface). Note that the
   * `set` method reverses the order of the parameters, to more closely
   * match array usage.  Note also that the `set` method returns the
   * old value that was stored at the specified position.
   *
   * @param      obj     what the component is to be set to
   * @param      index   the specified index
   * @throws ArrayIndexOutOfBoundsException if the index is out of range
   *         (`index < 0 || index >= size()`)
  */
  setElementAt(obj: E, index: number): void;
  /**
   * Deletes the component at the specified index. Each component in
   * this vector with an index greater or equal to the specified
   * `index` is shifted downward to have an index one
   * smaller than the value it had previously. The size of this vector
   * is decreased by `1`.
   *
   * The index must be a value greater than or equal to `0`
   * and less than the current size of the vector.
   *
   * This method is identical in functionality to the {@link #remove(int)}
   * method (which is part of the {@link List} interface).  Note that the
   * `remove` method returns the old value that was stored at the
   * specified position.
   *
   * @param      index   the index of the object to remove
   * @throws ArrayIndexOutOfBoundsException if the index is out of range
   *         (`index < 0 || index >= size()`)
  */
  removeElementAt(index: number): void;
  /**
   * Inserts the specified object as a component in this vector at the
   * specified `index`. Each component in this vector with
   * an index greater or equal to the specified `index` is
   * shifted upward to have an index one greater than the value it had
   * previously.
   *
   * The index must be a value greater than or equal to `0`
   * and less than or equal to the current size of the vector. (If the
   * index is equal to the current size of the vector, the new element
   * is appended to the Vector.)
   *
   * This method is identical in functionality to the
   * {@link #add(int, Object) add(int, E)}
   * method (which is part of the {@link List} interface).  Note that the
   * `add` method reverses the order of the parameters, to more closely
   * match array usage.
   *
   * @param      obj     the component to insert
   * @param      index   where to insert the new component
   * @throws ArrayIndexOutOfBoundsException if the index is out of range
   *         (`index < 0 || index > size()`)
  */
  insertElementAt(obj: E, index: number): void;
  /**
   * Adds the specified component to the end of this vector,
   * increasing its size by one. The capacity of this vector is
   * increased if its size becomes greater than its capacity.
   *
   * This method is identical in functionality to the
   * {@link #add(Object) add(E)}
   * method (which is part of the {@link List} interface).
   *
   * @param   obj   the component to be added
  */
  addElement(obj: E): void;
  /**
   * Removes the first (lowest-indexed) occurrence of the argument
   * from this vector. If the object is found in this vector, each
   * component in the vector with an index greater or equal to the
   * object's index is shifted downward to have an index one smaller
   * than the value it had previously.
   *
   * This method is identical in functionality to the
   * {@link #remove(Object)} method (which is part of the
   * {@link List} interface).
   *
   * @param   obj   the component to be removed
   * @return  `true` if the argument was a component of this
   *          vector; `false` otherwise.
  */
  removeElement(obj: any): boolean;
  /**
   * Removes all components from this vector and sets its size to zero.
   *
   * This method is identical in functionality to the {@link #clear}
   * method (which is part of the {@link List} interface).
  */
  removeAllElements(): void;
  /**
   * Returns a clone of this vector. The copy will contain a
   * reference to a clone of the internal data array, not a reference
   * to the original internal data array of this `Vector` object.
   *
   * @return  a clone of this vector
  */
  clone(): any;
  /**
   * Returns an array containing all of the elements in this Vector
   * in the correct order.
   *
   * @since 1.2
  */
  toArray(): any[];
  /**
   * Returns an array containing all of the elements in this Vector in the
   * correct order; the runtime type of the returned array is that of the
   * specified array.  If the Vector fits in the specified array, it is
   * returned therein.  Otherwise, a new array is allocated with the runtime
   * type of the specified array and the size of this Vector.
   *
   * If the Vector fits in the specified array with room to spare
   * (i.e., the array has more elements than the Vector),
   * the element in the array immediately following the end of the
   * Vector is set to null.  (This is useful in determining the length
   * of the Vector only if the caller knows that the Vector
   * does not contain any null elements.)
   *
   * @param  type of array elements. The same type as `` or a
   * supertype of ``.
   * @param a the array into which the elements of the Vector are to
   *          be stored, if it is big enough; otherwise, a new array of the
   *          same runtime type is allocated for this purpose.
   * @return an array containing the elements of the Vector
   * @throws ArrayStoreException if the runtime type of a, ``, is not
   * a supertype of the runtime type, ``, of every element in this
   * Vector
   * @throws NullPointerException if the given array is null
   * @since 1.2
  */
  toArray<T>(a: T[]): T[];
  /**
   * Returns the element at the specified position in this Vector.
   *
   * @param index index of the element to return
   * @return object at the specified index
   * @throws ArrayIndexOutOfBoundsException if the index is out of range
   *            (`index < 0 || index >= size()`)
   * @since 1.2
  */
  get(index: number): E;
  /**
   * Replaces the element at the specified position in this Vector with the
   * specified element.
   *
   * @param index index of the element to replace
   * @param element element to be stored at the specified position
   * @return the element previously at the specified position
   * @throws ArrayIndexOutOfBoundsException if the index is out of range
   *         (`index < 0 || index >= size()`)
   * @since 1.2
  */
  set(index: number, element: E): E;
  /**
   * Appends the specified element to the end of this Vector.
   *
   * @param e element to be appended to this Vector
   * @return `true` (as specified by {@link Collection#add})
   * @since 1.2
  */
  add(e: E): boolean;
  /**
   * Removes the first occurrence of the specified element in this Vector
   * If the Vector does not contain the element, it is unchanged.  More
   * formally, removes the element with the lowest index i such that
   * `Objects.equals(o, get(i))` (if such
   * an element exists).
   *
   * @param o element to be removed from this Vector, if present
   * @return true if the Vector contained the specified element
   * @since 1.2
  */
  remove(o: any): boolean;
  /**
   * Inserts the specified element at the specified position in this Vector.
   * Shifts the element currently at that position (if any) and any
   * subsequent elements to the right (adds one to their indices).
   *
   * @param index index at which the specified element is to be inserted
   * @param element element to be inserted
   * @throws ArrayIndexOutOfBoundsException if the index is out of range
   *         (`index < 0 || index > size()`)
   * @since 1.2
  */
  add(index: number, element: E): void;
  /**
   * Removes the element at the specified position in this Vector.
   * Shifts any subsequent elements to the left (subtracts one from their
   * indices).  Returns the element that was removed from the Vector.
   *
   * @param index the index of the element to be removed
   * @return element that was removed
   * @throws ArrayIndexOutOfBoundsException if the index is out of range
   *         (`index < 0 || index >= size()`)
   * @since 1.2
  */
  remove(index: number): E;
  /**
   * Removes all of the elements from this Vector.  The Vector will
   * be empty after this call returns (unless it throws an exception).
   *
   * @since 1.2
  */
  clear(): void;
  /**
   * Returns true if this Vector contains all of the elements in the
   * specified Collection.
   *
   * @param   c a collection whose elements will be tested for containment
   *          in this Vector
   * @return true if this Vector contains all of the elements in the
   *         specified collection
   * @throws NullPointerException if the specified collection is null
  */
  containsAll(c: Collection<any>): boolean;
  /**
   * Appends all of the elements in the specified Collection to the end of
   * this Vector, in the order that they are returned by the specified
   * Collection's Iterator.  The behavior of this operation is undefined if
   * the specified Collection is modified while the operation is in progress.
   * (This implies that the behavior of this call is undefined if the
   * specified Collection is this Vector, and this Vector is nonempty.)
   *
   * @param c elements to be inserted into this Vector
   * @return `true` if this Vector changed as a result of the call
   * @throws NullPointerException if the specified collection is null
   * @since 1.2
  */
  addAll(c: Collection<E>): boolean;
  /**
   * Removes from this Vector all of its elements that are contained in the
   * specified Collection.
   *
   * @param c a collection of elements to be removed from the Vector
   * @return true if this Vector changed as a result of the call
   * @throws ClassCastException if the types of one or more elements
   *         in this vector are incompatible with the specified
   *         collection
   * (optional)
   * @throws NullPointerException if this vector contains one or more null
   *         elements and the specified collection does not support null
   *         elements
   * (optional),
   *         or if the specified collection is null
   * @since 1.2
  */
  removeAll(c: Collection<any>): boolean;
  /**
   * Retains only the elements in this Vector that are contained in the
   * specified Collection.  In other words, removes from this Vector all
   * of its elements that are not contained in the specified Collection.
   *
   * @param c a collection of elements to be retained in this Vector
   *          (all other elements are removed)
   * @return true if this Vector changed as a result of the call
   * @throws ClassCastException if the types of one or more elements
   *         in this vector are incompatible with the specified
   *         collection
   * (optional)
   * @throws NullPointerException if this vector contains one or more null
   *         elements and the specified collection does not support null
   *         elements
   *         (optional),
   *         or if the specified collection is null
   * @since 1.2
  */
  retainAll(c: Collection<any>): boolean;
  /**
   * @throws NullPointerException {@inheritDoc}
  */
  removeIf(filter: Predicate<any>): boolean;
  /**
   * Inserts all of the elements in the specified Collection into this
   * Vector at the specified position.  Shifts the element currently at
   * that position (if any) and any subsequent elements to the right
   * (increases their indices).  The new elements will appear in the Vector
   * in the order that they are returned by the specified Collection's
   * iterator.
   *
   * @param index index at which to insert the first element from the
   *              specified collection
   * @param c elements to be inserted into this Vector
   * @return `true` if this Vector changed as a result of the call
   * @throws ArrayIndexOutOfBoundsException if the index is out of range
   *         (`index < 0 || index > size()`)
   * @throws NullPointerException if the specified collection is null
   * @since 1.2
  */
  addAll(index: number, c: Collection<E>): boolean;
  /**
   * Compares the specified Object with this Vector for equality.  Returns
   * true if and only if the specified Object is also a List, both Lists
   * have the same size, and all corresponding pairs of elements in the two
   * Lists are equal.  (Two elements `e1` and
   * `e2` are equal if `Objects.equals(e1, e2)`.)
   * In other words, two Lists are defined to be
   * equal if they contain the same elements in the same order.
   *
   * @param o the Object to be compared for equality with this Vector
   * @return true if the specified Object is equal to this Vector
  */
  equals(o: any): boolean;
  /**
   * Returns the hash code value for this Vector.
  */
  hashCode(): number;
  /**
   * Returns a string representation of this Vector, containing
   * the String representation of each element.
  */
  toString(): string;
  /**
   * Returns a view of the portion of this List between fromIndex,
   * inclusive, and toIndex, exclusive.  (If fromIndex and toIndex are
   * equal, the returned List is empty.)  The returned List is backed by this
   * List, so changes in the returned List are reflected in this List, and
   * vice-versa.  The returned List supports all of the optional List
   * operations supported by this List.
   *
   * This method eliminates the need for explicit range operations (of
   * the sort that commonly exist for arrays).  Any operation that expects
   * a List can be used as a range operation by operating on a subList view
   * instead of a whole List.  For example, the following idiom
   * removes a range of elements from a List:
   *      *      list.subList(from, to).clear();
   * 
   * Similar idioms may be constructed for indexOf and lastIndexOf,
   * and all of the algorithms in the Collections class can be applied to
   * a subList.
   *
   * The semantics of the List returned by this method become undefined if
   * the backing list (i.e., this List) is structurally modified in
   * any way other than via the returned List.  (Structural modifications are
   * those that change the size of the List, or otherwise perturb it in such
   * a fashion that iterations in progress may yield incorrect results.)
   *
   * @param fromIndex low endpoint (inclusive) of the subList
   * @param toIndex high endpoint (exclusive) of the subList
   * @return a view of the specified range within this List
   * @throws IndexOutOfBoundsException if an endpoint index value is out of range
   *         `(fromIndex < 0 || toIndex > size)`
   * @throws IllegalArgumentException if the endpoint indices are out of order
   *         `(fromIndex > toIndex)`
  */
  subList(fromIndex: number, toIndex: number): E[];
  /**
   * Returns a list iterator over the elements in this list (in proper
   * sequence), starting at the specified position in the list.
   * The specified index indicates the first element that would be
   * returned by an initial call to {@link ListIterator#next next}.
   * An initial call to {@link ListIterator#previous previous} would
   * return the element with the specified index minus one.
   *
   * The returned list iterator is fail-fast.
   *
   * @throws IndexOutOfBoundsException {@inheritDoc}
  */
  listIterator(index: number): ListIterator<E>;
  /**
   * Returns a list iterator over the elements in this list (in proper
   * sequence).
   *
   * The returned list iterator is fail-fast.
   *
   * @see #listIterator(int)
  */
  listIterator(): ListIterator<E>;
  /**
   * Returns an iterator over the elements in this list in proper sequence.
   *
   * The returned iterator is fail-fast.
   *
   * @return an iterator over the elements in this list in proper sequence
  */
  iterator(): Iterator<E>;
  /**
   * @throws NullPointerException {@inheritDoc}
  */
  forEach(action: Consumer<any>): void;
  /**
   * @throws NullPointerException {@inheritDoc}
  */
  replaceAll(operator: UnaryOperator<E>): void;
  /**
   * Sorts this list according to the order induced by the specified
   * {@link Comparator}.  The sort is stable: this method must not
   * reorder equal elements.
   *
   * All elements in this list must be mutually comparable using the
   * specified comparator (that is, `c.compare(e1, e2)` must not throw
   * a `ClassCastException` for any elements `e1` and `e2`
   * in the list).
   *
   * If the specified comparator is `null` then all elements in this
   * list must implement the {@link Comparable} interface and the elements'
   * {@linkplain Comparable natural ordering} should be used.
   *
   * This list must be modifiable, but need not be resizable.
   *
   * @implSpec
   * The default implementation obtains an array containing all elements in
   * this list, sorts the array, and iterates over this list resetting each
   * element from the corresponding position in the array. (This avoids the
   * n2 log(n) performance that would result from attempting
   * to sort a linked list in place.)
   *
   * @implNote
   * This implementation is a stable, adaptive, iterative mergesort that
   * requires far fewer than n lg(n) comparisons when the input array is
   * partially sorted, while offering the performance of a traditional
   * mergesort when the input array is randomly ordered.  If the input array
   * is nearly sorted, the implementation requires approximately n
   * comparisons.  Temporary storage requirements vary from a small constant
   * for nearly sorted input arrays to n/2 object references for randomly
   * ordered input arrays.
   *
   * The implementation takes equal advantage of ascending and
   * descending order in its input array, and can take advantage of
   * ascending and descending order in different parts of the same
   * input array.  It is well-suited to merging two or more sorted arrays:
   * simply concatenate the arrays and sort the resulting array.
   *
   * The implementation was adapted from Tim Peters's list sort for Python
   * (
   * TimSort).  It uses techniques from Peter McIlroy's "Optimistic
   * Sorting and Information Theoretic Complexity", in Proceedings of the
   * Fourth Annual ACM-SIAM Symposium on Discrete Algorithms, pp 467-474,
   * January 1993.
   *
   * @param c the `Comparator` used to compare list elements.
   *          A `null` value indicates that the elements'
   *          {@linkplain Comparable natural ordering} should be used
   * @throws ClassCastException if the list contains elements that are not
   *         mutually comparable using the specified comparator
   * @throws UnsupportedOperationException if the list's list-iterator does
   *         not support the `set` operation
   * @throws IllegalArgumentException
   *         (optional)
   *         if the comparator is found to violate the {@link Comparator}
   *         contract
   * @since 1.8
  */
  sort(c: Comparator<any>): void;
  /**
   * Creates a late-binding
   * and fail-fast {@link Spliterator} over the elements in this
   * list.
   *
   * The `Spliterator` reports {@link Spliterator#SIZED},
   * {@link Spliterator#SUBSIZED}, and {@link Spliterator#ORDERED}.
   * Overriding implementations should document the reporting of additional
   * characteristic values.
   *
   * @return a `Spliterator` over the elements in this list
   * @since 1.8
  */
  spliterator(): Spliterator<E>;
  /**
   * Returns an array containing all of the elements in this collection,
   * using the provided `generator` function to allocate the returned array.
   *
   * If this collection makes any guarantees as to what order its elements
   * are returned by its iterator, this method must return the elements in
   * the same order.
   *
   * @apiNote
   * This method acts as a bridge between array-based and collection-based APIs.
   * It allows creation of an array of a particular runtime type. Use
   * {@link #toArray()} to create an array whose runtime type is `Object[]`,
   * or use {@link #toArray(Object[]) toArray(T[])} to reuse an existing array.
   *
   * Suppose `x` is a collection known to contain only strings.
   * The following code can be used to dump the collection into a newly
   * allocated array of `String`:
   *
   *      *     String[] y = x.toArray(String[]::new);
   *
   * @implSpec
   * The default implementation calls the generator function with zero
   * and then passes the resulting array to {@link #toArray(Object[]) toArray(T[])}.
   *
   * @param  the component type of the array to contain the collection
   * @param generator a function which produces a new array of the desired
   *                  type and the provided length
   * @return an array containing all of the elements in this collection
   * @throws ArrayStoreException if the runtime type of any element in this
   *         collection is not assignable to the {@linkplain Class#getComponentType
   *         runtime component type} of the generated array
   * @throws NullPointerException if the generator function is null
   * @since 11
  */
  toArray<T>(generator: IntFunction<T[]>): T[];
}
export interface Vector<E> extends AbstractList<E>, RandomAccess, Cloneable, Serializable {}
/**
 * Signals that a resource is missing.
 * @see java.lang.Exception
 * @see ResourceBundle
 * @author      Mark Davis
 * @since       1.1
*/
export class MissingResourceException extends RuntimeException {
  /**
   * Constructs a MissingResourceException with the specified information.
   * A detail message is a String that describes this particular exception.
   * @param s the detail message
   * @param className the name of the resource class
   * @param key the key for the missing resource.
  */
  constructor(s: string, className: string, key: string);
  /**
   * Gets parameter passed by constructor.
   *
   * @return the name of the resource class
  */
  getClassName(): string;
  /**
   * Gets parameter passed by constructor.
   *
   * @return the key for the missing resource
  */
  getKey(): string;
}
/**
 * An abstract wrapper class for an `EventListener` class
 * which associates a set of additional parameters with the listener.
 * Subclasses must provide the storage and accessor methods
 * for the additional arguments or parameters.
 * 
 * For example, a bean which supports named properties
 * would have a two argument method signature for adding
 * a `PropertyChangeListener` for a property:
 *  * public void addPropertyChangeListener(String propertyName,
 *                                       PropertyChangeListener listener)
 * 
 * If the bean also implemented the zero argument get listener method:
 *  * public PropertyChangeListener[] getPropertyChangeListeners()
 * 
 * then the array may contain inner `PropertyChangeListeners`
 * which are also `PropertyChangeListenerProxy` objects.
 * 
 * If the calling method is interested in retrieving the named property
 * then it would have to test the element to see if it is a proxy class.
 *
 * @since 1.4
*/
export class EventListenerProxy<T> extends EventListener {
  /**
   * Creates a proxy for the specified listener.
   *
   * @param listener  the listener object
  */
  constructor(listener: T);
  /**
   * Returns the listener associated with the proxy.
   *
   * @return  the listener associated with the proxy
  */
  getListener(): T;
}
/**
 * Represents a currency. Currencies are identified by their ISO 4217 currency
 * codes. Visit the 
 * ISO web site for more information.
 * 
 * The class is designed so that there's never more than one
 * `Currency` instance for any given currency. Therefore, there's
 * no public constructor. You obtain a `Currency` instance using
 * the `getInstance` methods.
 * 
 * Users can supersede the Java runtime currency data by means of the system
 * property {@systemProperty java.util.currency.data}. If this system property is
 * defined then its value is the location of a properties file, the contents of
 * which are key/value pairs of the ISO 3166 country codes and the ISO 4217
 * currency data respectively.  The value part consists of three ISO 4217 values
 * of a currency, i.e., an alphabetic code, a numeric code, and a minor unit.
 * Those three ISO 4217 values are separated by commas.
 * The lines which start with '#'s are considered comment lines. An optional UTC
 * timestamp may be specified per currency entry if users need to specify a
 * cutover date indicating when the new data comes into effect. The timestamp is
 * appended to the end of the currency properties and uses a comma as a separator.
 * If a UTC datestamp is present and valid, the JRE will only use the new currency
 * properties if the current UTC date is later than the date specified at class
 * loading time. The format of the timestamp must be of ISO 8601 format :
 * `'yyyy-MM-dd'T'HH:mm:ss'`. For example,
 * 
 * 
 * #Sample currency properties
 * JP=JPZ,999,0
 * 
 * 
 * will supersede the currency data for Japan. If JPZ is one of the existing
 * ISO 4217 currency code referred by other countries, the existing
 * JPZ currency data is updated with the given numeric code and minor
 * unit value.
 *
 * 
 * 
 * #Sample currency properties with cutover date
 * JP=JPZ,999,0,2014-01-01T00:00:00
 * 
 * 
 * will supersede the currency data for Japan if `Currency` class is loaded after
 * 1st January 2014 00:00:00 GMT.
 * 
 * Where syntactically malformed entries are encountered, the entry is ignored
 * and the remainder of entries in file are processed. For instances where duplicate
 * country code entries exist, the behavior of the Currency information for that
 * `Currency` is undefined and the remainder of entries in file are processed.
 * 
 * If multiple property entries with same currency code but different numeric code
 * and/or minor unit are encountered, those entries are ignored and the remainder
 * of entries in file are processed.
 *
 * 
 * It is recommended to use {@link java.math.BigDecimal} class while dealing
 * with `Currency` or monetary values as it provides better handling of floating
 * point numbers and their operations.
 *
 * @see java.math.BigDecimal
 * @since 1.4
*/
export class Currency extends Serializable {
  /**
   * Returns the `Currency` instance for the given currency code.
   *
   * @param currencyCode the ISO 4217 code of the currency
   * @return the `Currency` instance for the given currency code
   * @throws    NullPointerException if `currencyCode` is null
   * @throws    IllegalArgumentException if `currencyCode` is not
   * a supported ISO 4217 code.
  */
  static getInstance(currencyCode: string): Currency;
  /**
   * Returns the `Currency` instance for the country of the
   * given locale. The language and variant components of the locale
   * are ignored. The result may vary over time, as countries change their
   * currencies. For example, for the original member countries of the
   * European Monetary Union, the method returns the old national currencies
   * until December 31, 2001, and the Euro from January 1, 2002, local time
   * of the respective countries.
   * 
   * If the specified `locale` contains "cu" and/or "rg"
   * Unicode extensions,
   * the instance returned from this method reflects
   * the values specified with those extensions. If both "cu" and "rg" are
   * specified, the currency from the "cu" extension supersedes the implicit one
   * from the "rg" extension.
   * 
   * The method returns `null` for territories that don't
   * have a currency, such as Antarctica.
   *
   * @param locale the locale for whose country a `Currency`
   * instance is needed
   * @return the `Currency` instance for the country of the given
   * locale, or `null`
   * @throws    NullPointerException if `locale`
   * is `null`
   * @throws    IllegalArgumentException if the country of the given `locale`
   * is not a supported ISO 3166 country code.
  */
  static getInstance(locale: Locale): Currency;
  /**
   * Gets the set of available currencies.  The returned set of currencies
   * contains all of the available currencies, which may include currencies
   * that represent obsolete ISO 4217 codes.  The set can be modified
   * without affecting the available currencies in the runtime.
   *
   * @return the set of available currencies.  If there is no currency
   *    available in the runtime, the returned set is empty.
   * @since 1.7
  */
  static getAvailableCurrencies(): Set<Currency>;
  /**
   * Gets the ISO 4217 currency code of this currency.
   *
   * @return the ISO 4217 currency code of this currency.
  */
  getCurrencyCode(): string;
  /**
   * Gets the symbol of this currency for the default
   * {@link Locale.Category#DISPLAY DISPLAY} locale.
   * For example, for the US Dollar, the symbol is "$" if the default
   * locale is the US, while for other locales it may be "US$". If no
   * symbol can be determined, the ISO 4217 currency code is returned.
   * 
   * If the default {@link Locale.Category#DISPLAY DISPLAY} locale
   * contains "rg" (region override)
   * Unicode extension,
   * the symbol returned from this method reflects
   * the value specified with that extension.
   * 
   * This is equivalent to calling
   * {@link #getSymbol(Locale)
   *     getSymbol(Locale.getDefault(Locale.Category.DISPLAY))}.
   *
   * @return the symbol of this currency for the default
   *     {@link Locale.Category#DISPLAY DISPLAY} locale
  */
  getSymbol(): string;
  /**
   * Gets the symbol of this currency for the specified locale.
   * For example, for the US Dollar, the symbol is "$" if the specified
   * locale is the US, while for other locales it may be "US$". If no
   * symbol can be determined, the ISO 4217 currency code is returned.
   * 
   * If the specified `locale` contains "rg" (region override)
   * Unicode extension,
   * the symbol returned from this method reflects
   * the value specified with that extension.
   *
   * @param locale the locale for which a display name for this currency is
   * needed
   * @return the symbol of this currency for the specified locale
   * @throws    NullPointerException if `locale` is null
  */
  getSymbol(locale: Locale): string;
  /**
   * Gets the default number of fraction digits used with this currency.
   * Note that the number of fraction digits is the same as ISO 4217's
   * minor unit for the currency.
   * For example, the default number of fraction digits for the Euro is 2,
   * while for the Japanese Yen it's 0.
   * In the case of pseudo-currencies, such as IMF Special Drawing Rights,
   * -1 is returned.
   *
   * @return the default number of fraction digits used with this currency
  */
  getDefaultFractionDigits(): number;
  /**
   * Returns the ISO 4217 numeric code of this currency.
   *
   * @return the ISO 4217 numeric code of this currency
   * @since 1.7
  */
  getNumericCode(): number;
  /**
   * Returns the 3 digit ISO 4217 numeric code of this currency as a `String`.
   * Unlike {@link #getNumericCode()}, which returns the numeric code as `int`,
   * this method always returns the numeric code as a 3 digit string.
   * e.g. a numeric value of 32 would be returned as "032",
   * and a numeric value of 6 would be returned as "006".
   *
   * @return the 3 digit ISO 4217 numeric code of this currency as a `String`
   * @since 9
  */
  getNumericCodeAsString(): string;
  /**
   * Gets the name that is suitable for displaying this currency for
   * the default {@link Locale.Category#DISPLAY DISPLAY} locale.
   * If there is no suitable display name found
   * for the default locale, the ISO 4217 currency code is returned.
   * 
   * This is equivalent to calling
   * {@link #getDisplayName(Locale)
   *     getDisplayName(Locale.getDefault(Locale.Category.DISPLAY))}.
   *
   * @return the display name of this currency for the default
   *     {@link Locale.Category#DISPLAY DISPLAY} locale
   * @since 1.7
  */
  getDisplayName(): string;
  /**
   * Gets the name that is suitable for displaying this currency for
   * the specified locale.  If there is no suitable display name found
   * for the specified locale, the ISO 4217 currency code is returned.
   *
   * @param locale the locale for which a display name for this currency is
   * needed
   * @return the display name of this currency for the specified locale
   * @throws    NullPointerException if `locale` is null
   * @since 1.7
  */
  getDisplayName(locale: Locale): string;
  /**
   * Returns the ISO 4217 currency code of this currency.
   *
   * @return the ISO 4217 currency code of this currency
  */
  toString(): string;
}
/**
 * Hash table and linked list implementation of the `Map` interface,
 * with predictable iteration order.  This implementation differs from
 * `HashMap` in that it maintains a doubly-linked list running through
 * all of its entries.  This linked list defines the iteration ordering,
 * which is normally the order in which keys were inserted into the map
 * (insertion-order).  Note that insertion order is not affected
 * if a key is re-inserted into the map.  (A key `k` is
 * reinserted into a map `m` if `m.put(k, v)` is invoked when
 * `m.containsKey(k)` would return `true` immediately prior to
 * the invocation.)
 *
 * This implementation spares its clients from the unspecified, generally
 * chaotic ordering provided by {@link HashMap} (and {@link Hashtable}),
 * without incurring the increased cost associated with {@link TreeMap}.  It
 * can be used to produce a copy of a map that has the same order as the
 * original, regardless of the original map's implementation:
 * {@code
 *     void foo(Map m) {
 *         Map copy = new LinkedHashMap<>(m);
 *         ...
 *     }
 * }
 * This technique is particularly useful if a module takes a map on input,
 * copies it, and later returns results whose order is determined by that of
 * the copy.  (Clients generally appreciate having things returned in the same
 * order they were presented.)
 *
 * A special {@link #LinkedHashMap(int,float,boolean) constructor} is
 * provided to create a linked hash map whose order of iteration is the order
 * in which its entries were last accessed, from least-recently accessed to
 * most-recently (access-order).  This kind of map is well-suited to
 * building LRU caches.  Invoking the `put`, `putIfAbsent`,
 * `get`, `getOrDefault`, `compute`, `computeIfAbsent`,
 * `computeIfPresent`, or `merge` methods results
 * in an access to the corresponding entry (assuming it exists after the
 * invocation completes). The `replace` methods only result in an access
 * of the entry if the value is replaced.  The `putAll` method generates one
 * entry access for each mapping in the specified map, in the order that
 * key-value mappings are provided by the specified map's entry set iterator.
 * No other methods generate entry accesses.  In particular, operations
 * on collection-views do not affect the order of iteration of the
 * backing map.
 *
 * The {@link #removeEldestEntry(Map.Entry)} method may be overridden to
 * impose a policy for removing stale mappings automatically when new mappings
 * are added to the map.
 *
 * This class provides all of the optional `Map` operations, and
 * permits null elements.  Like `HashMap`, it provides constant-time
 * performance for the basic operations (`add`, `contains` and
 * `remove`), assuming the hash function disperses elements
 * properly among the buckets.  Performance is likely to be just slightly
 * below that of `HashMap`, due to the added expense of maintaining the
 * linked list, with one exception: Iteration over the collection-views
 * of a `LinkedHashMap` requires time proportional to the size
 * of the map, regardless of its capacity.  Iteration over a `HashMap`
 * is likely to be more expensive, requiring time proportional to its
 * capacity.
 *
 * A linked hash map has two parameters that affect its performance:
 * initial capacity and load factor.  They are defined precisely
 * as for `HashMap`.  Note, however, that the penalty for choosing an
 * excessively high value for initial capacity is less severe for this class
 * than for `HashMap`, as iteration times for this class are unaffected
 * by capacity.
 *
 * Note that this implementation is not synchronized.
 * If multiple threads access a linked hash map concurrently, and at least
 * one of the threads modifies the map structurally, it must be
 * synchronized externally.  This is typically accomplished by
 * synchronizing on some object that naturally encapsulates the map.
 *
 * If no such object exists, the map should be "wrapped" using the
 * {@link Collections#synchronizedMap Collections.synchronizedMap}
 * method.  This is best done at creation time, to prevent accidental
 * unsynchronized access to the map: *   Map m = Collections.synchronizedMap(new LinkedHashMap(...));
 *
 * A structural modification is any operation that adds or deletes one or more
 * mappings or, in the case of access-ordered linked hash maps, affects
 * iteration order.  In insertion-ordered linked hash maps, merely changing
 * the value associated with a key that is already contained in the map is not
 * a structural modification.  In access-ordered linked hash maps,
 * merely querying the map with `get` is a structural modification.
 * )
 *
 * The iterators returned by the `iterator` method of the collections
 * returned by all of this class's collection view methods are
 * fail-fast: if the map is structurally modified at any time after
 * the iterator is created, in any way except through the iterator's own
 * `remove` method, the iterator will throw a {@link
 * ConcurrentModificationException}.  Thus, in the face of concurrent
 * modification, the iterator fails quickly and cleanly, rather than risking
 * arbitrary, non-deterministic behavior at an undetermined time in the future.
 *
 * Note that the fail-fast behavior of an iterator cannot be guaranteed
 * as it is, generally speaking, impossible to make any hard guarantees in the
 * presence of unsynchronized concurrent modification.  Fail-fast iterators
 * throw `ConcurrentModificationException` on a best-effort basis.
 * Therefore, it would be wrong to write a program that depended on this
 * exception for its correctness:   the fail-fast behavior of iterators
 * should be used only to detect bugs.
 *
 * The spliterators returned by the spliterator method of the collections
 * returned by all of this class's collection view methods are
 * late-binding,
 * fail-fast, and additionally report {@link Spliterator#ORDERED}.
 *
 * This class is a member of the
 * 
 * Java Collections Framework.
 *
 * @implNote
 * The spliterators returned by the spliterator method of the collections
 * returned by all of this class's collection view methods are created from
 * the iterators of the corresponding collections.
 *
 * @param  the type of keys maintained by this map
 * @param  the type of mapped values
 *
 * @author  Josh Bloch
 * @see     Object#hashCode()
 * @see     Collection
 * @see     Map
 * @see     HashMap
 * @see     TreeMap
 * @see     Hashtable
 * @since   1.4
*/
export class LinkedHashMap<K, V> extends HashMap<K, V> {
  /**
   * Constructs an empty insertion-ordered `LinkedHashMap` instance
   * with the specified initial capacity and load factor.
   *
   * @param  initialCapacity the initial capacity
   * @param  loadFactor      the load factor
   * @throws IllegalArgumentException if the initial capacity is negative
   *         or the load factor is nonpositive
  */
  constructor(initialCapacity: number, loadFactor: number);
  /**
   * Constructs an empty insertion-ordered `LinkedHashMap` instance
   * with the specified initial capacity and a default load factor (0.75).
   *
   * @param  initialCapacity the initial capacity
   * @throws IllegalArgumentException if the initial capacity is negative
  */
  constructor(initialCapacity: number);
  /**
   * Constructs an empty insertion-ordered `LinkedHashMap` instance
   * with the default initial capacity (16) and load factor (0.75).
  */
  constructor();
  /**
   * Constructs an insertion-ordered `LinkedHashMap` instance with
   * the same mappings as the specified map.  The `LinkedHashMap`
   * instance is created with a default load factor (0.75) and an initial
   * capacity sufficient to hold the mappings in the specified map.
   *
   * @param  m the map whose mappings are to be placed in this map
   * @throws NullPointerException if the specified map is null
  */
  constructor(m: Map<K, V>);
  /**
   * Constructs an empty `LinkedHashMap` instance with the
   * specified initial capacity, load factor and ordering mode.
   *
   * @param  initialCapacity the initial capacity
   * @param  loadFactor      the load factor
   * @param  accessOrder     the ordering mode - `true` for
   *         access-order, `false` for insertion-order
   * @throws IllegalArgumentException if the initial capacity is negative
   *         or the load factor is nonpositive
  */
  constructor(initialCapacity: number, loadFactor: number, accessOrder: boolean);
  /**
   * Returns `true` if this map maps one or more keys to the
   * specified value.
   *
   * @param value value whose presence in this map is to be tested
   * @return `true` if this map maps one or more keys to the
   *         specified value
  */
  containsValue(value: any): boolean;
  /**
   * Returns the value to which the specified key is mapped,
   * or `null` if this map contains no mapping for the key.
   *
   * More formally, if this map contains a mapping from a key
   * `k` to a value `v` such that {@code (key==null ? k==null :
   * key.equals(k))}, then this method returns `v`; otherwise
   * it returns `null`.  (There can be at most one such mapping.)
   *
   * A return value of `null` does not necessarily
   * indicate that the map contains no mapping for the key; it's also
   * possible that the map explicitly maps the key to `null`.
   * The {@link #containsKey containsKey} operation may be used to
   * distinguish these two cases.
  */
  get(key: any): V;
  /**
   * {@inheritDoc}
  */
  getOrDefault(key: any, defaultValue: V): V;
  /**
   * {@inheritDoc}
  */
  clear(): void;
  /**
   * Returns a {@link Set} view of the keys contained in this map.
   * The set is backed by the map, so changes to the map are
   * reflected in the set, and vice-versa.  If the map is modified
   * while an iteration over the set is in progress (except through
   * the iterator's own `remove` operation), the results of
   * the iteration are undefined.  The set supports element removal,
   * which removes the corresponding mapping from the map, via the
   * `Iterator.remove`, `Set.remove`,
   * `removeAll`, `retainAll`, and `clear`
   * operations.  It does not support the `add` or `addAll`
   * operations.
   * Its {@link Spliterator} typically provides faster sequential
   * performance but much poorer parallel performance than that of
   * `HashMap`.
   *
   * @return a set view of the keys contained in this map
  */
  keySet(): Set<K>;
  /**
   * Returns a {@link Collection} view of the values contained in this map.
   * The collection is backed by the map, so changes to the map are
   * reflected in the collection, and vice-versa.  If the map is
   * modified while an iteration over the collection is in progress
   * (except through the iterator's own `remove` operation),
   * the results of the iteration are undefined.  The collection
   * supports element removal, which removes the corresponding
   * mapping from the map, via the `Iterator.remove`,
   * `Collection.remove`, `removeAll`,
   * `retainAll` and `clear` operations.  It does not
   * support the `add` or `addAll` operations.
   * Its {@link Spliterator} typically provides faster sequential
   * performance but much poorer parallel performance than that of
   * `HashMap`.
   *
   * @return a view of the values contained in this map
  */
  values(): Collection<V>;
  /**
   * Returns a {@link Set} view of the mappings contained in this map.
   * The set is backed by the map, so changes to the map are
   * reflected in the set, and vice-versa.  If the map is modified
   * while an iteration over the set is in progress (except through
   * the iterator's own `remove` operation, or through the
   * `setValue` operation on a map entry returned by the
   * iterator) the results of the iteration are undefined.  The set
   * supports element removal, which removes the corresponding
   * mapping from the map, via the `Iterator.remove`,
   * `Set.remove`, `removeAll`, `retainAll` and
   * `clear` operations.  It does not support the
   * `add` or `addAll` operations.
   * Its {@link Spliterator} typically provides faster sequential
   * performance but much poorer parallel performance than that of
   * `HashMap`.
   *
   * @return a set view of the mappings contained in this map
  */
  entrySet(): Set<java_util_Map_Entry<K, V>>;
  forEach(action: BiConsumer<any, any>): void;
  replaceAll(func: BiFunction<any, any, V>): void;
}
export interface LinkedHashMap<K, V> extends HashMap<K, V>, Map<K, V> {}
/**
 * A container object which may or may not contain a `long` value.
 * If a value is present, `isPresent()` returns `true`. If no
 * value is present, the object is considered empty and
 * `isPresent()` returns `false`.
 *
 * Additional methods that depend on the presence or absence of a contained
 * value are provided, such as {@link #orElse(long) orElse()}
 * (returns a default value if no value is present) and
 * {@link #ifPresent(LongConsumer) ifPresent()} (performs an
 * action if a value is present).
 *
 * This is a value-based
 * class; programmers should treat instances that are
 * {@linkplain #equals(Object) equal} as interchangeable and should not
 * use instances for synchronization, or unpredictable behavior may
 * occur. For example, in a future release, synchronization may fail.
 *
 * @apiNote
 * `OptionalLong` is primarily intended for use as a method return type where
 * there is a clear need to represent "no result." A variable whose type is
 * `OptionalLong` should never itself be `null`; it should always point
 * to an `OptionalLong` instance.
 *
 * @since 1.8
*/
export class OptionalLong {
  /**
   * Returns an empty `OptionalLong` instance.  No value is present for
   * this `OptionalLong`.
   *
   * @apiNote
   * Though it may be tempting to do so, avoid testing if an object is empty
   * by comparing with `==` or `!=` against instances returned by
   * `OptionalLong.empty()`.  There is no guarantee that it is a singleton.
   * Instead, use {@link #isEmpty()} or {@link #isPresent()}.
   *
   * @return an empty `OptionalLong`.
  */
  static empty(): OptionalLong;
  /**
   * Returns an `OptionalLong` describing the given value.
   *
   * @param value the value to describe
   * @return an `OptionalLong` with the value present
  */
  static of(value: number): OptionalLong;
  /**
   * If a value is present, returns the value, otherwise throws
   * `NoSuchElementException`.
   *
   * @apiNote
   * The preferred alternative to this method is {@link #orElseThrow()}.
   *
   * @return the value described by this `OptionalLong`
   * @throws NoSuchElementException if no value is present
  */
  getAsLong(): number;
  /**
   * If a value is present, returns `true`, otherwise `false`.
   *
   * @return `true` if a value is present, otherwise `false`
  */
  isPresent(): boolean;
  /**
   * If a value is not present, returns `true`, otherwise
   * `false`.
   *
   * @return  `true` if a value is not present, otherwise `false`
   * @since   11
  */
  isEmpty(): boolean;
  /**
   * If a value is present, performs the given action with the value,
   * otherwise does nothing.
   *
   * @param action the action to be performed, if a value is present
   * @throws NullPointerException if value is present and the given action is
   *         `null`
  */
  ifPresent(action: LongConsumer): void;
  /**
   * If a value is present, performs the given action with the value,
   * otherwise performs the given empty-based action.
   *
   * @param action the action to be performed, if a value is present
   * @param emptyAction the empty-based action to be performed, if no value is
   *        present
   * @throws NullPointerException if a value is present and the given action
   *         is `null`, or no value is present and the given empty-based
   *         action is `null`.
   * @since 9
  */
  ifPresentOrElse(action: LongConsumer, emptyAction: Runnable): void;
  /**
   * If a value is present, returns a sequential {@link LongStream} containing
   * only that value, otherwise returns an empty `LongStream`.
   *
   * @apiNote
   * This method can be used to transform a `Stream` of optional longs
   * to an `LongStream` of present longs:
   * {@code
   *     Stream os = ..
   *     LongStream s = os.flatMapToLong(OptionalLong::stream)
   * }
   *
   * @return the optional value as an `LongStream`
   * @since 9
  */
  stream(): LongStream;
  /**
   * If a value is present, returns the value, otherwise returns
   * `other`.
   *
   * @param other the value to be returned, if no value is present
   * @return the value, if present, otherwise `other`
  */
  orElse(other: number): number;
  /**
   * If a value is present, returns the value, otherwise returns the result
   * produced by the supplying function.
   *
   * @param supplier the supplying function that produces a value to be returned
   * @return the value, if present, otherwise the result produced by the
   *         supplying function
   * @throws NullPointerException if no value is present and the supplying
   *         function is `null`
  */
  orElseGet(supplier: LongSupplier): number;
  /**
   * If a value is present, returns the value, otherwise throws
   * `NoSuchElementException`.
   *
   * @return the value described by this `OptionalLong`
   * @throws NoSuchElementException if no value is present
   * @since 10
  */
  orElseThrow(): number;
  /**
   * If a value is present, returns the value, otherwise throws an exception
   * produced by the exception supplying function.
   *
   * @apiNote
   * A method reference to the exception constructor with an empty argument
   * list can be used as the supplier. For example,
   * `IllegalStateException::new`
   *
   * @param  Type of the exception to be thrown
   * @param exceptionSupplier the supplying function that produces an
   *        exception to be thrown
   * @return the value, if present
   * @throws X if no value is present
   * @throws NullPointerException if no value is present and the exception
   *         supplying function is `null`
  */
  orElseThrow<X>(exceptionSupplier: Supplier<X>): number;
  /**
   * Indicates whether some other object is "equal to" this
   * `OptionalLong`.  The other object is considered equal if:
   * 
   * it is also an `OptionalLong` and;
   * both instances have no value present or;
   * the present values are "equal to" each other via `==`.
   * 
   *
   * @param obj an object to be tested for equality
   * @return `true` if the other object is "equal to" this object
   *         otherwise `false`
  */
  equals(obj: any): boolean;
  /**
   * Returns the hash code of the value, if present, otherwise `0`
   * (zero) if no value is present.
   *
   * @return hash code value of the present value or `0` if no value is
   *         present
  */
  hashCode(): number;
  /**
   * Returns a non-empty string representation of this `OptionalLong`
   * suitable for debugging.  The exact presentation format is unspecified and
   * may vary between implementations and versions.
   *
   * @implSpec
   * If a value is present the result must include its string representation
   * in the result.  Empty and present `OptionalLong`s must be
   * unambiguously differentiable.
   *
   * @return the string representation of this instance
  */
  toString(): string;
}
/**
 * The `Calendar` class is an abstract class that provides methods
 * for converting between a specific instant in time and a set of {@link
 * #fields calendar fields} such as `YEAR`, `MONTH`,
 * `DAY_OF_MONTH`, `HOUR`, and so on, and for
 * manipulating the calendar fields, such as getting the date of the next
 * week. An instant in time can be represented by a millisecond value that is
 * an offset from the Epoch, January 1, 1970
 * 00:00:00.000 GMT (Gregorian).
 *
 * The class also provides additional fields and methods for
 * implementing a concrete calendar system outside the package. Those
 * fields and methods are defined as `protected`.
 *
 * 
 * Like other locale-sensitive classes, `Calendar` provides a
 * class method, `getInstance`, for getting a generally useful
 * object of this type. `Calendar`'s `getInstance` method
 * returns a `Calendar` object whose
 * calendar fields have been initialized with the current date and time:
 * 
 *  *     Calendar rightNow = Calendar.getInstance();
 * 
 * 
 *
 * A `Calendar` object can produce all the calendar field values
 * needed to implement the date-time formatting for a particular language and
 * calendar style (for example, Japanese-Gregorian, Japanese-Traditional).
 * `Calendar` defines the range of values returned by
 * certain calendar fields, as well as their meaning.  For example,
 * the first month of the calendar system has value MONTH ==
 * JANUARY for all calendars.  Other values are defined by the
 * concrete subclass, such as `ERA`.  See individual field
 * documentation and subclass documentation for details.
 *
 * Getting and Setting Calendar Field Values
 *
 * The calendar field values can be set by calling the `set`
 * methods. Any field values set in a `Calendar` will not be
 * interpreted until it needs to calculate its time value (milliseconds from
 * the Epoch) or values of the calendar fields. Calling the
 * `get`, `getTimeInMillis`, `getTime`,
 * `add` and `roll` involves such calculation.
 *
 * Leniency
 *
 * `Calendar` has two modes for interpreting the calendar
 * fields, lenient and non-lenient.  When a
 * `Calendar` is in lenient mode, it accepts a wider range of
 * calendar field values than it produces.  When a `Calendar`
 * recomputes calendar field values for return by `get()`, all of
 * the calendar fields are normalized. For example, a lenient
 * `GregorianCalendar` interprets `MONTH == JANUARY`,
 * `DAY_OF_MONTH == 32` as February 1.
 *
 * When a `Calendar` is in non-lenient mode, it throws an
 * exception if there is any inconsistency in its calendar fields. For
 * example, a `GregorianCalendar` always produces
 * `DAY_OF_MONTH` values between 1 and the length of the month. A
 * non-lenient `GregorianCalendar` throws an exception upon
 * calculating its time or calendar field values if any out-of-range field
 * value has been set.
 *
 * First Week
 *
 * `Calendar` defines a locale-specific seven day week using two
 * parameters: the first day of the week and the minimal days in first week
 * (from 1 to 7).  These numbers are taken from the locale resource data or the
 * locale itself when a `Calendar` is constructed. If the designated
 * locale contains "fw" and/or "rg" 
 * Unicode extensions, the first day of the week will be obtained according to
 * those extensions. If both "fw" and "rg" are specified, the value from the "fw"
 * extension supersedes the implicit one from the "rg" extension.
 * They may also be specified explicitly through the methods for setting their
 * values.
 *
 * When setting or getting the `WEEK_OF_MONTH` or
 * `WEEK_OF_YEAR` fields, `Calendar` must determine the
 * first week of the month or year as a reference point.  The first week of a
 * month or year is defined as the earliest seven day period beginning on
 * `getFirstDayOfWeek()` and containing at least
 * `getMinimalDaysInFirstWeek()` days of that month or year.  Weeks
 * numbered ..., -1, 0 precede the first week; weeks numbered 2, 3,... follow
 * it.  Note that the normalized numbering returned by `get()` may be
 * different.  For example, a specific `Calendar` subclass may
 * designate the week before week 1 of a year as week n of
 * the previous year.
 *
 * Calendar Fields Resolution
 *
 * When computing a date and time from the calendar fields, there
 * may be insufficient information for the computation (such as only
 * year and month with no day of month), or there may be inconsistent
 * information (such as Tuesday, July 15, 1996 (Gregorian) -- July 15,
 * 1996 is actually a Monday). `Calendar` will resolve
 * calendar field values to determine the date and time in the
 * following way.
 *
 * If there is any conflict in calendar field values,
 * `Calendar` gives priorities to calendar fields that have been set
 * more recently. The following are the default combinations of the
 * calendar fields. The most recent combination, as determined by the
 * most recently set single field, will be used.
 *
 * For the date fields:
 * 
 *  * YEAR + MONTH + DAY_OF_MONTH
 * YEAR + MONTH + WEEK_OF_MONTH + DAY_OF_WEEK
 * YEAR + MONTH + DAY_OF_WEEK_IN_MONTH + DAY_OF_WEEK
 * YEAR + DAY_OF_YEAR
 * YEAR + DAY_OF_WEEK + WEEK_OF_YEAR
 * 
 *
 * For the time of day fields:
 * 
 *  * HOUR_OF_DAY
 * AM_PM + HOUR
 * 
 *
 * If there are any calendar fields whose values haven't been set in the selected
 * field combination, `Calendar` uses their default values. The default
 * value of each field may vary by concrete calendar systems. For example, in
 * `GregorianCalendar`, the default of a field is the same as that
 * of the start of the Epoch: i.e., `YEAR = 1970`, MONTH =
 * JANUARY, `DAY_OF_MONTH = 1`, etc.
 *
 * 
 * Note: There are certain possible ambiguities in
 * interpretation of certain singular times, which are resolved in the
 * following ways:
 * 
 *      23:59 is the last minute of the day and 00:00 is the first
 *          minute of the next day. Thus, 23:59 on Dec 31, 1999 < 00:00 on
 *          Jan 1, 2000 < 00:01 on Jan 1, 2000.
 *
 *      Although historically not precise, midnight also belongs to "am",
 *          and noon belongs to "pm", so on the same day,
 *          12:00 am (midnight) < 12:01 am, and 12:00 pm (noon) < 12:01 pm
 * 
 *
 * 
 * The date or time format strings are not part of the definition of a
 * calendar, as those must be modifiable or overridable by the user at
 * runtime. Use {@link DateFormat}
 * to format dates.
 *
 * Field Manipulation
 *
 * The calendar fields can be changed using three methods:
 * `set()`, `add()`, and `roll()`.
 *
 * `set(f, value)` changes calendar field
 * `f` to `value`.  In addition, it sets an
 * internal member variable to indicate that calendar field `f` has
 * been changed. Although calendar field `f` is changed immediately,
 * the calendar's time value in milliseconds is not recomputed until the next call to
 * `get()`, `getTime()`, `getTimeInMillis()`,
 * `add()`, or `roll()` is made. Thus, multiple calls to
 * `set()` do not trigger multiple, unnecessary
 * computations. As a result of changing a calendar field using
 * `set()`, other calendar fields may also change, depending on the
 * calendar field, the calendar field value, and the calendar system. In addition,
 * `get(f)` will not necessarily return `value` set by
 * the call to the `set` method
 * after the calendar fields have been recomputed. The specifics are determined by
 * the concrete calendar class.
 *
 * Example: Consider a `GregorianCalendar`
 * originally set to August 31, 1999. Calling set(Calendar.MONTH,
 * Calendar.SEPTEMBER) sets the date to September 31,
 * 1999. This is a temporary internal representation that resolves to
 * October 1, 1999 if `getTime()` is then called. However, a
 * call to `set(Calendar.DAY_OF_MONTH, 30)` before the call to
 * `getTime()` sets the date to September 30, 1999, since
 * no recomputation occurs after `set()` itself.
 *
 * `add(f, delta)` adds `delta`
 * to field `f`.  This is equivalent to calling set(f,
 * get(f) + delta) with two adjustments:
 *
 * 
 *   Add rule 1. The value of field `f`
 *   after the call minus the value of field `f` before the
 *   call is `delta`, modulo any overflow that has occurred in
 *   field `f`. Overflow occurs when a field value exceeds its
 *   range and, as a result, the next larger field is incremented or
 *   decremented and the field value is adjusted back into its range.
 *
 *   Add rule 2. If a smaller field is expected to be
 *   invariant, but it is impossible for it to be equal to its
 *   prior value because of changes in its minimum or maximum after field
 *   `f` is changed or other constraints, such as time zone
 *   offset changes, then its value is adjusted to be as close
 *   as possible to its expected value. A smaller field represents a
 *   smaller unit of time. `HOUR` is a smaller field than
 *   `DAY_OF_MONTH`. No adjustment is made to smaller fields
 *   that are not expected to be invariant. The calendar system
 *   determines what fields are expected to be invariant.
 * 
 *
 * In addition, unlike `set()`, `add()` forces
 * an immediate recomputation of the calendar's milliseconds and all
 * fields.
 *
 * Example: Consider a `GregorianCalendar`
 * originally set to August 31, 1999. Calling add(Calendar.MONTH,
 * 13) sets the calendar to September 30, 2000. Add rule
 * 1 sets the `MONTH` field to September, since
 * adding 13 months to August gives September of the next year. Since
 * `DAY_OF_MONTH` cannot be 31 in September in a
 * `GregorianCalendar`, add rule 2 sets the
 * `DAY_OF_MONTH` to 30, the closest possible value. Although
 * it is a smaller field, `DAY_OF_WEEK` is not adjusted by
 * rule 2, since it is expected to change when the month changes in a
 * `GregorianCalendar`.
 *
 * `roll(f, delta)` adds
 * `delta` to field `f` without changing larger
 * fields. This is equivalent to calling `add(f, delta)` with
 * the following adjustment:
 *
 * 
 *   Roll rule. Larger fields are unchanged after the
 *   call. A larger field represents a larger unit of
 *   time. `DAY_OF_MONTH` is a larger field than
 *   `HOUR`.
 * 
 *
 * Example: See {@link java.util.GregorianCalendar#roll(int, int)}.
 *
 * Usage model. To motivate the behavior of
 * `add()` and `roll()`, consider a user interface
 * component with increment and decrement buttons for the month, day, and
 * year, and an underlying `GregorianCalendar`. If the
 * interface reads January 31, 1999 and the user presses the month
 * increment button, what should it read? If the underlying
 * implementation uses `set()`, it might read March 3, 1999. A
 * better result would be February 28, 1999. Furthermore, if the user
 * presses the month increment button again, it should read March 31,
 * 1999, not March 28, 1999. By saving the original date and using either
 * `add()` or `roll()`, depending on whether larger
 * fields should be affected, the user interface can behave as most users
 * will intuitively expect.
 *
 * @see          java.lang.System#currentTimeMillis()
 * @see          Date
 * @see          GregorianCalendar
 * @see          TimeZone
 * @see          java.text.DateFormat
 * @author Mark Davis, David Goldsmith, Chen-Lieh Huang, Alan Liu
 * @since 1.1
*/
export class Calendar extends Serializable {
  /**
   * Field number for `get` and `set` indicating the
   * era, e.g., AD or BC in the Julian calendar. This is a calendar-specific
   * value; see subclass documentation.
   *
   * @see GregorianCalendar#AD
   * @see GregorianCalendar#BC
  */
  static readonly ERA: number;
  /**
   * Field number for `get` and `set` indicating the
   * year. This is a calendar-specific value; see subclass documentation.
  */
  static readonly YEAR: number;
  /**
   * Field number for `get` and `set` indicating the
   * month. This is a calendar-specific value. The first month of
   * the year in the Gregorian and Julian calendars is
   * `JANUARY` which is 0; the last depends on the number
   * of months in a year.
   *
   * @see #JANUARY
   * @see #FEBRUARY
   * @see #MARCH
   * @see #APRIL
   * @see #MAY
   * @see #JUNE
   * @see #JULY
   * @see #AUGUST
   * @see #SEPTEMBER
   * @see #OCTOBER
   * @see #NOVEMBER
   * @see #DECEMBER
   * @see #UNDECIMBER
  */
  static readonly MONTH: number;
  /**
   * Field number for `get` and `set` indicating the
   * week number within the current year.  The first week of the year, as
   * defined by `getFirstDayOfWeek()` and
   * `getMinimalDaysInFirstWeek()`, has value 1.  Subclasses define
   * the value of `WEEK_OF_YEAR` for days before the first week of
   * the year.
   *
   * @see #getFirstDayOfWeek
   * @see #getMinimalDaysInFirstWeek
  */
  static readonly WEEK_OF_YEAR: number;
  /**
   * Field number for `get` and `set` indicating the
   * week number within the current month.  The first week of the month, as
   * defined by `getFirstDayOfWeek()` and
   * `getMinimalDaysInFirstWeek()`, has value 1.  Subclasses define
   * the value of `WEEK_OF_MONTH` for days before the first week of
   * the month.
   *
   * @see #getFirstDayOfWeek
   * @see #getMinimalDaysInFirstWeek
  */
  static readonly WEEK_OF_MONTH: number;
  /**
   * Field number for `get` and `set` indicating the
   * day of the month. This is a synonym for `DAY_OF_MONTH`.
   * The first day of the month has value 1.
   *
   * @see #DAY_OF_MONTH
  */
  static readonly DATE: number;
  /**
   * Field number for `get` and `set` indicating the
   * day of the month. This is a synonym for `DATE`.
   * The first day of the month has value 1.
   *
   * @see #DATE
  */
  static readonly DAY_OF_MONTH: number;
  /**
   * Field number for `get` and `set` indicating the day
   * number within the current year.  The first day of the year has value 1.
  */
  static readonly DAY_OF_YEAR: number;
  /**
   * Field number for `get` and `set` indicating the day
   * of the week.  This field takes values `SUNDAY`,
   * `MONDAY`, `TUESDAY`, `WEDNESDAY`,
   * `THURSDAY`, `FRIDAY`, and `SATURDAY`.
   *
   * @see #SUNDAY
   * @see #MONDAY
   * @see #TUESDAY
   * @see #WEDNESDAY
   * @see #THURSDAY
   * @see #FRIDAY
   * @see #SATURDAY
  */
  static readonly DAY_OF_WEEK: number;
  /**
   * Field number for `get` and `set` indicating the
   * ordinal number of the day of the week within the current month. Together
   * with the `DAY_OF_WEEK` field, this uniquely specifies a day
   * within a month.  Unlike `WEEK_OF_MONTH` and
   * `WEEK_OF_YEAR`, this field's value does not depend on
   * `getFirstDayOfWeek()` or
   * `getMinimalDaysInFirstWeek()`.  `DAY_OF_MONTH 1`
   * through `7` always correspond to DAY_OF_WEEK_IN_MONTH
   * 1; `8` through `14` correspond to
   * `DAY_OF_WEEK_IN_MONTH 2`, and so on.
   * `DAY_OF_WEEK_IN_MONTH 0` indicates the week before
   * `DAY_OF_WEEK_IN_MONTH 1`.  Negative values count back from the
   * end of the month, so the last Sunday of a month is specified as
   * `DAY_OF_WEEK = SUNDAY, DAY_OF_WEEK_IN_MONTH = -1`.  Because
   * negative values count backward they will usually be aligned differently
   * within the month than positive values.  For example, if a month has 31
   * days, `DAY_OF_WEEK_IN_MONTH -1` will overlap
   * `DAY_OF_WEEK_IN_MONTH 5` and the end of `4`.
   *
   * @see #DAY_OF_WEEK
   * @see #WEEK_OF_MONTH
  */
  static readonly DAY_OF_WEEK_IN_MONTH: number;
  /**
   * Field number for `get` and `set` indicating
   * whether the `HOUR` is before or after noon.
   * E.g., at 10:04:15.250 PM the `AM_PM` is `PM`.
   *
   * @see #AM
   * @see #PM
   * @see #HOUR
  */
  static readonly AM_PM: number;
  /**
   * Field number for `get` and `set` indicating the
   * hour of the morning or afternoon. `HOUR` is used for the
   * 12-hour clock (0 - 11). Noon and midnight are represented by 0, not by 12.
   * E.g., at 10:04:15.250 PM the `HOUR` is 10.
   *
   * @see #AM_PM
   * @see #HOUR_OF_DAY
  */
  static readonly HOUR: number;
  /**
   * Field number for `get` and `set` indicating the
   * hour of the day. `HOUR_OF_DAY` is used for the 24-hour clock.
   * E.g., at 10:04:15.250 PM the `HOUR_OF_DAY` is 22.
   *
   * @see #HOUR
  */
  static readonly HOUR_OF_DAY: number;
  /**
   * Field number for `get` and `set` indicating the
   * minute within the hour.
   * E.g., at 10:04:15.250 PM the `MINUTE` is 4.
  */
  static readonly MINUTE: number;
  /**
   * Field number for `get` and `set` indicating the
   * second within the minute.
   * E.g., at 10:04:15.250 PM the `SECOND` is 15.
  */
  static readonly SECOND: number;
  /**
   * Field number for `get` and `set` indicating the
   * millisecond within the second.
   * E.g., at 10:04:15.250 PM the `MILLISECOND` is 250.
  */
  static readonly MILLISECOND: number;
  /**
   * Field number for `get` and `set`
   * indicating the raw offset from GMT in milliseconds.
   * 
   * This field reflects the correct GMT offset value of the time
   * zone of this `Calendar` if the
   * `TimeZone` implementation subclass supports
   * historical GMT offset changes.
  */
  static readonly ZONE_OFFSET: number;
  /**
   * Field number for `get` and `set` indicating the
   * daylight saving offset in milliseconds.
   * 
   * This field reflects the correct daylight saving offset value of
   * the time zone of this `Calendar` if the
   * `TimeZone` implementation subclass supports
   * historical Daylight Saving Time schedule changes.
  */
  static readonly DST_OFFSET: number;
  /**
   * The number of distinct fields recognized by `get` and `set`.
   * Field numbers range from `0..FIELD_COUNT-1`.
  */
  static readonly FIELD_COUNT: number;
  /**
   * Value of the {@link #DAY_OF_WEEK} field indicating
   * Sunday.
  */
  static readonly SUNDAY: number;
  /**
   * Value of the {@link #DAY_OF_WEEK} field indicating
   * Monday.
  */
  static readonly MONDAY: number;
  /**
   * Value of the {@link #DAY_OF_WEEK} field indicating
   * Tuesday.
  */
  static readonly TUESDAY: number;
  /**
   * Value of the {@link #DAY_OF_WEEK} field indicating
   * Wednesday.
  */
  static readonly WEDNESDAY: number;
  /**
   * Value of the {@link #DAY_OF_WEEK} field indicating
   * Thursday.
  */
  static readonly THURSDAY: number;
  /**
   * Value of the {@link #DAY_OF_WEEK} field indicating
   * Friday.
  */
  static readonly FRIDAY: number;
  /**
   * Value of the {@link #DAY_OF_WEEK} field indicating
   * Saturday.
  */
  static readonly SATURDAY: number;
  /**
   * Value of the {@link #MONTH} field indicating the
   * first month of the year in the Gregorian and Julian calendars.
  */
  static readonly JANUARY: number;
  /**
   * Value of the {@link #MONTH} field indicating the
   * second month of the year in the Gregorian and Julian calendars.
  */
  static readonly FEBRUARY: number;
  /**
   * Value of the {@link #MONTH} field indicating the
   * third month of the year in the Gregorian and Julian calendars.
  */
  static readonly MARCH: number;
  /**
   * Value of the {@link #MONTH} field indicating the
   * fourth month of the year in the Gregorian and Julian calendars.
  */
  static readonly APRIL: number;
  /**
   * Value of the {@link #MONTH} field indicating the
   * fifth month of the year in the Gregorian and Julian calendars.
  */
  static readonly MAY: number;
  /**
   * Value of the {@link #MONTH} field indicating the
   * sixth month of the year in the Gregorian and Julian calendars.
  */
  static readonly JUNE: number;
  /**
   * Value of the {@link #MONTH} field indicating the
   * seventh month of the year in the Gregorian and Julian calendars.
  */
  static readonly JULY: number;
  /**
   * Value of the {@link #MONTH} field indicating the
   * eighth month of the year in the Gregorian and Julian calendars.
  */
  static readonly AUGUST: number;
  /**
   * Value of the {@link #MONTH} field indicating the
   * ninth month of the year in the Gregorian and Julian calendars.
  */
  static readonly SEPTEMBER: number;
  /**
   * Value of the {@link #MONTH} field indicating the
   * tenth month of the year in the Gregorian and Julian calendars.
  */
  static readonly OCTOBER: number;
  /**
   * Value of the {@link #MONTH} field indicating the
   * eleventh month of the year in the Gregorian and Julian calendars.
  */
  static readonly NOVEMBER: number;
  /**
   * Value of the {@link #MONTH} field indicating the
   * twelfth month of the year in the Gregorian and Julian calendars.
  */
  static readonly DECEMBER: number;
  /**
   * Value of the {@link #MONTH} field indicating the
   * thirteenth month of the year. Although `GregorianCalendar`
   * does not use this value, lunar calendars do.
  */
  static readonly UNDECIMBER: number;
  /**
   * Value of the {@link #AM_PM} field indicating the
   * period of the day from midnight to just before noon.
  */
  static readonly AM: number;
  /**
   * Value of the {@link #AM_PM} field indicating the
   * period of the day from noon to just before midnight.
  */
  static readonly PM: number;
  /**
   * A style specifier for {@link #getDisplayNames(int, int, Locale)
   * getDisplayNames} indicating names in all styles, such as
   * "January" and "Jan".
   *
   * @see #SHORT_FORMAT
   * @see #LONG_FORMAT
   * @see #SHORT_STANDALONE
   * @see #LONG_STANDALONE
   * @see #SHORT
   * @see #LONG
   * @since 1.6
  */
  static readonly ALL_STYLES: number;
  /**
   * A style specifier for {@link #getDisplayName(int, int, Locale)
   * getDisplayName} and {@link #getDisplayNames(int, int, Locale)
   * getDisplayNames} equivalent to {@link #SHORT_FORMAT}.
   *
   * @see #SHORT_STANDALONE
   * @see #LONG
   * @since 1.6
  */
  static readonly SHORT: number;
  /**
   * A style specifier for {@link #getDisplayName(int, int, Locale)
   * getDisplayName} and {@link #getDisplayNames(int, int, Locale)
   * getDisplayNames} equivalent to {@link #LONG_FORMAT}.
   *
   * @see #LONG_STANDALONE
   * @see #SHORT
   * @since 1.6
  */
  static readonly LONG: number;
  /**
   * A style specifier for {@link #getDisplayName(int, int, Locale)
   * getDisplayName} and {@link #getDisplayNames(int, int, Locale)
   * getDisplayNames} indicating a narrow name used for format. Narrow names
   * are typically single character strings, such as "M" for Monday.
   *
   * @see #NARROW_STANDALONE
   * @see #SHORT_FORMAT
   * @see #LONG_FORMAT
   * @since 1.8
  */
  static readonly NARROW_FORMAT: number;
  /**
   * A style specifier for {@link #getDisplayName(int, int, Locale)
   * getDisplayName} and {@link #getDisplayNames(int, int, Locale)
   * getDisplayNames} indicating a narrow name independently. Narrow names
   * are typically single character strings, such as "M" for Monday.
   *
   * @see #NARROW_FORMAT
   * @see #SHORT_STANDALONE
   * @see #LONG_STANDALONE
   * @since 1.8
  */
  static readonly NARROW_STANDALONE: number;
  /**
   * A style specifier for {@link #getDisplayName(int, int, Locale)
   * getDisplayName} and {@link #getDisplayNames(int, int, Locale)
   * getDisplayNames} indicating a short name used for format.
   *
   * @see #SHORT_STANDALONE
   * @see #LONG_FORMAT
   * @see #LONG_STANDALONE
   * @since 1.8
  */
  static readonly SHORT_FORMAT: number;
  /**
   * A style specifier for {@link #getDisplayName(int, int, Locale)
   * getDisplayName} and {@link #getDisplayNames(int, int, Locale)
   * getDisplayNames} indicating a long name used for format.
   *
   * @see #LONG_STANDALONE
   * @see #SHORT_FORMAT
   * @see #SHORT_STANDALONE
   * @since 1.8
  */
  static readonly LONG_FORMAT: number;
  /**
   * A style specifier for {@link #getDisplayName(int, int, Locale)
   * getDisplayName} and {@link #getDisplayNames(int, int, Locale)
   * getDisplayNames} indicating a short name used independently,
   * such as a month abbreviation as calendar headers.
   *
   * @see #SHORT_FORMAT
   * @see #LONG_FORMAT
   * @see #LONG_STANDALONE
   * @since 1.8
  */
  static readonly SHORT_STANDALONE: number;
  /**
   * A style specifier for {@link #getDisplayName(int, int, Locale)
   * getDisplayName} and {@link #getDisplayNames(int, int, Locale)
   * getDisplayNames} indicating a long name used independently,
   * such as a month name as calendar headers.
   *
   * @see #LONG_FORMAT
   * @see #SHORT_FORMAT
   * @see #SHORT_STANDALONE
   * @since 1.8
  */
  static readonly LONG_STANDALONE: number;
  /**
   * Gets a calendar using the default time zone and locale. The
   * `Calendar` returned is based on the current time
   * in the default time zone with the default
   * {@link Locale.Category#FORMAT FORMAT} locale.
   * 
   * If the locale contains the time zone with "tz"
   * Unicode extension,
   * that time zone is used instead.
   *
   * @return a Calendar.
  */
  static getInstance(): Calendar;
  /**
   * Gets a calendar using the specified time zone and default locale.
   * The `Calendar` returned is based on the current time
   * in the given time zone with the default
   * {@link Locale.Category#FORMAT FORMAT} locale.
   *
   * @param zone the time zone to use
   * @return a Calendar.
  */
  static getInstance(zone: TimeZone): Calendar;
  /**
   * Gets a calendar using the default time zone and specified locale.
   * The `Calendar` returned is based on the current time
   * in the default time zone with the given locale.
   * 
   * If the locale contains the time zone with "tz"
   * Unicode extension,
   * that time zone is used instead.
   *
   * @param aLocale the locale for the week data
   * @return a Calendar.
  */
  static getInstance(aLocale: Locale): Calendar;
  /**
   * Gets a calendar with the specified time zone and locale.
   * The `Calendar` returned is based on the current time
   * in the given time zone with the given locale.
   *
   * @param zone the time zone to use
   * @param aLocale the locale for the week data
   * @return a Calendar.
  */
  static getInstance(zone: TimeZone, aLocale: Locale): Calendar;
  /**
   * Returns an array of all locales for which the `getInstance`
   * methods of this class can return localized instances.
   * The array returned must contain at least a `Locale`
   * instance equal to {@link java.util.Locale#US Locale.US}.
   *
   * @return An array of locales for which localized
   *         `Calendar` instances are available.
  */
  static getAvailableLocales(): Locale[];
  /**
   * Returns a `Date` object representing this
   * `Calendar`'s time value (millisecond offset from the Epoch").
   *
   * @return a `Date` representing the time value.
   * @see #setTime(Date)
   * @see #getTimeInMillis()
  */
  getTime(): Date;
  /**
   * Sets this Calendar's time with the given `Date`.
   * 
   * Note: Calling `setTime()` with
   * `Date(Long.MAX_VALUE)` or `Date(Long.MIN_VALUE)`
   * may yield incorrect field values from `get()`.
   *
   * @param date the given Date.
   * @see #getTime()
   * @see #setTimeInMillis(long)
   * @throws NullPointerException if `date` is `null`
  */
  setTime(time: Date);
  /**
   * Returns this Calendar's time value in milliseconds.
   *
   * @return the current time as UTC milliseconds from the epoch.
   * @see #getTime()
   * @see #setTimeInMillis(long)
  */
  getTimeInMillis(): number;
  /**
   * Sets this Calendar's current time from the given long value.
   *
   * @param millis the new time in UTC milliseconds from the epoch.
   * @see #setTime(Date)
   * @see #getTimeInMillis()
  */
  setTimeInMillis(timeInMillis: number);
  /**
   * Returns the value of the given calendar field. In lenient mode,
   * all calendar fields are normalized. In non-lenient mode, all
   * calendar fields are validated and this method throws an
   * exception if any calendar fields have out-of-range values. The
   * normalization and validation are handled by the
   * {@link #complete()} method, which process is calendar
   * system dependent.
   *
   * @param field the given calendar field.
   * @return the value for the given calendar field.
   * @throws ArrayIndexOutOfBoundsException if the specified field is out of range
   *             (field < 0 || field >= FIELD_COUNT).
   * @see #set(int,int)
   * @see #complete()
  */
  get(field: number): number;
  /**
   * Sets the given calendar field to the given value. The value is not
   * interpreted by this method regardless of the leniency mode.
   *
   * @param field the given calendar field.
   * @param value the value to be set for the given calendar field.
   * @throws ArrayIndexOutOfBoundsException if the specified field is out of range
   *             (field < 0 || field >= FIELD_COUNT).
   * in non-lenient mode.
   * @see #set(int,int,int)
   * @see #set(int,int,int,int,int)
   * @see #set(int,int,int,int,int,int)
   * @see #get(int)
  */
  set(field: number, value: number): void;
  /**
   * Sets the values for the calendar fields `YEAR`,
   * `MONTH`, and `DAY_OF_MONTH`.
   * Previous values of other calendar fields are retained.  If this is not desired,
   * call {@link #clear()} first.
   *
   * @param year the value used to set the `YEAR` calendar field.
   * @param month the value used to set the `MONTH` calendar field.
   * Month value is 0-based. e.g., 0 for January.
   * @param date the value used to set the `DAY_OF_MONTH` calendar field.
   * @see #set(int,int)
   * @see #set(int,int,int,int,int)
   * @see #set(int,int,int,int,int,int)
  */
  set(year: number, month: number, date: number): void;
  /**
   * Sets the values for the calendar fields `YEAR`,
   * `MONTH`, `DAY_OF_MONTH`,
   * `HOUR_OF_DAY`, and `MINUTE`.
   * Previous values of other fields are retained.  If this is not desired,
   * call {@link #clear()} first.
   *
   * @param year the value used to set the `YEAR` calendar field.
   * @param month the value used to set the `MONTH` calendar field.
   * Month value is 0-based. e.g., 0 for January.
   * @param date the value used to set the `DAY_OF_MONTH` calendar field.
   * @param hourOfDay the value used to set the `HOUR_OF_DAY` calendar field.
   * @param minute the value used to set the `MINUTE` calendar field.
   * @see #set(int,int)
   * @see #set(int,int,int)
   * @see #set(int,int,int,int,int,int)
  */
  set(year: number, month: number, date: number, hourOfDay: number, minute: number): void;
  /**
   * Sets the values for the fields `YEAR`, `MONTH`,
   * `DAY_OF_MONTH`, `HOUR_OF_DAY`, `MINUTE`, and
   * `SECOND`.
   * Previous values of other fields are retained.  If this is not desired,
   * call {@link #clear()} first.
   *
   * @param year the value used to set the `YEAR` calendar field.
   * @param month the value used to set the `MONTH` calendar field.
   * Month value is 0-based. e.g., 0 for January.
   * @param date the value used to set the `DAY_OF_MONTH` calendar field.
   * @param hourOfDay the value used to set the `HOUR_OF_DAY` calendar field.
   * @param minute the value used to set the `MINUTE` calendar field.
   * @param second the value used to set the `SECOND` calendar field.
   * @see #set(int,int)
   * @see #set(int,int,int)
   * @see #set(int,int,int,int,int)
  */
  set(year: number, month: number, date: number, hourOfDay: number, minute: number, second: number): void;
  /**
   * Sets all the calendar field values and the time value
   * (millisecond offset from the Epoch) of
   * this `Calendar` undefined. This means that {@link
   * #isSet(int) isSet()} will return `false` for all the
   * calendar fields, and the date and time calculations will treat
   * the fields as if they had never been set. A
   * `Calendar` implementation class may use its specific
   * default field values for date/time calculations. For example,
   * `GregorianCalendar` uses 1970 if the
   * `YEAR` field value is undefined.
   *
   * @see #clear(int)
  */
  clear(): void;
  /**
   * Sets the given calendar field value and the time value
   * (millisecond offset from the Epoch) of
   * this `Calendar` undefined. This means that {@link
   * #isSet(int) isSet(field)} will return `false`, and
   * the date and time calculations will treat the field as if it
   * had never been set. A `Calendar` implementation
   * class may use the field's specific default value for date and
   * time calculations.
   *
   * The {@link #HOUR_OF_DAY}, {@link #HOUR} and {@link #AM_PM}
   * fields are handled independently and the the resolution rule for the time of
   * day is applied. Clearing one of the fields doesn't reset
   * the hour of day value of this `Calendar`. Use {@link
   * #set(int,int) set(Calendar.HOUR_OF_DAY, 0)} to reset the hour
   * value.
   *
   * @param field the calendar field to be cleared.
   * @see #clear()
  */
  clear(field: number): void;
  /**
   * Determines if the given calendar field has a value set,
   * including cases that the value has been set by internal fields
   * calculations triggered by a `get` method call.
   *
   * @param field the calendar field to test
   * @return `true` if the given calendar field has a value set;
   * `false` otherwise.
  */
  isSet(field: number): boolean;
  /**
   * Returns the string representation of the calendar
   * `field` value in the given `style` and
   * `locale`.  If no string representation is
   * applicable, `null` is returned. This method calls
   * {@link Calendar#get(int) get(field)} to get the calendar
   * `field` value if the string representation is
   * applicable to the given calendar `field`.
   *
   * For example, if this `Calendar` is a
   * `GregorianCalendar` and its date is 2005-01-01, then
   * the string representation of the {@link #MONTH} field would be
   * "January" in the long style in an English locale or "Jan" in
   * the short style. However, no string representation would be
   * available for the {@link #DAY_OF_MONTH} field, and this method
   * would return `null`.
   *
   * The default implementation supports the calendar fields for
   * which a {@link DateFormatSymbols} has names in the given
   * `locale`.
   *
   * @param field
   *        the calendar field for which the string representation
   *        is returned
   * @param style
   *        the style applied to the string representation; one of {@link
   *        #SHORT_FORMAT} ({@link #SHORT}), {@link #SHORT_STANDALONE},
   *        {@link #LONG_FORMAT} ({@link #LONG}), {@link #LONG_STANDALONE},
   *        {@link #NARROW_FORMAT}, or {@link #NARROW_STANDALONE}.
   * @param locale
   *        the locale for the string representation
   *        (any calendar types specified by `locale` are ignored)
   * @return the string representation of the given
   *        `field` in the given `style`, or
   *        `null` if no string representation is
   *        applicable.
   * @throws    IllegalArgumentException
   *        if `field` or `style` is invalid,
   *        or if this `Calendar` is non-lenient and any
   *        of the calendar fields have invalid values
   * @throws    NullPointerException
   *        if `locale` is null
   * @since 1.6
  */
  getDisplayName(field: number, style: number, locale: Locale): string;
  /**
   * Returns a `Map` containing all names of the calendar
   * `field` in the given `style` and
   * `locale` and their corresponding field values. For
   * example, if this `Calendar` is a {@link
   * GregorianCalendar}, the returned map would contain "Jan" to
   * {@link #JANUARY}, "Feb" to {@link #FEBRUARY}, and so on, in the
   * {@linkplain #SHORT short} style in an English locale.
   *
   * Narrow names may not be unique due to use of single characters,
   * such as "S" for Sunday and Saturday. In that case narrow names are not
   * included in the returned `Map`.
   *
   * The values of other calendar fields may be taken into
   * account to determine a set of display names. For example, if
   * this `Calendar` is a lunisolar calendar system and
   * the year value given by the {@link #YEAR} field has a leap
   * month, this method would return month names containing the leap
   * month name, and month names are mapped to their values specific
   * for the year.
   *
   * The default implementation supports display names contained in
   * a {@link DateFormatSymbols}. For example, if `field`
   * is {@link #MONTH} and `style` is {@link
   * #ALL_STYLES}, this method returns a `Map` containing
   * all strings returned by {@link DateFormatSymbols#getShortMonths()}
   * and {@link DateFormatSymbols#getMonths()}.
   *
   * @param field
   *        the calendar field for which the display names are returned
   * @param style
   *        the style applied to the string representation; one of {@link
   *        #SHORT_FORMAT} ({@link #SHORT}), {@link #SHORT_STANDALONE},
   *        {@link #LONG_FORMAT} ({@link #LONG}), {@link #LONG_STANDALONE},
   *        {@link #NARROW_FORMAT}, or {@link #NARROW_STANDALONE}
   * @param locale
   *        the locale for the display names
   * @return a `Map` containing all display names in
   *        `style` and `locale` and their
   *        field values, or `null` if no display names
   *        are defined for `field`
   * @throws    IllegalArgumentException
   *        if `field` or `style` is invalid,
   *        or if this `Calendar` is non-lenient and any
   *        of the calendar fields have invalid values
   * @throws    NullPointerException
   *        if `locale` is null
   * @since 1.6
  */
  getDisplayNames(field: number, style: number, locale: Locale): Map<string, number>;
  /**
   * Returns an unmodifiable `Set` containing all calendar types
   * supported by `Calendar` in the runtime environment. The available
   * calendar types can be used for the Unicode locale extensions.
   * The `Set` returned contains at least `"gregory"`. The
   * calendar types don't include aliases, such as `"gregorian"` for
   * `"gregory"`.
   *
   * @return an unmodifiable `Set` containing all available calendar types
   * @since 1.8
   * @see #getCalendarType()
   * @see Calendar.Builder#setCalendarType(String)
   * @see Locale#getUnicodeLocaleType(String)
  */
  static getAvailableCalendarTypes(): Set<string>;
  /**
   * Returns the calendar type of this `Calendar`. Calendar types are
   * defined by the Unicode Locale Data Markup Language (LDML)
   * specification.
   *
   * The default implementation of this method returns the class name of
   * this `Calendar` instance. Any subclasses that implement
   * LDML-defined calendar systems should override this method to return
   * appropriate calendar types.
   *
   * @return the LDML-defined calendar type or the class name of this
   *         `Calendar` instance
   * @since 1.8
   * @see Locale extensions
   * @see Locale.Builder#setLocale(Locale)
   * @see Locale.Builder#setUnicodeLocaleKeyword(String, String)
  */
  getCalendarType(): string;
  /**
   * Compares this `Calendar` to the specified
   * `Object`.  The result is `true` if and only if
   * the argument is a `Calendar` object of the same calendar
   * system that represents the same time value (millisecond offset from the
   * Epoch) under the same
   * `Calendar` parameters as this object.
   *
   * The `Calendar` parameters are the values represented
   * by the `isLenient`, `getFirstDayOfWeek`,
   * `getMinimalDaysInFirstWeek` and `getTimeZone`
   * methods. If there is any difference in those parameters
   * between the two `Calendar`s, this method returns
   * `false`.
   *
   * Use the {@link #compareTo(Calendar) compareTo} method to
   * compare only the time values.
   *
   * @param obj the object to compare with.
   * @return `true` if this object is equal to `obj`;
   * `false` otherwise.
  */
  equals(obj: any): boolean;
  /**
   * Returns a hash code for this calendar.
   *
   * @return a hash code value for this object.
   * @since 1.2
  */
  hashCode(): number;
  /**
   * Returns whether this `Calendar` represents a time
   * before the time represented by the specified
   * `Object`. This method is equivalent to:
   * {@code
   *         compareTo(when) < 0
   * }
   * if and only if `when` is a `Calendar`
   * instance. Otherwise, the method returns `false`.
   *
   * @param when the `Object` to be compared
   * @return `true` if the time of this
   * `Calendar` is before the time represented by
   * `when`; `false` otherwise.
   * @see     #compareTo(Calendar)
  */
  before(when: any): boolean;
  /**
   * Returns whether this `Calendar` represents a time
   * after the time represented by the specified
   * `Object`. This method is equivalent to:
   * {@code
   *         compareTo(when) > 0
   * }
   * if and only if `when` is a `Calendar`
   * instance. Otherwise, the method returns `false`.
   *
   * @param when the `Object` to be compared
   * @return `true` if the time of this `Calendar` is
   * after the time represented by `when`; `false`
   * otherwise.
   * @see     #compareTo(Calendar)
  */
  after(when: any): boolean;
  /**
   * Compares the time values (millisecond offsets from the Epoch) represented by two
   * `Calendar` objects.
   *
   * @param anotherCalendar the `Calendar` to be compared.
   * @return the value `0` if the time represented by the argument
   * is equal to the time represented by this `Calendar`; a value
   * less than `0` if the time of this `Calendar` is
   * before the time represented by the argument; and a value greater than
   * `0` if the time of this `Calendar` is after the
   * time represented by the argument.
   * @throws    NullPointerException if the specified `Calendar` is
   *            `null`.
   * @throws    IllegalArgumentException if the time value of the
   * specified `Calendar` object can't be obtained due to
   * any invalid calendar values.
   * @since   1.5
  */
  compareTo(anotherCalendar: Calendar): number;
  /**
   * Adds or subtracts the specified amount of time to the given calendar field,
   * based on the calendar's rules. For example, to subtract 5 days from
   * the current time of the calendar, you can achieve it by calling:
   * `add(Calendar.DAY_OF_MONTH, -5)`.
   *
   * @param field the calendar field.
   * @param amount the amount of date or time to be added to the field.
   * @see #roll(int,int)
   * @see #set(int,int)
  */
  add(field: number, amount: number): void;
  /**
   * Adds or subtracts (up/down) a single unit of time on the given time
   * field without changing larger fields. For example, to roll the current
   * date up by one day, you can achieve it by calling:
   * roll(Calendar.DATE, true).
   * When rolling on the year or Calendar.YEAR field, it will roll the year
   * value in the range between 1 and the value returned by calling
   * `getMaximum(Calendar.YEAR)`.
   * When rolling on the month or Calendar.MONTH field, other fields like
   * date might conflict and, need to be changed. For instance,
   * rolling the month on the date 01/31/96 will result in 02/29/96.
   * When rolling on the hour-in-day or Calendar.HOUR_OF_DAY field, it will
   * roll the hour value in the range between 0 and 23, which is zero-based.
   *
   * @param field the time field.
   * @param up indicates if the value of the specified time field is to be
   * rolled up or rolled down. Use true if rolling up, false otherwise.
   * @see Calendar#add(int,int)
   * @see Calendar#set(int,int)
  */
  roll(field: number, up: boolean): void;
  /**
   * Adds the specified (signed) amount to the specified calendar field
   * without changing larger fields.  A negative amount means to roll
   * down.
   *
   * NOTE:  This default implementation on `Calendar` just repeatedly calls the
   * version of {@link #roll(int,boolean) roll()} that rolls by one unit.  This may not
   * always do the right thing.  For example, if the `DAY_OF_MONTH` field is 31,
   * rolling through February will leave it set to 28.  The `GregorianCalendar`
   * version of this function takes care of this problem.  Other subclasses
   * should also provide overrides of this function that do the right thing.
   *
   * @param field the calendar field.
   * @param amount the signed amount to add to the calendar `field`.
   * @since 1.2
   * @see #roll(int,boolean)
   * @see #add(int,int)
   * @see #set(int,int)
  */
  roll(field: number, amount: number): void;
  /**
   * Sets the time zone with the given time zone value.
   *
   * @param value the given time zone.
  */
  setTimeZone(timeZone: TimeZone);
  /**
   * Gets the time zone.
   *
   * @return the time zone object associated with this calendar.
  */
  getTimeZone(): TimeZone;
  /**
   * Specifies whether or not date/time interpretation is to be lenient.  With
   * lenient interpretation, a date such as "February 942, 1996" will be
   * treated as being equivalent to the 941st day after February 1, 1996.
   * With strict (non-lenient) interpretation, such dates will cause an exception to be
   * thrown. The default is lenient.
   *
   * @param lenient `true` if the lenient mode is to be turned
   * on; `false` if it is to be turned off.
   * @see #isLenient()
   * @see java.text.DateFormat#setLenient
  */
  setLenient(lenient: boolean): void;
  /**
   * Tells whether date/time interpretation is to be lenient.
   *
   * @return `true` if the interpretation mode of this calendar is lenient;
   * `false` otherwise.
   * @see #setLenient(boolean)
  */
  isLenient(): boolean;
  /**
   * Sets what the first day of the week is; e.g., `SUNDAY` in the U.S.,
   * `MONDAY` in France.
   *
   * @param value the given first day of the week.
   * @see #getFirstDayOfWeek()
   * @see #getMinimalDaysInFirstWeek()
  */
  setFirstDayOfWeek(firstDayOfWeek: number);
  /**
   * Gets what the first day of the week is; e.g., `SUNDAY` in the U.S.,
   * `MONDAY` in France.
   *
   * @return the first day of the week.
   * @see #setFirstDayOfWeek(int)
   * @see #getMinimalDaysInFirstWeek()
  */
  getFirstDayOfWeek(): number;
  /**
   * Sets what the minimal days required in the first week of the year are;
   * For example, if the first week is defined as one that contains the first
   * day of the first month of a year, call this method with value 1. If it
   * must be a full week, use value 7.
   *
   * @param value the given minimal days required in the first week
   * of the year.
   * @see #getMinimalDaysInFirstWeek()
  */
  setMinimalDaysInFirstWeek(minimalDaysInFirstWeek: number);
  /**
   * Gets what the minimal days required in the first week of the year are;
   * e.g., if the first week is defined as one that contains the first day
   * of the first month of a year, this method returns 1. If
   * the minimal days required must be a full week, this method
   * returns 7.
   *
   * @return the minimal days required in the first week of the year.
   * @see #setMinimalDaysInFirstWeek(int)
  */
  getMinimalDaysInFirstWeek(): number;
  /**
   * Returns whether this `Calendar` supports week dates.
   *
   * The default implementation of this method returns `false`.
   *
   * @return `true` if this `Calendar` supports week dates;
   *         `false` otherwise.
   * @see #getWeekYear()
   * @see #setWeekDate(int,int,int)
   * @see #getWeeksInWeekYear()
   * @since 1.7
  */
  isWeekDateSupported(): boolean;
  /**
   * Returns the week year represented by this `Calendar`. The
   * week year is in sync with the week cycle. The {@linkplain
   * #getFirstDayOfWeek() first day of the first week} is the first
   * day of the week year.
   *
   * The default implementation of this method throws an
   * {@link UnsupportedOperationException}.
   *
   * @return the week year of this `Calendar`
   * @throws    UnsupportedOperationException
   *            if any week year numbering isn't supported
   *            in this `Calendar`.
   * @see #isWeekDateSupported()
   * @see #getFirstDayOfWeek()
   * @see #getMinimalDaysInFirstWeek()
   * @since 1.7
  */
  getWeekYear(): number;
  /**
   * Sets the date of this `Calendar` with the given date
   * specifiers - week year, week of year, and day of week.
   *
   * Unlike the `set` method, all of the calendar fields
   * and `time` values are calculated upon return.
   *
   * If `weekOfYear` is out of the valid week-of-year range
   * in `weekYear`, the `weekYear` and `     * weekOfYear` values are adjusted in lenient mode, or an `     * IllegalArgumentException` is thrown in non-lenient mode.
   *
   * The default implementation of this method throws an
   * `UnsupportedOperationException`.
   *
   * @param weekYear   the week year
   * @param weekOfYear the week number based on `weekYear`
   * @param dayOfWeek  the day of week value: one of the constants
   *                   for the {@link #DAY_OF_WEEK} field: {@link
   *                   #SUNDAY}, ..., {@link #SATURDAY}.
   * @throws    IllegalArgumentException
   *            if any of the given date specifiers is invalid
   *            or any of the calendar fields are inconsistent
   *            with the given date specifiers in non-lenient mode
   * @throws    UnsupportedOperationException
   *            if any week year numbering isn't supported in this
   *            `Calendar`.
   * @see #isWeekDateSupported()
   * @see #getFirstDayOfWeek()
   * @see #getMinimalDaysInFirstWeek()
   * @since 1.7
  */
  setWeekDate(weekYear: number, weekOfYear: number, dayOfWeek: number): void;
  /**
   * Returns the number of weeks in the week year represented by this
   * `Calendar`.
   *
   * The default implementation of this method throws an
   * `UnsupportedOperationException`.
   *
   * @return the number of weeks in the week year.
   * @throws    UnsupportedOperationException
   *            if any week year numbering isn't supported in this
   *            `Calendar`.
   * @see #WEEK_OF_YEAR
   * @see #isWeekDateSupported()
   * @see #getWeekYear()
   * @see #getActualMaximum(int)
   * @since 1.7
  */
  getWeeksInWeekYear(): number;
  /**
   * Returns the minimum value for the given calendar field of this
   * `Calendar` instance. The minimum value is defined as
   * the smallest value returned by the {@link #get(int) get} method
   * for any possible time value.  The minimum value depends on
   * calendar system specific parameters of the instance.
   *
   * @param field the calendar field.
   * @return the minimum value for the given calendar field.
   * @see #getMaximum(int)
   * @see #getGreatestMinimum(int)
   * @see #getLeastMaximum(int)
   * @see #getActualMinimum(int)
   * @see #getActualMaximum(int)
  */
  getMinimum(field: number): number;
  /**
   * Returns the maximum value for the given calendar field of this
   * `Calendar` instance. The maximum value is defined as
   * the largest value returned by the {@link #get(int) get} method
   * for any possible time value. The maximum value depends on
   * calendar system specific parameters of the instance.
   *
   * @param field the calendar field.
   * @return the maximum value for the given calendar field.
   * @see #getMinimum(int)
   * @see #getGreatestMinimum(int)
   * @see #getLeastMaximum(int)
   * @see #getActualMinimum(int)
   * @see #getActualMaximum(int)
  */
  getMaximum(field: number): number;
  /**
   * Returns the highest minimum value for the given calendar field
   * of this `Calendar` instance. The highest minimum
   * value is defined as the largest value returned by {@link
   * #getActualMinimum(int)} for any possible time value. The
   * greatest minimum value depends on calendar system specific
   * parameters of the instance.
   *
   * @param field the calendar field.
   * @return the highest minimum value for the given calendar field.
   * @see #getMinimum(int)
   * @see #getMaximum(int)
   * @see #getLeastMaximum(int)
   * @see #getActualMinimum(int)
   * @see #getActualMaximum(int)
  */
  getGreatestMinimum(field: number): number;
  /**
   * Returns the lowest maximum value for the given calendar field
   * of this `Calendar` instance. The lowest maximum
   * value is defined as the smallest value returned by {@link
   * #getActualMaximum(int)} for any possible time value. The least
   * maximum value depends on calendar system specific parameters of
   * the instance. For example, a `Calendar` for the
   * Gregorian calendar system returns 28 for the
   * `DAY_OF_MONTH` field, because the 28th is the last
   * day of the shortest month of this calendar, February in a
   * common year.
   *
   * @param field the calendar field.
   * @return the lowest maximum value for the given calendar field.
   * @see #getMinimum(int)
   * @see #getMaximum(int)
   * @see #getGreatestMinimum(int)
   * @see #getActualMinimum(int)
   * @see #getActualMaximum(int)
  */
  getLeastMaximum(field: number): number;
  /**
   * Returns the minimum value that the specified calendar field
   * could have, given the time value of this `Calendar`.
   *
   * The default implementation of this method uses an iterative
   * algorithm to determine the actual minimum value for the
   * calendar field. Subclasses should, if possible, override this
   * with a more efficient implementation - in many cases, they can
   * simply return `getMinimum()`.
   *
   * @param field the calendar field
   * @return the minimum of the given calendar field for the time
   * value of this `Calendar`
   * @see #getMinimum(int)
   * @see #getMaximum(int)
   * @see #getGreatestMinimum(int)
   * @see #getLeastMaximum(int)
   * @see #getActualMaximum(int)
   * @since 1.2
  */
  getActualMinimum(field: number): number;
  /**
   * Returns the maximum value that the specified calendar field
   * could have, given the time value of this
   * `Calendar`. For example, the actual maximum value of
   * the `MONTH` field is 12 in some years, and 13 in
   * other years in the Hebrew calendar system.
   *
   * The default implementation of this method uses an iterative
   * algorithm to determine the actual maximum value for the
   * calendar field. Subclasses should, if possible, override this
   * with a more efficient implementation.
   *
   * @param field the calendar field
   * @return the maximum of the given calendar field for the time
   * value of this `Calendar`
   * @see #getMinimum(int)
   * @see #getMaximum(int)
   * @see #getGreatestMinimum(int)
   * @see #getLeastMaximum(int)
   * @see #getActualMinimum(int)
   * @since 1.2
  */
  getActualMaximum(field: number): number;
  /**
   * Creates and returns a copy of this object.
   *
   * @return a copy of this object.
  */
  clone(): any;
  /**
   * Return a string representation of this calendar. This method
   * is intended to be used only for debugging purposes, and the
   * format of the returned string may vary between implementations.
   * The returned string may be empty but may not be `null`.
   *
   * @return  a string representation of this calendar.
  */
  toString(): string;
  /**
   * Converts this object to an {@link Instant}.
   * 
   * The conversion creates an `Instant` that represents the
   * same point on the time-line as this `Calendar`.
   *
   * @return the instant representing the same point on the time-line
   * @since 1.8
  */
  toInstant(): Instant;
  /**
   * Compares this object with the specified object for order.  Returns a
   * negative integer, zero, or a positive integer as this object is less
   * than, equal to, or greater than the specified object.
   *
   * The implementor must ensure
   * `sgn(x.compareTo(y)) == -sgn(y.compareTo(x))`
   * for all `x` and `y`.  (This
   * implies that `x.compareTo(y)` must throw an exception iff
   * `y.compareTo(x)` throws an exception.)
   *
   * The implementor must also ensure that the relation is transitive:
   * `(x.compareTo(y) > 0 && y.compareTo(z) > 0)` implies
   * `x.compareTo(z) > 0`.
   *
   * Finally, the implementor must ensure that `x.compareTo(y)==0`
   * implies that `sgn(x.compareTo(z)) == sgn(y.compareTo(z))`, for
   * all `z`.
   *
   * It is strongly recommended, but not strictly required that
   * `(x.compareTo(y)==0) == (x.equals(y))`.  Generally speaking, any
   * class that implements the `Comparable` interface and violates
   * this condition should clearly indicate this fact.  The recommended
   * language is "Note: this class has a natural ordering that is
   * inconsistent with equals."
   *
   * In the foregoing description, the notation
   * `sgn(`expression`)` designates the mathematical
   * signum function, which is defined to return one of `-1`,
   * `0`, or `1` according to whether the value of
   * expression is negative, zero, or positive, respectively.
   *
   * @param   o the object to be compared.
   * @return  a negative integer, zero, or a positive integer as this object
   *          is less than, equal to, or greater than the specified object.
   *
   * @throws NullPointerException if the specified object is null
   * @throws ClassCastException if the specified object's type prevents it
   *         from being compared to this object.
  */
  compareTo(o: T): number;
}
export interface Calendar extends Serializable, Cloneable, Comparable<Calendar> {}
/**
 * Unchecked exception thrown when the format width is a negative value other
 * than `-1` or is otherwise unsupported. If a given format width is not
 * representable by an `int` type, then the value
 * `Integer.MIN_VALUE` will be used in the exception.
 *
 * @since 1.5
*/
export class IllegalFormatWidthException extends IllegalFormatException {
  /**
   * Constructs an instance of this class with the specified width.
   *
   * @param  w
   *         The width
  */
  constructor(w: number);
  /**
   * Returns the width. If the width is not representable by an `int`,
   * then returns `Integer.MIN_VALUE`.
   *
   * @return  The width
  */
  getWidth(): number;
  getMessage(): string;
}
export class TreeMap<K, V> extends AbstractMap<K, V> {
  /**
   * Constructs a new, empty tree map, using the natural ordering of its
   * keys.  All keys inserted into the map must implement the {@link
   * Comparable} interface.  Furthermore, all such keys must be
   * mutually comparable: `k1.compareTo(k2)` must not throw
   * a `ClassCastException` for any keys `k1` and
   * `k2` in the map.  If the user attempts to put a key into the
   * map that violates this constraint (for example, the user attempts to
   * put a string key into a map whose keys are integers), the
   * `put(Object key, Object value)` call will throw a
   * `ClassCastException`.
  */
  constructor();
  /**
   * Constructs a new, empty tree map, ordered according to the given
   * comparator.  All keys inserted into the map must be mutually
   * comparable by the given comparator: {@code comparator.compare(k1,
   * k2)} must not throw a `ClassCastException` for any keys
   * `k1` and `k2` in the map.  If the user attempts to put
   * a key into the map that violates this constraint, the {@code put(Object
   * key, Object value)} call will throw a
   * `ClassCastException`.
   *
   * @param comparator the comparator that will be used to order this map.
   *        If `null`, the {@linkplain Comparable natural
   *        ordering} of the keys will be used.
  */
  constructor(comparator: Comparator<any>);
  /**
   * Constructs a new tree map containing the same mappings as the given
   * map, ordered according to the natural ordering of its keys.
   * All keys inserted into the new map must implement the {@link
   * Comparable} interface.  Furthermore, all such keys must be
   * mutually comparable: `k1.compareTo(k2)` must not throw
   * a `ClassCastException` for any keys `k1` and
   * `k2` in the map.  This method runs in n*log(n) time.
   *
   * @param  m the map whose mappings are to be placed in this map
   * @throws ClassCastException if the keys in m are not {@link Comparable},
   *         or are not mutually comparable
   * @throws NullPointerException if the specified map is null
  */
  constructor(m: Map<K, V>);
  /**
   * Constructs a new tree map containing the same mappings and
   * using the same ordering as the specified sorted map.  This
   * method runs in linear time.
   *
   * @param  m the sorted map whose mappings are to be placed in this map,
   *         and whose comparator is to be used to sort this map
   * @throws NullPointerException if the specified map is null
  */
  constructor(m: SortedMap<K, V>);
  /**
   * Returns the number of key-value mappings in this map.
   *
   * @return the number of key-value mappings in this map
  */
  size(): number;
  /**
   * Returns `true` if this map contains a mapping for the specified
   * key.
   *
   * @param key key whose presence in this map is to be tested
   * @return `true` if this map contains a mapping for the
   *         specified key
   * @throws ClassCastException if the specified key cannot be compared
   *         with the keys currently in the map
   * @throws NullPointerException if the specified key is null
   *         and this map uses natural ordering, or its comparator
   *         does not permit null keys
  */
  containsKey(key: any): boolean;
  /**
   * Returns `true` if this map maps one or more keys to the
   * specified value.  More formally, returns `true` if and only if
   * this map contains at least one mapping to a value `v` such
   * that `(value==null ? v==null : value.equals(v))`.  This
   * operation will probably require time linear in the map size for
   * most implementations.
   *
   * @param value value whose presence in this map is to be tested
   * @return `true` if a mapping to `value` exists;
   *         `false` otherwise
   * @since 1.2
  */
  containsValue(value: any): boolean;
  /**
   * Returns the value to which the specified key is mapped,
   * or `null` if this map contains no mapping for the key.
   *
   * More formally, if this map contains a mapping from a key
   * `k` to a value `v` such that `key` compares
   * equal to `k` according to the map's ordering, then this
   * method returns `v`; otherwise it returns `null`.
   * (There can be at most one such mapping.)
   *
   * A return value of `null` does not necessarily
   * indicate that the map contains no mapping for the key; it's also
   * possible that the map explicitly maps the key to `null`.
   * The {@link #containsKey containsKey} operation may be used to
   * distinguish these two cases.
   *
   * @throws ClassCastException if the specified key cannot be compared
   *         with the keys currently in the map
   * @throws NullPointerException if the specified key is null
   *         and this map uses natural ordering, or its comparator
   *         does not permit null keys
  */
  get(key: any): V;
  comparator(): Comparator<any>;
  /**
   * @throws NoSuchElementException {@inheritDoc}
  */
  firstKey(): K;
  /**
   * @throws NoSuchElementException {@inheritDoc}
  */
  lastKey(): K;
  /**
   * Copies all of the mappings from the specified map to this map.
   * These mappings replace any mappings that this map had for any
   * of the keys currently in the specified map.
   *
   * @param  map mappings to be stored in this map
   * @throws ClassCastException if the class of a key or value in
   *         the specified map prevents it from being stored in this map
   * @throws NullPointerException if the specified map is null or
   *         the specified map contains a null key and this map does not
   *         permit null keys
  */
  putAll(map: Map<K, V>): void;
  /**
   * Associates the specified value with the specified key in this map.
   * If the map previously contained a mapping for the key, the old
   * value is replaced.
   *
   * @param key key with which the specified value is to be associated
   * @param value value to be associated with the specified key
   *
   * @return the previous value associated with `key`, or
   *         `null` if there was no mapping for `key`.
   *         (A `null` return can also indicate that the map
   *         previously associated `null` with `key`.)
   * @throws ClassCastException if the specified key cannot be compared
   *         with the keys currently in the map
   * @throws NullPointerException if the specified key is null
   *         and this map uses natural ordering, or its comparator
   *         does not permit null keys
  */
  put(key: K, value: V): V;
  /**
   * If the specified key is not already associated with a value (or is mapped
   * to `null`) associates it with the given value and returns
   * `null`, else returns the current value.
   *
   * @implSpec
   * The default implementation is equivalent to, for this `map`:
   *
   *  {@code
   * V v = map.get(key);
   * if (v == null)
   *     v = map.put(key, value);
   *
   * return v;
   * }
   *
   * The default implementation makes no guarantees about synchronization
   * or atomicity properties of this method. Any implementation providing
   * atomicity guarantees must override this method and document its
   * concurrency properties.
   *
   * @param key key with which the specified value is to be associated
   * @param value value to be associated with the specified key
   * @return the previous value associated with the specified key, or
   *         `null` if there was no mapping for the key.
   *         (A `null` return can also indicate that the map
   *         previously associated `null` with the key,
   *         if the implementation supports null values.)
   * @throws UnsupportedOperationException if the `put` operation
   *         is not supported by this map
   *         (optional)
   * @throws ClassCastException if the key or value is of an inappropriate
   *         type for this map
   *         (optional)
   * @throws NullPointerException if the specified key or value is null,
   *         and this map does not permit null keys or values
   *         (optional)
   * @throws IllegalArgumentException if some property of the specified key
   *         or value prevents it from being stored in this map
   *         (optional)
   * @since 1.8
  */
  putIfAbsent(key: K, value: V): V;
  /**
   * {@inheritDoc}
   *
   * This method will, on a best-effort basis, throw a
   * {@link ConcurrentModificationException} if it is detected that the
   * mapping function modifies this map during computation.
   *
   * @throws ConcurrentModificationException if it is detected that the
   * mapping function modified this map
  */
  computeIfAbsent(key: K, mappingFunction: Function<any, V>): V;
  /**
   * {@inheritDoc}
   *
   * This method will, on a best-effort basis, throw a
   * {@link ConcurrentModificationException} if it is detected that the
   * remapping function modifies this map during computation.
   *
   * @throws ConcurrentModificationException if it is detected that the
   * remapping function modified this map
  */
  computeIfPresent(key: K, remappingFunction: BiFunction<any, any, V>): V;
  /**
   * {@inheritDoc}
   *
   * This method will, on a best-effort basis, throw a
   * {@link ConcurrentModificationException} if it is detected that the
   * remapping function modifies this map during computation.
   *
   * @throws ConcurrentModificationException if it is detected that the
   * remapping function modified this map
  */
  compute(key: K, remappingFunction: BiFunction<any, any, V>): V;
  /**
   * {@inheritDoc}
   *
   * This method will, on a best-effort basis, throw a
   * {@link ConcurrentModificationException} if it is detected that the
   * remapping function modifies this map during computation.
   *
   * @throws ConcurrentModificationException if it is detected that the
   * remapping function modified this map
  */
  merge(key: K, value: V, remappingFunction: BiFunction<any, any, V>): V;
  /**
   * Removes the mapping for this key from this TreeMap if present.
   *
   * @param  key key for which mapping should be removed
   * @return the previous value associated with `key`, or
   *         `null` if there was no mapping for `key`.
   *         (A `null` return can also indicate that the map
   *         previously associated `null` with `key`.)
   * @throws ClassCastException if the specified key cannot be compared
   *         with the keys currently in the map
   * @throws NullPointerException if the specified key is null
   *         and this map uses natural ordering, or its comparator
   *         does not permit null keys
  */
  remove(key: any): V;
  /**
   * Removes all of the mappings from this map.
   * The map will be empty after this call returns.
  */
  clear(): void;
  /**
   * Returns a shallow copy of this `TreeMap` instance. (The keys and
   * values themselves are not cloned.)
   *
   * @return a shallow copy of this map
  */
  clone(): any;
  /**
   * @since 1.6
  */
  firstEntry(): java_util_Map_Entry<K, V>;
  /**
   * @since 1.6
  */
  lastEntry(): java_util_Map_Entry<K, V>;
  /**
   * @since 1.6
  */
  pollFirstEntry(): java_util_Map_Entry<K, V>;
  /**
   * @since 1.6
  */
  pollLastEntry(): java_util_Map_Entry<K, V>;
  /**
   * @throws ClassCastException {@inheritDoc}
   * @throws NullPointerException if the specified key is null
   *         and this map uses natural ordering, or its comparator
   *         does not permit null keys
   * @since 1.6
  */
  lowerEntry(key: K): java_util_Map_Entry<K, V>;
  /**
   * @throws ClassCastException {@inheritDoc}
   * @throws NullPointerException if the specified key is null
   *         and this map uses natural ordering, or its comparator
   *         does not permit null keys
   * @since 1.6
  */
  lowerKey(key: K): K;
  /**
   * @throws ClassCastException {@inheritDoc}
   * @throws NullPointerException if the specified key is null
   *         and this map uses natural ordering, or its comparator
   *         does not permit null keys
   * @since 1.6
  */
  floorEntry(key: K): java_util_Map_Entry<K, V>;
  /**
   * @throws ClassCastException {@inheritDoc}
   * @throws NullPointerException if the specified key is null
   *         and this map uses natural ordering, or its comparator
   *         does not permit null keys
   * @since 1.6
  */
  floorKey(key: K): K;
  /**
   * @throws ClassCastException {@inheritDoc}
   * @throws NullPointerException if the specified key is null
   *         and this map uses natural ordering, or its comparator
   *         does not permit null keys
   * @since 1.6
  */
  ceilingEntry(key: K): java_util_Map_Entry<K, V>;
  /**
   * @throws ClassCastException {@inheritDoc}
   * @throws NullPointerException if the specified key is null
   *         and this map uses natural ordering, or its comparator
   *         does not permit null keys
   * @since 1.6
  */
  ceilingKey(key: K): K;
  /**
   * @throws ClassCastException {@inheritDoc}
   * @throws NullPointerException if the specified key is null
   *         and this map uses natural ordering, or its comparator
   *         does not permit null keys
   * @since 1.6
  */
  higherEntry(key: K): java_util_Map_Entry<K, V>;
  /**
   * @throws ClassCastException {@inheritDoc}
   * @throws NullPointerException if the specified key is null
   *         and this map uses natural ordering, or its comparator
   *         does not permit null keys
   * @since 1.6
  */
  higherKey(key: K): K;
  /**
   * Returns a {@link Set} view of the keys contained in this map.
   *
   * The set's iterator returns the keys in ascending order.
   * The set's spliterator is
   * late-binding,
   * fail-fast, and additionally reports {@link Spliterator#SORTED}
   * and {@link Spliterator#ORDERED} with an encounter order that is ascending
   * key order.  The spliterator's comparator (see
   * {@link java.util.Spliterator#getComparator()}) is `null` if
   * the tree map's comparator (see {@link #comparator()}) is `null`.
   * Otherwise, the spliterator's comparator is the same as or imposes the
   * same total ordering as the tree map's comparator.
   *
   * The set is backed by the map, so changes to the map are
   * reflected in the set, and vice-versa.  If the map is modified
   * while an iteration over the set is in progress (except through
   * the iterator's own `remove` operation), the results of
   * the iteration are undefined.  The set supports element removal,
   * which removes the corresponding mapping from the map, via the
   * `Iterator.remove`, `Set.remove`,
   * `removeAll`, `retainAll`, and `clear`
   * operations.  It does not support the `add` or `addAll`
   * operations.
  */
  keySet(): Set<K>;
  /**
   * @since 1.6
  */
  navigableKeySet(): NavigableSet<K>;
  /**
   * @since 1.6
  */
  descendingKeySet(): NavigableSet<K>;
  /**
   * Returns a {@link Collection} view of the values contained in this map.
   *
   * The collection's iterator returns the values in ascending order
   * of the corresponding keys. The collection's spliterator is
   * late-binding,
   * fail-fast, and additionally reports {@link Spliterator#ORDERED}
   * with an encounter order that is ascending order of the corresponding
   * keys.
   *
   * The collection is backed by the map, so changes to the map are
   * reflected in the collection, and vice-versa.  If the map is
   * modified while an iteration over the collection is in progress
   * (except through the iterator's own `remove` operation),
   * the results of the iteration are undefined.  The collection
   * supports element removal, which removes the corresponding
   * mapping from the map, via the `Iterator.remove`,
   * `Collection.remove`, `removeAll`,
   * `retainAll` and `clear` operations.  It does not
   * support the `add` or `addAll` operations.
  */
  values(): Collection<V>;
  /**
   * Returns a {@link Set} view of the mappings contained in this map.
   *
   * The set's iterator returns the entries in ascending key order. The
   * set's spliterator is
   * late-binding,
   * fail-fast, and additionally reports {@link Spliterator#SORTED} and
   * {@link Spliterator#ORDERED} with an encounter order that is ascending key
   * order.
   *
   * The set is backed by the map, so changes to the map are
   * reflected in the set, and vice-versa.  If the map is modified
   * while an iteration over the set is in progress (except through
   * the iterator's own `remove` operation, or through the
   * `setValue` operation on a map entry returned by the
   * iterator) the results of the iteration are undefined.  The set
   * supports element removal, which removes the corresponding
   * mapping from the map, via the `Iterator.remove`,
   * `Set.remove`, `removeAll`, `retainAll` and
   * `clear` operations.  It does not support the
   * `add` or `addAll` operations.
  */
  entrySet(): Set<java_util_Map_Entry<K, V>>;
  /**
   * @since 1.6
  */
  descendingMap(): NavigableMap<K, V>;
  /**
   * @throws ClassCastException       {@inheritDoc}
   * @throws NullPointerException if `fromKey` or `toKey` is
   *         null and this map uses natural ordering, or its comparator
   *         does not permit null keys
   * @throws IllegalArgumentException {@inheritDoc}
   * @since 1.6
  */
  subMap(fromKey: K, fromInclusive: boolean, toKey: K, toInclusive: boolean): NavigableMap<K, V>;
  /**
   * @throws ClassCastException       {@inheritDoc}
   * @throws NullPointerException if `toKey` is null
   *         and this map uses natural ordering, or its comparator
   *         does not permit null keys
   * @throws IllegalArgumentException {@inheritDoc}
   * @since 1.6
  */
  headMap(toKey: K, inclusive: boolean): NavigableMap<K, V>;
  /**
   * @throws ClassCastException       {@inheritDoc}
   * @throws NullPointerException if `fromKey` is null
   *         and this map uses natural ordering, or its comparator
   *         does not permit null keys
   * @throws IllegalArgumentException {@inheritDoc}
   * @since 1.6
  */
  tailMap(fromKey: K, inclusive: boolean): NavigableMap<K, V>;
  /**
   * @throws ClassCastException       {@inheritDoc}
   * @throws NullPointerException if `fromKey` or `toKey` is
   *         null and this map uses natural ordering, or its comparator
   *         does not permit null keys
   * @throws IllegalArgumentException {@inheritDoc}
  */
  subMap(fromKey: K, toKey: K): SortedMap<K, V>;
  /**
   * @throws ClassCastException       {@inheritDoc}
   * @throws NullPointerException if `toKey` is null
   *         and this map uses natural ordering, or its comparator
   *         does not permit null keys
   * @throws IllegalArgumentException {@inheritDoc}
  */
  headMap(toKey: K): SortedMap<K, V>;
  /**
   * @throws ClassCastException       {@inheritDoc}
   * @throws NullPointerException if `fromKey` is null
   *         and this map uses natural ordering, or its comparator
   *         does not permit null keys
   * @throws IllegalArgumentException {@inheritDoc}
  */
  tailMap(fromKey: K): SortedMap<K, V>;
  /**
   * Replaces the entry for the specified key only if currently
   * mapped to the specified value.
   *
   * @implSpec
   * The default implementation is equivalent to, for this `map`:
   *
   *  {@code
   * if (map.containsKey(key) && Objects.equals(map.get(key), oldValue)) {
   *     map.put(key, newValue);
   *     return true;
   * } else
   *     return false;
   * }
   *
   * The default implementation does not throw NullPointerException
   * for maps that do not support null values if oldValue is null unless
   * newValue is also null.
   *
   * The default implementation makes no guarantees about synchronization
   * or atomicity properties of this method. Any implementation providing
   * atomicity guarantees must override this method and document its
   * concurrency properties.
   *
   * @param key key with which the specified value is associated
   * @param oldValue value expected to be associated with the specified key
   * @param newValue value to be associated with the specified key
   * @return `true` if the value was replaced
   * @throws UnsupportedOperationException if the `put` operation
   *         is not supported by this map
   *         (optional)
   * @throws ClassCastException if the class of a specified key or value
   *         prevents it from being stored in this map
   * @throws NullPointerException if a specified key or newValue is null,
   *         and this map does not permit null keys or values
   * @throws NullPointerException if oldValue is null and this map does not
   *         permit null values
   *         (optional)
   * @throws IllegalArgumentException if some property of a specified key
   *         or value prevents it from being stored in this map
   * @since 1.8
  */
  replace(key: K, oldValue: V, newValue: V): boolean;
  /**
   * Replaces the entry for the specified key only if currently
   * mapped to the specified value.
   *
   * @implSpec
   * The default implementation is equivalent to, for this `map`:
   *
   *  {@code
   * if (map.containsKey(key) && Objects.equals(map.get(key), oldValue)) {
   *     map.put(key, newValue);
   *     return true;
   * } else
   *     return false;
   * }
   *
   * The default implementation does not throw NullPointerException
   * for maps that do not support null values if oldValue is null unless
   * newValue is also null.
   *
   * The default implementation makes no guarantees about synchronization
   * or atomicity properties of this method. Any implementation providing
   * atomicity guarantees must override this method and document its
   * concurrency properties.
   *
   * @param key key with which the specified value is associated
   * @param oldValue value expected to be associated with the specified key
   * @param newValue value to be associated with the specified key
   * @return `true` if the value was replaced
   * @throws UnsupportedOperationException if the `put` operation
   *         is not supported by this map
   *         (optional)
   * @throws ClassCastException if the class of a specified key or value
   *         prevents it from being stored in this map
   * @throws NullPointerException if a specified key or newValue is null,
   *         and this map does not permit null keys or values
   * @throws NullPointerException if oldValue is null and this map does not
   *         permit null values
   *         (optional)
   * @throws IllegalArgumentException if some property of a specified key
   *         or value prevents it from being stored in this map
   * @since 1.8
  */
  replace(key: K, value: V): V;
  /**
   * Performs the given action for each entry in this map until all entries
   * have been processed or the action throws an exception.   Unless
   * otherwise specified by the implementing class, actions are performed in
   * the order of entry set iteration (if an iteration order is specified.)
   * Exceptions thrown by the action are relayed to the caller.
   *
   * @implSpec
   * The default implementation is equivalent to, for this `map`:
   *  {@code
   * for (Map.Entry entry : map.entrySet())
   *     action.accept(entry.getKey(), entry.getValue());
   * }
   *
   * The default implementation makes no guarantees about synchronization
   * or atomicity properties of this method. Any implementation providing
   * atomicity guarantees must override this method and document its
   * concurrency properties.
   *
   * @param action The action to be performed for each entry
   * @throws NullPointerException if the specified action is null
   * @throws ConcurrentModificationException if an entry is found to be
   * removed during iteration
   * @since 1.8
  */
  forEach(action: BiConsumer<any, any>): void;
  /**
   * Replaces each entry's value with the result of invoking the given
   * function on that entry until all entries have been processed or the
   * function throws an exception.  Exceptions thrown by the function are
   * relayed to the caller.
   *
   * @implSpec
   * The default implementation is equivalent to, for this `map`:
   *  {@code
   * for (Map.Entry entry : map.entrySet())
   *     entry.setValue(function.apply(entry.getKey(), entry.getValue()));
   * }
   *
   * The default implementation makes no guarantees about synchronization
   * or atomicity properties of this method. Any implementation providing
   * atomicity guarantees must override this method and document its
   * concurrency properties.
   *
   * @param function the function to apply to each entry
   * @throws UnsupportedOperationException if the `set` operation
   * is not supported by this map's entry set iterator.
   * @throws ClassCastException if the class of a replacement value
   * prevents it from being stored in this map
   * @throws NullPointerException if the specified function is null, or the
   * specified replacement value is null, and this map does not permit null
   * values
   * @throws ClassCastException if a replacement value is of an inappropriate
   *         type for this map
   *         (optional)
   * @throws NullPointerException if function or a replacement value is null,
   *         and this map does not permit null keys or values
   *         (optional)
   * @throws IllegalArgumentException if some property of a replacement value
   *         prevents it from being stored in this map
   *         (optional)
   * @throws ConcurrentModificationException if an entry is found to be
   * removed during iteration
   * @since 1.8
  */
  replaceAll(func: BiFunction<any, any, V>): void;
  /**
   * Removes the entry for the specified key only if it is currently
   * mapped to the specified value.
   *
   * @implSpec
   * The default implementation is equivalent to, for this `map`:
   *
   *  {@code
   * if (map.containsKey(key) && Objects.equals(map.get(key), value)) {
   *     map.remove(key);
   *     return true;
   * } else
   *     return false;
   * }
   *
   * The default implementation makes no guarantees about synchronization
   * or atomicity properties of this method. Any implementation providing
   * atomicity guarantees must override this method and document its
   * concurrency properties.
   *
   * @param key key with which the specified value is associated
   * @param value value expected to be associated with the specified key
   * @return `true` if the value was removed
   * @throws UnsupportedOperationException if the `remove` operation
   *         is not supported by this map
   *         (optional)
   * @throws ClassCastException if the key or value is of an inappropriate
   *         type for this map
   *         (optional)
   * @throws NullPointerException if the specified key or value is null,
   *         and this map does not permit null keys or values
   *         (optional)
   * @since 1.8
  */
  remove(key: any, value: any): boolean;
}
export interface TreeMap<K, V> extends AbstractMap<K, V>, NavigableMap<K, V>, Cloneable, Serializable {}
/**
 * A class can implement the `Observer` interface when it
 * wants to be informed of changes in observable objects.
 *
 * @author  Chris Warth
 * @see     java.util.Observable
 * @since   1.0
 *
 * @deprecated
 * This interface has been deprecated. See the {@link Observable}
 * class for further information.
*/
export class Observer {
  /**
   * This method is called whenever the observed object is changed. An
   * application calls an `Observable` object's
   * `notifyObservers` method to have all the object's
   * observers notified of the change.
   *
   * @param   o     the observable object.
   * @param   arg   an argument passed to the `notifyObservers`
   *                 method.
  */
  update(o: Observable, arg: any): void;
}
export class SortedSet<E> extends Set<E> {
  /**
   * Returns the comparator used to order the elements in this set,
   * or `null` if this set uses the {@linkplain Comparable
   * natural ordering} of its elements.
   *
   * @return the comparator used to order the elements in this set,
   *         or `null` if this set uses the natural ordering
   *         of its elements
  */
  comparator(): Comparator<any>;
  /**
   * Returns a view of the portion of this set whose elements range
   * from `fromElement`, inclusive, to `toElement`,
   * exclusive.  (If `fromElement` and `toElement` are
   * equal, the returned set is empty.)  The returned set is backed
   * by this set, so changes in the returned set are reflected in
   * this set, and vice-versa.  The returned set supports all
   * optional set operations that this set supports.
   *
   * The returned set will throw an `IllegalArgumentException`
   * on an attempt to insert an element outside its range.
   *
   * @param fromElement low endpoint (inclusive) of the returned set
   * @param toElement high endpoint (exclusive) of the returned set
   * @return a view of the portion of this set whose elements range from
   *         `fromElement`, inclusive, to `toElement`, exclusive
   * @throws ClassCastException if `fromElement` and
   *         `toElement` cannot be compared to one another using this
   *         set's comparator (or, if the set has no comparator, using
   *         natural ordering).  Implementations may, but are not required
   *         to, throw this exception if `fromElement` or
   *         `toElement` cannot be compared to elements currently in
   *         the set.
   * @throws NullPointerException if `fromElement` or
   *         `toElement` is null and this set does not permit null
   *         elements
   * @throws IllegalArgumentException if `fromElement` is
   *         greater than `toElement`; or if this set itself
   *         has a restricted range, and `fromElement` or
   *         `toElement` lies outside the bounds of the range
  */
  subSet(fromElement: E, toElement: E): SortedSet<E>;
  /**
   * Returns a view of the portion of this set whose elements are
   * strictly less than `toElement`.  The returned set is
   * backed by this set, so changes in the returned set are
   * reflected in this set, and vice-versa.  The returned set
   * supports all optional set operations that this set supports.
   *
   * The returned set will throw an `IllegalArgumentException`
   * on an attempt to insert an element outside its range.
   *
   * @param toElement high endpoint (exclusive) of the returned set
   * @return a view of the portion of this set whose elements are strictly
   *         less than `toElement`
   * @throws ClassCastException if `toElement` is not compatible
   *         with this set's comparator (or, if the set has no comparator,
   *         if `toElement` does not implement {@link Comparable}).
   *         Implementations may, but are not required to, throw this
   *         exception if `toElement` cannot be compared to elements
   *         currently in the set.
   * @throws NullPointerException if `toElement` is null and
   *         this set does not permit null elements
   * @throws IllegalArgumentException if this set itself has a
   *         restricted range, and `toElement` lies outside the
   *         bounds of the range
  */
  headSet(toElement: E): SortedSet<E>;
  /**
   * Returns a view of the portion of this set whose elements are
   * greater than or equal to `fromElement`.  The returned
   * set is backed by this set, so changes in the returned set are
   * reflected in this set, and vice-versa.  The returned set
   * supports all optional set operations that this set supports.
   *
   * The returned set will throw an `IllegalArgumentException`
   * on an attempt to insert an element outside its range.
   *
   * @param fromElement low endpoint (inclusive) of the returned set
   * @return a view of the portion of this set whose elements are greater
   *         than or equal to `fromElement`
   * @throws ClassCastException if `fromElement` is not compatible
   *         with this set's comparator (or, if the set has no comparator,
   *         if `fromElement` does not implement {@link Comparable}).
   *         Implementations may, but are not required to, throw this
   *         exception if `fromElement` cannot be compared to elements
   *         currently in the set.
   * @throws NullPointerException if `fromElement` is null
   *         and this set does not permit null elements
   * @throws IllegalArgumentException if this set itself has a
   *         restricted range, and `fromElement` lies outside the
   *         bounds of the range
  */
  tailSet(fromElement: E): SortedSet<E>;
  /**
   * Returns the first (lowest) element currently in this set.
   *
   * @return the first (lowest) element currently in this set
   * @throws NoSuchElementException if this set is empty
  */
  first(): E;
  /**
   * Returns the last (highest) element currently in this set.
   *
   * @return the last (highest) element currently in this set
   * @throws NoSuchElementException if this set is empty
  */
  last(): E;
  /**
   * Creates a `Spliterator` over the elements in this sorted set.
   *
   * The `Spliterator` reports {@link Spliterator#DISTINCT},
   * {@link Spliterator#SORTED} and {@link Spliterator#ORDERED}.
   * Implementations should document the reporting of additional
   * characteristic values.
   *
   * The spliterator's comparator (see
   * {@link java.util.Spliterator#getComparator()}) must be `null` if
   * the sorted set's comparator (see {@link #comparator()}) is `null`.
   * Otherwise, the spliterator's comparator must be the same as or impose the
   * same total ordering as the sorted set's comparator.
   *
   * @implSpec
   * The default implementation creates a
   * late-binding spliterator
   * from the sorted set's `Iterator`.  The spliterator inherits the
   * fail-fast properties of the set's iterator.  The
   * spliterator's comparator is the same as the sorted set's comparator.
   * 
   * The created `Spliterator` additionally reports
   * {@link Spliterator#SIZED}.
   *
   * @implNote
   * The created `Spliterator` additionally reports
   * {@link Spliterator#SUBSIZED}.
   *
   * @return a `Spliterator` over the elements in this sorted set
   * @since 1.8
  */
  spliterator(): Spliterator<E>;
}
/**
 * An unbounded priority {@linkplain Queue queue} based on a priority heap.
 * The elements of the priority queue are ordered according to their
 * {@linkplain Comparable natural ordering}, or by a {@link Comparator}
 * provided at queue construction time, depending on which constructor is
 * used.  A priority queue does not permit `null` elements.
 * A priority queue relying on natural ordering also does not permit
 * insertion of non-comparable objects (doing so may result in
 * `ClassCastException`).
 *
 * The head of this queue is the least element
 * with respect to the specified ordering.  If multiple elements are
 * tied for least value, the head is one of those elements -- ties are
 * broken arbitrarily.  The queue retrieval operations `poll`,
 * `remove`, `peek`, and `element` access the
 * element at the head of the queue.
 *
 * A priority queue is unbounded, but has an internal
 * capacity governing the size of an array used to store the
 * elements on the queue.  It is always at least as large as the queue
 * size.  As elements are added to a priority queue, its capacity
 * grows automatically.  The details of the growth policy are not
 * specified.
 *
 * This class and its iterator implement all of the
 * optional methods of the {@link Collection} and {@link
 * Iterator} interfaces.  The Iterator provided in method {@link
 * #iterator()} and the Spliterator provided in method {@link #spliterator()}
 * are not guaranteed to traverse the elements of
 * the priority queue in any particular order. If you need ordered
 * traversal, consider using `Arrays.sort(pq.toArray())`.
 *
 * Note that this implementation is not synchronized.
 * Multiple threads should not access a `PriorityQueue`
 * instance concurrently if any of the threads modifies the queue.
 * Instead, use the thread-safe {@link
 * java.util.concurrent.PriorityBlockingQueue} class.
 *
 * Implementation note: this implementation provides
 * O(log(n)) time for the enqueuing and dequeuing methods
 * (`offer`, `poll`, `remove()` and `add`);
 * linear time for the `remove(Object)` and `contains(Object)`
 * methods; and constant time for the retrieval methods
 * (`peek`, `element`, and `size`).
 *
 * This class is a member of the
 * 
 * Java Collections Framework.
 *
 * @since 1.5
 * @author Josh Bloch, Doug Lea
 * @param  the type of elements held in this queue
*/
export class PriorityQueue<E> extends AbstractQueue<E> {
  /**
   * Creates a `PriorityQueue` with the default initial
   * capacity (11) that orders its elements according to their
   * {@linkplain Comparable natural ordering}.
  */
  constructor();
  /**
   * Creates a `PriorityQueue` with the specified initial
   * capacity that orders its elements according to their
   * {@linkplain Comparable natural ordering}.
   *
   * @param initialCapacity the initial capacity for this priority queue
   * @throws IllegalArgumentException if `initialCapacity` is less
   *         than 1
  */
  constructor(initialCapacity: number);
  /**
   * Creates a `PriorityQueue` with the default initial capacity and
   * whose elements are ordered according to the specified comparator.
   *
   * @param  comparator the comparator that will be used to order this
   *         priority queue.  If `null`, the {@linkplain Comparable
   *         natural ordering} of the elements will be used.
   * @since 1.8
  */
  constructor(comparator: Comparator<any>);
  /**
   * Creates a `PriorityQueue` with the specified initial capacity
   * that orders its elements according to the specified comparator.
   *
   * @param  initialCapacity the initial capacity for this priority queue
   * @param  comparator the comparator that will be used to order this
   *         priority queue.  If `null`, the {@linkplain Comparable
   *         natural ordering} of the elements will be used.
   * @throws IllegalArgumentException if `initialCapacity` is
   *         less than 1
  */
  constructor(initialCapacity: number, comparator: Comparator<any>);
  /**
   * Creates a `PriorityQueue` containing the elements in the
   * specified collection.  If the specified collection is an instance of
   * a {@link SortedSet} or is another `PriorityQueue`, this
   * priority queue will be ordered according to the same ordering.
   * Otherwise, this priority queue will be ordered according to the
   * {@linkplain Comparable natural ordering} of its elements.
   *
   * @param  c the collection whose elements are to be placed
   *         into this priority queue
   * @throws ClassCastException if elements of the specified collection
   *         cannot be compared to one another according to the priority
   *         queue's ordering
   * @throws NullPointerException if the specified collection or any
   *         of its elements are null
  */
  constructor(c: Collection<E>);
  /**
   * Creates a `PriorityQueue` containing the elements in the
   * specified priority queue.  This priority queue will be
   * ordered according to the same ordering as the given priority
   * queue.
   *
   * @param  c the priority queue whose elements are to be placed
   *         into this priority queue
   * @throws ClassCastException if elements of `c` cannot be
   *         compared to one another according to `c`'s
   *         ordering
   * @throws NullPointerException if the specified priority queue or any
   *         of its elements are null
  */
  constructor(c: PriorityQueue<E>);
  /**
   * Creates a `PriorityQueue` containing the elements in the
   * specified sorted set.   This priority queue will be ordered
   * according to the same ordering as the given sorted set.
   *
   * @param  c the sorted set whose elements are to be placed
   *         into this priority queue
   * @throws ClassCastException if elements of the specified sorted
   *         set cannot be compared to one another according to the
   *         sorted set's ordering
   * @throws NullPointerException if the specified sorted set or any
   *         of its elements are null
  */
  constructor(c: SortedSet<E>);
  /**
   * Inserts the specified element into this priority queue.
   *
   * @return `true` (as specified by {@link Collection#add})
   * @throws ClassCastException if the specified element cannot be
   *         compared with elements currently in this priority queue
   *         according to the priority queue's ordering
   * @throws NullPointerException if the specified element is null
  */
  add(e: E): boolean;
  /**
   * Inserts the specified element into this priority queue.
   *
   * @return `true` (as specified by {@link Queue#offer})
   * @throws ClassCastException if the specified element cannot be
   *         compared with elements currently in this priority queue
   *         according to the priority queue's ordering
   * @throws NullPointerException if the specified element is null
  */
  offer(e: E): boolean;
  peek(): E;
  /**
   * Removes a single instance of the specified element from this queue,
   * if it is present.  More formally, removes an element `e` such
   * that `o.equals(e)`, if this queue contains one or more such
   * elements.  Returns `true` if and only if this queue contained
   * the specified element (or equivalently, if this queue changed as a
   * result of the call).
   *
   * @param o element to be removed from this queue, if present
   * @return `true` if this queue changed as a result of the call
  */
  remove(o: any): boolean;
  /**
   * Returns `true` if this queue contains the specified element.
   * More formally, returns `true` if and only if this queue contains
   * at least one element `e` such that `o.equals(e)`.
   *
   * @param o object to be checked for containment in this queue
   * @return `true` if this queue contains the specified element
  */
  contains(o: any): boolean;
  /**
   * Returns an array containing all of the elements in this queue.
   * The elements are in no particular order.
   *
   * The returned array will be "safe" in that no references to it are
   * maintained by this queue.  (In other words, this method must allocate
   * a new array).  The caller is thus free to modify the returned array.
   *
   * This method acts as bridge between array-based and collection-based
   * APIs.
   *
   * @return an array containing all of the elements in this queue
  */
  toArray(): any[];
  /**
   * Returns an array containing all of the elements in this queue; the
   * runtime type of the returned array is that of the specified array.
   * The returned array elements are in no particular order.
   * If the queue fits in the specified array, it is returned therein.
   * Otherwise, a new array is allocated with the runtime type of the
   * specified array and the size of this queue.
   *
   * If the queue fits in the specified array with room to spare
   * (i.e., the array has more elements than the queue), the element in
   * the array immediately following the end of the collection is set to
   * `null`.
   *
   * Like the {@link #toArray()} method, this method acts as bridge between
   * array-based and collection-based APIs.  Further, this method allows
   * precise control over the runtime type of the output array, and may,
   * under certain circumstances, be used to save allocation costs.
   *
   * Suppose `x` is a queue known to contain only strings.
   * The following code can be used to dump the queue into a newly
   * allocated array of `String`:
   *
   *  `String[] y = x.toArray(new String[0]);`
   *
   * Note that `toArray(new Object[0])` is identical in function to
   * `toArray()`.
   *
   * @param a the array into which the elements of the queue are to
   *          be stored, if it is big enough; otherwise, a new array of the
   *          same runtime type is allocated for this purpose.
   * @return an array containing all of the elements in this queue
   * @throws ArrayStoreException if the runtime type of the specified array
   *         is not a supertype of the runtime type of every element in
   *         this queue
   * @throws NullPointerException if the specified array is null
  */
  toArray<T>(a: T[]): T[];
  /**
   * Returns an iterator over the elements in this queue. The iterator
   * does not return the elements in any particular order.
   *
   * @return an iterator over the elements in this queue
  */
  iterator(): Iterator<E>;
  size(): number;
  /**
   * Removes all of the elements from this priority queue.
   * The queue will be empty after this call returns.
  */
  clear(): void;
  poll(): E;
  /**
   * Returns the comparator used to order the elements in this
   * queue, or `null` if this queue is sorted according to
   * the {@linkplain Comparable natural ordering} of its elements.
   *
   * @return the comparator used to order this queue, or
   *         `null` if this queue is sorted according to the
   *         natural ordering of its elements
  */
  comparator(): Comparator<any>;
  /**
   * Creates a late-binding
   * and fail-fast {@link Spliterator} over the elements in this
   * queue. The spliterator does not traverse elements in any particular order
   * (the {@link Spliterator#ORDERED ORDERED} characteristic is not reported).
   *
   * The `Spliterator` reports {@link Spliterator#SIZED},
   * {@link Spliterator#SUBSIZED}, and {@link Spliterator#NONNULL}.
   * Overriding implementations should document the reporting of additional
   * characteristic values.
   *
   * @return a `Spliterator` over the elements in this queue
   * @since 1.8
  */
  spliterator(): Spliterator<E>;
  /**
   * @throws NullPointerException {@inheritDoc}
  */
  removeIf(filter: Predicate<any>): boolean;
  /**
   * @throws NullPointerException {@inheritDoc}
  */
  removeAll(c: Collection<any>): boolean;
  /**
   * @throws NullPointerException {@inheritDoc}
  */
  retainAll(c: Collection<any>): boolean;
  /**
   * @throws NullPointerException {@inheritDoc}
  */
  forEach(action: Consumer<any>): void;
  /**
   * Retrieves and removes the head of this queue.  This method differs
   * from {@link #poll poll} only in that it throws an exception if this
   * queue is empty.
   *
   * This implementation returns the result of `poll`
   * unless the queue is empty.
   *
   * @return the head of this queue
   * @throws NoSuchElementException if this queue is empty
  */
  remove(): E;
  /**
   * Returns an array containing all of the elements in this collection,
   * using the provided `generator` function to allocate the returned array.
   *
   * If this collection makes any guarantees as to what order its elements
   * are returned by its iterator, this method must return the elements in
   * the same order.
   *
   * @apiNote
   * This method acts as a bridge between array-based and collection-based APIs.
   * It allows creation of an array of a particular runtime type. Use
   * {@link #toArray()} to create an array whose runtime type is `Object[]`,
   * or use {@link #toArray(Object[]) toArray(T[])} to reuse an existing array.
   *
   * Suppose `x` is a collection known to contain only strings.
   * The following code can be used to dump the collection into a newly
   * allocated array of `String`:
   *
   *      *     String[] y = x.toArray(String[]::new);
   *
   * @implSpec
   * The default implementation calls the generator function with zero
   * and then passes the resulting array to {@link #toArray(Object[]) toArray(T[])}.
   *
   * @param  the component type of the array to contain the collection
   * @param generator a function which produces a new array of the desired
   *                  type and the provided length
   * @return an array containing all of the elements in this collection
   * @throws ArrayStoreException if the runtime type of any element in this
   *         collection is not assignable to the {@linkplain Class#getComponentType
   *         runtime component type} of the generated array
   * @throws NullPointerException if the generator function is null
   * @since 11
  */
  toArray<T>(generator: IntFunction<T[]>): T[];
}
export interface PriorityQueue<E> extends AbstractQueue<E>, Serializable {}
/**
 * A simple text scanner which can parse primitive types and strings using
 * regular expressions.
 *
 * A `Scanner` breaks its input into tokens using a
 * delimiter pattern, which by default matches whitespace. The resulting
 * tokens may then be converted into values of different types using the
 * various `next` methods.
 *
 * For example, this code allows a user to read a number from
 * `System.in`:
 * {@code
 *     Scanner sc = new Scanner(System.in);
 *     int i = sc.nextInt();
 * }
 *
 * As another example, this code allows `long` types to be
 * assigned from entries in a file `myNumbers`:
 * {@code
 *      Scanner sc = new Scanner(new File("myNumbers"));
 *      while (sc.hasNextLong()) {
 *          long aLong = sc.nextLong();
 *      }
 * }
 *
 * The scanner can also use delimiters other than whitespace. This
 * example reads several items in from a string:
 * {@code
 *     String input = "1 fish 2 fish red fish blue fish";
 *     Scanner s = new Scanner(input).useDelimiter("\\s*fish\\s*");
 *     System.out.println(s.nextInt());
 *     System.out.println(s.nextInt());
 *     System.out.println(s.next());
 *     System.out.println(s.next());
 *     s.close();
 * }
 * 
 * prints the following output:
 * {@code
 *     1
 *     2
 *     red
 *     blue
 * }
 *
 * The same output can be generated with this code, which uses a regular
 * expression to parse all four tokens at once:
 * {@code
 *     String input = "1 fish 2 fish red fish blue fish";
 *     Scanner s = new Scanner(input);
 *     s.findInLine("(\\d+) fish (\\d+) fish (\\w+) fish (\\w+)");
 *     MatchResult result = s.match();
 *     for (int i=1; i<=result.groupCount(); i++)
 *         System.out.println(result.group(i));
 *     s.close();
 * }
 *
 * The default whitespace delimiter used
 * by a scanner is as recognized by {@link Character#isWhitespace(char)
 * Character.isWhitespace()}. The {@link #reset reset()}
 * method will reset the value of the scanner's delimiter to the default
 * whitespace delimiter regardless of whether it was previously changed.
 *
 * A scanning operation may block waiting for input.
 *
 * The {@link #next} and {@link #hasNext} methods and their
 * companion methods (such as {@link #nextInt} and
 * {@link #hasNextInt}) first skip any input that matches the delimiter
 * pattern, and then attempt to return the next token. Both `hasNext()`
 * and `next()` methods may block waiting for further input.  Whether a
 * `hasNext()` method blocks has no connection to whether or not its
 * associated `next()` method will block. The {@link #tokens} method
 * may also block waiting for input.
 *
 * The {@link #findInLine findInLine()},
 * {@link #findWithinHorizon findWithinHorizon()},
 * {@link #skip skip()}, and {@link #findAll findAll()}
 * methods operate independently of the delimiter pattern. These methods will
 * attempt to match the specified pattern with no regard to delimiters in the
 * input and thus can be used in special circumstances where delimiters are
 * not relevant. These methods may block waiting for more input.
 *
 * When a scanner throws an {@link InputMismatchException}, the scanner
 * will not pass the token that caused the exception, so that it may be
 * retrieved or skipped via some other method.
 *
 * Depending upon the type of delimiting pattern, empty tokens may be
 * returned. For example, the pattern `"\\s+"` will return no empty
 * tokens since it matches multiple instances of the delimiter. The delimiting
 * pattern `"\\s"` could return empty tokens since it only passes one
 * space at a time.
 *
 *  A scanner can read text from any object which implements the {@link
 * java.lang.Readable} interface.  If an invocation of the underlying
 * readable's {@link java.lang.Readable#read read()} method throws an {@link
 * java.io.IOException} then the scanner assumes that the end of the input
 * has been reached.  The most recent `IOException` thrown by the
 * underlying readable can be retrieved via the {@link #ioException} method.
 *
 * When a `Scanner` is closed, it will close its input source
 * if the source implements the {@link java.io.Closeable} interface.
 *
 * A `Scanner` is not safe for multithreaded use without
 * external synchronization.
 *
 * Unless otherwise mentioned, passing a `null` parameter into
 * any method of a `Scanner` will cause a
 * `NullPointerException` to be thrown.
 *
 * A scanner will default to interpreting numbers as decimal unless a
 * different radix has been set by using the {@link #useRadix} method. The
 * {@link #reset} method will reset the value of the scanner's radix to
 * `10` regardless of whether it was previously changed.
 *
 *  Localized numbers 
 *
 *  An instance of this class is capable of scanning numbers in the standard
 * formats as well as in the formats of the scanner's locale. A scanner's
 * initial locale is the value returned by the {@link
 * java.util.Locale#getDefault(Locale.Category)
 * Locale.getDefault(Locale.Category.FORMAT)} method; it may be changed via the {@link
 * #useLocale useLocale()} method. The {@link #reset} method will reset the value of the
 * scanner's locale to the initial locale regardless of whether it was
 * previously changed.
 *
 * The localized formats are defined in terms of the following parameters,
 * which for a particular locale are taken from that locale's {@link
 * java.text.DecimalFormat DecimalFormat} object, `df`, and its and
 * {@link java.text.DecimalFormatSymbols DecimalFormatSymbols} object,
 * `dfs`.
 *
 * 
 *     LocalGroupSeparator  
 *         The character used to separate thousands groups,
 *         i.e., `dfs.`{@link
 *         java.text.DecimalFormatSymbols#getGroupingSeparator
 *         getGroupingSeparator()}
 *     LocalDecimalSeparator  
 *         The character used for the decimal point,
 *     i.e., `dfs.`{@link
 *     java.text.DecimalFormatSymbols#getDecimalSeparator
 *     getDecimalSeparator()}
 *     LocalPositivePrefix  
 *         The string that appears before a positive number (may
 *         be empty), i.e., `df.`{@link
 *         java.text.DecimalFormat#getPositivePrefix
 *         getPositivePrefix()}
 *     LocalPositiveSuffix  
 *         The string that appears after a positive number (may be
 *         empty), i.e., `df.`{@link
 *         java.text.DecimalFormat#getPositiveSuffix
 *         getPositiveSuffix()}
 *     LocalNegativePrefix  
 *         The string that appears before a negative number (may
 *         be empty), i.e., `df.`{@link
 *         java.text.DecimalFormat#getNegativePrefix
 *         getNegativePrefix()}
 *     LocalNegativeSuffix  
 *         The string that appears after a negative number (may be
 *         empty), i.e., `df.`{@link
 *     java.text.DecimalFormat#getNegativeSuffix
 *     getNegativeSuffix()}
 *     LocalNaN  
 *         The string that represents not-a-number for
 *         floating-point values,
 *         i.e., `dfs.`{@link
 *         java.text.DecimalFormatSymbols#getNaN
 *         getNaN()}
 *     LocalInfinity  
 *         The string that represents infinity for floating-point
 *         values, i.e., `dfs.`{@link
 *         java.text.DecimalFormatSymbols#getInfinity
 *         getInfinity()}
 * 
 *
 *  Number syntax 
 *
 *  The strings that can be parsed as numbers by an instance of this class
 * are specified in terms of the following regular-expression grammar, where
 * Rmax is the highest digit in the radix being used (for example, Rmax is 9 in base 10).
 *
 * 
 *   NonAsciiDigit:
 *       A non-ASCII character c for which
 *            {@link java.lang.Character#isDigit Character.isDigit}`(c)`
 *                        returns true
 *
 *   Non0Digit:
 *       `[1-`Rmax`] | `NonASCIIDigit
 *
 *   Digit:
 *       `[0-`Rmax`] | `NonASCIIDigit
 *
 *   GroupedNumeral:
 *       ( Non0Digit
 *                   Digit{@code ?
 *                   }Digit`?`
 *           ( LocalGroupSeparator
 *                         Digit
 *                         Digit
 *                         Digit` )+ )`
 *
 *   Numeral:
 *       `( ( `Digit{@code + )
 *               | }GroupedNumeral` )`
 *
 *   Integer:
 *       `( [-+]? ( `Numeral` *                               ) )`
 *       `| `LocalPositivePrefix Numeral
 *                      LocalPositiveSuffix
 *       `| `LocalNegativePrefix Numeral
 *                 LocalNegativeSuffix
 *
 *   DecimalNumeral:
 *       Numeral
 *       `| `Numeral
 *                 LocalDecimalSeparator
 *                 Digit`*`
 *       `| `LocalDecimalSeparator
 *                 Digit`+`
 *
 *   Exponent:
 *       `( [eE] [+-]? `Digit`+ )`
 *
 *   Decimal:
 *       `( [-+]? `DecimalNumeral
 *                         Exponent`? )`
 *       `| `LocalPositivePrefix
 *                 DecimalNumeral
 *                 LocalPositiveSuffix
 *                 Exponent`?`
 *       `| `LocalNegativePrefix
 *                 DecimalNumeral
 *                 LocalNegativeSuffix
 *                 Exponent`?`
 *
 *   HexFloat:
 *       {@code [-+]? 0[xX][0-9a-fA-F]*\.[0-9a-fA-F]+
 *                 ([pP][-+]?[0-9]+)?}
 *
 *   NonNumber:
 *       {@code NaN
 *                          | }LocalNan{@code
 *                          | Infinity
 *                          | }LocalInfinity
 *
 *   SignedNonNumber:
 *       `( [-+]? `NonNumber` )`
 *       `| `LocalPositivePrefix
 *                 NonNumber
 *                 LocalPositiveSuffix
 *       `| `LocalNegativePrefix
 *                 NonNumber
 *                 LocalNegativeSuffix
 *
 *   Float:
 *       Decimal
 *           `| `HexFloat
 *           `| `SignedNonNumber
 *
 * 
 * Whitespace is not significant in the above regular expressions.
 *
 * @since   1.5
*/
export class Scanner extends Iterator<string> {
  /**
   * Constructs a new `Scanner` that produces values scanned
   * from the specified source.
   *
   * @param  source A character source implementing the {@link Readable}
   *         interface
  */
  constructor(source: Readable);
  /**
   * Constructs a new `Scanner` that produces values scanned
   * from the specified input stream. Bytes from the stream are converted
   * into characters using the underlying platform's
   * {@linkplain java.nio.charset.Charset#defaultCharset() default charset}.
   *
   * @param  source An input stream to be scanned
  */
  constructor(source: InputStream);
  /**
   * Constructs a new `Scanner` that produces values scanned
   * from the specified input stream. Bytes from the stream are converted
   * into characters using the specified charset.
   *
   * @param  source An input stream to be scanned
   * @param charsetName The encoding type used to convert bytes from the
   *        stream into characters to be scanned
   * @throws IllegalArgumentException if the specified character set
   *         does not exist
  */
  constructor(source: InputStream, charsetName: string);
  /**
   * Constructs a new `Scanner` that produces values scanned
   * from the specified input stream. Bytes from the stream are converted
   * into characters using the specified charset.
   *
   * @param  source an input stream to be scanned
   * @param  charset the charset used to convert bytes from the file
   *         into characters to be scanned
   * @since  10
  */
  constructor(source: InputStream, charset: Charset);
  /**
   * Constructs a new `Scanner` that produces values scanned
   * from the specified file. Bytes from the file are converted into
   * characters using the underlying platform's
   * {@linkplain java.nio.charset.Charset#defaultCharset() default charset}.
   *
   * @param  source A file to be scanned
   * @throws FileNotFoundException if source is not found
  */
  constructor(source: File);
  /**
   * Constructs a new `Scanner` that produces values scanned
   * from the specified file. Bytes from the file are converted into
   * characters using the specified charset.
   *
   * @param  source A file to be scanned
   * @param charsetName The encoding type used to convert bytes from the file
   *        into characters to be scanned
   * @throws FileNotFoundException if source is not found
   * @throws IllegalArgumentException if the specified encoding is
   *         not found
  */
  constructor(source: File, charsetName: string);
  /**
   * Constructs a new `Scanner` that produces values scanned
   * from the specified file. Bytes from the file are converted into
   * characters using the specified charset.
   *
   * @param  source A file to be scanned
   * @param  charset The charset used to convert bytes from the file
   *         into characters to be scanned
   * @throws IOException
   *         if an I/O error occurs opening the source
   * @since  10
  */
  constructor(source: File, charset: Charset);
  /**
   * Constructs a new `Scanner` that produces values scanned
   * from the specified file. Bytes from the file are converted into
   * characters using the underlying platform's
   * {@linkplain java.nio.charset.Charset#defaultCharset() default charset}.
   *
   * @param   source
   *          the path to the file to be scanned
   * @throws  IOException
   *          if an I/O error occurs opening source
   *
   * @since   1.7
  */
  constructor(source: Path);
  /**
   * Constructs a new `Scanner` that produces values scanned
   * from the specified file. Bytes from the file are converted into
   * characters using the specified charset.
   *
   * @param   source
   *          the path to the file to be scanned
   * @param   charsetName
   *          The encoding type used to convert bytes from the file
   *          into characters to be scanned
   * @throws  IOException
   *          if an I/O error occurs opening source
   * @throws  IllegalArgumentException
   *          if the specified encoding is not found
   * @since   1.7
  */
  constructor(source: Path, charsetName: string);
  /**
   * Constructs a new `Scanner` that produces values scanned
   * from the specified file. Bytes from the file are converted into
   * characters using the specified charset.
   *
   * @param   source
   *          the path to the file to be scanned
   * @param   charset
   *          the charset used to convert bytes from the file
   *          into characters to be scanned
   * @throws  IOException
   *          if an I/O error occurs opening the source
   * @since   10
  */
  constructor(source: Path, charset: Charset);
  /**
   * Constructs a new `Scanner` that produces values scanned
   * from the specified string.
   *
   * @param  source A string to scan
  */
  constructor(source: string);
  /**
   * Constructs a new `Scanner` that produces values scanned
   * from the specified channel. Bytes from the source are converted into
   * characters using the underlying platform's
   * {@linkplain java.nio.charset.Charset#defaultCharset() default charset}.
   *
   * @param  source A channel to scan
  */
  constructor(source: ReadableByteChannel);
  /**
   * Constructs a new `Scanner` that produces values scanned
   * from the specified channel. Bytes from the source are converted into
   * characters using the specified charset.
   *
   * @param  source A channel to scan
   * @param charsetName The encoding type used to convert bytes from the
   *        channel into characters to be scanned
   * @throws IllegalArgumentException if the specified character set
   *         does not exist
  */
  constructor(source: ReadableByteChannel, charsetName: string);
  /**
   * Constructs a new `Scanner` that produces values scanned
   * from the specified channel. Bytes from the source are converted into
   * characters using the specified charset.
   *
   * @param source a channel to scan
   * @param charset the encoding type used to convert bytes from the
   *        channel into characters to be scanned
   * @since 10
  */
  constructor(source: ReadableByteChannel, charset: Charset);
  /**
   * Closes this scanner.
   *
   *  If this scanner has not yet been closed then if its underlying
   * {@linkplain java.lang.Readable readable} also implements the {@link
   * java.io.Closeable} interface then the readable's `close` method
   * will be invoked.  If this scanner is already closed then invoking this
   * method will have no effect.
   *
   * Attempting to perform search operations after a scanner has
   * been closed will result in an {@link IllegalStateException}.
   *
  */
  close(): void;
  /**
   * Returns the `IOException` last thrown by this
   * `Scanner`'s underlying `Readable`. This method
   * returns `null` if no such exception exists.
   *
   * @return the last exception thrown by this scanner's readable
  */
  ioException(): IOException;
  /**
   * Returns the `Pattern` this `Scanner` is currently
   * using to match delimiters.
   *
   * @return this scanner's delimiting pattern.
  */
  delimiter(): Pattern;
  /**
   * Sets this scanner's delimiting pattern to the specified pattern.
   *
   * @param pattern A delimiting pattern
   * @return this scanner
  */
  useDelimiter(pattern: Pattern): Scanner;
  /**
   * Sets this scanner's delimiting pattern to a pattern constructed from
   * the specified `String`.
   *
   *  An invocation of this method of the form
   * `useDelimiter(pattern)` behaves in exactly the same way as the
   * invocation `useDelimiter(Pattern.compile(pattern))`.
   *
   *  Invoking the {@link #reset} method will set the scanner's delimiter
   * to the default.
   *
   * @param pattern A string specifying a delimiting pattern
   * @return this scanner
  */
  useDelimiter(pattern: string): Scanner;
  /**
   * Returns this scanner's locale.
   *
   * A scanner's locale affects many elements of its default
   * primitive matching regular expressions; see
   * localized numbers above.
   *
   * @return this scanner's locale
  */
  locale(): Locale;
  /**
   * Sets this scanner's locale to the specified locale.
   *
   * A scanner's locale affects many elements of its default
   * primitive matching regular expressions; see
   * localized numbers above.
   *
   * Invoking the {@link #reset} method will set the scanner's locale to
   * the initial locale.
   *
   * @param locale A string specifying the locale to use
   * @return this scanner
  */
  useLocale(locale: Locale): Scanner;
  /**
   * Returns this scanner's default radix.
   *
   * A scanner's radix affects elements of its default
   * number matching regular expressions; see
   * localized numbers above.
   *
   * @return the default radix of this scanner
  */
  radix(): number;
  /**
   * Sets this scanner's default radix to the specified radix.
   *
   * A scanner's radix affects elements of its default
   * number matching regular expressions; see
   * localized numbers above.
   *
   * If the radix is less than {@link Character#MIN_RADIX Character.MIN_RADIX}
   * or greater than {@link Character#MAX_RADIX Character.MAX_RADIX}, then an
   * `IllegalArgumentException` is thrown.
   *
   * Invoking the {@link #reset} method will set the scanner's radix to
   * `10`.
   *
   * @param radix The radix to use when scanning numbers
   * @return this scanner
   * @throws IllegalArgumentException if radix is out of range
  */
  useRadix(radix: number): Scanner;
  /**
   * Returns the match result of the last scanning operation performed
   * by this scanner. This method throws `IllegalStateException`
   * if no match has been performed, or if the last match was
   * not successful.
   *
   * The various `next` methods of `Scanner`
   * make a match result available if they complete without throwing an
   * exception. For instance, after an invocation of the {@link #nextInt}
   * method that returned an int, this method returns a
   * `MatchResult` for the search of the
   * Integer regular expression
   * defined above. Similarly the {@link #findInLine findInLine()},
   * {@link #findWithinHorizon findWithinHorizon()}, and {@link #skip skip()}
   * methods will make a match available if they succeed.
   *
   * @return a match result for the last match operation
   * @throws IllegalStateException  If no match result is available
  */
  match(): MatchResult;
  /**
   * Returns the string representation of this `Scanner`. The
   * string representation of a `Scanner` contains information
   * that may be useful for debugging. The exact format is unspecified.
   *
   * @return  The string representation of this scanner
  */
  toString(): string;
  /**
   * Returns true if this scanner has another token in its input.
   * This method may block while waiting for input to scan.
   * The scanner does not advance past any input.
   *
   * @return true if and only if this scanner has another token
   * @throws IllegalStateException if this scanner is closed
   * @see java.util.Iterator
  */
  hasNext(): boolean;
  /**
   * Finds and returns the next complete token from this scanner.
   * A complete token is preceded and followed by input that matches
   * the delimiter pattern. This method may block while waiting for input
   * to scan, even if a previous invocation of {@link #hasNext} returned
   * `true`.
   *
   * @return the next token
   * @throws NoSuchElementException if no more tokens are available
   * @throws IllegalStateException if this scanner is closed
   * @see java.util.Iterator
  */
  next(): string;
  /**
   * The remove operation is not supported by this implementation of
   * `Iterator`.
   *
   * @throws UnsupportedOperationException if this method is invoked.
   * @see java.util.Iterator
  */
  remove(): void;
  /**
   * Returns true if the next token matches the pattern constructed from the
   * specified string. The scanner does not advance past any input.
   *
   *  An invocation of this method of the form `hasNext(pattern)`
   * behaves in exactly the same way as the invocation
   * `hasNext(Pattern.compile(pattern))`.
   *
   * @param pattern a string specifying the pattern to scan
   * @return true if and only if this scanner has another token matching
   *         the specified pattern
   * @throws IllegalStateException if this scanner is closed
  */
  hasNext(pattern: string): boolean;
  /**
   * Returns the next token if it matches the pattern constructed from the
   * specified string.  If the match is successful, the scanner advances
   * past the input that matched the pattern.
   *
   *  An invocation of this method of the form `next(pattern)`
   * behaves in exactly the same way as the invocation
   * `next(Pattern.compile(pattern))`.
   *
   * @param pattern a string specifying the pattern to scan
   * @return the next token
   * @throws NoSuchElementException if no such tokens are available
   * @throws IllegalStateException if this scanner is closed
  */
  next(pattern: string): string;
  /**
   * Returns true if the next complete token matches the specified pattern.
   * A complete token is prefixed and postfixed by input that matches
   * the delimiter pattern. This method may block while waiting for input.
   * The scanner does not advance past any input.
   *
   * @param pattern the pattern to scan for
   * @return true if and only if this scanner has another token matching
   *         the specified pattern
   * @throws IllegalStateException if this scanner is closed
  */
  hasNext(pattern: Pattern): boolean;
  /**
   * Returns the next token if it matches the specified pattern. This
   * method may block while waiting for input to scan, even if a previous
   * invocation of {@link #hasNext(Pattern)} returned `true`.
   * If the match is successful, the scanner advances past the input that
   * matched the pattern.
   *
   * @param pattern the pattern to scan for
   * @return the next token
   * @throws NoSuchElementException if no more tokens are available
   * @throws IllegalStateException if this scanner is closed
  */
  next(pattern: Pattern): string;
  /**
   * Returns true if there is another line in the input of this scanner.
   * This method may block while waiting for input. The scanner does not
   * advance past any input.
   *
   * @return true if and only if this scanner has another line of input
   * @throws IllegalStateException if this scanner is closed
  */
  hasNextLine(): boolean;
  /**
   * Advances this scanner past the current line and returns the input
   * that was skipped.
   *
   * This method returns the rest of the current line, excluding any line
   * separator at the end. The position is set to the beginning of the next
   * line.
   *
   * Since this method continues to search through the input looking
   * for a line separator, it may buffer all of the input searching for
   * the line to skip if no line separators are present.
   *
   * @return the line that was skipped
   * @throws NoSuchElementException if no line was found
   * @throws IllegalStateException if this scanner is closed
  */
  nextLine(): string;
  /**
   * Attempts to find the next occurrence of a pattern constructed from the
   * specified string, ignoring delimiters.
   *
   * An invocation of this method of the form `findInLine(pattern)`
   * behaves in exactly the same way as the invocation
   * `findInLine(Pattern.compile(pattern))`.
   *
   * @param pattern a string specifying the pattern to search for
   * @return the text that matched the specified pattern
   * @throws IllegalStateException if this scanner is closed
  */
  findInLine(pattern: string): string;
  /**
   * Attempts to find the next occurrence of the specified pattern ignoring
   * delimiters. If the pattern is found before the next line separator, the
   * scanner advances past the input that matched and returns the string that
   * matched the pattern.
   * If no such pattern is detected in the input up to the next line
   * separator, then `null` is returned and the scanner's
   * position is unchanged. This method may block waiting for input that
   * matches the pattern.
   *
   * Since this method continues to search through the input looking
   * for the specified pattern, it may buffer all of the input searching for
   * the desired token if no line separators are present.
   *
   * @param pattern the pattern to scan for
   * @return the text that matched the specified pattern
   * @throws IllegalStateException if this scanner is closed
  */
  findInLine(pattern: Pattern): string;
  /**
   * Attempts to find the next occurrence of a pattern constructed from the
   * specified string, ignoring delimiters.
   *
   * An invocation of this method of the form
   * `findWithinHorizon(pattern)` behaves in exactly the same way as
   * the invocation
   * `findWithinHorizon(Pattern.compile(pattern), horizon)`.
   *
   * @param pattern a string specifying the pattern to search for
   * @param horizon the search horizon
   * @return the text that matched the specified pattern
   * @throws IllegalStateException if this scanner is closed
   * @throws IllegalArgumentException if horizon is negative
  */
  findWithinHorizon(pattern: string, horizon: number): string;
  /**
   * Attempts to find the next occurrence of the specified pattern.
   *
   * This method searches through the input up to the specified
   * search horizon, ignoring delimiters. If the pattern is found the
   * scanner advances past the input that matched and returns the string
   * that matched the pattern. If no such pattern is detected then the
   * null is returned and the scanner's position remains unchanged. This
   * method may block waiting for input that matches the pattern.
   *
   * A scanner will never search more than `horizon` code
   * points beyond its current position. Note that a match may be clipped
   * by the horizon; that is, an arbitrary match result may have been
   * different if the horizon had been larger. The scanner treats the
   * horizon as a transparent, non-anchoring bound (see {@link
   * Matcher#useTransparentBounds} and {@link Matcher#useAnchoringBounds}).
   *
   * If horizon is `0`, then the horizon is ignored and
   * this method continues to search through the input looking for the
   * specified pattern without bound. In this case it may buffer all of
   * the input searching for the pattern.
   *
   * If horizon is negative, then an IllegalArgumentException is
   * thrown.
   *
   * @param pattern the pattern to scan for
   * @param horizon the search horizon
   * @return the text that matched the specified pattern
   * @throws IllegalStateException if this scanner is closed
   * @throws IllegalArgumentException if horizon is negative
  */
  findWithinHorizon(pattern: Pattern, horizon: number): string;
  /**
   * Skips input that matches the specified pattern, ignoring delimiters.
   * This method will skip input if an anchored match of the specified
   * pattern succeeds.
   *
   * If a match to the specified pattern is not found at the
   * current position, then no input is skipped and a
   * `NoSuchElementException` is thrown.
   *
   * Since this method seeks to match the specified pattern starting at
   * the scanner's current position, patterns that can match a lot of
   * input (".*", for example) may cause the scanner to buffer a large
   * amount of input.
   *
   * Note that it is possible to skip something without risking a
   * `NoSuchElementException` by using a pattern that can
   * match nothing, e.g., `sc.skip("[ \t]*")`.
   *
   * @param pattern a string specifying the pattern to skip over
   * @return this scanner
   * @throws NoSuchElementException if the specified pattern is not found
   * @throws IllegalStateException if this scanner is closed
  */
  skip(pattern: Pattern): Scanner;
  /**
   * Skips input that matches a pattern constructed from the specified
   * string.
   *
   *  An invocation of this method of the form `skip(pattern)`
   * behaves in exactly the same way as the invocation
   * `skip(Pattern.compile(pattern))`.
   *
   * @param pattern a string specifying the pattern to skip over
   * @return this scanner
   * @throws IllegalStateException if this scanner is closed
  */
  skip(pattern: string): Scanner;
  /**
   * Returns true if the next token in this scanner's input can be
   * interpreted as a boolean value using a case insensitive pattern
   * created from the string "true|false".  The scanner does not
   * advance past the input that matched.
   *
   * @return true if and only if this scanner's next token is a valid
   *         boolean value
   * @throws IllegalStateException if this scanner is closed
  */
  hasNextBoolean(): boolean;
  /**
   * Scans the next token of the input into a boolean value and returns
   * that value. This method will throw `InputMismatchException`
   * if the next token cannot be translated into a valid boolean value.
   * If the match is successful, the scanner advances past the input that
   * matched.
   *
   * @return the boolean scanned from the input
   * @throws InputMismatchException if the next token is not a valid boolean
   * @throws NoSuchElementException if input is exhausted
   * @throws IllegalStateException if this scanner is closed
  */
  nextBoolean(): boolean;
  /**
   * Returns true if the next token in this scanner's input can be
   * interpreted as a byte value in the default radix using the
   * {@link #nextByte} method. The scanner does not advance past any input.
   *
   * @return true if and only if this scanner's next token is a valid
   *         byte value
   * @throws IllegalStateException if this scanner is closed
  */
  hasNextByte(): boolean;
  /**
   * Returns true if the next token in this scanner's input can be
   * interpreted as a byte value in the specified radix using the
   * {@link #nextByte} method. The scanner does not advance past any input.
   *
   * If the radix is less than {@link Character#MIN_RADIX Character.MIN_RADIX}
   * or greater than {@link Character#MAX_RADIX Character.MAX_RADIX}, then an
   * `IllegalArgumentException` is thrown.
   *
   * @param radix the radix used to interpret the token as a byte value
   * @return true if and only if this scanner's next token is a valid
   *         byte value
   * @throws IllegalStateException if this scanner is closed
   * @throws IllegalArgumentException if the radix is out of range
  */
  hasNextByte(radix: number): boolean;
  /**
   * Scans the next token of the input as a `byte`.
   *
   *  An invocation of this method of the form
   * `nextByte()` behaves in exactly the same way as the
   * invocation `nextByte(radix)`, where `radix`
   * is the default radix of this scanner.
   *
   * @return the `byte` scanned from the input
   * @throws InputMismatchException
   *         if the next token does not match the Integer
   *         regular expression, or is out of range
   * @throws NoSuchElementException if input is exhausted
   * @throws IllegalStateException if this scanner is closed
  */
  nextByte(): number;
  /**
   * Scans the next token of the input as a `byte`.
   * This method will throw `InputMismatchException`
   * if the next token cannot be translated into a valid byte value as
   * described below. If the translation is successful, the scanner advances
   * past the input that matched.
   *
   *  If the next token matches the Integer regular expression defined
   * above then the token is converted into a `byte` value as if by
   * removing all locale specific prefixes, group separators, and locale
   * specific suffixes, then mapping non-ASCII digits into ASCII
   * digits via {@link Character#digit Character.digit}, prepending a
   * negative sign (-) if the locale specific negative prefixes and suffixes
   * were present, and passing the resulting string to
   * {@link Byte#parseByte(String, int) Byte.parseByte} with the
   * specified radix.
   *
   * If the radix is less than {@link Character#MIN_RADIX Character.MIN_RADIX}
   * or greater than {@link Character#MAX_RADIX Character.MAX_RADIX}, then an
   * `IllegalArgumentException` is thrown.
   *
   * @param radix the radix used to interpret the token as a byte value
   * @return the `byte` scanned from the input
   * @throws InputMismatchException
   *         if the next token does not match the Integer
   *         regular expression, or is out of range
   * @throws NoSuchElementException if input is exhausted
   * @throws IllegalStateException if this scanner is closed
   * @throws IllegalArgumentException if the radix is out of range
  */
  nextByte(radix: number): number;
  /**
   * Returns true if the next token in this scanner's input can be
   * interpreted as a short value in the default radix using the
   * {@link #nextShort} method. The scanner does not advance past any input.
   *
   * @return true if and only if this scanner's next token is a valid
   *         short value in the default radix
   * @throws IllegalStateException if this scanner is closed
  */
  hasNextShort(): boolean;
  /**
   * Returns true if the next token in this scanner's input can be
   * interpreted as a short value in the specified radix using the
   * {@link #nextShort} method. The scanner does not advance past any input.
   *
   * If the radix is less than {@link Character#MIN_RADIX Character.MIN_RADIX}
   * or greater than {@link Character#MAX_RADIX Character.MAX_RADIX}, then an
   * `IllegalArgumentException` is thrown.
   *
   * @param radix the radix used to interpret the token as a short value
   * @return true if and only if this scanner's next token is a valid
   *         short value in the specified radix
   * @throws IllegalStateException if this scanner is closed
   * @throws IllegalArgumentException if the radix is out of range
  */
  hasNextShort(radix: number): boolean;
  /**
   * Scans the next token of the input as a `short`.
   *
   *  An invocation of this method of the form
   * `nextShort()` behaves in exactly the same way as the
   * invocation {@link #nextShort(int) nextShort(radix)}, where `radix`
   * is the default radix of this scanner.
   *
   * @return the `short` scanned from the input
   * @throws InputMismatchException
   *         if the next token does not match the Integer
   *         regular expression, or is out of range
   * @throws NoSuchElementException if input is exhausted
   * @throws IllegalStateException if this scanner is closed
  */
  nextShort(): number;
  /**
   * Scans the next token of the input as a `short`.
   * This method will throw `InputMismatchException`
   * if the next token cannot be translated into a valid short value as
   * described below. If the translation is successful, the scanner advances
   * past the input that matched.
   *
   *  If the next token matches the Integer regular expression defined
   * above then the token is converted into a `short` value as if by
   * removing all locale specific prefixes, group separators, and locale
   * specific suffixes, then mapping non-ASCII digits into ASCII
   * digits via {@link Character#digit Character.digit}, prepending a
   * negative sign (-) if the locale specific negative prefixes and suffixes
   * were present, and passing the resulting string to
   * {@link Short#parseShort(String, int) Short.parseShort} with the
   * specified radix.
   *
   * If the radix is less than {@link Character#MIN_RADIX Character.MIN_RADIX}
   * or greater than {@link Character#MAX_RADIX Character.MAX_RADIX}, then an
   * `IllegalArgumentException` is thrown.
   *
   * @param radix the radix used to interpret the token as a short value
   * @return the `short` scanned from the input
   * @throws InputMismatchException
   *         if the next token does not match the Integer
   *         regular expression, or is out of range
   * @throws NoSuchElementException if input is exhausted
   * @throws IllegalStateException if this scanner is closed
   * @throws IllegalArgumentException if the radix is out of range
  */
  nextShort(radix: number): number;
  /**
   * Returns true if the next token in this scanner's input can be
   * interpreted as an int value in the default radix using the
   * {@link #nextInt} method. The scanner does not advance past any input.
   *
   * @return true if and only if this scanner's next token is a valid
   *         int value
   * @throws IllegalStateException if this scanner is closed
  */
  hasNextInt(): boolean;
  /**
   * Returns true if the next token in this scanner's input can be
   * interpreted as an int value in the specified radix using the
   * {@link #nextInt} method. The scanner does not advance past any input.
   *
   * If the radix is less than {@link Character#MIN_RADIX Character.MIN_RADIX}
   * or greater than {@link Character#MAX_RADIX Character.MAX_RADIX}, then an
   * `IllegalArgumentException` is thrown.
   *
   * @param radix the radix used to interpret the token as an int value
   * @return true if and only if this scanner's next token is a valid
   *         int value
   * @throws IllegalStateException if this scanner is closed
   * @throws IllegalArgumentException if the radix is out of range
  */
  hasNextInt(radix: number): boolean;
  /**
   * Scans the next token of the input as an `int`.
   *
   *  An invocation of this method of the form
   * `nextInt()` behaves in exactly the same way as the
   * invocation `nextInt(radix)`, where `radix`
   * is the default radix of this scanner.
   *
   * @return the `int` scanned from the input
   * @throws InputMismatchException
   *         if the next token does not match the Integer
   *         regular expression, or is out of range
   * @throws NoSuchElementException if input is exhausted
   * @throws IllegalStateException if this scanner is closed
  */
  nextInt(): number;
  /**
   * Scans the next token of the input as an `int`.
   * This method will throw `InputMismatchException`
   * if the next token cannot be translated into a valid int value as
   * described below. If the translation is successful, the scanner advances
   * past the input that matched.
   *
   *  If the next token matches the Integer regular expression defined
   * above then the token is converted into an `int` value as if by
   * removing all locale specific prefixes, group separators, and locale
   * specific suffixes, then mapping non-ASCII digits into ASCII
   * digits via {@link Character#digit Character.digit}, prepending a
   * negative sign (-) if the locale specific negative prefixes and suffixes
   * were present, and passing the resulting string to
   * {@link Integer#parseInt(String, int) Integer.parseInt} with the
   * specified radix.
   *
   * If the radix is less than {@link Character#MIN_RADIX Character.MIN_RADIX}
   * or greater than {@link Character#MAX_RADIX Character.MAX_RADIX}, then an
   * `IllegalArgumentException` is thrown.
   *
   * @param radix the radix used to interpret the token as an int value
   * @return the `int` scanned from the input
   * @throws InputMismatchException
   *         if the next token does not match the Integer
   *         regular expression, or is out of range
   * @throws NoSuchElementException if input is exhausted
   * @throws IllegalStateException if this scanner is closed
   * @throws IllegalArgumentException if the radix is out of range
  */
  nextInt(radix: number): number;
  /**
   * Returns true if the next token in this scanner's input can be
   * interpreted as a long value in the default radix using the
   * {@link #nextLong} method. The scanner does not advance past any input.
   *
   * @return true if and only if this scanner's next token is a valid
   *         long value
   * @throws IllegalStateException if this scanner is closed
  */
  hasNextLong(): boolean;
  /**
   * Returns true if the next token in this scanner's input can be
   * interpreted as a long value in the specified radix using the
   * {@link #nextLong} method. The scanner does not advance past any input.
   *
   * If the radix is less than {@link Character#MIN_RADIX Character.MIN_RADIX}
   * or greater than {@link Character#MAX_RADIX Character.MAX_RADIX}, then an
   * `IllegalArgumentException` is thrown.
   *
   * @param radix the radix used to interpret the token as a long value
   * @return true if and only if this scanner's next token is a valid
   *         long value
   * @throws IllegalStateException if this scanner is closed
   * @throws IllegalArgumentException if the radix is out of range
  */
  hasNextLong(radix: number): boolean;
  /**
   * Scans the next token of the input as a `long`.
   *
   *  An invocation of this method of the form
   * `nextLong()` behaves in exactly the same way as the
   * invocation `nextLong(radix)`, where `radix`
   * is the default radix of this scanner.
   *
   * @return the `long` scanned from the input
   * @throws InputMismatchException
   *         if the next token does not match the Integer
   *         regular expression, or is out of range
   * @throws NoSuchElementException if input is exhausted
   * @throws IllegalStateException if this scanner is closed
  */
  nextLong(): number;
  /**
   * Scans the next token of the input as a `long`.
   * This method will throw `InputMismatchException`
   * if the next token cannot be translated into a valid long value as
   * described below. If the translation is successful, the scanner advances
   * past the input that matched.
   *
   *  If the next token matches the Integer regular expression defined
   * above then the token is converted into a `long` value as if by
   * removing all locale specific prefixes, group separators, and locale
   * specific suffixes, then mapping non-ASCII digits into ASCII
   * digits via {@link Character#digit Character.digit}, prepending a
   * negative sign (-) if the locale specific negative prefixes and suffixes
   * were present, and passing the resulting string to
   * {@link Long#parseLong(String, int) Long.parseLong} with the
   * specified radix.
   *
   * If the radix is less than {@link Character#MIN_RADIX Character.MIN_RADIX}
   * or greater than {@link Character#MAX_RADIX Character.MAX_RADIX}, then an
   * `IllegalArgumentException` is thrown.
   *
   * @param radix the radix used to interpret the token as an int value
   * @return the `long` scanned from the input
   * @throws InputMismatchException
   *         if the next token does not match the Integer
   *         regular expression, or is out of range
   * @throws NoSuchElementException if input is exhausted
   * @throws IllegalStateException if this scanner is closed
   * @throws IllegalArgumentException if the radix is out of range
  */
  nextLong(radix: number): number;
  /**
   * Returns true if the next token in this scanner's input can be
   * interpreted as a float value using the {@link #nextFloat}
   * method. The scanner does not advance past any input.
   *
   * @return true if and only if this scanner's next token is a valid
   *         float value
   * @throws IllegalStateException if this scanner is closed
  */
  hasNextFloat(): boolean;
  /**
   * Scans the next token of the input as a `float`.
   * This method will throw `InputMismatchException`
   * if the next token cannot be translated into a valid float value as
   * described below. If the translation is successful, the scanner advances
   * past the input that matched.
   *
   *  If the next token matches the Float regular expression defined above
   * then the token is converted into a `float` value as if by
   * removing all locale specific prefixes, group separators, and locale
   * specific suffixes, then mapping non-ASCII digits into ASCII
   * digits via {@link Character#digit Character.digit}, prepending a
   * negative sign (-) if the locale specific negative prefixes and suffixes
   * were present, and passing the resulting string to
   * {@link Float#parseFloat Float.parseFloat}. If the token matches
   * the localized NaN or infinity strings, then either "Nan" or "Infinity"
   * is passed to {@link Float#parseFloat(String) Float.parseFloat} as
   * appropriate.
   *
   * @return the `float` scanned from the input
   * @throws InputMismatchException
   *         if the next token does not match the Float
   *         regular expression, or is out of range
   * @throws NoSuchElementException if input is exhausted
   * @throws IllegalStateException if this scanner is closed
  */
  nextFloat(): number;
  /**
   * Returns true if the next token in this scanner's input can be
   * interpreted as a double value using the {@link #nextDouble}
   * method. The scanner does not advance past any input.
   *
   * @return true if and only if this scanner's next token is a valid
   *         double value
   * @throws IllegalStateException if this scanner is closed
  */
  hasNextDouble(): boolean;
  /**
   * Scans the next token of the input as a `double`.
   * This method will throw `InputMismatchException`
   * if the next token cannot be translated into a valid double value.
   * If the translation is successful, the scanner advances past the input
   * that matched.
   *
   *  If the next token matches the Float regular expression defined above
   * then the token is converted into a `double` value as if by
   * removing all locale specific prefixes, group separators, and locale
   * specific suffixes, then mapping non-ASCII digits into ASCII
   * digits via {@link Character#digit Character.digit}, prepending a
   * negative sign (-) if the locale specific negative prefixes and suffixes
   * were present, and passing the resulting string to
   * {@link Double#parseDouble Double.parseDouble}. If the token matches
   * the localized NaN or infinity strings, then either "Nan" or "Infinity"
   * is passed to {@link Double#parseDouble(String) Double.parseDouble} as
   * appropriate.
   *
   * @return the `double` scanned from the input
   * @throws InputMismatchException
   *         if the next token does not match the Float
   *         regular expression, or is out of range
   * @throws NoSuchElementException if the input is exhausted
   * @throws IllegalStateException if this scanner is closed
  */
  nextDouble(): number;
  /**
   * Returns true if the next token in this scanner's input can be
   * interpreted as a `BigInteger` in the default radix using the
   * {@link #nextBigInteger} method. The scanner does not advance past any
   * input.
   *
   * @return true if and only if this scanner's next token is a valid
   *         `BigInteger`
   * @throws IllegalStateException if this scanner is closed
  */
  hasNextBigInteger(): boolean;
  /**
   * Returns true if the next token in this scanner's input can be
   * interpreted as a `BigInteger` in the specified radix using
   * the {@link #nextBigInteger} method. The scanner does not advance past
   * any input.
   *
   * If the radix is less than {@link Character#MIN_RADIX Character.MIN_RADIX}
   * or greater than {@link Character#MAX_RADIX Character.MAX_RADIX}, then an
   * `IllegalArgumentException` is thrown.
   *
   * @param radix the radix used to interpret the token as an integer
   * @return true if and only if this scanner's next token is a valid
   *         `BigInteger`
   * @throws IllegalStateException if this scanner is closed
   * @throws IllegalArgumentException if the radix is out of range
  */
  hasNextBigInteger(radix: number): boolean;
  /**
   * Scans the next token of the input as a {@link java.math.BigInteger
   * BigInteger}.
   *
   *  An invocation of this method of the form
   * `nextBigInteger()` behaves in exactly the same way as the
   * invocation `nextBigInteger(radix)`, where `radix`
   * is the default radix of this scanner.
   *
   * @return the `BigInteger` scanned from the input
   * @throws InputMismatchException
   *         if the next token does not match the Integer
   *         regular expression, or is out of range
   * @throws NoSuchElementException if the input is exhausted
   * @throws IllegalStateException if this scanner is closed
  */
  nextBigInteger(): BigInteger;
  /**
   * Scans the next token of the input as a {@link java.math.BigInteger
   * BigInteger}.
   *
   *  If the next token matches the Integer regular expression defined
   * above then the token is converted into a `BigInteger` value as if
   * by removing all group separators, mapping non-ASCII digits into ASCII
   * digits via the {@link Character#digit Character.digit}, and passing the
   * resulting string to the {@link
   * java.math.BigInteger#BigInteger(java.lang.String)
   * BigInteger(String, int)} constructor with the specified radix.
   *
   * If the radix is less than {@link Character#MIN_RADIX Character.MIN_RADIX}
   * or greater than {@link Character#MAX_RADIX Character.MAX_RADIX}, then an
   * `IllegalArgumentException` is thrown.
   *
   * @param radix the radix used to interpret the token
   * @return the `BigInteger` scanned from the input
   * @throws InputMismatchException
   *         if the next token does not match the Integer
   *         regular expression, or is out of range
   * @throws NoSuchElementException if the input is exhausted
   * @throws IllegalStateException if this scanner is closed
   * @throws IllegalArgumentException if the radix is out of range
  */
  nextBigInteger(radix: number): BigInteger;
  /**
   * Returns true if the next token in this scanner's input can be
   * interpreted as a `BigDecimal` using the
   * {@link #nextBigDecimal} method. The scanner does not advance past any
   * input.
   *
   * @return true if and only if this scanner's next token is a valid
   *         `BigDecimal`
   * @throws IllegalStateException if this scanner is closed
  */
  hasNextBigDecimal(): boolean;
  /**
   * Scans the next token of the input as a {@link java.math.BigDecimal
   * BigDecimal}.
   *
   *  If the next token matches the Decimal regular expression defined
   * above then the token is converted into a `BigDecimal` value as if
   * by removing all group separators, mapping non-ASCII digits into ASCII
   * digits via the {@link Character#digit Character.digit}, and passing the
   * resulting string to the {@link
   * java.math.BigDecimal#BigDecimal(java.lang.String) BigDecimal(String)}
   * constructor.
   *
   * @return the `BigDecimal` scanned from the input
   * @throws InputMismatchException
   *         if the next token does not match the Decimal
   *         regular expression, or is out of range
   * @throws NoSuchElementException if the input is exhausted
   * @throws IllegalStateException if this scanner is closed
  */
  nextBigDecimal(): BigDecimal;
  /**
   * Resets this scanner.
   *
   *  Resetting a scanner discards all of its explicit state
   * information which may have been changed by invocations of
   * {@link #useDelimiter useDelimiter()},
   * {@link #useLocale useLocale()}, or
   * {@link #useRadix useRadix()}.
   *
   *  An invocation of this method of the form
   * `scanner.reset()` behaves in exactly the same way as the
   * invocation
   *
   * `     *   scanner.useDelimiter("\\p{javaWhitespace`+")
   *          .useLocale(Locale.getDefault(Locale.Category.FORMAT))
   *          .useRadix(10);
   * }
   *
   * @return this scanner
   *
   * @since 1.6
  */
  reset(): Scanner;
  /**
   * Returns a stream of delimiter-separated tokens from this scanner. The
   * stream contains the same tokens that would be returned, starting from
   * this scanner's current state, by calling the {@link #next} method
   * repeatedly until the {@link #hasNext} method returns false.
   *
   * The resulting stream is sequential and ordered. All stream elements are
   * non-null.
   *
   * Scanning starts upon initiation of the terminal stream operation, using the
   * current state of this scanner. Subsequent calls to any methods on this scanner
   * other than {@link #close} and {@link #ioException} may return undefined results
   * or may cause undefined effects on the returned stream. The returned stream's source
   * `Spliterator` is fail-fast and will, on a best-effort basis, throw a
   * {@link java.util.ConcurrentModificationException} if any such calls are detected
   * during stream pipeline execution.
   *
   * After stream pipeline execution completes, this scanner is left in an indeterminate
   * state and cannot be reused.
   *
   * If this scanner contains a resource that must be released, this scanner
   * should be closed, either by calling its {@link #close} method, or by
   * closing the returned stream. Closing the stream will close the underlying scanner.
   * `IllegalStateException` is thrown if the scanner has been closed when this
   * method is called, or if this scanner is closed during stream pipeline execution.
   *
   * This method might block waiting for more input.
   *
   * @apiNote
   * For example, the following code will create a list of
   * comma-delimited tokens from a string:
   *
   * {@code
   * List result = new Scanner("abc,def,,ghi")
   *     .useDelimiter(",")
   *     .tokens()
   *     .collect(Collectors.toList());
   * }
   *
   * The resulting list would contain `"abc"`, `"def"`,
   * the empty string, and `"ghi"`.
   *
   * @return a sequential stream of token strings
   * @throws IllegalStateException if this scanner is closed
   * @since 9
  */
  tokens(): Stream<string>;
  /**
   * Returns a stream of match results from this scanner. The stream
   * contains the same results in the same order that would be returned by
   * calling `findWithinHorizon(pattern, 0)` and then {@link #match}
   * successively as long as {@link #findWithinHorizon findWithinHorizon()}
   * finds matches.
   *
   * The resulting stream is sequential and ordered. All stream elements are
   * non-null.
   *
   * Scanning starts upon initiation of the terminal stream operation, using the
   * current state of this scanner. Subsequent calls to any methods on this scanner
   * other than {@link #close} and {@link #ioException} may return undefined results
   * or may cause undefined effects on the returned stream. The returned stream's source
   * `Spliterator` is fail-fast and will, on a best-effort basis, throw a
   * {@link java.util.ConcurrentModificationException} if any such calls are detected
   * during stream pipeline execution.
   *
   * After stream pipeline execution completes, this scanner is left in an indeterminate
   * state and cannot be reused.
   *
   * If this scanner contains a resource that must be released, this scanner
   * should be closed, either by calling its {@link #close} method, or by
   * closing the returned stream. Closing the stream will close the underlying scanner.
   * `IllegalStateException` is thrown if the scanner has been closed when this
   * method is called, or if this scanner is closed during stream pipeline execution.
   *
   * As with the {@link #findWithinHorizon findWithinHorizon()} methods, this method
   * might block waiting for additional input, and it might buffer an unbounded amount of
   * input searching for a match.
   *
   * @apiNote
   * For example, the following code will read a file and return a list
   * of all sequences of characters consisting of seven or more Latin capital
   * letters:
   *
   * {@code
   * try (Scanner sc = new Scanner(Path.of("input.txt"))) {
   *     Pattern pat = Pattern.compile("[A-Z]{7,}");
   *     List capWords = sc.findAll(pat)
   *                               .map(MatchResult::group)
   *                               .collect(Collectors.toList());
   * }
   * }
   *
   * @param pattern the pattern to be matched
   * @return a sequential stream of match results
   * @throws NullPointerException if pattern is null
   * @throws IllegalStateException if this scanner is closed
   * @since 9
  */
  findAll(pattern: Pattern): Stream<MatchResult>;
  /**
   * Returns a stream of match results that match the provided pattern string.
   * The effect is equivalent to the following code:
   *
   * {@code
   *     scanner.findAll(Pattern.compile(patString))
   * }
   *
   * @param patString the pattern string
   * @return a sequential stream of match results
   * @throws NullPointerException if patString is null
   * @throws IllegalStateException if this scanner is closed
   * @throws PatternSyntaxException if the regular expression's syntax is invalid
   * @since 9
   * @see java.util.regex.Pattern
  */
  findAll(patString: string): Stream<MatchResult>;
}
export interface Scanner extends Iterator<string>, Closeable {}
export class EventObject extends Serializable {
  /**
   * Constructs a prototypical Event.
   *
   * @param source the object on which the Event initially occurred
   * @throws IllegalArgumentException if source is null
  */
  constructor(source: any);
  /**
   * The object on which the Event initially occurred.
   *
   * @return the object on which the Event initially occurred
  */
  getSource(): any;
  /**
   * Returns a String representation of this EventObject.
   *
   * @return a String representation of this EventObject
  */
  toString(): string;
}
export class AbstractCollection<E> extends Collection<E> {
  /**
   * Returns an iterator over the elements contained in this collection.
   *
   * @return an iterator over the elements contained in this collection
  */
  iterator(): Iterator<E>;
  size(): number;
  /**
   * {@inheritDoc}
   *
   * @implSpec
   * This implementation returns `size() == 0`.
  */
  isEmpty(): boolean;
  /**
   * {@inheritDoc}
   *
   * @implSpec
   * This implementation iterates over the elements in the collection,
   * checking each element in turn for equality with the specified element.
   *
   * @throws ClassCastException   {@inheritDoc}
   * @throws NullPointerException {@inheritDoc}
  */
  contains(o: any): boolean;
  /**
   * {@inheritDoc}
   *
   * @implSpec
   * This implementation returns an array containing all the elements
   * returned by this collection's iterator, in the same order, stored in
   * consecutive elements of the array, starting with index `0`.
   * The length of the returned array is equal to the number of elements
   * returned by the iterator, even if the size of this collection changes
   * during iteration, as might happen if the collection permits
   * concurrent modification during iteration.  The `size` method is
   * called only as an optimization hint; the correct result is returned
   * even if the iterator returns a different number of elements.
   *
   * This method is equivalent to:
   *
   *   {@code
   * List list = new ArrayList(size());
   * for (E e : this)
   *     list.add(e);
   * return list.toArray();
   * }
  */
  toArray(): any[];
  /**
   * {@inheritDoc}
   *
   * @implSpec
   * This implementation returns an array containing all the elements
   * returned by this collection's iterator in the same order, stored in
   * consecutive elements of the array, starting with index `0`.
   * If the number of elements returned by the iterator is too large to
   * fit into the specified array, then the elements are returned in a
   * newly allocated array with length equal to the number of elements
   * returned by the iterator, even if the size of this collection
   * changes during iteration, as might happen if the collection permits
   * concurrent modification during iteration.  The `size` method is
   * called only as an optimization hint; the correct result is returned
   * even if the iterator returns a different number of elements.
   *
   * This method is equivalent to:
   *
   *   {@code
   * List list = new ArrayList(size());
   * for (E e : this)
   *     list.add(e);
   * return list.toArray(a);
   * }
   *
   * @throws ArrayStoreException  {@inheritDoc}
   * @throws NullPointerException {@inheritDoc}
  */
  toArray<T>(a: T[]): T[];
  /**
   * {@inheritDoc}
   *
   * @implSpec
   * This implementation always throws an
   * `UnsupportedOperationException`.
   *
   * @throws UnsupportedOperationException {@inheritDoc}
   * @throws ClassCastException            {@inheritDoc}
   * @throws NullPointerException          {@inheritDoc}
   * @throws IllegalArgumentException      {@inheritDoc}
   * @throws IllegalStateException         {@inheritDoc}
  */
  add(e: E): boolean;
  /**
   * {@inheritDoc}
   *
   * @implSpec
   * This implementation iterates over the collection looking for the
   * specified element.  If it finds the element, it removes the element
   * from the collection using the iterator's remove method.
   *
   * Note that this implementation throws an
   * `UnsupportedOperationException` if the iterator returned by this
   * collection's iterator method does not implement the `remove`
   * method and this collection contains the specified object.
   *
   * @throws UnsupportedOperationException {@inheritDoc}
   * @throws ClassCastException            {@inheritDoc}
   * @throws NullPointerException          {@inheritDoc}
  */
  remove(o: any): boolean;
  /**
   * {@inheritDoc}
   *
   * @implSpec
   * This implementation iterates over the specified collection,
   * checking each element returned by the iterator in turn to see
   * if it's contained in this collection.  If all elements are so
   * contained `true` is returned, otherwise `false`.
   *
   * @throws ClassCastException            {@inheritDoc}
   * @throws NullPointerException          {@inheritDoc}
   * @see #contains(Object)
  */
  containsAll(c: Collection<any>): boolean;
  /**
   * {@inheritDoc}
   *
   * @implSpec
   * This implementation iterates over the specified collection, and adds
   * each object returned by the iterator to this collection, in turn.
   *
   * Note that this implementation will throw an
   * `UnsupportedOperationException` unless `add` is
   * overridden (assuming the specified collection is non-empty).
   *
   * @throws UnsupportedOperationException {@inheritDoc}
   * @throws ClassCastException            {@inheritDoc}
   * @throws NullPointerException          {@inheritDoc}
   * @throws IllegalArgumentException      {@inheritDoc}
   * @throws IllegalStateException         {@inheritDoc}
   *
   * @see #add(Object)
  */
  addAll(c: Collection<E>): boolean;
  /**
   * {@inheritDoc}
   *
   * @implSpec
   * This implementation iterates over this collection, checking each
   * element returned by the iterator in turn to see if it's contained
   * in the specified collection.  If it's so contained, it's removed from
   * this collection with the iterator's `remove` method.
   *
   * Note that this implementation will throw an
   * `UnsupportedOperationException` if the iterator returned by the
   * `iterator` method does not implement the `remove` method
   * and this collection contains one or more elements in common with the
   * specified collection.
   *
   * @throws UnsupportedOperationException {@inheritDoc}
   * @throws ClassCastException            {@inheritDoc}
   * @throws NullPointerException          {@inheritDoc}
   *
   * @see #remove(Object)
   * @see #contains(Object)
  */
  removeAll(c: Collection<any>): boolean;
  /**
   * {@inheritDoc}
   *
   * @implSpec
   * This implementation iterates over this collection, checking each
   * element returned by the iterator in turn to see if it's contained
   * in the specified collection.  If it's not so contained, it's removed
   * from this collection with the iterator's `remove` method.
   *
   * Note that this implementation will throw an
   * `UnsupportedOperationException` if the iterator returned by the
   * `iterator` method does not implement the `remove` method
   * and this collection contains one or more elements not present in the
   * specified collection.
   *
   * @throws UnsupportedOperationException {@inheritDoc}
   * @throws ClassCastException            {@inheritDoc}
   * @throws NullPointerException          {@inheritDoc}
   *
   * @see #remove(Object)
   * @see #contains(Object)
  */
  retainAll(c: Collection<any>): boolean;
  /**
   * {@inheritDoc}
   *
   * @implSpec
   * This implementation iterates over this collection, removing each
   * element using the `Iterator.remove` operation.  Most
   * implementations will probably choose to override this method for
   * efficiency.
   *
   * Note that this implementation will throw an
   * `UnsupportedOperationException` if the iterator returned by this
   * collection's `iterator` method does not implement the
   * `remove` method and this collection is non-empty.
   *
   * @throws UnsupportedOperationException {@inheritDoc}
  */
  clear(): void;
  /**
   * Returns a string representation of this collection.  The string
   * representation consists of a list of the collection's elements in the
   * order they are returned by its iterator, enclosed in square brackets
   * (`"[]"`).  Adjacent elements are separated by the characters
   * `", "` (comma and space).  Elements are converted to strings as
   * by {@link String#valueOf(Object)}.
   *
   * @return a string representation of this collection
  */
  toString(): string;
  /**
   * Returns an array containing all of the elements in this collection,
   * using the provided `generator` function to allocate the returned array.
   *
   * If this collection makes any guarantees as to what order its elements
   * are returned by its iterator, this method must return the elements in
   * the same order.
   *
   * @apiNote
   * This method acts as a bridge between array-based and collection-based APIs.
   * It allows creation of an array of a particular runtime type. Use
   * {@link #toArray()} to create an array whose runtime type is `Object[]`,
   * or use {@link #toArray(Object[]) toArray(T[])} to reuse an existing array.
   *
   * Suppose `x` is a collection known to contain only strings.
   * The following code can be used to dump the collection into a newly
   * allocated array of `String`:
   *
   *      *     String[] y = x.toArray(String[]::new);
   *
   * @implSpec
   * The default implementation calls the generator function with zero
   * and then passes the resulting array to {@link #toArray(Object[]) toArray(T[])}.
   *
   * @param  the component type of the array to contain the collection
   * @param generator a function which produces a new array of the desired
   *                  type and the provided length
   * @return an array containing all of the elements in this collection
   * @throws ArrayStoreException if the runtime type of any element in this
   *         collection is not assignable to the {@linkplain Class#getComponentType
   *         runtime component type} of the generated array
   * @throws NullPointerException if the generator function is null
   * @since 11
  */
  toArray<T>(generator: IntFunction<T[]>): T[];
}
/**
 * A {@link SortedMap} extended with navigation methods returning the
 * closest matches for given search targets. Methods
 * {@link #lowerEntry}, {@link #floorEntry}, {@link #ceilingEntry},
 * and {@link #higherEntry} return `Map.Entry` objects
 * associated with keys respectively less than, less than or equal,
 * greater than or equal, and greater than a given key, returning
 * `null` if there is no such key.  Similarly, methods
 * {@link #lowerKey}, {@link #floorKey}, {@link #ceilingKey}, and
 * {@link #higherKey} return only the associated keys. All of these
 * methods are designed for locating, not traversing entries.
 *
 * A `NavigableMap` may be accessed and traversed in either
 * ascending or descending key order.  The {@link #descendingMap}
 * method returns a view of the map with the senses of all relational
 * and directional methods inverted. The performance of ascending
 * operations and views is likely to be faster than that of descending
 * ones.  Methods
 * {@link #subMap(Object, boolean, Object, boolean) subMap(K, boolean, K, boolean)},
 * {@link #headMap(Object, boolean) headMap(K, boolean)}, and
 * {@link #tailMap(Object, boolean) tailMap(K, boolean)}
 * differ from the like-named `SortedMap` methods in accepting
 * additional arguments describing whether lower and upper bounds are
 * inclusive versus exclusive.  Submaps of any `NavigableMap`
 * must implement the `NavigableMap` interface.
 *
 * This interface additionally defines methods {@link #firstEntry},
 * {@link #pollFirstEntry}, {@link #lastEntry}, and
 * {@link #pollLastEntry} that return and/or remove the least and
 * greatest mappings, if any exist, else returning `null`.
 *
 * Implementations of entry-returning methods are expected to
 * return `Map.Entry` pairs representing snapshots of mappings
 * at the time they were produced, and thus generally do not
 * support the optional `Entry.setValue` method. Note however
 * that it is possible to change mappings in the associated map using
 * method `put`.
 *
 * Methods
 * {@link #subMap(Object, Object) subMap(K, K)},
 * {@link #headMap(Object) headMap(K)}, and
 * {@link #tailMap(Object) tailMap(K)}
 * are specified to return `SortedMap` to allow existing
 * implementations of `SortedMap` to be compatibly retrofitted to
 * implement `NavigableMap`, but extensions and implementations
 * of this interface are encouraged to override these methods to return
 * `NavigableMap`.  Similarly,
 * {@link #keySet()} can be overridden to return {@link NavigableSet}.
 *
 * This interface is a member of the
 * 
 * Java Collections Framework.
 *
 * @author Doug Lea
 * @author Josh Bloch
 * @param  the type of keys maintained by this map
 * @param  the type of mapped values
 * @since 1.6
*/
export class NavigableMap<K, V> extends SortedMap<K, V> {
  /**
   * Returns a key-value mapping associated with the greatest key
   * strictly less than the given key, or `null` if there is
   * no such key.
   *
   * @param key the key
   * @return an entry with the greatest key less than `key`,
   *         or `null` if there is no such key
   * @throws ClassCastException if the specified key cannot be compared
   *         with the keys currently in the map
   * @throws NullPointerException if the specified key is null
   *         and this map does not permit null keys
  */
  lowerEntry(key: K): java_util_Map_Entry<K, V>;
  /**
   * Returns the greatest key strictly less than the given key, or
   * `null` if there is no such key.
   *
   * @param key the key
   * @return the greatest key less than `key`,
   *         or `null` if there is no such key
   * @throws ClassCastException if the specified key cannot be compared
   *         with the keys currently in the map
   * @throws NullPointerException if the specified key is null
   *         and this map does not permit null keys
  */
  lowerKey(key: K): K;
  /**
   * Returns a key-value mapping associated with the greatest key
   * less than or equal to the given key, or `null` if there
   * is no such key.
   *
   * @param key the key
   * @return an entry with the greatest key less than or equal to
   *         `key`, or `null` if there is no such key
   * @throws ClassCastException if the specified key cannot be compared
   *         with the keys currently in the map
   * @throws NullPointerException if the specified key is null
   *         and this map does not permit null keys
  */
  floorEntry(key: K): java_util_Map_Entry<K, V>;
  /**
   * Returns the greatest key less than or equal to the given key,
   * or `null` if there is no such key.
   *
   * @param key the key
   * @return the greatest key less than or equal to `key`,
   *         or `null` if there is no such key
   * @throws ClassCastException if the specified key cannot be compared
   *         with the keys currently in the map
   * @throws NullPointerException if the specified key is null
   *         and this map does not permit null keys
  */
  floorKey(key: K): K;
  /**
   * Returns a key-value mapping associated with the least key
   * greater than or equal to the given key, or `null` if
   * there is no such key.
   *
   * @param key the key
   * @return an entry with the least key greater than or equal to
   *         `key`, or `null` if there is no such key
   * @throws ClassCastException if the specified key cannot be compared
   *         with the keys currently in the map
   * @throws NullPointerException if the specified key is null
   *         and this map does not permit null keys
  */
  ceilingEntry(key: K): java_util_Map_Entry<K, V>;
  /**
   * Returns the least key greater than or equal to the given key,
   * or `null` if there is no such key.
   *
   * @param key the key
   * @return the least key greater than or equal to `key`,
   *         or `null` if there is no such key
   * @throws ClassCastException if the specified key cannot be compared
   *         with the keys currently in the map
   * @throws NullPointerException if the specified key is null
   *         and this map does not permit null keys
  */
  ceilingKey(key: K): K;
  /**
   * Returns a key-value mapping associated with the least key
   * strictly greater than the given key, or `null` if there
   * is no such key.
   *
   * @param key the key
   * @return an entry with the least key greater than `key`,
   *         or `null` if there is no such key
   * @throws ClassCastException if the specified key cannot be compared
   *         with the keys currently in the map
   * @throws NullPointerException if the specified key is null
   *         and this map does not permit null keys
  */
  higherEntry(key: K): java_util_Map_Entry<K, V>;
  /**
   * Returns the least key strictly greater than the given key, or
   * `null` if there is no such key.
   *
   * @param key the key
   * @return the least key greater than `key`,
   *         or `null` if there is no such key
   * @throws ClassCastException if the specified key cannot be compared
   *         with the keys currently in the map
   * @throws NullPointerException if the specified key is null
   *         and this map does not permit null keys
  */
  higherKey(key: K): K;
  /**
   * Returns a key-value mapping associated with the least
   * key in this map, or `null` if the map is empty.
   *
   * @return an entry with the least key,
   *         or `null` if this map is empty
  */
  firstEntry(): java_util_Map_Entry<K, V>;
  /**
   * Returns a key-value mapping associated with the greatest
   * key in this map, or `null` if the map is empty.
   *
   * @return an entry with the greatest key,
   *         or `null` if this map is empty
  */
  lastEntry(): java_util_Map_Entry<K, V>;
  /**
   * Removes and returns a key-value mapping associated with
   * the least key in this map, or `null` if the map is empty.
   *
   * @return the removed first entry of this map,
   *         or `null` if this map is empty
  */
  pollFirstEntry(): java_util_Map_Entry<K, V>;
  /**
   * Removes and returns a key-value mapping associated with
   * the greatest key in this map, or `null` if the map is empty.
   *
   * @return the removed last entry of this map,
   *         or `null` if this map is empty
  */
  pollLastEntry(): java_util_Map_Entry<K, V>;
  /**
   * Returns a reverse order view of the mappings contained in this map.
   * The descending map is backed by this map, so changes to the map are
   * reflected in the descending map, and vice-versa.  If either map is
   * modified while an iteration over a collection view of either map
   * is in progress (except through the iterator's own `remove`
   * operation), the results of the iteration are undefined.
   *
   * The returned map has an ordering equivalent to
   * {@link Collections#reverseOrder(Comparator) Collections.reverseOrder}`(comparator())`.
   * The expression `m.descendingMap().descendingMap()` returns a
   * view of `m` essentially equivalent to `m`.
   *
   * @return a reverse order view of this map
  */
  descendingMap(): NavigableMap<K, V>;
  /**
   * Returns a {@link NavigableSet} view of the keys contained in this map.
   * The set's iterator returns the keys in ascending order.
   * The set is backed by the map, so changes to the map are reflected in
   * the set, and vice-versa.  If the map is modified while an iteration
   * over the set is in progress (except through the iterator's own `     * remove` operation), the results of the iteration are undefined.  The
   * set supports element removal, which removes the corresponding mapping
   * from the map, via the `Iterator.remove`, `Set.remove`,
   * `removeAll`, `retainAll`, and `clear` operations.
   * It does not support the `add` or `addAll` operations.
   *
   * @return a navigable set view of the keys in this map
  */
  navigableKeySet(): NavigableSet<K>;
  /**
   * Returns a reverse order {@link NavigableSet} view of the keys contained in this map.
   * The set's iterator returns the keys in descending order.
   * The set is backed by the map, so changes to the map are reflected in
   * the set, and vice-versa.  If the map is modified while an iteration
   * over the set is in progress (except through the iterator's own `     * remove` operation), the results of the iteration are undefined.  The
   * set supports element removal, which removes the corresponding mapping
   * from the map, via the `Iterator.remove`, `Set.remove`,
   * `removeAll`, `retainAll`, and `clear` operations.
   * It does not support the `add` or `addAll` operations.
   *
   * @return a reverse order navigable set view of the keys in this map
  */
  descendingKeySet(): NavigableSet<K>;
  /**
   * Returns a view of the portion of this map whose keys range from
   * `fromKey` to `toKey`.  If `fromKey` and
   * `toKey` are equal, the returned map is empty unless
   * `fromInclusive` and `toInclusive` are both true.  The
   * returned map is backed by this map, so changes in the returned map are
   * reflected in this map, and vice-versa.  The returned map supports all
   * optional map operations that this map supports.
   *
   * The returned map will throw an `IllegalArgumentException`
   * on an attempt to insert a key outside of its range, or to construct a
   * submap either of whose endpoints lie outside its range.
   *
   * @param fromKey low endpoint of the keys in the returned map
   * @param fromInclusive `true` if the low endpoint
   *        is to be included in the returned view
   * @param toKey high endpoint of the keys in the returned map
   * @param toInclusive `true` if the high endpoint
   *        is to be included in the returned view
   * @return a view of the portion of this map whose keys range from
   *         `fromKey` to `toKey`
   * @throws ClassCastException if `fromKey` and `toKey`
   *         cannot be compared to one another using this map's comparator
   *         (or, if the map has no comparator, using natural ordering).
   *         Implementations may, but are not required to, throw this
   *         exception if `fromKey` or `toKey`
   *         cannot be compared to keys currently in the map.
   * @throws NullPointerException if `fromKey` or `toKey`
   *         is null and this map does not permit null keys
   * @throws IllegalArgumentException if `fromKey` is greater than
   *         `toKey`; or if this map itself has a restricted
   *         range, and `fromKey` or `toKey` lies
   *         outside the bounds of the range
  */
  subMap(fromKey: K, fromInclusive: boolean, toKey: K, toInclusive: boolean): NavigableMap<K, V>;
  /**
   * Returns a view of the portion of this map whose keys are less than (or
   * equal to, if `inclusive` is true) `toKey`.  The returned
   * map is backed by this map, so changes in the returned map are reflected
   * in this map, and vice-versa.  The returned map supports all optional
   * map operations that this map supports.
   *
   * The returned map will throw an `IllegalArgumentException`
   * on an attempt to insert a key outside its range.
   *
   * @param toKey high endpoint of the keys in the returned map
   * @param inclusive `true` if the high endpoint
   *        is to be included in the returned view
   * @return a view of the portion of this map whose keys are less than
   *         (or equal to, if `inclusive` is true) `toKey`
   * @throws ClassCastException if `toKey` is not compatible
   *         with this map's comparator (or, if the map has no comparator,
   *         if `toKey` does not implement {@link Comparable}).
   *         Implementations may, but are not required to, throw this
   *         exception if `toKey` cannot be compared to keys
   *         currently in the map.
   * @throws NullPointerException if `toKey` is null
   *         and this map does not permit null keys
   * @throws IllegalArgumentException if this map itself has a
   *         restricted range, and `toKey` lies outside the
   *         bounds of the range
  */
  headMap(toKey: K, inclusive: boolean): NavigableMap<K, V>;
  /**
   * Returns a view of the portion of this map whose keys are greater than (or
   * equal to, if `inclusive` is true) `fromKey`.  The returned
   * map is backed by this map, so changes in the returned map are reflected
   * in this map, and vice-versa.  The returned map supports all optional
   * map operations that this map supports.
   *
   * The returned map will throw an `IllegalArgumentException`
   * on an attempt to insert a key outside its range.
   *
   * @param fromKey low endpoint of the keys in the returned map
   * @param inclusive `true` if the low endpoint
   *        is to be included in the returned view
   * @return a view of the portion of this map whose keys are greater than
   *         (or equal to, if `inclusive` is true) `fromKey`
   * @throws ClassCastException if `fromKey` is not compatible
   *         with this map's comparator (or, if the map has no comparator,
   *         if `fromKey` does not implement {@link Comparable}).
   *         Implementations may, but are not required to, throw this
   *         exception if `fromKey` cannot be compared to keys
   *         currently in the map.
   * @throws NullPointerException if `fromKey` is null
   *         and this map does not permit null keys
   * @throws IllegalArgumentException if this map itself has a
   *         restricted range, and `fromKey` lies outside the
   *         bounds of the range
  */
  tailMap(fromKey: K, inclusive: boolean): NavigableMap<K, V>;
  /**
   * {@inheritDoc}
   *
   * Equivalent to `subMap(fromKey, true, toKey, false)`.
   *
   * @throws ClassCastException       {@inheritDoc}
   * @throws NullPointerException     {@inheritDoc}
   * @throws IllegalArgumentException {@inheritDoc}
  */
  subMap(fromKey: K, toKey: K): SortedMap<K, V>;
  /**
   * {@inheritDoc}
   *
   * Equivalent to `headMap(toKey, false)`.
   *
   * @throws ClassCastException       {@inheritDoc}
   * @throws NullPointerException     {@inheritDoc}
   * @throws IllegalArgumentException {@inheritDoc}
  */
  headMap(toKey: K): SortedMap<K, V>;
  /**
   * {@inheritDoc}
   *
   * Equivalent to `tailMap(fromKey, true)`.
   *
   * @throws ClassCastException       {@inheritDoc}
   * @throws NullPointerException     {@inheritDoc}
   * @throws IllegalArgumentException {@inheritDoc}
  */
  tailMap(fromKey: K): SortedMap<K, V>;
}
/**
 * This class consists of `static` utility methods for operating
 * on objects, or checking certain conditions before operation.  These utilities
 * include `null`-safe or `null`-tolerant methods for computing the
 * hash code of an object, returning a string for an object, comparing two
 * objects, and checking if indexes or sub-range values are out of bounds.
 *
 * @since 1.7
*/
export class Objects {
  /**
   * Returns `true` if the arguments are equal to each other
   * and `false` otherwise.
   * Consequently, if both arguments are `null`, `true`
   * is returned.  Otherwise, if the first argument is not `     * null`, equality is determined by calling the {@link
   * Object#equals equals} method of the first argument with the
   * second argument of this method. Otherwise, `false` is
   * returned.
   *
   * @param a an object
   * @param b an object to be compared with `a` for equality
   * @return `true` if the arguments are equal to each other
   * and `false` otherwise
   * @see Object#equals(Object)
  */
  static equals(a: any, b: any): boolean;
  /**
   * Returns `true` if the arguments are deeply equal to each other
   * and `false` otherwise.
   *
   * Two `null` values are deeply equal.  If both arguments are
   * arrays, the algorithm in {@link Arrays#deepEquals(Object[],
   * Object[]) Arrays.deepEquals} is used to determine equality.
   * Otherwise, equality is determined by using the {@link
   * Object#equals equals} method of the first argument.
   *
   * @param a an object
   * @param b an object to be compared with `a` for deep equality
   * @return `true` if the arguments are deeply equal to each other
   * and `false` otherwise
   * @see Arrays#deepEquals(Object[], Object[])
   * @see Objects#equals(Object, Object)
  */
  static deepEquals(a: any, b: any): boolean;
  /**
   * Returns the hash code of a non-`null` argument and 0 for
   * a `null` argument.
   *
   * @param o an object
   * @return the hash code of a non-`null` argument and 0 for
   * a `null` argument
   * @see Object#hashCode
  */
  static hashCode(o: any): number;
  /**
   * Generates a hash code for a sequence of input values. The hash
   * code is generated as if all the input values were placed into an
   * array, and that array were hashed by calling {@link
   * Arrays#hashCode(Object[])}.
   *
   * This method is useful for implementing {@link
   * Object#hashCode()} on objects containing multiple fields. For
   * example, if an object that has three fields, `x`, `    * y`, and `z`, one could write:
   *
   *     * @Override public int hashCode() {
   *     return Objects.hash(x, y, z);
   * }
   * 
   *
   * Warning: When a single object reference is supplied, the returned
   * value does not equal the hash code of that object reference. This
   * value can be computed by calling {@link #hashCode(Object)}.
   *
   * @param values the values to be hashed
   * @return a hash value of the sequence of input values
   * @see Arrays#hashCode(Object[])
   * @see List#hashCode
  */
  static hash(...values: any[]): number;
  /**
   * Returns the result of calling `toString` for a non-`     * null` argument and `"null"` for a `null` argument.
   *
   * @param o an object
   * @return the result of calling `toString` for a non-`     * null` argument and `"null"` for a `null` argument
   * @see Object#toString
   * @see String#valueOf(Object)
  */
  static toString(o: any): string;
  /**
   * Returns the result of calling `toString` on the first
   * argument if the first argument is not `null` and returns
   * the second argument otherwise.
   *
   * @param o an object
   * @param nullDefault string to return if the first argument is
   *        `null`
   * @return the result of calling `toString` on the first
   * argument if it is not `null` and the second argument
   * otherwise.
   * @see Objects#toString(Object)
  */
  static toString(o: any, nullDefault: string): string;
  /**
   * Returns 0 if the arguments are identical and `     * c.compare(a, b)` otherwise.
   * Consequently, if both arguments are `null` 0
   * is returned.
   *
   * Note that if one of the arguments is `null`, a `     * NullPointerException` may or may not be thrown depending on
   * what ordering policy, if any, the {@link Comparator Comparator}
   * chooses to have for `null` values.
   *
   * @param  the type of the objects being compared
   * @param a an object
   * @param b an object to be compared with `a`
   * @param c the `Comparator` to compare the first two arguments
   * @return 0 if the arguments are identical and `     * c.compare(a, b)` otherwise.
   * @see Comparable
   * @see Comparator
  */
  static compare<T>(a: T, b: T, c: Comparator<any>): number;
  /**
   * Checks that the specified object reference is not `null`. This
   * method is designed primarily for doing parameter validation in methods
   * and constructors, as demonstrated below:
   *      * public Foo(Bar bar) {
   *     this.bar = Objects.requireNonNull(bar);
   * }
   * 
   *
   * @param obj the object reference to check for nullity
   * @param  the type of the reference
   * @return `obj` if not `null`
   * @throws NullPointerException if `obj` is `null`
  */
  static requireNonNull<T>(obj: T): T;
  /**
   * Checks that the specified object reference is not `null` and
   * throws a customized {@link NullPointerException} if it is. This method
   * is designed primarily for doing parameter validation in methods and
   * constructors with multiple parameters, as demonstrated below:
   *      * public Foo(Bar bar, Baz baz) {
   *     this.bar = Objects.requireNonNull(bar, "bar must not be null");
   *     this.baz = Objects.requireNonNull(baz, "baz must not be null");
   * }
   * 
   *
   * @param obj     the object reference to check for nullity
   * @param message detail message to be used in the event that a `     *                NullPointerException` is thrown
   * @param  the type of the reference
   * @return `obj` if not `null`
   * @throws NullPointerException if `obj` is `null`
  */
  static requireNonNull<T>(obj: T, message: string): T;
  /**
   * Returns `true` if the provided reference is `null` otherwise
   * returns `false`.
   *
   * @apiNote This method exists to be used as a
   * {@link java.util.function.Predicate}, `filter(Objects::isNull)`
   *
   * @param obj a reference to be checked against `null`
   * @return `true` if the provided reference is `null` otherwise
   * `false`
   *
   * @see java.util.function.Predicate
   * @since 1.8
  */
  static isNull(obj: any): boolean;
  /**
   * Returns `true` if the provided reference is non-`null`
   * otherwise returns `false`.
   *
   * @apiNote This method exists to be used as a
   * {@link java.util.function.Predicate}, `filter(Objects::nonNull)`
   *
   * @param obj a reference to be checked against `null`
   * @return `true` if the provided reference is non-`null`
   * otherwise `false`
   *
   * @see java.util.function.Predicate
   * @since 1.8
  */
  static nonNull(obj: any): boolean;
  /**
   * Returns the first argument if it is non-`null` and
   * otherwise returns the non-`null` second argument.
   *
   * @param obj an object
   * @param defaultObj a non-`null` object to return if the first argument
   *                   is `null`
   * @param  the type of the reference
   * @return the first argument if it is non-`null` and
   *        otherwise the second argument if it is non-`null`
   * @throws NullPointerException if both `obj` is null and
   *        `defaultObj` is `null`
   * @since 9
  */
  static requireNonNullElse<T>(obj: T, defaultObj: T): T;
  /**
   * Returns the first argument if it is non-`null` and otherwise
   * returns the non-`null` value of `supplier.get()`.
   *
   * @param obj an object
   * @param supplier of a non-`null` object to return if the first argument
   *                 is `null`
   * @param  the type of the first argument and return type
   * @return the first argument if it is non-`null` and otherwise
   *         the value from `supplier.get()` if it is non-`null`
   * @throws NullPointerException if both `obj` is null and
   *        either the `supplier` is `null` or
   *        the `supplier.get()` value is `null`
   * @since 9
  */
  static requireNonNullElseGet<T>(obj: T, supplier: Supplier<T>): T;
  /**
   * Checks that the specified object reference is not `null` and
   * throws a customized {@link NullPointerException} if it is.
   *
   * Unlike the method {@link #requireNonNull(Object, String)},
   * this method allows creation of the message to be deferred until
   * after the null check is made. While this may confer a
   * performance advantage in the non-null case, when deciding to
   * call this method care should be taken that the costs of
   * creating the message supplier are less than the cost of just
   * creating the string message directly.
   *
   * @param obj     the object reference to check for nullity
   * @param messageSupplier supplier of the detail message to be
   * used in the event that a `NullPointerException` is thrown
   * @param  the type of the reference
   * @return `obj` if not `null`
   * @throws NullPointerException if `obj` is `null`
   * @since 1.8
  */
  static requireNonNull<T>(obj: T, messageSupplier: Supplier<string>): T;
  /**
   * Checks if the `index` is within the bounds of the range from
   * `0` (inclusive) to `length` (exclusive).
   *
   * The `index` is defined to be out of bounds if any of the
   * following inequalities is true:
   * 
   *  `index < 0`
   *  `index >= length`
   *  `length < 0`, which is implied from the former inequalities
   * 
   *
   * @param index the index
   * @param length the upper-bound (exclusive) of the range
   * @return `index` if it is within bounds of the range
   * @throws IndexOutOfBoundsException if the `index` is out of bounds
   * @since 9
  */
  static checkIndex(index: number, length: number): number;
  /**
   * Checks if the sub-range from `fromIndex` (inclusive) to
   * `toIndex` (exclusive) is within the bounds of range from `0`
   * (inclusive) to `length` (exclusive).
   *
   * The sub-range is defined to be out of bounds if any of the following
   * inequalities is true:
   * 
   *  `fromIndex < 0`
   *  `fromIndex > toIndex`
   *  `toIndex > length`
   *  `length < 0`, which is implied from the former inequalities
   * 
   *
   * @param fromIndex the lower-bound (inclusive) of the sub-range
   * @param toIndex the upper-bound (exclusive) of the sub-range
   * @param length the upper-bound (exclusive) the range
   * @return `fromIndex` if the sub-range within bounds of the range
   * @throws IndexOutOfBoundsException if the sub-range is out of bounds
   * @since 9
  */
  static checkFromToIndex(fromIndex: number, toIndex: number, length: number): number;
  /**
   * Checks if the sub-range from `fromIndex` (inclusive) to
   * `fromIndex + size` (exclusive) is within the bounds of range from
   * `0` (inclusive) to `length` (exclusive).
   *
   * The sub-range is defined to be out of bounds if any of the following
   * inequalities is true:
   * 
   *  `fromIndex < 0`
   *  `size < 0`
   *  `fromIndex + size > length`, taking into account integer overflow
   *  `length < 0`, which is implied from the former inequalities
   * 
   *
   * @param fromIndex the lower-bound (inclusive) of the sub-interval
   * @param size the size of the sub-range
   * @param length the upper-bound (exclusive) of the range
   * @return `fromIndex` if the sub-range within bounds of the range
   * @throws IndexOutOfBoundsException if the sub-range is out of bounds
   * @since 9
  */
  static checkFromIndexSize(fromIndex: number, size: number, length: number): number;
}
export class SimpleTimeZone extends TimeZone {
  /**
   * Constructs a SimpleTimeZone with the given base time zone offset from GMT
   * and time zone ID with no daylight saving time schedule.
   *
   * @param rawOffset  The base time zone offset in milliseconds to GMT.
   * @param ID         The time zone name that is given to this instance.
  */
  constructor(rawOffset: number, ID: string);
  /**
   * Constructs a SimpleTimeZone with the given base time zone offset from
   * GMT, time zone ID, and rules for starting and ending the daylight
   * time.
   * Both `startTime` and `endTime` are specified to be
   * represented in the wall clock time. The amount of daylight saving is
   * assumed to be 3600000 milliseconds (i.e., one hour). This constructor is
   * equivalent to:
   * 
   *     SimpleTimeZone(rawOffset,
   *                    ID,
   *                    startMonth,
   *                    startDay,
   *                    startDayOfWeek,
   *                    startTime,
   *                    SimpleTimeZone.{@link #WALL_TIME},
   *                    endMonth,
   *                    endDay,
   *                    endDayOfWeek,
   *                    endTime,
   *                    SimpleTimeZone.{@link #WALL_TIME},
   *                    3600000)
   * 
   *
   * @param rawOffset       The given base time zone offset from GMT.
   * @param ID              The time zone ID which is given to this object.
   * @param startMonth      The daylight saving time starting month. Month is
   *                        a {@link Calendar#MONTH MONTH} field value (0-based. e.g., 0
   *                        for January).
   * @param startDay        The day of the month on which the daylight saving time starts.
   *                        See the class description for the special cases of this parameter.
   * @param startDayOfWeek  The daylight saving time starting day-of-week.
   *                        See the class description for the special cases of this parameter.
   * @param startTime       The daylight saving time starting time in local wall clock
   *                        time (in milliseconds within the day), which is local
   *                        standard time in this case.
   * @param endMonth        The daylight saving time ending month. Month is
   *                        a {@link Calendar#MONTH MONTH} field
   *                        value (0-based. e.g., 9 for October).
   * @param endDay          The day of the month on which the daylight saving time ends.
   *                        See the class description for the special cases of this parameter.
   * @param endDayOfWeek    The daylight saving time ending day-of-week.
   *                        See the class description for the special cases of this parameter.
   * @param endTime         The daylight saving ending time in local wall clock time,
   *                        (in milliseconds within the day) which is local daylight
   *                        time in this case.
   * @throws    IllegalArgumentException if the month, day, dayOfWeek, or time
   * parameters are out of range for the start or end rule
  */
  constructor(rawOffset: number, ID: string, startMonth: number, startDay: number, startDayOfWeek: number, startTime: number, endMonth: number, endDay: number, endDayOfWeek: number, endTime: number);
  /**
   * Constructs a SimpleTimeZone with the given base time zone offset from
   * GMT, time zone ID, and rules for starting and ending the daylight
   * time.
   * Both `startTime` and `endTime` are assumed to be
   * represented in the wall clock time. This constructor is equivalent to:
   * 
   *     SimpleTimeZone(rawOffset,
   *                    ID,
   *                    startMonth,
   *                    startDay,
   *                    startDayOfWeek,
   *                    startTime,
   *                    SimpleTimeZone.{@link #WALL_TIME},
   *                    endMonth,
   *                    endDay,
   *                    endDayOfWeek,
   *                    endTime,
   *                    SimpleTimeZone.{@link #WALL_TIME},
   *                    dstSavings)
   * 
   *
   * @param rawOffset       The given base time zone offset from GMT.
   * @param ID              The time zone ID which is given to this object.
   * @param startMonth      The daylight saving time starting month. Month is
   *                        a {@link Calendar#MONTH MONTH} field
   *                        value (0-based. e.g., 0 for January).
   * @param startDay        The day of the month on which the daylight saving time starts.
   *                        See the class description for the special cases of this parameter.
   * @param startDayOfWeek  The daylight saving time starting day-of-week.
   *                        See the class description for the special cases of this parameter.
   * @param startTime       The daylight saving time starting time in local wall clock
   *                        time, which is local standard time in this case.
   * @param endMonth        The daylight saving time ending month. Month is
   *                        a {@link Calendar#MONTH MONTH} field
   *                        value (0-based. e.g., 9 for October).
   * @param endDay          The day of the month on which the daylight saving time ends.
   *                        See the class description for the special cases of this parameter.
   * @param endDayOfWeek    The daylight saving time ending day-of-week.
   *                        See the class description for the special cases of this parameter.
   * @param endTime         The daylight saving ending time in local wall clock time,
   *                        which is local daylight time in this case.
   * @param dstSavings      The amount of time in milliseconds saved during
   *                        daylight saving time.
   * @throws    IllegalArgumentException if the month, day, dayOfWeek, or time
   * parameters are out of range for the start or end rule
   * @since 1.2
  */
  constructor(rawOffset: number, ID: string, startMonth: number, startDay: number, startDayOfWeek: number, startTime: number, endMonth: number, endDay: number, endDayOfWeek: number, endTime: number, dstSavings: number);
  /**
   * Constructs a SimpleTimeZone with the given base time zone offset from
   * GMT, time zone ID, and rules for starting and ending the daylight
   * time.
   * This constructor takes the full set of the start and end rules
   * parameters, including modes of `startTime` and
   * `endTime`. The mode specifies either {@link #WALL_TIME wall
   * time} or {@link #STANDARD_TIME standard time} or {@link #UTC_TIME UTC
   * time}.
   *
   * @param rawOffset       The given base time zone offset from GMT.
   * @param ID              The time zone ID which is given to this object.
   * @param startMonth      The daylight saving time starting month. Month is
   *                        a {@link Calendar#MONTH MONTH} field
   *                        value (0-based. e.g., 0 for January).
   * @param startDay        The day of the month on which the daylight saving time starts.
   *                        See the class description for the special cases of this parameter.
   * @param startDayOfWeek  The daylight saving time starting day-of-week.
   *                        See the class description for the special cases of this parameter.
   * @param startTime       The daylight saving time starting time in the time mode
   *                        specified by `startTimeMode`.
   * @param startTimeMode   The mode of the start time specified by startTime.
   * @param endMonth        The daylight saving time ending month. Month is
   *                        a {@link Calendar#MONTH MONTH} field
   *                        value (0-based. e.g., 9 for October).
   * @param endDay          The day of the month on which the daylight saving time ends.
   *                        See the class description for the special cases of this parameter.
   * @param endDayOfWeek    The daylight saving time ending day-of-week.
   *                        See the class description for the special cases of this parameter.
   * @param endTime         The daylight saving ending time in time mode
   *                        specified by `endTimeMode`.
   * @param endTimeMode     The mode of the end time specified by endTime
   * @param dstSavings      The amount of time in milliseconds saved during
   *                        daylight saving time.
   *
   * @throws    IllegalArgumentException if the month, day, dayOfWeek, time more, or
   * time parameters are out of range for the start or end rule, or if a time mode
   * value is invalid.
   *
   * @see #WALL_TIME
   * @see #STANDARD_TIME
   * @see #UTC_TIME
   *
   * @since 1.4
  */
  constructor(rawOffset: number, ID: string, startMonth: number, startDay: number, startDayOfWeek: number, startTime: number, startTimeMode: number, endMonth: number, endDay: number, endDayOfWeek: number, endTime: number, endTimeMode: number, dstSavings: number);
  /**
   * Sets the daylight saving time starting year.
   *
   * @param year  The daylight saving starting year.
  */
  setStartYear(startYear: number);
  /**
   * Sets the daylight saving time start rule. For example, if daylight saving
   * time starts on the first Sunday in April at 2 am in local wall clock
   * time, you can set the start rule by calling:
   * `setStartRule(Calendar.APRIL, 1, Calendar.SUNDAY, 2*60*60*1000);`
   *
   * @param startMonth      The daylight saving time starting month. Month is
   *                        a {@link Calendar#MONTH MONTH} field
   *                        value (0-based. e.g., 0 for January).
   * @param startDay        The day of the month on which the daylight saving time starts.
   *                        See the class description for the special cases of this parameter.
   * @param startDayOfWeek  The daylight saving time starting day-of-week.
   *                        See the class description for the special cases of this parameter.
   * @param startTime       The daylight saving time starting time in local wall clock
   *                        time, which is local standard time in this case.
   * @throws    IllegalArgumentException if the `startMonth`, `startDay`,
   * `startDayOfWeek`, or `startTime` parameters are out of range
  */
  setStartRule(startMonth: number, startDay: number, startDayOfWeek: number, startTime: number): void;
  /**
   * Sets the daylight saving time start rule to a fixed date within a month.
   * This method is equivalent to:
   * `setStartRule(startMonth, startDay, 0, startTime)`
   *
   * @param startMonth      The daylight saving time starting month. Month is
   *                        a {@link Calendar#MONTH MONTH} field
   *                        value (0-based. e.g., 0 for January).
   * @param startDay        The day of the month on which the daylight saving time starts.
   * @param startTime       The daylight saving time starting time in local wall clock
   *                        time, which is local standard time in this case.
   *                        See the class description for the special cases of this parameter.
   * @throws    IllegalArgumentException if the `startMonth`,
   * `startDayOfMonth`, or `startTime` parameters are out of range
   * @since 1.2
  */
  setStartRule(startMonth: number, startDay: number, startTime: number): void;
  /**
   * Sets the daylight saving time start rule to a weekday before or after the given date within
   * a month, e.g., the first Monday on or after the 8th.
   *
   * @param startMonth      The daylight saving time starting month. Month is
   *                        a {@link Calendar#MONTH MONTH} field
   *                        value (0-based. e.g., 0 for January).
   * @param startDay        The day of the month on which the daylight saving time starts.
   * @param startDayOfWeek  The daylight saving time starting day-of-week.
   * @param startTime       The daylight saving time starting time in local wall clock
   *                        time, which is local standard time in this case.
   * @param after           If true, this rule selects the first `dayOfWeek` on or
   *                        after `dayOfMonth`.  If false, this rule
   *                        selects the last `dayOfWeek` on or before
   *                        `dayOfMonth`.
   * @throws    IllegalArgumentException if the `startMonth`, `startDay`,
   * `startDayOfWeek`, or `startTime` parameters are out of range
   * @since 1.2
  */
  setStartRule(startMonth: number, startDay: number, startDayOfWeek: number, startTime: number, after: boolean): void;
  /**
   * Sets the daylight saving time end rule. For example, if daylight saving time
   * ends on the last Sunday in October at 2 am in wall clock time,
   * you can set the end rule by calling:
   * `setEndRule(Calendar.OCTOBER, -1, Calendar.SUNDAY, 2*60*60*1000);`
   *
   * @param endMonth        The daylight saving time ending month. Month is
   *                        a {@link Calendar#MONTH MONTH} field
   *                        value (0-based. e.g., 9 for October).
   * @param endDay          The day of the month on which the daylight saving time ends.
   *                        See the class description for the special cases of this parameter.
   * @param endDayOfWeek    The daylight saving time ending day-of-week.
   *                        See the class description for the special cases of this parameter.
   * @param endTime         The daylight saving ending time in local wall clock time,
   *                        (in milliseconds within the day) which is local daylight
   *                        time in this case.
   * @throws    IllegalArgumentException if the `endMonth`, `endDay`,
   * `endDayOfWeek`, or `endTime` parameters are out of range
  */
  setEndRule(endMonth: number, endDay: number, endDayOfWeek: number, endTime: number): void;
  /**
   * Sets the daylight saving time end rule to a fixed date within a month.
   * This method is equivalent to:
   * `setEndRule(endMonth, endDay, 0, endTime)`
   *
   * @param endMonth        The daylight saving time ending month. Month is
   *                        a {@link Calendar#MONTH MONTH} field
   *                        value (0-based. e.g., 9 for October).
   * @param endDay          The day of the month on which the daylight saving time ends.
   * @param endTime         The daylight saving ending time in local wall clock time,
   *                        (in milliseconds within the day) which is local daylight
   *                        time in this case.
   * @throws    IllegalArgumentException the `endMonth`, `endDay`,
   * or `endTime` parameters are out of range
   * @since 1.2
  */
  setEndRule(endMonth: number, endDay: number, endTime: number): void;
  /**
   * Sets the daylight saving time end rule to a weekday before or after the given date within
   * a month, e.g., the first Monday on or after the 8th.
   *
   * @param endMonth        The daylight saving time ending month. Month is
   *                        a {@link Calendar#MONTH MONTH} field
   *                        value (0-based. e.g., 9 for October).
   * @param endDay          The day of the month on which the daylight saving time ends.
   * @param endDayOfWeek    The daylight saving time ending day-of-week.
   * @param endTime         The daylight saving ending time in local wall clock time,
   *                        (in milliseconds within the day) which is local daylight
   *                        time in this case.
   * @param after           If true, this rule selects the first `endDayOfWeek` on
   *                        or after `endDay`.  If false, this rule
   *                        selects the last `endDayOfWeek` on or before
   *                        `endDay` of the month.
   * @throws    IllegalArgumentException the `endMonth`, `endDay`,
   * `endDayOfWeek`, or `endTime` parameters are out of range
   * @since 1.2
  */
  setEndRule(endMonth: number, endDay: number, endDayOfWeek: number, endTime: number, after: boolean): void;
  /**
   * Returns the offset of this time zone from UTC at the given
   * time. If daylight saving time is in effect at the given time,
   * the offset value is adjusted with the amount of daylight
   * saving.
   *
   * @param date the time at which the time zone offset is found
   * @return the amount of time in milliseconds to add to UTC to get
   * local time.
   * @since 1.4
  */
  getOffset(date: number): number;
  /**
   * Returns the difference in milliseconds between local time and
   * UTC, taking into account both the raw offset and the effect of
   * daylight saving, for the specified date and time.  This method
   * assumes that the start and end month are distinct.  It also
   * uses a default {@link GregorianCalendar} object as its
   * underlying calendar, such as for determining leap years.  Do
   * not use the result of this method with a calendar other than a
   * default `GregorianCalendar`.
   *
   * Note:  In general, clients should use
   * `Calendar.get(ZONE_OFFSET) + Calendar.get(DST_OFFSET)`
   * instead of calling this method.
   *
   * @param era       The era of the given date.
   * @param year      The year in the given date.
   * @param month     The month in the given date. Month is 0-based. e.g.,
   *                  0 for January.
   * @param day       The day-in-month of the given date.
   * @param dayOfWeek The day-of-week of the given date.
   * @param millis    The milliseconds in day in standard local time.
   * @return          The milliseconds to add to UTC to get local time.
   * @throws          IllegalArgumentException the `era`,
   *                  `month`, `day`, `dayOfWeek`,
   *                  or `millis` parameters are out of range
  */
  getOffset(era: number, year: number, month: number, day: number, dayOfWeek: number, millis: number): number;
  /**
   * Gets the GMT offset for this time zone.
   * @return the GMT offset value in milliseconds
   * @see #setRawOffset
  */
  getRawOffset(): number;
  /**
   * Sets the base time zone offset to GMT.
   * This is the offset to add to UTC to get local time.
   * @see #getRawOffset
  */
  setRawOffset(rawOffset: number);
  /**
   * Sets the amount of time in milliseconds that the clock is advanced
   * during daylight saving time.
   * @param millisSavedDuringDST the number of milliseconds the time is
   * advanced with respect to standard time when the daylight saving time rules
   * are in effect. A positive number, typically one hour (3600000).
   * @see #getDSTSavings
   * @since 1.2
  */
  setDSTSavings(dSTSavings: number);
  /**
   * Returns the amount of time in milliseconds that the clock is
   * advanced during daylight saving time.
   *
   * @return the number of milliseconds the time is advanced with
   * respect to standard time when the daylight saving rules are in
   * effect, or 0 (zero) if this time zone doesn't observe daylight
   * saving time.
   *
   * @see #setDSTSavings
   * @since 1.2
  */
  getDSTSavings(): number;
  /**
   * Queries if this time zone uses daylight saving time.
   * @return true if this time zone uses daylight saving time;
   * false otherwise.
  */
  useDaylightTime(): boolean;
  /**
   * Returns `true` if this `SimpleTimeZone` observes
   * Daylight Saving Time. This method is equivalent to {@link
   * #useDaylightTime()}.
   *
   * @return `true` if this `SimpleTimeZone` observes
   * Daylight Saving Time; `false` otherwise.
   * @since 1.7
  */
  observesDaylightTime(): boolean;
  /**
   * Queries if the given date is in daylight saving time.
   * @return true if daylight saving time is in effective at the
   * given date; false otherwise.
  */
  inDaylightTime(date: Date): boolean;
  /**
   * Returns a clone of this `SimpleTimeZone` instance.
   * @return a clone of this instance.
  */
  clone(): any;
  /**
   * Generates the hash code for the SimpleDateFormat object.
   * @return the hash code for this object
  */
  hashCode(): number;
  /**
   * Compares the equality of two `SimpleTimeZone` objects.
   *
   * @param obj  The `SimpleTimeZone` object to be compared with.
   * @return     True if the given `obj` is the same as this
   *             `SimpleTimeZone` object; false otherwise.
  */
  equals(obj: any): boolean;
  /**
   * Returns `true` if this zone has the same rules and offset as another zone.
   * @param other the TimeZone object to be compared with
   * @return `true` if the given zone is a SimpleTimeZone and has the
   * same rules and offset as this one
   * @since 1.2
  */
  hasSameRules(other: TimeZone): boolean;
  /**
   * Returns a string representation of this time zone.
   * @return a string representation of this time zone.
  */
  toString(): string;
  static readonly WALL_TIME: number;
  /**
   * Constant for a mode of start or end time specified as standard time.
   * @since 1.4
  */
  static readonly STANDARD_TIME: number;
  /**
   * Constant for a mode of start or end time specified as UTC. European
   * Union rules are specified as UTC time, for example.
   * @since 1.4
  */
  static readonly UTC_TIME: number;
}
/**
 * A container object which may or may not contain a `double` value.
 * If a value is present, `isPresent()` returns `true`. If no
 * value is present, the object is considered empty and
 * `isPresent()` returns `false`.
 *
 * Additional methods that depend on the presence or absence of a contained
 * value are provided, such as {@link #orElse(double) orElse()}
 * (returns a default value if no value is present) and
 * {@link #ifPresent(DoubleConsumer) ifPresent()} (performs
 * an action if a value is present).
 *
 * This is a value-based
 * class; programmers should treat instances that are
 * {@linkplain #equals(Object) equal} as interchangeable and should not
 * use instances for synchronization, or unpredictable behavior may
 * occur. For example, in a future release, synchronization may fail.
 *
 * @apiNote
 * `OptionalDouble` is primarily intended for use as a method return type where
 * there is a clear need to represent "no result." A variable whose type is
 * `OptionalDouble` should never itself be `null`; it should always point
 * to an `OptionalDouble` instance.
 *
 * @since 1.8
*/
export class OptionalDouble {
  /**
   * Returns an empty `OptionalDouble` instance.  No value is present
   * for this `OptionalDouble`.
   *
   * @apiNote
   * Though it may be tempting to do so, avoid testing if an object is empty
   * by comparing with `==` or `!=` against instances returned by
   * `OptionalDouble.empty()`.  There is no guarantee that it is a singleton.
   * Instead, use {@link #isEmpty()} or {@link #isPresent()}.
   *
   *  @return an empty `OptionalDouble`.
  */
  static empty(): OptionalDouble;
  /**
   * Returns an `OptionalDouble` describing the given value.
   *
   * @param value the value to describe
   * @return an `OptionalDouble` with the value present
  */
  static of(value: number): OptionalDouble;
  /**
   * If a value is present, returns the value, otherwise throws
   * `NoSuchElementException`.
   *
   * @apiNote
   * The preferred alternative to this method is {@link #orElseThrow()}.
   *
   * @return the value described by this `OptionalDouble`
   * @throws NoSuchElementException if no value is present
  */
  getAsDouble(): number;
  /**
   * If a value is present, returns `true`, otherwise `false`.
   *
   * @return `true` if a value is present, otherwise `false`
  */
  isPresent(): boolean;
  /**
   * If a value is not present, returns `true`, otherwise
   * `false`.
   *
   * @return  `true` if a value is not present, otherwise `false`
   * @since   11
  */
  isEmpty(): boolean;
  /**
   * If a value is present, performs the given action with the value,
   * otherwise does nothing.
   *
   * @param action the action to be performed, if a value is present
   * @throws NullPointerException if value is present and the given action is
   *         `null`
  */
  ifPresent(action: DoubleConsumer): void;
  /**
   * If a value is present, performs the given action with the value,
   * otherwise performs the given empty-based action.
   *
   * @param action the action to be performed, if a value is present
   * @param emptyAction the empty-based action to be performed, if no value is
   * present
   * @throws NullPointerException if a value is present and the given action
   *         is `null`, or no value is present and the given empty-based
   *         action is `null`.
   * @since 9
  */
  ifPresentOrElse(action: DoubleConsumer, emptyAction: Runnable): void;
  /**
   * If a value is present, returns a sequential {@link DoubleStream}
   * containing only that value, otherwise returns an empty
   * `DoubleStream`.
   *
   * @apiNote
   * This method can be used to transform a `Stream` of optional doubles
   * to a `DoubleStream` of present doubles:
   * {@code
   *     Stream os = ..
   *     DoubleStream s = os.flatMapToDouble(OptionalDouble::stream)
   * }
   *
   * @return the optional value as a `DoubleStream`
   * @since 9
  */
  stream(): DoubleStream;
  /**
   * If a value is present, returns the value, otherwise returns
   * `other`.
   *
   * @param other the value to be returned, if no value is present
   * @return the value, if present, otherwise `other`
  */
  orElse(other: number): number;
  /**
   * If a value is present, returns the value, otherwise returns the result
   * produced by the supplying function.
   *
   * @param supplier the supplying function that produces a value to be returned
   * @return the value, if present, otherwise the result produced by the
   *         supplying function
   * @throws NullPointerException if no value is present and the supplying
   *         function is `null`
  */
  orElseGet(supplier: DoubleSupplier): number;
  /**
   * If a value is present, returns the value, otherwise throws
   * `NoSuchElementException`.
   *
   * @return the value described by this `OptionalDouble`
   * @throws NoSuchElementException if no value is present
   * @since 10
  */
  orElseThrow(): number;
  /**
   * If a value is present, returns the value, otherwise throws an exception
   * produced by the exception supplying function.
   *
   * @apiNote
   * A method reference to the exception constructor with an empty argument
   * list can be used as the supplier. For example,
   * `IllegalStateException::new`
   *
   * @param  Type of the exception to be thrown
   * @param exceptionSupplier the supplying function that produces an
   *        exception to be thrown
   * @return the value, if present
   * @throws X if no value is present
   * @throws NullPointerException if no value is present and the exception
   *         supplying function is `null`
  */
  orElseThrow<X>(exceptionSupplier: Supplier<X>): number;
  /**
   * Indicates whether some other object is "equal to" this
   * `OptionalDouble`. The other object is considered equal if:
   * 
   * it is also an `OptionalDouble` and;
   * both instances have no value present or;
   * the present values are "equal to" each other via
   * `Double.compare() == 0`.
   * 
   *
   * @param obj an object to be tested for equality
   * @return `true` if the other object is "equal to" this object
   *         otherwise `false`
  */
  equals(obj: any): boolean;
  /**
   * Returns the hash code of the value, if present, otherwise `0`
   * (zero) if no value is present.
   *
   * @return hash code value of the present value or `0` if no value is
   *         present
  */
  hashCode(): number;
  /**
   * Returns a non-empty string representation of this `OptionalDouble`
   * suitable for debugging.  The exact presentation format is unspecified and
   * may vary between implementations and versions.
   *
   * @implSpec
   * If a value is present the result must include its string representation
   * in the result.  Empty and present `OptionalDouble`s must be
   * unambiguously differentiable.
   *
   * @return the string representation of this instance
  */
  toString(): string;
}
/**
 * Thrown by various accessor methods to indicate that the element being requested
 * does not exist.
 *
 * @see     java.util.Enumeration#nextElement()
 * @see     java.util.Iterator#next()
 * @since   1.0
*/
export class NoSuchElementException extends RuntimeException {
  /**
   * Constructs a `NoSuchElementException` with `null`
   * as its error message string.
  */
  constructor();
  /**
   * Constructs a `NoSuchElementException` with the specified detail
   * message and cause.
   *
   * @param s     the detail message, or null
   * @param cause the cause (which is saved for later retrieval by the
   *              {@link #getCause()} method), or null
   * @since 15
  */
  constructor(s: string, cause: Throwable);
  /**
   * Constructs a `NoSuchElementException` with the specified cause.
   * The detail message is set to {@code (cause == null ? null :
   * cause.toString())} (which typically contains the class and
   * detail message of `cause`).
   *
   * @param cause the cause (which is saved for later retrieval by the
   *              {@link #getCause()} method)
   * @since 15
  */
  constructor(cause: Throwable);
  /**
   * Constructs a `NoSuchElementException`, saving a reference
   * to the error message string `s` for later retrieval by the
   * `getMessage` method.
   *
   * @param   s   the detail message.
  */
  constructor(s: string);
}
/**
 * Unchecked exception thrown when an unknown conversion is given.
 *
 *  Unless otherwise specified, passing a `null` argument to
 * any method or constructor in this class will cause a {@link
 * NullPointerException} to be thrown.
 *
 * @since 1.5
*/
export class UnknownFormatConversionException extends IllegalFormatException {
  /**
   * Constructs an instance of this class with the unknown conversion.
   *
   * @param  s
   *         Unknown conversion
  */
  constructor(s: string);
  /**
   * Returns the unknown conversion.
   *
   * @return  The unknown conversion.
  */
  getConversion(): string;
  getMessage(): string;
}
/**
 * Unchecked exception thrown when a character with an invalid Unicode code
 * point as defined by {@link Character#isValidCodePoint} is passed to the
 * {@link Formatter}.
 *
 *  Unless otherwise specified, passing a `null` argument to any
 * method or constructor in this class will cause a {@link
 * NullPointerException} to be thrown.
 *
 * @since 1.5
*/
export class IllegalFormatCodePointException extends IllegalFormatException {
  /**
   * Constructs an instance of this class with the specified illegal code
   * point as defined by {@link Character#isValidCodePoint}.
   *
   * @param  c
   *         The illegal Unicode code point
  */
  constructor(c: number);
  /**
   * Returns the illegal code point as defined by {@link
   * Character#isValidCodePoint}.
   *
   * @return  The illegal Unicode code point
  */
  getCodePoint(): number;
  getMessage(): string;
}
/**
 * `StringJoiner` is used to construct a sequence of characters separated
 * by a delimiter and optionally starting with a supplied prefix
 * and ending with a supplied suffix.
 * 
 * Prior to adding something to the `StringJoiner`, its
 * `sj.toString()` method will, by default, return `prefix + suffix`.
 * However, if the `setEmptyValue` method is called, the `emptyValue`
 * supplied will be returned instead. This can be used, for example, when
 * creating a string using set notation to indicate an empty set, i.e.
 * "{}", where the `prefix` is "{", the
 * `suffix` is "}" and nothing has been added to the
 * `StringJoiner`.
 *
 * @apiNote
 * The String `"[George:Sally:Fred]"` may be constructed as follows:
 *
 *  {@code
 * StringJoiner sj = new StringJoiner(":", "[", "]");
 * sj.add("George").add("Sally").add("Fred");
 * String desiredString = sj.toString();
 * }
 * 
 * A `StringJoiner` may be employed to create formatted output from a
 * {@link java.util.stream.Stream} using
 * {@link java.util.stream.Collectors#joining(CharSequence)}. For example:
 *
 *  {@code
 * List numbers = Arrays.asList(1, 2, 3, 4);
 * String commaSeparatedNumbers = numbers.stream()
 *     .map(i -> i.toString())
 *     .collect(Collectors.joining(", "));
 * }
 *
 * @see java.util.stream.Collectors#joining(CharSequence)
 * @see java.util.stream.Collectors#joining(CharSequence, CharSequence, CharSequence)
 * @since  1.8
*/
export class StringJoiner {
  /**
   * Constructs a `StringJoiner` with no characters in it, with no
   * `prefix` or `suffix`, and a copy of the supplied
   * `delimiter`.
   * If no characters are added to the `StringJoiner` and methods
   * accessing the value of it are invoked, it will not return a
   * `prefix` or `suffix` (or properties thereof) in the result,
   * unless `setEmptyValue` has first been called.
   *
   * @param  delimiter the sequence of characters to be used between each
   *         element added to the `StringJoiner` value
   * @throws NullPointerException if `delimiter` is `null`
  */
  constructor(delimiter: CharSequence);
  /**
   * Constructs a `StringJoiner` with no characters in it using copies
   * of the supplied `prefix`, `delimiter` and `suffix`.
   * If no characters are added to the `StringJoiner` and methods
   * accessing the string value of it are invoked, it will return the
   * `prefix + suffix` (or properties thereof) in the result, unless
   * `setEmptyValue` has first been called.
   *
   * @param  delimiter the sequence of characters to be used between each
   *         element added to the `StringJoiner`
   * @param  prefix the sequence of characters to be used at the beginning
   * @param  suffix the sequence of characters to be used at the end
   * @throws NullPointerException if `prefix`, `delimiter`, or
   *         `suffix` is `null`
  */
  constructor(delimiter: CharSequence, prefix: CharSequence, suffix: CharSequence);
  /**
   * Sets the sequence of characters to be used when determining the string
   * representation of this `StringJoiner` and no elements have been
   * added yet, that is, when it is empty.  A copy of the `emptyValue`
   * parameter is made for this purpose. Note that once an add method has been
   * called, the `StringJoiner` is no longer considered empty, even if
   * the element(s) added correspond to the empty `String`.
   *
   * @param  emptyValue the characters to return as the value of an empty
   *         `StringJoiner`
   * @return this `StringJoiner` itself so the calls may be chained
   * @throws NullPointerException when the `emptyValue` parameter is
   *         `null`
  */
  setEmptyValue(emptyValue: CharSequence);
  /**
   * Returns the current value, consisting of the `prefix`, the values
   * added so far separated by the `delimiter`, and the `suffix`,
   * unless no elements have been added in which case, the
   * `prefix + suffix` or the `emptyValue` characters are returned.
   *
   * @return the string representation of this `StringJoiner`
  */
  toString(): string;
  /**
   * Adds a copy of the given `CharSequence` value as the next
   * element of the `StringJoiner` value. If `newElement` is
   * `null`, then `"null"` is added.
   *
   * @param  newElement The element to add
   * @return a reference to this `StringJoiner`
  */
  add(newElement: CharSequence): StringJoiner;
  /**
   * Adds the contents of the given `StringJoiner` without prefix and
   * suffix as the next element if it is non-empty. If the given `     * StringJoiner` is empty, the call has no effect.
   *
   * A `StringJoiner` is empty if {@link #add(CharSequence) add()}
   * has never been called, and if `merge()` has never been called
   * with a non-empty `StringJoiner` argument.
   *
   * If the other `StringJoiner` is using a different delimiter,
   * then elements from the other `StringJoiner` are concatenated with
   * that delimiter and the result is appended to this `StringJoiner`
   * as a single element.
   *
   * @param other The `StringJoiner` whose contents should be merged
   *              into this one
   * @throws NullPointerException if the other `StringJoiner` is null
   * @return This `StringJoiner`
  */
  merge(other: StringJoiner): StringJoiner;
  /**
   * Returns the length of the `String` representation
   * of this `StringJoiner`. Note that if
   * no add methods have been called, then the length of the `String`
   * representation (either `prefix + suffix` or `emptyValue`)
   * will be returned. The value should be equivalent to
   * `toString().length()`.
   *
   * @return the length of the current value of `StringJoiner`
  */
  length(): number;
}
/**
 * A state object for collecting statistics such as count, min, max, sum, and
 * average.
 *
 * This class is designed to work with (though does not require)
 * {@linkplain java.util.stream streams}. For example, you can compute
 * summary statistics on a stream of ints with:
 *  {@code
 * IntSummaryStatistics stats = intStream.collect(IntSummaryStatistics::new,
 *                                                IntSummaryStatistics::accept,
 *                                                IntSummaryStatistics::combine);
 * }
 *
 * `IntSummaryStatistics` can be used as a
 * {@linkplain java.util.stream.Stream#collect(Collector) reduction}
 * target for a {@linkplain java.util.stream.Stream stream}. For example:
 *
 *  {@code
 * IntSummaryStatistics stats = people.stream()
 *                                    .collect(Collectors.summarizingInt(Person::getDependents));
 *}
 *
 * This computes, in a single pass, the count of people, as well as the minimum,
 * maximum, sum, and average of their number of dependents.
 *
 * @implNote This implementation is not thread safe. However, it is safe to use
 * {@link java.util.stream.Collectors#summarizingInt(java.util.function.ToIntFunction)
 * Collectors.summarizingInt()} on a parallel stream, because the parallel
 * implementation of {@link java.util.stream.Stream#collect Stream.collect()}
 * provides the necessary partitioning, isolation, and merging of results for
 * safe and efficient parallel execution.
 *
 * This implementation does not check for overflow of the count or the sum.
 * @since 1.8
*/
export class IntSummaryStatistics extends IntConsumer {
  /**
   * Constructs an empty instance with zero count, zero sum,
   * `Integer.MAX_VALUE` min, `Integer.MIN_VALUE` max and zero
   * average.
  */
  constructor();
  /**
   * Constructs a non-empty instance with the specified `count`,
   * `min`, `max`, and `sum`.
   *
   * If `count` is zero then the remaining arguments are ignored and
   * an empty instance is constructed.
   *
   * If the arguments are inconsistent then an `IllegalArgumentException`
   * is thrown.  The necessary consistent argument conditions are:
   * 
   *   `count >= 0`
   *   `min <= max`
   * 
   * @apiNote
   * The enforcement of argument correctness means that the retrieved set of
   * recorded values obtained from a `IntSummaryStatistics` source
   * instance may not be a legal set of arguments for this constructor due to
   * arithmetic overflow of the source's recorded count of values.
   * The consistent argument conditions are not sufficient to prevent the
   * creation of an internally inconsistent instance.  An example of such a
   * state would be an instance with: `count` = 2, `min` = 1,
   * `max` = 2, and `sum` = 0.
   *
   * @param count the count of values
   * @param min the minimum value
   * @param max the maximum value
   * @param sum the sum of all values
   * @throws IllegalArgumentException if the arguments are inconsistent
   * @since 10
  */
  constructor(count: number, min: number, max: number, sum: number);
  /**
   * Records a new value into the summary information
   *
   * @param value the input value
  */
  accept(value: number): void;
  /**
   * Combines the state of another `IntSummaryStatistics` into this one.
   *
   * @param other another `IntSummaryStatistics`
   * @throws NullPointerException if `other` is null
  */
  combine(other: IntSummaryStatistics): void;
  /**
   * Returns the count of values recorded.
   *
   * @return the count of values
  */
  getCount(): number;
  /**
   * Returns the sum of values recorded, or zero if no values have been
   * recorded.
   *
   * @return the sum of values, or zero if none
  */
  getSum(): number;
  /**
   * Returns the minimum value recorded, or `Integer.MAX_VALUE` if no
   * values have been recorded.
   *
   * @return the minimum value, or `Integer.MAX_VALUE` if none
  */
  getMin(): number;
  /**
   * Returns the maximum value recorded, or `Integer.MIN_VALUE` if no
   * values have been recorded.
   *
   * @return the maximum value, or `Integer.MIN_VALUE` if none
  */
  getMax(): number;
  /**
   * Returns the arithmetic mean of values recorded, or zero if no values have been
   * recorded.
   *
   * @return the arithmetic mean of values, or zero if none
  */
  getAverage(): number;
  /**
   * Returns a non-empty string representation of this object suitable for
   * debugging. The exact presentation format is unspecified and may vary
   * between implementations and versions.
  */
  toString(): string;
}
/**
 * This class implements a vector of bits that grows as needed. Each
 * component of the bit set has a `boolean` value. The
 * bits of a `BitSet` are indexed by nonnegative integers.
 * Individual indexed bits can be examined, set, or cleared. One
 * `BitSet` may be used to modify the contents of another
 * `BitSet` through logical AND, logical inclusive OR, and
 * logical exclusive OR operations.
 *
 * By default, all bits in the set initially have the value
 * `false`.
 *
 * Every bit set has a current size, which is the number of bits
 * of space currently in use by the bit set. Note that the size is
 * related to the implementation of a bit set, so it may change with
 * implementation. The length of a bit set relates to logical length
 * of a bit set and is defined independently of implementation.
 *
 * Unless otherwise noted, passing a null parameter to any of the
 * methods in a `BitSet` will result in a
 * `NullPointerException`.
 *
 * A `BitSet` is not safe for multithreaded use without
 * external synchronization.
 *
 * @author  Arthur van Hoff
 * @author  Michael McCloskey
 * @author  Martin Buchholz
 * @since   1.0
*/
export class BitSet extends Cloneable {
  /**
   * Creates a new bit set. All bits are initially `false`.
  */
  constructor();
  /**
   * Creates a bit set whose initial size is large enough to explicitly
   * represent bits with indices in the range `0` through
   * `nbits-1`. All bits are initially `false`.
   *
   * @param  nbits the initial size of the bit set
   * @throws NegativeArraySizeException if the specified initial size
   *         is negative
  */
  constructor(nbits: number);
  /**
   * Returns a new bit set containing all the bits in the given long array.
   *
   * More precisely,
   * `BitSet.valueOf(longs).get(n) == ((longs[n/64] & (1L<<(n%64))) != 0)`
   * for all `n < 64 * longs.length`.
   *
   * This method is equivalent to
   * `BitSet.valueOf(LongBuffer.wrap(longs))`.
   *
   * @param longs a long array containing a little-endian representation
   *        of a sequence of bits to be used as the initial bits of the
   *        new bit set
   * @return a `BitSet` containing all the bits in the long array
   * @since 1.7
  */
  static valueOf(longs: number[]): BitSet;
  /**
   * Returns a new bit set containing all the bits in the given long
   * buffer between its position and limit.
   *
   * More precisely,
   * `BitSet.valueOf(lb).get(n) == ((lb.get(lb.position()+n/64) & (1L<<(n%64))) != 0)`
   * for all `n < 64 * lb.remaining()`.
   *
   * The long buffer is not modified by this method, and no
   * reference to the buffer is retained by the bit set.
   *
   * @param lb a long buffer containing a little-endian representation
   *        of a sequence of bits between its position and limit, to be
   *        used as the initial bits of the new bit set
   * @return a `BitSet` containing all the bits in the buffer in the
   *         specified range
   * @since 1.7
  */
  static valueOf(lb: LongBuffer): BitSet;
  /**
   * Returns a new bit set containing all the bits in the given byte array.
   *
   * More precisely,
   * `BitSet.valueOf(bytes).get(n) == ((bytes[n/8] & (1<<(n%8))) != 0)`
   * for all `n <  8 * bytes.length`.
   *
   * This method is equivalent to
   * `BitSet.valueOf(ByteBuffer.wrap(bytes))`.
   *
   * @param bytes a byte array containing a little-endian
   *        representation of a sequence of bits to be used as the
   *        initial bits of the new bit set
   * @return a `BitSet` containing all the bits in the byte array
   * @since 1.7
  */
  static valueOf(bytes: number[]): BitSet;
  /**
   * Returns a new bit set containing all the bits in the given byte
   * buffer between its position and limit.
   *
   * More precisely,
   * `BitSet.valueOf(bb).get(n) == ((bb.get(bb.position()+n/8) & (1<<(n%8))) != 0)`
   * for all `n < 8 * bb.remaining()`.
   *
   * The byte buffer is not modified by this method, and no
   * reference to the buffer is retained by the bit set.
   *
   * @param bb a byte buffer containing a little-endian representation
   *        of a sequence of bits between its position and limit, to be
   *        used as the initial bits of the new bit set
   * @return a `BitSet` containing all the bits in the buffer in the
   *         specified range
   * @since 1.7
  */
  static valueOf(bb: ByteBuffer): BitSet;
  /**
   * Returns a new byte array containing all the bits in this bit set.
   *
   * More precisely, if
   * `byte[] bytes = s.toByteArray();`
   * then `bytes.length == (s.length()+7)/8` and
   * `s.get(n) == ((bytes[n/8] & (1<<(n%8))) != 0)`
   * for all `n < 8 * bytes.length`.
   *
   * @return a byte array containing a little-endian representation
   *         of all the bits in this bit set
   * @since 1.7
  */
  toByteArray(): number[];
  /**
   * Returns a new long array containing all the bits in this bit set.
   *
   * More precisely, if
   * `long[] longs = s.toLongArray();`
   * then `longs.length == (s.length()+63)/64` and
   * `s.get(n) == ((longs[n/64] & (1L<<(n%64))) != 0)`
   * for all `n < 64 * longs.length`.
   *
   * @return a long array containing a little-endian representation
   *         of all the bits in this bit set
   * @since 1.7
  */
  toLongArray(): number[];
  /**
   * Sets the bit at the specified index to the complement of its
   * current value.
   *
   * @param  bitIndex the index of the bit to flip
   * @throws IndexOutOfBoundsException if the specified index is negative
   * @since  1.4
  */
  flip(bitIndex: number): void;
  /**
   * Sets each bit from the specified `fromIndex` (inclusive) to the
   * specified `toIndex` (exclusive) to the complement of its current
   * value.
   *
   * @param  fromIndex index of the first bit to flip
   * @param  toIndex index after the last bit to flip
   * @throws IndexOutOfBoundsException if `fromIndex` is negative,
   *         or `toIndex` is negative, or `fromIndex` is
   *         larger than `toIndex`
   * @since  1.4
  */
  flip(fromIndex: number, toIndex: number): void;
  /**
   * Sets the bit at the specified index to `true`.
   *
   * @param  bitIndex a bit index
   * @throws IndexOutOfBoundsException if the specified index is negative
   * @since  1.0
  */
  set(bitIndex: number): void;
  /**
   * Sets the bit at the specified index to the specified value.
   *
   * @param  bitIndex a bit index
   * @param  value a boolean value to set
   * @throws IndexOutOfBoundsException if the specified index is negative
   * @since  1.4
  */
  set(bitIndex: number, value: boolean): void;
  /**
   * Sets the bits from the specified `fromIndex` (inclusive) to the
   * specified `toIndex` (exclusive) to `true`.
   *
   * @param  fromIndex index of the first bit to be set
   * @param  toIndex index after the last bit to be set
   * @throws IndexOutOfBoundsException if `fromIndex` is negative,
   *         or `toIndex` is negative, or `fromIndex` is
   *         larger than `toIndex`
   * @since  1.4
  */
  set(fromIndex: number, toIndex: number): void;
  /**
   * Sets the bits from the specified `fromIndex` (inclusive) to the
   * specified `toIndex` (exclusive) to the specified value.
   *
   * @param  fromIndex index of the first bit to be set
   * @param  toIndex index after the last bit to be set
   * @param  value value to set the selected bits to
   * @throws IndexOutOfBoundsException if `fromIndex` is negative,
   *         or `toIndex` is negative, or `fromIndex` is
   *         larger than `toIndex`
   * @since  1.4
  */
  set(fromIndex: number, toIndex: number, value: boolean): void;
  /**
   * Sets the bit specified by the index to `false`.
   *
   * @param  bitIndex the index of the bit to be cleared
   * @throws IndexOutOfBoundsException if the specified index is negative
   * @since  1.0
  */
  clear(bitIndex: number): void;
  /**
   * Sets the bits from the specified `fromIndex` (inclusive) to the
   * specified `toIndex` (exclusive) to `false`.
   *
   * @param  fromIndex index of the first bit to be cleared
   * @param  toIndex index after the last bit to be cleared
   * @throws IndexOutOfBoundsException if `fromIndex` is negative,
   *         or `toIndex` is negative, or `fromIndex` is
   *         larger than `toIndex`
   * @since  1.4
  */
  clear(fromIndex: number, toIndex: number): void;
  /**
   * Sets all of the bits in this BitSet to `false`.
   *
   * @since 1.4
  */
  clear(): void;
  /**
   * Returns the value of the bit with the specified index. The value
   * is `true` if the bit with the index `bitIndex`
   * is currently set in this `BitSet`; otherwise, the result
   * is `false`.
   *
   * @param  bitIndex   the bit index
   * @return the value of the bit with the specified index
   * @throws IndexOutOfBoundsException if the specified index is negative
  */
  get(bitIndex: number): boolean;
  /**
   * Returns a new `BitSet` composed of bits from this `BitSet`
   * from `fromIndex` (inclusive) to `toIndex` (exclusive).
   *
   * @param  fromIndex index of the first bit to include
   * @param  toIndex index after the last bit to include
   * @return a new `BitSet` from a range of this `BitSet`
   * @throws IndexOutOfBoundsException if `fromIndex` is negative,
   *         or `toIndex` is negative, or `fromIndex` is
   *         larger than `toIndex`
   * @since  1.4
  */
  get(fromIndex: number, toIndex: number): BitSet;
  /**
   * Returns the index of the first bit that is set to `true`
   * that occurs on or after the specified starting index. If no such
   * bit exists then `-1` is returned.
   *
   * To iterate over the `true` bits in a `BitSet`,
   * use the following loop:
   *
   *   {@code
   * for (int i = bs.nextSetBit(0); i >= 0; i = bs.nextSetBit(i+1)) {
   *     // operate on index i here
   *     if (i == Integer.MAX_VALUE) {
   *         break; // or (i+1) would overflow
   *     }
   * }}
   *
   * @param  fromIndex the index to start checking from (inclusive)
   * @return the index of the next set bit, or `-1` if there
   *         is no such bit
   * @throws IndexOutOfBoundsException if the specified index is negative
   * @since  1.4
  */
  nextSetBit(fromIndex: number): number;
  /**
   * Returns the index of the first bit that is set to `false`
   * that occurs on or after the specified starting index.
   *
   * @param  fromIndex the index to start checking from (inclusive)
   * @return the index of the next clear bit
   * @throws IndexOutOfBoundsException if the specified index is negative
   * @since  1.4
  */
  nextClearBit(fromIndex: number): number;
  /**
   * Returns the index of the nearest bit that is set to `true`
   * that occurs on or before the specified starting index.
   * If no such bit exists, or if `-1` is given as the
   * starting index, then `-1` is returned.
   *
   * To iterate over the `true` bits in a `BitSet`,
   * use the following loop:
   *
   *   {@code
   * for (int i = bs.length(); (i = bs.previousSetBit(i-1)) >= 0; ) {
   *     // operate on index i here
   * }}
   *
   * @param  fromIndex the index to start checking from (inclusive)
   * @return the index of the previous set bit, or `-1` if there
   *         is no such bit
   * @throws IndexOutOfBoundsException if the specified index is less
   *         than `-1`
   * @since  1.7
  */
  previousSetBit(fromIndex: number): number;
  /**
   * Returns the index of the nearest bit that is set to `false`
   * that occurs on or before the specified starting index.
   * If no such bit exists, or if `-1` is given as the
   * starting index, then `-1` is returned.
   *
   * @param  fromIndex the index to start checking from (inclusive)
   * @return the index of the previous clear bit, or `-1` if there
   *         is no such bit
   * @throws IndexOutOfBoundsException if the specified index is less
   *         than `-1`
   * @since  1.7
  */
  previousClearBit(fromIndex: number): number;
  /**
   * Returns the "logical size" of this `BitSet`: the index of
   * the highest set bit in the `BitSet` plus one. Returns zero
   * if the `BitSet` contains no set bits.
   *
   * @return the logical size of this `BitSet`
   * @since  1.2
  */
  length(): number;
  /**
   * Returns true if this `BitSet` contains no bits that are set
   * to `true`.
   *
   * @return boolean indicating whether this `BitSet` is empty
   * @since  1.4
  */
  isEmpty(): boolean;
  /**
   * Returns true if the specified `BitSet` has any bits set to
   * `true` that are also set to `true` in this `BitSet`.
   *
   * @param  set `BitSet` to intersect with
   * @return boolean indicating whether this `BitSet` intersects
   *         the specified `BitSet`
   * @since  1.4
  */
  intersects(set: BitSet): boolean;
  /**
   * Returns the number of bits set to `true` in this `BitSet`.
   *
   * @return the number of bits set to `true` in this `BitSet`
   * @since  1.4
  */
  cardinality(): number;
  /**
   * Performs a logical AND of this target bit set with the
   * argument bit set. This bit set is modified so that each bit in it
   * has the value `true` if and only if it both initially
   * had the value `true` and the corresponding bit in the
   * bit set argument also had the value `true`.
   *
   * @param set a bit set
  */
  and(set: BitSet): void;
  /**
   * Performs a logical OR of this bit set with the bit set
   * argument. This bit set is modified so that a bit in it has the
   * value `true` if and only if it either already had the
   * value `true` or the corresponding bit in the bit set
   * argument has the value `true`.
   *
   * @param set a bit set
  */
  or(set: BitSet): void;
  /**
   * Performs a logical XOR of this bit set with the bit set
   * argument. This bit set is modified so that a bit in it has the
   * value `true` if and only if one of the following
   * statements holds:
   * 
   * The bit initially has the value `true`, and the
   *     corresponding bit in the argument has the value `false`.
   * The bit initially has the value `false`, and the
   *     corresponding bit in the argument has the value `true`.
   * 
   *
   * @param  set a bit set
  */
  xor(set: BitSet): void;
  /**
   * Clears all of the bits in this `BitSet` whose corresponding
   * bit is set in the specified `BitSet`.
   *
   * @param  set the `BitSet` with which to mask this
   *         `BitSet`
   * @since  1.2
  */
  andNot(set: BitSet): void;
  /**
   * Returns the hash code value for this bit set. The hash code depends
   * only on which bits are set within this `BitSet`.
   *
   * The hash code is defined to be the result of the following
   * calculation:
   *   {@code
   * public int hashCode() {
   *     long h = 1234;
   *     long[] words = toLongArray();
   *     for (int i = words.length; --i >= 0; )
   *         h ^= words[i] * (i + 1);
   *     return (int)((h >> 32) ^ h);
   * }}
   * Note that the hash code changes if the set of bits is altered.
   *
   * @return the hash code value for this bit set
  */
  hashCode(): number;
  /**
   * Returns the number of bits of space actually in use by this
   * `BitSet` to represent bit values.
   * The maximum element in the set is the size - 1st element.
   *
   * @return the number of bits currently in this bit set
  */
  size(): number;
  /**
   * Compares this object against the specified object.
   * The result is `true` if and only if the argument is
   * not `null` and is a `BitSet` object that has
   * exactly the same set of bits set to `true` as this bit
   * set. That is, for every nonnegative `int` index `k`,
   * ((BitSet)obj).get(k) == this.get(k)
   * must be true. The current sizes of the two bit sets are not compared.
   *
   * @param  obj the object to compare with
   * @return `true` if the objects are the same;
   *         `false` otherwise
   * @see    #size()
  */
  equals(obj: any): boolean;
  /**
   * Cloning this `BitSet` produces a new `BitSet`
   * that is equal to it.
   * The clone of the bit set is another bit set that has exactly the
   * same bits set to `true` as this bit set.
   *
   * @return a clone of this bit set
   * @see    #size()
  */
  clone(): any;
  /**
   * Returns a string representation of this bit set. For every index
   * for which this `BitSet` contains a bit in the set
   * state, the decimal representation of that index is included in
   * the result. Such indices are listed in order from lowest to
   * highest, separated by ", " (a comma and a space) and
   * surrounded by braces, resulting in the usual mathematical
   * notation for a set of integers.
   *
   * Example:
   *      * BitSet drPepper = new BitSet();
   * Now `drPepper.toString()` returns "`{`}".
   *      * drPepper.set(2);
   * Now `drPepper.toString()` returns "`{2`}".
   *      * drPepper.set(4);
   * drPepper.set(10);
   * Now `drPepper.toString()` returns "`{2, 4, 10`}".
   *
   * @return a string representation of this bit set
  */
  toString(): string;
  /**
   * Returns a stream of indices for which this `BitSet`
   * contains a bit in the set state. The indices are returned
   * in order, from lowest to highest. The size of the stream
   * is the number of bits in the set state, equal to the value
   * returned by the {@link #cardinality()} method.
   *
   * The stream binds to this bit set when the terminal stream operation
   * commences (specifically, the spliterator for the stream is
   * late-binding).  If the
   * bit set is modified during that operation then the result is undefined.
   *
   * @return a stream of integers representing set indices
   * @since 1.8
  */
  stream(): IntStream;
}
export interface BitSet extends Cloneable, Serializable {}
/**
 * This class contains various methods for manipulating arrays (such as
 * sorting and searching). This class also contains a static factory
 * that allows arrays to be viewed as lists.
 *
 * The methods in this class all throw a `NullPointerException`,
 * if the specified array reference is null, except where noted.
 *
 * The documentation for the methods contained in this class includes
 * brief descriptions of the implementations. Such descriptions should
 * be regarded as implementation notes, rather than parts of the
 * specification. Implementors should feel free to substitute other
 * algorithms, so long as the specification itself is adhered to. (For
 * example, the algorithm used by `sort(Object[])` does not have to be
 * a MergeSort, but it does have to be stable.)
 *
 * This class is a member of the
 * 
 * Java Collections Framework.
 *
 * @author Josh Bloch
 * @author Neal Gafter
 * @author John Rose
 * @since  1.2
*/
export class Arrays {
  /**
   * Sorts the specified array into ascending numerical order.
   *
   * @implNote The sorting algorithm is a Dual-Pivot Quicksort
   * by Vladimir Yaroslavskiy, Jon Bentley, and Joshua Bloch. This algorithm
   * offers O(n log(n)) performance on all data sets, and is typically
   * faster than traditional (one-pivot) Quicksort implementations.
   *
   * @param a the array to be sorted
  */
  static sort(a: number[]): void;
  /**
   * Sorts the specified range of the array into ascending order. The range
   * to be sorted extends from the index `fromIndex`, inclusive, to
   * the index `toIndex`, exclusive. If `fromIndex == toIndex`,
   * the range to be sorted is empty.
   *
   * @implNote The sorting algorithm is a Dual-Pivot Quicksort
   * by Vladimir Yaroslavskiy, Jon Bentley, and Joshua Bloch. This algorithm
   * offers O(n log(n)) performance on all data sets, and is typically
   * faster than traditional (one-pivot) Quicksort implementations.
   *
   * @param a the array to be sorted
   * @param fromIndex the index of the first element, inclusive, to be sorted
   * @param toIndex the index of the last element, exclusive, to be sorted
   *
   * @throws IllegalArgumentException if `fromIndex > toIndex`
   * @throws ArrayIndexOutOfBoundsException
   *     if `fromIndex < 0` or `toIndex > a.length`
  */
  static sort(a: number[], fromIndex: number, toIndex: number): void;
  /**
   * Sorts the specified array into ascending numerical order.
   *
   * @implNote The sorting algorithm is a Dual-Pivot Quicksort
   * by Vladimir Yaroslavskiy, Jon Bentley, and Joshua Bloch. This algorithm
   * offers O(n log(n)) performance on all data sets, and is typically
   * faster than traditional (one-pivot) Quicksort implementations.
   *
   * @param a the array to be sorted
  */
  static sort(a: number[]): void;
  /**
   * Sorts the specified range of the array into ascending order. The range
   * to be sorted extends from the index `fromIndex`, inclusive, to
   * the index `toIndex`, exclusive. If `fromIndex == toIndex`,
   * the range to be sorted is empty.
   *
   * @implNote The sorting algorithm is a Dual-Pivot Quicksort
   * by Vladimir Yaroslavskiy, Jon Bentley, and Joshua Bloch. This algorithm
   * offers O(n log(n)) performance on all data sets, and is typically
   * faster than traditional (one-pivot) Quicksort implementations.
   *
   * @param a the array to be sorted
   * @param fromIndex the index of the first element, inclusive, to be sorted
   * @param toIndex the index of the last element, exclusive, to be sorted
   *
   * @throws IllegalArgumentException if `fromIndex > toIndex`
   * @throws ArrayIndexOutOfBoundsException
   *     if `fromIndex < 0` or `toIndex > a.length`
  */
  static sort(a: number[], fromIndex: number, toIndex: number): void;
  /**
   * Sorts the specified array into ascending numerical order.
   *
   * @implNote The sorting algorithm is a Dual-Pivot Quicksort
   * by Vladimir Yaroslavskiy, Jon Bentley, and Joshua Bloch. This algorithm
   * offers O(n log(n)) performance on all data sets, and is typically
   * faster than traditional (one-pivot) Quicksort implementations.
   *
   * @param a the array to be sorted
  */
  static sort(a: number[]): void;
  /**
   * Sorts the specified range of the array into ascending order. The range
   * to be sorted extends from the index `fromIndex`, inclusive, to
   * the index `toIndex`, exclusive. If `fromIndex == toIndex`,
   * the range to be sorted is empty.
   *
   * @implNote The sorting algorithm is a Dual-Pivot Quicksort
   * by Vladimir Yaroslavskiy, Jon Bentley, and Joshua Bloch. This algorithm
   * offers O(n log(n)) performance on all data sets, and is typically
   * faster than traditional (one-pivot) Quicksort implementations.
   *
   * @param a the array to be sorted
   * @param fromIndex the index of the first element, inclusive, to be sorted
   * @param toIndex the index of the last element, exclusive, to be sorted
   *
   * @throws IllegalArgumentException if `fromIndex > toIndex`
   * @throws ArrayIndexOutOfBoundsException
   *     if `fromIndex < 0` or `toIndex > a.length`
  */
  static sort(a: number[], fromIndex: number, toIndex: number): void;
  /**
   * Sorts the specified array into ascending numerical order.
   *
   * @implNote The sorting algorithm is a Dual-Pivot Quicksort
   * by Vladimir Yaroslavskiy, Jon Bentley, and Joshua Bloch. This algorithm
   * offers O(n log(n)) performance on all data sets, and is typically
   * faster than traditional (one-pivot) Quicksort implementations.
   *
   * @param a the array to be sorted
  */
  static sort(a: string[]): void;
  /**
   * Sorts the specified range of the array into ascending order. The range
   * to be sorted extends from the index `fromIndex`, inclusive, to
   * the index `toIndex`, exclusive. If `fromIndex == toIndex`,
   * the range to be sorted is empty.
   *
   * @implNote The sorting algorithm is a Dual-Pivot Quicksort
   * by Vladimir Yaroslavskiy, Jon Bentley, and Joshua Bloch. This algorithm
   * offers O(n log(n)) performance on all data sets, and is typically
   * faster than traditional (one-pivot) Quicksort implementations.
   *
   * @param a the array to be sorted
   * @param fromIndex the index of the first element, inclusive, to be sorted
   * @param toIndex the index of the last element, exclusive, to be sorted
   *
   * @throws IllegalArgumentException if `fromIndex > toIndex`
   * @throws ArrayIndexOutOfBoundsException
   *     if `fromIndex < 0` or `toIndex > a.length`
  */
  static sort(a: string[], fromIndex: number, toIndex: number): void;
  /**
   * Sorts the specified array into ascending numerical order.
   *
   * @implNote The sorting algorithm is a Dual-Pivot Quicksort
   * by Vladimir Yaroslavskiy, Jon Bentley, and Joshua Bloch. This algorithm
   * offers O(n log(n)) performance on all data sets, and is typically
   * faster than traditional (one-pivot) Quicksort implementations.
   *
   * @param a the array to be sorted
  */
  static sort(a: number[]): void;
  /**
   * Sorts the specified range of the array into ascending order. The range
   * to be sorted extends from the index `fromIndex`, inclusive, to
   * the index `toIndex`, exclusive. If `fromIndex == toIndex`,
   * the range to be sorted is empty.
   *
   * @implNote The sorting algorithm is a Dual-Pivot Quicksort
   * by Vladimir Yaroslavskiy, Jon Bentley, and Joshua Bloch. This algorithm
   * offers O(n log(n)) performance on all data sets, and is typically
   * faster than traditional (one-pivot) Quicksort implementations.
   *
   * @param a the array to be sorted
   * @param fromIndex the index of the first element, inclusive, to be sorted
   * @param toIndex the index of the last element, exclusive, to be sorted
   *
   * @throws IllegalArgumentException if `fromIndex > toIndex`
   * @throws ArrayIndexOutOfBoundsException
   *     if `fromIndex < 0` or `toIndex > a.length`
  */
  static sort(a: number[], fromIndex: number, toIndex: number): void;
  /**
   * Sorts the specified array into ascending numerical order.
   *
   * The `<` relation does not provide a total order on all float
   * values: `-0.0f == 0.0f` is `true` and a `Float.NaN`
   * value compares neither less than, greater than, nor equal to any value,
   * even itself. This method uses the total order imposed by the method
   * {@link Float#compareTo}: `-0.0f` is treated as less than value
   * `0.0f` and `Float.NaN` is considered greater than any
   * other value and all `Float.NaN` values are considered equal.
   *
   * @implNote The sorting algorithm is a Dual-Pivot Quicksort
   * by Vladimir Yaroslavskiy, Jon Bentley, and Joshua Bloch. This algorithm
   * offers O(n log(n)) performance on all data sets, and is typically
   * faster than traditional (one-pivot) Quicksort implementations.
   *
   * @param a the array to be sorted
  */
  static sort(a: number[]): void;
  /**
   * Sorts the specified range of the array into ascending order. The range
   * to be sorted extends from the index `fromIndex`, inclusive, to
   * the index `toIndex`, exclusive. If `fromIndex == toIndex`,
   * the range to be sorted is empty.
   *
   * The `<` relation does not provide a total order on all float
   * values: `-0.0f == 0.0f` is `true` and a `Float.NaN`
   * value compares neither less than, greater than, nor equal to any value,
   * even itself. This method uses the total order imposed by the method
   * {@link Float#compareTo}: `-0.0f` is treated as less than value
   * `0.0f` and `Float.NaN` is considered greater than any
   * other value and all `Float.NaN` values are considered equal.
   *
   * @implNote The sorting algorithm is a Dual-Pivot Quicksort
   * by Vladimir Yaroslavskiy, Jon Bentley, and Joshua Bloch. This algorithm
   * offers O(n log(n)) performance on all data sets, and is typically
   * faster than traditional (one-pivot) Quicksort implementations.
   *
   * @param a the array to be sorted
   * @param fromIndex the index of the first element, inclusive, to be sorted
   * @param toIndex the index of the last element, exclusive, to be sorted
   *
   * @throws IllegalArgumentException if `fromIndex > toIndex`
   * @throws ArrayIndexOutOfBoundsException
   *     if `fromIndex < 0` or `toIndex > a.length`
  */
  static sort(a: number[], fromIndex: number, toIndex: number): void;
  /**
   * Sorts the specified array into ascending numerical order.
   *
   * The `<` relation does not provide a total order on all double
   * values: `-0.0d == 0.0d` is `true` and a `Double.NaN`
   * value compares neither less than, greater than, nor equal to any value,
   * even itself. This method uses the total order imposed by the method
   * {@link Double#compareTo}: `-0.0d` is treated as less than value
   * `0.0d` and `Double.NaN` is considered greater than any
   * other value and all `Double.NaN` values are considered equal.
   *
   * @implNote The sorting algorithm is a Dual-Pivot Quicksort
   * by Vladimir Yaroslavskiy, Jon Bentley, and Joshua Bloch. This algorithm
   * offers O(n log(n)) performance on all data sets, and is typically
   * faster than traditional (one-pivot) Quicksort implementations.
   *
   * @param a the array to be sorted
  */
  static sort(a: number[]): void;
  /**
   * Sorts the specified range of the array into ascending order. The range
   * to be sorted extends from the index `fromIndex`, inclusive, to
   * the index `toIndex`, exclusive. If `fromIndex == toIndex`,
   * the range to be sorted is empty.
   *
   * The `<` relation does not provide a total order on all double
   * values: `-0.0d == 0.0d` is `true` and a `Double.NaN`
   * value compares neither less than, greater than, nor equal to any value,
   * even itself. This method uses the total order imposed by the method
   * {@link Double#compareTo}: `-0.0d` is treated as less than value
   * `0.0d` and `Double.NaN` is considered greater than any
   * other value and all `Double.NaN` values are considered equal.
   *
   * @implNote The sorting algorithm is a Dual-Pivot Quicksort
   * by Vladimir Yaroslavskiy, Jon Bentley, and Joshua Bloch. This algorithm
   * offers O(n log(n)) performance on all data sets, and is typically
   * faster than traditional (one-pivot) Quicksort implementations.
   *
   * @param a the array to be sorted
   * @param fromIndex the index of the first element, inclusive, to be sorted
   * @param toIndex the index of the last element, exclusive, to be sorted
   *
   * @throws IllegalArgumentException if `fromIndex > toIndex`
   * @throws ArrayIndexOutOfBoundsException
   *     if `fromIndex < 0` or `toIndex > a.length`
  */
  static sort(a: number[], fromIndex: number, toIndex: number): void;
  /**
   * Sorts the specified array into ascending numerical order.
   *
   * @implNote The sorting algorithm is a Dual-Pivot Quicksort by
   * Vladimir Yaroslavskiy, Jon Bentley and Josh Bloch. This algorithm
   * offers O(n log(n)) performance on all data sets, and is typically
   * faster than traditional (one-pivot) Quicksort implementations.
   *
   * @param a the array to be sorted
   *
   * @since 1.8
  */
  static parallelSort(a: number[]): void;
  /**
   * Sorts the specified range of the array into ascending numerical order.
   * The range to be sorted extends from the index `fromIndex`,
   * inclusive, to the index `toIndex`, exclusive. If
   * `fromIndex == toIndex`, the range to be sorted is empty.
   *
   * @implNote The sorting algorithm is a Dual-Pivot Quicksort by
   * Vladimir Yaroslavskiy, Jon Bentley and Josh Bloch. This algorithm
   * offers O(n log(n)) performance on all data sets, and is typically
   * faster than traditional (one-pivot) Quicksort implementations.
   *
   * @param a the array to be sorted
   * @param fromIndex the index of the first element, inclusive, to be sorted
   * @param toIndex the index of the last element, exclusive, to be sorted
   *
   * @throws IllegalArgumentException if `fromIndex > toIndex`
   * @throws ArrayIndexOutOfBoundsException
   *     if `fromIndex < 0` or `toIndex > a.length`
   *
   * @since 1.8
  */
  static parallelSort(a: number[], fromIndex: number, toIndex: number): void;
  /**
   * Sorts the specified array into ascending numerical order.
   *
   * @implNote The sorting algorithm is a Dual-Pivot Quicksort by
   * Vladimir Yaroslavskiy, Jon Bentley and Josh Bloch. This algorithm
   * offers O(n log(n)) performance on all data sets, and is typically
   * faster than traditional (one-pivot) Quicksort implementations.
   *
   * @param a the array to be sorted
   *
   * @since 1.8
  */
  static parallelSort(a: string[]): void;
  /**
   * Sorts the specified range of the array into ascending numerical order.
   * The range to be sorted extends from the index `fromIndex`,
   * inclusive, to the index `toIndex`, exclusive. If
   * `fromIndex == toIndex`, the range to be sorted is empty.
   *
   * @implNote The sorting algorithm is a Dual-Pivot Quicksort by
   * Vladimir Yaroslavskiy, Jon Bentley and Josh Bloch. This algorithm
   * offers O(n log(n)) performance on all data sets, and is typically
   * faster than traditional (one-pivot) Quicksort implementations.
   *
   * @param a the array to be sorted
   * @param fromIndex the index of the first element, inclusive, to be sorted
   * @param toIndex the index of the last element, exclusive, to be sorted
   *
   * @throws IllegalArgumentException if `fromIndex > toIndex`
   * @throws ArrayIndexOutOfBoundsException
   *     if `fromIndex < 0` or `toIndex > a.length`
   *
   * @since 1.8
  */
  static parallelSort(a: string[], fromIndex: number, toIndex: number): void;
  /**
   * Sorts the specified array into ascending numerical order.
   *
   * @implNote The sorting algorithm is a Dual-Pivot Quicksort by
   * Vladimir Yaroslavskiy, Jon Bentley and Josh Bloch. This algorithm
   * offers O(n log(n)) performance on all data sets, and is typically
   * faster than traditional (one-pivot) Quicksort implementations.
   *
   * @param a the array to be sorted
   *
   * @since 1.8
  */
  static parallelSort(a: number[]): void;
  /**
   * Sorts the specified range of the array into ascending numerical order.
   * The range to be sorted extends from the index `fromIndex`,
   * inclusive, to the index `toIndex`, exclusive. If
   * `fromIndex == toIndex`, the range to be sorted is empty.
   *
   * @implNote The sorting algorithm is a Dual-Pivot Quicksort by
   * Vladimir Yaroslavskiy, Jon Bentley and Josh Bloch. This algorithm
   * offers O(n log(n)) performance on all data sets, and is typically
   * faster than traditional (one-pivot) Quicksort implementations.
   *
   * @param a the array to be sorted
   * @param fromIndex the index of the first element, inclusive, to be sorted
   * @param toIndex the index of the last element, exclusive, to be sorted
   *
   * @throws IllegalArgumentException if `fromIndex > toIndex`
   * @throws ArrayIndexOutOfBoundsException
   *     if `fromIndex < 0` or `toIndex > a.length`
   *
   * @since 1.8
  */
  static parallelSort(a: number[], fromIndex: number, toIndex: number): void;
  /**
   * Sorts the specified array into ascending numerical order.
   *
   * @implNote The sorting algorithm is a Dual-Pivot Quicksort by
   * Vladimir Yaroslavskiy, Jon Bentley and Josh Bloch. This algorithm
   * offers O(n log(n)) performance on all data sets, and is typically
   * faster than traditional (one-pivot) Quicksort implementations.
   *
   * @param a the array to be sorted
   *
   * @since 1.8
  */
  static parallelSort(a: number[]): void;
  /**
   * Sorts the specified range of the array into ascending numerical order.
   * The range to be sorted extends from the index `fromIndex`,
   * inclusive, to the index `toIndex`, exclusive. If
   * `fromIndex == toIndex`, the range to be sorted is empty.
   *
   * @implNote The sorting algorithm is a Dual-Pivot Quicksort by
   * Vladimir Yaroslavskiy, Jon Bentley and Josh Bloch. This algorithm
   * offers O(n log(n)) performance on all data sets, and is typically
   * faster than traditional (one-pivot) Quicksort implementations.
   *
   * @param a the array to be sorted
   * @param fromIndex the index of the first element, inclusive, to be sorted
   * @param toIndex the index of the last element, exclusive, to be sorted
   *
   * @throws IllegalArgumentException if `fromIndex > toIndex`
   * @throws ArrayIndexOutOfBoundsException
   *     if `fromIndex < 0` or `toIndex > a.length`
   *
   * @since 1.8
  */
  static parallelSort(a: number[], fromIndex: number, toIndex: number): void;
  /**
   * Sorts the specified array into ascending numerical order.
   *
   * @implNote The sorting algorithm is a Dual-Pivot Quicksort by
   * Vladimir Yaroslavskiy, Jon Bentley and Josh Bloch. This algorithm
   * offers O(n log(n)) performance on all data sets, and is typically
   * faster than traditional (one-pivot) Quicksort implementations.
   *
   * @param a the array to be sorted
   *
   * @since 1.8
  */
  static parallelSort(a: number[]): void;
  /**
   * Sorts the specified range of the array into ascending numerical order.
   * The range to be sorted extends from the index `fromIndex`,
   * inclusive, to the index `toIndex`, exclusive. If
   * `fromIndex == toIndex`, the range to be sorted is empty.
   *
   * @implNote The sorting algorithm is a Dual-Pivot Quicksort by
   * Vladimir Yaroslavskiy, Jon Bentley and Josh Bloch. This algorithm
   * offers O(n log(n)) performance on all data sets, and is typically
   * faster than traditional (one-pivot) Quicksort implementations.
   *
   * @param a the array to be sorted
   * @param fromIndex the index of the first element, inclusive, to be sorted
   * @param toIndex the index of the last element, exclusive, to be sorted
   *
   * @throws IllegalArgumentException if `fromIndex > toIndex`
   * @throws ArrayIndexOutOfBoundsException
   *     if `fromIndex < 0` or `toIndex > a.length`
   *
   * @since 1.8
  */
  static parallelSort(a: number[], fromIndex: number, toIndex: number): void;
  /**
   * Sorts the specified array into ascending numerical order.
   *
   * The `<` relation does not provide a total order on all float
   * values: `-0.0f == 0.0f` is `true` and a `Float.NaN`
   * value compares neither less than, greater than, nor equal to any value,
   * even itself. This method uses the total order imposed by the method
   * {@link Float#compareTo}: `-0.0f` is treated as less than value
   * `0.0f` and `Float.NaN` is considered greater than any
   * other value and all `Float.NaN` values are considered equal.
   *
   * @implNote The sorting algorithm is a Dual-Pivot Quicksort by
   * Vladimir Yaroslavskiy, Jon Bentley and Josh Bloch. This algorithm
   * offers O(n log(n)) performance on all data sets, and is typically
   * faster than traditional (one-pivot) Quicksort implementations.
   *
   * @param a the array to be sorted
   *
   * @since 1.8
  */
  static parallelSort(a: number[]): void;
  /**
   * Sorts the specified range of the array into ascending numerical order.
   * The range to be sorted extends from the index `fromIndex`,
   * inclusive, to the index `toIndex`, exclusive. If
   * `fromIndex == toIndex`, the range to be sorted is empty.
   *
   * The `<` relation does not provide a total order on all float
   * values: `-0.0f == 0.0f` is `true` and a `Float.NaN`
   * value compares neither less than, greater than, nor equal to any value,
   * even itself. This method uses the total order imposed by the method
   * {@link Float#compareTo}: `-0.0f` is treated as less than value
   * `0.0f` and `Float.NaN` is considered greater than any
   * other value and all `Float.NaN` values are considered equal.
   *
   * @implNote The sorting algorithm is a Dual-Pivot Quicksort by
   * Vladimir Yaroslavskiy, Jon Bentley and Josh Bloch. This algorithm
   * offers O(n log(n)) performance on all data sets, and is typically
   * faster than traditional (one-pivot) Quicksort implementations.
   *
   * @param a the array to be sorted
   * @param fromIndex the index of the first element, inclusive, to be sorted
   * @param toIndex the index of the last element, exclusive, to be sorted
   *
   * @throws IllegalArgumentException if `fromIndex > toIndex`
   * @throws ArrayIndexOutOfBoundsException
   *     if `fromIndex < 0` or `toIndex > a.length`
   *
   * @since 1.8
  */
  static parallelSort(a: number[], fromIndex: number, toIndex: number): void;
  /**
   * Sorts the specified array into ascending numerical order.
   *
   * The `<` relation does not provide a total order on all double
   * values: `-0.0d == 0.0d` is `true` and a `Double.NaN`
   * value compares neither less than, greater than, nor equal to any value,
   * even itself. This method uses the total order imposed by the method
   * {@link Double#compareTo}: `-0.0d` is treated as less than value
   * `0.0d` and `Double.NaN` is considered greater than any
   * other value and all `Double.NaN` values are considered equal.
   *
   * @implNote The sorting algorithm is a Dual-Pivot Quicksort by
   * Vladimir Yaroslavskiy, Jon Bentley and Josh Bloch. This algorithm
   * offers O(n log(n)) performance on all data sets, and is typically
   * faster than traditional (one-pivot) Quicksort implementations.
   *
   * @param a the array to be sorted
   *
   * @since 1.8
  */
  static parallelSort(a: number[]): void;
  /**
   * Sorts the specified range of the array into ascending numerical order.
   * The range to be sorted extends from the index `fromIndex`,
   * inclusive, to the index `toIndex`, exclusive. If
   * `fromIndex == toIndex`, the range to be sorted is empty.
   *
   * The `<` relation does not provide a total order on all double
   * values: `-0.0d == 0.0d` is `true` and a `Double.NaN`
   * value compares neither less than, greater than, nor equal to any value,
   * even itself. This method uses the total order imposed by the method
   * {@link Double#compareTo}: `-0.0d` is treated as less than value
   * `0.0d` and `Double.NaN` is considered greater than any
   * other value and all `Double.NaN` values are considered equal.
   *
   * @implNote The sorting algorithm is a Dual-Pivot Quicksort by
   * Vladimir Yaroslavskiy, Jon Bentley and Josh Bloch. This algorithm
   * offers O(n log(n)) performance on all data sets, and is typically
   * faster than traditional (one-pivot) Quicksort implementations.
   *
   * @param a the array to be sorted
   * @param fromIndex the index of the first element, inclusive, to be sorted
   * @param toIndex the index of the last element, exclusive, to be sorted
   *
   * @throws IllegalArgumentException if `fromIndex > toIndex`
   * @throws ArrayIndexOutOfBoundsException
   *     if `fromIndex < 0` or `toIndex > a.length`
   *
   * @since 1.8
  */
  static parallelSort(a: number[], fromIndex: number, toIndex: number): void;
  /**
   * Sorts the specified array of objects into ascending order, according
   * to the {@linkplain Comparable natural ordering} of its elements.
   * All elements in the array must implement the {@link Comparable}
   * interface.  Furthermore, all elements in the array must be
   * mutually comparable (that is, `e1.compareTo(e2)` must
   * not throw a `ClassCastException` for any elements `e1`
   * and `e2` in the array).
   *
   * This sort is guaranteed to be stable:  equal elements will
   * not be reordered as a result of the sort.
   *
   * @implNote The sorting algorithm is a parallel sort-merge that breaks the
   * array into sub-arrays that are themselves sorted and then merged. When
   * the sub-array length reaches a minimum granularity, the sub-array is
   * sorted using the appropriate {@link Arrays#sort(Object[]) Arrays.sort}
   * method. If the length of the specified array is less than the minimum
   * granularity, then it is sorted using the appropriate {@link
   * Arrays#sort(Object[]) Arrays.sort} method. The algorithm requires a
   * working space no greater than the size of the original array. The
   * {@link ForkJoinPool#commonPool() ForkJoin common pool} is used to
   * execute any parallel tasks.
   *
   * @param  the class of the objects to be sorted
   * @param a the array to be sorted
   *
   * @throws ClassCastException if the array contains elements that are not
   *         mutually comparable (for example, strings and integers)
   * @throws IllegalArgumentException (optional) if the natural
   *         ordering of the array elements is found to violate the
   *         {@link Comparable} contract
   *
   * @since 1.8
  */
  static parallelSort<T>(a: T[]): void;
  /**
   * Sorts the specified range of the specified array of objects into
   * ascending order, according to the
   * {@linkplain Comparable natural ordering} of its
   * elements.  The range to be sorted extends from index
   * `fromIndex`, inclusive, to index `toIndex`, exclusive.
   * (If `fromIndex==toIndex`, the range to be sorted is empty.)  All
   * elements in this range must implement the {@link Comparable}
   * interface.  Furthermore, all elements in this range must be mutually
   * comparable (that is, `e1.compareTo(e2)` must not throw a
   * `ClassCastException` for any elements `e1` and
   * `e2` in the array).
   *
   * This sort is guaranteed to be stable:  equal elements will
   * not be reordered as a result of the sort.
   *
   * @implNote The sorting algorithm is a parallel sort-merge that breaks the
   * array into sub-arrays that are themselves sorted and then merged. When
   * the sub-array length reaches a minimum granularity, the sub-array is
   * sorted using the appropriate {@link Arrays#sort(Object[]) Arrays.sort}
   * method. If the length of the specified array is less than the minimum
   * granularity, then it is sorted using the appropriate {@link
   * Arrays#sort(Object[]) Arrays.sort} method. The algorithm requires a working
   * space no greater than the size of the specified range of the original
   * array. The {@link ForkJoinPool#commonPool() ForkJoin common pool} is
   * used to execute any parallel tasks.
   *
   * @param  the class of the objects to be sorted
   * @param a the array to be sorted
   * @param fromIndex the index of the first element (inclusive) to be
   *        sorted
   * @param toIndex the index of the last element (exclusive) to be sorted
   * @throws IllegalArgumentException if `fromIndex > toIndex` or
   *         (optional) if the natural ordering of the array elements is
   *         found to violate the {@link Comparable} contract
   * @throws ArrayIndexOutOfBoundsException if `fromIndex < 0` or
   *         `toIndex > a.length`
   * @throws ClassCastException if the array contains elements that are
   *         not mutually comparable (for example, strings and
   *         integers).
   *
   * @since 1.8
  */
  static parallelSort<T>(a: T[], fromIndex: number, toIndex: number): void;
  /**
   * Sorts the specified array of objects according to the order induced by
   * the specified comparator.  All elements in the array must be
   * mutually comparable by the specified comparator (that is,
   * `c.compare(e1, e2)` must not throw a `ClassCastException`
   * for any elements `e1` and `e2` in the array).
   *
   * This sort is guaranteed to be stable:  equal elements will
   * not be reordered as a result of the sort.
   *
   * @implNote The sorting algorithm is a parallel sort-merge that breaks the
   * array into sub-arrays that are themselves sorted and then merged. When
   * the sub-array length reaches a minimum granularity, the sub-array is
   * sorted using the appropriate {@link Arrays#sort(Object[]) Arrays.sort}
   * method. If the length of the specified array is less than the minimum
   * granularity, then it is sorted using the appropriate {@link
   * Arrays#sort(Object[]) Arrays.sort} method. The algorithm requires a
   * working space no greater than the size of the original array. The
   * {@link ForkJoinPool#commonPool() ForkJoin common pool} is used to
   * execute any parallel tasks.
   *
   * @param  the class of the objects to be sorted
   * @param a the array to be sorted
   * @param cmp the comparator to determine the order of the array.  A
   *        `null` value indicates that the elements'
   *        {@linkplain Comparable natural ordering} should be used.
   * @throws ClassCastException if the array contains elements that are
   *         not mutually comparable using the specified comparator
   * @throws IllegalArgumentException (optional) if the comparator is
   *         found to violate the {@link java.util.Comparator} contract
   *
   * @since 1.8
  */
  static parallelSort<T>(a: T[], cmp: Comparator<any>): void;
  /**
   * Sorts the specified range of the specified array of objects according
   * to the order induced by the specified comparator.  The range to be
   * sorted extends from index `fromIndex`, inclusive, to index
   * `toIndex`, exclusive.  (If `fromIndex==toIndex`, the
   * range to be sorted is empty.)  All elements in the range must be
   * mutually comparable by the specified comparator (that is,
   * `c.compare(e1, e2)` must not throw a `ClassCastException`
   * for any elements `e1` and `e2` in the range).
   *
   * This sort is guaranteed to be stable:  equal elements will
   * not be reordered as a result of the sort.
   *
   * @implNote The sorting algorithm is a parallel sort-merge that breaks the
   * array into sub-arrays that are themselves sorted and then merged. When
   * the sub-array length reaches a minimum granularity, the sub-array is
   * sorted using the appropriate {@link Arrays#sort(Object[]) Arrays.sort}
   * method. If the length of the specified array is less than the minimum
   * granularity, then it is sorted using the appropriate {@link
   * Arrays#sort(Object[]) Arrays.sort} method. The algorithm requires a working
   * space no greater than the size of the specified range of the original
   * array. The {@link ForkJoinPool#commonPool() ForkJoin common pool} is
   * used to execute any parallel tasks.
   *
   * @param  the class of the objects to be sorted
   * @param a the array to be sorted
   * @param fromIndex the index of the first element (inclusive) to be
   *        sorted
   * @param toIndex the index of the last element (exclusive) to be sorted
   * @param cmp the comparator to determine the order of the array.  A
   *        `null` value indicates that the elements'
   *        {@linkplain Comparable natural ordering} should be used.
   * @throws IllegalArgumentException if `fromIndex > toIndex` or
   *         (optional) if the natural ordering of the array elements is
   *         found to violate the {@link Comparable} contract
   * @throws ArrayIndexOutOfBoundsException if `fromIndex < 0` or
   *         `toIndex > a.length`
   * @throws ClassCastException if the array contains elements that are
   *         not mutually comparable (for example, strings and
   *         integers).
   *
   * @since 1.8
  */
  static parallelSort<T>(a: T[], fromIndex: number, toIndex: number, cmp: Comparator<any>): void;
  /**
   * Sorts the specified array of objects into ascending order, according
   * to the {@linkplain Comparable natural ordering} of its elements.
   * All elements in the array must implement the {@link Comparable}
   * interface.  Furthermore, all elements in the array must be
   * mutually comparable (that is, `e1.compareTo(e2)` must
   * not throw a `ClassCastException` for any elements `e1`
   * and `e2` in the array).
   *
   * This sort is guaranteed to be stable:  equal elements will
   * not be reordered as a result of the sort.
   *
   * Implementation note: This implementation is a stable, adaptive,
   * iterative mergesort that requires far fewer than n lg(n) comparisons
   * when the input array is partially sorted, while offering the
   * performance of a traditional mergesort when the input array is
   * randomly ordered.  If the input array is nearly sorted, the
   * implementation requires approximately n comparisons.  Temporary
   * storage requirements vary from a small constant for nearly sorted
   * input arrays to n/2 object references for randomly ordered input
   * arrays.
   *
   * The implementation takes equal advantage of ascending and
   * descending order in its input array, and can take advantage of
   * ascending and descending order in different parts of the same
   * input array.  It is well-suited to merging two or more sorted arrays:
   * simply concatenate the arrays and sort the resulting array.
   *
   * The implementation was adapted from Tim Peters's list sort for Python
   * (
   * TimSort).  It uses techniques from Peter McIlroy's "Optimistic
   * Sorting and Information Theoretic Complexity", in Proceedings of the
   * Fourth Annual ACM-SIAM Symposium on Discrete Algorithms, pp 467-474,
   * January 1993.
   *
   * @param a the array to be sorted
   * @throws ClassCastException if the array contains elements that are not
   *         mutually comparable (for example, strings and integers)
   * @throws IllegalArgumentException (optional) if the natural
   *         ordering of the array elements is found to violate the
   *         {@link Comparable} contract
  */
  static sort(a: any[]): void;
  /**
   * Sorts the specified range of the specified array of objects into
   * ascending order, according to the
   * {@linkplain Comparable natural ordering} of its
   * elements.  The range to be sorted extends from index
   * `fromIndex`, inclusive, to index `toIndex`, exclusive.
   * (If `fromIndex==toIndex`, the range to be sorted is empty.)  All
   * elements in this range must implement the {@link Comparable}
   * interface.  Furthermore, all elements in this range must be mutually
   * comparable (that is, `e1.compareTo(e2)` must not throw a
   * `ClassCastException` for any elements `e1` and
   * `e2` in the array).
   *
   * This sort is guaranteed to be stable:  equal elements will
   * not be reordered as a result of the sort.
   *
   * Implementation note: This implementation is a stable, adaptive,
   * iterative mergesort that requires far fewer than n lg(n) comparisons
   * when the input array is partially sorted, while offering the
   * performance of a traditional mergesort when the input array is
   * randomly ordered.  If the input array is nearly sorted, the
   * implementation requires approximately n comparisons.  Temporary
   * storage requirements vary from a small constant for nearly sorted
   * input arrays to n/2 object references for randomly ordered input
   * arrays.
   *
   * The implementation takes equal advantage of ascending and
   * descending order in its input array, and can take advantage of
   * ascending and descending order in different parts of the same
   * input array.  It is well-suited to merging two or more sorted arrays:
   * simply concatenate the arrays and sort the resulting array.
   *
   * The implementation was adapted from Tim Peters's list sort for Python
   * (
   * TimSort).  It uses techniques from Peter McIlroy's "Optimistic
   * Sorting and Information Theoretic Complexity", in Proceedings of the
   * Fourth Annual ACM-SIAM Symposium on Discrete Algorithms, pp 467-474,
   * January 1993.
   *
   * @param a the array to be sorted
   * @param fromIndex the index of the first element (inclusive) to be
   *        sorted
   * @param toIndex the index of the last element (exclusive) to be sorted
   * @throws IllegalArgumentException if `fromIndex > toIndex` or
   *         (optional) if the natural ordering of the array elements is
   *         found to violate the {@link Comparable} contract
   * @throws ArrayIndexOutOfBoundsException if `fromIndex < 0` or
   *         `toIndex > a.length`
   * @throws ClassCastException if the array contains elements that are
   *         not mutually comparable (for example, strings and
   *         integers).
  */
  static sort(a: any[], fromIndex: number, toIndex: number): void;
  /**
   * Sorts the specified array of objects according to the order induced by
   * the specified comparator.  All elements in the array must be
   * mutually comparable by the specified comparator (that is,
   * `c.compare(e1, e2)` must not throw a `ClassCastException`
   * for any elements `e1` and `e2` in the array).
   *
   * This sort is guaranteed to be stable:  equal elements will
   * not be reordered as a result of the sort.
   *
   * Implementation note: This implementation is a stable, adaptive,
   * iterative mergesort that requires far fewer than n lg(n) comparisons
   * when the input array is partially sorted, while offering the
   * performance of a traditional mergesort when the input array is
   * randomly ordered.  If the input array is nearly sorted, the
   * implementation requires approximately n comparisons.  Temporary
   * storage requirements vary from a small constant for nearly sorted
   * input arrays to n/2 object references for randomly ordered input
   * arrays.
   *
   * The implementation takes equal advantage of ascending and
   * descending order in its input array, and can take advantage of
   * ascending and descending order in different parts of the same
   * input array.  It is well-suited to merging two or more sorted arrays:
   * simply concatenate the arrays and sort the resulting array.
   *
   * The implementation was adapted from Tim Peters's list sort for Python
   * (
   * TimSort).  It uses techniques from Peter McIlroy's "Optimistic
   * Sorting and Information Theoretic Complexity", in Proceedings of the
   * Fourth Annual ACM-SIAM Symposium on Discrete Algorithms, pp 467-474,
   * January 1993.
   *
   * @param  the class of the objects to be sorted
   * @param a the array to be sorted
   * @param c the comparator to determine the order of the array.  A
   *        `null` value indicates that the elements'
   *        {@linkplain Comparable natural ordering} should be used.
   * @throws ClassCastException if the array contains elements that are
   *         not mutually comparable using the specified comparator
   * @throws IllegalArgumentException (optional) if the comparator is
   *         found to violate the {@link Comparator} contract
  */
  static sort<T>(a: T[], c: Comparator<any>): void;
  /**
   * Sorts the specified range of the specified array of objects according
   * to the order induced by the specified comparator.  The range to be
   * sorted extends from index `fromIndex`, inclusive, to index
   * `toIndex`, exclusive.  (If `fromIndex==toIndex`, the
   * range to be sorted is empty.)  All elements in the range must be
   * mutually comparable by the specified comparator (that is,
   * `c.compare(e1, e2)` must not throw a `ClassCastException`
   * for any elements `e1` and `e2` in the range).
   *
   * This sort is guaranteed to be stable:  equal elements will
   * not be reordered as a result of the sort.
   *
   * Implementation note: This implementation is a stable, adaptive,
   * iterative mergesort that requires far fewer than n lg(n) comparisons
   * when the input array is partially sorted, while offering the
   * performance of a traditional mergesort when the input array is
   * randomly ordered.  If the input array is nearly sorted, the
   * implementation requires approximately n comparisons.  Temporary
   * storage requirements vary from a small constant for nearly sorted
   * input arrays to n/2 object references for randomly ordered input
   * arrays.
   *
   * The implementation takes equal advantage of ascending and
   * descending order in its input array, and can take advantage of
   * ascending and descending order in different parts of the same
   * input array.  It is well-suited to merging two or more sorted arrays:
   * simply concatenate the arrays and sort the resulting array.
   *
   * The implementation was adapted from Tim Peters's list sort for Python
   * (
   * TimSort).  It uses techniques from Peter McIlroy's "Optimistic
   * Sorting and Information Theoretic Complexity", in Proceedings of the
   * Fourth Annual ACM-SIAM Symposium on Discrete Algorithms, pp 467-474,
   * January 1993.
   *
   * @param  the class of the objects to be sorted
   * @param a the array to be sorted
   * @param fromIndex the index of the first element (inclusive) to be
   *        sorted
   * @param toIndex the index of the last element (exclusive) to be sorted
   * @param c the comparator to determine the order of the array.  A
   *        `null` value indicates that the elements'
   *        {@linkplain Comparable natural ordering} should be used.
   * @throws ClassCastException if the array contains elements that are not
   *         mutually comparable using the specified comparator.
   * @throws IllegalArgumentException if `fromIndex > toIndex` or
   *         (optional) if the comparator is found to violate the
   *         {@link Comparator} contract
   * @throws ArrayIndexOutOfBoundsException if `fromIndex < 0` or
   *         `toIndex > a.length`
  */
  static sort<T>(a: T[], fromIndex: number, toIndex: number, c: Comparator<any>): void;
  /**
   * Cumulates, in parallel, each element of the given array in place,
   * using the supplied function. For example if the array initially
   * holds `[2, 1, 0, 3]` and the operation performs addition,
   * then upon return the array holds `[2, 3, 3, 6]`.
   * Parallel prefix computation is usually more efficient than
   * sequential loops for large arrays.
   *
   * @param  the class of the objects in the array
   * @param array the array, which is modified in-place by this method
   * @param op a side-effect-free, associative function to perform the
   * cumulation
   * @throws NullPointerException if the specified array or function is null
   * @since 1.8
  */
  static parallelPrefix<T>(array: T[], op: BinaryOperator<T>): void;
  /**
   * Performs {@link #parallelPrefix(Object[], BinaryOperator)}
   * for the given subrange of the array.
   *
   * @param  the class of the objects in the array
   * @param array the array
   * @param fromIndex the index of the first element, inclusive
   * @param toIndex the index of the last element, exclusive
   * @param op a side-effect-free, associative function to perform the
   * cumulation
   * @throws IllegalArgumentException if `fromIndex > toIndex`
   * @throws ArrayIndexOutOfBoundsException
   *     if `fromIndex < 0` or `toIndex > array.length`
   * @throws NullPointerException if the specified array or function is null
   * @since 1.8
  */
  static parallelPrefix<T>(array: T[], fromIndex: number, toIndex: number, op: BinaryOperator<T>): void;
  /**
   * Cumulates, in parallel, each element of the given array in place,
   * using the supplied function. For example if the array initially
   * holds `[2, 1, 0, 3]` and the operation performs addition,
   * then upon return the array holds `[2, 3, 3, 6]`.
   * Parallel prefix computation is usually more efficient than
   * sequential loops for large arrays.
   *
   * @param array the array, which is modified in-place by this method
   * @param op a side-effect-free, associative function to perform the
   * cumulation
   * @throws NullPointerException if the specified array or function is null
   * @since 1.8
  */
  static parallelPrefix(array: number[], op: LongBinaryOperator): void;
  /**
   * Performs {@link #parallelPrefix(long[], LongBinaryOperator)}
   * for the given subrange of the array.
   *
   * @param array the array
   * @param fromIndex the index of the first element, inclusive
   * @param toIndex the index of the last element, exclusive
   * @param op a side-effect-free, associative function to perform the
   * cumulation
   * @throws IllegalArgumentException if `fromIndex > toIndex`
   * @throws ArrayIndexOutOfBoundsException
   *     if `fromIndex < 0` or `toIndex > array.length`
   * @throws NullPointerException if the specified array or function is null
   * @since 1.8
  */
  static parallelPrefix(array: number[], fromIndex: number, toIndex: number, op: LongBinaryOperator): void;
  /**
   * Cumulates, in parallel, each element of the given array in place,
   * using the supplied function. For example if the array initially
   * holds `[2.0, 1.0, 0.0, 3.0]` and the operation performs addition,
   * then upon return the array holds `[2.0, 3.0, 3.0, 6.0]`.
   * Parallel prefix computation is usually more efficient than
   * sequential loops for large arrays.
   *
   *  Because floating-point operations may not be strictly associative,
   * the returned result may not be identical to the value that would be
   * obtained if the operation was performed sequentially.
   *
   * @param array the array, which is modified in-place by this method
   * @param op a side-effect-free function to perform the cumulation
   * @throws NullPointerException if the specified array or function is null
   * @since 1.8
  */
  static parallelPrefix(array: number[], op: DoubleBinaryOperator): void;
  /**
   * Performs {@link #parallelPrefix(double[], DoubleBinaryOperator)}
   * for the given subrange of the array.
   *
   * @param array the array
   * @param fromIndex the index of the first element, inclusive
   * @param toIndex the index of the last element, exclusive
   * @param op a side-effect-free, associative function to perform the
   * cumulation
   * @throws IllegalArgumentException if `fromIndex > toIndex`
   * @throws ArrayIndexOutOfBoundsException
   *     if `fromIndex < 0` or `toIndex > array.length`
   * @throws NullPointerException if the specified array or function is null
   * @since 1.8
  */
  static parallelPrefix(array: number[], fromIndex: number, toIndex: number, op: DoubleBinaryOperator): void;
  /**
   * Cumulates, in parallel, each element of the given array in place,
   * using the supplied function. For example if the array initially
   * holds `[2, 1, 0, 3]` and the operation performs addition,
   * then upon return the array holds `[2, 3, 3, 6]`.
   * Parallel prefix computation is usually more efficient than
   * sequential loops for large arrays.
   *
   * @param array the array, which is modified in-place by this method
   * @param op a side-effect-free, associative function to perform the
   * cumulation
   * @throws NullPointerException if the specified array or function is null
   * @since 1.8
  */
  static parallelPrefix(array: number[], op: IntBinaryOperator): void;
  /**
   * Performs {@link #parallelPrefix(int[], IntBinaryOperator)}
   * for the given subrange of the array.
   *
   * @param array the array
   * @param fromIndex the index of the first element, inclusive
   * @param toIndex the index of the last element, exclusive
   * @param op a side-effect-free, associative function to perform the
   * cumulation
   * @throws IllegalArgumentException if `fromIndex > toIndex`
   * @throws ArrayIndexOutOfBoundsException
   *     if `fromIndex < 0` or `toIndex > array.length`
   * @throws NullPointerException if the specified array or function is null
   * @since 1.8
  */
  static parallelPrefix(array: number[], fromIndex: number, toIndex: number, op: IntBinaryOperator): void;
  /**
   * Searches the specified array of longs for the specified value using the
   * binary search algorithm.  The array must be sorted (as
   * by the {@link #sort(long[])} method) prior to making this call.  If it
   * is not sorted, the results are undefined.  If the array contains
   * multiple elements with the specified value, there is no guarantee which
   * one will be found.
   *
   * @param a the array to be searched
   * @param key the value to be searched for
   * @return index of the search key, if it is contained in the array;
   *         otherwise, (-(insertion point) - 1).  The
   *         insertion point is defined as the point at which the
   *         key would be inserted into the array: the index of the first
   *         element greater than the key, or `a.length` if all
   *         elements in the array are less than the specified key.  Note
   *         that this guarantees that the return value will be >= 0 if
   *         and only if the key is found.
  */
  static binarySearch(a: number[], key: number): number;
  /**
   * Searches a range of
   * the specified array of longs for the specified value using the
   * binary search algorithm.
   * The range must be sorted (as
   * by the {@link #sort(long[], int, int)} method)
   * prior to making this call.  If it
   * is not sorted, the results are undefined.  If the range contains
   * multiple elements with the specified value, there is no guarantee which
   * one will be found.
   *
   * @param a the array to be searched
   * @param fromIndex the index of the first element (inclusive) to be
   *          searched
   * @param toIndex the index of the last element (exclusive) to be searched
   * @param key the value to be searched for
   * @return index of the search key, if it is contained in the array
   *         within the specified range;
   *         otherwise, (-(insertion point) - 1).  The
   *         insertion point is defined as the point at which the
   *         key would be inserted into the array: the index of the first
   *         element in the range greater than the key,
   *         or `toIndex` if all
   *         elements in the range are less than the specified key.  Note
   *         that this guarantees that the return value will be >= 0 if
   *         and only if the key is found.
   * @throws IllegalArgumentException
   *         if `fromIndex > toIndex`
   * @throws ArrayIndexOutOfBoundsException
   *         if `fromIndex < 0 or toIndex > a.length`
   * @since 1.6
  */
  static binarySearch(a: number[], fromIndex: number, toIndex: number, key: number): number;
  /**
   * Searches the specified array of ints for the specified value using the
   * binary search algorithm.  The array must be sorted (as
   * by the {@link #sort(int[])} method) prior to making this call.  If it
   * is not sorted, the results are undefined.  If the array contains
   * multiple elements with the specified value, there is no guarantee which
   * one will be found.
   *
   * @param a the array to be searched
   * @param key the value to be searched for
   * @return index of the search key, if it is contained in the array;
   *         otherwise, (-(insertion point) - 1).  The
   *         insertion point is defined as the point at which the
   *         key would be inserted into the array: the index of the first
   *         element greater than the key, or `a.length` if all
   *         elements in the array are less than the specified key.  Note
   *         that this guarantees that the return value will be >= 0 if
   *         and only if the key is found.
  */
  static binarySearch(a: number[], key: number): number;
  /**
   * Searches a range of
   * the specified array of ints for the specified value using the
   * binary search algorithm.
   * The range must be sorted (as
   * by the {@link #sort(int[], int, int)} method)
   * prior to making this call.  If it
   * is not sorted, the results are undefined.  If the range contains
   * multiple elements with the specified value, there is no guarantee which
   * one will be found.
   *
   * @param a the array to be searched
   * @param fromIndex the index of the first element (inclusive) to be
   *          searched
   * @param toIndex the index of the last element (exclusive) to be searched
   * @param key the value to be searched for
   * @return index of the search key, if it is contained in the array
   *         within the specified range;
   *         otherwise, (-(insertion point) - 1).  The
   *         insertion point is defined as the point at which the
   *         key would be inserted into the array: the index of the first
   *         element in the range greater than the key,
   *         or `toIndex` if all
   *         elements in the range are less than the specified key.  Note
   *         that this guarantees that the return value will be >= 0 if
   *         and only if the key is found.
   * @throws IllegalArgumentException
   *         if `fromIndex > toIndex`
   * @throws ArrayIndexOutOfBoundsException
   *         if `fromIndex < 0 or toIndex > a.length`
   * @since 1.6
  */
  static binarySearch(a: number[], fromIndex: number, toIndex: number, key: number): number;
  /**
   * Searches the specified array of shorts for the specified value using
   * the binary search algorithm.  The array must be sorted
   * (as by the {@link #sort(short[])} method) prior to making this call.  If
   * it is not sorted, the results are undefined.  If the array contains
   * multiple elements with the specified value, there is no guarantee which
   * one will be found.
   *
   * @param a the array to be searched
   * @param key the value to be searched for
   * @return index of the search key, if it is contained in the array;
   *         otherwise, (-(insertion point) - 1).  The
   *         insertion point is defined as the point at which the
   *         key would be inserted into the array: the index of the first
   *         element greater than the key, or `a.length` if all
   *         elements in the array are less than the specified key.  Note
   *         that this guarantees that the return value will be >= 0 if
   *         and only if the key is found.
  */
  static binarySearch(a: number[], key: number): number;
  /**
   * Searches a range of
   * the specified array of shorts for the specified value using
   * the binary search algorithm.
   * The range must be sorted
   * (as by the {@link #sort(short[], int, int)} method)
   * prior to making this call.  If
   * it is not sorted, the results are undefined.  If the range contains
   * multiple elements with the specified value, there is no guarantee which
   * one will be found.
   *
   * @param a the array to be searched
   * @param fromIndex the index of the first element (inclusive) to be
   *          searched
   * @param toIndex the index of the last element (exclusive) to be searched
   * @param key the value to be searched for
   * @return index of the search key, if it is contained in the array
   *         within the specified range;
   *         otherwise, (-(insertion point) - 1).  The
   *         insertion point is defined as the point at which the
   *         key would be inserted into the array: the index of the first
   *         element in the range greater than the key,
   *         or `toIndex` if all
   *         elements in the range are less than the specified key.  Note
   *         that this guarantees that the return value will be >= 0 if
   *         and only if the key is found.
   * @throws IllegalArgumentException
   *         if `fromIndex > toIndex`
   * @throws ArrayIndexOutOfBoundsException
   *         if `fromIndex < 0 or toIndex > a.length`
   * @since 1.6
  */
  static binarySearch(a: number[], fromIndex: number, toIndex: number, key: number): number;
  /**
   * Searches the specified array of chars for the specified value using the
   * binary search algorithm.  The array must be sorted (as
   * by the {@link #sort(char[])} method) prior to making this call.  If it
   * is not sorted, the results are undefined.  If the array contains
   * multiple elements with the specified value, there is no guarantee which
   * one will be found.
   *
   * @param a the array to be searched
   * @param key the value to be searched for
   * @return index of the search key, if it is contained in the array;
   *         otherwise, (-(insertion point) - 1).  The
   *         insertion point is defined as the point at which the
   *         key would be inserted into the array: the index of the first
   *         element greater than the key, or `a.length` if all
   *         elements in the array are less than the specified key.  Note
   *         that this guarantees that the return value will be >= 0 if
   *         and only if the key is found.
  */
  static binarySearch(a: string[], key: string): number;
  /**
   * Searches a range of
   * the specified array of chars for the specified value using the
   * binary search algorithm.
   * The range must be sorted (as
   * by the {@link #sort(char[], int, int)} method)
   * prior to making this call.  If it
   * is not sorted, the results are undefined.  If the range contains
   * multiple elements with the specified value, there is no guarantee which
   * one will be found.
   *
   * @param a the array to be searched
   * @param fromIndex the index of the first element (inclusive) to be
   *          searched
   * @param toIndex the index of the last element (exclusive) to be searched
   * @param key the value to be searched for
   * @return index of the search key, if it is contained in the array
   *         within the specified range;
   *         otherwise, (-(insertion point) - 1).  The
   *         insertion point is defined as the point at which the
   *         key would be inserted into the array: the index of the first
   *         element in the range greater than the key,
   *         or `toIndex` if all
   *         elements in the range are less than the specified key.  Note
   *         that this guarantees that the return value will be >= 0 if
   *         and only if the key is found.
   * @throws IllegalArgumentException
   *         if `fromIndex > toIndex`
   * @throws ArrayIndexOutOfBoundsException
   *         if `fromIndex < 0 or toIndex > a.length`
   * @since 1.6
  */
  static binarySearch(a: string[], fromIndex: number, toIndex: number, key: string): number;
  /**
   * Searches the specified array of bytes for the specified value using the
   * binary search algorithm.  The array must be sorted (as
   * by the {@link #sort(byte[])} method) prior to making this call.  If it
   * is not sorted, the results are undefined.  If the array contains
   * multiple elements with the specified value, there is no guarantee which
   * one will be found.
   *
   * @param a the array to be searched
   * @param key the value to be searched for
   * @return index of the search key, if it is contained in the array;
   *         otherwise, (-(insertion point) - 1).  The
   *         insertion point is defined as the point at which the
   *         key would be inserted into the array: the index of the first
   *         element greater than the key, or `a.length` if all
   *         elements in the array are less than the specified key.  Note
   *         that this guarantees that the return value will be >= 0 if
   *         and only if the key is found.
  */
  static binarySearch(a: number[], key: number): number;
  /**
   * Searches a range of
   * the specified array of bytes for the specified value using the
   * binary search algorithm.
   * The range must be sorted (as
   * by the {@link #sort(byte[], int, int)} method)
   * prior to making this call.  If it
   * is not sorted, the results are undefined.  If the range contains
   * multiple elements with the specified value, there is no guarantee which
   * one will be found.
   *
   * @param a the array to be searched
   * @param fromIndex the index of the first element (inclusive) to be
   *          searched
   * @param toIndex the index of the last element (exclusive) to be searched
   * @param key the value to be searched for
   * @return index of the search key, if it is contained in the array
   *         within the specified range;
   *         otherwise, (-(insertion point) - 1).  The
   *         insertion point is defined as the point at which the
   *         key would be inserted into the array: the index of the first
   *         element in the range greater than the key,
   *         or `toIndex` if all
   *         elements in the range are less than the specified key.  Note
   *         that this guarantees that the return value will be >= 0 if
   *         and only if the key is found.
   * @throws IllegalArgumentException
   *         if `fromIndex > toIndex`
   * @throws ArrayIndexOutOfBoundsException
   *         if `fromIndex < 0 or toIndex > a.length`
   * @since 1.6
  */
  static binarySearch(a: number[], fromIndex: number, toIndex: number, key: number): number;
  /**
   * Searches the specified array of doubles for the specified value using
   * the binary search algorithm.  The array must be sorted
   * (as by the {@link #sort(double[])} method) prior to making this call.
   * If it is not sorted, the results are undefined.  If the array contains
   * multiple elements with the specified value, there is no guarantee which
   * one will be found.  This method considers all NaN values to be
   * equivalent and equal.
   *
   * @param a the array to be searched
   * @param key the value to be searched for
   * @return index of the search key, if it is contained in the array;
   *         otherwise, (-(insertion point) - 1).  The
   *         insertion point is defined as the point at which the
   *         key would be inserted into the array: the index of the first
   *         element greater than the key, or `a.length` if all
   *         elements in the array are less than the specified key.  Note
   *         that this guarantees that the return value will be >= 0 if
   *         and only if the key is found.
  */
  static binarySearch(a: number[], key: number): number;
  /**
   * Searches a range of
   * the specified array of doubles for the specified value using
   * the binary search algorithm.
   * The range must be sorted
   * (as by the {@link #sort(double[], int, int)} method)
   * prior to making this call.
   * If it is not sorted, the results are undefined.  If the range contains
   * multiple elements with the specified value, there is no guarantee which
   * one will be found.  This method considers all NaN values to be
   * equivalent and equal.
   *
   * @param a the array to be searched
   * @param fromIndex the index of the first element (inclusive) to be
   *          searched
   * @param toIndex the index of the last element (exclusive) to be searched
   * @param key the value to be searched for
   * @return index of the search key, if it is contained in the array
   *         within the specified range;
   *         otherwise, (-(insertion point) - 1).  The
   *         insertion point is defined as the point at which the
   *         key would be inserted into the array: the index of the first
   *         element in the range greater than the key,
   *         or `toIndex` if all
   *         elements in the range are less than the specified key.  Note
   *         that this guarantees that the return value will be >= 0 if
   *         and only if the key is found.
   * @throws IllegalArgumentException
   *         if `fromIndex > toIndex`
   * @throws ArrayIndexOutOfBoundsException
   *         if `fromIndex < 0 or toIndex > a.length`
   * @since 1.6
  */
  static binarySearch(a: number[], fromIndex: number, toIndex: number, key: number): number;
  /**
   * Searches the specified array of floats for the specified value using
   * the binary search algorithm. The array must be sorted
   * (as by the {@link #sort(float[])} method) prior to making this call. If
   * it is not sorted, the results are undefined. If the array contains
   * multiple elements with the specified value, there is no guarantee which
   * one will be found. This method considers all NaN values to be
   * equivalent and equal.
   *
   * @param a the array to be searched
   * @param key the value to be searched for
   * @return index of the search key, if it is contained in the array;
   *         otherwise, (-(insertion point) - 1). The
   *         insertion point is defined as the point at which the
   *         key would be inserted into the array: the index of the first
   *         element greater than the key, or `a.length` if all
   *         elements in the array are less than the specified key. Note
   *         that this guarantees that the return value will be >= 0 if
   *         and only if the key is found.
  */
  static binarySearch(a: number[], key: number): number;
  /**
   * Searches a range of
   * the specified array of floats for the specified value using
   * the binary search algorithm.
   * The range must be sorted
   * (as by the {@link #sort(float[], int, int)} method)
   * prior to making this call. If
   * it is not sorted, the results are undefined. If the range contains
   * multiple elements with the specified value, there is no guarantee which
   * one will be found. This method considers all NaN values to be
   * equivalent and equal.
   *
   * @param a the array to be searched
   * @param fromIndex the index of the first element (inclusive) to be
   *          searched
   * @param toIndex the index of the last element (exclusive) to be searched
   * @param key the value to be searched for
   * @return index of the search key, if it is contained in the array
   *         within the specified range;
   *         otherwise, (-(insertion point) - 1). The
   *         insertion point is defined as the point at which the
   *         key would be inserted into the array: the index of the first
   *         element in the range greater than the key,
   *         or `toIndex` if all
   *         elements in the range are less than the specified key. Note
   *         that this guarantees that the return value will be >= 0 if
   *         and only if the key is found.
   * @throws IllegalArgumentException
   *         if `fromIndex > toIndex`
   * @throws ArrayIndexOutOfBoundsException
   *         if `fromIndex < 0 or toIndex > a.length`
   * @since 1.6
  */
  static binarySearch(a: number[], fromIndex: number, toIndex: number, key: number): number;
  /**
   * Searches the specified array for the specified object using the binary
   * search algorithm. The array must be sorted into ascending order
   * according to the
   * {@linkplain Comparable natural ordering}
   * of its elements (as by the
   * {@link #sort(Object[])} method) prior to making this call.
   * If it is not sorted, the results are undefined.
   * (If the array contains elements that are not mutually comparable (for
   * example, strings and integers), it cannot be sorted according
   * to the natural ordering of its elements, hence results are undefined.)
   * If the array contains multiple
   * elements equal to the specified object, there is no guarantee which
   * one will be found.
   *
   * @param a the array to be searched
   * @param key the value to be searched for
   * @return index of the search key, if it is contained in the array;
   *         otherwise, (-(insertion point) - 1).  The
   *         insertion point is defined as the point at which the
   *         key would be inserted into the array: the index of the first
   *         element greater than the key, or `a.length` if all
   *         elements in the array are less than the specified key.  Note
   *         that this guarantees that the return value will be >= 0 if
   *         and only if the key is found.
   * @throws ClassCastException if the search key is not comparable to the
   *         elements of the array.
  */
  static binarySearch(a: any[], key: any): number;
  /**
   * Searches a range of
   * the specified array for the specified object using the binary
   * search algorithm.
   * The range must be sorted into ascending order
   * according to the
   * {@linkplain Comparable natural ordering}
   * of its elements (as by the
   * {@link #sort(Object[], int, int)} method) prior to making this
   * call.  If it is not sorted, the results are undefined.
   * (If the range contains elements that are not mutually comparable (for
   * example, strings and integers), it cannot be sorted according
   * to the natural ordering of its elements, hence results are undefined.)
   * If the range contains multiple
   * elements equal to the specified object, there is no guarantee which
   * one will be found.
   *
   * @param a the array to be searched
   * @param fromIndex the index of the first element (inclusive) to be
   *          searched
   * @param toIndex the index of the last element (exclusive) to be searched
   * @param key the value to be searched for
   * @return index of the search key, if it is contained in the array
   *         within the specified range;
   *         otherwise, (-(insertion point) - 1).  The
   *         insertion point is defined as the point at which the
   *         key would be inserted into the array: the index of the first
   *         element in the range greater than the key,
   *         or `toIndex` if all
   *         elements in the range are less than the specified key.  Note
   *         that this guarantees that the return value will be >= 0 if
   *         and only if the key is found.
   * @throws ClassCastException if the search key is not comparable to the
   *         elements of the array within the specified range.
   * @throws IllegalArgumentException
   *         if `fromIndex > toIndex`
   * @throws ArrayIndexOutOfBoundsException
   *         if `fromIndex < 0 or toIndex > a.length`
   * @since 1.6
  */
  static binarySearch(a: any[], fromIndex: number, toIndex: number, key: any): number;
  /**
   * Searches the specified array for the specified object using the binary
   * search algorithm.  The array must be sorted into ascending order
   * according to the specified comparator (as by the
   * {@link #sort(Object[], Comparator) sort(T[], Comparator)}
   * method) prior to making this call.  If it is
   * not sorted, the results are undefined.
   * If the array contains multiple
   * elements equal to the specified object, there is no guarantee which one
   * will be found.
   *
   * @param  the class of the objects in the array
   * @param a the array to be searched
   * @param key the value to be searched for
   * @param c the comparator by which the array is ordered.  A
   *        `null` value indicates that the elements'
   *        {@linkplain Comparable natural ordering} should be used.
   * @return index of the search key, if it is contained in the array;
   *         otherwise, (-(insertion point) - 1).  The
   *         insertion point is defined as the point at which the
   *         key would be inserted into the array: the index of the first
   *         element greater than the key, or `a.length` if all
   *         elements in the array are less than the specified key.  Note
   *         that this guarantees that the return value will be >= 0 if
   *         and only if the key is found.
   * @throws ClassCastException if the array contains elements that are not
   *         mutually comparable using the specified comparator,
   *         or the search key is not comparable to the
   *         elements of the array using this comparator.
  */
  static binarySearch<T>(a: T[], key: T, c: Comparator<any>): number;
  /**
   * Searches a range of
   * the specified array for the specified object using the binary
   * search algorithm.
   * The range must be sorted into ascending order
   * according to the specified comparator (as by the
   * {@link #sort(Object[], int, int, Comparator)
   * sort(T[], int, int, Comparator)}
   * method) prior to making this call.
   * If it is not sorted, the results are undefined.
   * If the range contains multiple elements equal to the specified object,
   * there is no guarantee which one will be found.
   *
   * @param  the class of the objects in the array
   * @param a the array to be searched
   * @param fromIndex the index of the first element (inclusive) to be
   *          searched
   * @param toIndex the index of the last element (exclusive) to be searched
   * @param key the value to be searched for
   * @param c the comparator by which the array is ordered.  A
   *        `null` value indicates that the elements'
   *        {@linkplain Comparable natural ordering} should be used.
   * @return index of the search key, if it is contained in the array
   *         within the specified range;
   *         otherwise, (-(insertion point) - 1).  The
   *         insertion point is defined as the point at which the
   *         key would be inserted into the array: the index of the first
   *         element in the range greater than the key,
   *         or `toIndex` if all
   *         elements in the range are less than the specified key.  Note
   *         that this guarantees that the return value will be >= 0 if
   *         and only if the key is found.
   * @throws ClassCastException if the range contains elements that are not
   *         mutually comparable using the specified comparator,
   *         or the search key is not comparable to the
   *         elements in the range using this comparator.
   * @throws IllegalArgumentException
   *         if `fromIndex > toIndex`
   * @throws ArrayIndexOutOfBoundsException
   *         if `fromIndex < 0 or toIndex > a.length`
   * @since 1.6
  */
  static binarySearch<T>(a: T[], fromIndex: number, toIndex: number, key: T, c: Comparator<any>): number;
  /**
   * Returns `true` if the two specified arrays of longs are
   * equal to one another.  Two arrays are considered equal if both
   * arrays contain the same number of elements, and all corresponding pairs
   * of elements in the two arrays are equal.  In other words, two arrays
   * are equal if they contain the same elements in the same order.  Also,
   * two array references are considered equal if both are `null`.
   *
   * @param a one array to be tested for equality
   * @param a2 the other array to be tested for equality
   * @return `true` if the two arrays are equal
  */
  static equals(a: number[], a2: number[]): boolean;
  /**
   * Returns true if the two specified arrays of longs, over the specified
   * ranges, are equal to one another.
   *
   * Two arrays are considered equal if the number of elements covered by
   * each range is the same, and all corresponding pairs of elements over the
   * specified ranges in the two arrays are equal.  In other words, two arrays
   * are equal if they contain, over the specified ranges, the same elements
   * in the same order.
   *
   * @param a the first array to be tested for equality
   * @param aFromIndex the index (inclusive) of the first element in the
   *                   first array to be tested
   * @param aToIndex the index (exclusive) of the last element in the
   *                 first array to be tested
   * @param b the second array to be tested for equality
   * @param bFromIndex the index (inclusive) of the first element in the
   *                   second array to be tested
   * @param bToIndex the index (exclusive) of the last element in the
   *                 second array to be tested
   * @return `true` if the two arrays, over the specified ranges, are
   *         equal
   * @throws IllegalArgumentException
   *         if `aFromIndex > aToIndex` or
   *         if `bFromIndex > bToIndex`
   * @throws ArrayIndexOutOfBoundsException
   *         if `aFromIndex < 0 or aToIndex > a.length` or
   *         if `bFromIndex < 0 or bToIndex > b.length`
   * @throws NullPointerException
   *         if either array is `null`
   * @since 9
  */
  static equals(a: number[], aFromIndex: number, aToIndex: number, b: number[], bFromIndex: number, bToIndex: number): boolean;
  /**
   * Returns `true` if the two specified arrays of ints are
   * equal to one another.  Two arrays are considered equal if both
   * arrays contain the same number of elements, and all corresponding pairs
   * of elements in the two arrays are equal.  In other words, two arrays
   * are equal if they contain the same elements in the same order.  Also,
   * two array references are considered equal if both are `null`.
   *
   * @param a one array to be tested for equality
   * @param a2 the other array to be tested for equality
   * @return `true` if the two arrays are equal
  */
  static equals(a: number[], a2: number[]): boolean;
  /**
   * Returns true if the two specified arrays of ints, over the specified
   * ranges, are equal to one another.
   *
   * Two arrays are considered equal if the number of elements covered by
   * each range is the same, and all corresponding pairs of elements over the
   * specified ranges in the two arrays are equal.  In other words, two arrays
   * are equal if they contain, over the specified ranges, the same elements
   * in the same order.
   *
   * @param a the first array to be tested for equality
   * @param aFromIndex the index (inclusive) of the first element in the
   *                   first array to be tested
   * @param aToIndex the index (exclusive) of the last element in the
   *                 first array to be tested
   * @param b the second array to be tested for equality
   * @param bFromIndex the index (inclusive) of the first element in the
   *                   second array to be tested
   * @param bToIndex the index (exclusive) of the last element in the
   *                 second array to be tested
   * @return `true` if the two arrays, over the specified ranges, are
   *         equal
   * @throws IllegalArgumentException
   *         if `aFromIndex > aToIndex` or
   *         if `bFromIndex > bToIndex`
   * @throws ArrayIndexOutOfBoundsException
   *         if `aFromIndex < 0 or aToIndex > a.length` or
   *         if `bFromIndex < 0 or bToIndex > b.length`
   * @throws NullPointerException
   *         if either array is `null`
   * @since 9
  */
  static equals(a: number[], aFromIndex: number, aToIndex: number, b: number[], bFromIndex: number, bToIndex: number): boolean;
  /**
   * Returns `true` if the two specified arrays of shorts are
   * equal to one another.  Two arrays are considered equal if both
   * arrays contain the same number of elements, and all corresponding pairs
   * of elements in the two arrays are equal.  In other words, two arrays
   * are equal if they contain the same elements in the same order.  Also,
   * two array references are considered equal if both are `null`.
   *
   * @param a one array to be tested for equality
   * @param a2 the other array to be tested for equality
   * @return `true` if the two arrays are equal
  */
  static equals(a: number[], a2: number[]): boolean;
  /**
   * Returns true if the two specified arrays of shorts, over the specified
   * ranges, are equal to one another.
   *
   * Two arrays are considered equal if the number of elements covered by
   * each range is the same, and all corresponding pairs of elements over the
   * specified ranges in the two arrays are equal.  In other words, two arrays
   * are equal if they contain, over the specified ranges, the same elements
   * in the same order.
   *
   * @param a the first array to be tested for equality
   * @param aFromIndex the index (inclusive) of the first element in the
   *                   first array to be tested
   * @param aToIndex the index (exclusive) of the last element in the
   *                 first array to be tested
   * @param b the second array to be tested for equality
   * @param bFromIndex the index (inclusive) of the first element in the
   *                   second array to be tested
   * @param bToIndex the index (exclusive) of the last element in the
   *                 second array to be tested
   * @return `true` if the two arrays, over the specified ranges, are
   *         equal
   * @throws IllegalArgumentException
   *         if `aFromIndex > aToIndex` or
   *         if `bFromIndex > bToIndex`
   * @throws ArrayIndexOutOfBoundsException
   *         if `aFromIndex < 0 or aToIndex > a.length` or
   *         if `bFromIndex < 0 or bToIndex > b.length`
   * @throws NullPointerException
   *         if either array is `null`
   * @since 9
  */
  static equals(a: number[], aFromIndex: number, aToIndex: number, b: number[], bFromIndex: number, bToIndex: number): boolean;
  /**
   * Returns `true` if the two specified arrays of chars are
   * equal to one another.  Two arrays are considered equal if both
   * arrays contain the same number of elements, and all corresponding pairs
   * of elements in the two arrays are equal.  In other words, two arrays
   * are equal if they contain the same elements in the same order.  Also,
   * two array references are considered equal if both are `null`.
   *
   * @param a one array to be tested for equality
   * @param a2 the other array to be tested for equality
   * @return `true` if the two arrays are equal
  */
  static equals(a: string[], a2: string[]): boolean;
  /**
   * Returns true if the two specified arrays of chars, over the specified
   * ranges, are equal to one another.
   *
   * Two arrays are considered equal if the number of elements covered by
   * each range is the same, and all corresponding pairs of elements over the
   * specified ranges in the two arrays are equal.  In other words, two arrays
   * are equal if they contain, over the specified ranges, the same elements
   * in the same order.
   *
   * @param a the first array to be tested for equality
   * @param aFromIndex the index (inclusive) of the first element in the
   *                   first array to be tested
   * @param aToIndex the index (exclusive) of the last element in the
   *                 first array to be tested
   * @param b the second array to be tested for equality
   * @param bFromIndex the index (inclusive) of the first element in the
   *                   second array to be tested
   * @param bToIndex the index (exclusive) of the last element in the
   *                 second array to be tested
   * @return `true` if the two arrays, over the specified ranges, are
   *         equal
   * @throws IllegalArgumentException
   *         if `aFromIndex > aToIndex` or
   *         if `bFromIndex > bToIndex`
   * @throws ArrayIndexOutOfBoundsException
   *         if `aFromIndex < 0 or aToIndex > a.length` or
   *         if `bFromIndex < 0 or bToIndex > b.length`
   * @throws NullPointerException
   *         if either array is `null`
   * @since 9
  */
  static equals(a: string[], aFromIndex: number, aToIndex: number, b: string[], bFromIndex: number, bToIndex: number): boolean;
  /**
   * Returns `true` if the two specified arrays of bytes are
   * equal to one another.  Two arrays are considered equal if both
   * arrays contain the same number of elements, and all corresponding pairs
   * of elements in the two arrays are equal.  In other words, two arrays
   * are equal if they contain the same elements in the same order.  Also,
   * two array references are considered equal if both are `null`.
   *
   * @param a one array to be tested for equality
   * @param a2 the other array to be tested for equality
   * @return `true` if the two arrays are equal
  */
  static equals(a: number[], a2: number[]): boolean;
  /**
   * Returns true if the two specified arrays of bytes, over the specified
   * ranges, are equal to one another.
   *
   * Two arrays are considered equal if the number of elements covered by
   * each range is the same, and all corresponding pairs of elements over the
   * specified ranges in the two arrays are equal.  In other words, two arrays
   * are equal if they contain, over the specified ranges, the same elements
   * in the same order.
   *
   * @param a the first array to be tested for equality
   * @param aFromIndex the index (inclusive) of the first element in the
   *                   first array to be tested
   * @param aToIndex the index (exclusive) of the last element in the
   *                 first array to be tested
   * @param b the second array to be tested for equality
   * @param bFromIndex the index (inclusive) of the first element in the
   *                   second array to be tested
   * @param bToIndex the index (exclusive) of the last element in the
   *                 second array to be tested
   * @return `true` if the two arrays, over the specified ranges, are
   *         equal
   * @throws IllegalArgumentException
   *         if `aFromIndex > aToIndex` or
   *         if `bFromIndex > bToIndex`
   * @throws ArrayIndexOutOfBoundsException
   *         if `aFromIndex < 0 or aToIndex > a.length` or
   *         if `bFromIndex < 0 or bToIndex > b.length`
   * @throws NullPointerException
   *         if either array is `null`
   * @since 9
  */
  static equals(a: number[], aFromIndex: number, aToIndex: number, b: number[], bFromIndex: number, bToIndex: number): boolean;
  /**
   * Returns `true` if the two specified arrays of booleans are
   * equal to one another.  Two arrays are considered equal if both
   * arrays contain the same number of elements, and all corresponding pairs
   * of elements in the two arrays are equal.  In other words, two arrays
   * are equal if they contain the same elements in the same order.  Also,
   * two array references are considered equal if both are `null`.
   *
   * @param a one array to be tested for equality
   * @param a2 the other array to be tested for equality
   * @return `true` if the two arrays are equal
  */
  static equals(a: boolean[], a2: boolean[]): boolean;
  /**
   * Returns true if the two specified arrays of booleans, over the specified
   * ranges, are equal to one another.
   *
   * Two arrays are considered equal if the number of elements covered by
   * each range is the same, and all corresponding pairs of elements over the
   * specified ranges in the two arrays are equal.  In other words, two arrays
   * are equal if they contain, over the specified ranges, the same elements
   * in the same order.
   *
   * @param a the first array to be tested for equality
   * @param aFromIndex the index (inclusive) of the first element in the
   *                   first array to be tested
   * @param aToIndex the index (exclusive) of the last element in the
   *                 first array to be tested
   * @param b the second array to be tested for equality
   * @param bFromIndex the index (inclusive) of the first element in the
   *                   second array to be tested
   * @param bToIndex the index (exclusive) of the last element in the
   *                 second array to be tested
   * @return `true` if the two arrays, over the specified ranges, are
   *         equal
   * @throws IllegalArgumentException
   *         if `aFromIndex > aToIndex` or
   *         if `bFromIndex > bToIndex`
   * @throws ArrayIndexOutOfBoundsException
   *         if `aFromIndex < 0 or aToIndex > a.length` or
   *         if `bFromIndex < 0 or bToIndex > b.length`
   * @throws NullPointerException
   *         if either array is `null`
   * @since 9
  */
  static equals(a: boolean[], aFromIndex: number, aToIndex: number, b: boolean[], bFromIndex: number, bToIndex: number): boolean;
  /**
   * Returns `true` if the two specified arrays of doubles are
   * equal to one another.  Two arrays are considered equal if both
   * arrays contain the same number of elements, and all corresponding pairs
   * of elements in the two arrays are equal.  In other words, two arrays
   * are equal if they contain the same elements in the same order.  Also,
   * two array references are considered equal if both are `null`.
   *
   * Two doubles `d1` and `d2` are considered equal if:
   *     `new Double(d1).equals(new Double(d2))`
   * (Unlike the `==` operator, this method considers
   * `NaN` equal to itself, and 0.0d unequal to -0.0d.)
   *
   * @param a one array to be tested for equality
   * @param a2 the other array to be tested for equality
   * @return `true` if the two arrays are equal
   * @see Double#equals(Object)
  */
  static equals(a: number[], a2: number[]): boolean;
  /**
   * Returns true if the two specified arrays of doubles, over the specified
   * ranges, are equal to one another.
   *
   * Two arrays are considered equal if the number of elements covered by
   * each range is the same, and all corresponding pairs of elements over the
   * specified ranges in the two arrays are equal.  In other words, two arrays
   * are equal if they contain, over the specified ranges, the same elements
   * in the same order.
   *
   * Two doubles `d1` and `d2` are considered equal if:
   *     `new Double(d1).equals(new Double(d2))`
   * (Unlike the `==` operator, this method considers
   * `NaN` equal to itself, and 0.0d unequal to -0.0d.)
   *
   * @param a the first array to be tested for equality
   * @param aFromIndex the index (inclusive) of the first element in the
   *                   first array to be tested
   * @param aToIndex the index (exclusive) of the last element in the
   *                 first array to be tested
   * @param b the second array to be tested for equality
   * @param bFromIndex the index (inclusive) of the first element in the
   *                   second array to be tested
   * @param bToIndex the index (exclusive) of the last element in the
   *                 second array to be tested
   * @return `true` if the two arrays, over the specified ranges, are
   *         equal
   * @throws IllegalArgumentException
   *         if `aFromIndex > aToIndex` or
   *         if `bFromIndex > bToIndex`
   * @throws ArrayIndexOutOfBoundsException
   *         if `aFromIndex < 0 or aToIndex > a.length` or
   *         if `bFromIndex < 0 or bToIndex > b.length`
   * @throws NullPointerException
   *         if either array is `null`
   * @see Double#equals(Object)
   * @since 9
  */
  static equals(a: number[], aFromIndex: number, aToIndex: number, b: number[], bFromIndex: number, bToIndex: number): boolean;
  /**
   * Returns `true` if the two specified arrays of floats are
   * equal to one another.  Two arrays are considered equal if both
   * arrays contain the same number of elements, and all corresponding pairs
   * of elements in the two arrays are equal.  In other words, two arrays
   * are equal if they contain the same elements in the same order.  Also,
   * two array references are considered equal if both are `null`.
   *
   * Two floats `f1` and `f2` are considered equal if:
   *     `new Float(f1).equals(new Float(f2))`
   * (Unlike the `==` operator, this method considers
   * `NaN` equal to itself, and 0.0f unequal to -0.0f.)
   *
   * @param a one array to be tested for equality
   * @param a2 the other array to be tested for equality
   * @return `true` if the two arrays are equal
   * @see Float#equals(Object)
  */
  static equals(a: number[], a2: number[]): boolean;
  /**
   * Returns true if the two specified arrays of floats, over the specified
   * ranges, are equal to one another.
   *
   * Two arrays are considered equal if the number of elements covered by
   * each range is the same, and all corresponding pairs of elements over the
   * specified ranges in the two arrays are equal.  In other words, two arrays
   * are equal if they contain, over the specified ranges, the same elements
   * in the same order.
   *
   * Two floats `f1` and `f2` are considered equal if:
   *     `new Float(f1).equals(new Float(f2))`
   * (Unlike the `==` operator, this method considers
   * `NaN` equal to itself, and 0.0f unequal to -0.0f.)
   *
   * @param a the first array to be tested for equality
   * @param aFromIndex the index (inclusive) of the first element in the
   *                   first array to be tested
   * @param aToIndex the index (exclusive) of the last element in the
   *                 first array to be tested
   * @param b the second array to be tested for equality
   * @param bFromIndex the index (inclusive) of the first element in the
   *                   second array to be tested
   * @param bToIndex the index (exclusive) of the last element in the
   *                 second array to be tested
   * @return `true` if the two arrays, over the specified ranges, are
   *         equal
   * @throws IllegalArgumentException
   *         if `aFromIndex > aToIndex` or
   *         if `bFromIndex > bToIndex`
   * @throws ArrayIndexOutOfBoundsException
   *         if `aFromIndex < 0 or aToIndex > a.length` or
   *         if `bFromIndex < 0 or bToIndex > b.length`
   * @throws NullPointerException
   *         if either array is `null`
   * @see Float#equals(Object)
   * @since 9
  */
  static equals(a: number[], aFromIndex: number, aToIndex: number, b: number[], bFromIndex: number, bToIndex: number): boolean;
  /**
   * Returns `true` if the two specified arrays of Objects are
   * equal to one another.  The two arrays are considered equal if
   * both arrays contain the same number of elements, and all corresponding
   * pairs of elements in the two arrays are equal.  Two objects `e1`
   * and `e2` are considered equal if
   * `Objects.equals(e1, e2)`.
   * In other words, the two arrays are equal if
   * they contain the same elements in the same order.  Also, two array
   * references are considered equal if both are `null`.
   *
   * @param a one array to be tested for equality
   * @param a2 the other array to be tested for equality
   * @return `true` if the two arrays are equal
  */
  static equals(a: any[], a2: any[]): boolean;
  /**
   * Returns true if the two specified arrays of Objects, over the specified
   * ranges, are equal to one another.
   *
   * Two arrays are considered equal if the number of elements covered by
   * each range is the same, and all corresponding pairs of elements over the
   * specified ranges in the two arrays are equal.  In other words, two arrays
   * are equal if they contain, over the specified ranges, the same elements
   * in the same order.
   *
   * Two objects `e1` and `e2` are considered equal if
   * `Objects.equals(e1, e2)`.
   *
   * @param a the first array to be tested for equality
   * @param aFromIndex the index (inclusive) of the first element in the
   *                   first array to be tested
   * @param aToIndex the index (exclusive) of the last element in the
   *                 first array to be tested
   * @param b the second array to be tested for equality
   * @param bFromIndex the index (inclusive) of the first element in the
   *                   second array to be tested
   * @param bToIndex the index (exclusive) of the last element in the
   *                 second array to be tested
   * @return `true` if the two arrays, over the specified ranges, are
   *         equal
   * @throws IllegalArgumentException
   *         if `aFromIndex > aToIndex` or
   *         if `bFromIndex > bToIndex`
   * @throws ArrayIndexOutOfBoundsException
   *         if `aFromIndex < 0 or aToIndex > a.length` or
   *         if `bFromIndex < 0 or bToIndex > b.length`
   * @throws NullPointerException
   *         if either array is `null`
   * @since 9
  */
  static equals(a: any[], aFromIndex: number, aToIndex: number, b: any[], bFromIndex: number, bToIndex: number): boolean;
  /**
   * Returns `true` if the two specified arrays of Objects are
   * equal to one another.
   *
   * Two arrays are considered equal if both arrays contain the same number
   * of elements, and all corresponding pairs of elements in the two arrays
   * are equal.  In other words, the two arrays are equal if they contain the
   * same elements in the same order.  Also, two array references are
   * considered equal if both are `null`.
   *
   * Two objects `e1` and `e2` are considered equal if,
   * given the specified comparator, `cmp.compare(e1, e2) == 0`.
   *
   * @param a one array to be tested for equality
   * @param a2 the other array to be tested for equality
   * @param cmp the comparator to compare array elements
   * @param  the type of array elements
   * @return `true` if the two arrays are equal
   * @throws NullPointerException if the comparator is `null`
   * @since 9
  */
  static equals<T>(a: T[], a2: T[], cmp: Comparator<any>): boolean;
  /**
   * Returns true if the two specified arrays of Objects, over the specified
   * ranges, are equal to one another.
   *
   * Two arrays are considered equal if the number of elements covered by
   * each range is the same, and all corresponding pairs of elements over the
   * specified ranges in the two arrays are equal.  In other words, two arrays
   * are equal if they contain, over the specified ranges, the same elements
   * in the same order.
   *
   * Two objects `e1` and `e2` are considered equal if,
   * given the specified comparator, `cmp.compare(e1, e2) == 0`.
   *
   * @param a the first array to be tested for equality
   * @param aFromIndex the index (inclusive) of the first element in the
   *                   first array to be tested
   * @param aToIndex the index (exclusive) of the last element in the
   *                 first array to be tested
   * @param b the second array to be tested for equality
   * @param bFromIndex the index (inclusive) of the first element in the
   *                   second array to be tested
   * @param bToIndex the index (exclusive) of the last element in the
   *                 second array to be tested
   * @param cmp the comparator to compare array elements
   * @param  the type of array elements
   * @return `true` if the two arrays, over the specified ranges, are
   *         equal
   * @throws IllegalArgumentException
   *         if `aFromIndex > aToIndex` or
   *         if `bFromIndex > bToIndex`
   * @throws ArrayIndexOutOfBoundsException
   *         if `aFromIndex < 0 or aToIndex > a.length` or
   *         if `bFromIndex < 0 or bToIndex > b.length`
   * @throws NullPointerException
   *         if either array or the comparator is `null`
   * @since 9
  */
  static equals<T>(a: T[], aFromIndex: number, aToIndex: number, b: T[], bFromIndex: number, bToIndex: number, cmp: Comparator<any>): boolean;
  /**
   * Assigns the specified long value to each element of the specified array
   * of longs.
   *
   * @param a the array to be filled
   * @param val the value to be stored in all elements of the array
  */
  static fill(a: number[], val: number): void;
  /**
   * Assigns the specified long value to each element of the specified
   * range of the specified array of longs.  The range to be filled
   * extends from index `fromIndex`, inclusive, to index
   * `toIndex`, exclusive.  (If `fromIndex==toIndex`, the
   * range to be filled is empty.)
   *
   * @param a the array to be filled
   * @param fromIndex the index of the first element (inclusive) to be
   *        filled with the specified value
   * @param toIndex the index of the last element (exclusive) to be
   *        filled with the specified value
   * @param val the value to be stored in all elements of the array
   * @throws IllegalArgumentException if `fromIndex > toIndex`
   * @throws ArrayIndexOutOfBoundsException if `fromIndex < 0` or
   *         `toIndex > a.length`
  */
  static fill(a: number[], fromIndex: number, toIndex: number, val: number): void;
  /**
   * Assigns the specified int value to each element of the specified array
   * of ints.
   *
   * @param a the array to be filled
   * @param val the value to be stored in all elements of the array
  */
  static fill(a: number[], val: number): void;
  /**
   * Assigns the specified int value to each element of the specified
   * range of the specified array of ints.  The range to be filled
   * extends from index `fromIndex`, inclusive, to index
   * `toIndex`, exclusive.  (If `fromIndex==toIndex`, the
   * range to be filled is empty.)
   *
   * @param a the array to be filled
   * @param fromIndex the index of the first element (inclusive) to be
   *        filled with the specified value
   * @param toIndex the index of the last element (exclusive) to be
   *        filled with the specified value
   * @param val the value to be stored in all elements of the array
   * @throws IllegalArgumentException if `fromIndex > toIndex`
   * @throws ArrayIndexOutOfBoundsException if `fromIndex < 0` or
   *         `toIndex > a.length`
  */
  static fill(a: number[], fromIndex: number, toIndex: number, val: number): void;
  /**
   * Assigns the specified short value to each element of the specified array
   * of shorts.
   *
   * @param a the array to be filled
   * @param val the value to be stored in all elements of the array
  */
  static fill(a: number[], val: number): void;
  /**
   * Assigns the specified short value to each element of the specified
   * range of the specified array of shorts.  The range to be filled
   * extends from index `fromIndex`, inclusive, to index
   * `toIndex`, exclusive.  (If `fromIndex==toIndex`, the
   * range to be filled is empty.)
   *
   * @param a the array to be filled
   * @param fromIndex the index of the first element (inclusive) to be
   *        filled with the specified value
   * @param toIndex the index of the last element (exclusive) to be
   *        filled with the specified value
   * @param val the value to be stored in all elements of the array
   * @throws IllegalArgumentException if `fromIndex > toIndex`
   * @throws ArrayIndexOutOfBoundsException if `fromIndex < 0` or
   *         `toIndex > a.length`
  */
  static fill(a: number[], fromIndex: number, toIndex: number, val: number): void;
  /**
   * Assigns the specified char value to each element of the specified array
   * of chars.
   *
   * @param a the array to be filled
   * @param val the value to be stored in all elements of the array
  */
  static fill(a: string[], val: string): void;
  /**
   * Assigns the specified char value to each element of the specified
   * range of the specified array of chars.  The range to be filled
   * extends from index `fromIndex`, inclusive, to index
   * `toIndex`, exclusive.  (If `fromIndex==toIndex`, the
   * range to be filled is empty.)
   *
   * @param a the array to be filled
   * @param fromIndex the index of the first element (inclusive) to be
   *        filled with the specified value
   * @param toIndex the index of the last element (exclusive) to be
   *        filled with the specified value
   * @param val the value to be stored in all elements of the array
   * @throws IllegalArgumentException if `fromIndex > toIndex`
   * @throws ArrayIndexOutOfBoundsException if `fromIndex < 0` or
   *         `toIndex > a.length`
  */
  static fill(a: string[], fromIndex: number, toIndex: number, val: string): void;
  /**
   * Assigns the specified byte value to each element of the specified array
   * of bytes.
   *
   * @param a the array to be filled
   * @param val the value to be stored in all elements of the array
  */
  static fill(a: number[], val: number): void;
  /**
   * Assigns the specified byte value to each element of the specified
   * range of the specified array of bytes.  The range to be filled
   * extends from index `fromIndex`, inclusive, to index
   * `toIndex`, exclusive.  (If `fromIndex==toIndex`, the
   * range to be filled is empty.)
   *
   * @param a the array to be filled
   * @param fromIndex the index of the first element (inclusive) to be
   *        filled with the specified value
   * @param toIndex the index of the last element (exclusive) to be
   *        filled with the specified value
   * @param val the value to be stored in all elements of the array
   * @throws IllegalArgumentException if `fromIndex > toIndex`
   * @throws ArrayIndexOutOfBoundsException if `fromIndex < 0` or
   *         `toIndex > a.length`
  */
  static fill(a: number[], fromIndex: number, toIndex: number, val: number): void;
  /**
   * Assigns the specified boolean value to each element of the specified
   * array of booleans.
   *
   * @param a the array to be filled
   * @param val the value to be stored in all elements of the array
  */
  static fill(a: boolean[], val: boolean): void;
  /**
   * Assigns the specified boolean value to each element of the specified
   * range of the specified array of booleans.  The range to be filled
   * extends from index `fromIndex`, inclusive, to index
   * `toIndex`, exclusive.  (If `fromIndex==toIndex`, the
   * range to be filled is empty.)
   *
   * @param a the array to be filled
   * @param fromIndex the index of the first element (inclusive) to be
   *        filled with the specified value
   * @param toIndex the index of the last element (exclusive) to be
   *        filled with the specified value
   * @param val the value to be stored in all elements of the array
   * @throws IllegalArgumentException if `fromIndex > toIndex`
   * @throws ArrayIndexOutOfBoundsException if `fromIndex < 0` or
   *         `toIndex > a.length`
  */
  static fill(a: boolean[], fromIndex: number, toIndex: number, val: boolean): void;
  /**
   * Assigns the specified double value to each element of the specified
   * array of doubles.
   *
   * @param a the array to be filled
   * @param val the value to be stored in all elements of the array
  */
  static fill(a: number[], val: number): void;
  /**
   * Assigns the specified double value to each element of the specified
   * range of the specified array of doubles.  The range to be filled
   * extends from index `fromIndex`, inclusive, to index
   * `toIndex`, exclusive.  (If `fromIndex==toIndex`, the
   * range to be filled is empty.)
   *
   * @param a the array to be filled
   * @param fromIndex the index of the first element (inclusive) to be
   *        filled with the specified value
   * @param toIndex the index of the last element (exclusive) to be
   *        filled with the specified value
   * @param val the value to be stored in all elements of the array
   * @throws IllegalArgumentException if `fromIndex > toIndex`
   * @throws ArrayIndexOutOfBoundsException if `fromIndex < 0` or
   *         `toIndex > a.length`
  */
  static fill(a: number[], fromIndex: number, toIndex: number, val: number): void;
  /**
   * Assigns the specified float value to each element of the specified array
   * of floats.
   *
   * @param a the array to be filled
   * @param val the value to be stored in all elements of the array
  */
  static fill(a: number[], val: number): void;
  /**
   * Assigns the specified float value to each element of the specified
   * range of the specified array of floats.  The range to be filled
   * extends from index `fromIndex`, inclusive, to index
   * `toIndex`, exclusive.  (If `fromIndex==toIndex`, the
   * range to be filled is empty.)
   *
   * @param a the array to be filled
   * @param fromIndex the index of the first element (inclusive) to be
   *        filled with the specified value
   * @param toIndex the index of the last element (exclusive) to be
   *        filled with the specified value
   * @param val the value to be stored in all elements of the array
   * @throws IllegalArgumentException if `fromIndex > toIndex`
   * @throws ArrayIndexOutOfBoundsException if `fromIndex < 0` or
   *         `toIndex > a.length`
  */
  static fill(a: number[], fromIndex: number, toIndex: number, val: number): void;
  /**
   * Assigns the specified Object reference to each element of the specified
   * array of Objects.
   *
   * @param a the array to be filled
   * @param val the value to be stored in all elements of the array
   * @throws ArrayStoreException if the specified value is not of a
   *         runtime type that can be stored in the specified array
  */
  static fill(a: any[], val: any): void;
  /**
   * Assigns the specified Object reference to each element of the specified
   * range of the specified array of Objects.  The range to be filled
   * extends from index `fromIndex`, inclusive, to index
   * `toIndex`, exclusive.  (If `fromIndex==toIndex`, the
   * range to be filled is empty.)
   *
   * @param a the array to be filled
   * @param fromIndex the index of the first element (inclusive) to be
   *        filled with the specified value
   * @param toIndex the index of the last element (exclusive) to be
   *        filled with the specified value
   * @param val the value to be stored in all elements of the array
   * @throws IllegalArgumentException if `fromIndex > toIndex`
   * @throws ArrayIndexOutOfBoundsException if `fromIndex < 0` or
   *         `toIndex > a.length`
   * @throws ArrayStoreException if the specified value is not of a
   *         runtime type that can be stored in the specified array
  */
  static fill(a: any[], fromIndex: number, toIndex: number, val: any): void;
  /**
   * Copies the specified array, truncating or padding with nulls (if necessary)
   * so the copy has the specified length.  For all indices that are
   * valid in both the original array and the copy, the two arrays will
   * contain identical values.  For any indices that are valid in the
   * copy but not the original, the copy will contain `null`.
   * Such indices will exist if and only if the specified length
   * is greater than that of the original array.
   * The resulting array is of exactly the same class as the original array.
   *
   * @param  the class of the objects in the array
   * @param original the array to be copied
   * @param newLength the length of the copy to be returned
   * @return a copy of the original array, truncated or padded with nulls
   *     to obtain the specified length
   * @throws NegativeArraySizeException if `newLength` is negative
   * @throws NullPointerException if `original` is null
   * @since 1.6
  */
  static copyOf<T>(original: T[], newLength: number): T[];
  /**
   * Copies the specified array, truncating or padding with nulls (if necessary)
   * so the copy has the specified length.  For all indices that are
   * valid in both the original array and the copy, the two arrays will
   * contain identical values.  For any indices that are valid in the
   * copy but not the original, the copy will contain `null`.
   * Such indices will exist if and only if the specified length
   * is greater than that of the original array.
   * The resulting array is of the class `newType`.
   *
   * @param  the class of the objects in the original array
   * @param  the class of the objects in the returned array
   * @param original the array to be copied
   * @param newLength the length of the copy to be returned
   * @param newType the class of the copy to be returned
   * @return a copy of the original array, truncated or padded with nulls
   *     to obtain the specified length
   * @throws NegativeArraySizeException if `newLength` is negative
   * @throws NullPointerException if `original` is null
   * @throws ArrayStoreException if an element copied from
   *     `original` is not of a runtime type that can be stored in
   *     an array of class `newType`
   * @since 1.6
  */
  static copyOf<T, U>(original: U[], newLength: number, newType: Class<T[]>): T[];
  /**
   * Copies the specified array, truncating or padding with zeros (if necessary)
   * so the copy has the specified length.  For all indices that are
   * valid in both the original array and the copy, the two arrays will
   * contain identical values.  For any indices that are valid in the
   * copy but not the original, the copy will contain `(byte)0`.
   * Such indices will exist if and only if the specified length
   * is greater than that of the original array.
   *
   * @param original the array to be copied
   * @param newLength the length of the copy to be returned
   * @return a copy of the original array, truncated or padded with zeros
   *     to obtain the specified length
   * @throws NegativeArraySizeException if `newLength` is negative
   * @throws NullPointerException if `original` is null
   * @since 1.6
  */
  static copyOf(original: number[], newLength: number): number[];
  /**
   * Copies the specified array, truncating or padding with zeros (if necessary)
   * so the copy has the specified length.  For all indices that are
   * valid in both the original array and the copy, the two arrays will
   * contain identical values.  For any indices that are valid in the
   * copy but not the original, the copy will contain `(short)0`.
   * Such indices will exist if and only if the specified length
   * is greater than that of the original array.
   *
   * @param original the array to be copied
   * @param newLength the length of the copy to be returned
   * @return a copy of the original array, truncated or padded with zeros
   *     to obtain the specified length
   * @throws NegativeArraySizeException if `newLength` is negative
   * @throws NullPointerException if `original` is null
   * @since 1.6
  */
  static copyOf(original: number[], newLength: number): number[];
  /**
   * Copies the specified array, truncating or padding with zeros (if necessary)
   * so the copy has the specified length.  For all indices that are
   * valid in both the original array and the copy, the two arrays will
   * contain identical values.  For any indices that are valid in the
   * copy but not the original, the copy will contain `0`.
   * Such indices will exist if and only if the specified length
   * is greater than that of the original array.
   *
   * @param original the array to be copied
   * @param newLength the length of the copy to be returned
   * @return a copy of the original array, truncated or padded with zeros
   *     to obtain the specified length
   * @throws NegativeArraySizeException if `newLength` is negative
   * @throws NullPointerException if `original` is null
   * @since 1.6
  */
  static copyOf(original: number[], newLength: number): number[];
  /**
   * Copies the specified array, truncating or padding with zeros (if necessary)
   * so the copy has the specified length.  For all indices that are
   * valid in both the original array and the copy, the two arrays will
   * contain identical values.  For any indices that are valid in the
   * copy but not the original, the copy will contain `0L`.
   * Such indices will exist if and only if the specified length
   * is greater than that of the original array.
   *
   * @param original the array to be copied
   * @param newLength the length of the copy to be returned
   * @return a copy of the original array, truncated or padded with zeros
   *     to obtain the specified length
   * @throws NegativeArraySizeException if `newLength` is negative
   * @throws NullPointerException if `original` is null
   * @since 1.6
  */
  static copyOf(original: number[], newLength: number): number[];
  /**
   * Copies the specified array, truncating or padding with null characters (if necessary)
   * so the copy has the specified length.  For all indices that are valid
   * in both the original array and the copy, the two arrays will contain
   * identical values.  For any indices that are valid in the copy but not
   * the original, the copy will contain `'\u005cu0000'`.  Such indices
   * will exist if and only if the specified length is greater than that of
   * the original array.
   *
   * @param original the array to be copied
   * @param newLength the length of the copy to be returned
   * @return a copy of the original array, truncated or padded with null characters
   *     to obtain the specified length
   * @throws NegativeArraySizeException if `newLength` is negative
   * @throws NullPointerException if `original` is null
   * @since 1.6
  */
  static copyOf(original: string[], newLength: number): string[];
  /**
   * Copies the specified array, truncating or padding with zeros (if necessary)
   * so the copy has the specified length.  For all indices that are
   * valid in both the original array and the copy, the two arrays will
   * contain identical values.  For any indices that are valid in the
   * copy but not the original, the copy will contain `0f`.
   * Such indices will exist if and only if the specified length
   * is greater than that of the original array.
   *
   * @param original the array to be copied
   * @param newLength the length of the copy to be returned
   * @return a copy of the original array, truncated or padded with zeros
   *     to obtain the specified length
   * @throws NegativeArraySizeException if `newLength` is negative
   * @throws NullPointerException if `original` is null
   * @since 1.6
  */
  static copyOf(original: number[], newLength: number): number[];
  /**
   * Copies the specified array, truncating or padding with zeros (if necessary)
   * so the copy has the specified length.  For all indices that are
   * valid in both the original array and the copy, the two arrays will
   * contain identical values.  For any indices that are valid in the
   * copy but not the original, the copy will contain `0d`.
   * Such indices will exist if and only if the specified length
   * is greater than that of the original array.
   *
   * @param original the array to be copied
   * @param newLength the length of the copy to be returned
   * @return a copy of the original array, truncated or padded with zeros
   *     to obtain the specified length
   * @throws NegativeArraySizeException if `newLength` is negative
   * @throws NullPointerException if `original` is null
   * @since 1.6
  */
  static copyOf(original: number[], newLength: number): number[];
  /**
   * Copies the specified array, truncating or padding with `false` (if necessary)
   * so the copy has the specified length.  For all indices that are
   * valid in both the original array and the copy, the two arrays will
   * contain identical values.  For any indices that are valid in the
   * copy but not the original, the copy will contain `false`.
   * Such indices will exist if and only if the specified length
   * is greater than that of the original array.
   *
   * @param original the array to be copied
   * @param newLength the length of the copy to be returned
   * @return a copy of the original array, truncated or padded with false elements
   *     to obtain the specified length
   * @throws NegativeArraySizeException if `newLength` is negative
   * @throws NullPointerException if `original` is null
   * @since 1.6
  */
  static copyOf(original: boolean[], newLength: number): boolean[];
  /**
   * Copies the specified range of the specified array into a new array.
   * The initial index of the range (`from`) must lie between zero
   * and `original.length`, inclusive.  The value at
   * `original[from]` is placed into the initial element of the copy
   * (unless `from == original.length` or `from == to`).
   * Values from subsequent elements in the original array are placed into
   * subsequent elements in the copy.  The final index of the range
   * (`to`), which must be greater than or equal to `from`,
   * may be greater than `original.length`, in which case
   * `null` is placed in all elements of the copy whose index is
   * greater than or equal to `original.length - from`.  The length
   * of the returned array will be `to - from`.
   * 
   * The resulting array is of exactly the same class as the original array.
   *
   * @param  the class of the objects in the array
   * @param original the array from which a range is to be copied
   * @param from the initial index of the range to be copied, inclusive
   * @param to the final index of the range to be copied, exclusive.
   *     (This index may lie outside the array.)
   * @return a new array containing the specified range from the original array,
   *     truncated or padded with nulls to obtain the required length
   * @throws ArrayIndexOutOfBoundsException if `from < 0`
   *     or `from > original.length`
   * @throws IllegalArgumentException if `from > to`
   * @throws NullPointerException if `original` is null
   * @since 1.6
  */
  static copyOfRange<T>(original: T[], from: number, to: number): T[];
  /**
   * Copies the specified range of the specified array into a new array.
   * The initial index of the range (`from`) must lie between zero
   * and `original.length`, inclusive.  The value at
   * `original[from]` is placed into the initial element of the copy
   * (unless `from == original.length` or `from == to`).
   * Values from subsequent elements in the original array are placed into
   * subsequent elements in the copy.  The final index of the range
   * (`to`), which must be greater than or equal to `from`,
   * may be greater than `original.length`, in which case
   * `null` is placed in all elements of the copy whose index is
   * greater than or equal to `original.length - from`.  The length
   * of the returned array will be `to - from`.
   * The resulting array is of the class `newType`.
   *
   * @param  the class of the objects in the original array
   * @param  the class of the objects in the returned array
   * @param original the array from which a range is to be copied
   * @param from the initial index of the range to be copied, inclusive
   * @param to the final index of the range to be copied, exclusive.
   *     (This index may lie outside the array.)
   * @param newType the class of the copy to be returned
   * @return a new array containing the specified range from the original array,
   *     truncated or padded with nulls to obtain the required length
   * @throws ArrayIndexOutOfBoundsException if `from < 0`
   *     or `from > original.length`
   * @throws IllegalArgumentException if `from > to`
   * @throws NullPointerException if `original` is null
   * @throws ArrayStoreException if an element copied from
   *     `original` is not of a runtime type that can be stored in
   *     an array of class `newType`.
   * @since 1.6
  */
  static copyOfRange<T, U>(original: U[], from: number, to: number, newType: Class<T[]>): T[];
  /**
   * Copies the specified range of the specified array into a new array.
   * The initial index of the range (`from`) must lie between zero
   * and `original.length`, inclusive.  The value at
   * `original[from]` is placed into the initial element of the copy
   * (unless `from == original.length` or `from == to`).
   * Values from subsequent elements in the original array are placed into
   * subsequent elements in the copy.  The final index of the range
   * (`to`), which must be greater than or equal to `from`,
   * may be greater than `original.length`, in which case
   * `(byte)0` is placed in all elements of the copy whose index is
   * greater than or equal to `original.length - from`.  The length
   * of the returned array will be `to - from`.
   *
   * @param original the array from which a range is to be copied
   * @param from the initial index of the range to be copied, inclusive
   * @param to the final index of the range to be copied, exclusive.
   *     (This index may lie outside the array.)
   * @return a new array containing the specified range from the original array,
   *     truncated or padded with zeros to obtain the required length
   * @throws ArrayIndexOutOfBoundsException if `from < 0`
   *     or `from > original.length`
   * @throws IllegalArgumentException if `from > to`
   * @throws NullPointerException if `original` is null
   * @since 1.6
  */
  static copyOfRange(original: number[], from: number, to: number): number[];
  /**
   * Copies the specified range of the specified array into a new array.
   * The initial index of the range (`from`) must lie between zero
   * and `original.length`, inclusive.  The value at
   * `original[from]` is placed into the initial element of the copy
   * (unless `from == original.length` or `from == to`).
   * Values from subsequent elements in the original array are placed into
   * subsequent elements in the copy.  The final index of the range
   * (`to`), which must be greater than or equal to `from`,
   * may be greater than `original.length`, in which case
   * `(short)0` is placed in all elements of the copy whose index is
   * greater than or equal to `original.length - from`.  The length
   * of the returned array will be `to - from`.
   *
   * @param original the array from which a range is to be copied
   * @param from the initial index of the range to be copied, inclusive
   * @param to the final index of the range to be copied, exclusive.
   *     (This index may lie outside the array.)
   * @return a new array containing the specified range from the original array,
   *     truncated or padded with zeros to obtain the required length
   * @throws ArrayIndexOutOfBoundsException if `from < 0`
   *     or `from > original.length`
   * @throws IllegalArgumentException if `from > to`
   * @throws NullPointerException if `original` is null
   * @since 1.6
  */
  static copyOfRange(original: number[], from: number, to: number): number[];
  /**
   * Copies the specified range of the specified array into a new array.
   * The initial index of the range (`from`) must lie between zero
   * and `original.length`, inclusive.  The value at
   * `original[from]` is placed into the initial element of the copy
   * (unless `from == original.length` or `from == to`).
   * Values from subsequent elements in the original array are placed into
   * subsequent elements in the copy.  The final index of the range
   * (`to`), which must be greater than or equal to `from`,
   * may be greater than `original.length`, in which case
   * `0` is placed in all elements of the copy whose index is
   * greater than or equal to `original.length - from`.  The length
   * of the returned array will be `to - from`.
   *
   * @param original the array from which a range is to be copied
   * @param from the initial index of the range to be copied, inclusive
   * @param to the final index of the range to be copied, exclusive.
   *     (This index may lie outside the array.)
   * @return a new array containing the specified range from the original array,
   *     truncated or padded with zeros to obtain the required length
   * @throws ArrayIndexOutOfBoundsException if `from < 0`
   *     or `from > original.length`
   * @throws IllegalArgumentException if `from > to`
   * @throws NullPointerException if `original` is null
   * @since 1.6
  */
  static copyOfRange(original: number[], from: number, to: number): number[];
  /**
   * Copies the specified range of the specified array into a new array.
   * The initial index of the range (`from`) must lie between zero
   * and `original.length`, inclusive.  The value at
   * `original[from]` is placed into the initial element of the copy
   * (unless `from == original.length` or `from == to`).
   * Values from subsequent elements in the original array are placed into
   * subsequent elements in the copy.  The final index of the range
   * (`to`), which must be greater than or equal to `from`,
   * may be greater than `original.length`, in which case
   * `0L` is placed in all elements of the copy whose index is
   * greater than or equal to `original.length - from`.  The length
   * of the returned array will be `to - from`.
   *
   * @param original the array from which a range is to be copied
   * @param from the initial index of the range to be copied, inclusive
   * @param to the final index of the range to be copied, exclusive.
   *     (This index may lie outside the array.)
   * @return a new array containing the specified range from the original array,
   *     truncated or padded with zeros to obtain the required length
   * @throws ArrayIndexOutOfBoundsException if `from < 0`
   *     or `from > original.length`
   * @throws IllegalArgumentException if `from > to`
   * @throws NullPointerException if `original` is null
   * @since 1.6
  */
  static copyOfRange(original: number[], from: number, to: number): number[];
  /**
   * Copies the specified range of the specified array into a new array.
   * The initial index of the range (`from`) must lie between zero
   * and `original.length`, inclusive.  The value at
   * `original[from]` is placed into the initial element of the copy
   * (unless `from == original.length` or `from == to`).
   * Values from subsequent elements in the original array are placed into
   * subsequent elements in the copy.  The final index of the range
   * (`to`), which must be greater than or equal to `from`,
   * may be greater than `original.length`, in which case
   * `'\u005cu0000'` is placed in all elements of the copy whose index is
   * greater than or equal to `original.length - from`.  The length
   * of the returned array will be `to - from`.
   *
   * @param original the array from which a range is to be copied
   * @param from the initial index of the range to be copied, inclusive
   * @param to the final index of the range to be copied, exclusive.
   *     (This index may lie outside the array.)
   * @return a new array containing the specified range from the original array,
   *     truncated or padded with null characters to obtain the required length
   * @throws ArrayIndexOutOfBoundsException if `from < 0`
   *     or `from > original.length`
   * @throws IllegalArgumentException if `from > to`
   * @throws NullPointerException if `original` is null
   * @since 1.6
  */
  static copyOfRange(original: string[], from: number, to: number): string[];
  /**
   * Copies the specified range of the specified array into a new array.
   * The initial index of the range (`from`) must lie between zero
   * and `original.length`, inclusive.  The value at
   * `original[from]` is placed into the initial element of the copy
   * (unless `from == original.length` or `from == to`).
   * Values from subsequent elements in the original array are placed into
   * subsequent elements in the copy.  The final index of the range
   * (`to`), which must be greater than or equal to `from`,
   * may be greater than `original.length`, in which case
   * `0f` is placed in all elements of the copy whose index is
   * greater than or equal to `original.length - from`.  The length
   * of the returned array will be `to - from`.
   *
   * @param original the array from which a range is to be copied
   * @param from the initial index of the range to be copied, inclusive
   * @param to the final index of the range to be copied, exclusive.
   *     (This index may lie outside the array.)
   * @return a new array containing the specified range from the original array,
   *     truncated or padded with zeros to obtain the required length
   * @throws ArrayIndexOutOfBoundsException if `from < 0`
   *     or `from > original.length`
   * @throws IllegalArgumentException if `from > to`
   * @throws NullPointerException if `original` is null
   * @since 1.6
  */
  static copyOfRange(original: number[], from: number, to: number): number[];
  /**
   * Copies the specified range of the specified array into a new array.
   * The initial index of the range (`from`) must lie between zero
   * and `original.length`, inclusive.  The value at
   * `original[from]` is placed into the initial element of the copy
   * (unless `from == original.length` or `from == to`).
   * Values from subsequent elements in the original array are placed into
   * subsequent elements in the copy.  The final index of the range
   * (`to`), which must be greater than or equal to `from`,
   * may be greater than `original.length`, in which case
   * `0d` is placed in all elements of the copy whose index is
   * greater than or equal to `original.length - from`.  The length
   * of the returned array will be `to - from`.
   *
   * @param original the array from which a range is to be copied
   * @param from the initial index of the range to be copied, inclusive
   * @param to the final index of the range to be copied, exclusive.
   *     (This index may lie outside the array.)
   * @return a new array containing the specified range from the original array,
   *     truncated or padded with zeros to obtain the required length
   * @throws ArrayIndexOutOfBoundsException if `from < 0`
   *     or `from > original.length`
   * @throws IllegalArgumentException if `from > to`
   * @throws NullPointerException if `original` is null
   * @since 1.6
  */
  static copyOfRange(original: number[], from: number, to: number): number[];
  /**
   * Copies the specified range of the specified array into a new array.
   * The initial index of the range (`from`) must lie between zero
   * and `original.length`, inclusive.  The value at
   * `original[from]` is placed into the initial element of the copy
   * (unless `from == original.length` or `from == to`).
   * Values from subsequent elements in the original array are placed into
   * subsequent elements in the copy.  The final index of the range
   * (`to`), which must be greater than or equal to `from`,
   * may be greater than `original.length`, in which case
   * `false` is placed in all elements of the copy whose index is
   * greater than or equal to `original.length - from`.  The length
   * of the returned array will be `to - from`.
   *
   * @param original the array from which a range is to be copied
   * @param from the initial index of the range to be copied, inclusive
   * @param to the final index of the range to be copied, exclusive.
   *     (This index may lie outside the array.)
   * @return a new array containing the specified range from the original array,
   *     truncated or padded with false elements to obtain the required length
   * @throws ArrayIndexOutOfBoundsException if `from < 0`
   *     or `from > original.length`
   * @throws IllegalArgumentException if `from > to`
   * @throws NullPointerException if `original` is null
   * @since 1.6
  */
  static copyOfRange(original: boolean[], from: number, to: number): boolean[];
  /**
   * Returns a fixed-size list backed by the specified array. Changes made to
   * the array will be visible in the returned list, and changes made to the
   * list will be visible in the array. The returned list is
   * {@link Serializable} and implements {@link RandomAccess}.
   *
   * The returned list implements the optional `Collection` methods, except
   * those that would change the size of the returned list. Those methods leave
   * the list unchanged and throw {@link UnsupportedOperationException}.
   *
   * @apiNote
   * This method acts as bridge between array-based and collection-based
   * APIs, in combination with {@link Collection#toArray}.
   *
   * This method provides a way to wrap an existing array:
   * {@code
   *     Integer[] numbers = ...
   *     ...
   *     List values = Arrays.asList(numbers);
   * }
   *
   * This method also provides a convenient way to create a fixed-size
   * list initialized to contain several elements:
   * {@code
   *     List stooges = Arrays.asList("Larry", "Moe", "Curly");
   * }
   *
   * The list returned by this method is modifiable.
   * To create an unmodifiable list, use
   * {@link Collections#unmodifiableList Collections.unmodifiableList}
   * or Unmodifiable Lists.
   *
   * @param  the class of the objects in the array
   * @param a the array by which the list will be backed
   * @return a list view of the specified array
   * @throws NullPointerException if the specified array is `null`
  */
  static asList<T>(...a: T[]): T[];
  /**
   * Returns a hash code based on the contents of the specified array.
   * For any two `long` arrays `a` and `b`
   * such that `Arrays.equals(a, b)`, it is also the case that
   * `Arrays.hashCode(a) == Arrays.hashCode(b)`.
   *
   * The value returned by this method is the same value that would be
   * obtained by invoking the {@link List#hashCode() hashCode}
   * method on a {@link List} containing a sequence of {@link Long}
   * instances representing the elements of `a` in the same order.
   * If `a` is `null`, this method returns 0.
   *
   * @param a the array whose hash value to compute
   * @return a content-based hash code for `a`
   * @since 1.5
  */
  static hashCode(a: number[]): number;
  /**
   * Returns a hash code based on the contents of the specified array.
   * For any two non-null `int` arrays `a` and `b`
   * such that `Arrays.equals(a, b)`, it is also the case that
   * `Arrays.hashCode(a) == Arrays.hashCode(b)`.
   *
   * The value returned by this method is the same value that would be
   * obtained by invoking the {@link List#hashCode() hashCode}
   * method on a {@link List} containing a sequence of {@link Integer}
   * instances representing the elements of `a` in the same order.
   * If `a` is `null`, this method returns 0.
   *
   * @param a the array whose hash value to compute
   * @return a content-based hash code for `a`
   * @since 1.5
  */
  static hashCode(a: number[]): number;
  /**
   * Returns a hash code based on the contents of the specified array.
   * For any two `short` arrays `a` and `b`
   * such that `Arrays.equals(a, b)`, it is also the case that
   * `Arrays.hashCode(a) == Arrays.hashCode(b)`.
   *
   * The value returned by this method is the same value that would be
   * obtained by invoking the {@link List#hashCode() hashCode}
   * method on a {@link List} containing a sequence of {@link Short}
   * instances representing the elements of `a` in the same order.
   * If `a` is `null`, this method returns 0.
   *
   * @param a the array whose hash value to compute
   * @return a content-based hash code for `a`
   * @since 1.5
  */
  static hashCode(a: number[]): number;
  /**
   * Returns a hash code based on the contents of the specified array.
   * For any two `char` arrays `a` and `b`
   * such that `Arrays.equals(a, b)`, it is also the case that
   * `Arrays.hashCode(a) == Arrays.hashCode(b)`.
   *
   * The value returned by this method is the same value that would be
   * obtained by invoking the {@link List#hashCode() hashCode}
   * method on a {@link List} containing a sequence of {@link Character}
   * instances representing the elements of `a` in the same order.
   * If `a` is `null`, this method returns 0.
   *
   * @param a the array whose hash value to compute
   * @return a content-based hash code for `a`
   * @since 1.5
  */
  static hashCode(a: string[]): number;
  /**
   * Returns a hash code based on the contents of the specified array.
   * For any two `byte` arrays `a` and `b`
   * such that `Arrays.equals(a, b)`, it is also the case that
   * `Arrays.hashCode(a) == Arrays.hashCode(b)`.
   *
   * The value returned by this method is the same value that would be
   * obtained by invoking the {@link List#hashCode() hashCode}
   * method on a {@link List} containing a sequence of {@link Byte}
   * instances representing the elements of `a` in the same order.
   * If `a` is `null`, this method returns 0.
   *
   * @param a the array whose hash value to compute
   * @return a content-based hash code for `a`
   * @since 1.5
  */
  static hashCode(a: number[]): number;
  /**
   * Returns a hash code based on the contents of the specified array.
   * For any two `boolean` arrays `a` and `b`
   * such that `Arrays.equals(a, b)`, it is also the case that
   * `Arrays.hashCode(a) == Arrays.hashCode(b)`.
   *
   * The value returned by this method is the same value that would be
   * obtained by invoking the {@link List#hashCode() hashCode}
   * method on a {@link List} containing a sequence of {@link Boolean}
   * instances representing the elements of `a` in the same order.
   * If `a` is `null`, this method returns 0.
   *
   * @param a the array whose hash value to compute
   * @return a content-based hash code for `a`
   * @since 1.5
  */
  static hashCode(a: boolean[]): number;
  /**
   * Returns a hash code based on the contents of the specified array.
   * For any two `float` arrays `a` and `b`
   * such that `Arrays.equals(a, b)`, it is also the case that
   * `Arrays.hashCode(a) == Arrays.hashCode(b)`.
   *
   * The value returned by this method is the same value that would be
   * obtained by invoking the {@link List#hashCode() hashCode}
   * method on a {@link List} containing a sequence of {@link Float}
   * instances representing the elements of `a` in the same order.
   * If `a` is `null`, this method returns 0.
   *
   * @param a the array whose hash value to compute
   * @return a content-based hash code for `a`
   * @since 1.5
  */
  static hashCode(a: number[]): number;
  /**
   * Returns a hash code based on the contents of the specified array.
   * For any two `double` arrays `a` and `b`
   * such that `Arrays.equals(a, b)`, it is also the case that
   * `Arrays.hashCode(a) == Arrays.hashCode(b)`.
   *
   * The value returned by this method is the same value that would be
   * obtained by invoking the {@link List#hashCode() hashCode}
   * method on a {@link List} containing a sequence of {@link Double}
   * instances representing the elements of `a` in the same order.
   * If `a` is `null`, this method returns 0.
   *
   * @param a the array whose hash value to compute
   * @return a content-based hash code for `a`
   * @since 1.5
  */
  static hashCode(a: number[]): number;
  /**
   * Returns a hash code based on the contents of the specified array.  If
   * the array contains other arrays as elements, the hash code is based on
   * their identities rather than their contents.  It is therefore
   * acceptable to invoke this method on an array that contains itself as an
   * element,  either directly or indirectly through one or more levels of
   * arrays.
   *
   * For any two arrays `a` and `b` such that
   * `Arrays.equals(a, b)`, it is also the case that
   * `Arrays.hashCode(a) == Arrays.hashCode(b)`.
   *
   * The value returned by this method is equal to the value that would
   * be returned by `Arrays.asList(a).hashCode()`, unless `a`
   * is `null`, in which case `0` is returned.
   *
   * @param a the array whose content-based hash code to compute
   * @return a content-based hash code for `a`
   * @see #deepHashCode(Object[])
   * @since 1.5
  */
  static hashCode(a: any[]): number;
  /**
   * Returns a hash code based on the "deep contents" of the specified
   * array.  If the array contains other arrays as elements, the
   * hash code is based on their contents and so on, ad infinitum.
   * It is therefore unacceptable to invoke this method on an array that
   * contains itself as an element, either directly or indirectly through
   * one or more levels of arrays.  The behavior of such an invocation is
   * undefined.
   *
   * For any two arrays `a` and `b` such that
   * `Arrays.deepEquals(a, b)`, it is also the case that
   * `Arrays.deepHashCode(a) == Arrays.deepHashCode(b)`.
   *
   * The computation of the value returned by this method is similar to
   * that of the value returned by {@link List#hashCode()} on a list
   * containing the same elements as `a` in the same order, with one
   * difference: If an element `e` of `a` is itself an array,
   * its hash code is computed not by calling `e.hashCode()`, but as
   * by calling the appropriate overloading of `Arrays.hashCode(e)`
   * if `e` is an array of a primitive type, or as by calling
   * `Arrays.deepHashCode(e)` recursively if `e` is an array
   * of a reference type.  If `a` is `null`, this method
   * returns 0.
   *
   * @param a the array whose deep-content-based hash code to compute
   * @return a deep-content-based hash code for `a`
   * @see #hashCode(Object[])
   * @since 1.5
  */
  static deepHashCode(a: any[]): number;
  /**
   * Returns `true` if the two specified arrays are deeply
   * equal to one another.  Unlike the {@link #equals(Object[],Object[])}
   * method, this method is appropriate for use with nested arrays of
   * arbitrary depth.
   *
   * Two array references are considered deeply equal if both
   * are `null`, or if they refer to arrays that contain the same
   * number of elements and all corresponding pairs of elements in the two
   * arrays are deeply equal.
   *
   * Two possibly `null` elements `e1` and `e2` are
   * deeply equal if any of the following conditions hold:
   * 
   *     `e1` and `e2` are both arrays of object reference
   *         types, and `Arrays.deepEquals(e1, e2) would return true`
   *     `e1` and `e2` are arrays of the same primitive
   *         type, and the appropriate overloading of
   *         `Arrays.equals(e1, e2)` would return true.
   *     `e1 == e2`
   *     `e1.equals(e2)` would return true.
   * 
   * Note that this definition permits `null` elements at any depth.
   *
   * If either of the specified arrays contain themselves as elements
   * either directly or indirectly through one or more levels of arrays,
   * the behavior of this method is undefined.
   *
   * @param a1 one array to be tested for equality
   * @param a2 the other array to be tested for equality
   * @return `true` if the two arrays are equal
   * @see #equals(Object[],Object[])
   * @see Objects#deepEquals(Object, Object)
   * @since 1.5
  */
  static deepEquals(a1: any[], a2: any[]): boolean;
  /**
   * Returns a string representation of the contents of the specified array.
   * The string representation consists of a list of the array's elements,
   * enclosed in square brackets (`"[]"`).  Adjacent elements are
   * separated by the characters `", "` (a comma followed by a
   * space).  Elements are converted to strings as by
   * `String.valueOf(long)`.  Returns `"null"` if `a`
   * is `null`.
   *
   * @param a the array whose string representation to return
   * @return a string representation of `a`
   * @since 1.5
  */
  static toString(a: number[]): string;
  /**
   * Returns a string representation of the contents of the specified array.
   * The string representation consists of a list of the array's elements,
   * enclosed in square brackets (`"[]"`).  Adjacent elements are
   * separated by the characters `", "` (a comma followed by a
   * space).  Elements are converted to strings as by
   * `String.valueOf(int)`.  Returns `"null"` if `a` is
   * `null`.
   *
   * @param a the array whose string representation to return
   * @return a string representation of `a`
   * @since 1.5
  */
  static toString(a: number[]): string;
  /**
   * Returns a string representation of the contents of the specified array.
   * The string representation consists of a list of the array's elements,
   * enclosed in square brackets (`"[]"`).  Adjacent elements are
   * separated by the characters `", "` (a comma followed by a
   * space).  Elements are converted to strings as by
   * `String.valueOf(short)`.  Returns `"null"` if `a`
   * is `null`.
   *
   * @param a the array whose string representation to return
   * @return a string representation of `a`
   * @since 1.5
  */
  static toString(a: number[]): string;
  /**
   * Returns a string representation of the contents of the specified array.
   * The string representation consists of a list of the array's elements,
   * enclosed in square brackets (`"[]"`).  Adjacent elements are
   * separated by the characters `", "` (a comma followed by a
   * space).  Elements are converted to strings as by
   * `String.valueOf(char)`.  Returns `"null"` if `a`
   * is `null`.
   *
   * @param a the array whose string representation to return
   * @return a string representation of `a`
   * @since 1.5
  */
  static toString(a: string[]): string;
  /**
   * Returns a string representation of the contents of the specified array.
   * The string representation consists of a list of the array's elements,
   * enclosed in square brackets (`"[]"`).  Adjacent elements
   * are separated by the characters `", "` (a comma followed
   * by a space).  Elements are converted to strings as by
   * `String.valueOf(byte)`.  Returns `"null"` if
   * `a` is `null`.
   *
   * @param a the array whose string representation to return
   * @return a string representation of `a`
   * @since 1.5
  */
  static toString(a: number[]): string;
  /**
   * Returns a string representation of the contents of the specified array.
   * The string representation consists of a list of the array's elements,
   * enclosed in square brackets (`"[]"`).  Adjacent elements are
   * separated by the characters `", "` (a comma followed by a
   * space).  Elements are converted to strings as by
   * `String.valueOf(boolean)`.  Returns `"null"` if
   * `a` is `null`.
   *
   * @param a the array whose string representation to return
   * @return a string representation of `a`
   * @since 1.5
  */
  static toString(a: boolean[]): string;
  /**
   * Returns a string representation of the contents of the specified array.
   * The string representation consists of a list of the array's elements,
   * enclosed in square brackets (`"[]"`).  Adjacent elements are
   * separated by the characters `", "` (a comma followed by a
   * space).  Elements are converted to strings as by
   * `String.valueOf(float)`.  Returns `"null"` if `a`
   * is `null`.
   *
   * @param a the array whose string representation to return
   * @return a string representation of `a`
   * @since 1.5
  */
  static toString(a: number[]): string;
  /**
   * Returns a string representation of the contents of the specified array.
   * The string representation consists of a list of the array's elements,
   * enclosed in square brackets (`"[]"`).  Adjacent elements are
   * separated by the characters `", "` (a comma followed by a
   * space).  Elements are converted to strings as by
   * `String.valueOf(double)`.  Returns `"null"` if `a`
   * is `null`.
   *
   * @param a the array whose string representation to return
   * @return a string representation of `a`
   * @since 1.5
  */
  static toString(a: number[]): string;
  /**
   * Returns a string representation of the contents of the specified array.
   * If the array contains other arrays as elements, they are converted to
   * strings by the {@link Object#toString} method inherited from
   * `Object`, which describes their identities rather than
   * their contents.
   *
   * The value returned by this method is equal to the value that would
   * be returned by `Arrays.asList(a).toString()`, unless `a`
   * is `null`, in which case `"null"` is returned.
   *
   * @param a the array whose string representation to return
   * @return a string representation of `a`
   * @see #deepToString(Object[])
   * @since 1.5
  */
  static toString(a: any[]): string;
  /**
   * Returns a string representation of the "deep contents" of the specified
   * array.  If the array contains other arrays as elements, the string
   * representation contains their contents and so on.  This method is
   * designed for converting multidimensional arrays to strings.
   *
   * The string representation consists of a list of the array's
   * elements, enclosed in square brackets (`"[]"`).  Adjacent
   * elements are separated by the characters `", "` (a comma
   * followed by a space).  Elements are converted to strings as by
   * `String.valueOf(Object)`, unless they are themselves
   * arrays.
   *
   * If an element `e` is an array of a primitive type, it is
   * converted to a string as by invoking the appropriate overloading of
   * `Arrays.toString(e)`.  If an element `e` is an array of a
   * reference type, it is converted to a string as by invoking
   * this method recursively.
   *
   * To avoid infinite recursion, if the specified array contains itself
   * as an element, or contains an indirect reference to itself through one
   * or more levels of arrays, the self-reference is converted to the string
   * `"[...]"`.  For example, an array containing only a reference
   * to itself would be rendered as `"[[...]]"`.
   *
   * This method returns `"null"` if the specified array
   * is `null`.
   *
   * @param a the array whose string representation to return
   * @return a string representation of `a`
   * @see #toString(Object[])
   * @since 1.5
  */
  static deepToString(a: any[]): string;
  /**
   * Set all elements of the specified array, using the provided
   * generator function to compute each element.
   *
   * If the generator function throws an exception, it is relayed to
   * the caller and the array is left in an indeterminate state.
   *
   * @apiNote
   * Setting a subrange of an array, using a generator function to compute
   * each element, can be written as follows:
   * {@code
   * IntStream.range(startInclusive, endExclusive)
   *          .forEach(i -> array[i] = generator.apply(i));
   * }
   *
   * @param  type of elements of the array
   * @param array array to be initialized
   * @param generator a function accepting an index and producing the desired
   *        value for that position
   * @throws NullPointerException if the generator is null
   * @since 1.8
  */
  static setAll<T>(array: T[], generator: IntFunction<T>): void;
  /**
   * Set all elements of the specified array, in parallel, using the
   * provided generator function to compute each element.
   *
   * If the generator function throws an exception, an unchecked exception
   * is thrown from `parallelSetAll` and the array is left in an
   * indeterminate state.
   *
   * @apiNote
   * Setting a subrange of an array, in parallel, using a generator function
   * to compute each element, can be written as follows:
   * {@code
   * IntStream.range(startInclusive, endExclusive)
   *          .parallel()
   *          .forEach(i -> array[i] = generator.apply(i));
   * }
   *
   * @param  type of elements of the array
   * @param array array to be initialized
   * @param generator a function accepting an index and producing the desired
   *        value for that position
   * @throws NullPointerException if the generator is null
   * @since 1.8
  */
  static parallelSetAll<T>(array: T[], generator: IntFunction<T>): void;
  /**
   * Set all elements of the specified array, using the provided
   * generator function to compute each element.
   *
   * If the generator function throws an exception, it is relayed to
   * the caller and the array is left in an indeterminate state.
   *
   * @apiNote
   * Setting a subrange of an array, using a generator function to compute
   * each element, can be written as follows:
   * {@code
   * IntStream.range(startInclusive, endExclusive)
   *          .forEach(i -> array[i] = generator.applyAsInt(i));
   * }
   *
   * @param array array to be initialized
   * @param generator a function accepting an index and producing the desired
   *        value for that position
   * @throws NullPointerException if the generator is null
   * @since 1.8
  */
  static setAll(array: number[], generator: IntUnaryOperator): void;
  /**
   * Set all elements of the specified array, in parallel, using the
   * provided generator function to compute each element.
   *
   * If the generator function throws an exception, an unchecked exception
   * is thrown from `parallelSetAll` and the array is left in an
   * indeterminate state.
   *
   * @apiNote
   * Setting a subrange of an array, in parallel, using a generator function
   * to compute each element, can be written as follows:
   * {@code
   * IntStream.range(startInclusive, endExclusive)
   *          .parallel()
   *          .forEach(i -> array[i] = generator.applyAsInt(i));
   * }
   *
   * @param array array to be initialized
   * @param generator a function accepting an index and producing the desired
   * value for that position
   * @throws NullPointerException if the generator is null
   * @since 1.8
  */
  static parallelSetAll(array: number[], generator: IntUnaryOperator): void;
  /**
   * Set all elements of the specified array, using the provided
   * generator function to compute each element.
   *
   * If the generator function throws an exception, it is relayed to
   * the caller and the array is left in an indeterminate state.
   *
   * @apiNote
   * Setting a subrange of an array, using a generator function to compute
   * each element, can be written as follows:
   * {@code
   * IntStream.range(startInclusive, endExclusive)
   *          .forEach(i -> array[i] = generator.applyAsLong(i));
   * }
   *
   * @param array array to be initialized
   * @param generator a function accepting an index and producing the desired
   *        value for that position
   * @throws NullPointerException if the generator is null
   * @since 1.8
  */
  static setAll(array: number[], generator: IntToLongFunction): void;
  /**
   * Set all elements of the specified array, in parallel, using the
   * provided generator function to compute each element.
   *
   * If the generator function throws an exception, an unchecked exception
   * is thrown from `parallelSetAll` and the array is left in an
   * indeterminate state.
   *
   * @apiNote
   * Setting a subrange of an array, in parallel, using a generator function
   * to compute each element, can be written as follows:
   * {@code
   * IntStream.range(startInclusive, endExclusive)
   *          .parallel()
   *          .forEach(i -> array[i] = generator.applyAsLong(i));
   * }
   *
   * @param array array to be initialized
   * @param generator a function accepting an index and producing the desired
   *        value for that position
   * @throws NullPointerException if the generator is null
   * @since 1.8
  */
  static parallelSetAll(array: number[], generator: IntToLongFunction): void;
  /**
   * Set all elements of the specified array, using the provided
   * generator function to compute each element.
   *
   * If the generator function throws an exception, it is relayed to
   * the caller and the array is left in an indeterminate state.
   *
   * @apiNote
   * Setting a subrange of an array, using a generator function to compute
   * each element, can be written as follows:
   * {@code
   * IntStream.range(startInclusive, endExclusive)
   *          .forEach(i -> array[i] = generator.applyAsDouble(i));
   * }
   *
   * @param array array to be initialized
   * @param generator a function accepting an index and producing the desired
   *        value for that position
   * @throws NullPointerException if the generator is null
   * @since 1.8
  */
  static setAll(array: number[], generator: IntToDoubleFunction): void;
  /**
   * Set all elements of the specified array, in parallel, using the
   * provided generator function to compute each element.
   *
   * If the generator function throws an exception, an unchecked exception
   * is thrown from `parallelSetAll` and the array is left in an
   * indeterminate state.
   *
   * @apiNote
   * Setting a subrange of an array, in parallel, using a generator function
   * to compute each element, can be written as follows:
   * {@code
   * IntStream.range(startInclusive, endExclusive)
   *          .parallel()
   *          .forEach(i -> array[i] = generator.applyAsDouble(i));
   * }
   *
   * @param array array to be initialized
   * @param generator a function accepting an index and producing the desired
   *        value for that position
   * @throws NullPointerException if the generator is null
   * @since 1.8
  */
  static parallelSetAll(array: number[], generator: IntToDoubleFunction): void;
  /**
   * Returns a {@link Spliterator} covering all of the specified array.
   *
   * The spliterator reports {@link Spliterator#SIZED},
   * {@link Spliterator#SUBSIZED}, {@link Spliterator#ORDERED}, and
   * {@link Spliterator#IMMUTABLE}.
   *
   * @param  type of elements
   * @param array the array, assumed to be unmodified during use
   * @return a spliterator for the array elements
   * @since 1.8
  */
  static spliterator<T>(array: T[]): Spliterator<T>;
  /**
   * Returns a {@link Spliterator} covering the specified range of the
   * specified array.
   *
   * The spliterator reports {@link Spliterator#SIZED},
   * {@link Spliterator#SUBSIZED}, {@link Spliterator#ORDERED}, and
   * {@link Spliterator#IMMUTABLE}.
   *
   * @param  type of elements
   * @param array the array, assumed to be unmodified during use
   * @param startInclusive the first index to cover, inclusive
   * @param endExclusive index immediately past the last index to cover
   * @return a spliterator for the array elements
   * @throws ArrayIndexOutOfBoundsException if `startInclusive` is
   *         negative, `endExclusive` is less than
   *         `startInclusive`, or `endExclusive` is greater than
   *         the array size
   * @since 1.8
  */
  static spliterator<T>(array: T[], startInclusive: number, endExclusive: number): Spliterator<T>;
  /**
   * Returns a {@link Spliterator.OfInt} covering all of the specified array.
   *
   * The spliterator reports {@link Spliterator#SIZED},
   * {@link Spliterator#SUBSIZED}, {@link Spliterator#ORDERED}, and
   * {@link Spliterator#IMMUTABLE}.
   *
   * @param array the array, assumed to be unmodified during use
   * @return a spliterator for the array elements
   * @since 1.8
  */
  static spliterator(array: number[]): OfInt;
  /**
   * Returns a {@link Spliterator.OfInt} covering the specified range of the
   * specified array.
   *
   * The spliterator reports {@link Spliterator#SIZED},
   * {@link Spliterator#SUBSIZED}, {@link Spliterator#ORDERED}, and
   * {@link Spliterator#IMMUTABLE}.
   *
   * @param array the array, assumed to be unmodified during use
   * @param startInclusive the first index to cover, inclusive
   * @param endExclusive index immediately past the last index to cover
   * @return a spliterator for the array elements
   * @throws ArrayIndexOutOfBoundsException if `startInclusive` is
   *         negative, `endExclusive` is less than
   *         `startInclusive`, or `endExclusive` is greater than
   *         the array size
   * @since 1.8
  */
  static spliterator(array: number[], startInclusive: number, endExclusive: number): OfInt;
  /**
   * Returns a {@link Spliterator.OfLong} covering all of the specified array.
   *
   * The spliterator reports {@link Spliterator#SIZED},
   * {@link Spliterator#SUBSIZED}, {@link Spliterator#ORDERED}, and
   * {@link Spliterator#IMMUTABLE}.
   *
   * @param array the array, assumed to be unmodified during use
   * @return the spliterator for the array elements
   * @since 1.8
  */
  static spliterator(array: number[]): OfLong;
  /**
   * Returns a {@link Spliterator.OfLong} covering the specified range of the
   * specified array.
   *
   * The spliterator reports {@link Spliterator#SIZED},
   * {@link Spliterator#SUBSIZED}, {@link Spliterator#ORDERED}, and
   * {@link Spliterator#IMMUTABLE}.
   *
   * @param array the array, assumed to be unmodified during use
   * @param startInclusive the first index to cover, inclusive
   * @param endExclusive index immediately past the last index to cover
   * @return a spliterator for the array elements
   * @throws ArrayIndexOutOfBoundsException if `startInclusive` is
   *         negative, `endExclusive` is less than
   *         `startInclusive`, or `endExclusive` is greater than
   *         the array size
   * @since 1.8
  */
  static spliterator(array: number[], startInclusive: number, endExclusive: number): OfLong;
  /**
   * Returns a {@link Spliterator.OfDouble} covering all of the specified
   * array.
   *
   * The spliterator reports {@link Spliterator#SIZED},
   * {@link Spliterator#SUBSIZED}, {@link Spliterator#ORDERED}, and
   * {@link Spliterator#IMMUTABLE}.
   *
   * @param array the array, assumed to be unmodified during use
   * @return a spliterator for the array elements
   * @since 1.8
  */
  static spliterator(array: number[]): OfDouble;
  /**
   * Returns a {@link Spliterator.OfDouble} covering the specified range of
   * the specified array.
   *
   * The spliterator reports {@link Spliterator#SIZED},
   * {@link Spliterator#SUBSIZED}, {@link Spliterator#ORDERED}, and
   * {@link Spliterator#IMMUTABLE}.
   *
   * @param array the array, assumed to be unmodified during use
   * @param startInclusive the first index to cover, inclusive
   * @param endExclusive index immediately past the last index to cover
   * @return a spliterator for the array elements
   * @throws ArrayIndexOutOfBoundsException if `startInclusive` is
   *         negative, `endExclusive` is less than
   *         `startInclusive`, or `endExclusive` is greater than
   *         the array size
   * @since 1.8
  */
  static spliterator(array: number[], startInclusive: number, endExclusive: number): OfDouble;
  /**
   * Returns a sequential {@link Stream} with the specified array as its
   * source.
   *
   * @param  The type of the array elements
   * @param array The array, assumed to be unmodified during use
   * @return a `Stream` for the array
   * @since 1.8
  */
  static stream<T>(array: T[]): Stream<T>;
  /**
   * Returns a sequential {@link Stream} with the specified range of the
   * specified array as its source.
   *
   * @param  the type of the array elements
   * @param array the array, assumed to be unmodified during use
   * @param startInclusive the first index to cover, inclusive
   * @param endExclusive index immediately past the last index to cover
   * @return a `Stream` for the array range
   * @throws ArrayIndexOutOfBoundsException if `startInclusive` is
   *         negative, `endExclusive` is less than
   *         `startInclusive`, or `endExclusive` is greater than
   *         the array size
   * @since 1.8
  */
  static stream<T>(array: T[], startInclusive: number, endExclusive: number): Stream<T>;
  /**
   * Returns a sequential {@link IntStream} with the specified array as its
   * source.
   *
   * @param array the array, assumed to be unmodified during use
   * @return an `IntStream` for the array
   * @since 1.8
  */
  static stream(array: number[]): IntStream;
  /**
   * Returns a sequential {@link IntStream} with the specified range of the
   * specified array as its source.
   *
   * @param array the array, assumed to be unmodified during use
   * @param startInclusive the first index to cover, inclusive
   * @param endExclusive index immediately past the last index to cover
   * @return an `IntStream` for the array range
   * @throws ArrayIndexOutOfBoundsException if `startInclusive` is
   *         negative, `endExclusive` is less than
   *         `startInclusive`, or `endExclusive` is greater than
   *         the array size
   * @since 1.8
  */
  static stream(array: number[], startInclusive: number, endExclusive: number): IntStream;
  /**
   * Returns a sequential {@link LongStream} with the specified array as its
   * source.
   *
   * @param array the array, assumed to be unmodified during use
   * @return a `LongStream` for the array
   * @since 1.8
  */
  static stream(array: number[]): LongStream;
  /**
   * Returns a sequential {@link LongStream} with the specified range of the
   * specified array as its source.
   *
   * @param array the array, assumed to be unmodified during use
   * @param startInclusive the first index to cover, inclusive
   * @param endExclusive index immediately past the last index to cover
   * @return a `LongStream` for the array range
   * @throws ArrayIndexOutOfBoundsException if `startInclusive` is
   *         negative, `endExclusive` is less than
   *         `startInclusive`, or `endExclusive` is greater than
   *         the array size
   * @since 1.8
  */
  static stream(array: number[], startInclusive: number, endExclusive: number): LongStream;
  /**
   * Returns a sequential {@link DoubleStream} with the specified array as its
   * source.
   *
   * @param array the array, assumed to be unmodified during use
   * @return a `DoubleStream` for the array
   * @since 1.8
  */
  static stream(array: number[]): DoubleStream;
  /**
   * Returns a sequential {@link DoubleStream} with the specified range of the
   * specified array as its source.
   *
   * @param array the array, assumed to be unmodified during use
   * @param startInclusive the first index to cover, inclusive
   * @param endExclusive index immediately past the last index to cover
   * @return a `DoubleStream` for the array range
   * @throws ArrayIndexOutOfBoundsException if `startInclusive` is
   *         negative, `endExclusive` is less than
   *         `startInclusive`, or `endExclusive` is greater than
   *         the array size
   * @since 1.8
  */
  static stream(array: number[], startInclusive: number, endExclusive: number): DoubleStream;
  /**
   * Compares two `boolean` arrays lexicographically.
   *
   * If the two arrays share a common prefix then the lexicographic
   * comparison is the result of comparing two elements, as if by
   * {@link Boolean#compare(boolean, boolean)}, at an index within the
   * respective arrays that is the prefix length.
   * Otherwise, one array is a proper prefix of the other and, lexicographic
   * comparison is the result of comparing the two array lengths.
   * (See {@link #mismatch(boolean[], boolean[])} for the definition of a
   * common and proper prefix.)
   *
   * A `null` array reference is considered lexicographically less
   * than a non-`null` array reference.  Two `null` array
   * references are considered equal.
   *
   * The comparison is consistent with {@link #equals(boolean[], boolean[]) equals},
   * more specifically the following holds for arrays `a` and `b`:
   * {@code
   *     Arrays.equals(a, b) == (Arrays.compare(a, b) == 0)
   * }
   *
   * @apiNote
   * This method behaves as if (for non-`null` array references):
   * {@code
   *     int i = Arrays.mismatch(a, b);
   *     if (i >= 0 && i < Math.min(a.length, b.length))
   *         return Boolean.compare(a[i], b[i]);
   *     return a.length - b.length;
   * }
   *
   * @param a the first array to compare
   * @param b the second array to compare
   * @return the value `0` if the first and second array are equal and
   *         contain the same elements in the same order;
   *         a value less than `0` if the first array is
   *         lexicographically less than the second array; and
   *         a value greater than `0` if the first array is
   *         lexicographically greater than the second array
   * @since 9
  */
  static compare(a: boolean[], b: boolean[]): number;
  /**
   * Compares two `boolean` arrays lexicographically over the specified
   * ranges.
   *
   * If the two arrays, over the specified ranges, share a common prefix
   * then the lexicographic comparison is the result of comparing two
   * elements, as if by {@link Boolean#compare(boolean, boolean)}, at a
   * relative index within the respective arrays that is the length of the
   * prefix.
   * Otherwise, one array is a proper prefix of the other and, lexicographic
   * comparison is the result of comparing the two range lengths.
   * (See {@link #mismatch(boolean[], int, int, boolean[], int, int)} for the
   * definition of a common and proper prefix.)
   *
   * The comparison is consistent with
   * {@link #equals(boolean[], int, int, boolean[], int, int) equals}, more
   * specifically the following holds for arrays `a` and `b` with
   * specified ranges [`aFromIndex`, `atoIndex`) and
   * [`bFromIndex`, `btoIndex`) respectively:
   * {@code
   *     Arrays.equals(a, aFromIndex, aToIndex, b, bFromIndex, bToIndex) ==
   *         (Arrays.compare(a, aFromIndex, aToIndex, b, bFromIndex, bToIndex) == 0)
   * }
   *
   * @apiNote
   * This method behaves as if:
   * {@code
   *     int i = Arrays.mismatch(a, aFromIndex, aToIndex,
   *                             b, bFromIndex, bToIndex);
   *     if (i >= 0 && i < Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex))
   *         return Boolean.compare(a[aFromIndex + i], b[bFromIndex + i]);
   *     return (aToIndex - aFromIndex) - (bToIndex - bFromIndex);
   * }
   *
   * @param a the first array to compare
   * @param aFromIndex the index (inclusive) of the first element in the
   *                   first array to be compared
   * @param aToIndex the index (exclusive) of the last element in the
   *                 first array to be compared
   * @param b the second array to compare
   * @param bFromIndex the index (inclusive) of the first element in the
   *                   second array to be compared
   * @param bToIndex the index (exclusive) of the last element in the
   *                 second array to be compared
   * @return the value `0` if, over the specified ranges, the first and
   *         second array are equal and contain the same elements in the same
   *         order;
   *         a value less than `0` if, over the specified ranges, the
   *         first array is lexicographically less than the second array; and
   *         a value greater than `0` if, over the specified ranges, the
   *         first array is lexicographically greater than the second array
   * @throws IllegalArgumentException
   *         if `aFromIndex > aToIndex` or
   *         if `bFromIndex > bToIndex`
   * @throws ArrayIndexOutOfBoundsException
   *         if `aFromIndex < 0 or aToIndex > a.length` or
   *         if `bFromIndex < 0 or bToIndex > b.length`
   * @throws NullPointerException
   *         if either array is `null`
   * @since 9
  */
  static compare(a: boolean[], aFromIndex: number, aToIndex: number, b: boolean[], bFromIndex: number, bToIndex: number): number;
  /**
   * Compares two `byte` arrays lexicographically.
   *
   * If the two arrays share a common prefix then the lexicographic
   * comparison is the result of comparing two elements, as if by
   * {@link Byte#compare(byte, byte)}, at an index within the respective
   * arrays that is the prefix length.
   * Otherwise, one array is a proper prefix of the other and, lexicographic
   * comparison is the result of comparing the two array lengths.
   * (See {@link #mismatch(byte[], byte[])} for the definition of a common and
   * proper prefix.)
   *
   * A `null` array reference is considered lexicographically less
   * than a non-`null` array reference.  Two `null` array
   * references are considered equal.
   *
   * The comparison is consistent with {@link #equals(byte[], byte[]) equals},
   * more specifically the following holds for arrays `a` and `b`:
   * {@code
   *     Arrays.equals(a, b) == (Arrays.compare(a, b) == 0)
   * }
   *
   * @apiNote
   * This method behaves as if (for non-`null` array references):
   * {@code
   *     int i = Arrays.mismatch(a, b);
   *     if (i >= 0 && i < Math.min(a.length, b.length))
   *         return Byte.compare(a[i], b[i]);
   *     return a.length - b.length;
   * }
   *
   * @param a the first array to compare
   * @param b the second array to compare
   * @return the value `0` if the first and second array are equal and
   *         contain the same elements in the same order;
   *         a value less than `0` if the first array is
   *         lexicographically less than the second array; and
   *         a value greater than `0` if the first array is
   *         lexicographically greater than the second array
   * @since 9
  */
  static compare(a: number[], b: number[]): number;
  /**
   * Compares two `byte` arrays lexicographically over the specified
   * ranges.
   *
   * If the two arrays, over the specified ranges, share a common prefix
   * then the lexicographic comparison is the result of comparing two
   * elements, as if by {@link Byte#compare(byte, byte)}, at a relative index
   * within the respective arrays that is the length of the prefix.
   * Otherwise, one array is a proper prefix of the other and, lexicographic
   * comparison is the result of comparing the two range lengths.
   * (See {@link #mismatch(byte[], int, int, byte[], int, int)} for the
   * definition of a common and proper prefix.)
   *
   * The comparison is consistent with
   * {@link #equals(byte[], int, int, byte[], int, int) equals}, more
   * specifically the following holds for arrays `a` and `b` with
   * specified ranges [`aFromIndex`, `atoIndex`) and
   * [`bFromIndex`, `btoIndex`) respectively:
   * {@code
   *     Arrays.equals(a, aFromIndex, aToIndex, b, bFromIndex, bToIndex) ==
   *         (Arrays.compare(a, aFromIndex, aToIndex, b, bFromIndex, bToIndex) == 0)
   * }
   *
   * @apiNote
   * This method behaves as if:
   * {@code
   *     int i = Arrays.mismatch(a, aFromIndex, aToIndex,
   *                             b, bFromIndex, bToIndex);
   *     if (i >= 0 && i < Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex))
   *         return Byte.compare(a[aFromIndex + i], b[bFromIndex + i]);
   *     return (aToIndex - aFromIndex) - (bToIndex - bFromIndex);
   * }
   *
   * @param a the first array to compare
   * @param aFromIndex the index (inclusive) of the first element in the
   *                   first array to be compared
   * @param aToIndex the index (exclusive) of the last element in the
   *                 first array to be compared
   * @param b the second array to compare
   * @param bFromIndex the index (inclusive) of the first element in the
   *                   second array to be compared
   * @param bToIndex the index (exclusive) of the last element in the
   *                 second array to be compared
   * @return the value `0` if, over the specified ranges, the first and
   *         second array are equal and contain the same elements in the same
   *         order;
   *         a value less than `0` if, over the specified ranges, the
   *         first array is lexicographically less than the second array; and
   *         a value greater than `0` if, over the specified ranges, the
   *         first array is lexicographically greater than the second array
   * @throws IllegalArgumentException
   *         if `aFromIndex > aToIndex` or
   *         if `bFromIndex > bToIndex`
   * @throws ArrayIndexOutOfBoundsException
   *         if `aFromIndex < 0 or aToIndex > a.length` or
   *         if `bFromIndex < 0 or bToIndex > b.length`
   * @throws NullPointerException
   *         if either array is `null`
   * @since 9
  */
  static compare(a: number[], aFromIndex: number, aToIndex: number, b: number[], bFromIndex: number, bToIndex: number): number;
  /**
   * Compares two `byte` arrays lexicographically, numerically treating
   * elements as unsigned.
   *
   * If the two arrays share a common prefix then the lexicographic
   * comparison is the result of comparing two elements, as if by
   * {@link Byte#compareUnsigned(byte, byte)}, at an index within the
   * respective arrays that is the prefix length.
   * Otherwise, one array is a proper prefix of the other and, lexicographic
   * comparison is the result of comparing the two array lengths.
   * (See {@link #mismatch(byte[], byte[])} for the definition of a common
   * and proper prefix.)
   *
   * A `null` array reference is considered lexicographically less
   * than a non-`null` array reference.  Two `null` array
   * references are considered equal.
   *
   * @apiNote
   * This method behaves as if (for non-`null` array references):
   * {@code
   *     int i = Arrays.mismatch(a, b);
   *     if (i >= 0 && i < Math.min(a.length, b.length))
   *         return Byte.compareUnsigned(a[i], b[i]);
   *     return a.length - b.length;
   * }
   *
   * @param a the first array to compare
   * @param b the second array to compare
   * @return the value `0` if the first and second array are
   *         equal and contain the same elements in the same order;
   *         a value less than `0` if the first array is
   *         lexicographically less than the second array; and
   *         a value greater than `0` if the first array is
   *         lexicographically greater than the second array
   * @since 9
  */
  static compareUnsigned(a: number[], b: number[]): number;
  /**
   * Compares two `byte` arrays lexicographically over the specified
   * ranges, numerically treating elements as unsigned.
   *
   * If the two arrays, over the specified ranges, share a common prefix
   * then the lexicographic comparison is the result of comparing two
   * elements, as if by {@link Byte#compareUnsigned(byte, byte)}, at a
   * relative index within the respective arrays that is the length of the
   * prefix.
   * Otherwise, one array is a proper prefix of the other and, lexicographic
   * comparison is the result of comparing the two range lengths.
   * (See {@link #mismatch(byte[], int, int, byte[], int, int)} for the
   * definition of a common and proper prefix.)
   *
   * @apiNote
   * This method behaves as if:
   * {@code
   *     int i = Arrays.mismatch(a, aFromIndex, aToIndex,
   *                             b, bFromIndex, bToIndex);
   *     if (i >= 0 && i < Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex))
   *         return Byte.compareUnsigned(a[aFromIndex + i], b[bFromIndex + i]);
   *     return (aToIndex - aFromIndex) - (bToIndex - bFromIndex);
   * }
   *
   * @param a the first array to compare
   * @param aFromIndex the index (inclusive) of the first element in the
   *                   first array to be compared
   * @param aToIndex the index (exclusive) of the last element in the
   *                 first array to be compared
   * @param b the second array to compare
   * @param bFromIndex the index (inclusive) of the first element in the
   *                   second array to be compared
   * @param bToIndex the index (exclusive) of the last element in the
   *                 second array to be compared
   * @return the value `0` if, over the specified ranges, the first and
   *         second array are equal and contain the same elements in the same
   *         order;
   *         a value less than `0` if, over the specified ranges, the
   *         first array is lexicographically less than the second array; and
   *         a value greater than `0` if, over the specified ranges, the
   *         first array is lexicographically greater than the second array
   * @throws IllegalArgumentException
   *         if `aFromIndex > aToIndex` or
   *         if `bFromIndex > bToIndex`
   * @throws ArrayIndexOutOfBoundsException
   *         if `aFromIndex < 0 or aToIndex > a.length` or
   *         if `bFromIndex < 0 or bToIndex > b.length`
   * @throws NullPointerException
   *         if either array is null
   * @since 9
  */
  static compareUnsigned(a: number[], aFromIndex: number, aToIndex: number, b: number[], bFromIndex: number, bToIndex: number): number;
  /**
   * Compares two `short` arrays lexicographically.
   *
   * If the two arrays share a common prefix then the lexicographic
   * comparison is the result of comparing two elements, as if by
   * {@link Short#compare(short, short)}, at an index within the respective
   * arrays that is the prefix length.
   * Otherwise, one array is a proper prefix of the other and, lexicographic
   * comparison is the result of comparing the two array lengths.
   * (See {@link #mismatch(short[], short[])} for the definition of a common
   * and proper prefix.)
   *
   * A `null` array reference is considered lexicographically less
   * than a non-`null` array reference.  Two `null` array
   * references are considered equal.
   *
   * The comparison is consistent with {@link #equals(short[], short[]) equals},
   * more specifically the following holds for arrays `a` and `b`:
   * {@code
   *     Arrays.equals(a, b) == (Arrays.compare(a, b) == 0)
   * }
   *
   * @apiNote
   * This method behaves as if (for non-`null` array references):
   * {@code
   *     int i = Arrays.mismatch(a, b);
   *     if (i >= 0 && i < Math.min(a.length, b.length))
   *         return Short.compare(a[i], b[i]);
   *     return a.length - b.length;
   * }
   *
   * @param a the first array to compare
   * @param b the second array to compare
   * @return the value `0` if the first and second array are equal and
   *         contain the same elements in the same order;
   *         a value less than `0` if the first array is
   *         lexicographically less than the second array; and
   *         a value greater than `0` if the first array is
   *         lexicographically greater than the second array
   * @since 9
  */
  static compare(a: number[], b: number[]): number;
  /**
   * Compares two `short` arrays lexicographically over the specified
   * ranges.
   *
   * If the two arrays, over the specified ranges, share a common prefix
   * then the lexicographic comparison is the result of comparing two
   * elements, as if by {@link Short#compare(short, short)}, at a relative
   * index within the respective arrays that is the length of the prefix.
   * Otherwise, one array is a proper prefix of the other and, lexicographic
   * comparison is the result of comparing the two range lengths.
   * (See {@link #mismatch(short[], int, int, short[], int, int)} for the
   * definition of a common and proper prefix.)
   *
   * The comparison is consistent with
   * {@link #equals(short[], int, int, short[], int, int) equals}, more
   * specifically the following holds for arrays `a` and `b` with
   * specified ranges [`aFromIndex`, `atoIndex`) and
   * [`bFromIndex`, `btoIndex`) respectively:
   * {@code
   *     Arrays.equals(a, aFromIndex, aToIndex, b, bFromIndex, bToIndex) ==
   *         (Arrays.compare(a, aFromIndex, aToIndex, b, bFromIndex, bToIndex) == 0)
   * }
   *
   * @apiNote
   * This method behaves as if:
   * {@code
   *     int i = Arrays.mismatch(a, aFromIndex, aToIndex,
   *                             b, bFromIndex, bToIndex);
   *     if (i >= 0 && i < Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex))
   *         return Short.compare(a[aFromIndex + i], b[bFromIndex + i]);
   *     return (aToIndex - aFromIndex) - (bToIndex - bFromIndex);
   * }
   *
   * @param a the first array to compare
   * @param aFromIndex the index (inclusive) of the first element in the
   *                   first array to be compared
   * @param aToIndex the index (exclusive) of the last element in the
   *                 first array to be compared
   * @param b the second array to compare
   * @param bFromIndex the index (inclusive) of the first element in the
   *                   second array to be compared
   * @param bToIndex the index (exclusive) of the last element in the
   *                 second array to be compared
   * @return the value `0` if, over the specified ranges, the first and
   *         second array are equal and contain the same elements in the same
   *         order;
   *         a value less than `0` if, over the specified ranges, the
   *         first array is lexicographically less than the second array; and
   *         a value greater than `0` if, over the specified ranges, the
   *         first array is lexicographically greater than the second array
   * @throws IllegalArgumentException
   *         if `aFromIndex > aToIndex` or
   *         if `bFromIndex > bToIndex`
   * @throws ArrayIndexOutOfBoundsException
   *         if `aFromIndex < 0 or aToIndex > a.length` or
   *         if `bFromIndex < 0 or bToIndex > b.length`
   * @throws NullPointerException
   *         if either array is `null`
   * @since 9
  */
  static compare(a: number[], aFromIndex: number, aToIndex: number, b: number[], bFromIndex: number, bToIndex: number): number;
  /**
   * Compares two `short` arrays lexicographically, numerically treating
   * elements as unsigned.
   *
   * If the two arrays share a common prefix then the lexicographic
   * comparison is the result of comparing two elements, as if by
   * {@link Short#compareUnsigned(short, short)}, at an index within the
   * respective arrays that is the prefix length.
   * Otherwise, one array is a proper prefix of the other and, lexicographic
   * comparison is the result of comparing the two array lengths.
   * (See {@link #mismatch(short[], short[])} for the definition of a common
   * and proper prefix.)
   *
   * A `null` array reference is considered lexicographically less
   * than a non-`null` array reference.  Two `null` array
   * references are considered equal.
   *
   * @apiNote
   * This method behaves as if (for non-`null` array references):
   * {@code
   *     int i = Arrays.mismatch(a, b);
   *     if (i >= 0 && i < Math.min(a.length, b.length))
   *         return Short.compareUnsigned(a[i], b[i]);
   *     return a.length - b.length;
   * }
   *
   * @param a the first array to compare
   * @param b the second array to compare
   * @return the value `0` if the first and second array are
   *         equal and contain the same elements in the same order;
   *         a value less than `0` if the first array is
   *         lexicographically less than the second array; and
   *         a value greater than `0` if the first array is
   *         lexicographically greater than the second array
   * @since 9
  */
  static compareUnsigned(a: number[], b: number[]): number;
  /**
   * Compares two `short` arrays lexicographically over the specified
   * ranges, numerically treating elements as unsigned.
   *
   * If the two arrays, over the specified ranges, share a common prefix
   * then the lexicographic comparison is the result of comparing two
   * elements, as if by {@link Short#compareUnsigned(short, short)}, at a
   * relative index within the respective arrays that is the length of the
   * prefix.
   * Otherwise, one array is a proper prefix of the other and, lexicographic
   * comparison is the result of comparing the two range lengths.
   * (See {@link #mismatch(short[], int, int, short[], int, int)} for the
   * definition of a common and proper prefix.)
   *
   * @apiNote
   * This method behaves as if:
   * {@code
   *     int i = Arrays.mismatch(a, aFromIndex, aToIndex,
   *                             b, bFromIndex, bToIndex);
   *     if (i >= 0 && i < Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex))
   *         return Short.compareUnsigned(a[aFromIndex + i], b[bFromIndex + i]);
   *     return (aToIndex - aFromIndex) - (bToIndex - bFromIndex);
   * }
   *
   * @param a the first array to compare
   * @param aFromIndex the index (inclusive) of the first element in the
   *                   first array to be compared
   * @param aToIndex the index (exclusive) of the last element in the
   *                 first array to be compared
   * @param b the second array to compare
   * @param bFromIndex the index (inclusive) of the first element in the
   *                   second array to be compared
   * @param bToIndex the index (exclusive) of the last element in the
   *                 second array to be compared
   * @return the value `0` if, over the specified ranges, the first and
   *         second array are equal and contain the same elements in the same
   *         order;
   *         a value less than `0` if, over the specified ranges, the
   *         first array is lexicographically less than the second array; and
   *         a value greater than `0` if, over the specified ranges, the
   *         first array is lexicographically greater than the second array
   * @throws IllegalArgumentException
   *         if `aFromIndex > aToIndex` or
   *         if `bFromIndex > bToIndex`
   * @throws ArrayIndexOutOfBoundsException
   *         if `aFromIndex < 0 or aToIndex > a.length` or
   *         if `bFromIndex < 0 or bToIndex > b.length`
   * @throws NullPointerException
   *         if either array is null
   * @since 9
  */
  static compareUnsigned(a: number[], aFromIndex: number, aToIndex: number, b: number[], bFromIndex: number, bToIndex: number): number;
  /**
   * Compares two `char` arrays lexicographically.
   *
   * If the two arrays share a common prefix then the lexicographic
   * comparison is the result of comparing two elements, as if by
   * {@link Character#compare(char, char)}, at an index within the respective
   * arrays that is the prefix length.
   * Otherwise, one array is a proper prefix of the other and, lexicographic
   * comparison is the result of comparing the two array lengths.
   * (See {@link #mismatch(char[], char[])} for the definition of a common and
   * proper prefix.)
   *
   * A `null` array reference is considered lexicographically less
   * than a non-`null` array reference.  Two `null` array
   * references are considered equal.
   *
   * The comparison is consistent with {@link #equals(char[], char[]) equals},
   * more specifically the following holds for arrays `a` and `b`:
   * {@code
   *     Arrays.equals(a, b) == (Arrays.compare(a, b) == 0)
   * }
   *
   * @apiNote
   * This method behaves as if (for non-`null` array references):
   * {@code
   *     int i = Arrays.mismatch(a, b);
   *     if (i >= 0 && i < Math.min(a.length, b.length))
   *         return Character.compare(a[i], b[i]);
   *     return a.length - b.length;
   * }
   *
   * @param a the first array to compare
   * @param b the second array to compare
   * @return the value `0` if the first and second array are equal and
   *         contain the same elements in the same order;
   *         a value less than `0` if the first array is
   *         lexicographically less than the second array; and
   *         a value greater than `0` if the first array is
   *         lexicographically greater than the second array
   * @since 9
  */
  static compare(a: string[], b: string[]): number;
  /**
   * Compares two `char` arrays lexicographically over the specified
   * ranges.
   *
   * If the two arrays, over the specified ranges, share a common prefix
   * then the lexicographic comparison is the result of comparing two
   * elements, as if by {@link Character#compare(char, char)}, at a relative
   * index within the respective arrays that is the length of the prefix.
   * Otherwise, one array is a proper prefix of the other and, lexicographic
   * comparison is the result of comparing the two range lengths.
   * (See {@link #mismatch(char[], int, int, char[], int, int)} for the
   * definition of a common and proper prefix.)
   *
   * The comparison is consistent with
   * {@link #equals(char[], int, int, char[], int, int) equals}, more
   * specifically the following holds for arrays `a` and `b` with
   * specified ranges [`aFromIndex`, `atoIndex`) and
   * [`bFromIndex`, `btoIndex`) respectively:
   * {@code
   *     Arrays.equals(a, aFromIndex, aToIndex, b, bFromIndex, bToIndex) ==
   *         (Arrays.compare(a, aFromIndex, aToIndex, b, bFromIndex, bToIndex) == 0)
   * }
   *
   * @apiNote
   * This method behaves as if:
   * {@code
   *     int i = Arrays.mismatch(a, aFromIndex, aToIndex,
   *                             b, bFromIndex, bToIndex);
   *     if (i >= 0 && i < Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex))
   *         return Character.compare(a[aFromIndex + i], b[bFromIndex + i]);
   *     return (aToIndex - aFromIndex) - (bToIndex - bFromIndex);
   * }
   *
   * @param a the first array to compare
   * @param aFromIndex the index (inclusive) of the first element in the
   *                   first array to be compared
   * @param aToIndex the index (exclusive) of the last element in the
   *                 first array to be compared
   * @param b the second array to compare
   * @param bFromIndex the index (inclusive) of the first element in the
   *                   second array to be compared
   * @param bToIndex the index (exclusive) of the last element in the
   *                 second array to be compared
   * @return the value `0` if, over the specified ranges, the first and
   *         second array are equal and contain the same elements in the same
   *         order;
   *         a value less than `0` if, over the specified ranges, the
   *         first array is lexicographically less than the second array; and
   *         a value greater than `0` if, over the specified ranges, the
   *         first array is lexicographically greater than the second array
   * @throws IllegalArgumentException
   *         if `aFromIndex > aToIndex` or
   *         if `bFromIndex > bToIndex`
   * @throws ArrayIndexOutOfBoundsException
   *         if `aFromIndex < 0 or aToIndex > a.length` or
   *         if `bFromIndex < 0 or bToIndex > b.length`
   * @throws NullPointerException
   *         if either array is `null`
   * @since 9
  */
  static compare(a: string[], aFromIndex: number, aToIndex: number, b: string[], bFromIndex: number, bToIndex: number): number;
  /**
   * Compares two `int` arrays lexicographically.
   *
   * If the two arrays share a common prefix then the lexicographic
   * comparison is the result of comparing two elements, as if by
   * {@link Integer#compare(int, int)}, at an index within the respective
   * arrays that is the prefix length.
   * Otherwise, one array is a proper prefix of the other and, lexicographic
   * comparison is the result of comparing the two array lengths.
   * (See {@link #mismatch(int[], int[])} for the definition of a common and
   * proper prefix.)
   *
   * A `null` array reference is considered lexicographically less
   * than a non-`null` array reference.  Two `null` array
   * references are considered equal.
   *
   * The comparison is consistent with {@link #equals(int[], int[]) equals},
   * more specifically the following holds for arrays `a` and `b`:
   * {@code
   *     Arrays.equals(a, b) == (Arrays.compare(a, b) == 0)
   * }
   *
   * @apiNote
   * This method behaves as if (for non-`null` array references):
   * {@code
   *     int i = Arrays.mismatch(a, b);
   *     if (i >= 0 && i < Math.min(a.length, b.length))
   *         return Integer.compare(a[i], b[i]);
   *     return a.length - b.length;
   * }
   *
   * @param a the first array to compare
   * @param b the second array to compare
   * @return the value `0` if the first and second array are equal and
   *         contain the same elements in the same order;
   *         a value less than `0` if the first array is
   *         lexicographically less than the second array; and
   *         a value greater than `0` if the first array is
   *         lexicographically greater than the second array
   * @since 9
  */
  static compare(a: number[], b: number[]): number;
  /**
   * Compares two `int` arrays lexicographically over the specified
   * ranges.
   *
   * If the two arrays, over the specified ranges, share a common prefix
   * then the lexicographic comparison is the result of comparing two
   * elements, as if by {@link Integer#compare(int, int)}, at a relative index
   * within the respective arrays that is the length of the prefix.
   * Otherwise, one array is a proper prefix of the other and, lexicographic
   * comparison is the result of comparing the two range lengths.
   * (See {@link #mismatch(int[], int, int, int[], int, int)} for the
   * definition of a common and proper prefix.)
   *
   * The comparison is consistent with
   * {@link #equals(int[], int, int, int[], int, int) equals}, more
   * specifically the following holds for arrays `a` and `b` with
   * specified ranges [`aFromIndex`, `atoIndex`) and
   * [`bFromIndex`, `btoIndex`) respectively:
   * {@code
   *     Arrays.equals(a, aFromIndex, aToIndex, b, bFromIndex, bToIndex) ==
   *         (Arrays.compare(a, aFromIndex, aToIndex, b, bFromIndex, bToIndex) == 0)
   * }
   *
   * @apiNote
   * This method behaves as if:
   * {@code
   *     int i = Arrays.mismatch(a, aFromIndex, aToIndex,
   *                             b, bFromIndex, bToIndex);
   *     if (i >= 0 && i < Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex))
   *         return Integer.compare(a[aFromIndex + i], b[bFromIndex + i]);
   *     return (aToIndex - aFromIndex) - (bToIndex - bFromIndex);
   * }
   *
   * @param a the first array to compare
   * @param aFromIndex the index (inclusive) of the first element in the
   *                   first array to be compared
   * @param aToIndex the index (exclusive) of the last element in the
   *                 first array to be compared
   * @param b the second array to compare
   * @param bFromIndex the index (inclusive) of the first element in the
   *                   second array to be compared
   * @param bToIndex the index (exclusive) of the last element in the
   *                 second array to be compared
   * @return the value `0` if, over the specified ranges, the first and
   *         second array are equal and contain the same elements in the same
   *         order;
   *         a value less than `0` if, over the specified ranges, the
   *         first array is lexicographically less than the second array; and
   *         a value greater than `0` if, over the specified ranges, the
   *         first array is lexicographically greater than the second array
   * @throws IllegalArgumentException
   *         if `aFromIndex > aToIndex` or
   *         if `bFromIndex > bToIndex`
   * @throws ArrayIndexOutOfBoundsException
   *         if `aFromIndex < 0 or aToIndex > a.length` or
   *         if `bFromIndex < 0 or bToIndex > b.length`
   * @throws NullPointerException
   *         if either array is `null`
   * @since 9
  */
  static compare(a: number[], aFromIndex: number, aToIndex: number, b: number[], bFromIndex: number, bToIndex: number): number;
  /**
   * Compares two `int` arrays lexicographically, numerically treating
   * elements as unsigned.
   *
   * If the two arrays share a common prefix then the lexicographic
   * comparison is the result of comparing two elements, as if by
   * {@link Integer#compareUnsigned(int, int)}, at an index within the
   * respective arrays that is the prefix length.
   * Otherwise, one array is a proper prefix of the other and, lexicographic
   * comparison is the result of comparing the two array lengths.
   * (See {@link #mismatch(int[], int[])} for the definition of a common
   * and proper prefix.)
   *
   * A `null` array reference is considered lexicographically less
   * than a non-`null` array reference.  Two `null` array
   * references are considered equal.
   *
   * @apiNote
   * This method behaves as if (for non-`null` array references):
   * {@code
   *     int i = Arrays.mismatch(a, b);
   *     if (i >= 0 && i < Math.min(a.length, b.length))
   *         return Integer.compareUnsigned(a[i], b[i]);
   *     return a.length - b.length;
   * }
   *
   * @param a the first array to compare
   * @param b the second array to compare
   * @return the value `0` if the first and second array are
   *         equal and contain the same elements in the same order;
   *         a value less than `0` if the first array is
   *         lexicographically less than the second array; and
   *         a value greater than `0` if the first array is
   *         lexicographically greater than the second array
   * @since 9
  */
  static compareUnsigned(a: number[], b: number[]): number;
  /**
   * Compares two `int` arrays lexicographically over the specified
   * ranges, numerically treating elements as unsigned.
   *
   * If the two arrays, over the specified ranges, share a common prefix
   * then the lexicographic comparison is the result of comparing two
   * elements, as if by {@link Integer#compareUnsigned(int, int)}, at a
   * relative index within the respective arrays that is the length of the
   * prefix.
   * Otherwise, one array is a proper prefix of the other and, lexicographic
   * comparison is the result of comparing the two range lengths.
   * (See {@link #mismatch(int[], int, int, int[], int, int)} for the
   * definition of a common and proper prefix.)
   *
   * @apiNote
   * This method behaves as if:
   * {@code
   *     int i = Arrays.mismatch(a, aFromIndex, aToIndex,
   *                             b, bFromIndex, bToIndex);
   *     if (i >= 0 && i < Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex))
   *         return Integer.compareUnsigned(a[aFromIndex + i], b[bFromIndex + i]);
   *     return (aToIndex - aFromIndex) - (bToIndex - bFromIndex);
   * }
   *
   * @param a the first array to compare
   * @param aFromIndex the index (inclusive) of the first element in the
   *                   first array to be compared
   * @param aToIndex the index (exclusive) of the last element in the
   *                 first array to be compared
   * @param b the second array to compare
   * @param bFromIndex the index (inclusive) of the first element in the
   *                   second array to be compared
   * @param bToIndex the index (exclusive) of the last element in the
   *                 second array to be compared
   * @return the value `0` if, over the specified ranges, the first and
   *         second array are equal and contain the same elements in the same
   *         order;
   *         a value less than `0` if, over the specified ranges, the
   *         first array is lexicographically less than the second array; and
   *         a value greater than `0` if, over the specified ranges, the
   *         first array is lexicographically greater than the second array
   * @throws IllegalArgumentException
   *         if `aFromIndex > aToIndex` or
   *         if `bFromIndex > bToIndex`
   * @throws ArrayIndexOutOfBoundsException
   *         if `aFromIndex < 0 or aToIndex > a.length` or
   *         if `bFromIndex < 0 or bToIndex > b.length`
   * @throws NullPointerException
   *         if either array is null
   * @since 9
  */
  static compareUnsigned(a: number[], aFromIndex: number, aToIndex: number, b: number[], bFromIndex: number, bToIndex: number): number;
  /**
   * Compares two `long` arrays lexicographically.
   *
   * If the two arrays share a common prefix then the lexicographic
   * comparison is the result of comparing two elements, as if by
   * {@link Long#compare(long, long)}, at an index within the respective
   * arrays that is the prefix length.
   * Otherwise, one array is a proper prefix of the other and, lexicographic
   * comparison is the result of comparing the two array lengths.
   * (See {@link #mismatch(long[], long[])} for the definition of a common and
   * proper prefix.)
   *
   * A `null` array reference is considered lexicographically less
   * than a non-`null` array reference.  Two `null` array
   * references are considered equal.
   *
   * The comparison is consistent with {@link #equals(long[], long[]) equals},
   * more specifically the following holds for arrays `a` and `b`:
   * {@code
   *     Arrays.equals(a, b) == (Arrays.compare(a, b) == 0)
   * }
   *
   * @apiNote
   * This method behaves as if (for non-`null` array references):
   * {@code
   *     int i = Arrays.mismatch(a, b);
   *     if (i >= 0 && i < Math.min(a.length, b.length))
   *         return Long.compare(a[i], b[i]);
   *     return a.length - b.length;
   * }
   *
   * @param a the first array to compare
   * @param b the second array to compare
   * @return the value `0` if the first and second array are equal and
   *         contain the same elements in the same order;
   *         a value less than `0` if the first array is
   *         lexicographically less than the second array; and
   *         a value greater than `0` if the first array is
   *         lexicographically greater than the second array
   * @since 9
  */
  static compare(a: number[], b: number[]): number;
  /**
   * Compares two `long` arrays lexicographically over the specified
   * ranges.
   *
   * If the two arrays, over the specified ranges, share a common prefix
   * then the lexicographic comparison is the result of comparing two
   * elements, as if by {@link Long#compare(long, long)}, at a relative index
   * within the respective arrays that is the length of the prefix.
   * Otherwise, one array is a proper prefix of the other and, lexicographic
   * comparison is the result of comparing the two range lengths.
   * (See {@link #mismatch(long[], int, int, long[], int, int)} for the
   * definition of a common and proper prefix.)
   *
   * The comparison is consistent with
   * {@link #equals(long[], int, int, long[], int, int) equals}, more
   * specifically the following holds for arrays `a` and `b` with
   * specified ranges [`aFromIndex`, `atoIndex`) and
   * [`bFromIndex`, `btoIndex`) respectively:
   * {@code
   *     Arrays.equals(a, aFromIndex, aToIndex, b, bFromIndex, bToIndex) ==
   *         (Arrays.compare(a, aFromIndex, aToIndex, b, bFromIndex, bToIndex) == 0)
   * }
   *
   * @apiNote
   * This method behaves as if:
   * {@code
   *     int i = Arrays.mismatch(a, aFromIndex, aToIndex,
   *                             b, bFromIndex, bToIndex);
   *     if (i >= 0 && i < Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex))
   *         return Long.compare(a[aFromIndex + i], b[bFromIndex + i]);
   *     return (aToIndex - aFromIndex) - (bToIndex - bFromIndex);
   * }
   *
   * @param a the first array to compare
   * @param aFromIndex the index (inclusive) of the first element in the
   *                   first array to be compared
   * @param aToIndex the index (exclusive) of the last element in the
   *                 first array to be compared
   * @param b the second array to compare
   * @param bFromIndex the index (inclusive) of the first element in the
   *                   second array to be compared
   * @param bToIndex the index (exclusive) of the last element in the
   *                 second array to be compared
   * @return the value `0` if, over the specified ranges, the first and
   *         second array are equal and contain the same elements in the same
   *         order;
   *         a value less than `0` if, over the specified ranges, the
   *         first array is lexicographically less than the second array; and
   *         a value greater than `0` if, over the specified ranges, the
   *         first array is lexicographically greater than the second array
   * @throws IllegalArgumentException
   *         if `aFromIndex > aToIndex` or
   *         if `bFromIndex > bToIndex`
   * @throws ArrayIndexOutOfBoundsException
   *         if `aFromIndex < 0 or aToIndex > a.length` or
   *         if `bFromIndex < 0 or bToIndex > b.length`
   * @throws NullPointerException
   *         if either array is `null`
   * @since 9
  */
  static compare(a: number[], aFromIndex: number, aToIndex: number, b: number[], bFromIndex: number, bToIndex: number): number;
  /**
   * Compares two `long` arrays lexicographically, numerically treating
   * elements as unsigned.
   *
   * If the two arrays share a common prefix then the lexicographic
   * comparison is the result of comparing two elements, as if by
   * {@link Long#compareUnsigned(long, long)}, at an index within the
   * respective arrays that is the prefix length.
   * Otherwise, one array is a proper prefix of the other and, lexicographic
   * comparison is the result of comparing the two array lengths.
   * (See {@link #mismatch(long[], long[])} for the definition of a common
   * and proper prefix.)
   *
   * A `null` array reference is considered lexicographically less
   * than a non-`null` array reference.  Two `null` array
   * references are considered equal.
   *
   * @apiNote
   * This method behaves as if (for non-`null` array references):
   * {@code
   *     int i = Arrays.mismatch(a, b);
   *     if (i >= 0 && i < Math.min(a.length, b.length))
   *         return Long.compareUnsigned(a[i], b[i]);
   *     return a.length - b.length;
   * }
   *
   * @param a the first array to compare
   * @param b the second array to compare
   * @return the value `0` if the first and second array are
   *         equal and contain the same elements in the same order;
   *         a value less than `0` if the first array is
   *         lexicographically less than the second array; and
   *         a value greater than `0` if the first array is
   *         lexicographically greater than the second array
   * @since 9
  */
  static compareUnsigned(a: number[], b: number[]): number;
  /**
   * Compares two `long` arrays lexicographically over the specified
   * ranges, numerically treating elements as unsigned.
   *
   * If the two arrays, over the specified ranges, share a common prefix
   * then the lexicographic comparison is the result of comparing two
   * elements, as if by {@link Long#compareUnsigned(long, long)}, at a
   * relative index within the respective arrays that is the length of the
   * prefix.
   * Otherwise, one array is a proper prefix of the other and, lexicographic
   * comparison is the result of comparing the two range lengths.
   * (See {@link #mismatch(long[], int, int, long[], int, int)} for the
   * definition of a common and proper prefix.)
   *
   * @apiNote
   * This method behaves as if:
   * {@code
   *     int i = Arrays.mismatch(a, aFromIndex, aToIndex,
   *                             b, bFromIndex, bToIndex);
   *     if (i >= 0 && i < Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex))
   *         return Long.compareUnsigned(a[aFromIndex + i], b[bFromIndex + i]);
   *     return (aToIndex - aFromIndex) - (bToIndex - bFromIndex);
   * }
   *
   * @param a the first array to compare
   * @param aFromIndex the index (inclusive) of the first element in the
   *                   first array to be compared
   * @param aToIndex the index (exclusive) of the last element in the
   *                 first array to be compared
   * @param b the second array to compare
   * @param bFromIndex the index (inclusive) of the first element in the
   *                   second array to be compared
   * @param bToIndex the index (exclusive) of the last element in the
   *                 second array to be compared
   * @return the value `0` if, over the specified ranges, the first and
   *         second array are equal and contain the same elements in the same
   *         order;
   *         a value less than `0` if, over the specified ranges, the
   *         first array is lexicographically less than the second array; and
   *         a value greater than `0` if, over the specified ranges, the
   *         first array is lexicographically greater than the second array
   * @throws IllegalArgumentException
   *         if `aFromIndex > aToIndex` or
   *         if `bFromIndex > bToIndex`
   * @throws ArrayIndexOutOfBoundsException
   *         if `aFromIndex < 0 or aToIndex > a.length` or
   *         if `bFromIndex < 0 or bToIndex > b.length`
   * @throws NullPointerException
   *         if either array is null
   * @since 9
  */
  static compareUnsigned(a: number[], aFromIndex: number, aToIndex: number, b: number[], bFromIndex: number, bToIndex: number): number;
  /**
   * Compares two `float` arrays lexicographically.
   *
   * If the two arrays share a common prefix then the lexicographic
   * comparison is the result of comparing two elements, as if by
   * {@link Float#compare(float, float)}, at an index within the respective
   * arrays that is the prefix length.
   * Otherwise, one array is a proper prefix of the other and, lexicographic
   * comparison is the result of comparing the two array lengths.
   * (See {@link #mismatch(float[], float[])} for the definition of a common
   * and proper prefix.)
   *
   * A `null` array reference is considered lexicographically less
   * than a non-`null` array reference.  Two `null` array
   * references are considered equal.
   *
   * The comparison is consistent with {@link #equals(float[], float[]) equals},
   * more specifically the following holds for arrays `a` and `b`:
   * {@code
   *     Arrays.equals(a, b) == (Arrays.compare(a, b) == 0)
   * }
   *
   * @apiNote
   * This method behaves as if (for non-`null` array references):
   * {@code
   *     int i = Arrays.mismatch(a, b);
   *     if (i >= 0 && i < Math.min(a.length, b.length))
   *         return Float.compare(a[i], b[i]);
   *     return a.length - b.length;
   * }
   *
   * @param a the first array to compare
   * @param b the second array to compare
   * @return the value `0` if the first and second array are equal and
   *         contain the same elements in the same order;
   *         a value less than `0` if the first array is
   *         lexicographically less than the second array; and
   *         a value greater than `0` if the first array is
   *         lexicographically greater than the second array
   * @since 9
  */
  static compare(a: number[], b: number[]): number;
  /**
   * Compares two `float` arrays lexicographically over the specified
   * ranges.
   *
   * If the two arrays, over the specified ranges, share a common prefix
   * then the lexicographic comparison is the result of comparing two
   * elements, as if by {@link Float#compare(float, float)}, at a relative
   * index within the respective arrays that is the length of the prefix.
   * Otherwise, one array is a proper prefix of the other and, lexicographic
   * comparison is the result of comparing the two range lengths.
   * (See {@link #mismatch(float[], int, int, float[], int, int)} for the
   * definition of a common and proper prefix.)
   *
   * The comparison is consistent with
   * {@link #equals(float[], int, int, float[], int, int) equals}, more
   * specifically the following holds for arrays `a` and `b` with
   * specified ranges [`aFromIndex`, `atoIndex`) and
   * [`bFromIndex`, `btoIndex`) respectively:
   * {@code
   *     Arrays.equals(a, aFromIndex, aToIndex, b, bFromIndex, bToIndex) ==
   *         (Arrays.compare(a, aFromIndex, aToIndex, b, bFromIndex, bToIndex) == 0)
   * }
   *
   * @apiNote
   * This method behaves as if:
   * {@code
   *     int i = Arrays.mismatch(a, aFromIndex, aToIndex,
   *                             b, bFromIndex, bToIndex);
   *     if (i >= 0 && i < Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex))
   *         return Float.compare(a[aFromIndex + i], b[bFromIndex + i]);
   *     return (aToIndex - aFromIndex) - (bToIndex - bFromIndex);
   * }
   *
   * @param a the first array to compare
   * @param aFromIndex the index (inclusive) of the first element in the
   *                   first array to be compared
   * @param aToIndex the index (exclusive) of the last element in the
   *                 first array to be compared
   * @param b the second array to compare
   * @param bFromIndex the index (inclusive) of the first element in the
   *                   second array to be compared
   * @param bToIndex the index (exclusive) of the last element in the
   *                 second array to be compared
   * @return the value `0` if, over the specified ranges, the first and
   *         second array are equal and contain the same elements in the same
   *         order;
   *         a value less than `0` if, over the specified ranges, the
   *         first array is lexicographically less than the second array; and
   *         a value greater than `0` if, over the specified ranges, the
   *         first array is lexicographically greater than the second array
   * @throws IllegalArgumentException
   *         if `aFromIndex > aToIndex` or
   *         if `bFromIndex > bToIndex`
   * @throws ArrayIndexOutOfBoundsException
   *         if `aFromIndex < 0 or aToIndex > a.length` or
   *         if `bFromIndex < 0 or bToIndex > b.length`
   * @throws NullPointerException
   *         if either array is `null`
   * @since 9
  */
  static compare(a: number[], aFromIndex: number, aToIndex: number, b: number[], bFromIndex: number, bToIndex: number): number;
  /**
   * Compares two `double` arrays lexicographically.
   *
   * If the two arrays share a common prefix then the lexicographic
   * comparison is the result of comparing two elements, as if by
   * {@link Double#compare(double, double)}, at an index within the respective
   * arrays that is the prefix length.
   * Otherwise, one array is a proper prefix of the other and, lexicographic
   * comparison is the result of comparing the two array lengths.
   * (See {@link #mismatch(double[], double[])} for the definition of a common
   * and proper prefix.)
   *
   * A `null` array reference is considered lexicographically less
   * than a non-`null` array reference.  Two `null` array
   * references are considered equal.
   *
   * The comparison is consistent with {@link #equals(double[], double[]) equals},
   * more specifically the following holds for arrays `a` and `b`:
   * {@code
   *     Arrays.equals(a, b) == (Arrays.compare(a, b) == 0)
   * }
   *
   * @apiNote
   * This method behaves as if (for non-`null` array references):
   * {@code
   *     int i = Arrays.mismatch(a, b);
   *     if (i >= 0 && i < Math.min(a.length, b.length))
   *         return Double.compare(a[i], b[i]);
   *     return a.length - b.length;
   * }
   *
   * @param a the first array to compare
   * @param b the second array to compare
   * @return the value `0` if the first and second array are equal and
   *         contain the same elements in the same order;
   *         a value less than `0` if the first array is
   *         lexicographically less than the second array; and
   *         a value greater than `0` if the first array is
   *         lexicographically greater than the second array
   * @since 9
  */
  static compare(a: number[], b: number[]): number;
  /**
   * Compares two `double` arrays lexicographically over the specified
   * ranges.
   *
   * If the two arrays, over the specified ranges, share a common prefix
   * then the lexicographic comparison is the result of comparing two
   * elements, as if by {@link Double#compare(double, double)}, at a relative
   * index within the respective arrays that is the length of the prefix.
   * Otherwise, one array is a proper prefix of the other and, lexicographic
   * comparison is the result of comparing the two range lengths.
   * (See {@link #mismatch(double[], int, int, double[], int, int)} for the
   * definition of a common and proper prefix.)
   *
   * The comparison is consistent with
   * {@link #equals(double[], int, int, double[], int, int) equals}, more
   * specifically the following holds for arrays `a` and `b` with
   * specified ranges [`aFromIndex`, `atoIndex`) and
   * [`bFromIndex`, `btoIndex`) respectively:
   * {@code
   *     Arrays.equals(a, aFromIndex, aToIndex, b, bFromIndex, bToIndex) ==
   *         (Arrays.compare(a, aFromIndex, aToIndex, b, bFromIndex, bToIndex) == 0)
   * }
   *
   * @apiNote
   * This method behaves as if:
   * {@code
   *     int i = Arrays.mismatch(a, aFromIndex, aToIndex,
   *                             b, bFromIndex, bToIndex);
   *     if (i >= 0 && i < Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex))
   *         return Double.compare(a[aFromIndex + i], b[bFromIndex + i]);
   *     return (aToIndex - aFromIndex) - (bToIndex - bFromIndex);
   * }
   *
   * @param a the first array to compare
   * @param aFromIndex the index (inclusive) of the first element in the
   *                   first array to be compared
   * @param aToIndex the index (exclusive) of the last element in the
   *                 first array to be compared
   * @param b the second array to compare
   * @param bFromIndex the index (inclusive) of the first element in the
   *                   second array to be compared
   * @param bToIndex the index (exclusive) of the last element in the
   *                 second array to be compared
   * @return the value `0` if, over the specified ranges, the first and
   *         second array are equal and contain the same elements in the same
   *         order;
   *         a value less than `0` if, over the specified ranges, the
   *         first array is lexicographically less than the second array; and
   *         a value greater than `0` if, over the specified ranges, the
   *         first array is lexicographically greater than the second array
   * @throws IllegalArgumentException
   *         if `aFromIndex > aToIndex` or
   *         if `bFromIndex > bToIndex`
   * @throws ArrayIndexOutOfBoundsException
   *         if `aFromIndex < 0 or aToIndex > a.length` or
   *         if `bFromIndex < 0 or bToIndex > b.length`
   * @throws NullPointerException
   *         if either array is `null`
   * @since 9
  */
  static compare(a: number[], aFromIndex: number, aToIndex: number, b: number[], bFromIndex: number, bToIndex: number): number;
  /**
   * Compares two `Object` arrays, within comparable elements,
   * lexicographically.
   *
   * If the two arrays share a common prefix then the lexicographic
   * comparison is the result of comparing two elements of type `T` at
   * an index `i` within the respective arrays that is the prefix
   * length, as if by:
   * {@code
   *     Comparator.nullsFirst(Comparator.naturalOrder()).
   *         compare(a[i], b[i])
   * }
   * Otherwise, one array is a proper prefix of the other and, lexicographic
   * comparison is the result of comparing the two array lengths.
   * (See {@link #mismatch(Object[], Object[])} for the definition of a common
   * and proper prefix.)
   *
   * A `null` array reference is considered lexicographically less
   * than a non-`null` array reference. Two `null` array
   * references are considered equal.
   * A `null` array element is considered lexicographically less than a
   * non-`null` array element. Two `null` array elements are
   * considered equal.
   *
   * The comparison is consistent with {@link #equals(Object[], Object[]) equals},
   * more specifically the following holds for arrays `a` and `b`:
   * {@code
   *     Arrays.equals(a, b) == (Arrays.compare(a, b) == 0)
   * }
   *
   * @apiNote
   * This method behaves as if (for non-`null` array references
   * and elements):
   * {@code
   *     int i = Arrays.mismatch(a, b);
   *     if (i >= 0 && i < Math.min(a.length, b.length))
   *         return a[i].compareTo(b[i]);
   *     return a.length - b.length;
   * }
   *
   * @param a the first array to compare
   * @param b the second array to compare
   * @param  the type of comparable array elements
   * @return the value `0` if the first and second array are equal and
   *         contain the same elements in the same order;
   *         a value less than `0` if the first array is
   *         lexicographically less than the second array; and
   *         a value greater than `0` if the first array is
   *         lexicographically greater than the second array
   * @since 9
  */
  static compare<T>(a: T[], b: T[]): number;
  /**
   * Compares two `Object` arrays lexicographically over the specified
   * ranges.
   *
   * If the two arrays, over the specified ranges, share a common prefix
   * then the lexicographic comparison is the result of comparing two
   * elements of type `T` at a relative index `i` within the
   * respective arrays that is the prefix length, as if by:
   * {@code
   *     Comparator.nullsFirst(Comparator.naturalOrder()).
   *         compare(a[aFromIndex + i, b[bFromIndex + i])
   * }
   * Otherwise, one array is a proper prefix of the other and, lexicographic
   * comparison is the result of comparing the two range lengths.
   * (See {@link #mismatch(Object[], int, int, Object[], int, int)} for the
   * definition of a common and proper prefix.)
   *
   * The comparison is consistent with
   * {@link #equals(Object[], int, int, Object[], int, int) equals}, more
   * specifically the following holds for arrays `a` and `b` with
   * specified ranges [`aFromIndex`, `atoIndex`) and
   * [`bFromIndex`, `btoIndex`) respectively:
   * {@code
   *     Arrays.equals(a, aFromIndex, aToIndex, b, bFromIndex, bToIndex) ==
   *         (Arrays.compare(a, aFromIndex, aToIndex, b, bFromIndex, bToIndex) == 0)
   * }
   *
   * @apiNote
   * This method behaves as if (for non-`null` array elements):
   * {@code
   *     int i = Arrays.mismatch(a, aFromIndex, aToIndex,
   *                             b, bFromIndex, bToIndex);
   *     if (i >= 0 && i < Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex))
   *         return a[aFromIndex + i].compareTo(b[bFromIndex + i]);
   *     return (aToIndex - aFromIndex) - (bToIndex - bFromIndex);
   * }
   *
   * @param a the first array to compare
   * @param aFromIndex the index (inclusive) of the first element in the
   *                   first array to be compared
   * @param aToIndex the index (exclusive) of the last element in the
   *                 first array to be compared
   * @param b the second array to compare
   * @param bFromIndex the index (inclusive) of the first element in the
   *                   second array to be compared
   * @param bToIndex the index (exclusive) of the last element in the
   *                 second array to be compared
   * @param  the type of comparable array elements
   * @return the value `0` if, over the specified ranges, the first and
   *         second array are equal and contain the same elements in the same
   *         order;
   *         a value less than `0` if, over the specified ranges, the
   *         first array is lexicographically less than the second array; and
   *         a value greater than `0` if, over the specified ranges, the
   *         first array is lexicographically greater than the second array
   * @throws IllegalArgumentException
   *         if `aFromIndex > aToIndex` or
   *         if `bFromIndex > bToIndex`
   * @throws ArrayIndexOutOfBoundsException
   *         if `aFromIndex < 0 or aToIndex > a.length` or
   *         if `bFromIndex < 0 or bToIndex > b.length`
   * @throws NullPointerException
   *         if either array is `null`
   * @since 9
  */
  static compare<T>(a: T[], aFromIndex: number, aToIndex: number, b: T[], bFromIndex: number, bToIndex: number): number;
  /**
   * Compares two `Object` arrays lexicographically using a specified
   * comparator.
   *
   * If the two arrays share a common prefix then the lexicographic
   * comparison is the result of comparing with the specified comparator two
   * elements at an index within the respective arrays that is the prefix
   * length.
   * Otherwise, one array is a proper prefix of the other and, lexicographic
   * comparison is the result of comparing the two array lengths.
   * (See {@link #mismatch(Object[], Object[])} for the definition of a common
   * and proper prefix.)
   *
   * A `null` array reference is considered lexicographically less
   * than a non-`null` array reference.  Two `null` array
   * references are considered equal.
   *
   * @apiNote
   * This method behaves as if (for non-`null` array references):
   * {@code
   *     int i = Arrays.mismatch(a, b, cmp);
   *     if (i >= 0 && i < Math.min(a.length, b.length))
   *         return cmp.compare(a[i], b[i]);
   *     return a.length - b.length;
   * }
   *
   * @param a the first array to compare
   * @param b the second array to compare
   * @param cmp the comparator to compare array elements
   * @param  the type of array elements
   * @return the value `0` if the first and second array are equal and
   *         contain the same elements in the same order;
   *         a value less than `0` if the first array is
   *         lexicographically less than the second array; and
   *         a value greater than `0` if the first array is
   *         lexicographically greater than the second array
   * @throws NullPointerException if the comparator is `null`
   * @since 9
  */
  static compare<T>(a: T[], b: T[], cmp: Comparator<any>): number;
  /**
   * Compares two `Object` arrays lexicographically over the specified
   * ranges.
   *
   * If the two arrays, over the specified ranges, share a common prefix
   * then the lexicographic comparison is the result of comparing with the
   * specified comparator two elements at a relative index within the
   * respective arrays that is the prefix length.
   * Otherwise, one array is a proper prefix of the other and, lexicographic
   * comparison is the result of comparing the two range lengths.
   * (See {@link #mismatch(Object[], int, int, Object[], int, int)} for the
   * definition of a common and proper prefix.)
   *
   * @apiNote
   * This method behaves as if (for non-`null` array elements):
   * {@code
   *     int i = Arrays.mismatch(a, aFromIndex, aToIndex,
   *                             b, bFromIndex, bToIndex, cmp);
   *     if (i >= 0 && i < Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex))
   *         return cmp.compare(a[aFromIndex + i], b[bFromIndex + i]);
   *     return (aToIndex - aFromIndex) - (bToIndex - bFromIndex);
   * }
   *
   * @param a the first array to compare
   * @param aFromIndex the index (inclusive) of the first element in the
   *                   first array to be compared
   * @param aToIndex the index (exclusive) of the last element in the
   *                 first array to be compared
   * @param b the second array to compare
   * @param bFromIndex the index (inclusive) of the first element in the
   *                   second array to be compared
   * @param bToIndex the index (exclusive) of the last element in the
   *                 second array to be compared
   * @param cmp the comparator to compare array elements
   * @param  the type of array elements
   * @return the value `0` if, over the specified ranges, the first and
   *         second array are equal and contain the same elements in the same
   *         order;
   *         a value less than `0` if, over the specified ranges, the
   *         first array is lexicographically less than the second array; and
   *         a value greater than `0` if, over the specified ranges, the
   *         first array is lexicographically greater than the second array
   * @throws IllegalArgumentException
   *         if `aFromIndex > aToIndex` or
   *         if `bFromIndex > bToIndex`
   * @throws ArrayIndexOutOfBoundsException
   *         if `aFromIndex < 0 or aToIndex > a.length` or
   *         if `bFromIndex < 0 or bToIndex > b.length`
   * @throws NullPointerException
   *         if either array or the comparator is `null`
   * @since 9
  */
  static compare<T>(a: T[], aFromIndex: number, aToIndex: number, b: T[], bFromIndex: number, bToIndex: number, cmp: Comparator<any>): number;
  /**
   * Finds and returns the index of the first mismatch between two
   * `boolean` arrays, otherwise return -1 if no mismatch is found.  The
   * index will be in the range of 0 (inclusive) up to the length (inclusive)
   * of the smaller array.
   *
   * If the two arrays share a common prefix then the returned index is the
   * length of the common prefix and it follows that there is a mismatch
   * between the two elements at that index within the respective arrays.
   * If one array is a proper prefix of the other then the returned index is
   * the length of the smaller array and it follows that the index is only
   * valid for the larger array.
   * Otherwise, there is no mismatch.
   *
   * Two non-`null` arrays, `a` and `b`, share a common
   * prefix of length `pl` if the following expression is true:
   * {@code
   *     pl >= 0 &&
   *     pl < Math.min(a.length, b.length) &&
   *     Arrays.equals(a, 0, pl, b, 0, pl) &&
   *     a[pl] != b[pl]
   * }
   * Note that a common prefix length of `0` indicates that the first
   * elements from each array mismatch.
   *
   * Two non-`null` arrays, `a` and `b`, share a proper
   * prefix if the following expression is true:
   * {@code
   *     a.length != b.length &&
   *     Arrays.equals(a, 0, Math.min(a.length, b.length),
   *                   b, 0, Math.min(a.length, b.length))
   * }
   *
   * @param a the first array to be tested for a mismatch
   * @param b the second array to be tested for a mismatch
   * @return the index of the first mismatch between the two arrays,
   *         otherwise `-1`.
   * @throws NullPointerException
   *         if either array is `null`
   * @since 9
  */
  static mismatch(a: boolean[], b: boolean[]): number;
  /**
   * Finds and returns the relative index of the first mismatch between two
   * `boolean` arrays over the specified ranges, otherwise return -1 if
   * no mismatch is found.  The index will be in the range of 0 (inclusive) up
   * to the length (inclusive) of the smaller range.
   *
   * If the two arrays, over the specified ranges, share a common prefix
   * then the returned relative index is the length of the common prefix and
   * it follows that there is a mismatch between the two elements at that
   * relative index within the respective arrays.
   * If one array is a proper prefix of the other, over the specified ranges,
   * then the returned relative index is the length of the smaller range and
   * it follows that the relative index is only valid for the array with the
   * larger range.
   * Otherwise, there is no mismatch.
   *
   * Two non-`null` arrays, `a` and `b` with specified
   * ranges [`aFromIndex`, `atoIndex`) and
   * [`bFromIndex`, `btoIndex`) respectively, share a common
   * prefix of length `pl` if the following expression is true:
   * {@code
   *     pl >= 0 &&
   *     pl < Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex) &&
   *     Arrays.equals(a, aFromIndex, aFromIndex + pl, b, bFromIndex, bFromIndex + pl) &&
   *     a[aFromIndex + pl] != b[bFromIndex + pl]
   * }
   * Note that a common prefix length of `0` indicates that the first
   * elements from each array mismatch.
   *
   * Two non-`null` arrays, `a` and `b` with specified
   * ranges [`aFromIndex`, `atoIndex`) and
   * [`bFromIndex`, `btoIndex`) respectively, share a proper
   * prefix if the following expression is true:
   * {@code
   *     (aToIndex - aFromIndex) != (bToIndex - bFromIndex) &&
   *     Arrays.equals(a, 0, Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex),
   *                   b, 0, Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex))
   * }
   *
   * @param a the first array to be tested for a mismatch
   * @param aFromIndex the index (inclusive) of the first element in the
   *                   first array to be tested
   * @param aToIndex the index (exclusive) of the last element in the
   *                 first array to be tested
   * @param b the second array to be tested for a mismatch
   * @param bFromIndex the index (inclusive) of the first element in the
   *                   second array to be tested
   * @param bToIndex the index (exclusive) of the last element in the
   *                 second array to be tested
   * @return the relative index of the first mismatch between the two arrays
   *         over the specified ranges, otherwise `-1`.
   * @throws IllegalArgumentException
   *         if `aFromIndex > aToIndex` or
   *         if `bFromIndex > bToIndex`
   * @throws ArrayIndexOutOfBoundsException
   *         if `aFromIndex < 0 or aToIndex > a.length` or
   *         if `bFromIndex < 0 or bToIndex > b.length`
   * @throws NullPointerException
   *         if either array is `null`
   * @since 9
  */
  static mismatch(a: boolean[], aFromIndex: number, aToIndex: number, b: boolean[], bFromIndex: number, bToIndex: number): number;
  /**
   * Finds and returns the index of the first mismatch between two `byte`
   * arrays, otherwise return -1 if no mismatch is found.  The index will be
   * in the range of 0 (inclusive) up to the length (inclusive) of the smaller
   * array.
   *
   * If the two arrays share a common prefix then the returned index is the
   * length of the common prefix and it follows that there is a mismatch
   * between the two elements at that index within the respective arrays.
   * If one array is a proper prefix of the other then the returned index is
   * the length of the smaller array and it follows that the index is only
   * valid for the larger array.
   * Otherwise, there is no mismatch.
   *
   * Two non-`null` arrays, `a` and `b`, share a common
   * prefix of length `pl` if the following expression is true:
   * {@code
   *     pl >= 0 &&
   *     pl < Math.min(a.length, b.length) &&
   *     Arrays.equals(a, 0, pl, b, 0, pl) &&
   *     a[pl] != b[pl]
   * }
   * Note that a common prefix length of `0` indicates that the first
   * elements from each array mismatch.
   *
   * Two non-`null` arrays, `a` and `b`, share a proper
   * prefix if the following expression is true:
   * {@code
   *     a.length != b.length &&
   *     Arrays.equals(a, 0, Math.min(a.length, b.length),
   *                   b, 0, Math.min(a.length, b.length))
   * }
   *
   * @param a the first array to be tested for a mismatch
   * @param b the second array to be tested for a mismatch
   * @return the index of the first mismatch between the two arrays,
   *         otherwise `-1`.
   * @throws NullPointerException
   *         if either array is `null`
   * @since 9
  */
  static mismatch(a: number[], b: number[]): number;
  /**
   * Finds and returns the relative index of the first mismatch between two
   * `byte` arrays over the specified ranges, otherwise return -1 if no
   * mismatch is found.  The index will be in the range of 0 (inclusive) up to
   * the length (inclusive) of the smaller range.
   *
   * If the two arrays, over the specified ranges, share a common prefix
   * then the returned relative index is the length of the common prefix and
   * it follows that there is a mismatch between the two elements at that
   * relative index within the respective arrays.
   * If one array is a proper prefix of the other, over the specified ranges,
   * then the returned relative index is the length of the smaller range and
   * it follows that the relative index is only valid for the array with the
   * larger range.
   * Otherwise, there is no mismatch.
   *
   * Two non-`null` arrays, `a` and `b` with specified
   * ranges [`aFromIndex`, `atoIndex`) and
   * [`bFromIndex`, `btoIndex`) respectively, share a common
   * prefix of length `pl` if the following expression is true:
   * {@code
   *     pl >= 0 &&
   *     pl < Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex) &&
   *     Arrays.equals(a, aFromIndex, aFromIndex + pl, b, bFromIndex, bFromIndex + pl) &&
   *     a[aFromIndex + pl] != b[bFromIndex + pl]
   * }
   * Note that a common prefix length of `0` indicates that the first
   * elements from each array mismatch.
   *
   * Two non-`null` arrays, `a` and `b` with specified
   * ranges [`aFromIndex`, `atoIndex`) and
   * [`bFromIndex`, `btoIndex`) respectively, share a proper
   * prefix if the following expression is true:
   * {@code
   *     (aToIndex - aFromIndex) != (bToIndex - bFromIndex) &&
   *     Arrays.equals(a, 0, Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex),
   *                   b, 0, Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex))
   * }
   *
   * @param a the first array to be tested for a mismatch
   * @param aFromIndex the index (inclusive) of the first element in the
   *                   first array to be tested
   * @param aToIndex the index (exclusive) of the last element in the
   *                 first array to be tested
   * @param b the second array to be tested for a mismatch
   * @param bFromIndex the index (inclusive) of the first element in the
   *                   second array to be tested
   * @param bToIndex the index (exclusive) of the last element in the
   *                 second array to be tested
   * @return the relative index of the first mismatch between the two arrays
   *         over the specified ranges, otherwise `-1`.
   * @throws IllegalArgumentException
   *         if `aFromIndex > aToIndex` or
   *         if `bFromIndex > bToIndex`
   * @throws ArrayIndexOutOfBoundsException
   *         if `aFromIndex < 0 or aToIndex > a.length` or
   *         if `bFromIndex < 0 or bToIndex > b.length`
   * @throws NullPointerException
   *         if either array is `null`
   * @since 9
  */
  static mismatch(a: number[], aFromIndex: number, aToIndex: number, b: number[], bFromIndex: number, bToIndex: number): number;
  /**
   * Finds and returns the index of the first mismatch between two `char`
   * arrays, otherwise return -1 if no mismatch is found.  The index will be
   * in the range of 0 (inclusive) up to the length (inclusive) of the smaller
   * array.
   *
   * If the two arrays share a common prefix then the returned index is the
   * length of the common prefix and it follows that there is a mismatch
   * between the two elements at that index within the respective arrays.
   * If one array is a proper prefix of the other then the returned index is
   * the length of the smaller array and it follows that the index is only
   * valid for the larger array.
   * Otherwise, there is no mismatch.
   *
   * Two non-`null` arrays, `a` and `b`, share a common
   * prefix of length `pl` if the following expression is true:
   * {@code
   *     pl >= 0 &&
   *     pl < Math.min(a.length, b.length) &&
   *     Arrays.equals(a, 0, pl, b, 0, pl) &&
   *     a[pl] != b[pl]
   * }
   * Note that a common prefix length of `0` indicates that the first
   * elements from each array mismatch.
   *
   * Two non-`null` arrays, `a` and `b`, share a proper
   * prefix if the following expression is true:
   * {@code
   *     a.length != b.length &&
   *     Arrays.equals(a, 0, Math.min(a.length, b.length),
   *                   b, 0, Math.min(a.length, b.length))
   * }
   *
   * @param a the first array to be tested for a mismatch
   * @param b the second array to be tested for a mismatch
   * @return the index of the first mismatch between the two arrays,
   *         otherwise `-1`.
   * @throws NullPointerException
   *         if either array is `null`
   * @since 9
  */
  static mismatch(a: string[], b: string[]): number;
  /**
   * Finds and returns the relative index of the first mismatch between two
   * `char` arrays over the specified ranges, otherwise return -1 if no
   * mismatch is found.  The index will be in the range of 0 (inclusive) up to
   * the length (inclusive) of the smaller range.
   *
   * If the two arrays, over the specified ranges, share a common prefix
   * then the returned relative index is the length of the common prefix and
   * it follows that there is a mismatch between the two elements at that
   * relative index within the respective arrays.
   * If one array is a proper prefix of the other, over the specified ranges,
   * then the returned relative index is the length of the smaller range and
   * it follows that the relative index is only valid for the array with the
   * larger range.
   * Otherwise, there is no mismatch.
   *
   * Two non-`null` arrays, `a` and `b` with specified
   * ranges [`aFromIndex`, `atoIndex`) and
   * [`bFromIndex`, `btoIndex`) respectively, share a common
   * prefix of length `pl` if the following expression is true:
   * {@code
   *     pl >= 0 &&
   *     pl < Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex) &&
   *     Arrays.equals(a, aFromIndex, aFromIndex + pl, b, bFromIndex, bFromIndex + pl) &&
   *     a[aFromIndex + pl] != b[bFromIndex + pl]
   * }
   * Note that a common prefix length of `0` indicates that the first
   * elements from each array mismatch.
   *
   * Two non-`null` arrays, `a` and `b` with specified
   * ranges [`aFromIndex`, `atoIndex`) and
   * [`bFromIndex`, `btoIndex`) respectively, share a proper
   * prefix if the following expression is true:
   * {@code
   *     (aToIndex - aFromIndex) != (bToIndex - bFromIndex) &&
   *     Arrays.equals(a, 0, Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex),
   *                   b, 0, Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex))
   * }
   *
   * @param a the first array to be tested for a mismatch
   * @param aFromIndex the index (inclusive) of the first element in the
   *                   first array to be tested
   * @param aToIndex the index (exclusive) of the last element in the
   *                 first array to be tested
   * @param b the second array to be tested for a mismatch
   * @param bFromIndex the index (inclusive) of the first element in the
   *                   second array to be tested
   * @param bToIndex the index (exclusive) of the last element in the
   *                 second array to be tested
   * @return the relative index of the first mismatch between the two arrays
   *         over the specified ranges, otherwise `-1`.
   * @throws IllegalArgumentException
   *         if `aFromIndex > aToIndex` or
   *         if `bFromIndex > bToIndex`
   * @throws ArrayIndexOutOfBoundsException
   *         if `aFromIndex < 0 or aToIndex > a.length` or
   *         if `bFromIndex < 0 or bToIndex > b.length`
   * @throws NullPointerException
   *         if either array is `null`
   * @since 9
  */
  static mismatch(a: string[], aFromIndex: number, aToIndex: number, b: string[], bFromIndex: number, bToIndex: number): number;
  /**
   * Finds and returns the index of the first mismatch between two `short`
   * arrays, otherwise return -1 if no mismatch is found.  The index will be
   * in the range of 0 (inclusive) up to the length (inclusive) of the smaller
   * array.
   *
   * If the two arrays share a common prefix then the returned index is the
   * length of the common prefix and it follows that there is a mismatch
   * between the two elements at that index within the respective arrays.
   * If one array is a proper prefix of the other then the returned index is
   * the length of the smaller array and it follows that the index is only
   * valid for the larger array.
   * Otherwise, there is no mismatch.
   *
   * Two non-`null` arrays, `a` and `b`, share a common
   * prefix of length `pl` if the following expression is true:
   * {@code
   *     pl >= 0 &&
   *     pl < Math.min(a.length, b.length) &&
   *     Arrays.equals(a, 0, pl, b, 0, pl) &&
   *     a[pl] != b[pl]
   * }
   * Note that a common prefix length of `0` indicates that the first
   * elements from each array mismatch.
   *
   * Two non-`null` arrays, `a` and `b`, share a proper
   * prefix if the following expression is true:
   * {@code
   *     a.length != b.length &&
   *     Arrays.equals(a, 0, Math.min(a.length, b.length),
   *                   b, 0, Math.min(a.length, b.length))
   * }
   *
   * @param a the first array to be tested for a mismatch
   * @param b the second array to be tested for a mismatch
   * @return the index of the first mismatch between the two arrays,
   *         otherwise `-1`.
   * @throws NullPointerException
   *         if either array is `null`
   * @since 9
  */
  static mismatch(a: number[], b: number[]): number;
  /**
   * Finds and returns the relative index of the first mismatch between two
   * `short` arrays over the specified ranges, otherwise return -1 if no
   * mismatch is found.  The index will be in the range of 0 (inclusive) up to
   * the length (inclusive) of the smaller range.
   *
   * If the two arrays, over the specified ranges, share a common prefix
   * then the returned relative index is the length of the common prefix and
   * it follows that there is a mismatch between the two elements at that
   * relative index within the respective arrays.
   * If one array is a proper prefix of the other, over the specified ranges,
   * then the returned relative index is the length of the smaller range and
   * it follows that the relative index is only valid for the array with the
   * larger range.
   * Otherwise, there is no mismatch.
   *
   * Two non-`null` arrays, `a` and `b` with specified
   * ranges [`aFromIndex`, `atoIndex`) and
   * [`bFromIndex`, `btoIndex`) respectively, share a common
   * prefix of length `pl` if the following expression is true:
   * {@code
   *     pl >= 0 &&
   *     pl < Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex) &&
   *     Arrays.equals(a, aFromIndex, aFromIndex + pl, b, bFromIndex, bFromIndex + pl) &&
   *     a[aFromIndex + pl] != b[bFromIndex + pl]
   * }
   * Note that a common prefix length of `0` indicates that the first
   * elements from each array mismatch.
   *
   * Two non-`null` arrays, `a` and `b` with specified
   * ranges [`aFromIndex`, `atoIndex`) and
   * [`bFromIndex`, `btoIndex`) respectively, share a proper
   * prefix if the following expression is true:
   * {@code
   *     (aToIndex - aFromIndex) != (bToIndex - bFromIndex) &&
   *     Arrays.equals(a, 0, Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex),
   *                   b, 0, Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex))
   * }
   *
   * @param a the first array to be tested for a mismatch
   * @param aFromIndex the index (inclusive) of the first element in the
   *                   first array to be tested
   * @param aToIndex the index (exclusive) of the last element in the
   *                 first array to be tested
   * @param b the second array to be tested for a mismatch
   * @param bFromIndex the index (inclusive) of the first element in the
   *                   second array to be tested
   * @param bToIndex the index (exclusive) of the last element in the
   *                 second array to be tested
   * @return the relative index of the first mismatch between the two arrays
   *         over the specified ranges, otherwise `-1`.
   * @throws IllegalArgumentException
   *         if `aFromIndex > aToIndex` or
   *         if `bFromIndex > bToIndex`
   * @throws ArrayIndexOutOfBoundsException
   *         if `aFromIndex < 0 or aToIndex > a.length` or
   *         if `bFromIndex < 0 or bToIndex > b.length`
   * @throws NullPointerException
   *         if either array is `null`
   * @since 9
  */
  static mismatch(a: number[], aFromIndex: number, aToIndex: number, b: number[], bFromIndex: number, bToIndex: number): number;
  /**
   * Finds and returns the index of the first mismatch between two `int`
   * arrays, otherwise return -1 if no mismatch is found.  The index will be
   * in the range of 0 (inclusive) up to the length (inclusive) of the smaller
   * array.
   *
   * If the two arrays share a common prefix then the returned index is the
   * length of the common prefix and it follows that there is a mismatch
   * between the two elements at that index within the respective arrays.
   * If one array is a proper prefix of the other then the returned index is
   * the length of the smaller array and it follows that the index is only
   * valid for the larger array.
   * Otherwise, there is no mismatch.
   *
   * Two non-`null` arrays, `a` and `b`, share a common
   * prefix of length `pl` if the following expression is true:
   * {@code
   *     pl >= 0 &&
   *     pl < Math.min(a.length, b.length) &&
   *     Arrays.equals(a, 0, pl, b, 0, pl) &&
   *     a[pl] != b[pl]
   * }
   * Note that a common prefix length of `0` indicates that the first
   * elements from each array mismatch.
   *
   * Two non-`null` arrays, `a` and `b`, share a proper
   * prefix if the following expression is true:
   * {@code
   *     a.length != b.length &&
   *     Arrays.equals(a, 0, Math.min(a.length, b.length),
   *                   b, 0, Math.min(a.length, b.length))
   * }
   *
   * @param a the first array to be tested for a mismatch
   * @param b the second array to be tested for a mismatch
   * @return the index of the first mismatch between the two arrays,
   *         otherwise `-1`.
   * @throws NullPointerException
   *         if either array is `null`
   * @since 9
  */
  static mismatch(a: number[], b: number[]): number;
  /**
   * Finds and returns the relative index of the first mismatch between two
   * `int` arrays over the specified ranges, otherwise return -1 if no
   * mismatch is found.  The index will be in the range of 0 (inclusive) up to
   * the length (inclusive) of the smaller range.
   *
   * If the two arrays, over the specified ranges, share a common prefix
   * then the returned relative index is the length of the common prefix and
   * it follows that there is a mismatch between the two elements at that
   * relative index within the respective arrays.
   * If one array is a proper prefix of the other, over the specified ranges,
   * then the returned relative index is the length of the smaller range and
   * it follows that the relative index is only valid for the array with the
   * larger range.
   * Otherwise, there is no mismatch.
   *
   * Two non-`null` arrays, `a` and `b` with specified
   * ranges [`aFromIndex`, `atoIndex`) and
   * [`bFromIndex`, `btoIndex`) respectively, share a common
   * prefix of length `pl` if the following expression is true:
   * {@code
   *     pl >= 0 &&
   *     pl < Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex) &&
   *     Arrays.equals(a, aFromIndex, aFromIndex + pl, b, bFromIndex, bFromIndex + pl) &&
   *     a[aFromIndex + pl] != b[bFromIndex + pl]
   * }
   * Note that a common prefix length of `0` indicates that the first
   * elements from each array mismatch.
   *
   * Two non-`null` arrays, `a` and `b` with specified
   * ranges [`aFromIndex`, `atoIndex`) and
   * [`bFromIndex`, `btoIndex`) respectively, share a proper
   * prefix if the following expression is true:
   * {@code
   *     (aToIndex - aFromIndex) != (bToIndex - bFromIndex) &&
   *     Arrays.equals(a, 0, Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex),
   *                   b, 0, Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex))
   * }
   *
   * @param a the first array to be tested for a mismatch
   * @param aFromIndex the index (inclusive) of the first element in the
   *                   first array to be tested
   * @param aToIndex the index (exclusive) of the last element in the
   *                 first array to be tested
   * @param b the second array to be tested for a mismatch
   * @param bFromIndex the index (inclusive) of the first element in the
   *                   second array to be tested
   * @param bToIndex the index (exclusive) of the last element in the
   *                 second array to be tested
   * @return the relative index of the first mismatch between the two arrays
   *         over the specified ranges, otherwise `-1`.
   * @throws IllegalArgumentException
   *         if `aFromIndex > aToIndex` or
   *         if `bFromIndex > bToIndex`
   * @throws ArrayIndexOutOfBoundsException
   *         if `aFromIndex < 0 or aToIndex > a.length` or
   *         if `bFromIndex < 0 or bToIndex > b.length`
   * @throws NullPointerException
   *         if either array is `null`
   * @since 9
  */
  static mismatch(a: number[], aFromIndex: number, aToIndex: number, b: number[], bFromIndex: number, bToIndex: number): number;
  /**
   * Finds and returns the index of the first mismatch between two `long`
   * arrays, otherwise return -1 if no mismatch is found.  The index will be
   * in the range of 0 (inclusive) up to the length (inclusive) of the smaller
   * array.
   *
   * If the two arrays share a common prefix then the returned index is the
   * length of the common prefix and it follows that there is a mismatch
   * between the two elements at that index within the respective arrays.
   * If one array is a proper prefix of the other then the returned index is
   * the length of the smaller array and it follows that the index is only
   * valid for the larger array.
   * Otherwise, there is no mismatch.
   *
   * Two non-`null` arrays, `a` and `b`, share a common
   * prefix of length `pl` if the following expression is true:
   * {@code
   *     pl >= 0 &&
   *     pl < Math.min(a.length, b.length) &&
   *     Arrays.equals(a, 0, pl, b, 0, pl) &&
   *     a[pl] != b[pl]
   * }
   * Note that a common prefix length of `0` indicates that the first
   * elements from each array mismatch.
   *
   * Two non-`null` arrays, `a` and `b`, share a proper
   * prefix if the following expression is true:
   * {@code
   *     a.length != b.length &&
   *     Arrays.equals(a, 0, Math.min(a.length, b.length),
   *                   b, 0, Math.min(a.length, b.length))
   * }
   *
   * @param a the first array to be tested for a mismatch
   * @param b the second array to be tested for a mismatch
   * @return the index of the first mismatch between the two arrays,
   *         otherwise `-1`.
   * @throws NullPointerException
   *         if either array is `null`
   * @since 9
  */
  static mismatch(a: number[], b: number[]): number;
  /**
   * Finds and returns the relative index of the first mismatch between two
   * `long` arrays over the specified ranges, otherwise return -1 if no
   * mismatch is found.  The index will be in the range of 0 (inclusive) up to
   * the length (inclusive) of the smaller range.
   *
   * If the two arrays, over the specified ranges, share a common prefix
   * then the returned relative index is the length of the common prefix and
   * it follows that there is a mismatch between the two elements at that
   * relative index within the respective arrays.
   * If one array is a proper prefix of the other, over the specified ranges,
   * then the returned relative index is the length of the smaller range and
   * it follows that the relative index is only valid for the array with the
   * larger range.
   * Otherwise, there is no mismatch.
   *
   * Two non-`null` arrays, `a` and `b` with specified
   * ranges [`aFromIndex`, `atoIndex`) and
   * [`bFromIndex`, `btoIndex`) respectively, share a common
   * prefix of length `pl` if the following expression is true:
   * {@code
   *     pl >= 0 &&
   *     pl < Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex) &&
   *     Arrays.equals(a, aFromIndex, aFromIndex + pl, b, bFromIndex, bFromIndex + pl) &&
   *     a[aFromIndex + pl] != b[bFromIndex + pl]
   * }
   * Note that a common prefix length of `0` indicates that the first
   * elements from each array mismatch.
   *
   * Two non-`null` arrays, `a` and `b` with specified
   * ranges [`aFromIndex`, `atoIndex`) and
   * [`bFromIndex`, `btoIndex`) respectively, share a proper
   * prefix if the following expression is true:
   * {@code
   *     (aToIndex - aFromIndex) != (bToIndex - bFromIndex) &&
   *     Arrays.equals(a, 0, Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex),
   *                   b, 0, Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex))
   * }
   *
   * @param a the first array to be tested for a mismatch
   * @param aFromIndex the index (inclusive) of the first element in the
   *                   first array to be tested
   * @param aToIndex the index (exclusive) of the last element in the
   *                 first array to be tested
   * @param b the second array to be tested for a mismatch
   * @param bFromIndex the index (inclusive) of the first element in the
   *                   second array to be tested
   * @param bToIndex the index (exclusive) of the last element in the
   *                 second array to be tested
   * @return the relative index of the first mismatch between the two arrays
   *         over the specified ranges, otherwise `-1`.
   * @throws IllegalArgumentException
   *         if `aFromIndex > aToIndex` or
   *         if `bFromIndex > bToIndex`
   * @throws ArrayIndexOutOfBoundsException
   *         if `aFromIndex < 0 or aToIndex > a.length` or
   *         if `bFromIndex < 0 or bToIndex > b.length`
   * @throws NullPointerException
   *         if either array is `null`
   * @since 9
  */
  static mismatch(a: number[], aFromIndex: number, aToIndex: number, b: number[], bFromIndex: number, bToIndex: number): number;
  /**
   * Finds and returns the index of the first mismatch between two `float`
   * arrays, otherwise return -1 if no mismatch is found.  The index will be
   * in the range of 0 (inclusive) up to the length (inclusive) of the smaller
   * array.
   *
   * If the two arrays share a common prefix then the returned index is the
   * length of the common prefix and it follows that there is a mismatch
   * between the two elements at that index within the respective arrays.
   * If one array is a proper prefix of the other then the returned index is
   * the length of the smaller array and it follows that the index is only
   * valid for the larger array.
   * Otherwise, there is no mismatch.
   *
   * Two non-`null` arrays, `a` and `b`, share a common
   * prefix of length `pl` if the following expression is true:
   * {@code
   *     pl >= 0 &&
   *     pl < Math.min(a.length, b.length) &&
   *     Arrays.equals(a, 0, pl, b, 0, pl) &&
   *     Float.compare(a[pl], b[pl]) != 0
   * }
   * Note that a common prefix length of `0` indicates that the first
   * elements from each array mismatch.
   *
   * Two non-`null` arrays, `a` and `b`, share a proper
   * prefix if the following expression is true:
   * {@code
   *     a.length != b.length &&
   *     Arrays.equals(a, 0, Math.min(a.length, b.length),
   *                   b, 0, Math.min(a.length, b.length))
   * }
   *
   * @param a the first array to be tested for a mismatch
   * @param b the second array to be tested for a mismatch
   * @return the index of the first mismatch between the two arrays,
   *         otherwise `-1`.
   * @throws NullPointerException
   *         if either array is `null`
   * @since 9
  */
  static mismatch(a: number[], b: number[]): number;
  /**
   * Finds and returns the relative index of the first mismatch between two
   * `float` arrays over the specified ranges, otherwise return -1 if no
   * mismatch is found.  The index will be in the range of 0 (inclusive) up to
   * the length (inclusive) of the smaller range.
   *
   * If the two arrays, over the specified ranges, share a common prefix
   * then the returned relative index is the length of the common prefix and
   * it follows that there is a mismatch between the two elements at that
   * relative index within the respective arrays.
   * If one array is a proper prefix of the other, over the specified ranges,
   * then the returned relative index is the length of the smaller range and
   * it follows that the relative index is only valid for the array with the
   * larger range.
   * Otherwise, there is no mismatch.
   *
   * Two non-`null` arrays, `a` and `b` with specified
   * ranges [`aFromIndex`, `atoIndex`) and
   * [`bFromIndex`, `btoIndex`) respectively, share a common
   * prefix of length `pl` if the following expression is true:
   * {@code
   *     pl >= 0 &&
   *     pl < Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex) &&
   *     Arrays.equals(a, aFromIndex, aFromIndex + pl, b, bFromIndex, bFromIndex + pl) &&
   *     Float.compare(a[aFromIndex + pl], b[bFromIndex + pl]) != 0
   * }
   * Note that a common prefix length of `0` indicates that the first
   * elements from each array mismatch.
   *
   * Two non-`null` arrays, `a` and `b` with specified
   * ranges [`aFromIndex`, `atoIndex`) and
   * [`bFromIndex`, `btoIndex`) respectively, share a proper
   * prefix if the following expression is true:
   * {@code
   *     (aToIndex - aFromIndex) != (bToIndex - bFromIndex) &&
   *     Arrays.equals(a, 0, Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex),
   *                   b, 0, Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex))
   * }
   *
   * @param a the first array to be tested for a mismatch
   * @param aFromIndex the index (inclusive) of the first element in the
   *                   first array to be tested
   * @param aToIndex the index (exclusive) of the last element in the
   *                 first array to be tested
   * @param b the second array to be tested for a mismatch
   * @param bFromIndex the index (inclusive) of the first element in the
   *                   second array to be tested
   * @param bToIndex the index (exclusive) of the last element in the
   *                 second array to be tested
   * @return the relative index of the first mismatch between the two arrays
   *         over the specified ranges, otherwise `-1`.
   * @throws IllegalArgumentException
   *         if `aFromIndex > aToIndex` or
   *         if `bFromIndex > bToIndex`
   * @throws ArrayIndexOutOfBoundsException
   *         if `aFromIndex < 0 or aToIndex > a.length` or
   *         if `bFromIndex < 0 or bToIndex > b.length`
   * @throws NullPointerException
   *         if either array is `null`
   * @since 9
  */
  static mismatch(a: number[], aFromIndex: number, aToIndex: number, b: number[], bFromIndex: number, bToIndex: number): number;
  /**
   * Finds and returns the index of the first mismatch between two
   * `double` arrays, otherwise return -1 if no mismatch is found.  The
   * index will be in the range of 0 (inclusive) up to the length (inclusive)
   * of the smaller array.
   *
   * If the two arrays share a common prefix then the returned index is the
   * length of the common prefix and it follows that there is a mismatch
   * between the two elements at that index within the respective arrays.
   * If one array is a proper prefix of the other then the returned index is
   * the length of the smaller array and it follows that the index is only
   * valid for the larger array.
   * Otherwise, there is no mismatch.
   *
   * Two non-`null` arrays, `a` and `b`, share a common
   * prefix of length `pl` if the following expression is true:
   * {@code
   *     pl >= 0 &&
   *     pl < Math.min(a.length, b.length) &&
   *     Arrays.equals(a, 0, pl, b, 0, pl) &&
   *     Double.compare(a[pl], b[pl]) != 0
   * }
   * Note that a common prefix length of `0` indicates that the first
   * elements from each array mismatch.
   *
   * Two non-`null` arrays, `a` and `b`, share a proper
   * prefix if the following expression is true:
   * {@code
   *     a.length != b.length &&
   *     Arrays.equals(a, 0, Math.min(a.length, b.length),
   *                   b, 0, Math.min(a.length, b.length))
   * }
   *
   * @param a the first array to be tested for a mismatch
   * @param b the second array to be tested for a mismatch
   * @return the index of the first mismatch between the two arrays,
   *         otherwise `-1`.
   * @throws NullPointerException
   *         if either array is `null`
   * @since 9
  */
  static mismatch(a: number[], b: number[]): number;
  /**
   * Finds and returns the relative index of the first mismatch between two
   * `double` arrays over the specified ranges, otherwise return -1 if
   * no mismatch is found.  The index will be in the range of 0 (inclusive) up
   * to the length (inclusive) of the smaller range.
   *
   * If the two arrays, over the specified ranges, share a common prefix
   * then the returned relative index is the length of the common prefix and
   * it follows that there is a mismatch between the two elements at that
   * relative index within the respective arrays.
   * If one array is a proper prefix of the other, over the specified ranges,
   * then the returned relative index is the length of the smaller range and
   * it follows that the relative index is only valid for the array with the
   * larger range.
   * Otherwise, there is no mismatch.
   *
   * Two non-`null` arrays, `a` and `b` with specified
   * ranges [`aFromIndex`, `atoIndex`) and
   * [`bFromIndex`, `btoIndex`) respectively, share a common
   * prefix of length `pl` if the following expression is true:
   * {@code
   *     pl >= 0 &&
   *     pl < Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex) &&
   *     Arrays.equals(a, aFromIndex, aFromIndex + pl, b, bFromIndex, bFromIndex + pl) &&
   *     Double.compare(a[aFromIndex + pl], b[bFromIndex + pl]) != 0
   * }
   * Note that a common prefix length of `0` indicates that the first
   * elements from each array mismatch.
   *
   * Two non-`null` arrays, `a` and `b` with specified
   * ranges [`aFromIndex`, `atoIndex`) and
   * [`bFromIndex`, `btoIndex`) respectively, share a proper
   * prefix if the following expression is true:
   * {@code
   *     (aToIndex - aFromIndex) != (bToIndex - bFromIndex) &&
   *     Arrays.equals(a, 0, Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex),
   *                   b, 0, Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex))
   * }
   *
   * @param a the first array to be tested for a mismatch
   * @param aFromIndex the index (inclusive) of the first element in the
   *                   first array to be tested
   * @param aToIndex the index (exclusive) of the last element in the
   *                 first array to be tested
   * @param b the second array to be tested for a mismatch
   * @param bFromIndex the index (inclusive) of the first element in the
   *                   second array to be tested
   * @param bToIndex the index (exclusive) of the last element in the
   *                 second array to be tested
   * @return the relative index of the first mismatch between the two arrays
   *         over the specified ranges, otherwise `-1`.
   * @throws IllegalArgumentException
   *         if `aFromIndex > aToIndex` or
   *         if `bFromIndex > bToIndex`
   * @throws ArrayIndexOutOfBoundsException
   *         if `aFromIndex < 0 or aToIndex > a.length` or
   *         if `bFromIndex < 0 or bToIndex > b.length`
   * @throws NullPointerException
   *         if either array is `null`
   * @since 9
  */
  static mismatch(a: number[], aFromIndex: number, aToIndex: number, b: number[], bFromIndex: number, bToIndex: number): number;
  /**
   * Finds and returns the index of the first mismatch between two
   * `Object` arrays, otherwise return -1 if no mismatch is found.  The
   * index will be in the range of 0 (inclusive) up to the length (inclusive)
   * of the smaller array.
   *
   * If the two arrays share a common prefix then the returned index is the
   * length of the common prefix and it follows that there is a mismatch
   * between the two elements at that index within the respective arrays.
   * If one array is a proper prefix of the other then the returned index is
   * the length of the smaller array and it follows that the index is only
   * valid for the larger array.
   * Otherwise, there is no mismatch.
   *
   * Two non-`null` arrays, `a` and `b`, share a common
   * prefix of length `pl` if the following expression is true:
   * {@code
   *     pl >= 0 &&
   *     pl < Math.min(a.length, b.length) &&
   *     Arrays.equals(a, 0, pl, b, 0, pl) &&
   *     !Objects.equals(a[pl], b[pl])
   * }
   * Note that a common prefix length of `0` indicates that the first
   * elements from each array mismatch.
   *
   * Two non-`null` arrays, `a` and `b`, share a proper
   * prefix if the following expression is true:
   * {@code
   *     a.length != b.length &&
   *     Arrays.equals(a, 0, Math.min(a.length, b.length),
   *                   b, 0, Math.min(a.length, b.length))
   * }
   *
   * @param a the first array to be tested for a mismatch
   * @param b the second array to be tested for a mismatch
   * @return the index of the first mismatch between the two arrays,
   *         otherwise `-1`.
   * @throws NullPointerException
   *         if either array is `null`
   * @since 9
  */
  static mismatch(a: any[], b: any[]): number;
  /**
   * Finds and returns the relative index of the first mismatch between two
   * `Object` arrays over the specified ranges, otherwise return -1 if
   * no mismatch is found.  The index will be in the range of 0 (inclusive) up
   * to the length (inclusive) of the smaller range.
   *
   * If the two arrays, over the specified ranges, share a common prefix
   * then the returned relative index is the length of the common prefix and
   * it follows that there is a mismatch between the two elements at that
   * relative index within the respective arrays.
   * If one array is a proper prefix of the other, over the specified ranges,
   * then the returned relative index is the length of the smaller range and
   * it follows that the relative index is only valid for the array with the
   * larger range.
   * Otherwise, there is no mismatch.
   *
   * Two non-`null` arrays, `a` and `b` with specified
   * ranges [`aFromIndex`, `atoIndex`) and
   * [`bFromIndex`, `btoIndex`) respectively, share a common
   * prefix of length `pl` if the following expression is true:
   * {@code
   *     pl >= 0 &&
   *     pl < Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex) &&
   *     Arrays.equals(a, aFromIndex, aFromIndex + pl, b, bFromIndex, bFromIndex + pl) &&
   *     !Objects.equals(a[aFromIndex + pl], b[bFromIndex + pl])
   * }
   * Note that a common prefix length of `0` indicates that the first
   * elements from each array mismatch.
   *
   * Two non-`null` arrays, `a` and `b` with specified
   * ranges [`aFromIndex`, `atoIndex`) and
   * [`bFromIndex`, `btoIndex`) respectively, share a proper
   * prefix if the following expression is true:
   * {@code
   *     (aToIndex - aFromIndex) != (bToIndex - bFromIndex) &&
   *     Arrays.equals(a, 0, Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex),
   *                   b, 0, Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex))
   * }
   *
   * @param a the first array to be tested for a mismatch
   * @param aFromIndex the index (inclusive) of the first element in the
   *                   first array to be tested
   * @param aToIndex the index (exclusive) of the last element in the
   *                 first array to be tested
   * @param b the second array to be tested for a mismatch
   * @param bFromIndex the index (inclusive) of the first element in the
   *                   second array to be tested
   * @param bToIndex the index (exclusive) of the last element in the
   *                 second array to be tested
   * @return the relative index of the first mismatch between the two arrays
   *         over the specified ranges, otherwise `-1`.
   * @throws IllegalArgumentException
   *         if `aFromIndex > aToIndex` or
   *         if `bFromIndex > bToIndex`
   * @throws ArrayIndexOutOfBoundsException
   *         if `aFromIndex < 0 or aToIndex > a.length` or
   *         if `bFromIndex < 0 or bToIndex > b.length`
   * @throws NullPointerException
   *         if either array is `null`
   * @since 9
  */
  static mismatch(a: any[], aFromIndex: number, aToIndex: number, b: any[], bFromIndex: number, bToIndex: number): number;
  /**
   * Finds and returns the index of the first mismatch between two
   * `Object` arrays, otherwise return -1 if no mismatch is found.
   * The index will be in the range of 0 (inclusive) up to the length
   * (inclusive) of the smaller array.
   *
   * The specified comparator is used to determine if two array elements
   * from the each array are not equal.
   *
   * If the two arrays share a common prefix then the returned index is the
   * length of the common prefix and it follows that there is a mismatch
   * between the two elements at that index within the respective arrays.
   * If one array is a proper prefix of the other then the returned index is
   * the length of the smaller array and it follows that the index is only
   * valid for the larger array.
   * Otherwise, there is no mismatch.
   *
   * Two non-`null` arrays, `a` and `b`, share a common
   * prefix of length `pl` if the following expression is true:
   * {@code
   *     pl >= 0 &&
   *     pl < Math.min(a.length, b.length) &&
   *     Arrays.equals(a, 0, pl, b, 0, pl, cmp)
   *     cmp.compare(a[pl], b[pl]) != 0
   * }
   * Note that a common prefix length of `0` indicates that the first
   * elements from each array mismatch.
   *
   * Two non-`null` arrays, `a` and `b`, share a proper
   * prefix if the following expression is true:
   * {@code
   *     a.length != b.length &&
   *     Arrays.equals(a, 0, Math.min(a.length, b.length),
   *                   b, 0, Math.min(a.length, b.length),
   *                   cmp)
   * }
   *
   * @param a the first array to be tested for a mismatch
   * @param b the second array to be tested for a mismatch
   * @param cmp the comparator to compare array elements
   * @param  the type of array elements
   * @return the index of the first mismatch between the two arrays,
   *         otherwise `-1`.
   * @throws NullPointerException
   *         if either array or the comparator is `null`
   * @since 9
  */
  static mismatch<T>(a: T[], b: T[], cmp: Comparator<any>): number;
  /**
   * Finds and returns the relative index of the first mismatch between two
   * `Object` arrays over the specified ranges, otherwise return -1 if
   * no mismatch is found.  The index will be in the range of 0 (inclusive) up
   * to the length (inclusive) of the smaller range.
   *
   * If the two arrays, over the specified ranges, share a common prefix
   * then the returned relative index is the length of the common prefix and
   * it follows that there is a mismatch between the two elements at that
   * relative index within the respective arrays.
   * If one array is a proper prefix of the other, over the specified ranges,
   * then the returned relative index is the length of the smaller range and
   * it follows that the relative index is only valid for the array with the
   * larger range.
   * Otherwise, there is no mismatch.
   *
   * Two non-`null` arrays, `a` and `b` with specified
   * ranges [`aFromIndex`, `atoIndex`) and
   * [`bFromIndex`, `btoIndex`) respectively, share a common
   * prefix of length `pl` if the following expression is true:
   * {@code
   *     pl >= 0 &&
   *     pl < Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex) &&
   *     Arrays.equals(a, aFromIndex, aFromIndex + pl, b, bFromIndex, bFromIndex + pl, cmp) &&
   *     cmp.compare(a[aFromIndex + pl], b[bFromIndex + pl]) != 0
   * }
   * Note that a common prefix length of `0` indicates that the first
   * elements from each array mismatch.
   *
   * Two non-`null` arrays, `a` and `b` with specified
   * ranges [`aFromIndex`, `atoIndex`) and
   * [`bFromIndex`, `btoIndex`) respectively, share a proper
   * prefix if the following expression is true:
   * {@code
   *     (aToIndex - aFromIndex) != (bToIndex - bFromIndex) &&
   *     Arrays.equals(a, 0, Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex),
   *                   b, 0, Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex),
   *                   cmp)
   * }
   *
   * @param a the first array to be tested for a mismatch
   * @param aFromIndex the index (inclusive) of the first element in the
   *                   first array to be tested
   * @param aToIndex the index (exclusive) of the last element in the
   *                 first array to be tested
   * @param b the second array to be tested for a mismatch
   * @param bFromIndex the index (inclusive) of the first element in the
   *                   second array to be tested
   * @param bToIndex the index (exclusive) of the last element in the
   *                 second array to be tested
   * @param cmp the comparator to compare array elements
   * @param  the type of array elements
   * @return the relative index of the first mismatch between the two arrays
   *         over the specified ranges, otherwise `-1`.
   * @throws IllegalArgumentException
   *         if `aFromIndex > aToIndex` or
   *         if `bFromIndex > bToIndex`
   * @throws ArrayIndexOutOfBoundsException
   *         if `aFromIndex < 0 or aToIndex > a.length` or
   *         if `bFromIndex < 0 or bToIndex > b.length`
   * @throws NullPointerException
   *         if either array or the comparator is `null`
   * @since 9
  */
  static mismatch<T>(a: T[], aFromIndex: number, aToIndex: number, b: T[], bFromIndex: number, bToIndex: number, cmp: Comparator<any>): number;
}
export class TimerTask extends Runnable {
  /**
   * The action to be performed by this timer task.
  */
  run(): void;
  /**
   * Cancels this timer task.  If the task has been scheduled for one-time
   * execution and has not yet run, or has not yet been scheduled, it will
   * never run.  If the task has been scheduled for repeated execution, it
   * will never run again.  (If the task is running when this call occurs,
   * the task will run to completion, but will never run again.)
   *
   * Note that calling this method from within the `run` method of
   * a repeating timer task absolutely guarantees that the timer task will
   * not run again.
   *
   * This method may be called repeatedly; the second and subsequent
   * calls have no effect.
   *
   * @return true if this task is scheduled for one-time execution and has
   *         not yet run, or this task is scheduled for repeated execution.
   *         Returns false if the task was scheduled for one-time execution
   *         and has already run, or if the task was never scheduled, or if
   *         the task was already cancelled.  (Loosely speaking, this method
   *         returns `true` if it prevents one or more scheduled
   *         executions from taking place.)
  */
  cancel(): boolean;
  /**
   * Returns the scheduled execution time of the most recent
   * actual execution of this task.  (If this method is invoked
   * while task execution is in progress, the return value is the scheduled
   * execution time of the ongoing task execution.)
   *
   * This method is typically invoked from within a task's run method, to
   * determine whether the current execution of the task is sufficiently
   * timely to warrant performing the scheduled activity:
   * {@code
   *   public void run() {
   *       if (System.currentTimeMillis() - scheduledExecutionTime() >=
   *           MAX_TARDINESS)
   *               return;  // Too late; skip this execution.
   *       // Perform the task
   *   }
   * }
   * This method is typically not used in conjunction with
   * fixed-delay execution repeating tasks, as their scheduled
   * execution times are allowed to drift over time, and so are not terribly
   * significant.
   *
   * @return the time at which the most recent execution of this task was
   *         scheduled to occur, in the format returned by Date.getTime().
   *         The return value is undefined if the task has yet to commence
   *         its first execution.
   * @see Date#getTime()
  */
  scheduledExecutionTime(): number;
}
/**
 * A specialized {@link Map} implementation for use with enum type keys.  All
 * of the keys in an enum map must come from a single enum type that is
 * specified, explicitly or implicitly, when the map is created.  Enum maps
 * are represented internally as arrays.  This representation is extremely
 * compact and efficient.
 *
 * Enum maps are maintained in the natural order of their keys
 * (the order in which the enum constants are declared).  This is reflected
 * in the iterators returned by the collections views ({@link #keySet()},
 * {@link #entrySet()}, and {@link #values()}).
 *
 * Iterators returned by the collection views are weakly consistent:
 * they will never throw {@link ConcurrentModificationException} and they may
 * or may not show the effects of any modifications to the map that occur while
 * the iteration is in progress.
 *
 * Null keys are not permitted.  Attempts to insert a null key will
 * throw {@link NullPointerException}.  Attempts to test for the
 * presence of a null key or to remove one will, however, function properly.
 * Null values are permitted.
 *
 * Like most collection implementations `EnumMap` is not
 * synchronized. If multiple threads access an enum map concurrently, and at
 * least one of the threads modifies the map, it should be synchronized
 * externally.  This is typically accomplished by synchronizing on some
 * object that naturally encapsulates the enum map.  If no such object exists,
 * the map should be "wrapped" using the {@link Collections#synchronizedMap}
 * method.  This is best done at creation time, to prevent accidental
 * unsynchronized access:
 *
 *  *     Map<EnumKey, V> m
 *         = Collections.synchronizedMap(new EnumMap<EnumKey, V>(...));
 * 
 *
 * Implementation note: All basic operations execute in constant time.
 * They are likely (though not guaranteed) to be faster than their
 * {@link HashMap} counterparts.
 *
 * This class is a member of the
 * 
 * Java Collections Framework.
 *
 * @author Josh Bloch
 * @see EnumSet
 * @since 1.5
*/
export class EnumMap<K, V> extends AbstractMap<K, V> {
  /**
   * Creates an empty enum map with the specified key type.
   *
   * @param keyType the class object of the key type for this enum map
   * @throws NullPointerException if `keyType` is null
  */
  constructor(keyType: Class<K>);
  /**
   * Creates an enum map with the same key type as the specified enum
   * map, initially containing the same mappings (if any).
   *
   * @param m the enum map from which to initialize this enum map
   * @throws NullPointerException if `m` is null
  */
  constructor(m: EnumMap<K, V>);
  /**
   * Creates an enum map initialized from the specified map.  If the
   * specified map is an `EnumMap` instance, this constructor behaves
   * identically to {@link #EnumMap(EnumMap)}.  Otherwise, the specified map
   * must contain at least one mapping (in order to determine the new
   * enum map's key type).
   *
   * @param m the map from which to initialize this enum map
   * @throws IllegalArgumentException if `m` is not an
   *     `EnumMap` instance and contains no mappings
   * @throws NullPointerException if `m` is null
  */
  constructor(m: Map<K, V>);
  /**
   * Returns the number of key-value mappings in this map.
   *
   * @return the number of key-value mappings in this map
  */
  size(): number;
  /**
   * Returns `true` if this map maps one or more keys to the
   * specified value.
   *
   * @param value the value whose presence in this map is to be tested
   * @return `true` if this map maps one or more keys to this value
  */
  containsValue(value: any): boolean;
  /**
   * Returns `true` if this map contains a mapping for the specified
   * key.
   *
   * @param key the key whose presence in this map is to be tested
   * @return `true` if this map contains a mapping for the specified
   *            key
  */
  containsKey(key: any): boolean;
  /**
   * Returns the value to which the specified key is mapped,
   * or `null` if this map contains no mapping for the key.
   *
   * More formally, if this map contains a mapping from a key
   * `k` to a value `v` such that `(key == k)`,
   * then this method returns `v`; otherwise it returns
   * `null`.  (There can be at most one such mapping.)
   *
   * A return value of `null` does not necessarily
   * indicate that the map contains no mapping for the key; it's also
   * possible that the map explicitly maps the key to `null`.
   * The {@link #containsKey containsKey} operation may be used to
   * distinguish these two cases.
  */
  get(key: any): V;
  /**
   * Associates the specified value with the specified key in this map.
   * If the map previously contained a mapping for this key, the old
   * value is replaced.
   *
   * @param key the key with which the specified value is to be associated
   * @param value the value to be associated with the specified key
   *
   * @return the previous value associated with specified key, or
   *     `null` if there was no mapping for key.  (A `null`
   *     return can also indicate that the map previously associated
   *     `null` with the specified key.)
   * @throws NullPointerException if the specified key is null
  */
  put(key: K, value: V): V;
  /**
   * Removes the mapping for this key from this map if present.
   *
   * @param key the key whose mapping is to be removed from the map
   * @return the previous value associated with specified key, or
   *     `null` if there was no entry for key.  (A `null`
   *     return can also indicate that the map previously associated
   *     `null` with the specified key.)
  */
  remove(key: any): V;
  /**
   * Copies all of the mappings from the specified map to this map.
   * These mappings will replace any mappings that this map had for
   * any of the keys currently in the specified map.
   *
   * @param m the mappings to be stored in this map
   * @throws NullPointerException the specified map is null, or if
   *     one or more keys in the specified map are null
  */
  putAll(m: Map<K, V>): void;
  /**
   * Removes all mappings from this map.
  */
  clear(): void;
  /**
   * Returns a {@link Set} view of the keys contained in this map.
   * The returned set obeys the general contract outlined in
   * {@link Map#keySet()}.  The set's iterator will return the keys
   * in their natural order (the order in which the enum constants
   * are declared).
   *
   * @return a set view of the keys contained in this enum map
  */
  keySet(): Set<K>;
  /**
   * Returns a {@link Collection} view of the values contained in this map.
   * The returned collection obeys the general contract outlined in
   * {@link Map#values()}.  The collection's iterator will return the
   * values in the order their corresponding keys appear in map,
   * which is their natural order (the order in which the enum constants
   * are declared).
   *
   * @return a collection view of the values contained in this map
  */
  values(): Collection<V>;
  /**
   * Returns a {@link Set} view of the mappings contained in this map.
   * The returned set obeys the general contract outlined in
   * {@link Map#keySet()}.  The set's iterator will return the
   * mappings in the order their keys appear in map, which is their
   * natural order (the order in which the enum constants are declared).
   *
   * @return a set view of the mappings contained in this enum map
  */
  entrySet(): Set<java_util_Map_Entry<K, V>>;
  /**
   * Compares the specified object with this map for equality.  Returns
   * `true` if the given object is also a map and the two maps
   * represent the same mappings, as specified in the {@link
   * Map#equals(Object)} contract.
   *
   * @param o the object to be compared for equality with this map
   * @return `true` if the specified object is equal to this map
  */
  equals(o: any): boolean;
  /**
   * Returns the hash code value for this map.  The hash code of a map is
   * defined to be the sum of the hash codes of each entry in the map.
  */
  hashCode(): number;
  /**
   * Returns a shallow copy of this enum map. The values themselves
   * are not cloned.
   *
   * @return a shallow copy of this enum map
  */
  clone(): EnumMap<K, V>;
  /**
   * Removes the entry for the specified key only if it is currently
   * mapped to the specified value.
   *
   * @implSpec
   * The default implementation is equivalent to, for this `map`:
   *
   *  {@code
   * if (map.containsKey(key) && Objects.equals(map.get(key), value)) {
   *     map.remove(key);
   *     return true;
   * } else
   *     return false;
   * }
   *
   * The default implementation makes no guarantees about synchronization
   * or atomicity properties of this method. Any implementation providing
   * atomicity guarantees must override this method and document its
   * concurrency properties.
   *
   * @param key key with which the specified value is associated
   * @param value value expected to be associated with the specified key
   * @return `true` if the value was removed
   * @throws UnsupportedOperationException if the `remove` operation
   *         is not supported by this map
   *         (optional)
   * @throws ClassCastException if the key or value is of an inappropriate
   *         type for this map
   *         (optional)
   * @throws NullPointerException if the specified key or value is null,
   *         and this map does not permit null keys or values
   *         (optional)
   * @since 1.8
  */
  remove(key: any, value: any): boolean;
}
export interface EnumMap<K, V> extends AbstractMap<K, V>, Serializable, Cloneable {}
/**
 * Unchecked exception thrown when a conversion and flag are incompatible.
 *
 *  Unless otherwise specified, passing a `null` argument to any
 * method or constructor in this class will cause a {@link
 * NullPointerException} to be thrown.
 *
 * @since 1.5
*/
export class FormatFlagsConversionMismatchException extends IllegalFormatException {
  /**
   * Constructs an instance of this class with the specified flag
   * and conversion.
   *
   * @param  f
   *         The flag
   *
   * @param  c
   *         The conversion
  */
  constructor(f: string, c: string);
  /**
   * Returns the incompatible flag.
   *
   * @return  The flag
  */
  getFlags(): string;
  /**
   * Returns the incompatible conversion.
   *
   * @return  The conversion
  */
  getConversion(): string;
  getMessage(): string;
}
export class TreeSet<E> extends AbstractSet<E> {
  /**
   * Constructs a new, empty tree set, sorted according to the
   * natural ordering of its elements.  All elements inserted into
   * the set must implement the {@link Comparable} interface.
   * Furthermore, all such elements must be mutually
   * comparable: `e1.compareTo(e2)` must not throw a
   * `ClassCastException` for any elements `e1` and
   * `e2` in the set.  If the user attempts to add an element
   * to the set that violates this constraint (for example, the user
   * attempts to add a string element to a set whose elements are
   * integers), the `add` call will throw a
   * `ClassCastException`.
  */
  constructor();
  /**
   * Constructs a new, empty tree set, sorted according to the specified
   * comparator.  All elements inserted into the set must be mutually
   * comparable by the specified comparator: {@code comparator.compare(e1,
   * e2)} must not throw a `ClassCastException` for any elements
   * `e1` and `e2` in the set.  If the user attempts to add
   * an element to the set that violates this constraint, the
   * `add` call will throw a `ClassCastException`.
   *
   * @param comparator the comparator that will be used to order this set.
   *        If `null`, the {@linkplain Comparable natural
   *        ordering} of the elements will be used.
  */
  constructor(comparator: Comparator<any>);
  /**
   * Constructs a new tree set containing the elements in the specified
   * collection, sorted according to the natural ordering of its
   * elements.  All elements inserted into the set must implement the
   * {@link Comparable} interface.  Furthermore, all such elements must be
   * mutually comparable: `e1.compareTo(e2)` must not throw a
   * `ClassCastException` for any elements `e1` and
   * `e2` in the set.
   *
   * @param c collection whose elements will comprise the new set
   * @throws ClassCastException if the elements in `c` are
   *         not {@link Comparable}, or are not mutually comparable
   * @throws NullPointerException if the specified collection is null
  */
  constructor(c: Collection<E>);
  /**
   * Constructs a new tree set containing the same elements and
   * using the same ordering as the specified sorted set.
   *
   * @param s sorted set whose elements will comprise the new set
   * @throws NullPointerException if the specified sorted set is null
  */
  constructor(s: SortedSet<E>);
  /**
   * Returns an iterator over the elements in this set in ascending order.
   *
   * @return an iterator over the elements in this set in ascending order
  */
  iterator(): Iterator<E>;
  /**
   * Returns an iterator over the elements in this set in descending order.
   *
   * @return an iterator over the elements in this set in descending order
   * @since 1.6
  */
  descendingIterator(): Iterator<E>;
  /**
   * @since 1.6
  */
  descendingSet(): NavigableSet<E>;
  /**
   * Returns the number of elements in this set (its cardinality).
   *
   * @return the number of elements in this set (its cardinality)
  */
  size(): number;
  /**
   * Returns `true` if this set contains no elements.
   *
   * @return `true` if this set contains no elements
  */
  isEmpty(): boolean;
  /**
   * Returns `true` if this set contains the specified element.
   * More formally, returns `true` if and only if this set
   * contains an element `e` such that
   * `Objects.equals(o, e)`.
   *
   * @param o object to be checked for containment in this set
   * @return `true` if this set contains the specified element
   * @throws ClassCastException if the specified object cannot be compared
   *         with the elements currently in the set
   * @throws NullPointerException if the specified element is null
   *         and this set uses natural ordering, or its comparator
   *         does not permit null elements
  */
  contains(o: any): boolean;
  /**
   * Adds the specified element to this set if it is not already present.
   * More formally, adds the specified element `e` to this set if
   * the set contains no element `e2` such that
   * `Objects.equals(e, e2)`.
   * If this set already contains the element, the call leaves the set
   * unchanged and returns `false`.
   *
   * @param e element to be added to this set
   * @return `true` if this set did not already contain the specified
   *         element
   * @throws ClassCastException if the specified object cannot be compared
   *         with the elements currently in this set
   * @throws NullPointerException if the specified element is null
   *         and this set uses natural ordering, or its comparator
   *         does not permit null elements
  */
  add(e: E): boolean;
  /**
   * Removes the specified element from this set if it is present.
   * More formally, removes an element `e` such that
   * `Objects.equals(o, e)`,
   * if this set contains such an element.  Returns `true` if
   * this set contained the element (or equivalently, if this set
   * changed as a result of the call).  (This set will not contain the
   * element once the call returns.)
   *
   * @param o object to be removed from this set, if present
   * @return `true` if this set contained the specified element
   * @throws ClassCastException if the specified object cannot be compared
   *         with the elements currently in this set
   * @throws NullPointerException if the specified element is null
   *         and this set uses natural ordering, or its comparator
   *         does not permit null elements
  */
  remove(o: any): boolean;
  /**
   * Removes all of the elements from this set.
   * The set will be empty after this call returns.
  */
  clear(): void;
  /**
   * Adds all of the elements in the specified collection to this set.
   *
   * @param c collection containing elements to be added to this set
   * @return `true` if this set changed as a result of the call
   * @throws ClassCastException if the elements provided cannot be compared
   *         with the elements currently in the set
   * @throws NullPointerException if the specified collection is null or
   *         if any element is null and this set uses natural ordering, or
   *         its comparator does not permit null elements
  */
  addAll(c: Collection<E>): boolean;
  /**
   * @throws ClassCastException {@inheritDoc}
   * @throws NullPointerException if `fromElement` or `toElement`
   *         is null and this set uses natural ordering, or its comparator
   *         does not permit null elements
   * @throws IllegalArgumentException {@inheritDoc}
   * @since 1.6
  */
  subSet(fromElement: E, fromInclusive: boolean, toElement: E, toInclusive: boolean): NavigableSet<E>;
  /**
   * @throws ClassCastException {@inheritDoc}
   * @throws NullPointerException if `toElement` is null and
   *         this set uses natural ordering, or its comparator does
   *         not permit null elements
   * @throws IllegalArgumentException {@inheritDoc}
   * @since 1.6
  */
  headSet(toElement: E, inclusive: boolean): NavigableSet<E>;
  /**
   * @throws ClassCastException {@inheritDoc}
   * @throws NullPointerException if `fromElement` is null and
   *         this set uses natural ordering, or its comparator does
   *         not permit null elements
   * @throws IllegalArgumentException {@inheritDoc}
   * @since 1.6
  */
  tailSet(fromElement: E, inclusive: boolean): NavigableSet<E>;
  /**
   * @throws ClassCastException {@inheritDoc}
   * @throws NullPointerException if `fromElement` or
   *         `toElement` is null and this set uses natural ordering,
   *         or its comparator does not permit null elements
   * @throws IllegalArgumentException {@inheritDoc}
  */
  subSet(fromElement: E, toElement: E): SortedSet<E>;
  /**
   * @throws ClassCastException {@inheritDoc}
   * @throws NullPointerException if `toElement` is null
   *         and this set uses natural ordering, or its comparator does
   *         not permit null elements
   * @throws IllegalArgumentException {@inheritDoc}
  */
  headSet(toElement: E): SortedSet<E>;
  /**
   * @throws ClassCastException {@inheritDoc}
   * @throws NullPointerException if `fromElement` is null
   *         and this set uses natural ordering, or its comparator does
   *         not permit null elements
   * @throws IllegalArgumentException {@inheritDoc}
  */
  tailSet(fromElement: E): SortedSet<E>;
  comparator(): Comparator<any>;
  /**
   * @throws NoSuchElementException {@inheritDoc}
  */
  first(): E;
  /**
   * @throws NoSuchElementException {@inheritDoc}
  */
  last(): E;
  /**
   * @throws ClassCastException {@inheritDoc}
   * @throws NullPointerException if the specified element is null
   *         and this set uses natural ordering, or its comparator
   *         does not permit null elements
   * @since 1.6
  */
  lower(e: E): E;
  /**
   * @throws ClassCastException {@inheritDoc}
   * @throws NullPointerException if the specified element is null
   *         and this set uses natural ordering, or its comparator
   *         does not permit null elements
   * @since 1.6
  */
  floor(e: E): E;
  /**
   * @throws ClassCastException {@inheritDoc}
   * @throws NullPointerException if the specified element is null
   *         and this set uses natural ordering, or its comparator
   *         does not permit null elements
   * @since 1.6
  */
  ceiling(e: E): E;
  /**
   * @throws ClassCastException {@inheritDoc}
   * @throws NullPointerException if the specified element is null
   *         and this set uses natural ordering, or its comparator
   *         does not permit null elements
   * @since 1.6
  */
  higher(e: E): E;
  /**
   * @since 1.6
  */
  pollFirst(): E;
  /**
   * @since 1.6
  */
  pollLast(): E;
  /**
   * Returns a shallow copy of this `TreeSet` instance. (The elements
   * themselves are not cloned.)
   *
   * @return a shallow copy of this set
  */
  clone(): any;
  /**
   * Creates a late-binding
   * and fail-fast {@link Spliterator} over the elements in this
   * set.
   *
   * The `Spliterator` reports {@link Spliterator#SIZED},
   * {@link Spliterator#DISTINCT}, {@link Spliterator#SORTED}, and
   * {@link Spliterator#ORDERED}.  Overriding implementations should document
   * the reporting of additional characteristic values.
   *
   * The spliterator's comparator (see
   * {@link java.util.Spliterator#getComparator()}) is `null` if
   * the tree set's comparator (see {@link #comparator()}) is `null`.
   * Otherwise, the spliterator's comparator is the same as or imposes the
   * same total ordering as the tree set's comparator.
   *
   * @return a `Spliterator` over the elements in this set
   * @since 1.8
  */
  spliterator(): Spliterator<E>;
}
export interface TreeSet<E> extends AbstractSet<E>, NavigableSet<E>, Cloneable, Serializable {}
export class InvalidPropertiesFormatException extends IOException {
  /**
   * Constructs an InvalidPropertiesFormatException with the specified
   * cause.
   *
   * @param  cause the cause (which is saved for later retrieval by the
   *         {@link Throwable#getCause()} method).
  */
  constructor(cause: Throwable);
  /**
   * Constructs an InvalidPropertiesFormatException with the specified
   * detail message.
   *
   * @param   message   the detail message. The detail message is saved for
   *          later retrieval by the {@link Throwable#getMessage()} method.
  */
  constructor(message: string);
}
/**
 * Resizable-array implementation of the `List` interface.  Implements
 * all optional list operations, and permits all elements, including
 * `null`.  In addition to implementing the `List` interface,
 * this class provides methods to manipulate the size of the array that is
 * used internally to store the list.  (This class is roughly equivalent to
 * `Vector`, except that it is unsynchronized.)
 *
 * The `size`, `isEmpty`, `get`, `set`,
 * `iterator`, and `listIterator` operations run in constant
 * time.  The `add` operation runs in amortized constant time,
 * that is, adding n elements requires O(n) time.  All of the other operations
 * run in linear time (roughly speaking).  The constant factor is low compared
 * to that for the `LinkedList` implementation.
 *
 * Each `ArrayList` instance has a capacity.  The capacity is
 * the size of the array used to store the elements in the list.  It is always
 * at least as large as the list size.  As elements are added to an ArrayList,
 * its capacity grows automatically.  The details of the growth policy are not
 * specified beyond the fact that adding an element has constant amortized
 * time cost.
 *
 * An application can increase the capacity of an `ArrayList` instance
 * before adding a large number of elements using the `ensureCapacity`
 * operation.  This may reduce the amount of incremental reallocation.
 *
 * Note that this implementation is not synchronized.
 * If multiple threads access an `ArrayList` instance concurrently,
 * and at least one of the threads modifies the list structurally, it
 * must be synchronized externally.  (A structural modification is
 * any operation that adds or deletes one or more elements, or explicitly
 * resizes the backing array; merely setting the value of an element is not
 * a structural modification.)  This is typically accomplished by
 * synchronizing on some object that naturally encapsulates the list.
 *
 * If no such object exists, the list should be "wrapped" using the
 * {@link Collections#synchronizedList Collections.synchronizedList}
 * method.  This is best done at creation time, to prevent accidental
 * unsynchronized access to the list: *   List list = Collections.synchronizedList(new ArrayList(...));
 *
 * 
 * The iterators returned by this class's {@link #iterator() iterator} and
 * {@link #listIterator(int) listIterator} methods are fail-fast:
 * if the list is structurally modified at any time after the iterator is
 * created, in any way except through the iterator's own
 * {@link ListIterator#remove() remove} or
 * {@link ListIterator#add(Object) add} methods, the iterator will throw a
 * {@link ConcurrentModificationException}.  Thus, in the face of
 * concurrent modification, the iterator fails quickly and cleanly, rather
 * than risking arbitrary, non-deterministic behavior at an undetermined
 * time in the future.
 *
 * Note that the fail-fast behavior of an iterator cannot be guaranteed
 * as it is, generally speaking, impossible to make any hard guarantees in the
 * presence of unsynchronized concurrent modification.  Fail-fast iterators
 * throw `ConcurrentModificationException` on a best-effort basis.
 * Therefore, it would be wrong to write a program that depended on this
 * exception for its correctness:  the fail-fast behavior of iterators
 * should be used only to detect bugs.
 *
 * This class is a member of the
 * 
 * Java Collections Framework.
 *
 * @param  the type of elements in this list
 *
 * @author  Josh Bloch
 * @author  Neal Gafter
 * @see     Collection
 * @see     List
 * @see     LinkedList
 * @see     Vector
 * @since   1.2
*/
export class ArrayList<E> extends AbstractList<E> {
  /**
   * Constructs an empty list with the specified initial capacity.
   *
   * @param  initialCapacity  the initial capacity of the list
   * @throws IllegalArgumentException if the specified initial capacity
   *         is negative
  */
  constructor(initialCapacity: number);
  /**
   * Constructs an empty list with an initial capacity of ten.
  */
  constructor();
  /**
   * Constructs a list containing the elements of the specified
   * collection, in the order they are returned by the collection's
   * iterator.
   *
   * @param c the collection whose elements are to be placed into this list
   * @throws NullPointerException if the specified collection is null
  */
  constructor(c: Collection<E>);
  /**
   * Trims the capacity of this `ArrayList` instance to be the
   * list's current size.  An application can use this operation to minimize
   * the storage of an `ArrayList` instance.
  */
  trimToSize(): void;
  /**
   * Increases the capacity of this `ArrayList` instance, if
   * necessary, to ensure that it can hold at least the number of elements
   * specified by the minimum capacity argument.
   *
   * @param minCapacity the desired minimum capacity
  */
  ensureCapacity(minCapacity: number): void;
  /**
   * Returns the number of elements in this list.
   *
   * @return the number of elements in this list
  */
  size(): number;
  /**
   * Returns `true` if this list contains no elements.
   *
   * @return `true` if this list contains no elements
  */
  isEmpty(): boolean;
  /**
   * Returns `true` if this list contains the specified element.
   * More formally, returns `true` if and only if this list contains
   * at least one element `e` such that
   * `Objects.equals(o, e)`.
   *
   * @param o element whose presence in this list is to be tested
   * @return `true` if this list contains the specified element
  */
  contains(o: any): boolean;
  /**
   * Returns the index of the first occurrence of the specified element
   * in this list, or -1 if this list does not contain the element.
   * More formally, returns the lowest index `i` such that
   * `Objects.equals(o, get(i))`,
   * or -1 if there is no such index.
  */
  indexOf(o: any): number;
  /**
   * Returns the index of the last occurrence of the specified element
   * in this list, or -1 if this list does not contain the element.
   * More formally, returns the highest index `i` such that
   * `Objects.equals(o, get(i))`,
   * or -1 if there is no such index.
  */
  lastIndexOf(o: any): number;
  /**
   * Returns a shallow copy of this `ArrayList` instance.  (The
   * elements themselves are not copied.)
   *
   * @return a clone of this `ArrayList` instance
  */
  clone(): any;
  /**
   * Returns an array containing all of the elements in this list
   * in proper sequence (from first to last element).
   *
   * The returned array will be "safe" in that no references to it are
   * maintained by this list.  (In other words, this method must allocate
   * a new array).  The caller is thus free to modify the returned array.
   *
   * This method acts as bridge between array-based and collection-based
   * APIs.
   *
   * @return an array containing all of the elements in this list in
   *         proper sequence
  */
  toArray(): any[];
  /**
   * Returns an array containing all of the elements in this list in proper
   * sequence (from first to last element); the runtime type of the returned
   * array is that of the specified array.  If the list fits in the
   * specified array, it is returned therein.  Otherwise, a new array is
   * allocated with the runtime type of the specified array and the size of
   * this list.
   *
   * If the list fits in the specified array with room to spare
   * (i.e., the array has more elements than the list), the element in
   * the array immediately following the end of the collection is set to
   * `null`.  (This is useful in determining the length of the
   * list only if the caller knows that the list does not contain
   * any null elements.)
   *
   * @param a the array into which the elements of the list are to
   *          be stored, if it is big enough; otherwise, a new array of the
   *          same runtime type is allocated for this purpose.
   * @return an array containing the elements of the list
   * @throws ArrayStoreException if the runtime type of the specified array
   *         is not a supertype of the runtime type of every element in
   *         this list
   * @throws NullPointerException if the specified array is null
  */
  toArray<T>(a: T[]): T[];
  /**
   * Returns the element at the specified position in this list.
   *
   * @param  index index of the element to return
   * @return the element at the specified position in this list
   * @throws IndexOutOfBoundsException {@inheritDoc}
  */
  get(index: number): E;
  /**
   * Replaces the element at the specified position in this list with
   * the specified element.
   *
   * @param index index of the element to replace
   * @param element element to be stored at the specified position
   * @return the element previously at the specified position
   * @throws IndexOutOfBoundsException {@inheritDoc}
  */
  set(index: number, element: E): E;
  /**
   * Appends the specified element to the end of this list.
   *
   * @param e element to be appended to this list
   * @return `true` (as specified by {@link Collection#add})
  */
  add(e: E): boolean;
  /**
   * Inserts the specified element at the specified position in this
   * list. Shifts the element currently at that position (if any) and
   * any subsequent elements to the right (adds one to their indices).
   *
   * @param index index at which the specified element is to be inserted
   * @param element element to be inserted
   * @throws IndexOutOfBoundsException {@inheritDoc}
  */
  add(index: number, element: E): void;
  /**
   * Removes the element at the specified position in this list.
   * Shifts any subsequent elements to the left (subtracts one from their
   * indices).
   *
   * @param index the index of the element to be removed
   * @return the element that was removed from the list
   * @throws IndexOutOfBoundsException {@inheritDoc}
  */
  remove(index: number): E;
  /**
   * {@inheritDoc}
  */
  equals(o: any): boolean;
  /**
   * {@inheritDoc}
  */
  hashCode(): number;
  /**
   * Removes the first occurrence of the specified element from this list,
   * if it is present.  If the list does not contain the element, it is
   * unchanged.  More formally, removes the element with the lowest index
   * `i` such that
   * `Objects.equals(o, get(i))`
   * (if such an element exists).  Returns `true` if this list
   * contained the specified element (or equivalently, if this list
   * changed as a result of the call).
   *
   * @param o element to be removed from this list, if present
   * @return `true` if this list contained the specified element
  */
  remove(o: any): boolean;
  /**
   * Removes all of the elements from this list.  The list will
   * be empty after this call returns.
  */
  clear(): void;
  /**
   * Appends all of the elements in the specified collection to the end of
   * this list, in the order that they are returned by the
   * specified collection's Iterator.  The behavior of this operation is
   * undefined if the specified collection is modified while the operation
   * is in progress.  (This implies that the behavior of this call is
   * undefined if the specified collection is this list, and this
   * list is nonempty.)
   *
   * @param c collection containing elements to be added to this list
   * @return `true` if this list changed as a result of the call
   * @throws NullPointerException if the specified collection is null
  */
  addAll(c: Collection<E>): boolean;
  /**
   * Inserts all of the elements in the specified collection into this
   * list, starting at the specified position.  Shifts the element
   * currently at that position (if any) and any subsequent elements to
   * the right (increases their indices).  The new elements will appear
   * in the list in the order that they are returned by the
   * specified collection's iterator.
   *
   * @param index index at which to insert the first element from the
   *              specified collection
   * @param c collection containing elements to be added to this list
   * @return `true` if this list changed as a result of the call
   * @throws IndexOutOfBoundsException {@inheritDoc}
   * @throws NullPointerException if the specified collection is null
  */
  addAll(index: number, c: Collection<E>): boolean;
  /**
   * Removes from this list all of its elements that are contained in the
   * specified collection.
   *
   * @param c collection containing elements to be removed from this list
   * @return `true` if this list changed as a result of the call
   * @throws ClassCastException if the class of an element of this list
   *         is incompatible with the specified collection
   * (optional)
   * @throws NullPointerException if this list contains a null element and the
   *         specified collection does not permit null elements
   * (optional),
   *         or if the specified collection is null
   * @see Collection#contains(Object)
  */
  removeAll(c: Collection<any>): boolean;
  /**
   * Retains only the elements in this list that are contained in the
   * specified collection.  In other words, removes from this list all
   * of its elements that are not contained in the specified collection.
   *
   * @param c collection containing elements to be retained in this list
   * @return `true` if this list changed as a result of the call
   * @throws ClassCastException if the class of an element of this list
   *         is incompatible with the specified collection
   * (optional)
   * @throws NullPointerException if this list contains a null element and the
   *         specified collection does not permit null elements
   * (optional),
   *         or if the specified collection is null
   * @see Collection#contains(Object)
  */
  retainAll(c: Collection<any>): boolean;
  /**
   * Returns a list iterator over the elements in this list (in proper
   * sequence), starting at the specified position in the list.
   * The specified index indicates the first element that would be
   * returned by an initial call to {@link ListIterator#next next}.
   * An initial call to {@link ListIterator#previous previous} would
   * return the element with the specified index minus one.
   *
   * The returned list iterator is fail-fast.
   *
   * @throws IndexOutOfBoundsException {@inheritDoc}
  */
  listIterator(index: number): ListIterator<E>;
  /**
   * Returns a list iterator over the elements in this list (in proper
   * sequence).
   *
   * The returned list iterator is fail-fast.
   *
   * @see #listIterator(int)
  */
  listIterator(): ListIterator<E>;
  /**
   * Returns an iterator over the elements in this list in proper sequence.
   *
   * The returned iterator is fail-fast.
   *
   * @return an iterator over the elements in this list in proper sequence
  */
  iterator(): Iterator<E>;
  /**
   * Returns a view of the portion of this list between the specified
   * `fromIndex`, inclusive, and `toIndex`, exclusive.  (If
   * `fromIndex` and `toIndex` are equal, the returned list is
   * empty.)  The returned list is backed by this list, so non-structural
   * changes in the returned list are reflected in this list, and vice-versa.
   * The returned list supports all of the optional list operations.
   *
   * This method eliminates the need for explicit range operations (of
   * the sort that commonly exist for arrays).  Any operation that expects
   * a list can be used as a range operation by passing a subList view
   * instead of a whole list.  For example, the following idiom
   * removes a range of elements from a list:
   *      *      list.subList(from, to).clear();
   * 
   * Similar idioms may be constructed for {@link #indexOf(Object)} and
   * {@link #lastIndexOf(Object)}, and all of the algorithms in the
   * {@link Collections} class can be applied to a subList.
   *
   * The semantics of the list returned by this method become undefined if
   * the backing list (i.e., this list) is structurally modified in
   * any way other than via the returned list.  (Structural modifications are
   * those that change the size of this list, or otherwise perturb it in such
   * a fashion that iterations in progress may yield incorrect results.)
   *
   * @throws IndexOutOfBoundsException {@inheritDoc}
   * @throws IllegalArgumentException {@inheritDoc}
  */
  subList(fromIndex: number, toIndex: number): E[];
  /**
   * @throws NullPointerException {@inheritDoc}
  */
  forEach(action: Consumer<any>): void;
  /**
   * Creates a late-binding
   * and fail-fast {@link Spliterator} over the elements in this
   * list.
   *
   * The `Spliterator` reports {@link Spliterator#SIZED},
   * {@link Spliterator#SUBSIZED}, and {@link Spliterator#ORDERED}.
   * Overriding implementations should document the reporting of additional
   * characteristic values.
   *
   * @return a `Spliterator` over the elements in this list
   * @since 1.8
  */
  spliterator(): Spliterator<E>;
  /**
   * @throws NullPointerException {@inheritDoc}
  */
  removeIf(filter: Predicate<any>): boolean;
  /**
   * Replaces each element of this list with the result of applying the
   * operator to that element.  Errors or runtime exceptions thrown by
   * the operator are relayed to the caller.
   *
   * @implSpec
   * The default implementation is equivalent to, for this `list`:
   * {@code
   *     final ListIterator li = list.listIterator();
   *     while (li.hasNext()) {
   *         li.set(operator.apply(li.next()));
   *     }
   * }
   *
   * If the list's list-iterator does not support the `set` operation
   * then an `UnsupportedOperationException` will be thrown when
   * replacing the first element.
   *
   * @param operator the operator to apply to each element
   * @throws UnsupportedOperationException if this list is unmodifiable.
   *         Implementations may throw this exception if an element
   *         cannot be replaced or if, in general, modification is not
   *         supported
   * @throws NullPointerException if the specified operator is null or
   *         if the operator result is a null value and this list does
   *         not permit null elements
   *         (optional)
   * @since 1.8
  */
  replaceAll(operator: UnaryOperator<E>): void;
  /**
   * Sorts this list according to the order induced by the specified
   * {@link Comparator}.  The sort is stable: this method must not
   * reorder equal elements.
   *
   * All elements in this list must be mutually comparable using the
   * specified comparator (that is, `c.compare(e1, e2)` must not throw
   * a `ClassCastException` for any elements `e1` and `e2`
   * in the list).
   *
   * If the specified comparator is `null` then all elements in this
   * list must implement the {@link Comparable} interface and the elements'
   * {@linkplain Comparable natural ordering} should be used.
   *
   * This list must be modifiable, but need not be resizable.
   *
   * @implSpec
   * The default implementation obtains an array containing all elements in
   * this list, sorts the array, and iterates over this list resetting each
   * element from the corresponding position in the array. (This avoids the
   * n2 log(n) performance that would result from attempting
   * to sort a linked list in place.)
   *
   * @implNote
   * This implementation is a stable, adaptive, iterative mergesort that
   * requires far fewer than n lg(n) comparisons when the input array is
   * partially sorted, while offering the performance of a traditional
   * mergesort when the input array is randomly ordered.  If the input array
   * is nearly sorted, the implementation requires approximately n
   * comparisons.  Temporary storage requirements vary from a small constant
   * for nearly sorted input arrays to n/2 object references for randomly
   * ordered input arrays.
   *
   * The implementation takes equal advantage of ascending and
   * descending order in its input array, and can take advantage of
   * ascending and descending order in different parts of the same
   * input array.  It is well-suited to merging two or more sorted arrays:
   * simply concatenate the arrays and sort the resulting array.
   *
   * The implementation was adapted from Tim Peters's list sort for Python
   * (
   * TimSort).  It uses techniques from Peter McIlroy's "Optimistic
   * Sorting and Information Theoretic Complexity", in Proceedings of the
   * Fourth Annual ACM-SIAM Symposium on Discrete Algorithms, pp 467-474,
   * January 1993.
   *
   * @param c the `Comparator` used to compare list elements.
   *          A `null` value indicates that the elements'
   *          {@linkplain Comparable natural ordering} should be used
   * @throws ClassCastException if the list contains elements that are not
   *         mutually comparable using the specified comparator
   * @throws UnsupportedOperationException if the list's list-iterator does
   *         not support the `set` operation
   * @throws IllegalArgumentException
   *         (optional)
   *         if the comparator is found to violate the {@link Comparator}
   *         contract
   * @since 1.8
  */
  sort(c: Comparator<any>): void;
  /**
   * Returns an array containing all of the elements in this collection,
   * using the provided `generator` function to allocate the returned array.
   *
   * If this collection makes any guarantees as to what order its elements
   * are returned by its iterator, this method must return the elements in
   * the same order.
   *
   * @apiNote
   * This method acts as a bridge between array-based and collection-based APIs.
   * It allows creation of an array of a particular runtime type. Use
   * {@link #toArray()} to create an array whose runtime type is `Object[]`,
   * or use {@link #toArray(Object[]) toArray(T[])} to reuse an existing array.
   *
   * Suppose `x` is a collection known to contain only strings.
   * The following code can be used to dump the collection into a newly
   * allocated array of `String`:
   *
   *      *     String[] y = x.toArray(String[]::new);
   *
   * @implSpec
   * The default implementation calls the generator function with zero
   * and then passes the resulting array to {@link #toArray(Object[]) toArray(T[])}.
   *
   * @param  the component type of the array to contain the collection
   * @param generator a function which produces a new array of the desired
   *                  type and the provided length
   * @return an array containing all of the elements in this collection
   * @throws ArrayStoreException if the runtime type of any element in this
   *         collection is not assignable to the {@linkplain Class#getComponentType
   *         runtime component type} of the generated array
   * @throws NullPointerException if the generator function is null
   * @since 11
  */
  toArray<T>(generator: IntFunction<T[]>): T[];
}
export interface ArrayList<E> extends AbstractList<E>, RandomAccess, Cloneable, Serializable {}
/**
 *
 * Resource bundles contain locale-specific objects.  When your program needs a
 * locale-specific resource, a `String` for example, your program can
 * load it from the resource bundle that is appropriate for the current user's
 * locale. In this way, you can write program code that is largely independent
 * of the user's locale isolating most, if not all, of the locale-specific
 * information in resource bundles.
 *
 * 
 * This allows you to write programs that can:
 * 
 *  be easily localized, or translated, into different languages
 *  handle multiple locales at once
 *  be easily modified later to support even more locales
 * 
 *
 * 
 * Resource bundles belong to families whose members share a common base
 * name, but whose names also have additional components that identify
 * their locales. For example, the base name of a family of resource
 * bundles might be "MyResources". The family should have a default
 * resource bundle which simply has the same name as its family -
 * "MyResources" - and will be used as the bundle of last resort if a
 * specific locale is not supported. The family can then provide as
 * many locale-specific members as needed, for example a German one
 * named "MyResources_de".
 *
 * 
 * Each resource bundle in a family contains the same items, but the items have
 * been translated for the locale represented by that resource bundle.
 * For example, both "MyResources" and "MyResources_de" may have a
 * `String` that's used on a button for canceling operations.
 * In "MyResources" the `String` may contain "Cancel" and in
 * "MyResources_de" it may contain "Abbrechen".
 *
 * 
 * If there are different resources for different countries, you
 * can make specializations: for example, "MyResources_de_CH" contains objects for
 * the German language (de) in Switzerland (CH). If you want to only
 * modify some of the resources
 * in the specialization, you can do so.
 *
 * 
 * When your program needs a locale-specific object, it loads
 * the `ResourceBundle` class using the
 * {@link #getBundle(java.lang.String, java.util.Locale) getBundle}
 * method:
 * 
 *  * ResourceBundle myResources =
 *      ResourceBundle.getBundle("MyResources", currentLocale);
 * 
 * 
 *
 * 
 * Resource bundles contain key/value pairs. The keys uniquely
 * identify a locale-specific object in the bundle. Here's an
 * example of a `ListResourceBundle` that contains
 * two key/value pairs:
 * 
 *  * public class MyResources extends ListResourceBundle {
 *     protected Object[][] getContents() {
 *         return new Object[][] {
 *             // LOCALIZE THE SECOND STRING OF EACH ARRAY (e.g., "OK")
 *             {"OkKey", "OK"},
 *             {"CancelKey", "Cancel"},
 *             // END OF MATERIAL TO LOCALIZE
 *        };
 *     }
 * }
 * 
 * 
 * Keys are always `String`s.
 * In this example, the keys are "OkKey" and "CancelKey".
 * In the above example, the values
 * are also `String`s--"OK" and "Cancel"--but
 * they don't have to be. The values can be any type of object.
 *
 * 
 * You retrieve an object from resource bundle using the appropriate
 * getter method. Because "OkKey" and "CancelKey"
 * are both strings, you would use `getString` to retrieve them:
 * 
 *  * button1 = new Button(myResources.getString("OkKey"));
 * button2 = new Button(myResources.getString("CancelKey"));
 * 
 * 
 * The getter methods all require the key as an argument and return
 * the object if found. If the object is not found, the getter method
 * throws a `MissingResourceException`.
 *
 * 
 * Besides `getString`, `ResourceBundle` also provides
 * a method for getting string arrays, `getStringArray`,
 * as well as a generic `getObject` method for any other
 * type of object. When using `getObject`, you'll
 * have to cast the result to the appropriate type. For example:
 * 
 *  * int[] myIntegers = (int[]) myResources.getObject("intList");
 * 
 * 
 *
 * 
 * The Java Platform provides two subclasses of `ResourceBundle`,
 * `ListResourceBundle` and `PropertyResourceBundle`,
 * that provide a fairly simple way to create resources.
 * As you saw briefly in a previous example, `ListResourceBundle`
 * manages its resource as a list of key/value pairs.
 * `PropertyResourceBundle` uses a properties file to manage
 * its resources.
 *
 * 
 * If `ListResourceBundle` or `PropertyResourceBundle`
 * do not suit your needs, you can write your own `ResourceBundle`
 * subclass.  Your subclasses must override two methods: `handleGetObject`
 * and `getKeys()`.
 *
 * 
 * The implementation of a `ResourceBundle` subclass must be thread-safe
 * if it's simultaneously used by multiple threads. The default implementations
 * of the non-abstract methods in this class, and the methods in the direct
 * known concrete subclasses `ListResourceBundle` and
 * `PropertyResourceBundle` are thread-safe.
 *
 * Resource Bundles and Named Modules
 *
 * Resource bundles can be deployed in modules in the following ways:
 *
 * Resource bundles together with an application
 *
 * Resource bundles can be deployed together with an application in the same
 * module.  In that case, the resource bundles are loaded
 * by code in the module by calling the {@link #getBundle(String)}
 * or {@link #getBundle(String, Locale)} method.
 *
 * Resource bundles as service providers
 *
 * Resource bundles can be deployed in one or more service provider modules
 * and they can be located using {@link ServiceLoader}.
 * A {@linkplain ResourceBundleProvider service} interface or class must be
 * defined. The caller module declares that it uses the service, the service
 * provider modules declare that they provide implementations of the service.
 * Refer to {@link ResourceBundleProvider} for developing resource bundle
 * services and deploying resource bundle providers.
 * The module obtaining the resource bundle can be a resource bundle
 * provider itself; in which case this module only locates the resource bundle
 * via service provider mechanism.
 *
 * A {@linkplain ResourceBundleProvider resource bundle provider} can
 * provide resource bundles in any format such XML which replaces the need
 * of {@link Control ResourceBundle.Control}.
 *
 * Resource bundles in other modules and class path
 *
 * Resource bundles in a named module may be encapsulated so that
 * it cannot be located by code in other modules.  Resource bundles
 * in unnamed modules and class path are open for any module to access.
 * Resource bundle follows the resource encapsulation rules as specified
 * in {@link Module#getResourceAsStream(String)}.
 *
 * The `getBundle` factory methods with no `Control` parameter
 * locate and load resource bundles from
 * {@linkplain ResourceBundleProvider service providers}.
 * It may continue the search as if calling {@link Module#getResourceAsStream(String)}
 * to find the named resource from a given module and calling
 * {@link ClassLoader#getResourceAsStream(String)}; refer to
 * the specification of the `getBundle` method for details.
 * Only non-encapsulated resource bundles of "`java.class`"
 * or "`java.properties`" format are searched.
 *
 * If the caller module is a
 * 
 * resource bundle provider, it does not fall back to the
 * class loader search.
 *
 * Resource bundles in automatic modules
 *
 * A common format of resource bundles is in {@linkplain PropertyResourceBundle
 * .properties} file format.  Typically `.properties` resource bundles
 * are packaged in a JAR file.  Resource bundle only JAR file can be readily
 * deployed as an 
 * automatic module.  For example, if the JAR file contains the
 * entry "`p/q/Foo_ja.properties`" and no `.class` entry,
 * when resolved and defined as an automatic module, no package is derived
 * for this module.  This allows resource bundles in `.properties`
 * format packaged in one or more JAR files that may contain entries
 * in the same directory and can be resolved successfully as
 * automatic modules.
 *
 * ResourceBundle.Control
 *
 * The {@link ResourceBundle.Control} class provides information necessary
 * to perform the bundle loading process by the `getBundle`
 * factory methods that take a `ResourceBundle.Control`
 * instance. You can implement your own subclass in order to enable
 * non-standard resource bundle formats, change the search strategy, or
 * define caching parameters. Refer to the descriptions of the class and the
 * {@link #getBundle(String, Locale, ClassLoader, Control) getBundle}
 * factory method for details.
 *
 *  {@link ResourceBundle.Control} is designed for an application deployed
 * in an unnamed module, for example to support resource bundles in
 * non-standard formats or package localized resources in a non-traditional
 * convention. {@link ResourceBundleProvider} is the replacement for
 * `ResourceBundle.Control` when migrating to modules.
 * `UnsupportedOperationException` will be thrown when a factory
 * method that takes the `ResourceBundle.Control` parameter is called.
 *
 * For the `getBundle` factory
 * methods that take no {@link Control} instance, their  default behavior of resource bundle loading
 * can be modified with custom {@link
 * ResourceBundleControlProvider} implementations.
 * If any of the
 * providers provides a {@link Control} for the given base name, that {@link
 * Control} will be used instead of the default {@link Control}. If there is
 * more than one service provider for supporting the same base name,
 * the first one returned from {@link ServiceLoader} will be used.
 * A custom {@link Control} implementation is ignored by named modules.
 *
 * Cache Management
 *
 * Resource bundle instances created by the `getBundle` factory
 * methods are cached by default, and the factory methods return the same
 * resource bundle instance multiple times if it has been
 * cached. `getBundle` clients may clear the cache, manage the
 * lifetime of cached resource bundle instances using time-to-live values,
 * or specify not to cache resource bundle instances. Refer to the
 * descriptions of the {@linkplain #getBundle(String, Locale, ClassLoader,
 * Control) `getBundle` factory method}, {@link
 * #clearCache(ClassLoader) clearCache}, {@link
 * Control#getTimeToLive(String, Locale)
 * ResourceBundle.Control.getTimeToLive}, and {@link
 * Control#needsReload(String, Locale, String, ClassLoader, ResourceBundle,
 * long) ResourceBundle.Control.needsReload} for details.
 *
 * Example
 *
 * The following is a very simple example of a `ResourceBundle`
 * subclass, `MyResources`, that manages two resources (for a larger number of
 * resources you would probably use a `Map`).
 * Notice that you don't need to supply a value if
 * a "parent-level" `ResourceBundle` handles the same
 * key with the same value (as for the okKey below).
 * 
 *  * // default (English language, United States)
 * public class MyResources extends ResourceBundle {
 *     public Object handleGetObject(String key) {
 *         if (key.equals("okKey")) return "Ok";
 *         if (key.equals("cancelKey")) return "Cancel";
 *         return null;
 *     }
 *
 *     public Enumeration<String> getKeys() {
 *         return Collections.enumeration(keySet());
 *     }
 *
 *     // Overrides handleKeySet() so that the getKeys() implementation
 *     // can rely on the keySet() value.
 *     protected Set<String> handleKeySet() {
 *         return new HashSet<String>(Arrays.asList("okKey", "cancelKey"));
 *     }
 * }
 *
 * // German language
 * public class MyResources_de extends MyResources {
 *     public Object handleGetObject(String key) {
 *         // don't need okKey, since parent level handles it.
 *         if (key.equals("cancelKey")) return "Abbrechen";
 *         return null;
 *     }
 *
 *     protected Set<String> handleKeySet() {
 *         return new HashSet<String>(Arrays.asList("cancelKey"));
 *     }
 * }
 * 
 * 
 * You do not have to restrict yourself to using a single family of
 * `ResourceBundle`s. For example, you could have a set of bundles for
 * exception messages, `ExceptionResources`
 * (`ExceptionResources_fr`, `ExceptionResources_de`, ...),
 * and one for widgets, `WidgetResource` (`WidgetResources_fr`,
 * `WidgetResources_de`, ...); breaking up the resources however you like.
 *
 * @see ListResourceBundle
 * @see PropertyResourceBundle
 * @see MissingResourceException
 * @see ResourceBundleProvider
 * @since 1.1
 * @revised 9
*/
export class ResourceBundle {
  /**
   * Returns the base name of this bundle, if known, or `null` if unknown.
   *
   * If not null, then this is the value of the `baseName` parameter
   * that was passed to the `ResourceBundle.getBundle(...)` method
   * when the resource bundle was loaded.
   *
   * @return The base name of the resource bundle, as provided to and expected
   * by the `ResourceBundle.getBundle(...)` methods.
   *
   * @see #getBundle(java.lang.String, java.util.Locale, java.lang.ClassLoader)
   *
   * @since 1.8
  */
  getBaseBundleName(): string;
  /**
   * Sole constructor.  (For invocation by subclass constructors, typically
   * implicit.)
  */
  constructor();
  /**
   * Gets a string for the given key from this resource bundle or one of its parents.
   * Calling this method is equivalent to calling
   * 
   * (String) {@link #getObject(java.lang.String) getObject}(key).
   * 
   *
   * @param key the key for the desired string
   * @throws    NullPointerException if `key` is `null`
   * @throws    MissingResourceException if no object for the given key can be found
   * @throws    ClassCastException if the object found for the given key is not a string
   * @return the string for the given key
  */
  getString(key: string): string;
  /**
   * Gets a string array for the given key from this resource bundle or one of its parents.
   * Calling this method is equivalent to calling
   * 
   * (String[]) {@link #getObject(java.lang.String) getObject}(key).
   * 
   *
   * @param key the key for the desired string array
   * @throws    NullPointerException if `key` is `null`
   * @throws    MissingResourceException if no object for the given key can be found
   * @throws    ClassCastException if the object found for the given key is not a string array
   * @return the string array for the given key
  */
  getStringArray(key: string): string[];
  /**
   * Gets an object for the given key from this resource bundle or one of its parents.
   * This method first tries to obtain the object from this resource bundle using
   * {@link #handleGetObject(java.lang.String) handleGetObject}.
   * If not successful, and the parent resource bundle is not null,
   * it calls the parent's `getObject` method.
   * If still not successful, it throws a MissingResourceException.
   *
   * @param key the key for the desired object
   * @throws    NullPointerException if `key` is `null`
   * @throws    MissingResourceException if no object for the given key can be found
   * @return the object for the given key
  */
  getObject(key: string): any;
  /**
   * Returns the locale of this resource bundle. This method can be used after a
   * call to getBundle() to determine whether the resource bundle returned really
   * corresponds to the requested locale or is a fallback.
   *
   * @return the locale of this resource bundle
  */
  getLocale(): Locale;
  /**
   * Gets a resource bundle using the specified base name, the default locale,
   * and the caller module. Calling this method is equivalent to calling
   * 
   * `getBundle(baseName, Locale.getDefault(), callerModule)`,
   * 
   *
   * @param baseName the base name of the resource bundle, a fully qualified class name
   * @throws    java.lang.NullPointerException
   *     if `baseName` is `null`
   * @throws    MissingResourceException
   *     if no resource bundle for the specified base name can be found
   * @return a resource bundle for the given base name and the default locale
   *
   * @see Resource Bundle Search and Loading Strategy
   * @see Resource Bundles and Named Modules
  */
  static getBundle(baseName: string): ResourceBundle;
  /**
   * Returns a resource bundle using the specified base name, the
   * default locale and the specified control. Calling this method
   * is equivalent to calling
   *      * getBundle(baseName, Locale.getDefault(),
   *           this.getClass().getClassLoader(), control),
   * 
   * except that `getClassLoader()` is run with the security
   * privileges of `ResourceBundle`.  See {@link
   * #getBundle(String, Locale, ClassLoader, Control) getBundle} for the
   * complete description of the resource bundle loading process with a
   * `ResourceBundle.Control`.
   *
   * @param baseName
   *        the base name of the resource bundle, a fully qualified class
   *        name
   * @param control
   *        the control which gives information for the resource bundle
   *        loading process
   * @return a resource bundle for the given base name and the default locale
   * @throws NullPointerException
   *         if `baseName` or `control` is
   *         `null`
   * @throws MissingResourceException
   *         if no resource bundle for the specified base name can be found
   * @throws IllegalArgumentException
   *         if the given `control` doesn't perform properly
   *         (e.g., `control.getCandidateLocales` returns null.)
   *         Note that validation of `control` is performed as
   *         needed.
   * @throws UnsupportedOperationException
   *         if this method is called in a named module
   * @since 1.6
   * @revised 9
  */
  static getBundle(baseName: string, control: Control): ResourceBundle;
  /**
   * Gets a resource bundle using the specified base name and locale,
   * and the caller module. Calling this method is equivalent to calling
   * 
   * `getBundle(baseName, locale, callerModule)`,
   * 
   *
   * @param baseName
   *        the base name of the resource bundle, a fully qualified class name
   * @param locale
   *        the locale for which a resource bundle is desired
   * @throws    NullPointerException
   *        if `baseName` or `locale` is `null`
   * @throws    MissingResourceException
   *        if no resource bundle for the specified base name can be found
   * @return a resource bundle for the given base name and locale
   *
   * @see Resource Bundle Search and Loading Strategy
   * @see Resource Bundles and Named Modules
  */
  static getBundle(baseName: string, locale: Locale): ResourceBundle;
  /**
   * Gets a resource bundle using the specified base name and the default locale
   * on behalf of the specified module. This method is equivalent to calling
   * 
   * `getBundle(baseName, Locale.getDefault(), module)`
   * 
   *
   * @param baseName the base name of the resource bundle,
   *                 a fully qualified class name
   * @param module   the module for which the resource bundle is searched
   * @throws NullPointerException
   *         if `baseName` or `module` is `null`
   * @throws SecurityException
   *         if a security manager exists and the caller is not the specified
   *         module and doesn't have `RuntimePermission("getClassLoader")`
   * @throws MissingResourceException
   *         if no resource bundle for the specified base name can be found in the
   *         specified module
   * @return a resource bundle for the given base name and the default locale
   * @since 9
   * @see ResourceBundleProvider
   * @see Resource Bundle Search and Loading Strategy
   * @see Resource Bundles and Named Modules
  */
  static getBundle(baseName: string, module: Module): ResourceBundle;
  /**
   * Gets a resource bundle using the specified base name and locale
   * on behalf of the specified module.
   *
   *  Resource bundles in named modules may be encapsulated.  When
   * the resource bundle is loaded from a
   * {@linkplain ResourceBundleProvider service provider}, the caller module
   * must have an appropriate uses clause in its module descriptor
   * to declare that the module uses of {@link ResourceBundleProvider}
   * for the named resource bundle.
   * Otherwise, it will load the resource bundles that are local in the
   * given module as if calling {@link Module#getResourceAsStream(String)}
   * or that are visible to the class loader of the given module
   * as if calling {@link ClassLoader#getResourceAsStream(String)}.
   * When the resource bundle is loaded from the specified module, it is
   * subject to the encapsulation rules specified by
   * {@link Module#getResourceAsStream Module.getResourceAsStream}.
   *
   * 
   * If the given `module` is an unnamed module, then this method is
   * equivalent to calling {@link #getBundle(String, Locale, ClassLoader)
   * getBundle(baseName, targetLocale, module.getClassLoader()} to load
   * resource bundles that are visible to the class loader of the given
   * unnamed module. Custom {@link java.util.spi.ResourceBundleControlProvider}
   * implementations, if present, will only be invoked if the specified
   * module is an unnamed module.
   *
   * @param baseName the base name of the resource bundle,
   *                 a fully qualified class name
   * @param targetLocale the locale for which a resource bundle is desired
   * @param module   the module for which the resource bundle is searched
   * @throws NullPointerException
   *         if `baseName`, `targetLocale`, or `module` is
   *         `null`
   * @throws SecurityException
   *         if a security manager exists and the caller is not the specified
   *         module and doesn't have `RuntimePermission("getClassLoader")`
   * @throws MissingResourceException
   *         if no resource bundle for the specified base name and locale can
   *         be found in the specified `module`
   * @return a resource bundle for the given base name and locale in the module
   * @since 9
   * @see Resource Bundle Search and Loading Strategy
   * @see Resource Bundles and Named Modules
  */
  static getBundle(baseName: string, targetLocale: Locale, module: Module): ResourceBundle;
  /**
   * Returns a resource bundle using the specified base name, target
   * locale and control, and the caller's class loader. Calling this
   * method is equivalent to calling
   *      * getBundle(baseName, targetLocale, this.getClass().getClassLoader(),
   *           control),
   * 
   * except that `getClassLoader()` is run with the security
   * privileges of `ResourceBundle`.  See {@link
   * #getBundle(String, Locale, ClassLoader, Control) getBundle} for the
   * complete description of the resource bundle loading process with a
   * `ResourceBundle.Control`.
   *
   * @param baseName
   *        the base name of the resource bundle, a fully qualified
   *        class name
   * @param targetLocale
   *        the locale for which a resource bundle is desired
   * @param control
   *        the control which gives information for the resource
   *        bundle loading process
   * @return a resource bundle for the given base name and a
   *         `Locale` in `locales`
   * @throws NullPointerException
   *         if `baseName`, `locales` or
   *         `control` is `null`
   * @throws MissingResourceException
   *         if no resource bundle for the specified base name in any
   *         of the `locales` can be found.
   * @throws IllegalArgumentException
   *         if the given `control` doesn't perform properly
   *         (e.g., `control.getCandidateLocales` returns null.)
   *         Note that validation of `control` is performed as
   *         needed.
   * @throws UnsupportedOperationException
   *         if this method is called in a named module
   * @since 1.6
   * @revised 9
  */
  static getBundle(baseName: string, targetLocale: Locale, control: Control): ResourceBundle;
  /**
   * Gets a resource bundle using the specified base name, locale, and class
   * loader.
   *
   * When this method is called from a named module and the given
   * loader is the class loader of the caller module, this is equivalent
   * to calling:
   *      * getBundle(baseName, targetLocale, callerModule)
   * 
   *
   * otherwise, this is equivalent to calling:
   *      * getBundle(baseName, targetLocale, loader, control)
   * 
   * where `control` is the default instance of {@link Control} unless
   * a `Control` instance is provided by
   * {@link ResourceBundleControlProvider} SPI.  Refer to the
   * description of modifying the default
   * behavior. The following describes the default behavior.
   *
   * 
   * Resource Bundle Search and Loading Strategy
   *
   * `getBundle` uses the base name, the specified locale, and
   * the default locale (obtained from {@link java.util.Locale#getDefault()
   * Locale.getDefault}) to generate a sequence of candidate bundle names.  If the specified
   * locale's language, script, country, and variant are all empty strings,
   * then the base name is the only candidate bundle name.  Otherwise, a list
   * of candidate locales is generated from the attribute values of the
   * specified locale (language, script, country and variant) and appended to
   * the base name.  Typically, this will look like the following:
   *
   *      *     baseName + "_" + language + "_" + script + "_" + country + "_" + variant
   *     baseName + "_" + language + "_" + script + "_" + country
   *     baseName + "_" + language + "_" + script
   *     baseName + "_" + language + "_" + country + "_" + variant
   *     baseName + "_" + language + "_" + country
   *     baseName + "_" + language
   * 
   *
   * Candidate bundle names where the final component is an empty string
   * are omitted, along with the underscore.  For example, if country is an
   * empty string, the second and the fifth candidate bundle names above
   * would be omitted.  Also, if script is an empty string, the candidate names
   * including script are omitted.  For example, a locale with language "de"
   * and variant "JAVA" will produce candidate names with base name
   * "MyResource" below.
   *
   *      *     MyResource_de__JAVA
   *     MyResource_de
   * 
   *
   * In the case that the variant contains one or more underscores ('_'), a
   * sequence of bundle names generated by truncating the last underscore and
   * the part following it is inserted after a candidate bundle name with the
   * original variant.  For example, for a locale with language "en", script
   * "Latn, country "US" and variant "WINDOWS_VISTA", and bundle base name
   * "MyResource", the list of candidate bundle names below is generated:
   *
   *      * MyResource_en_Latn_US_WINDOWS_VISTA
   * MyResource_en_Latn_US_WINDOWS
   * MyResource_en_Latn_US
   * MyResource_en_Latn
   * MyResource_en_US_WINDOWS_VISTA
   * MyResource_en_US_WINDOWS
   * MyResource_en_US
   * MyResource_en
   * 
   *
   * Note: For some `Locale`s, the list of
   * candidate bundle names contains extra names, or the order of bundle names
   * is slightly modified.  See the description of the default implementation
   * of {@link Control#getCandidateLocales(String, Locale)
   * getCandidateLocales} for details.
   *
   * `getBundle` then iterates over the candidate bundle names
   * to find the first one for which it can instantiate an actual
   * resource bundle. It uses the default controls' {@link Control#getFormats
   * getFormats} method, which generates two bundle names for each generated
   * name, the first a class name and the second a properties file name. For
   * each candidate bundle name, it attempts to create a resource bundle:
   *
   * First, it attempts to load a class using the generated class name.
   * If such a class can be found and loaded using the specified class
   * loader, is assignment compatible with ResourceBundle, is accessible from
   * ResourceBundle, and can be instantiated, `getBundle` creates a
   * new instance of this class and uses it as the result resource
   * bundle.
   *
   * Otherwise, `getBundle` attempts to locate a property
   * resource file using the generated properties file name.  It generates a
   * path name from the candidate bundle name by replacing all "." characters
   * with "/" and appending the string ".properties".  It attempts to find a
   * "resource" with this name using {@link
   * java.lang.ClassLoader#getResource(java.lang.String)
   * ClassLoader.getResource}.  (Note that a "resource" in the sense of
   * `getResource` has nothing to do with the contents of a
   * resource bundle, it is just a container of data, such as a file.)  If it
   * finds a "resource", it attempts to create a new {@link
   * PropertyResourceBundle} instance from its contents.  If successful, this
   * instance becomes the result resource bundle.  
   *
   * This continues until a result resource bundle is instantiated or the
   * list of candidate bundle names is exhausted.  If no matching resource
   * bundle is found, the default control's {@link Control#getFallbackLocale
   * getFallbackLocale} method is called, which returns the current default
   * locale.  A new sequence of candidate locale names is generated using this
   * locale and searched again, as above.
   *
   * If still no result bundle is found, the base name alone is looked up. If
   * this still fails, a `MissingResourceException` is thrown.
   *
   *  Once a result resource bundle has been found,
   * its parent chain is instantiated.  If the result bundle already
   * has a parent (perhaps because it was returned from a cache) the chain is
   * complete.
   *
   * Otherwise, `getBundle` examines the remainder of the
   * candidate locale list that was used during the pass that generated the
   * result resource bundle.  (As before, candidate bundle names where the
   * final component is an empty string are omitted.)  When it comes to the
   * end of the candidate list, it tries the plain bundle name.  With each of the
   * candidate bundle names it attempts to instantiate a resource bundle (first
   * looking for a class and then a properties file, as described above).
   *
   * Whenever it succeeds, it calls the previously instantiated resource
   * bundle's {@link #setParent(java.util.ResourceBundle) setParent} method
   * with the new resource bundle.  This continues until the list of names
   * is exhausted or the current bundle already has a non-null parent.
   *
   * Once the parent chain is complete, the bundle is returned.
   *
   * Note: `getBundle` caches instantiated resource
   * bundles and might return the same resource bundle instance multiple times.
   *
   * Note:The `baseName` argument should be a fully
   * qualified class name. However, for compatibility with earlier versions,
   * Java SE Runtime Environments do not verify this, and so it is
   * possible to access `PropertyResourceBundle`s by specifying a
   * path name (using "/") instead of a fully qualified class name (using
   * ".").
   *
   * 
   * Example:
   * 
   * The following class and property files are provided:
   * 
   *     MyResources.class
   *     MyResources.properties
   *     MyResources_fr.properties
   *     MyResources_fr_CH.class
   *     MyResources_fr_CH.properties
   *     MyResources_en.properties
   *     MyResources_es_ES.class
   * 
   *
   * The contents of all files are valid (that is, public non-abstract
   * subclasses of `ResourceBundle` for the ".class" files,
   * syntactically correct ".properties" files).  The default locale is
   * `Locale("en", "GB")`.
   *
   * Calling `getBundle` with the locale arguments below will
   * instantiate resource bundles as follows:
   *
   * 
   * getBundle() locale to resource bundle mapping
   * 
   * LocaleResource bundle
   * 
   * 
   * Locale("fr", "CH")MyResources_fr_CH.class, parent MyResources_fr.properties, parent MyResources.class
   * Locale("fr", "FR")MyResources_fr.properties, parent MyResources.class
   * Locale("de", "DE")MyResources_en.properties, parent MyResources.class
   * Locale("en", "US")MyResources_en.properties, parent MyResources.class
   * Locale("es", "ES")MyResources_es_ES.class, parent MyResources.class
   * 
   * 
   *
   * The file MyResources_fr_CH.properties is never used because it is
   * hidden by the MyResources_fr_CH.class. Likewise, MyResources.properties
   * is also hidden by MyResources.class.
   *
   * @apiNote If the caller module is a named module and the given
   * `loader` is the caller module's class loader, this method is
   * equivalent to `getBundle(baseName, locale)`; otherwise, it may not
   * find resource bundles from named modules.
   * Use {@link #getBundle(String, Locale, Module)} to load resource bundles
   * on behalf on a specific module instead.
   *
   * @param baseName the base name of the resource bundle, a fully qualified class name
   * @param locale the locale for which a resource bundle is desired
   * @param loader the class loader from which to load the resource bundle
   * @return a resource bundle for the given base name and locale
   * @throws    java.lang.NullPointerException
   *        if `baseName`, `locale`, or `loader` is `null`
   * @throws    MissingResourceException
   *        if no resource bundle for the specified base name can be found
   * @since 1.2
   * @revised 9
   * @see Resource Bundles and Named Modules
  */
  static getBundle(baseName: string, locale: Locale, loader: ClassLoader): ResourceBundle;
  /**
   * Returns a resource bundle using the specified base name, target
   * locale, class loader and control. Unlike the {@link
   * #getBundle(String, Locale, ClassLoader) getBundle}
   * factory methods with no `control` argument, the given
   * `control` specifies how to locate and instantiate resource
   * bundles. Conceptually, the bundle loading process with the given
   * `control` is performed in the following steps.
   *
   * 
   * This factory method looks up the resource bundle in the cache for
   * the specified `baseName`, `targetLocale` and
   * `loader`.  If the requested resource bundle instance is
   * found in the cache and the time-to-live periods of the instance and
   * all of its parent instances have not expired, the instance is returned
   * to the caller. Otherwise, this factory method proceeds with the
   * loading process below.
   *
   * The {@link ResourceBundle.Control#getFormats(String)
   * control.getFormats} method is called to get resource bundle formats
   * to produce bundle or resource names. The strings
   * `"java.class"` and `"java.properties"`
   * designate class-based and {@linkplain PropertyResourceBundle
   * property}-based resource bundles, respectively. Other strings
   * starting with `"java."` are reserved for future extensions
   * and must not be used for application-defined formats. Other strings
   * designate application-defined formats.
   *
   * The {@link ResourceBundle.Control#getCandidateLocales(String,
   * Locale) control.getCandidateLocales} method is called with the target
   * locale to get a list of candidate `Locale`s for
   * which resource bundles are searched.
   *
   * The {@link ResourceBundle.Control#newBundle(String, Locale,
   * String, ClassLoader, boolean) control.newBundle} method is called to
   * instantiate a `ResourceBundle` for the base bundle name, a
   * candidate locale, and a format. (Refer to the note on the cache
   * lookup below.) This step is iterated over all combinations of the
   * candidate locales and formats until the `newBundle` method
   * returns a `ResourceBundle` instance or the iteration has
   * used up all the combinations. For example, if the candidate locales
   * are `Locale("de", "DE")`, `Locale("de")` and
   * `Locale("")` and the formats are `"java.class"`
   * and `"java.properties"`, then the following is the
   * sequence of locale-format combinations to be used to call
   * `control.newBundle`.
   *
   * 
   * locale-format combinations for newBundle
   * 
   * 
   * Index
   * `Locale`
   * `format`
   * 
   * 
   * 
   * 
   * 1
   * `Locale("de", "DE")`
   * `java.class`
   * 
   * 
   * 2
   * `Locale("de", "DE")`
   * `java.properties`
   * 
   * 
   * 3
   * `Locale("de")`
   * `java.class`
   * 
   * 
   * 4
   * `Locale("de")`
   * `java.properties`
   * 
   * 
   * 5
   * `Locale("")`
   * `java.class`
   * 
   * 
   * 6
   * `Locale("")`
   * `java.properties`
   * 
   * 
   * 
   * 
   *
   * If the previous step has found no resource bundle, proceed to
   * Step 6. If a bundle has been found that is a base bundle (a bundle
   * for `Locale("")`), and the candidate locale list only contained
   * `Locale("")`, return the bundle to the caller. If a bundle
   * has been found that is a base bundle, but the candidate locale list
   * contained locales other than Locale(""), put the bundle on hold and
   * proceed to Step 6. If a bundle has been found that is not a base
   * bundle, proceed to Step 7.
   *
   * The {@link ResourceBundle.Control#getFallbackLocale(String,
   * Locale) control.getFallbackLocale} method is called to get a fallback
   * locale (alternative to the current target locale) to try further
   * finding a resource bundle. If the method returns a non-null locale,
   * it becomes the next target locale and the loading process starts over
   * from Step 3. Otherwise, if a base bundle was found and put on hold in
   * a previous Step 5, it is returned to the caller now. Otherwise, a
   * MissingResourceException is thrown.
   *
   * At this point, we have found a resource bundle that's not the
   * base bundle. If this bundle set its parent during its instantiation,
   * it is returned to the caller. Otherwise, its parent chain is
   * instantiated based on the list of candidate locales from which it was
   * found. Finally, the bundle is returned to the caller.
   * 
   *
   * During the resource bundle loading process above, this factory
   * method looks up the cache before calling the {@link
   * Control#newBundle(String, Locale, String, ClassLoader, boolean)
   * control.newBundle} method.  If the time-to-live period of the
   * resource bundle found in the cache has expired, the factory method
   * calls the {@link ResourceBundle.Control#needsReload(String, Locale,
   * String, ClassLoader, ResourceBundle, long) control.needsReload}
   * method to determine whether the resource bundle needs to be reloaded.
   * If reloading is required, the factory method calls
   * `control.newBundle` to reload the resource bundle.  If
   * `control.newBundle` returns `null`, the factory
   * method puts a dummy resource bundle in the cache as a mark of
   * nonexistent resource bundles in order to avoid lookup overhead for
   * subsequent requests. Such dummy resource bundles are under the same
   * expiration control as specified by `control`.
   *
   * All resource bundles loaded are cached by default. Refer to
   * {@link Control#getTimeToLive(String,Locale)
   * control.getTimeToLive} for details.
   *
   * The following is an example of the bundle loading process with the
   * default `ResourceBundle.Control` implementation.
   *
   * Conditions:
   * 
   * Base bundle name: `foo.bar.Messages`
   * Requested `Locale`: {@link Locale#ITALY}
   * Default `Locale`: {@link Locale#FRENCH}
   * Available resource bundles:
   * `foo/bar/Messages_fr.properties` and
   * `foo/bar/Messages.properties`
   * 
   *
   * First, `getBundle` tries loading a resource bundle in
   * the following sequence.
   *
   * 
   * class `foo.bar.Messages_it_IT`
   * file `foo/bar/Messages_it_IT.properties`
   * class `foo.bar.Messages_it`
   * file `foo/bar/Messages_it.properties`
   * class `foo.bar.Messages`
   * file `foo/bar/Messages.properties`
   * 
   *
   * At this point, `getBundle` finds
   * `foo/bar/Messages.properties`, which is put on hold
   * because it's the base bundle.  `getBundle` calls {@link
   * Control#getFallbackLocale(String, Locale)
   * control.getFallbackLocale("foo.bar.Messages", Locale.ITALY)} which
   * returns `Locale.FRENCH`. Next, `getBundle`
   * tries loading a bundle in the following sequence.
   *
   * 
   * class `foo.bar.Messages_fr`
   * file `foo/bar/Messages_fr.properties`
   * class `foo.bar.Messages`
   * file `foo/bar/Messages.properties`
   * 
   *
   * `getBundle` finds
   * `foo/bar/Messages_fr.properties` and creates a
   * `ResourceBundle` instance. Then, `getBundle`
   * sets up its parent chain from the list of the candidate locales.  Only
   * `foo/bar/Messages.properties` is found in the list and
   * `getBundle` creates a `ResourceBundle` instance
   * that becomes the parent of the instance for
   * `foo/bar/Messages_fr.properties`.
   *
   * @param baseName
   *        the base name of the resource bundle, a fully qualified
   *        class name
   * @param targetLocale
   *        the locale for which a resource bundle is desired
   * @param loader
   *        the class loader from which to load the resource bundle
   * @param control
   *        the control which gives information for the resource
   *        bundle loading process
   * @return a resource bundle for the given base name and locale
   * @throws NullPointerException
   *         if `baseName`, `targetLocale`,
   *         `loader`, or `control` is
   *         `null`
   * @throws MissingResourceException
   *         if no resource bundle for the specified base name can be found
   * @throws IllegalArgumentException
   *         if the given `control` doesn't perform properly
   *         (e.g., `control.getCandidateLocales` returns null.)
   *         Note that validation of `control` is performed as
   *         needed.
   * @throws UnsupportedOperationException
   *         if this method is called in a named module
   * @since 1.6
   * @revised 9
  */
  static getBundle(baseName: string, targetLocale: Locale, loader: ClassLoader, control: Control): ResourceBundle;
  /**
   * Removes all resource bundles from the cache that have been loaded
   * by the caller's module.
   *
   * @since 1.6
   * @revised 9
   * @see ResourceBundle.Control#getTimeToLive(String,Locale)
  */
  static clearCache(): void;
  /**
   * Removes all resource bundles from the cache that have been loaded
   * by the given class loader.
   *
   * @param loader the class loader
   * @throws    NullPointerException if `loader` is null
   * @since 1.6
   * @see ResourceBundle.Control#getTimeToLive(String,Locale)
  */
  static clearCache(loader: ClassLoader): void;
  /**
   * Returns an enumeration of the keys.
   *
   * @return an `Enumeration` of the keys contained in
   *         this `ResourceBundle` and its parent bundles.
  */
  getKeys(): Enumeration<string>;
  /**
   * Determines whether the given `key` is contained in
   * this `ResourceBundle` or its parent bundles.
   *
   * @param key
   *        the resource `key`
   * @return `true` if the given `key` is
   *        contained in this `ResourceBundle` or its
   *        parent bundles; `false` otherwise.
   * @throws    NullPointerException
   *         if `key` is `null`
   * @since 1.6
  */
  containsKey(key: string): boolean;
  /**
   * Returns a `Set` of all keys contained in this
   * `ResourceBundle` and its parent bundles.
   *
   * @return a `Set` of all keys contained in this
   *         `ResourceBundle` and its parent bundles.
   * @since 1.6
  */
  keySet(): Set<string>;
}
export class LinkedHashSet<E> extends HashSet<E> {
  /**
   * Constructs a new, empty linked hash set with the specified initial
   * capacity and load factor.
   *
   * @param      initialCapacity the initial capacity of the linked hash set
   * @param      loadFactor      the load factor of the linked hash set
   * @throws     IllegalArgumentException  if the initial capacity is less
   *               than zero, or if the load factor is nonpositive
  */
  constructor(initialCapacity: number, loadFactor: number);
  /**
   * Constructs a new, empty linked hash set with the specified initial
   * capacity and the default load factor (0.75).
   *
   * @param   initialCapacity   the initial capacity of the LinkedHashSet
   * @throws  IllegalArgumentException if the initial capacity is less
   *              than zero
  */
  constructor(initialCapacity: number);
  /**
   * Constructs a new, empty linked hash set with the default initial
   * capacity (16) and load factor (0.75).
  */
  constructor();
  /**
   * Constructs a new linked hash set with the same elements as the
   * specified collection.  The linked hash set is created with an initial
   * capacity sufficient to hold the elements in the specified collection
   * and the default load factor (0.75).
   *
   * @param c  the collection whose elements are to be placed into
   *           this set
   * @throws NullPointerException if the specified collection is null
  */
  constructor(c: Collection<E>);
  /**
   * Creates a late-binding
   * and fail-fast `Spliterator` over the elements in this set.
   *
   * The `Spliterator` reports {@link Spliterator#SIZED},
   * {@link Spliterator#DISTINCT}, and `ORDERED`.  Implementations
   * should document the reporting of additional characteristic values.
   *
   * @implNote
   * The implementation creates a
   * late-binding spliterator
   * from the set's `Iterator`.  The spliterator inherits the
   * fail-fast properties of the set's iterator.
   * The created `Spliterator` additionally reports
   * {@link Spliterator#SUBSIZED}.
   *
   * @return a `Spliterator` over the elements in this set
   * @since 1.8
  */
  spliterator(): Spliterator<E>;
}
export interface LinkedHashSet<E> extends HashSet<E>, Set<E>, Cloneable, Serializable {}
/**
 * Thrown by methods in the `Stack` class to indicate
 * that the stack is empty.
 *
 * @author  Jonathan Payne
 * @see     java.util.Stack
 * @since   1.0
*/
export class EmptyStackException extends RuntimeException {
  /**
   * Constructs a new `EmptyStackException` with `null`
   * as its error message string.
  */
  constructor();
}
export class TooManyListenersException extends Exception {
  constructor();
  constructor(s: string);
}
/**
 * The `Properties` class represents a persistent set of
 * properties. The `Properties` can be saved to a stream
 * or loaded from a stream. Each key and its corresponding value in
 * the property list is a string.
 * 
 * A property list can contain another property list as its
 * "defaults"; this second property list is searched if
 * the property key is not found in the original property list.
 * 
 * Because `Properties` inherits from `Hashtable`, the
 * `put` and `putAll` methods can be applied to a
 * `Properties` object.  Their use is strongly discouraged as they
 * allow the caller to insert entries whose keys or values are not
 * `Strings`.  The `setProperty` method should be used
 * instead.  If the `store` or `save` method is called
 * on a "compromised" `Properties` object that contains a
 * non-`String` key or value, the call will fail. Similarly,
 * the call to the `propertyNames` or `list` method
 * will fail if it is called on a "compromised" `Properties`
 * object that contains a non-`String` key.
 *
 * 
 * The iterators returned by the `iterator` method of this class's
 * "collection views" (that is, `entrySet()`, `keySet()`, and
 * `values()`) may not fail-fast (unlike the Hashtable implementation).
 * These iterators are guaranteed to traverse elements as they existed upon
 * construction exactly once, and may (but are not guaranteed to) reflect any
 * modifications subsequent to construction.
 * 
 * The {@link #load(java.io.Reader) load(Reader)} `/`
 * {@link #store(java.io.Writer, java.lang.String) store(Writer, String)}
 * methods load and store properties from and to a character based stream
 * in a simple line-oriented format specified below.
 *
 * The {@link #load(java.io.InputStream) load(InputStream)} `/`
 * {@link #store(java.io.OutputStream, java.lang.String) store(OutputStream, String)}
 * methods work the same way as the load(Reader)/store(Writer, String) pair, except
 * the input/output stream is encoded in ISO 8859-1 character encoding.
 * Characters that cannot be directly represented in this encoding can be written using
 * Unicode escapes as defined in section {@jls 3.3} of
 * The Java Language Specification;
 * only a single 'u' character is allowed in an escape
 * sequence.
 *
 *  The {@link #loadFromXML(InputStream)} and {@link
 * #storeToXML(OutputStream, String, String)} methods load and store properties
 * in a simple XML format.  By default the UTF-8 character encoding is used,
 * however a specific encoding may be specified if required. Implementations
 * are required to support UTF-8 and UTF-16 and may support other encodings.
 * An XML properties document has the following DOCTYPE declaration:
 *
 *  * <!DOCTYPE properties SYSTEM "http://java.sun.com/dtd/properties.dtd">
 * 
 * Note that the system URI (http://java.sun.com/dtd/properties.dtd) is
 * not accessed when exporting or importing properties; it merely
 * serves as a string to uniquely identify the DTD, which is:
 *  *    <?xml version="1.0" encoding="UTF-8"?>
 *
 *    <!-- DTD for properties -->
 *
 *    <!ELEMENT properties ( comment?, entry* ) >
 *
 *    <!ATTLIST properties version CDATA #FIXED "1.0">
 *
 *    <!ELEMENT comment (#PCDATA) >
 *
 *    <!ELEMENT entry (#PCDATA) >
 *
 *    <!ATTLIST entry key CDATA #REQUIRED>
 * 
 *
 * This class is thread-safe: multiple threads can share a single
 * `Properties` object without the need for external synchronization.
 *
 * @apiNote
 * The `Properties` class does not inherit the concept of a load factor
 * from its superclass, `Hashtable`.
 *
 * @author  Arthur van Hoff
 * @author  Michael McCloskey
 * @author  Xueming Shen
 * @since   1.0
*/
export class Properties extends Hashtable<any, any> {
  /**
   * Creates an empty property list with no default values.
   *
   * @implNote The initial capacity of a `Properties` object created
   * with this constructor is unspecified.
  */
  constructor();
  /**
   * Creates an empty property list with no default values, and with an
   * initial size accommodating the specified number of elements without the
   * need to dynamically resize.
   *
   * @param  initialCapacity the `Properties` will be sized to
   *         accommodate this many elements
   * @throws IllegalArgumentException if the initial capacity is less than
   *         zero.
  */
  constructor(initialCapacity: number);
  /**
   * Creates an empty property list with the specified defaults.
   *
   * @implNote The initial capacity of a `Properties` object created
   * with this constructor is unspecified.
   *
   * @param   defaults   the defaults.
  */
  constructor(defaults: Properties);
  /**
   * Calls the `Hashtable` method `put`. Provided for
   * parallelism with the `getProperty` method. Enforces use of
   * strings for property keys and values. The value returned is the
   * result of the `Hashtable` call to `put`.
   *
   * @param key the key to be placed into this property list.
   * @param value the value corresponding to `key`.
   * @return     the previous value of the specified key in this property
   *             list, or `null` if it did not have one.
   * @see #getProperty
   * @since    1.2
  */
  setProperty(key: string, value: string): any;
  /**
   * Reads a property list (key and element pairs) from the input
   * character stream in a simple line-oriented format.
   * 
   * Properties are processed in terms of lines. There are two
   * kinds of line, natural lines and logical lines.
   * A natural line is defined as a line of
   * characters that is terminated either by a set of line terminator
   * characters (`\n` or `\r` or `\r\n`)
   * or by the end of the stream. A natural line may be either a blank line,
   * a comment line, or hold all or some of a key-element pair. A logical
   * line holds all the data of a key-element pair, which may be spread
   * out across several adjacent natural lines by escaping
   * the line terminator sequence with a backslash character
   * `\`.  Note that a comment line cannot be extended
   * in this manner; every natural line that is a comment must have
   * its own comment indicator, as described below. Lines are read from
   * input until the end of the stream is reached.
   *
   * 
   * A natural line that contains only white space characters is
   * considered blank and is ignored.  A comment line has an ASCII
   * `'#'` or `'!'` as its first non-white
   * space character; comment lines are also ignored and do not
   * encode key-element information.  In addition to line
   * terminators, this format considers the characters space
   * (`' '`, `'\u005Cu0020'`), tab
   * (`'\t'`, `'\u005Cu0009'`), and form feed
   * (`'\f'`, `'\u005Cu000C'`) to be white
   * space.
   *
   * 
   * If a logical line is spread across several natural lines, the
   * backslash escaping the line terminator sequence, the line
   * terminator sequence, and any white space at the start of the
   * following line have no affect on the key or element values.
   * The remainder of the discussion of key and element parsing
   * (when loading) will assume all the characters constituting
   * the key and element appear on a single natural line after
   * line continuation characters have been removed.  Note that
   * it is not sufficient to only examine the character
   * preceding a line terminator sequence to decide if the line
   * terminator is escaped; there must be an odd number of
   * contiguous backslashes for the line terminator to be escaped.
   * Since the input is processed from left to right, a
   * non-zero even number of 2n contiguous backslashes
   * before a line terminator (or elsewhere) encodes n
   * backslashes after escape processing.
   *
   * 
   * The key contains all of the characters in the line starting
   * with the first non-white space character and up to, but not
   * including, the first unescaped `'='`,
   * `':'`, or white space character other than a line
   * terminator. All of these key termination characters may be
   * included in the key by escaping them with a preceding backslash
   * character; for example,
   *
   * `\:\=`
   *
   * would be the two-character key `":="`.  Line
   * terminator characters can be included using `\r` and
   * `\n` escape sequences.  Any white space after the
   * key is skipped; if the first non-white space character after
   * the key is `'='` or `':'`, then it is
   * ignored and any white space characters after it are also
   * skipped.  All remaining characters on the line become part of
   * the associated element string; if there are no remaining
   * characters, the element is the empty string
   * `""`.  Once the raw character sequences
   * constituting the key and element are identified, escape
   * processing is performed as described above.
   *
   * 
   * As an example, each of the following three lines specifies the key
   * `"Truth"` and the associated element value
   * `"Beauty"`:
   *      * Truth = Beauty
   *  Truth:Beauty
   * Truth                    :Beauty
   * 
   * As another example, the following three lines specify a single
   * property:
   *      * fruits                           apple, banana, pear, \
   *                                  cantaloupe, watermelon, \
   *                                  kiwi, mango
   * 
   * The key is `"fruits"` and the associated element is:
   * "apple, banana, pear, cantaloupe, watermelon, kiwi, mango"
   * Note that a space appears before each `\` so that a space
   * will appear after each comma in the final result; the `\`,
   * line terminator, and leading white space on the continuation line are
   * merely discarded and are not replaced by one or more other
   * characters.
   * 
   * As a third example, the line:
   * cheeses
   * 
   * specifies that the key is `"cheeses"` and the associated
   * element is the empty string `""`.
   * 
   * 
   * Characters in keys and elements can be represented in escape
   * sequences similar to those used for character and string literals
   * (see sections {@jls 3.3} and {@jls 3.10.6} of
   * The Java Language Specification).
   *
   * The differences from the character escape sequences and Unicode
   * escapes used for characters and strings are:
   *
   * 
   *  Octal escapes are not recognized.
   *
   *  The character sequence `\b` does not
   * represent a backspace character.
   *
   *  The method does not treat a backslash character,
   * `\`, before a non-valid escape character as an
   * error; the backslash is silently dropped.  For example, in a
   * Java string the sequence `"\z"` would cause a
   * compile time error.  In contrast, this method silently drops
   * the backslash.  Therefore, this method treats the two character
   * sequence `"\b"` as equivalent to the single
   * character `'b'`.
   *
   *  Escapes are not necessary for single and double quotes;
   * however, by the rule above, single and double quote characters
   * preceded by a backslash still yield single and double quote
   * characters, respectively.
   *
   *  Only a single 'u' character is allowed in a Unicode escape
   * sequence.
   *
   * 
   * 
   * The specified stream remains open after this method returns.
   *
   * @param   reader   the input character stream.
   * @throws  IOException  if an error occurred when reading from the
   *          input stream.
   * @throws  IllegalArgumentException if a malformed Unicode escape
   *          appears in the input.
   * @throws  NullPointerException if `reader` is null.
   * @since   1.6
  */
  load(reader: Reader): void;
  /**
   * Reads a property list (key and element pairs) from the input
   * byte stream. The input stream is in a simple line-oriented
   * format as specified in
   * {@link #load(java.io.Reader) load(Reader)} and is assumed to use
   * the ISO 8859-1 character encoding; that is each byte is one Latin1
   * character. Characters not in Latin1, and certain special characters,
   * are represented in keys and elements using Unicode escapes as defined in
   * section {@jls 3.3} of
   * The Java Language Specification.
   * 
   * The specified stream remains open after this method returns.
   *
   * @param      inStream   the input stream.
   * @throws     IOException  if an error occurred when reading from the
   *             input stream.
   * @throws     IllegalArgumentException if the input stream contains a
   *             malformed Unicode escape sequence.
   * @throws     NullPointerException if `inStream` is null.
   * @since 1.2
  */
  load(inStream: InputStream): void;
  /**
   * Calls the `store(OutputStream out, String comments)` method
   * and suppresses IOExceptions that were thrown.
   *
   * @deprecated This method does not throw an IOException if an I/O error
   * occurs while saving the property list.  The preferred way to save a
   * properties list is via the {@code store(OutputStream out,
   * String comments)} method or the
   * `storeToXML(OutputStream os, String comment)` method.
   *
   * @param   out      an output stream.
   * @param   comments   a description of the property list.
   * @throws     ClassCastException  if this `Properties` object
   *             contains any keys or values that are not
   *             `Strings`.
  */
  save(out: OutputStream, comments: string): void;
  /**
   * Writes this property list (key and element pairs) in this
   * `Properties` table to the output character stream in a
   * format suitable for using the {@link #load(java.io.Reader) load(Reader)}
   * method.
   * 
   * Properties from the defaults table of this `Properties`
   * table (if any) are not written out by this method.
   * 
   * If the comments argument is not null, then an ASCII `#`
   * character, the comments string, and a line separator are first written
   * to the output stream. Thus, the `comments` can serve as an
   * identifying comment. Any one of a line feed ('\n'), a carriage
   * return ('\r'), or a carriage return followed immediately by a line feed
   * in comments is replaced by a line separator generated by the `Writer`
   * and if the next character in comments is not character `#` or
   * character `!` then an ASCII `#` is written out
   * after that line separator.
   * 
   * Next, a comment line is always written, consisting of an ASCII
   * `#` character, the current date and time (as if produced
   * by the `toString` method of `Date` for the
   * current time), and a line separator as generated by the `Writer`.
   * 
   * Then every entry in this `Properties` table is
   * written out, one per line. For each entry the key string is
   * written, then an ASCII `=`, then the associated
   * element string. For the key, all space characters are
   * written with a preceding `\` character.  For the
   * element, leading space characters, but not embedded or trailing
   * space characters, are written with a preceding `\`
   * character. The key and element characters `#`,
   * `!`, `=`, and `:` are written
   * with a preceding backslash to ensure that they are properly loaded.
   * 
   * After the entries have been written, the output stream is flushed.
   * The output stream remains open after this method returns.
   *
   * @param   writer      an output character stream writer.
   * @param   comments   a description of the property list.
   * @throws     IOException if writing this property list to the specified
   *             output stream throws an `IOException`.
   * @throws     ClassCastException  if this `Properties` object
   *             contains any keys or values that are not `Strings`.
   * @throws     NullPointerException  if `writer` is null.
   * @since 1.6
  */
  store(writer: Writer, comments: string): void;
  /**
   * Writes this property list (key and element pairs) in this
   * `Properties` table to the output stream in a format suitable
   * for loading into a `Properties` table using the
   * {@link #load(InputStream) load(InputStream)} method.
   * 
   * Properties from the defaults table of this `Properties`
   * table (if any) are not written out by this method.
   * 
   * This method outputs the comments, properties keys and values in
   * the same format as specified in
   * {@link #store(java.io.Writer, java.lang.String) store(Writer)},
   * with the following differences:
   * 
   * The stream is written using the ISO 8859-1 character encoding.
   *
   * Characters not in Latin-1 in the comments are written as
   * `\u005Cu`xxxx for their appropriate unicode
   * hexadecimal value xxxx.
   *
   * Characters less than `\u005Cu0020` and characters greater
   * than `\u005Cu007E` in property keys or values are written
   * as `\u005Cu`xxxx for the appropriate hexadecimal
   * value xxxx.
   * 
   * 
   * After the entries have been written, the output stream is flushed.
   * The output stream remains open after this method returns.
   *
   * @param   out      an output stream.
   * @param   comments   a description of the property list.
   * @throws     IOException if writing this property list to the specified
   *             output stream throws an `IOException`.
   * @throws     ClassCastException  if this `Properties` object
   *             contains any keys or values that are not `Strings`.
   * @throws     NullPointerException  if `out` is null.
   * @since 1.2
  */
  store(out: OutputStream, comments: string): void;
  /**
   * Loads all of the properties represented by the XML document on the
   * specified input stream into this properties table.
   *
   * The XML document must have the following DOCTYPE declaration:
   *      * <!DOCTYPE properties SYSTEM "http://java.sun.com/dtd/properties.dtd">
   * 
   * Furthermore, the document must satisfy the properties DTD described
   * above.
   *
   *  An implementation is required to read XML documents that use the
   * "`UTF-8`" or "`UTF-16`" encoding. An implementation may
   * support additional encodings.
   *
   * The specified stream is closed after this method returns.
   *
   * @param in the input stream from which to read the XML document.
   * @throws IOException if reading from the specified input stream
   *         results in an `IOException`.
   * @throws java.io.UnsupportedEncodingException if the document's encoding
   *         declaration can be read and it specifies an encoding that is not
   *         supported
   * @throws InvalidPropertiesFormatException Data on input stream does not
   *         constitute a valid XML document with the mandated document type.
   * @throws NullPointerException if `in` is null.
   * @see    #storeToXML(OutputStream, String, String)
   * @see    Character
   *         Encoding in Entities
   * @since 1.5
  */
  loadFromXML(in_: InputStream): void;
  /**
   * Emits an XML document representing all of the properties contained
   * in this table.
   *
   *  An invocation of this method of the form {@code props.storeToXML(os,
   * comment)} behaves in exactly the same way as the invocation
   * `props.storeToXML(os, comment, "UTF-8");`.
   *
   * @param os the output stream on which to emit the XML document.
   * @param comment a description of the property list, or `null`
   *        if no comment is desired.
   * @throws IOException if writing to the specified output stream
   *         results in an `IOException`.
   * @throws NullPointerException if `os` is null.
   * @throws ClassCastException  if this `Properties` object
   *         contains any keys or values that are not
   *         `Strings`.
   * @see    #loadFromXML(InputStream)
   * @since 1.5
  */
  storeToXML(os: OutputStream, comment: string): void;
  /**
   * Emits an XML document representing all of the properties contained
   * in this table, using the specified encoding.
   *
   * The XML document will have the following DOCTYPE declaration:
   *      * <!DOCTYPE properties SYSTEM "http://java.sun.com/dtd/properties.dtd">
   * 
   *
   * If the specified comment is `null` then no comment
   * will be stored in the document.
   *
   *  An implementation is required to support writing of XML documents
   * that use the "`UTF-8`" or "`UTF-16`" encoding. An
   * implementation may support additional encodings.
   *
   * The specified stream remains open after this method returns.
   *
   * This method behaves the same as
   * {@linkplain #storeToXML(OutputStream os, String comment, Charset charset)}
   * except that it will {@linkplain java.nio.charset.Charset#forName look up the charset}
   * using the given encoding name.
   *
   * @param os        the output stream on which to emit the XML document.
   * @param comment   a description of the property list, or `null`
   *                  if no comment is desired.
   * @param  encoding the name of a supported
   *                  
   *                  character encoding
   *
   * @throws IOException if writing to the specified output stream
   *         results in an `IOException`.
   * @throws java.io.UnsupportedEncodingException if the encoding is not
   *         supported by the implementation.
   * @throws NullPointerException if `os` is `null`,
   *         or if `encoding` is `null`.
   * @throws ClassCastException  if this `Properties` object
   *         contains any keys or values that are not `Strings`.
   * @see    #loadFromXML(InputStream)
   * @see    Character
   *         Encoding in Entities
   * @since 1.5
  */
  storeToXML(os: OutputStream, comment: string, encoding: string): void;
  /**
   * Emits an XML document representing all of the properties contained
   * in this table, using the specified encoding.
   *
   * The XML document will have the following DOCTYPE declaration:
   *      * <!DOCTYPE properties SYSTEM "http://java.sun.com/dtd/properties.dtd">
   * 
   *
   * If the specified comment is `null` then no comment
   * will be stored in the document.
   *
   *  An implementation is required to support writing of XML documents
   * that use the "`UTF-8`" or "`UTF-16`" encoding. An
   * implementation may support additional encodings.
   *
   *  Unmappable characters for the specified charset will be encoded as
   * numeric character references.
   *
   * The specified stream remains open after this method returns.
   *
   * @param os        the output stream on which to emit the XML document.
   * @param comment   a description of the property list, or `null`
   *                  if no comment is desired.
   * @param charset   the charset
   *
   * @throws IOException if writing to the specified output stream
   *         results in an `IOException`.
   * @throws NullPointerException if `os` or `charset` is `null`.
   * @throws ClassCastException  if this `Properties` object
   *         contains any keys or values that are not `Strings`.
   * @see    #loadFromXML(InputStream)
   * @see    Character
   *         Encoding in Entities
   * @since 10
  */
  storeToXML(os: OutputStream, comment: string, charset: Charset): void;
  /**
   * Searches for the property with the specified key in this property list.
   * If the key is not found in this property list, the default property list,
   * and its defaults, recursively, are then checked. The method returns
   * `null` if the property is not found.
   *
   * @param   key   the property key.
   * @return  the value in this property list with the specified key value.
   * @see     #setProperty
   * @see     #defaults
  */
  getProperty(key: string): string;
  /**
   * Searches for the property with the specified key in this property list.
   * If the key is not found in this property list, the default property list,
   * and its defaults, recursively, are then checked. The method returns the
   * default value argument if the property is not found.
   *
   * @param   key            the hashtable key.
   * @param   defaultValue   a default value.
   *
   * @return  the value in this property list with the specified key value.
   * @see     #setProperty
   * @see     #defaults
  */
  getProperty(key: string, defaultValue: string): string;
  /**
   * Returns an enumeration of all the keys in this property list,
   * including distinct keys in the default property list if a key
   * of the same name has not already been found from the main
   * properties list.
   *
   * @return  an enumeration of all the keys in this property list, including
   *          the keys in the default property list.
   * @throws  ClassCastException if any key in this property list
   *          is not a string.
   * @see     java.util.Enumeration
   * @see     java.util.Properties#defaults
   * @see     #stringPropertyNames
  */
  propertyNames(): Enumeration<any>;
  /**
   * Returns an unmodifiable set of keys from this property list
   * where the key and its corresponding value are strings,
   * including distinct keys in the default property list if a key
   * of the same name has not already been found from the main
   * properties list.  Properties whose key or value is not
   * of type `String` are omitted.
   * 
   * The returned set is not backed by this `Properties` object.
   * Changes to this `Properties` object are not reflected in the
   * returned set.
   *
   * @return  an unmodifiable set of keys in this property list where
   *          the key and its corresponding value are strings,
   *          including the keys in the default property list.
   * @see     java.util.Properties#defaults
   * @since   1.6
  */
  stringPropertyNames(): Set<string>;
  /**
   * Prints this property list out to the specified output stream.
   * This method is useful for debugging.
   *
   * @param   out   an output stream.
   * @throws  ClassCastException if any key in this property list
   *          is not a string.
  */
  list(out: PrintStream): void;
  list(out: PrintWriter): void;
  size(): number;
  isEmpty(): boolean;
  keys(): Enumeration<any>;
  elements(): Enumeration<any>;
  contains(value: any): boolean;
  containsValue(value: any): boolean;
  containsKey(key: any): boolean;
  get(key: any): any;
  put(key: any, value: any): any;
  remove(key: any): any;
  putAll(t: Map<any, any>): void;
  clear(): void;
  toString(): string;
  keySet(): Set<any>;
  values(): Collection<any>;
  entrySet(): Set<java_util_Map_Entry<any, any>>;
  equals(o: any): boolean;
  hashCode(): number;
  getOrDefault(key: any, defaultValue: any): any;
  forEach(action: BiConsumer<any, any>): void;
  replaceAll(func: BiFunction<any, any, any>): void;
  putIfAbsent(key: any, value: any): any;
  remove(key: any, value: any): boolean;
  replace(key: any, oldValue: any, newValue: any): boolean;
  replace(key: any, value: any): any;
  computeIfAbsent(key: any, mappingFunction: Function<any, any>): any;
  computeIfPresent(key: any, remappingFunction: BiFunction<any, any, any>): any;
  compute(key: any, remappingFunction: BiFunction<any, any, any>): any;
  merge(key: any, value: any, remappingFunction: BiFunction<any, any, any>): any;
  clone(): any;
  /**
   * Maps the specified `key` to the specified
   * `value` in this hashtable. Neither the key nor the
   * value can be `null`. 
   *
   * The value can be retrieved by calling the `get` method
   * with a key that is equal to the original key.
   *
   * @param      key     the hashtable key
   * @param      value   the value
   * @return     the previous value of the specified key in this hashtable,
   *             or `null` if it did not have one
   * @throws     NullPointerException  if the key or value is
   *               `null`
   * @see     Object#equals(Object)
   * @see     #get(Object)
  */
  put(key: K, value: V): V;
  getOrDefault(key: any, defaultValue: V): V;
  putIfAbsent(key: K, value: V): V;
  replace(key: K, oldValue: V, newValue: V): boolean;
  replace(key: K, value: V): V;
  /**
   * {@inheritDoc}
   *
   * This method will, on a best-effort basis, throw a
   * {@link java.util.ConcurrentModificationException} if the mapping
   * function modified this map during computation.
   *
   * @throws ConcurrentModificationException if it is detected that the
   * mapping function modified this map
  */
  computeIfAbsent(key: K, mappingFunction: Function<any, V>): V;
  /**
   * {@inheritDoc}
   *
   * This method will, on a best-effort basis, throw a
   * {@link java.util.ConcurrentModificationException} if the remapping
   * function modified this map during computation.
   *
   * @throws ConcurrentModificationException if it is detected that the
   * remapping function modified this map
  */
  computeIfPresent(key: K, remappingFunction: BiFunction<any, any, V>): V;
  /**
   * {@inheritDoc}
   *
   * This method will, on a best-effort basis, throw a
   * {@link java.util.ConcurrentModificationException} if the remapping
   * function modified this map during computation.
   *
   * @throws ConcurrentModificationException if it is detected that the
   * remapping function modified this map
  */
  compute(key: K, remappingFunction: BiFunction<any, any, V>): V;
  /**
   * {@inheritDoc}
   *
   * This method will, on a best-effort basis, throw a
   * {@link java.util.ConcurrentModificationException} if the remapping
   * function modified this map during computation.
   *
   * @throws ConcurrentModificationException if it is detected that the
   * remapping function modified this map
  */
  merge(key: K, value: V, remappingFunction: BiFunction<any, any, V>): V;
}
/**
 * Thrown by methods in {@link Locale} and {@link Locale.Builder} to
 * indicate that an argument is not a well-formed BCP 47 tag.
 *
 * @see Locale
 * @since 1.7
*/
export class IllformedLocaleException extends RuntimeException {
  /**
   * Constructs a new `IllformedLocaleException` with no
   * detail message and -1 as the error index.
  */
  constructor();
  /**
   * Constructs a new `IllformedLocaleException` with the
   * given message and -1 as the error index.
   *
   * @param message the message
  */
  constructor(message: string);
  /**
   * Constructs a new `IllformedLocaleException` with the
   * given message and the error index.  The error index is the approximate
   * offset from the start of the ill-formed value to the point where the
   * parse first detected an error.  A negative error index value indicates
   * either the error index is not applicable or unknown.
   *
   * @param message the message
   * @param errorIndex the index
  */
  constructor(message: string, errorIndex: number);
  /**
   * Returns the index where the error was found. A negative value indicates
   * either the error index is not applicable or unknown.
   *
   * @return the error index
  */
  getErrorIndex(): number;
}
/**
 * Resizable-array implementation of the {@link Deque} interface.  Array
 * deques have no capacity restrictions; they grow as necessary to support
 * usage.  They are not thread-safe; in the absence of external
 * synchronization, they do not support concurrent access by multiple threads.
 * Null elements are prohibited.  This class is likely to be faster than
 * {@link Stack} when used as a stack, and faster than {@link LinkedList}
 * when used as a queue.
 *
 * Most `ArrayDeque` operations run in amortized constant time.
 * Exceptions include
 * {@link #remove(Object) remove},
 * {@link #removeFirstOccurrence removeFirstOccurrence},
 * {@link #removeLastOccurrence removeLastOccurrence},
 * {@link #contains contains},
 * {@link #iterator iterator.remove()},
 * and the bulk operations, all of which run in linear time.
 *
 * The iterators returned by this class's {@link #iterator() iterator}
 * method are fail-fast: If the deque is modified at any time after
 * the iterator is created, in any way except through the iterator's own
 * `remove` method, the iterator will generally throw a {@link
 * ConcurrentModificationException}.  Thus, in the face of concurrent
 * modification, the iterator fails quickly and cleanly, rather than risking
 * arbitrary, non-deterministic behavior at an undetermined time in the
 * future.
 *
 * Note that the fail-fast behavior of an iterator cannot be guaranteed
 * as it is, generally speaking, impossible to make any hard guarantees in the
 * presence of unsynchronized concurrent modification.  Fail-fast iterators
 * throw `ConcurrentModificationException` on a best-effort basis.
 * Therefore, it would be wrong to write a program that depended on this
 * exception for its correctness: the fail-fast behavior of iterators
 * should be used only to detect bugs.
 *
 * This class and its iterator implement all of the
 * optional methods of the {@link Collection} and {@link
 * Iterator} interfaces.
 *
 * This class is a member of the
 * 
 * Java Collections Framework.
 *
 * @author  Josh Bloch and Doug Lea
 * @param  the type of elements held in this deque
 * @since   1.6
*/
export class ArrayDeque<E> extends AbstractCollection<E> {
  /**
   * Constructs an empty array deque with an initial capacity
   * sufficient to hold 16 elements.
  */
  constructor();
  /**
   * Constructs an empty array deque with an initial capacity
   * sufficient to hold the specified number of elements.
   *
   * @param numElements lower bound on initial capacity of the deque
  */
  constructor(numElements: number);
  /**
   * Constructs a deque containing the elements of the specified
   * collection, in the order they are returned by the collection's
   * iterator.  (The first element returned by the collection's
   * iterator becomes the first element, or front of the
   * deque.)
   *
   * @param c the collection whose elements are to be placed into the deque
   * @throws NullPointerException if the specified collection is null
  */
  constructor(c: Collection<E>);
  /**
   * Inserts the specified element at the front of this deque.
   *
   * @param e the element to add
   * @throws NullPointerException if the specified element is null
  */
  addFirst(e: E): void;
  /**
   * Inserts the specified element at the end of this deque.
   *
   * This method is equivalent to {@link #add}.
   *
   * @param e the element to add
   * @throws NullPointerException if the specified element is null
  */
  addLast(e: E): void;
  /**
   * Adds all of the elements in the specified collection at the end
   * of this deque, as if by calling {@link #addLast} on each one,
   * in the order that they are returned by the collection's iterator.
   *
   * @param c the elements to be inserted into this deque
   * @return `true` if this deque changed as a result of the call
   * @throws NullPointerException if the specified collection or any
   *         of its elements are null
  */
  addAll(c: Collection<E>): boolean;
  /**
   * Inserts the specified element at the front of this deque.
   *
   * @param e the element to add
   * @return `true` (as specified by {@link Deque#offerFirst})
   * @throws NullPointerException if the specified element is null
  */
  offerFirst(e: E): boolean;
  /**
   * Inserts the specified element at the end of this deque.
   *
   * @param e the element to add
   * @return `true` (as specified by {@link Deque#offerLast})
   * @throws NullPointerException if the specified element is null
  */
  offerLast(e: E): boolean;
  /**
   * @throws NoSuchElementException {@inheritDoc}
  */
  removeFirst(): E;
  /**
   * @throws NoSuchElementException {@inheritDoc}
  */
  removeLast(): E;
  pollFirst(): E;
  pollLast(): E;
  /**
   * @throws NoSuchElementException {@inheritDoc}
  */
  getFirst(): E;
  /**
   * @throws NoSuchElementException {@inheritDoc}
  */
  getLast(): E;
  peekFirst(): E;
  peekLast(): E;
  /**
   * Removes the first occurrence of the specified element in this
   * deque (when traversing the deque from head to tail).
   * If the deque does not contain the element, it is unchanged.
   * More formally, removes the first element `e` such that
   * `o.equals(e)` (if such an element exists).
   * Returns `true` if this deque contained the specified element
   * (or equivalently, if this deque changed as a result of the call).
   *
   * @param o element to be removed from this deque, if present
   * @return `true` if the deque contained the specified element
  */
  removeFirstOccurrence(o: any): boolean;
  /**
   * Removes the last occurrence of the specified element in this
   * deque (when traversing the deque from head to tail).
   * If the deque does not contain the element, it is unchanged.
   * More formally, removes the last element `e` such that
   * `o.equals(e)` (if such an element exists).
   * Returns `true` if this deque contained the specified element
   * (or equivalently, if this deque changed as a result of the call).
   *
   * @param o element to be removed from this deque, if present
   * @return `true` if the deque contained the specified element
  */
  removeLastOccurrence(o: any): boolean;
  /**
   * Inserts the specified element at the end of this deque.
   *
   * This method is equivalent to {@link #addLast}.
   *
   * @param e the element to add
   * @return `true` (as specified by {@link Collection#add})
   * @throws NullPointerException if the specified element is null
  */
  add(e: E): boolean;
  /**
   * Inserts the specified element at the end of this deque.
   *
   * This method is equivalent to {@link #offerLast}.
   *
   * @param e the element to add
   * @return `true` (as specified by {@link Queue#offer})
   * @throws NullPointerException if the specified element is null
  */
  offer(e: E): boolean;
  /**
   * Retrieves and removes the head of the queue represented by this deque.
   *
   * This method differs from {@link #poll() poll()} only in that it
   * throws an exception if this deque is empty.
   *
   * This method is equivalent to {@link #removeFirst}.
   *
   * @return the head of the queue represented by this deque
   * @throws NoSuchElementException {@inheritDoc}
  */
  remove(): E;
  /**
   * Retrieves and removes the head of the queue represented by this deque
   * (in other words, the first element of this deque), or returns
   * `null` if this deque is empty.
   *
   * This method is equivalent to {@link #pollFirst}.
   *
   * @return the head of the queue represented by this deque, or
   *         `null` if this deque is empty
  */
  poll(): E;
  /**
   * Retrieves, but does not remove, the head of the queue represented by
   * this deque.  This method differs from {@link #peek peek} only in
   * that it throws an exception if this deque is empty.
   *
   * This method is equivalent to {@link #getFirst}.
   *
   * @return the head of the queue represented by this deque
   * @throws NoSuchElementException {@inheritDoc}
  */
  element(): E;
  /**
   * Retrieves, but does not remove, the head of the queue represented by
   * this deque, or returns `null` if this deque is empty.
   *
   * This method is equivalent to {@link #peekFirst}.
   *
   * @return the head of the queue represented by this deque, or
   *         `null` if this deque is empty
  */
  peek(): E;
  /**
   * Pushes an element onto the stack represented by this deque.  In other
   * words, inserts the element at the front of this deque.
   *
   * This method is equivalent to {@link #addFirst}.
   *
   * @param e the element to push
   * @throws NullPointerException if the specified element is null
  */
  push(e: E): void;
  /**
   * Pops an element from the stack represented by this deque.  In other
   * words, removes and returns the first element of this deque.
   *
   * This method is equivalent to {@link #removeFirst()}.
   *
   * @return the element at the front of this deque (which is the top
   *         of the stack represented by this deque)
   * @throws NoSuchElementException {@inheritDoc}
  */
  pop(): E;
  /**
   * Returns the number of elements in this deque.
   *
   * @return the number of elements in this deque
  */
  size(): number;
  /**
   * Returns `true` if this deque contains no elements.
   *
   * @return `true` if this deque contains no elements
  */
  isEmpty(): boolean;
  /**
   * Returns an iterator over the elements in this deque.  The elements
   * will be ordered from first (head) to last (tail).  This is the same
   * order that elements would be dequeued (via successive calls to
   * {@link #remove} or popped (via successive calls to {@link #pop}).
   *
   * @return an iterator over the elements in this deque
  */
  iterator(): Iterator<E>;
  descendingIterator(): Iterator<E>;
  /**
   * Creates a late-binding
   * and fail-fast {@link Spliterator} over the elements in this
   * deque.
   *
   * The `Spliterator` reports {@link Spliterator#SIZED},
   * {@link Spliterator#SUBSIZED}, {@link Spliterator#ORDERED}, and
   * {@link Spliterator#NONNULL}.  Overriding implementations should document
   * the reporting of additional characteristic values.
   *
   * @return a `Spliterator` over the elements in this deque
   * @since 1.8
  */
  spliterator(): Spliterator<E>;
  /**
   * @throws NullPointerException {@inheritDoc}
  */
  forEach(action: Consumer<any>): void;
  /**
   * @throws NullPointerException {@inheritDoc}
  */
  removeIf(filter: Predicate<any>): boolean;
  /**
   * @throws NullPointerException {@inheritDoc}
  */
  removeAll(c: Collection<any>): boolean;
  /**
   * @throws NullPointerException {@inheritDoc}
  */
  retainAll(c: Collection<any>): boolean;
  /**
   * Returns `true` if this deque contains the specified element.
   * More formally, returns `true` if and only if this deque contains
   * at least one element `e` such that `o.equals(e)`.
   *
   * @param o object to be checked for containment in this deque
   * @return `true` if this deque contains the specified element
  */
  contains(o: any): boolean;
  /**
   * Removes a single instance of the specified element from this deque.
   * If the deque does not contain the element, it is unchanged.
   * More formally, removes the first element `e` such that
   * `o.equals(e)` (if such an element exists).
   * Returns `true` if this deque contained the specified element
   * (or equivalently, if this deque changed as a result of the call).
   *
   * This method is equivalent to {@link #removeFirstOccurrence(Object)}.
   *
   * @param o element to be removed from this deque, if present
   * @return `true` if this deque contained the specified element
  */
  remove(o: any): boolean;
  /**
   * Removes all of the elements from this deque.
   * The deque will be empty after this call returns.
  */
  clear(): void;
  /**
   * Returns an array containing all of the elements in this deque
   * in proper sequence (from first to last element).
   *
   * The returned array will be "safe" in that no references to it are
   * maintained by this deque.  (In other words, this method must allocate
   * a new array).  The caller is thus free to modify the returned array.
   *
   * This method acts as bridge between array-based and collection-based
   * APIs.
   *
   * @return an array containing all of the elements in this deque
  */
  toArray(): any[];
  /**
   * Returns an array containing all of the elements in this deque in
   * proper sequence (from first to last element); the runtime type of the
   * returned array is that of the specified array.  If the deque fits in
   * the specified array, it is returned therein.  Otherwise, a new array
   * is allocated with the runtime type of the specified array and the
   * size of this deque.
   *
   * If this deque fits in the specified array with room to spare
   * (i.e., the array has more elements than this deque), the element in
   * the array immediately following the end of the deque is set to
   * `null`.
   *
   * Like the {@link #toArray()} method, this method acts as bridge between
   * array-based and collection-based APIs.  Further, this method allows
   * precise control over the runtime type of the output array, and may,
   * under certain circumstances, be used to save allocation costs.
   *
   * Suppose `x` is a deque known to contain only strings.
   * The following code can be used to dump the deque into a newly
   * allocated array of `String`:
   *
   *  `String[] y = x.toArray(new String[0]);`
   *
   * Note that `toArray(new Object[0])` is identical in function to
   * `toArray()`.
   *
   * @param a the array into which the elements of the deque are to
   *          be stored, if it is big enough; otherwise, a new array of the
   *          same runtime type is allocated for this purpose
   * @return an array containing all of the elements in this deque
   * @throws ArrayStoreException if the runtime type of the specified array
   *         is not a supertype of the runtime type of every element in
   *         this deque
   * @throws NullPointerException if the specified array is null
  */
  toArray<T>(a: T[]): T[];
  /**
   * Returns a copy of this deque.
   *
   * @return a copy of this deque
  */
  clone(): ArrayDeque<E>;
  /**
   * Returns an array containing all of the elements in this collection,
   * using the provided `generator` function to allocate the returned array.
   *
   * If this collection makes any guarantees as to what order its elements
   * are returned by its iterator, this method must return the elements in
   * the same order.
   *
   * @apiNote
   * This method acts as a bridge between array-based and collection-based APIs.
   * It allows creation of an array of a particular runtime type. Use
   * {@link #toArray()} to create an array whose runtime type is `Object[]`,
   * or use {@link #toArray(Object[]) toArray(T[])} to reuse an existing array.
   *
   * Suppose `x` is a collection known to contain only strings.
   * The following code can be used to dump the collection into a newly
   * allocated array of `String`:
   *
   *      *     String[] y = x.toArray(String[]::new);
   *
   * @implSpec
   * The default implementation calls the generator function with zero
   * and then passes the resulting array to {@link #toArray(Object[]) toArray(T[])}.
   *
   * @param  the component type of the array to contain the collection
   * @param generator a function which produces a new array of the desired
   *                  type and the provided length
   * @return an array containing all of the elements in this collection
   * @throws ArrayStoreException if the runtime type of any element in this
   *         collection is not assignable to the {@linkplain Class#getComponentType
   *         runtime component type} of the generated array
   * @throws NullPointerException if the generator function is null
   * @since 11
  */
  toArray<T>(generator: IntFunction<T[]>): T[];
}
export interface ArrayDeque<E> extends AbstractCollection<E>, Deque<E>, Cloneable, Serializable {}
export class PropertyPermission extends BasicPermission {
  /**
   * Creates a new PropertyPermission object with the specified name.
   * The name is the name of the system property, and
   * actions contains a comma-separated list of the
   * desired actions granted on the property. Possible actions are
   * "read" and "write".
   *
   * @param name the name of the PropertyPermission.
   * @param actions the actions string.
   *
   * @throws NullPointerException if `name` is `null`.
   * @throws IllegalArgumentException if `name` is empty or if
   * `actions` is invalid.
  */
  constructor(name: string, actions: string);
  /**
   * Checks if this PropertyPermission object "implies" the specified
   * permission.
   * 
   * More specifically, this method returns true if:
   * 
   *  p is an instanceof PropertyPermission,
   *  p's actions are a subset of this
   * object's actions, and
   *  p's name is implied by this object's
   *      name. For example, "java.*" implies "java.home".
   * 
   * @param p the permission to check against.
   *
   * @return true if the specified permission is implied by this object,
   * false if not.
  */
  implies(p: Permission): boolean;
  /**
   * Checks two PropertyPermission objects for equality. Checks that obj is
   * a PropertyPermission, and has the same name and actions as this object.
   *
   * @param obj the object we are testing for equality with this object.
   * @return true if obj is a PropertyPermission, and has the same name and
   * actions as this PropertyPermission object.
  */
  equals(obj: any): boolean;
  /**
   * Returns the hash code value for this object.
   * The hash code used is the hash code of this permissions name, that is,
   * `getName().hashCode()`, where `getName` is
   * from the Permission superclass.
   *
   * @return a hash code value for this object.
  */
  hashCode(): number;
  /**
   * Returns the "canonical string representation" of the actions.
   * That is, this method always returns present actions in the following order:
   * read, write. For example, if this PropertyPermission object
   * allows both write and read actions, a call to `getActions`
   * will return the string "read,write".
   *
   * @return the canonical string representation of the actions.
  */
  getActions(): string;
  /**
   * Returns a new PermissionCollection object for storing
   * PropertyPermission objects.
   *
   * @return a new PermissionCollection object suitable for storing
   * PropertyPermissions.
  */
  newPermissionCollection(): PermissionCollection;
}
/**
 * An interpreter for printf-style format strings.  This class provides support
 * for layout justification and alignment, common formats for numeric, string,
 * and date/time data, and locale-specific output.  Common Java types such as
 * `byte`, {@link java.math.BigDecimal BigDecimal}, and {@link Calendar}
 * are supported.  Limited formatting customization for arbitrary user types is
 * provided through the {@link Formattable} interface.
 *
 *  Formatters are not necessarily safe for multithreaded access.  Thread
 * safety is optional and is the responsibility of users of methods in this
 * class.
 *
 *  Formatted printing for the Java language is heavily inspired by C's
 * `printf`.  Although the format strings are similar to C, some
 * customizations have been made to accommodate the Java language and exploit
 * some of its features.  Also, Java formatting is more strict than C's; for
 * example, if a conversion is incompatible with a flag, an exception will be
 * thrown.  In C inapplicable flags are silently ignored.  The format strings
 * are thus intended to be recognizable to C programmers but not necessarily
 * completely compatible with those in C.
 *
 *  Examples of expected usage:
 *
 *  *   StringBuilder sb = new StringBuilder();
 *   // Send all output to the Appendable object sb
 *   Formatter formatter = new Formatter(sb, Locale.US);
 *
 *   // Explicit argument indices may be used to re-order output.
 *   formatter.format("%4$2s %3$2s %2$2s %1$2s", "a", "b", "c", "d")
 *   // -> " d  c  b  a"
 *
 *   // Optional locale as the first argument can be used to get
 *   // locale-specific formatting of numbers.  The precision and width can be
 *   // given to round and align the value.
 *   formatter.format(Locale.FRANCE, "e = %+10.4f", Math.E);
 *   // -> "e =    +2,7183"
 *
 *   // The '(' numeric flag may be used to format negative numbers with
 *   // parentheses rather than a minus sign.  Group separators are
 *   // automatically inserted.
 *   formatter.format("Amount gained or lost since last statement: $ %(,.2f",
 *                    balanceDelta);
 *   // -> "Amount gained or lost since last statement: $ (6,217.58)"
 * 
 *
 *  Convenience methods for common formatting requests exist as illustrated
 * by the following invocations:
 *
 *  *   // Writes a formatted string to System.out.
 *   System.out.format("Local time: %tT", Calendar.getInstance());
 *   // -> "Local time: 13:34:18"
 *
 *   // Writes formatted output to System.err.
 *   System.err.printf("Unable to open file '%1$s': %2$s",
 *                     fileName, exception.getMessage());
 *   // -> "Unable to open file 'food': No such file or directory"
 * 
 *
 *  Like C's `sprintf(3)`, Strings may be formatted using the static
 * method {@link String#format(String,Object...) String.format}:
 *
 *  *   // Format a string containing a date.
 *   import java.util.Calendar;
 *   import java.util.GregorianCalendar;
 *   import static java.util.Calendar.*;
 *
 *   Calendar c = new GregorianCalendar(1995, MAY, 23);
 *   String s = String.format("Duke's Birthday: %1$tb %1$te, %1$tY", c);
 *   // -> s == "Duke's Birthday: May 23, 1995"
 * 
 *
 * Organization
 *
 *  This specification is divided into two sections.  The first section, Summary, covers the basic formatting concepts.  This
 * section is intended for users who want to get started quickly and are
 * familiar with formatted printing in other programming languages.  The second
 * section, Details, covers the specific implementation
 * details.  It is intended for users who want more precise specification of
 * formatting behavior.
 *
 * Summary
 *
 *  This section is intended to provide a brief overview of formatting
 * concepts.  For precise behavioral details, refer to the Details section.
 *
 * Format String Syntax
 *
 *  Every method which produces formatted output requires a format
 * string and an argument list.  The format string is a {@link
 * String} which may contain fixed text and one or more embedded format
 * specifiers.  Consider the following example:
 *
 *  *   Calendar c = ...;
 *   String s = String.format("Duke's Birthday: %1$tm %1$te,%1$tY", c);
 * 
 *
 * This format string is the first argument to the `format` method.  It
 * contains three format specifiers "`%1$tm`", "`%1$te`", and
 * "`%1$tY`" which indicate how the arguments should be processed and
 * where they should be inserted in the text.  The remaining portions of the
 * format string are fixed text including `"Dukes Birthday: "` and any
 * other spaces or punctuation.
 *
 * The argument list consists of all arguments passed to the method after the
 * format string.  In the above example, the argument list is of size one and
 * consists of the {@link java.util.Calendar Calendar} object `c`.
 *
 * 
 *
 *  The format specifiers for general, character, and numeric types have
 * the following syntax:
 *
 *  *   %[argument_index$][flags][width][.precision]conversion
 * 
 *
 *  The optional argument_index is a decimal integer indicating the
 * position of the argument in the argument list.  The first argument is
 * referenced by "`1$`", the second by "`2$`", etc.
 *
 *  The optional flags is a set of characters that modify the output
 * format.  The set of valid flags depends on the conversion.
 *
 *  The optional width is a positive decimal integer indicating
 * the minimum number of characters to be written to the output.
 *
 *  The optional precision is a non-negative decimal integer usually
 * used to restrict the number of characters.  The specific behavior depends on
 * the conversion.
 *
 *  The required conversion is a character indicating how the
 * argument should be formatted.  The set of valid conversions for a given
 * argument depends on the argument's data type.
 *
 *  The format specifiers for types which are used to represents dates and
 * times have the following syntax:
 *
 *  *   %[argument_index$][flags][width]conversion
 * 
 *
 *  The optional argument_index, flags and width are
 * defined as above.
 *
 *  The required conversion is a two character sequence.  The first
 * character is `'t'` or `'T'`.  The second character indicates
 * the format to be used.  These characters are similar to but not completely
 * identical to those defined by GNU `date` and POSIX
 * `strftime(3c)`.
 *
 *  The format specifiers which do not correspond to arguments have the
 * following syntax:
 *
 *  *   %[flags][width]conversion
 * 
 *
 *  The optional flags and width is defined as above.
 *
 *  The required conversion is a character indicating content to be
 * inserted in the output.
 *
 * 
 *
 *  Conversions 
 *
 *  Conversions are divided into the following categories:
 *
 * 
 *
 *  General - may be applied to any argument
 * type
 *
 *  Character - may be applied to basic types which represent
 * Unicode characters: `char`, {@link Character}, `byte`, {@link
 * Byte}, `short`, and {@link Short}. This conversion may also be
 * applied to the types `int` and {@link Integer} when {@link
 * Character#isValidCodePoint} returns `true`
 *
 *  Numeric
 *
 * 
 *
 *  Integral - may be applied to Java integral types: `byte`,
 * {@link Byte}, `short`, {@link Short}, `int` and {@link
 * Integer}, `long`, {@link Long}, and {@link java.math.BigInteger
 * BigInteger} (but not `char` or {@link Character})
 *
 * Floating Point - may be applied to Java floating-point types:
 * `float`, {@link Float}, `double`, {@link Double}, and {@link
 * java.math.BigDecimal BigDecimal}
 *
 * 
 *
 *  Date/Time - may be applied to Java types which are capable of
 * encoding a date or time: `long`, {@link Long}, {@link Calendar},
 * {@link Date} and {@link TemporalAccessor TemporalAccessor}
 *
 *  Percent - produces a literal `'%'`
 * ('\u0025')
 *
 *  Line Separator - produces the platform-specific line separator
 *
 * 
 *
 *  For category General, Character, Numeric,
 * Integral and Date/Time conversion, unless otherwise specified,
 * if the argument arg is `null`, then the result is "`null`".
 *
 *  The following table summarizes the supported conversions.  Conversions
 * denoted by an upper-case character (i.e. `'B'`, `'H'`,
 * `'S'`, `'C'`, `'X'`, `'E'`, `'G'`,
 * `'A'`, and `'T'`) are the same as those for the corresponding
 * lower-case conversion characters except that the result is converted to
 * upper case according to the rules of the prevailing {@link java.util.Locale
 * Locale}. If there is no explicit locale specified, either at the
 * construction of the instance or as a parameter to its method
 * invocation, then the {@link java.util.Locale.Category#FORMAT default locale}
 * is used.
 *
 *
 * 
 * genConv
 * 
 *  Conversion
 *      Argument Category
 *      Description
 * 
 * 
 *  `'b'`, `'B'`
 *      general
 *      If the argument arg is `null`, then the result is
 *     "`false`".  If arg is a `boolean` or {@link
 *     Boolean}, then the result is the string returned by {@link
 *     String#valueOf(boolean) String.valueOf(arg)}.  Otherwise, the result is
 *     "true".
 *
 *  `'h'`, `'H'`
 *      general
 *      The result is obtained by invoking
 *     `Integer.toHexString(arg.hashCode())`.
 *
 *  `'s'`, `'S'`
 *      general
 *      If arg implements {@link Formattable}, then
 *     {@link Formattable#formatTo arg.formatTo} is invoked. Otherwise, the
 *     result is obtained by invoking `arg.toString()`.
 *
 * `'c'`, `'C'`
 *      character
 *      The result is a Unicode character
 *
 * `'d'`
 *      integral
 *      The result is formatted as a decimal integer
 *
 * `'o'`
 *      integral
 *      The result is formatted as an octal integer
 *
 * `'x'`, `'X'`
 *      integral
 *      The result is formatted as a hexadecimal integer
 *
 * `'e'`, `'E'`
 *      floating point
 *      The result is formatted as a decimal number in computerized
 *     scientific notation
 *
 * `'f'`
 *      floating point
 *      The result is formatted as a decimal number
 *
 * `'g'`, `'G'`
 *      floating point
 *      The result is formatted using computerized scientific notation or
 *     decimal format, depending on the precision and the value after rounding.
 *
 * `'a'`, `'A'`
 *      floating point
 *      The result is formatted as a hexadecimal floating-point number with
 *     a significand and an exponent. This conversion is not supported
 *     for the `BigDecimal` type despite the latter's being in the
 *     floating point argument category.
 *
 * `'t'`, `'T'`
 *      date/time
 *      Prefix for date and time conversion characters.  See Date/Time Conversions.
 *
 * `'%'`
 *      percent
 *      The result is a literal `'%'` ('\u0025')
 *
 * `'n'`
 *      line separator
 *      The result is the platform-specific line separator
 *
 * 
 * 
 *
 *  Any characters not explicitly defined as conversions are illegal and are
 * reserved for future extensions.
 *
 * Date/Time Conversions
 *
 *  The following date and time conversion suffix characters are defined for
 * the `'t'` and `'T'` conversions.  The types are similar to but
 * not completely identical to those defined by GNU `date` and POSIX
 * `strftime(3c)`.  Additional conversion types are provided to access
 * Java-specific functionality (e.g. `'L'` for milliseconds within the
 * second).
 *
 *  The following conversion characters are used for formatting times:
 *
 * 
 * time
 * 
 *  `'H'`
 *      Hour of the day for the 24-hour clock, formatted as two digits with
 *     a leading zero as necessary i.e. `00 - 23`.
 *
 * `'I'`
 *      Hour for the 12-hour clock, formatted as two digits with a leading
 *     zero as necessary, i.e.  `01 - 12`.
 *
 * `'k'`
 *      Hour of the day for the 24-hour clock, i.e. `0 - 23`.
 *
 * `'l'`
 *      Hour for the 12-hour clock, i.e. `1 - 12`.
 *
 * `'M'`
 *      Minute within the hour formatted as two digits with a leading zero
 *     as necessary, i.e.  `00 - 59`.
 *
 * `'S'`
 *      Seconds within the minute, formatted as two digits with a leading
 *     zero as necessary, i.e. `00 - 60` ("`60`" is a special
 *     value required to support leap seconds).
 *
 * `'L'`
 *      Millisecond within the second formatted as three digits with
 *     leading zeros as necessary, i.e. `000 - 999`.
 *
 * `'N'`
 *      Nanosecond within the second, formatted as nine digits with leading
 *     zeros as necessary, i.e. `000000000 - 999999999`.
 *
 * `'p'`
 *      Locale-specific {@linkplain
 *     java.text.DateFormatSymbols#getAmPmStrings morning or afternoon} marker
 *     in lower case, e.g."`am`" or "`pm`". Use of the conversion
 *     prefix `'T'` forces this output to upper case.
 *
 * `'z'`
 *      RFC 822
 *     style numeric time zone offset from GMT, e.g. `-0800`.  This
 *     value will be adjusted as necessary for Daylight Saving Time.  For
 *     `long`, {@link Long}, and {@link Date} the time zone used is
 *     the {@linkplain TimeZone#getDefault() default time zone} for this
 *     instance of the Java virtual machine.
 *
 * `'Z'`
 *      A string representing the abbreviation for the time zone.  This
 *     value will be adjusted as necessary for Daylight Saving Time.  For
 *     `long`, {@link Long}, and {@link Date} the  time zone used is
 *     the {@linkplain TimeZone#getDefault() default time zone} for this
 *     instance of the Java virtual machine.  The Formatter's locale will
 *     supersede the locale of the argument (if any).
 *
 * `'s'`
 *      Seconds since the beginning of the epoch starting at 1 January 1970
 *     `00:00:00` UTC, i.e. `Long.MIN_VALUE/1000` to
 *     `Long.MAX_VALUE/1000`.
 *
 * `'Q'`
 *      Milliseconds since the beginning of the epoch starting at 1 January
 *     1970 `00:00:00` UTC, i.e. `Long.MIN_VALUE` to
 *     `Long.MAX_VALUE`.
 *
 * 
 * 
 *
 *  The following conversion characters are used for formatting dates:
 *
 * 
 * date
 * 
 *
 * `'B'`
 *      Locale-specific {@linkplain java.text.DateFormatSymbols#getMonths
 *     full month name}, e.g. `"January"`, `"February"`.
 *
 * `'b'`
 *      Locale-specific {@linkplain
 *     java.text.DateFormatSymbols#getShortMonths abbreviated month name},
 *     e.g. `"Jan"`, `"Feb"`.
 *
 * `'h'`
 *      Same as `'b'`.
 *
 * `'A'`
 *      Locale-specific full name of the {@linkplain
 *     java.text.DateFormatSymbols#getWeekdays day of the week},
 *     e.g. `"Sunday"`, `"Monday"`
 *
 * `'a'`
 *      Locale-specific short name of the {@linkplain
 *     java.text.DateFormatSymbols#getShortWeekdays day of the week},
 *     e.g. `"Sun"`, `"Mon"`
 *
 * `'C'`
 *      Four-digit year divided by `100`, formatted as two digits
 *     with leading zero as necessary, i.e. `00 - 99`
 *
 * `'Y'`
 *      Year, formatted as at least four digits with leading zeros as
 *     necessary, e.g. `0092` equals `92` CE for the Gregorian
 *     calendar.
 *
 * `'y'`
 *      Last two digits of the year, formatted with leading zeros as
 *     necessary, i.e. `00 - 99`.
 *
 * `'j'`
 *      Day of year, formatted as three digits with leading zeros as
 *     necessary, e.g. `001 - 366` for the Gregorian calendar.
 *
 * `'m'`
 *      Month, formatted as two digits with leading zeros as necessary,
 *     i.e. `01 - 13`.
 *
 * `'d'`
 *      Day of month, formatted as two digits with leading zeros as
 *     necessary, i.e. `01 - 31`
 *
 * `'e'`
 *      Day of month, formatted as two digits, i.e. `1 - 31`.
 *
 * 
 * 
 *
 *  The following conversion characters are used for formatting common
 * date/time compositions.
 *
 * 
 * composites
 * 
 *
 * `'R'`
 *      Time formatted for the 24-hour clock as `"%tH:%tM"`
 *
 * `'T'`
 *      Time formatted for the 24-hour clock as `"%tH:%tM:%tS"`.
 *
 * `'r'`
 *      Time formatted for the 12-hour clock as `"%tI:%tM:%tS %Tp"`.
 *     The location of the morning or afternoon marker (`'%Tp'`) may be
 *     locale-dependent.
 *
 * `'D'`
 *      Date formatted as `"%tm/%td/%ty"`.
 *
 * `'F'`
 *      ISO 8601
 *     complete date formatted as `"%tY-%tm-%td"`.
 *
 * `'c'`
 *      Date and time formatted as `"%ta %tb %td %tT %tZ %tY"`,
 *     e.g. `"Sun Jul 20 16:17:00 EDT 1969"`.
 *
 * 
 * 
 *
 *  Any characters not explicitly defined as date/time conversion suffixes
 * are illegal and are reserved for future extensions.
 *
 *  Flags 
 *
 *  The following table summarizes the supported flags.  y means the
 * flag is supported for the indicated argument types.
 *
 * 
 * genConv
 * 
 *  Flag  General
 *      Character  Integral
 *      Floating Point
 *      Date/Time
 *      Description
 * 
 * 
 *  '-'  y
 *      y
 *      y
 *      y
 *      y
 *      The result will be left-justified.
 *
 *  '#'  y1
 *      -
 *      y3
 *      y
 *      -
 *      The result should use a conversion-dependent alternate form
 *
 *  '+'  -
 *      -
 *      y4
 *      y
 *      -
 *      The result will always include a sign
 *
 *  '  '  -
 *      -
 *      y4
 *      y
 *      -
 *      The result will include a leading space for positive values
 *
 *  '0'  -
 *      -
 *      y
 *      y
 *      -
 *      The result will be zero-padded
 *
 *  ','  -
 *      -
 *      y2
 *      y5
 *      -
 *      The result will include locale-specific {@linkplain
 *     java.text.DecimalFormatSymbols#getGroupingSeparator grouping separators}
 *
 *  '('  -
 *      -
 *      y4
 *      y5
 *      -
 *      The result will enclose negative numbers in parentheses
 *
 * 
 * 
 *
 *  1 Depends on the definition of {@link Formattable}.
 *
 *  2 For `'d'` conversion only.
 *
 *  3 For `'o'`, `'x'`, and `'X'`
 * conversions only.
 *
 *  4 For `'d'`, `'o'`, `'x'`, and
 * `'X'` conversions applied to {@link java.math.BigInteger BigInteger}
 * or `'d'` applied to `byte`, {@link Byte}, `short`, {@link
 * Short}, `int` and {@link Integer}, `long`, and {@link Long}.
 *
 *  5 For `'e'`, `'E'`, `'f'`,
 * `'g'`, and `'G'` conversions only.
 *
 *  Any characters not explicitly defined as flags are illegal and are
 * reserved for future extensions.
 *
 *  Width 
 *
 *  The width is the minimum number of characters to be written to the
 * output.  For the line separator conversion, width is not applicable; if it
 * is provided, an exception will be thrown.
 *
 *  Precision 
 *
 *  For general argument types, the precision is the maximum number of
 * characters to be written to the output.
 *
 *  For the floating-point conversions `'a'`, `'A'`, `'e'`,
 * `'E'`, and `'f'` the precision is the number of digits after the
 * radix point.  If the conversion is `'g'` or `'G'`, then the
 * precision is the total number of digits in the resulting magnitude after
 * rounding.
 *
 *  For character, integral, and date/time argument types and the percent
 * and line separator conversions, the precision is not applicable; if a
 * precision is provided, an exception will be thrown.
 *
 *  Argument Index 
 *
 *  The argument index is a decimal integer indicating the position of the
 * argument in the argument list.  The first argument is referenced by
 * "`1$`", the second by "`2$`", etc.
 *
 *  Another way to reference arguments by position is to use the
 * `'<'` ('\u003c') flag, which causes the argument for
 * the previous format specifier to be re-used.  For example, the following two
 * statements would produce identical strings:
 *
 *  *   Calendar c = ...;
 *   String s1 = String.format("Duke's Birthday: %1$tm %1$te,%1$tY", c);
 *
 *   String s2 = String.format("Duke's Birthday: %1$tm %<te,%<tY", c);
 * 
 *
 * 
 * Details
 *
 *  This section is intended to provide behavioral details for formatting,
 * including conditions and exceptions, supported data types, localization, and
 * interactions between flags, conversions, and data types.  For an overview of
 * formatting concepts, refer to the Summary
 *
 *  Any characters not explicitly defined as conversions, date/time
 * conversion suffixes, or flags are illegal and are reserved for
 * future extensions.  Use of such a character in a format string will
 * cause an {@link UnknownFormatConversionException} or {@link
 * UnknownFormatFlagsException} to be thrown.
 *
 *  If the format specifier contains a width or precision with an invalid
 * value or which is otherwise unsupported, then a {@link
 * IllegalFormatWidthException} or {@link IllegalFormatPrecisionException}
 * respectively will be thrown. Similarly, values of zero for an argument
 * index will result in an {@link IllegalFormatException}.
 *
 *  If a format specifier contains a conversion character that is not
 * applicable to the corresponding argument, then an {@link
 * IllegalFormatConversionException} will be thrown.
 *
 *  Values of precision must be in the range zero to
 * {@link Integer#MAX_VALUE}, inclusive, otherwise
 * {@link IllegalFormatPrecisionException} is thrown.
 *
 *  Values of width must be in the range one to
 * {@link Integer#MAX_VALUE}, inclusive, otherwise
 * {@link IllegalFormatWidthException} will be thrown
 * Note that widths can appear to have a negative value, but the negative sign
 * is a flag. For example in the format string `"%-20s"` the
 * width is 20 and the flag is "-".
 *
 *  Values of index must be in the range one to
 * {@link Integer#MAX_VALUE}, inclusive, otherwise
 * {@link IllegalFormatException} will be thrown.
 *
 *  All specified exceptions may be thrown by any of the `format`
 * methods of `Formatter` as well as by any `format` convenience
 * methods such as {@link String#format(String,Object...) String.format} and
 * {@link java.io.PrintStream#printf(String,Object...) PrintStream.printf}.
 *
 *  For category General, Character, Numeric,
 * Integral and Date/Time conversion, unless otherwise specified,
 * if the argument arg is `null`, then the result is "`null`".
 *
 *  Conversions denoted by an upper-case character (i.e. `'B'`,
 * `'H'`, `'S'`, `'C'`, `'X'`, `'E'`,
 * `'G'`, `'A'`, and `'T'`) are the same as those for the
 * corresponding lower-case conversion characters except that the result is
 * converted to upper case according to the rules of the prevailing {@link
 * java.util.Locale Locale}. If there is no explicit locale specified,
 * either at the construction of the instance or as a parameter to its method
 * invocation, then the {@link java.util.Locale.Category#FORMAT default locale}
 * is used.
 *
 * General
 *
 *  The following general conversions may be applied to any argument type:
 *
 * 
 * dgConv
 * 
 *
 *  `'b'`
 *      '\u0062'
 *      Produces either "`true`" or "`false`" as returned by
 *     {@link Boolean#toString(boolean)}.
 *
 *      If the argument is `null`, then the result is
 *     "`false`".  If the argument is a `boolean` or {@link
 *     Boolean}, then the result is the string returned by {@link
 *     String#valueOf(boolean) String.valueOf()}.  Otherwise, the result is
 *     "`true`".
 *
 *      If the `'#'` flag is given, then a {@link
 *     FormatFlagsConversionMismatchException} will be thrown.
 *
 *  `'B'`
 *      '\u0042'
 *      The upper-case variant of `'b'`.
 *
 *  `'h'`
 *      '\u0068'
 *      Produces a string representing the hash code value of the object.
 *
 *      The result is obtained by invoking
 *     `Integer.toHexString(arg.hashCode())`.
 *
 *      If the `'#'` flag is given, then a {@link
 *     FormatFlagsConversionMismatchException} will be thrown.
 *
 *  `'H'`
 *      '\u0048'
 *      The upper-case variant of `'h'`.
 *
 *  `'s'`
 *      '\u0073'
 *      Produces a string.
 *
 *      If the argument implements {@link Formattable}, then
 *     its {@link Formattable#formatTo formatTo} method is invoked.
 *     Otherwise, the result is obtained by invoking the argument's
 *     `toString()` method.
 *
 *      If the `'#'` flag is given and the argument is not a {@link
 *     Formattable}, then a {@link FormatFlagsConversionMismatchException}
 *     will be thrown.
 *
 *  `'S'`
 *      '\u0053'
 *      The upper-case variant of `'s'`.
 *
 * 
 * 
 *
 *  The following flags apply to general conversions:
 *
 * 
 * dFlags
 * 
 *
 *  `'-'`
 *      '\u002d'
 *      Left justifies the output.  Spaces ('\u0020') will be
 *     added at the end of the converted value as required to fill the minimum
 *     width of the field.  If the width is not provided, then a {@link
 *     MissingFormatWidthException} will be thrown.  If this flag is not given
 *     then the output will be right-justified.
 *
 *  `'#'`
 *      '\u0023'
 *      Requires the output use an alternate form.  The definition of the
 *     form is specified by the conversion.
 *
 * 
 * 
 *
 *  The width is the minimum number of characters to
 * be written to the
 * output.  If the length of the converted value is less than the width then
 * the output will be padded by '  ' ('\u0020')
 * until the total number of characters equals the width.  The padding is on
 * the left by default.  If the `'-'` flag is given, then the padding
 * will be on the right.  If the width is not specified then there is no
 * minimum.
 *
 *  The precision is the maximum number of characters to be written to the
 * output.  The precision is applied before the width, thus the output will be
 * truncated to `precision` characters even if the width is greater than
 * the precision.  If the precision is not specified then there is no explicit
 * limit on the number of characters.
 *
 * Character
 *
 * This conversion may be applied to `char` and {@link Character}.  It
 * may also be applied to the types `byte`, {@link Byte},
 * `short`, and {@link Short}, `int` and {@link Integer} when
 * {@link Character#isValidCodePoint} returns `true`.  If it returns
 * `false` then an {@link IllegalFormatCodePointException} will be
 * thrown.
 *
 * 
 * charConv
 * 
 *
 *  `'c'`
 *      '\u0063'
 *      Formats the argument as a Unicode character as described in Unicode Character
 *     Representation.  This may be more than one 16-bit `char` in
 *     the case where the argument represents a supplementary character.
 *
 *      If the `'#'` flag is given, then a {@link
 *     FormatFlagsConversionMismatchException} will be thrown.
 *
 *  `'C'`
 *      '\u0043'
 *      The upper-case variant of `'c'`.
 *
 * 
 * 
 *
 *  The `'-'` flag defined for General
 * conversions applies.  If the `'#'` flag is given, then a {@link
 * FormatFlagsConversionMismatchException} will be thrown.
 *
 *  The width is defined as for General conversions.
 *
 *  The precision is not applicable.  If the precision is specified then an
 * {@link IllegalFormatPrecisionException} will be thrown.
 *
 * Numeric
 *
 *  Numeric conversions are divided into the following categories:
 *
 * 
 *
 *  Byte, Short, Integer, and Long
 *
 *  BigInteger
 *
 *  Float and Double
 *
 *  BigDecimal
 *
 * 
 *
 *  Numeric types will be formatted according to the following algorithm:
 *
 *  Number Localization Algorithm
 *
 *  After digits are obtained for the integer part, fractional part, and
 * exponent (as appropriate for the data type), the following transformation
 * is applied:
 *
 * 
 *
 *  Each digit character d in the string is replaced by a
 * locale-specific digit computed relative to the current locale's
 * {@linkplain java.text.DecimalFormatSymbols#getZeroDigit() zero digit}
 * z; that is d -  `'0'`
 *  + z.
 *
 *  If a decimal separator is present, a locale-specific {@linkplain
 * java.text.DecimalFormatSymbols#getDecimalSeparator decimal separator} is
 * substituted.
 *
 *  If the `','` ('\u002c')
 * flag is given, then the locale-specific {@linkplain
 * java.text.DecimalFormatSymbols#getGroupingSeparator grouping separator} is
 * inserted by scanning the integer part of the string from least significant
 * to most significant digits and inserting a separator at intervals defined by
 * the locale's {@linkplain java.text.DecimalFormat#getGroupingSize() grouping
 * size}.
 *
 *  If the `'0'` flag is given, then the locale-specific {@linkplain
 * java.text.DecimalFormatSymbols#getZeroDigit() zero digits} are inserted
 * after the sign character, if any, and before the first non-zero digit, until
 * the length of the string is equal to the requested field width.
 *
 *  If the value is negative and the `'('` flag is given, then a
 * `'('` ('\u0028') is prepended and a `')'`
 * ('\u0029') is appended.
 *
 *  If the value is negative (or floating-point negative zero) and
 * `'('` flag is not given, then a `'-'` ('\u002d')
 * is prepended.
 *
 *  If the `'+'` flag is given and the value is positive or zero (or
 * floating-point positive zero), then a `'+'` ('\u002b')
 * will be prepended.
 *
 * 
 *
 *  If the value is NaN or positive infinity the literal strings "NaN" or
 * "Infinity" respectively, will be output.  If the value is negative infinity,
 * then the output will be "(Infinity)" if the `'('` flag is given
 * otherwise the output will be "-Infinity".  These values are not localized.
 *
 *  Byte, Short, Integer, and Long 
 *
 *  The following conversions may be applied to `byte`, {@link Byte},
 * `short`, {@link Short}, `int` and {@link Integer},
 * `long`, and {@link Long}.
 *
 * 
 * IntConv
 * 
 *
 *  `'d'`
 *      '\u0064'
 *      Formats the argument as a decimal integer. The localization algorithm is applied.
 *
 *      If the `'0'` flag is given and the value is negative, then
 *     the zero padding will occur after the sign.
 *
 *      If the `'#'` flag is given then a {@link
 *     FormatFlagsConversionMismatchException} will be thrown.
 *
 *  `'o'`
 *      '\u006f'
 *      Formats the argument as an integer in base eight.  No localization
 *     is applied.
 *
 *      If x is negative then the result will be an unsigned value
 *     generated by adding 2n to the value where `n` is the
 *     number of bits in the type as returned by the static `SIZE` field
 *     in the {@linkplain Byte#SIZE Byte}, {@linkplain Short#SIZE Short},
 *     {@linkplain Integer#SIZE Integer}, or {@linkplain Long#SIZE Long}
 *     classes as appropriate.
 *
 *      If the `'#'` flag is given then the output will always begin
 *     with the radix indicator `'0'`.
 *
 *      If the `'0'` flag is given then the output will be padded
 *     with leading zeros to the field width following any indication of sign.
 *
 *      If `'('`, `'+'`, '  ', or `','` flags
 *     are given then a {@link FormatFlagsConversionMismatchException} will be
 *     thrown.
 *
 *  `'x'`
 *      '\u0078'
 *      Formats the argument as an integer in base sixteen. No
 *     localization is applied.
 *
 *      If x is negative then the result will be an unsigned value
 *     generated by adding 2n to the value where `n` is the
 *     number of bits in the type as returned by the static `SIZE` field
 *     in the {@linkplain Byte#SIZE Byte}, {@linkplain Short#SIZE Short},
 *     {@linkplain Integer#SIZE Integer}, or {@linkplain Long#SIZE Long}
 *     classes as appropriate.
 *
 *      If the `'#'` flag is given then the output will always begin
 *     with the radix indicator `"0x"`.
 *
 *      If the `'0'` flag is given then the output will be padded to
 *     the field width with leading zeros after the radix indicator or sign (if
 *     present).
 *
 *      If `'('`, '  ', `'+'`, or
 *     `','` flags are given then a {@link
 *     FormatFlagsConversionMismatchException} will be thrown.
 *
 *  `'X'`
 *      '\u0058'
 *      The upper-case variant of `'x'`.  The entire string
 *     representing the number will be converted to {@linkplain
 *     String#toUpperCase upper case} including the `'x'` (if any) and
 *     all hexadecimal digits `'a'` - `'f'`
 *     ('\u0061' -  '\u0066').
 *
 * 
 * 
 *
 *  If the conversion is `'o'`, `'x'`, or `'X'` and
 * both the `'#'` and the `'0'` flags are given, then result will
 * contain the radix indicator (`'0'` for octal and `"0x"` or
 * `"0X"` for hexadecimal), some number of zeros (based on the width),
 * and the value.
 *
 *  If the `'-'` flag is not given, then the space padding will occur
 * before the sign.
 *
 *  The following flags apply to numeric integral
 * conversions:
 *
 * 
 * intFlags
 * 
 *
 *  `'+'`
 *      '\u002b'
 *      Requires the output to include a positive sign for all positive
 *     numbers.  If this flag is not given then only negative values will
 *     include a sign.
 *
 *      If both the `'+'` and '  ' flags are given
 *     then an {@link IllegalFormatFlagsException} will be thrown.
 *
 *  '  '
 *      '\u0020'
 *      Requires the output to include a single extra space
 *     ('\u0020') for non-negative values.
 *
 *      If both the `'+'` and '  ' flags are given
 *     then an {@link IllegalFormatFlagsException} will be thrown.
 *
 *  `'0'`
 *      '\u0030'
 *      Requires the output to be padded with leading {@linkplain
 *     java.text.DecimalFormatSymbols#getZeroDigit zeros} to the minimum field
 *     width following any sign or radix indicator except when converting NaN
 *     or infinity.  If the width is not provided, then a {@link
 *     MissingFormatWidthException} will be thrown.
 *
 *      If both the `'-'` and `'0'` flags are given then an
 *     {@link IllegalFormatFlagsException} will be thrown.
 *
 *  `','`
 *      '\u002c'
 *      Requires the output to include the locale-specific {@linkplain
 *     java.text.DecimalFormatSymbols#getGroupingSeparator group separators} as
 *     described in the "group" section of the
 *     localization algorithm.
 *
 *  `'('`
 *      '\u0028'
 *      Requires the output to prepend a `'('`
 *     ('\u0028') and append a `')'`
 *     ('\u0029') to negative values.
 *
 * 
 * 
 *
 *  If no flags are given the default formatting is
 * as follows:
 *
 * 
 *
 *  The output is right-justified within the `width`
 *
 *  Negative numbers begin with a `'-'` ('\u002d')
 *
 *  Positive numbers and zero do not include a sign or extra leading
 * space
 *
 *  No grouping separators are included
 *
 * 
 *
 *  The width is the minimum number of characters to
 * be written to the output.  This includes any signs, digits, grouping
 * separators, radix indicator, and parentheses.  If the length of the
 * converted value is less than the width then the output will be padded by
 * spaces ('\u0020') until the total number of characters equals
 * width.  The padding is on the left by default.  If `'-'` flag is
 * given then the padding will be on the right.  If width is not specified then
 * there is no minimum.
 *
 *  The precision is not applicable.  If precision is specified then an
 * {@link IllegalFormatPrecisionException} will be thrown.
 *
 *  BigInteger 
 *
 *  The following conversions may be applied to {@link
 * java.math.BigInteger}.
 *
 * 
 * bIntConv
 * 
 *
 *  `'d'`
 *      '\u0064'
 *      Requires the output to be formatted as a decimal integer. The localization algorithm is applied.
 *
 *      If the `'#'` flag is given {@link
 *     FormatFlagsConversionMismatchException} will be thrown.
 *
 *  `'o'`
 *      '\u006f'
 *      Requires the output to be formatted as an integer in base eight.
 *     No localization is applied.
 *
 *      If x is negative then the result will be a signed value
 *     beginning with `'-'` ('\u002d').  Signed output is
 *     allowed for this type because unlike the primitive types it is not
 *     possible to create an unsigned equivalent without assuming an explicit
 *     data-type size.
 *
 *      If x is positive or zero and the `'+'` flag is given
 *     then the result will begin with `'+'` ('\u002b').
 *
 *      If the `'#'` flag is given then the output will always begin
 *     with `'0'` prefix.
 *
 *      If the `'0'` flag is given then the output will be padded
 *     with leading zeros to the field width following any indication of sign.
 *
 *      If the `','` flag is given then a {@link
 *     FormatFlagsConversionMismatchException} will be thrown.
 *
 *  `'x'`
 *      '\u0078'
 *      Requires the output to be formatted as an integer in base
 *     sixteen.  No localization is applied.
 *
 *      If x is negative then the result will be a signed value
 *     beginning with `'-'` ('\u002d').  Signed output is
 *     allowed for this type because unlike the primitive types it is not
 *     possible to create an unsigned equivalent without assuming an explicit
 *     data-type size.
 *
 *      If x is positive or zero and the `'+'` flag is given
 *     then the result will begin with `'+'` ('\u002b').
 *
 *      If the `'#'` flag is given then the output will always begin
 *     with the radix indicator `"0x"`.
 *
 *      If the `'0'` flag is given then the output will be padded to
 *     the field width with leading zeros after the radix indicator or sign (if
 *     present).
 *
 *      If the `','` flag is given then a {@link
 *     FormatFlagsConversionMismatchException} will be thrown.
 *
 *  `'X'`
 *      '\u0058'
 *      The upper-case variant of `'x'`.  The entire string
 *     representing the number will be converted to {@linkplain
 *     String#toUpperCase upper case} including the `'x'` (if any) and
 *     all hexadecimal digits `'a'` - `'f'`
 *     ('\u0061' - '\u0066').
 *
 * 
 * 
 *
 *  If the conversion is `'o'`, `'x'`, or `'X'` and
 * both the `'#'` and the `'0'` flags are given, then result will
 * contain the base indicator (`'0'` for octal and `"0x"` or
 * `"0X"` for hexadecimal), some number of zeros (based on the width),
 * and the value.
 *
 *  If the `'0'` flag is given and the value is negative, then the
 * zero padding will occur after the sign.
 *
 *  If the `'-'` flag is not given, then the space padding will occur
 * before the sign.
 *
 *  All flags defined for Byte, Short, Integer, and
 * Long apply.  The default behavior when no flags are
 * given is the same as for Byte, Short, Integer, and Long.
 *
 *  The specification of width is the same as
 * defined for Byte, Short, Integer, and Long.
 *
 *  The precision is not applicable.  If precision is specified then an
 * {@link IllegalFormatPrecisionException} will be thrown.
 *
 *  Float and Double
 *
 *  The following conversions may be applied to `float`, {@link
 * Float}, `double` and {@link Double}.
 *
 * 
 * floatConv
 * 
 *
 *  `'e'`
 *      '\u0065'
 *      Requires the output to be formatted using computerized scientific notation.  The localization algorithm is applied.
 *
 *      The formatting of the magnitude m depends upon its value.
 *
 *      If m is NaN or infinite, the literal strings "NaN" or
 *     "Infinity", respectively, will be output.  These values are not
 *     localized.
 *
 *      If m is positive-zero or negative-zero, then the exponent
 *     will be `"+00"`.
 *
 *      Otherwise, the result is a string that represents the sign and
 *     magnitude (absolute value) of the argument.  The formatting of the sign
 *     is described in the localization
 *     algorithm. The formatting of the magnitude m depends upon its
 *     value.
 *
 *      Let n be the unique integer such that 10n
 *     <= m < 10n+1; then let a be the
 *     mathematically exact quotient of m and 10n so
 *     that 1 <= a < 10. The magnitude is then represented as the
 *     integer part of a, as a single decimal digit, followed by the
 *     decimal separator followed by decimal digits representing the fractional
 *     part of a, followed by the exponent symbol `'e'`
 *     ('\u0065'), followed by the sign of the exponent, followed
 *     by a representation of n as a decimal integer, as produced by the
 *     method {@link Long#toString(long, int)}, and zero-padded to include at
 *     least two digits.
 *
 *      The number of digits in the result for the fractional part of
 *     m or a is equal to the precision.  If the precision is not
 *     specified then the default value is `6`. If the precision is less
 *     than the number of digits which would appear after the decimal point in
 *     the string returned by {@link Float#toString(float)} or {@link
 *     Double#toString(double)} respectively, then the value will be rounded
 *     using the {@linkplain java.math.RoundingMode#HALF_UP round half up
 *     algorithm}.  Otherwise, zeros may be appended to reach the precision.
 *     For a canonical representation of the value, use {@link
 *     Float#toString(float)} or {@link Double#toString(double)} as
 *     appropriate.
 *
 *     If the `','` flag is given, then an {@link
 *     FormatFlagsConversionMismatchException} will be thrown.
 *
 *  `'E'`
 *      '\u0045'
 *      The upper-case variant of `'e'`.  The exponent symbol
 *     will be `'E'` ('\u0045').
 *
 *  `'g'`
 *      '\u0067'
 *      Requires the output to be formatted in general scientific notation
 *     as described below. The localization
 *     algorithm is applied.
 *
 *      After rounding for the precision, the formatting of the resulting
 *     magnitude m depends on its value.
 *
 *      If m is greater than or equal to 10-4 but less
 *     than 10precision then it is represented in decimal format.
 *
 *      If m is less than 10-4 or greater than or equal to
 *     10precision, then it is represented in computerized scientific notation.
 *
 *      The total number of significant digits in m is equal to the
 *     precision.  If the precision is not specified, then the default value is
 *     `6`.  If the precision is `0`, then it is taken to be
 *     `1`.
 *
 *      If the `'#'` flag is given then an {@link
 *     FormatFlagsConversionMismatchException} will be thrown.
 *
 *  `'G'`
 *      '\u0047'
 *      The upper-case variant of `'g'`.
 *
 *  `'f'`
 *      '\u0066'
 *      Requires the output to be formatted using decimal
 *     format.  The localization algorithm is
 *     applied.
 *
 *      The result is a string that represents the sign and magnitude
 *     (absolute value) of the argument.  The formatting of the sign is
 *     described in the localization
 *     algorithm. The formatting of the magnitude m depends upon its
 *     value.
 *
 *      If m NaN or infinite, the literal strings "NaN" or
 *     "Infinity", respectively, will be output.  These values are not
 *     localized.
 *
 *      The magnitude is formatted as the integer part of m, with no
 *     leading zeroes, followed by the decimal separator followed by one or
 *     more decimal digits representing the fractional part of m.
 *
 *      The number of digits in the result for the fractional part of
 *     m or a is equal to the precision.  If the precision is not
 *     specified then the default value is `6`. If the precision is less
 *     than the number of digits which would appear after the decimal point in
 *     the string returned by {@link Float#toString(float)} or {@link
 *     Double#toString(double)} respectively, then the value will be rounded
 *     using the {@linkplain java.math.RoundingMode#HALF_UP round half up
 *     algorithm}.  Otherwise, zeros may be appended to reach the precision.
 *     For a canonical representation of the value, use {@link
 *     Float#toString(float)} or {@link Double#toString(double)} as
 *     appropriate.
 *
 *  `'a'`
 *      '\u0061'
 *      Requires the output to be formatted in hexadecimal exponential
 *     form.  No localization is applied.
 *
 *      The result is a string that represents the sign and magnitude
 *     (absolute value) of the argument x.
 *
 *      If x is negative or a negative-zero value then the result
 *     will begin with `'-'` ('\u002d').
 *
 *      If x is positive or a positive-zero value and the
 *     `'+'` flag is given then the result will begin with `'+'`
 *     ('\u002b').
 *
 *      The formatting of the magnitude m depends upon its value.
 *
 *     
 *
 *      If the value is NaN or infinite, the literal strings "NaN" or
 *     "Infinity", respectively, will be output.
 *
 *      If m is zero then it is represented by the string
 *     `"0x0.0p0"`.
 *
 *      If m is a `double` value with a normalized
 *     representation then substrings are used to represent the significand and
 *     exponent fields.  The significand is represented by the characters
 *     `"0x1."` followed by the hexadecimal representation of the rest
 *     of the significand as a fraction.  The exponent is represented by
 *     `'p'` ('\u0070') followed by a decimal string of the
 *     unbiased exponent as if produced by invoking {@link
 *     Integer#toString(int) Integer.toString} on the exponent value.  If the
 *     precision is specified, the value is rounded to the given number of
 *     hexadecimal digits.
 *
 *      If m is a `double` value with a subnormal
 *     representation then, unless the precision is specified to be in the range
 *     1 through 12, inclusive, the significand is represented by the characters
 *     `'0x0.'` followed by the hexadecimal representation of the rest of
 *     the significand as a fraction, and the exponent represented by
 *     `'p-1022'`.  If the precision is in the interval
 *     [1, 12], the subnormal value is normalized such that it
 *     begins with the characters `'0x1.'`, rounded to the number of
 *     hexadecimal digits of precision, and the exponent adjusted
 *     accordingly.  Note that there must be at least one nonzero digit in a
 *     subnormal significand.
 *
 *     
 *
 *      If the `'('` or `','` flags are given, then a {@link
 *     FormatFlagsConversionMismatchException} will be thrown.
 *
 *  `'A'`
 *      '\u0041'
 *      The upper-case variant of `'a'`.  The entire string
 *     representing the number will be converted to upper case including the
 *     `'x'` ('\u0078') and `'p'`
 *     ('\u0070' and all hexadecimal digits `'a'` -
 *     `'f'` ('\u0061' - '\u0066').
 *
 * 
 * 
 *
 *  All flags defined for Byte, Short, Integer, and
 * Long apply.
 *
 *  If the `'#'` flag is given, then the decimal separator will
 * always be present.
 *
 *  If no flags are given the default formatting
 * is as follows:
 *
 * 
 *
 *  The output is right-justified within the `width`
 *
 *  Negative numbers begin with a `'-'`
 *
 *  Positive numbers and positive zero do not include a sign or extra
 * leading space
 *
 *  No grouping separators are included
 *
 *  The decimal separator will only appear if a digit follows it
 *
 * 
 *
 *  The width is the minimum number of characters
 * to be written to the output.  This includes any signs, digits, grouping
 * separators, decimal separators, exponential symbol, radix indicator,
 * parentheses, and strings representing infinity and NaN as applicable.  If
 * the length of the converted value is less than the width then the output
 * will be padded by spaces ('\u0020') until the total number of
 * characters equals width.  The padding is on the left by default.  If the
 * `'-'` flag is given then the padding will be on the right.  If width
 * is not specified then there is no minimum.
 *
 *  If the conversion is `'e'`,
 * `'E'` or `'f'`, then the precision is the number of digits
 * after the decimal separator.  If the precision is not specified, then it is
 * assumed to be `6`.
 *
 *  If the conversion is `'g'` or `'G'`, then the precision is
 * the total number of significant digits in the resulting magnitude after
 * rounding.  If the precision is not specified, then the default value is
 * `6`.  If the precision is `0`, then it is taken to be
 * `1`.
 *
 *  If the conversion is `'a'` or `'A'`, then the precision
 * is the number of hexadecimal digits after the radix point.  If the
 * precision is not provided, then all of the digits as returned by {@link
 * Double#toHexString(double)} will be output.
 *
 *  BigDecimal 
 *
 *  The following conversions may be applied {@link java.math.BigDecimal
 * BigDecimal}.
 *
 * 
 * floatConv
 * 
 *
 *  `'e'`
 *      '\u0065'
 *      Requires the output to be formatted using computerized scientific notation.  The localization algorithm is applied.
 *
 *      The formatting of the magnitude m depends upon its value.
 *
 *      If m is positive-zero or negative-zero, then the exponent
 *     will be `"+00"`.
 *
 *      Otherwise, the result is a string that represents the sign and
 *     magnitude (absolute value) of the argument.  The formatting of the sign
 *     is described in the localization
 *     algorithm. The formatting of the magnitude m depends upon its
 *     value.
 *
 *      Let n be the unique integer such that 10n
 *     <= m < 10n+1; then let a be the
 *     mathematically exact quotient of m and 10n so
 *     that 1 <= a < 10. The magnitude is then represented as the
 *     integer part of a, as a single decimal digit, followed by the
 *     decimal separator followed by decimal digits representing the fractional
 *     part of a, followed by the exponent symbol `'e'`
 *     ('\u0065'), followed by the sign of the exponent, followed
 *     by a representation of n as a decimal integer, as produced by the
 *     method {@link Long#toString(long, int)}, and zero-padded to include at
 *     least two digits.
 *
 *      The number of digits in the result for the fractional part of
 *     m or a is equal to the precision.  If the precision is not
 *     specified then the default value is `6`.  If the precision is
 *     less than the number of digits to the right of the decimal point then
 *     the value will be rounded using the
 *     {@linkplain java.math.RoundingMode#HALF_UP round half up
 *     algorithm}.  Otherwise, zeros may be appended to reach the precision.
 *     For a canonical representation of the value, use {@link
 *     BigDecimal#toString()}.
 *
 *      If the `','` flag is given, then an {@link
 *     FormatFlagsConversionMismatchException} will be thrown.
 *
 *  `'E'`
 *      '\u0045'
 *      The upper-case variant of `'e'`.  The exponent symbol
 *     will be `'E'` ('\u0045').
 *
 *  `'g'`
 *      '\u0067'
 *      Requires the output to be formatted in general scientific notation
 *     as described below. The localization
 *     algorithm is applied.
 *
 *      After rounding for the precision, the formatting of the resulting
 *     magnitude m depends on its value.
 *
 *      If m is greater than or equal to 10-4 but less
 *     than 10precision then it is represented in decimal format.
 *
 *      If m is less than 10-4 or greater than or equal to
 *     10precision, then it is represented in computerized scientific notation.
 *
 *      The total number of significant digits in m is equal to the
 *     precision.  If the precision is not specified, then the default value is
 *     `6`.  If the precision is `0`, then it is taken to be
 *     `1`.
 *
 *      If the `'#'` flag is given then an {@link
 *     FormatFlagsConversionMismatchException} will be thrown.
 *
 *  `'G'`
 *      '\u0047'
 *      The upper-case variant of `'g'`.
 *
 *  `'f'`
 *      '\u0066'
 *      Requires the output to be formatted using decimal
 *     format.  The localization algorithm is
 *     applied.
 *
 *      The result is a string that represents the sign and magnitude
 *     (absolute value) of the argument.  The formatting of the sign is
 *     described in the localization
 *     algorithm. The formatting of the magnitude m depends upon its
 *     value.
 *
 *      The magnitude is formatted as the integer part of m, with no
 *     leading zeroes, followed by the decimal separator followed by one or
 *     more decimal digits representing the fractional part of m.
 *
 *      The number of digits in the result for the fractional part of
 *     m or a is equal to the precision. If the precision is not
 *     specified then the default value is `6`.  If the precision is
 *     less than the number of digits to the right of the decimal point
 *     then the value will be rounded using the
 *     {@linkplain java.math.RoundingMode#HALF_UP round half up
 *     algorithm}.  Otherwise, zeros may be appended to reach the precision.
 *     For a canonical representation of the value, use {@link
 *     BigDecimal#toString()}.
 *
 * 
 * 
 *
 *  All flags defined for Byte, Short, Integer, and
 * Long apply.
 *
 *  If the `'#'` flag is given, then the decimal separator will
 * always be present.
 *
 *  The default behavior when no flags are
 * given is the same as for Float and Double.
 *
 *  The specification of width and precision is the same as defined for Float and
 * Double.
 *
 * Date/Time
 *
 *  This conversion may be applied to `long`, {@link Long}, {@link
 * Calendar}, {@link Date} and {@link TemporalAccessor TemporalAccessor}
 *
 * 
 * DTConv
 * 
 *
 *  `'t'`
 *      '\u0074'
 *      Prefix for date and time conversion characters.
 *  `'T'`
 *      '\u0054'
 *      The upper-case variant of `'t'`.
 *
 * 
 * 
 *
 *  The following date and time conversion character suffixes are defined
 * for the `'t'` and `'T'` conversions.  The types are similar to
 * but not completely identical to those defined by GNU `date` and
 * POSIX `strftime(3c)`.  Additional conversion types are provided to
 * access Java-specific functionality (e.g. `'L'` for milliseconds
 * within the second).
 *
 *  The following conversion characters are used for formatting times:
 *
 * 
 * time
 * 
 *
 *  `'H'`
 *      '\u0048'
 *      Hour of the day for the 24-hour clock, formatted as two digits with
 *     a leading zero as necessary i.e. `00 - 23`. `00`
 *     corresponds to midnight.
 *
 * `'I'`
 *      '\u0049'
 *      Hour for the 12-hour clock, formatted as two digits with a leading
 *     zero as necessary, i.e.  `01 - 12`.  `01` corresponds to
 *     one o'clock (either morning or afternoon).
 *
 * `'k'`
 *      '\u006b'
 *      Hour of the day for the 24-hour clock, i.e. `0 - 23`.
 *     `0` corresponds to midnight.
 *
 * `'l'`
 *      '\u006c'
 *      Hour for the 12-hour clock, i.e. `1 - 12`.  `1`
 *     corresponds to one o'clock (either morning or afternoon).
 *
 * `'M'`
 *      '\u004d'
 *      Minute within the hour formatted as two digits with a leading zero
 *     as necessary, i.e.  `00 - 59`.
 *
 * `'S'`
 *      '\u0053'
 *      Seconds within the minute, formatted as two digits with a leading
 *     zero as necessary, i.e. `00 - 60` ("`60`" is a special
 *     value required to support leap seconds).
 *
 * `'L'`
 *      '\u004c'
 *      Millisecond within the second formatted as three digits with
 *     leading zeros as necessary, i.e. `000 - 999`.
 *
 * `'N'`
 *      '\u004e'
 *      Nanosecond within the second, formatted as nine digits with leading
 *     zeros as necessary, i.e. `000000000 - 999999999`.  The precision
 *     of this value is limited by the resolution of the underlying operating
 *     system or hardware.
 *
 * `'p'`
 *      '\u0070'
 *      Locale-specific {@linkplain
 *     java.text.DateFormatSymbols#getAmPmStrings morning or afternoon} marker
 *     in lower case, e.g."`am`" or "`pm`".  Use of the
 *     conversion prefix `'T'` forces this output to upper case.  (Note
 *     that `'p'` produces lower-case output.  This is different from
 *     GNU `date` and POSIX `strftime(3c)` which produce
 *     upper-case output.)
 *
 * `'z'`
 *      '\u007a'
 *      RFC 822
 *     style numeric time zone offset from GMT, e.g. `-0800`.  This
 *     value will be adjusted as necessary for Daylight Saving Time.  For
 *     `long`, {@link Long}, and {@link Date} the time zone used is
 *     the {@linkplain TimeZone#getDefault() default time zone} for this
 *     instance of the Java virtual machine.
 *
 * `'Z'`
 *      '\u005a'
 *      A string representing the abbreviation for the time zone.  This
 *     value will be adjusted as necessary for Daylight Saving Time.  For
 *     `long`, {@link Long}, and {@link Date} the time zone used is
 *     the {@linkplain TimeZone#getDefault() default time zone} for this
 *     instance of the Java virtual machine.  The Formatter's locale will
 *     supersede the locale of the argument (if any).
 *
 * `'s'`
 *      '\u0073'
 *      Seconds since the beginning of the epoch starting at 1 January 1970
 *     `00:00:00` UTC, i.e. `Long.MIN_VALUE/1000` to
 *     `Long.MAX_VALUE/1000`.
 *
 * `'Q'`
 *      '\u004f'
 *      Milliseconds since the beginning of the epoch starting at 1 January
 *     1970 `00:00:00` UTC, i.e. `Long.MIN_VALUE` to
 *     `Long.MAX_VALUE`. The precision of this value is limited by
 *     the resolution of the underlying operating system or hardware.
 *
 * 
 * 
 *
 *  The following conversion characters are used for formatting dates:
 *
 * 
 * date
 * 
 *
 * `'B'`
 *      '\u0042'
 *      Locale-specific {@linkplain java.text.DateFormatSymbols#getMonths
 *     full month name}, e.g. `"January"`, `"February"`.
 *
 * `'b'`
 *      '\u0062'
 *      Locale-specific {@linkplain
 *     java.text.DateFormatSymbols#getShortMonths abbreviated month name},
 *     e.g. `"Jan"`, `"Feb"`.
 *
 * `'h'`
 *      '\u0068'
 *      Same as `'b'`.
 *
 * `'A'`
 *      '\u0041'
 *      Locale-specific full name of the {@linkplain
 *     java.text.DateFormatSymbols#getWeekdays day of the week},
 *     e.g. `"Sunday"`, `"Monday"`
 *
 * `'a'`
 *      '\u0061'
 *      Locale-specific short name of the {@linkplain
 *     java.text.DateFormatSymbols#getShortWeekdays day of the week},
 *     e.g. `"Sun"`, `"Mon"`
 *
 * `'C'`
 *      '\u0043'
 *      Four-digit year divided by `100`, formatted as two digits
 *     with leading zero as necessary, i.e. `00 - 99`
 *
 * `'Y'`
 *      '\u0059'  Year, formatted to at least
 *     four digits with leading zeros as necessary, e.g. `0092` equals
 *     `92` CE for the Gregorian calendar.
 *
 * `'y'`
 *      '\u0079'
 *      Last two digits of the year, formatted with leading zeros as
 *     necessary, i.e. `00 - 99`.
 *
 * `'j'`
 *      '\u006a'
 *      Day of year, formatted as three digits with leading zeros as
 *     necessary, e.g. `001 - 366` for the Gregorian calendar.
 *     `001` corresponds to the first day of the year.
 *
 * `'m'`
 *      '\u006d'
 *      Month, formatted as two digits with leading zeros as necessary,
 *     i.e. `01 - 13`, where "`01`" is the first month of the
 *     year and ("`13`" is a special value required to support lunar
 *     calendars).
 *
 * `'d'`
 *      '\u0064'
 *      Day of month, formatted as two digits with leading zeros as
 *     necessary, i.e. `01 - 31`, where "`01`" is the first day
 *     of the month.
 *
 * `'e'`
 *      '\u0065'
 *      Day of month, formatted as two digits, i.e. `1 - 31` where
 *     "`1`" is the first day of the month.
 *
 * 
 * 
 *
 *  The following conversion characters are used for formatting common
 * date/time compositions.
 *
 * 
 * composites
 * 
 *
 * `'R'`
 *      '\u0052'
 *      Time formatted for the 24-hour clock as `"%tH:%tM"`
 *
 * `'T'`
 *      '\u0054'
 *      Time formatted for the 24-hour clock as `"%tH:%tM:%tS"`.
 *
 * `'r'`
 *      '\u0072'
 *      Time formatted for the 12-hour clock as {@code "%tI:%tM:%tS
 *     %Tp"}.  The location of the morning or afternoon marker
 *     (`'%Tp'`) may be locale-dependent.
 *
 * `'D'`
 *      '\u0044'
 *      Date formatted as `"%tm/%td/%ty"`.
 *
 * `'F'`
 *      '\u0046'
 *      ISO 8601
 *     complete date formatted as `"%tY-%tm-%td"`.
 *
 * `'c'`
 *      '\u0063'
 *      Date and time formatted as `"%ta %tb %td %tT %tZ %tY"`,
 *     e.g. `"Sun Jul 20 16:17:00 EDT 1969"`.
 *
 * 
 * 
 *
 *  The `'-'` flag defined for General
 * conversions applies.  If the `'#'` flag is given, then a {@link
 * FormatFlagsConversionMismatchException} will be thrown.
 *
 *  The width is the minimum number of characters to
 * be written to the output.  If the length of the converted value is less than
 * the `width` then the output will be padded by spaces
 * ('\u0020') until the total number of characters equals width.
 * The padding is on the left by default.  If the `'-'` flag is given
 * then the padding will be on the right.  If width is not specified then there
 * is no minimum.
 *
 *  The precision is not applicable.  If the precision is specified then an
 * {@link IllegalFormatPrecisionException} will be thrown.
 *
 * Percent
 *
 *  The conversion does not correspond to any argument.
 *
 * 
 * DTConv
 * 
 *
 * `'%'`
 *      The result is a literal `'%'` ('\u0025')
 *
 *  The width is the minimum number of characters to
 * be written to the output including the `'%'`.  If the length of the
 * converted value is less than the `width` then the output will be
 * padded by spaces ('\u0020') until the total number of
 * characters equals width.  The padding is on the left.  If width is not
 * specified then just the `'%'` is output.
 *
 *  The `'-'` flag defined for General
 * conversions applies.  If any other flags are provided, then a
 * {@link FormatFlagsConversionMismatchException} will be thrown.
 *
 *  The precision is not applicable.  If the precision is specified an
 * {@link IllegalFormatPrecisionException} will be thrown.
 *
 * 
 * 
 *
 * Line Separator
 *
 *  The conversion does not correspond to any argument.
 *
 * 
 * DTConv
 * 
 *
 * `'n'`
 *      the platform-specific line separator as returned by {@link
 *     System#lineSeparator()}.
 *
 * 
 * 
 *
 *  Flags, width, and precision are not applicable.  If any are provided an
 * {@link IllegalFormatFlagsException}, {@link IllegalFormatWidthException},
 * and {@link IllegalFormatPrecisionException}, respectively will be thrown.
 *
 * Argument Index
 *
 *  Format specifiers can reference arguments in three ways:
 *
 * 
 *
 *  Explicit indexing is used when the format specifier contains an
 * argument index.  The argument index is a decimal integer indicating the
 * position of the argument in the argument list.  The first argument is
 * referenced by "`1$`", the second by "`2$`", etc.  An argument
 * may be referenced more than once.
 *
 *  For example:
 *
 *  *   formatter.format("%4$s %3$s %2$s %1$s %4$s %3$s %2$s %1$s",
 *                    "a", "b", "c", "d")
 *   // -> "d c b a d c b a"
 * 
 *
 *  Relative indexing is used when the format specifier contains a
 * `'<'` ('\u003c') flag which causes the argument for
 * the previous format specifier to be re-used.  If there is no previous
 * argument, then a {@link MissingFormatArgumentException} is thrown.
 *
 *  *    formatter.format("%s %s %<s %<s", "a", "b", "c", "d")
 *    // -> "a b b b"
 *    // "c" and "d" are ignored because they are not referenced
 * 
 *
 *  Ordinary indexing is used when the format specifier contains
 * neither an argument index nor a `'<'` flag.  Each format specifier
 * which uses ordinary indexing is assigned a sequential implicit index into
 * argument list which is independent of the indices used by explicit or
 * relative indexing.
 *
 *  *   formatter.format("%s %s %s %s", "a", "b", "c", "d")
 *   // -> "a b c d"
 * 
 *
 * 
 *
 *  It is possible to have a format string which uses all forms of indexing,
 * for example:
 *
 *  *   formatter.format("%2$s %s %<s %s", "a", "b", "c", "d")
 *   // -> "b a a b"
 *   // "c" and "d" are ignored because they are not referenced
 * 
 *
 *  The maximum number of arguments is limited by the maximum dimension of a
 * Java array as defined by
 * The Java Virtual Machine Specification.
 * If the argument index does not correspond to an
 * available argument, then a {@link MissingFormatArgumentException} is thrown.
 *
 *  If there are more arguments than format specifiers, the extra arguments
 * are ignored.
 *
 *  Unless otherwise specified, passing a `null` argument to any
 * method or constructor in this class will cause a {@link
 * NullPointerException} to be thrown.
 *
 * @author  Iris Clark
 * @since 1.5
*/
export class Formatter extends Closeable {
  /**
   * Constructs a new formatter.
   *
   *  The destination of the formatted output is a {@link StringBuilder}
   * which may be retrieved by invoking {@link #out out()} and whose
   * current content may be converted into a string by invoking {@link
   * #toString toString()}.  The locale used is the {@linkplain
   * Locale#getDefault(Locale.Category) default locale} for
   * {@linkplain Locale.Category#FORMAT formatting} for this instance of the Java
   * virtual machine.
  */
  constructor();
  /**
   * Constructs a new formatter with the specified destination.
   *
   *  The locale used is the {@linkplain
   * Locale#getDefault(Locale.Category) default locale} for
   * {@linkplain Locale.Category#FORMAT formatting} for this instance of the Java
   * virtual machine.
   *
   * @param  a
   *         Destination for the formatted output.  If `a` is
   *         `null` then a {@link StringBuilder} will be created.
  */
  constructor(a: Appendable);
  /**
   * Constructs a new formatter with the specified locale.
   *
   *  The destination of the formatted output is a {@link StringBuilder}
   * which may be retrieved by invoking {@link #out out()} and whose current
   * content may be converted into a string by invoking {@link #toString
   * toString()}.
   *
   * @param  l
   *         The {@linkplain java.util.Locale locale} to apply during
   *         formatting.  If `l` is `null` then no localization
   *         is applied.
  */
  constructor(l: Locale);
  /**
   * Constructs a new formatter with the specified destination and locale.
   *
   * @param  a
   *         Destination for the formatted output.  If `a` is
   *         `null` then a {@link StringBuilder} will be created.
   *
   * @param  l
   *         The {@linkplain java.util.Locale locale} to apply during
   *         formatting.  If `l` is `null` then no localization
   *         is applied.
  */
  constructor(a: Appendable, l: Locale);
  /**
   * Constructs a new formatter with the specified file name.
   *
   *  The charset used is the {@linkplain
   * java.nio.charset.Charset#defaultCharset() default charset} for this
   * instance of the Java virtual machine.
   *
   *  The locale used is the {@linkplain
   * Locale#getDefault(Locale.Category) default locale} for
   * {@linkplain Locale.Category#FORMAT formatting} for this instance of the Java
   * virtual machine.
   *
   * @param  fileName
   *         The name of the file to use as the destination of this
   *         formatter.  If the file exists then it will be truncated to
   *         zero size; otherwise, a new file will be created.  The output
   *         will be written to the file and is buffered.
   *
   * @throws  SecurityException
   *          If a security manager is present and {@link
   *          SecurityManager#checkWrite checkWrite(fileName)} denies write
   *          access to the file
   *
   * @throws  FileNotFoundException
   *          If the given file name does not denote an existing, writable
   *          regular file and a new regular file of that name cannot be
   *          created, or if some other error occurs while opening or
   *          creating the file
  */
  constructor(fileName: string);
  /**
   * Constructs a new formatter with the specified file name and charset.
   *
   *  The locale used is the {@linkplain
   * Locale#getDefault(Locale.Category) default locale} for
   * {@linkplain Locale.Category#FORMAT formatting} for this instance of the Java
   * virtual machine.
   *
   * @param  fileName
   *         The name of the file to use as the destination of this
   *         formatter.  If the file exists then it will be truncated to
   *         zero size; otherwise, a new file will be created.  The output
   *         will be written to the file and is buffered.
   *
   * @param  csn
   *         The name of a supported {@linkplain java.nio.charset.Charset
   *         charset}
   *
   * @throws  FileNotFoundException
   *          If the given file name does not denote an existing, writable
   *          regular file and a new regular file of that name cannot be
   *          created, or if some other error occurs while opening or
   *          creating the file
   *
   * @throws  SecurityException
   *          If a security manager is present and {@link
   *          SecurityManager#checkWrite checkWrite(fileName)} denies write
   *          access to the file
   *
   * @throws  UnsupportedEncodingException
   *          If the named charset is not supported
  */
  constructor(fileName: string, csn: string);
  /**
   * Constructs a new formatter with the specified file name, charset, and
   * locale.
   *
   * @param  fileName
   *         The name of the file to use as the destination of this
   *         formatter.  If the file exists then it will be truncated to
   *         zero size; otherwise, a new file will be created.  The output
   *         will be written to the file and is buffered.
   *
   * @param  csn
   *         The name of a supported {@linkplain java.nio.charset.Charset
   *         charset}
   *
   * @param  l
   *         The {@linkplain java.util.Locale locale} to apply during
   *         formatting.  If `l` is `null` then no localization
   *         is applied.
   *
   * @throws  FileNotFoundException
   *          If the given file name does not denote an existing, writable
   *          regular file and a new regular file of that name cannot be
   *          created, or if some other error occurs while opening or
   *          creating the file
   *
   * @throws  SecurityException
   *          If a security manager is present and {@link
   *          SecurityManager#checkWrite checkWrite(fileName)} denies write
   *          access to the file
   *
   * @throws  UnsupportedEncodingException
   *          If the named charset is not supported
  */
  constructor(fileName: string, csn: string, l: Locale);
  /**
   * Constructs a new formatter with the specified file name, charset, and
   * locale.
   *
   * @param  fileName
   *         The name of the file to use as the destination of this
   *         formatter.  If the file exists then it will be truncated to
   *         zero size; otherwise, a new file will be created.  The output
   *         will be written to the file and is buffered.
   *
   * @param  charset
   *         A {@linkplain java.nio.charset.Charset charset}
   *
   * @param  l
   *         The {@linkplain java.util.Locale locale} to apply during
   *         formatting.  If `l` is `null` then no localization
   *         is applied.
   *
   * @throws  IOException
   *          if an I/O error occurs while opening or creating the file
   *
   * @throws  SecurityException
   *          If a security manager is present and {@link
   *          SecurityManager#checkWrite checkWrite(fileName)} denies write
   *          access to the file
   *
   * @throws NullPointerException
   *         if `fileName` or `charset` is `null`.
  */
  constructor(fileName: string, charset: Charset, l: Locale);
  /**
   * Constructs a new formatter with the specified file.
   *
   *  The charset used is the {@linkplain
   * java.nio.charset.Charset#defaultCharset() default charset} for this
   * instance of the Java virtual machine.
   *
   *  The locale used is the {@linkplain
   * Locale#getDefault(Locale.Category) default locale} for
   * {@linkplain Locale.Category#FORMAT formatting} for this instance of the Java
   * virtual machine.
   *
   * @param  file
   *         The file to use as the destination of this formatter.  If the
   *         file exists then it will be truncated to zero size; otherwise,
   *         a new file will be created.  The output will be written to the
   *         file and is buffered.
   *
   * @throws  SecurityException
   *          If a security manager is present and {@link
   *          SecurityManager#checkWrite checkWrite(file.getPath())} denies
   *          write access to the file
   *
   * @throws  FileNotFoundException
   *          If the given file object does not denote an existing, writable
   *          regular file and a new regular file of that name cannot be
   *          created, or if some other error occurs while opening or
   *          creating the file
  */
  constructor(file: File);
  /**
   * Constructs a new formatter with the specified file and charset.
   *
   *  The locale used is the {@linkplain
   * Locale#getDefault(Locale.Category) default locale} for
   * {@linkplain Locale.Category#FORMAT formatting} for this instance of the Java
   * virtual machine.
   *
   * @param  file
   *         The file to use as the destination of this formatter.  If the
   *         file exists then it will be truncated to zero size; otherwise,
   *         a new file will be created.  The output will be written to the
   *         file and is buffered.
   *
   * @param  csn
   *         The name of a supported {@linkplain java.nio.charset.Charset
   *         charset}
   *
   * @throws  FileNotFoundException
   *          If the given file object does not denote an existing, writable
   *          regular file and a new regular file of that name cannot be
   *          created, or if some other error occurs while opening or
   *          creating the file
   *
   * @throws  SecurityException
   *          If a security manager is present and {@link
   *          SecurityManager#checkWrite checkWrite(file.getPath())} denies
   *          write access to the file
   *
   * @throws  UnsupportedEncodingException
   *          If the named charset is not supported
  */
  constructor(file: File, csn: string);
  /**
   * Constructs a new formatter with the specified file, charset, and
   * locale.
   *
   * @param  file
   *         The file to use as the destination of this formatter.  If the
   *         file exists then it will be truncated to zero size; otherwise,
   *         a new file will be created.  The output will be written to the
   *         file and is buffered.
   *
   * @param  csn
   *         The name of a supported {@linkplain java.nio.charset.Charset
   *         charset}
   *
   * @param  l
   *         The {@linkplain java.util.Locale locale} to apply during
   *         formatting.  If `l` is `null` then no localization
   *         is applied.
   *
   * @throws  FileNotFoundException
   *          If the given file object does not denote an existing, writable
   *          regular file and a new regular file of that name cannot be
   *          created, or if some other error occurs while opening or
   *          creating the file
   *
   * @throws  SecurityException
   *          If a security manager is present and {@link
   *          SecurityManager#checkWrite checkWrite(file.getPath())} denies
   *          write access to the file
   *
   * @throws  UnsupportedEncodingException
   *          If the named charset is not supported
  */
  constructor(file: File, csn: string, l: Locale);
  /**
   * Constructs a new formatter with the specified file, charset, and
   * locale.
   *
   * @param  file
   *         The file to use as the destination of this formatter.  If the
   *         file exists then it will be truncated to zero size; otherwise,
   *         a new file will be created.  The output will be written to the
   *         file and is buffered.
   *
   * @param  charset
   *         A {@linkplain java.nio.charset.Charset charset}
   *
   * @param  l
   *         The {@linkplain java.util.Locale locale} to apply during
   *         formatting.  If `l` is `null` then no localization
   *         is applied.
   *
   * @throws IOException
   *         if an I/O error occurs while opening or creating the file
   *
   * @throws SecurityException
   *         If a security manager is present and {@link
   *         SecurityManager#checkWrite checkWrite(file.getPath())} denies
   *         write access to the file
   *
   * @throws NullPointerException
   *         if `file` or `charset` is `null`.
  */
  constructor(file: File, charset: Charset, l: Locale);
  /**
   * Constructs a new formatter with the specified print stream.
   *
   *  The locale used is the {@linkplain
   * Locale#getDefault(Locale.Category) default locale} for
   * {@linkplain Locale.Category#FORMAT formatting} for this instance of the Java
   * virtual machine.
   *
   *  Characters are written to the given {@link java.io.PrintStream
   * PrintStream} object and are therefore encoded using that object's
   * charset.
   *
   * @param  ps
   *         The stream to use as the destination of this formatter.
  */
  constructor(ps: PrintStream);
  /**
   * Constructs a new formatter with the specified output stream.
   *
   *  The charset used is the {@linkplain
   * java.nio.charset.Charset#defaultCharset() default charset} for this
   * instance of the Java virtual machine.
   *
   *  The locale used is the {@linkplain
   * Locale#getDefault(Locale.Category) default locale} for
   * {@linkplain Locale.Category#FORMAT formatting} for this instance of the Java
   * virtual machine.
   *
   * @param  os
   *         The output stream to use as the destination of this formatter.
   *         The output will be buffered.
  */
  constructor(os: OutputStream);
  /**
   * Constructs a new formatter with the specified output stream and
   * charset.
   *
   *  The locale used is the {@linkplain
   * Locale#getDefault(Locale.Category) default locale} for
   * {@linkplain Locale.Category#FORMAT formatting} for this instance of the Java
   * virtual machine.
   *
   * @param  os
   *         The output stream to use as the destination of this formatter.
   *         The output will be buffered.
   *
   * @param  csn
   *         The name of a supported {@linkplain java.nio.charset.Charset
   *         charset}
   *
   * @throws  UnsupportedEncodingException
   *          If the named charset is not supported
  */
  constructor(os: OutputStream, csn: string);
  /**
   * Constructs a new formatter with the specified output stream, charset,
   * and locale.
   *
   * @param  os
   *         The output stream to use as the destination of this formatter.
   *         The output will be buffered.
   *
   * @param  csn
   *         The name of a supported {@linkplain java.nio.charset.Charset
   *         charset}
   *
   * @param  l
   *         The {@linkplain java.util.Locale locale} to apply during
   *         formatting.  If `l` is `null` then no localization
   *         is applied.
   *
   * @throws  UnsupportedEncodingException
   *          If the named charset is not supported
  */
  constructor(os: OutputStream, csn: string, l: Locale);
  /**
   * Constructs a new formatter with the specified output stream, charset,
   * and locale.
   *
   * @param  os
   *         The output stream to use as the destination of this formatter.
   *         The output will be buffered.
   *
   * @param  charset
   *         A {@linkplain java.nio.charset.Charset charset}
   *
   * @param  l
   *         The {@linkplain java.util.Locale locale} to apply during
   *         formatting.  If `l` is `null` then no localization
   *         is applied.
   *
   * @throws NullPointerException
   *         if `os` or `charset` is `null`.
  */
  constructor(os: OutputStream, charset: Charset, l: Locale);
  /**
   * Returns the locale set by the construction of this formatter.
   *
   *  The {@link #format(java.util.Locale,String,Object...) format} method
   * for this object which has a locale argument does not change this value.
   *
   * @return  `null` if no localization is applied, otherwise a
   *          locale
   *
   * @throws  FormatterClosedException
   *          If this formatter has been closed by invoking its {@link
   *          #close()} method
  */
  locale(): Locale;
  /**
   * Returns the destination for the output.
   *
   * @return  The destination for the output
   *
   * @throws  FormatterClosedException
   *          If this formatter has been closed by invoking its {@link
   *          #close()} method
  */
  out(): Appendable;
  /**
   * Returns the result of invoking `toString()` on the destination
   * for the output.  For example, the following code formats text into a
   * {@link StringBuilder} then retrieves the resultant string:
   *
   *      *   Formatter f = new Formatter();
   *   f.format("Last reboot at %tc", lastRebootDate);
   *   String s = f.toString();
   *   // -> s == "Last reboot at Sat Jan 01 00:00:00 PST 2000"
   * 
   *
   *  An invocation of this method behaves in exactly the same way as the
   * invocation
   *
   *      *     out().toString() 
   *
   *  Depending on the specification of `toString` for the {@link
   * Appendable}, the returned string may or may not contain the characters
   * written to the destination.  For instance, buffers typically return
   * their contents in `toString()`, but streams cannot since the
   * data is discarded.
   *
   * @return  The result of invoking `toString()` on the destination
   *          for the output
   *
   * @throws  FormatterClosedException
   *          If this formatter has been closed by invoking its {@link
   *          #close()} method
  */
  toString(): string;
  /**
   * Flushes this formatter.  If the destination implements the {@link
   * java.io.Flushable} interface, its `flush` method will be invoked.
   *
   *  Flushing a formatter writes any buffered output in the destination
   * to the underlying stream.
   *
   * @throws  FormatterClosedException
   *          If this formatter has been closed by invoking its {@link
   *          #close()} method
  */
  flush(): void;
  /**
   * Closes this formatter.  If the destination implements the {@link
   * java.io.Closeable} interface, its `close` method will be invoked.
   *
   *  Closing a formatter allows it to release resources it may be holding
   * (such as open files).  If the formatter is already closed, then invoking
   * this method has no effect.
   *
   *  Attempting to invoke any methods except {@link #ioException()} in
   * this formatter after it has been closed will result in a {@link
   * FormatterClosedException}.
  */
  close(): void;
  /**
   * Returns the `IOException` last thrown by this formatter's {@link
   * Appendable}.
   *
   *  If the destination's `append()` method never throws
   * `IOException`, then this method will always return `null`.
   *
   * @return  The last exception thrown by the Appendable or `null` if
   *          no such exception exists.
  */
  ioException(): IOException;
  /**
   * Writes a formatted string to this object's destination using the
   * specified format string and arguments.  The locale used is the one
   * defined during the construction of this formatter.
   *
   * @param  format
   *         A format string as described in Format string
   *         syntax.
   *
   * @param  args
   *         Arguments referenced by the format specifiers in the format
   *         string.  If there are more arguments than format specifiers, the
   *         extra arguments are ignored.  The maximum number of arguments is
   *         limited by the maximum dimension of a Java array as defined by
   *         The Java Virtual Machine Specification.
   *
   * @throws  IllegalFormatException
   *          If a format string contains an illegal syntax, a format
   *          specifier that is incompatible with the given arguments,
   *          insufficient arguments given the format string, or other
   *          illegal conditions.  For specification of all possible
   *          formatting errors, see the Details
   *          section of the formatter class specification.
   *
   * @throws  FormatterClosedException
   *          If this formatter has been closed by invoking its {@link
   *          #close()} method
   *
   * @return  This formatter
  */
  format(format: string, ...args: any[]): Formatter;
  /**
   * Writes a formatted string to this object's destination using the
   * specified locale, format string, and arguments.
   *
   * @param  l
   *         The {@linkplain java.util.Locale locale} to apply during
   *         formatting.  If `l` is `null` then no localization
   *         is applied.  This does not change this object's locale that was
   *         set during construction.
   *
   * @param  format
   *         A format string as described in Format string
   *         syntax
   *
   * @param  args
   *         Arguments referenced by the format specifiers in the format
   *         string.  If there are more arguments than format specifiers, the
   *         extra arguments are ignored.  The maximum number of arguments is
   *         limited by the maximum dimension of a Java array as defined by
   *         The Java Virtual Machine Specification.
   *
   * @throws  IllegalFormatException
   *          If a format string contains an illegal syntax, a format
   *          specifier that is incompatible with the given arguments,
   *          insufficient arguments given the format string, or other
   *          illegal conditions.  For specification of all possible
   *          formatting errors, see the Details
   *          section of the formatter class specification.
   *
   * @throws  FormatterClosedException
   *          If this formatter has been closed by invoking its {@link
   *          #close()} method
   *
   * @return  This formatter
  */
  format(l: Locale, format: string, ...args: any[]): Formatter;
}
export interface Formatter extends Closeable, Flushable {}
/**
 * Unchecked exception thrown when the precision is a negative value other than
 * `-1`, the conversion does not support a precision, or the value is
 * otherwise unsupported. If the precision is not representable by an
 * `int` type, then the value `Integer.MIN_VALUE` will be used
 * in the exception.
 *
 * @since 1.5
*/
export class IllegalFormatPrecisionException extends IllegalFormatException {
  /**
   * Constructs an instance of this class with the specified precision.
   *
   * @param  p
   *         The precision
  */
  constructor(p: number);
  /**
   * Returns the precision. If the precision isn't representable by an
   * `int`, then will return `Integer.MIN_VALUE`.
   *
   * @return  The precision
  */
  getPrecision(): number;
  getMessage(): string;
}
export class AbstractSequentialList<E> extends AbstractList<E> {
  /**
   * Returns the element at the specified position in this list.
   *
   * This implementation first gets a list iterator pointing to the
   * indexed element (with `listIterator(index)`).  Then, it gets
   * the element using `ListIterator.next` and returns it.
   *
   * @throws IndexOutOfBoundsException {@inheritDoc}
  */
  get(index: number): E;
  /**
   * Replaces the element at the specified position in this list with the
   * specified element (optional operation).
   *
   * This implementation first gets a list iterator pointing to the
   * indexed element (with `listIterator(index)`).  Then, it gets
   * the current element using `ListIterator.next` and replaces it
   * with `ListIterator.set`.
   *
   * Note that this implementation will throw an
   * `UnsupportedOperationException` if the list iterator does not
   * implement the `set` operation.
   *
   * @throws UnsupportedOperationException {@inheritDoc}
   * @throws ClassCastException            {@inheritDoc}
   * @throws NullPointerException          {@inheritDoc}
   * @throws IllegalArgumentException      {@inheritDoc}
   * @throws IndexOutOfBoundsException     {@inheritDoc}
  */
  set(index: number, element: E): E;
  /**
   * Inserts the specified element at the specified position in this list
   * (optional operation).  Shifts the element currently at that position
   * (if any) and any subsequent elements to the right (adds one to their
   * indices).
   *
   * This implementation first gets a list iterator pointing to the
   * indexed element (with `listIterator(index)`).  Then, it
   * inserts the specified element with `ListIterator.add`.
   *
   * Note that this implementation will throw an
   * `UnsupportedOperationException` if the list iterator does not
   * implement the `add` operation.
   *
   * @throws UnsupportedOperationException {@inheritDoc}
   * @throws ClassCastException            {@inheritDoc}
   * @throws NullPointerException          {@inheritDoc}
   * @throws IllegalArgumentException      {@inheritDoc}
   * @throws IndexOutOfBoundsException     {@inheritDoc}
  */
  add(index: number, element: E): void;
  /**
   * Removes the element at the specified position in this list (optional
   * operation).  Shifts any subsequent elements to the left (subtracts one
   * from their indices).  Returns the element that was removed from the
   * list.
   *
   * This implementation first gets a list iterator pointing to the
   * indexed element (with `listIterator(index)`).  Then, it removes
   * the element with `ListIterator.remove`.
   *
   * Note that this implementation will throw an
   * `UnsupportedOperationException` if the list iterator does not
   * implement the `remove` operation.
   *
   * @throws UnsupportedOperationException {@inheritDoc}
   * @throws IndexOutOfBoundsException     {@inheritDoc}
  */
  remove(index: number): E;
  /**
   * Inserts all of the elements in the specified collection into this
   * list at the specified position (optional operation).  Shifts the
   * element currently at that position (if any) and any subsequent
   * elements to the right (increases their indices).  The new elements
   * will appear in this list in the order that they are returned by the
   * specified collection's iterator.  The behavior of this operation is
   * undefined if the specified collection is modified while the
   * operation is in progress.  (Note that this will occur if the specified
   * collection is this list, and it's nonempty.)
   *
   * This implementation gets an iterator over the specified collection and
   * a list iterator over this list pointing to the indexed element (with
   * `listIterator(index)`).  Then, it iterates over the specified
   * collection, inserting the elements obtained from the iterator into this
   * list, one at a time, using `ListIterator.add` followed by
   * `ListIterator.next` (to skip over the added element).
   *
   * Note that this implementation will throw an
   * `UnsupportedOperationException` if the list iterator returned by
   * the `listIterator` method does not implement the `add`
   * operation.
   *
   * @throws UnsupportedOperationException {@inheritDoc}
   * @throws ClassCastException            {@inheritDoc}
   * @throws NullPointerException          {@inheritDoc}
   * @throws IllegalArgumentException      {@inheritDoc}
   * @throws IndexOutOfBoundsException     {@inheritDoc}
  */
  addAll(index: number, c: Collection<E>): boolean;
  /**
   * Returns an iterator over the elements in this list (in proper
   * sequence).
   *
   * This implementation merely returns a list iterator over the list.
   *
   * @return an iterator over the elements in this list (in proper sequence)
  */
  iterator(): Iterator<E>;
  /**
   * Returns a list iterator over the elements in this list (in proper
   * sequence).
   *
   * @param  index index of first element to be returned from the list
   *         iterator (by a call to the `next` method)
   * @return a list iterator over the elements in this list (in proper
   *         sequence)
   * @throws IndexOutOfBoundsException {@inheritDoc}
  */
  listIterator(index: number): ListIterator<E>;
  /**
   * Appends the specified element to the end of this list (optional
   * operation).
   *
   * Lists that support this operation may place limitations on what
   * elements may be added to this list.  In particular, some
   * lists will refuse to add null elements, and others will impose
   * restrictions on the type of elements that may be added.  List
   * classes should clearly specify in their documentation any restrictions
   * on what elements may be added.
   *
   * @implSpec
   * This implementation calls `add(size(), e)`.
   *
   * Note that this implementation throws an
   * `UnsupportedOperationException` unless
   * {@link #add(int, Object) add(int, E)} is overridden.
   *
   * @param e element to be appended to this list
   * @return `true` (as specified by {@link Collection#add})
   * @throws UnsupportedOperationException if the `add` operation
   *         is not supported by this list
   * @throws ClassCastException if the class of the specified element
   *         prevents it from being added to this list
   * @throws NullPointerException if the specified element is null and this
   *         list does not permit null elements
   * @throws IllegalArgumentException if some property of this element
   *         prevents it from being added to this list
  */
  add(e: E): boolean;
  /**
   * {@inheritDoc}
   *
   * @implSpec
   * This implementation returns `listIterator(0)`.
   *
   * @see #listIterator(int)
  */
  listIterator(): ListIterator<E>;
  /**
   * {@inheritDoc}
   *
   * @implSpec
   * This implementation iterates over the collection looking for the
   * specified element.  If it finds the element, it removes the element
   * from the collection using the iterator's remove method.
   *
   * Note that this implementation throws an
   * `UnsupportedOperationException` if the iterator returned by this
   * collection's iterator method does not implement the `remove`
   * method and this collection contains the specified object.
   *
   * @throws UnsupportedOperationException {@inheritDoc}
   * @throws ClassCastException            {@inheritDoc}
   * @throws NullPointerException          {@inheritDoc}
  */
  remove(o: any): boolean;
  /**
   * {@inheritDoc}
   *
   * @implSpec
   * This implementation iterates over the specified collection, and adds
   * each object returned by the iterator to this collection, in turn.
   *
   * Note that this implementation will throw an
   * `UnsupportedOperationException` unless `add` is
   * overridden (assuming the specified collection is non-empty).
   *
   * @throws UnsupportedOperationException {@inheritDoc}
   * @throws ClassCastException            {@inheritDoc}
   * @throws NullPointerException          {@inheritDoc}
   * @throws IllegalArgumentException      {@inheritDoc}
   * @throws IllegalStateException         {@inheritDoc}
   *
   * @see #add(Object)
  */
  addAll(c: Collection<E>): boolean;
}
export class List<E> extends Collection<E> {
  /**
   * Returns the number of elements in this list.  If this list contains
   * more than `Integer.MAX_VALUE` elements, returns
   * `Integer.MAX_VALUE`.
   *
   * @return the number of elements in this list
  */
  size(): number;
  /**
   * Returns `true` if this list contains no elements.
   *
   * @return `true` if this list contains no elements
  */
  isEmpty(): boolean;
  /**
   * Returns `true` if this list contains the specified element.
   * More formally, returns `true` if and only if this list contains
   * at least one element `e` such that
   * `Objects.equals(o, e)`.
   *
   * @param o element whose presence in this list is to be tested
   * @return `true` if this list contains the specified element
   * @throws ClassCastException if the type of the specified element
   *         is incompatible with this list
   * (optional)
   * @throws NullPointerException if the specified element is null and this
   *         list does not permit null elements
   * (optional)
  */
  contains(o: any): boolean;
  /**
   * Returns an iterator over the elements in this list in proper sequence.
   *
   * @return an iterator over the elements in this list in proper sequence
  */
  iterator(): Iterator<E>;
  /**
   * Returns an array containing all of the elements in this list in proper
   * sequence (from first to last element).
   *
   * The returned array will be "safe" in that no references to it are
   * maintained by this list.  (In other words, this method must
   * allocate a new array even if this list is backed by an array).
   * The caller is thus free to modify the returned array.
   *
   * This method acts as bridge between array-based and collection-based
   * APIs.
   *
   * @return an array containing all of the elements in this list in proper
   *         sequence
   * @see Arrays#asList(Object[])
  */
  toArray(): any[];
  /**
   * Returns an array containing all of the elements in this list in
   * proper sequence (from first to last element); the runtime type of
   * the returned array is that of the specified array.  If the list fits
   * in the specified array, it is returned therein.  Otherwise, a new
   * array is allocated with the runtime type of the specified array and
   * the size of this list.
   *
   * If the list fits in the specified array with room to spare (i.e.,
   * the array has more elements than the list), the element in the array
   * immediately following the end of the list is set to `null`.
   * (This is useful in determining the length of the list only if
   * the caller knows that the list does not contain any null elements.)
   *
   * Like the {@link #toArray()} method, this method acts as bridge between
   * array-based and collection-based APIs.  Further, this method allows
   * precise control over the runtime type of the output array, and may,
   * under certain circumstances, be used to save allocation costs.
   *
   * Suppose `x` is a list known to contain only strings.
   * The following code can be used to dump the list into a newly
   * allocated array of `String`:
   *
   * {@code
   *     String[] y = x.toArray(new String[0]);
   * }
   *
   * Note that `toArray(new Object[0])` is identical in function to
   * `toArray()`.
   *
   * @param a the array into which the elements of this list are to
   *          be stored, if it is big enough; otherwise, a new array of the
   *          same runtime type is allocated for this purpose.
   * @return an array containing the elements of this list
   * @throws ArrayStoreException if the runtime type of the specified array
   *         is not a supertype of the runtime type of every element in
   *         this list
   * @throws NullPointerException if the specified array is null
  */
  toArray<T>(a: T[]): T[];
  /**
   * Appends the specified element to the end of this list (optional
   * operation).
   *
   * Lists that support this operation may place limitations on what
   * elements may be added to this list.  In particular, some
   * lists will refuse to add null elements, and others will impose
   * restrictions on the type of elements that may be added.  List
   * classes should clearly specify in their documentation any restrictions
   * on what elements may be added.
   *
   * @param e element to be appended to this list
   * @return `true` (as specified by {@link Collection#add})
   * @throws UnsupportedOperationException if the `add` operation
   *         is not supported by this list
   * @throws ClassCastException if the class of the specified element
   *         prevents it from being added to this list
   * @throws NullPointerException if the specified element is null and this
   *         list does not permit null elements
   * @throws IllegalArgumentException if some property of this element
   *         prevents it from being added to this list
  */
  add(e: E): boolean;
  /**
   * Removes the first occurrence of the specified element from this list,
   * if it is present (optional operation).  If this list does not contain
   * the element, it is unchanged.  More formally, removes the element with
   * the lowest index `i` such that
   * `Objects.equals(o, get(i))`
   * (if such an element exists).  Returns `true` if this list
   * contained the specified element (or equivalently, if this list changed
   * as a result of the call).
   *
   * @param o element to be removed from this list, if present
   * @return `true` if this list contained the specified element
   * @throws ClassCastException if the type of the specified element
   *         is incompatible with this list
   * (optional)
   * @throws NullPointerException if the specified element is null and this
   *         list does not permit null elements
   * (optional)
   * @throws UnsupportedOperationException if the `remove` operation
   *         is not supported by this list
  */
  remove(o: any): boolean;
  /**
   * Returns `true` if this list contains all of the elements of the
   * specified collection.
   *
   * @param  c collection to be checked for containment in this list
   * @return `true` if this list contains all of the elements of the
   *         specified collection
   * @throws ClassCastException if the types of one or more elements
   *         in the specified collection are incompatible with this
   *         list
   * (optional)
   * @throws NullPointerException if the specified collection contains one
   *         or more null elements and this list does not permit null
   *         elements
   *         (optional),
   *         or if the specified collection is null
   * @see #contains(Object)
  */
  containsAll(c: Collection<any>): boolean;
  /**
   * Appends all of the elements in the specified collection to the end of
   * this list, in the order that they are returned by the specified
   * collection's iterator (optional operation).  The behavior of this
   * operation is undefined if the specified collection is modified while
   * the operation is in progress.  (Note that this will occur if the
   * specified collection is this list, and it's nonempty.)
   *
   * @param c collection containing elements to be added to this list
   * @return `true` if this list changed as a result of the call
   * @throws UnsupportedOperationException if the `addAll` operation
   *         is not supported by this list
   * @throws ClassCastException if the class of an element of the specified
   *         collection prevents it from being added to this list
   * @throws NullPointerException if the specified collection contains one
   *         or more null elements and this list does not permit null
   *         elements, or if the specified collection is null
   * @throws IllegalArgumentException if some property of an element of the
   *         specified collection prevents it from being added to this list
   * @see #add(Object)
  */
  addAll(c: Collection<E>): boolean;
  /**
   * Inserts all of the elements in the specified collection into this
   * list at the specified position (optional operation).  Shifts the
   * element currently at that position (if any) and any subsequent
   * elements to the right (increases their indices).  The new elements
   * will appear in this list in the order that they are returned by the
   * specified collection's iterator.  The behavior of this operation is
   * undefined if the specified collection is modified while the
   * operation is in progress.  (Note that this will occur if the specified
   * collection is this list, and it's nonempty.)
   *
   * @param index index at which to insert the first element from the
   *              specified collection
   * @param c collection containing elements to be added to this list
   * @return `true` if this list changed as a result of the call
   * @throws UnsupportedOperationException if the `addAll` operation
   *         is not supported by this list
   * @throws ClassCastException if the class of an element of the specified
   *         collection prevents it from being added to this list
   * @throws NullPointerException if the specified collection contains one
   *         or more null elements and this list does not permit null
   *         elements, or if the specified collection is null
   * @throws IllegalArgumentException if some property of an element of the
   *         specified collection prevents it from being added to this list
   * @throws IndexOutOfBoundsException if the index is out of range
   *         (`index < 0 || index > size()`)
  */
  addAll(index: number, c: Collection<E>): boolean;
  /**
   * Removes from this list all of its elements that are contained in the
   * specified collection (optional operation).
   *
   * @param c collection containing elements to be removed from this list
   * @return `true` if this list changed as a result of the call
   * @throws UnsupportedOperationException if the `removeAll` operation
   *         is not supported by this list
   * @throws ClassCastException if the class of an element of this list
   *         is incompatible with the specified collection
   * (optional)
   * @throws NullPointerException if this list contains a null element and the
   *         specified collection does not permit null elements
   *         (optional),
   *         or if the specified collection is null
   * @see #remove(Object)
   * @see #contains(Object)
  */
  removeAll(c: Collection<any>): boolean;
  /**
   * Retains only the elements in this list that are contained in the
   * specified collection (optional operation).  In other words, removes
   * from this list all of its elements that are not contained in the
   * specified collection.
   *
   * @param c collection containing elements to be retained in this list
   * @return `true` if this list changed as a result of the call
   * @throws UnsupportedOperationException if the `retainAll` operation
   *         is not supported by this list
   * @throws ClassCastException if the class of an element of this list
   *         is incompatible with the specified collection
   * (optional)
   * @throws NullPointerException if this list contains a null element and the
   *         specified collection does not permit null elements
   *         (optional),
   *         or if the specified collection is null
   * @see #remove(Object)
   * @see #contains(Object)
  */
  retainAll(c: Collection<any>): boolean;
  /**
   * Replaces each element of this list with the result of applying the
   * operator to that element.  Errors or runtime exceptions thrown by
   * the operator are relayed to the caller.
   *
   * @implSpec
   * The default implementation is equivalent to, for this `list`:
   * {@code
   *     final ListIterator li = list.listIterator();
   *     while (li.hasNext()) {
   *         li.set(operator.apply(li.next()));
   *     }
   * }
   *
   * If the list's list-iterator does not support the `set` operation
   * then an `UnsupportedOperationException` will be thrown when
   * replacing the first element.
   *
   * @param operator the operator to apply to each element
   * @throws UnsupportedOperationException if this list is unmodifiable.
   *         Implementations may throw this exception if an element
   *         cannot be replaced or if, in general, modification is not
   *         supported
   * @throws NullPointerException if the specified operator is null or
   *         if the operator result is a null value and this list does
   *         not permit null elements
   *         (optional)
   * @since 1.8
  */
  replaceAll(operator: UnaryOperator<E>): void;
  /**
   * Sorts this list according to the order induced by the specified
   * {@link Comparator}.  The sort is stable: this method must not
   * reorder equal elements.
   *
   * All elements in this list must be mutually comparable using the
   * specified comparator (that is, `c.compare(e1, e2)` must not throw
   * a `ClassCastException` for any elements `e1` and `e2`
   * in the list).
   *
   * If the specified comparator is `null` then all elements in this
   * list must implement the {@link Comparable} interface and the elements'
   * {@linkplain Comparable natural ordering} should be used.
   *
   * This list must be modifiable, but need not be resizable.
   *
   * @implSpec
   * The default implementation obtains an array containing all elements in
   * this list, sorts the array, and iterates over this list resetting each
   * element from the corresponding position in the array. (This avoids the
   * n2 log(n) performance that would result from attempting
   * to sort a linked list in place.)
   *
   * @implNote
   * This implementation is a stable, adaptive, iterative mergesort that
   * requires far fewer than n lg(n) comparisons when the input array is
   * partially sorted, while offering the performance of a traditional
   * mergesort when the input array is randomly ordered.  If the input array
   * is nearly sorted, the implementation requires approximately n
   * comparisons.  Temporary storage requirements vary from a small constant
   * for nearly sorted input arrays to n/2 object references for randomly
   * ordered input arrays.
   *
   * The implementation takes equal advantage of ascending and
   * descending order in its input array, and can take advantage of
   * ascending and descending order in different parts of the same
   * input array.  It is well-suited to merging two or more sorted arrays:
   * simply concatenate the arrays and sort the resulting array.
   *
   * The implementation was adapted from Tim Peters's list sort for Python
   * (
   * TimSort).  It uses techniques from Peter McIlroy's "Optimistic
   * Sorting and Information Theoretic Complexity", in Proceedings of the
   * Fourth Annual ACM-SIAM Symposium on Discrete Algorithms, pp 467-474,
   * January 1993.
   *
   * @param c the `Comparator` used to compare list elements.
   *          A `null` value indicates that the elements'
   *          {@linkplain Comparable natural ordering} should be used
   * @throws ClassCastException if the list contains elements that are not
   *         mutually comparable using the specified comparator
   * @throws UnsupportedOperationException if the list's list-iterator does
   *         not support the `set` operation
   * @throws IllegalArgumentException
   *         (optional)
   *         if the comparator is found to violate the {@link Comparator}
   *         contract
   * @since 1.8
  */
  sort(c: Comparator<any>): void;
  /**
   * Removes all of the elements from this list (optional operation).
   * The list will be empty after this call returns.
   *
   * @throws UnsupportedOperationException if the `clear` operation
   *         is not supported by this list
  */
  clear(): void;
  /**
   * Compares the specified object with this list for equality.  Returns
   * `true` if and only if the specified object is also a list, both
   * lists have the same size, and all corresponding pairs of elements in
   * the two lists are equal.  (Two elements `e1` and
   * `e2` are equal if `Objects.equals(e1, e2)`.)
   * In other words, two lists are defined to be
   * equal if they contain the same elements in the same order.  This
   * definition ensures that the equals method works properly across
   * different implementations of the `List` interface.
   *
   * @param o the object to be compared for equality with this list
   * @return `true` if the specified object is equal to this list
  */
  equals(o: any): boolean;
  /**
   * Returns the hash code value for this list.  The hash code of a list
   * is defined to be the result of the following calculation:
   * {@code
   *     int hashCode = 1;
   *     for (E e : list)
   *         hashCode = 31*hashCode + (e==null ? 0 : e.hashCode());
   * }
   * This ensures that `list1.equals(list2)` implies that
   * `list1.hashCode()==list2.hashCode()` for any two lists,
   * `list1` and `list2`, as required by the general
   * contract of {@link Object#hashCode}.
   *
   * @return the hash code value for this list
   * @see Object#equals(Object)
   * @see #equals(Object)
  */
  hashCode(): number;
  /**
   * Returns the element at the specified position in this list.
   *
   * @param index index of the element to return
   * @return the element at the specified position in this list
   * @throws IndexOutOfBoundsException if the index is out of range
   *         (`index < 0 || index >= size()`)
  */
  get(index: number): E;
  /**
   * Replaces the element at the specified position in this list with the
   * specified element (optional operation).
   *
   * @param index index of the element to replace
   * @param element element to be stored at the specified position
   * @return the element previously at the specified position
   * @throws UnsupportedOperationException if the `set` operation
   *         is not supported by this list
   * @throws ClassCastException if the class of the specified element
   *         prevents it from being added to this list
   * @throws NullPointerException if the specified element is null and
   *         this list does not permit null elements
   * @throws IllegalArgumentException if some property of the specified
   *         element prevents it from being added to this list
   * @throws IndexOutOfBoundsException if the index is out of range
   *         (`index < 0 || index >= size()`)
  */
  set(index: number, element: E): E;
  /**
   * Inserts the specified element at the specified position in this list
   * (optional operation).  Shifts the element currently at that position
   * (if any) and any subsequent elements to the right (adds one to their
   * indices).
   *
   * @param index index at which the specified element is to be inserted
   * @param element element to be inserted
   * @throws UnsupportedOperationException if the `add` operation
   *         is not supported by this list
   * @throws ClassCastException if the class of the specified element
   *         prevents it from being added to this list
   * @throws NullPointerException if the specified element is null and
   *         this list does not permit null elements
   * @throws IllegalArgumentException if some property of the specified
   *         element prevents it from being added to this list
   * @throws IndexOutOfBoundsException if the index is out of range
   *         (`index < 0 || index > size()`)
  */
  add(index: number, element: E): void;
  /**
   * Removes the element at the specified position in this list (optional
   * operation).  Shifts any subsequent elements to the left (subtracts one
   * from their indices).  Returns the element that was removed from the
   * list.
   *
   * @param index the index of the element to be removed
   * @return the element previously at the specified position
   * @throws UnsupportedOperationException if the `remove` operation
   *         is not supported by this list
   * @throws IndexOutOfBoundsException if the index is out of range
   *         (`index < 0 || index >= size()`)
  */
  remove(index: number): E;
  /**
   * Returns the index of the first occurrence of the specified element
   * in this list, or -1 if this list does not contain the element.
   * More formally, returns the lowest index `i` such that
   * `Objects.equals(o, get(i))`,
   * or -1 if there is no such index.
   *
   * @param o element to search for
   * @return the index of the first occurrence of the specified element in
   *         this list, or -1 if this list does not contain the element
   * @throws ClassCastException if the type of the specified element
   *         is incompatible with this list
   *         (optional)
   * @throws NullPointerException if the specified element is null and this
   *         list does not permit null elements
   *         (optional)
  */
  indexOf(o: any): number;
  /**
   * Returns the index of the last occurrence of the specified element
   * in this list, or -1 if this list does not contain the element.
   * More formally, returns the highest index `i` such that
   * `Objects.equals(o, get(i))`,
   * or -1 if there is no such index.
   *
   * @param o element to search for
   * @return the index of the last occurrence of the specified element in
   *         this list, or -1 if this list does not contain the element
   * @throws ClassCastException if the type of the specified element
   *         is incompatible with this list
   *         (optional)
   * @throws NullPointerException if the specified element is null and this
   *         list does not permit null elements
   *         (optional)
  */
  lastIndexOf(o: any): number;
  /**
   * Returns a list iterator over the elements in this list (in proper
   * sequence).
   *
   * @return a list iterator over the elements in this list (in proper
   *         sequence)
  */
  listIterator(): ListIterator<E>;
  /**
   * Returns a list iterator over the elements in this list (in proper
   * sequence), starting at the specified position in the list.
   * The specified index indicates the first element that would be
   * returned by an initial call to {@link ListIterator#next next}.
   * An initial call to {@link ListIterator#previous previous} would
   * return the element with the specified index minus one.
   *
   * @param index index of the first element to be returned from the
   *        list iterator (by a call to {@link ListIterator#next next})
   * @return a list iterator over the elements in this list (in proper
   *         sequence), starting at the specified position in the list
   * @throws IndexOutOfBoundsException if the index is out of range
   *         (`index < 0 || index > size()`)
  */
  listIterator(index: number): ListIterator<E>;
  /**
   * Returns a view of the portion of this list between the specified
   * `fromIndex`, inclusive, and `toIndex`, exclusive.  (If
   * `fromIndex` and `toIndex` are equal, the returned list is
   * empty.)  The returned list is backed by this list, so non-structural
   * changes in the returned list are reflected in this list, and vice-versa.
   * The returned list supports all of the optional list operations supported
   * by this list.
   *
   * This method eliminates the need for explicit range operations (of
   * the sort that commonly exist for arrays).  Any operation that expects
   * a list can be used as a range operation by passing a subList view
   * instead of a whole list.  For example, the following idiom
   * removes a range of elements from a list:
   * {@code
   *      list.subList(from, to).clear();
   * }
   * Similar idioms may be constructed for `indexOf` and
   * `lastIndexOf`, and all of the algorithms in the
   * `Collections` class can be applied to a subList.
   *
   * The semantics of the list returned by this method become undefined if
   * the backing list (i.e., this list) is structurally modified in
   * any way other than via the returned list.  (Structural modifications are
   * those that change the size of this list, or otherwise perturb it in such
   * a fashion that iterations in progress may yield incorrect results.)
   *
   * @param fromIndex low endpoint (inclusive) of the subList
   * @param toIndex high endpoint (exclusive) of the subList
   * @return a view of the specified range within this list
   * @throws IndexOutOfBoundsException for an illegal endpoint index value
   *         ({@code fromIndex < 0 || toIndex > size ||
   *         fromIndex > toIndex})
  */
  subList(fromIndex: number, toIndex: number): E[];
  /**
   * Creates a {@link Spliterator} over the elements in this list.
   *
   * The `Spliterator` reports {@link Spliterator#SIZED} and
   * {@link Spliterator#ORDERED}.  Implementations should document the
   * reporting of additional characteristic values.
   *
   * @implSpec
   * The default implementation creates a
   * late-binding
   * spliterator as follows:
   * 
   * If the list is an instance of {@link RandomAccess} then the default
   *     implementation creates a spliterator that traverses elements by
   *     invoking the method {@link List#get}.  If such invocation results or
   *     would result in an `IndexOutOfBoundsException` then the
   *     spliterator will fail-fast and throw a
   *     `ConcurrentModificationException`.
   *     If the list is also an instance of {@link AbstractList} then the
   *     spliterator will use the list's {@link AbstractList#modCount modCount}
   *     field to provide additional fail-fast behavior.
   * Otherwise, the default implementation creates a spliterator from the
   *     list's `Iterator`.  The spliterator inherits the
   *     fail-fast of the list's iterator.
   * 
   *
   * @implNote
   * The created `Spliterator` additionally reports
   * {@link Spliterator#SUBSIZED}.
   *
   * @return a `Spliterator` over the elements in this list
   * @since 1.8
  */
  spliterator(): Spliterator<E>;
  /**
   * Returns an unmodifiable list containing zero elements.
   *
   * See Unmodifiable Lists for details.
   *
   * @param  the `List`'s element type
   * @return an empty `List`
   *
   * @since 9
  */
  static of<E>(): E[];
  /**
   * Returns an unmodifiable list containing one element.
   *
   * See Unmodifiable Lists for details.
   *
   * @param  the `List`'s element type
   * @param e1 the single element
   * @return a `List` containing the specified element
   * @throws NullPointerException if the element is `null`
   *
   * @since 9
  */
  static of<E>(e1: E): E[];
  /**
   * Returns an unmodifiable list containing two elements.
   *
   * See Unmodifiable Lists for details.
   *
   * @param  the `List`'s element type
   * @param e1 the first element
   * @param e2 the second element
   * @return a `List` containing the specified elements
   * @throws NullPointerException if an element is `null`
   *
   * @since 9
  */
  static of<E>(e1: E, e2: E): E[];
  /**
   * Returns an unmodifiable list containing three elements.
   *
   * See Unmodifiable Lists for details.
   *
   * @param  the `List`'s element type
   * @param e1 the first element
   * @param e2 the second element
   * @param e3 the third element
   * @return a `List` containing the specified elements
   * @throws NullPointerException if an element is `null`
   *
   * @since 9
  */
  static of<E>(e1: E, e2: E, e3: E): E[];
  /**
   * Returns an unmodifiable list containing four elements.
   *
   * See Unmodifiable Lists for details.
   *
   * @param  the `List`'s element type
   * @param e1 the first element
   * @param e2 the second element
   * @param e3 the third element
   * @param e4 the fourth element
   * @return a `List` containing the specified elements
   * @throws NullPointerException if an element is `null`
   *
   * @since 9
  */
  static of<E>(e1: E, e2: E, e3: E, e4: E): E[];
  /**
   * Returns an unmodifiable list containing five elements.
   *
   * See Unmodifiable Lists for details.
   *
   * @param  the `List`'s element type
   * @param e1 the first element
   * @param e2 the second element
   * @param e3 the third element
   * @param e4 the fourth element
   * @param e5 the fifth element
   * @return a `List` containing the specified elements
   * @throws NullPointerException if an element is `null`
   *
   * @since 9
  */
  static of<E>(e1: E, e2: E, e3: E, e4: E, e5: E): E[];
  /**
   * Returns an unmodifiable list containing six elements.
   *
   * See Unmodifiable Lists for details.
   *
   * @param  the `List`'s element type
   * @param e1 the first element
   * @param e2 the second element
   * @param e3 the third element
   * @param e4 the fourth element
   * @param e5 the fifth element
   * @param e6 the sixth element
   * @return a `List` containing the specified elements
   * @throws NullPointerException if an element is `null`
   *
   * @since 9
  */
  static of<E>(e1: E, e2: E, e3: E, e4: E, e5: E, e6: E): E[];
  /**
   * Returns an unmodifiable list containing seven elements.
   *
   * See Unmodifiable Lists for details.
   *
   * @param  the `List`'s element type
   * @param e1 the first element
   * @param e2 the second element
   * @param e3 the third element
   * @param e4 the fourth element
   * @param e5 the fifth element
   * @param e6 the sixth element
   * @param e7 the seventh element
   * @return a `List` containing the specified elements
   * @throws NullPointerException if an element is `null`
   *
   * @since 9
  */
  static of<E>(e1: E, e2: E, e3: E, e4: E, e5: E, e6: E, e7: E): E[];
  /**
   * Returns an unmodifiable list containing eight elements.
   *
   * See Unmodifiable Lists for details.
   *
   * @param  the `List`'s element type
   * @param e1 the first element
   * @param e2 the second element
   * @param e3 the third element
   * @param e4 the fourth element
   * @param e5 the fifth element
   * @param e6 the sixth element
   * @param e7 the seventh element
   * @param e8 the eighth element
   * @return a `List` containing the specified elements
   * @throws NullPointerException if an element is `null`
   *
   * @since 9
  */
  static of<E>(e1: E, e2: E, e3: E, e4: E, e5: E, e6: E, e7: E, e8: E): E[];
  /**
   * Returns an unmodifiable list containing nine elements.
   *
   * See Unmodifiable Lists for details.
   *
   * @param  the `List`'s element type
   * @param e1 the first element
   * @param e2 the second element
   * @param e3 the third element
   * @param e4 the fourth element
   * @param e5 the fifth element
   * @param e6 the sixth element
   * @param e7 the seventh element
   * @param e8 the eighth element
   * @param e9 the ninth element
   * @return a `List` containing the specified elements
   * @throws NullPointerException if an element is `null`
   *
   * @since 9
  */
  static of<E>(e1: E, e2: E, e3: E, e4: E, e5: E, e6: E, e7: E, e8: E, e9: E): E[];
  /**
   * Returns an unmodifiable list containing ten elements.
   *
   * See Unmodifiable Lists for details.
   *
   * @param  the `List`'s element type
   * @param e1 the first element
   * @param e2 the second element
   * @param e3 the third element
   * @param e4 the fourth element
   * @param e5 the fifth element
   * @param e6 the sixth element
   * @param e7 the seventh element
   * @param e8 the eighth element
   * @param e9 the ninth element
   * @param e10 the tenth element
   * @return a `List` containing the specified elements
   * @throws NullPointerException if an element is `null`
   *
   * @since 9
  */
  static of<E>(e1: E, e2: E, e3: E, e4: E, e5: E, e6: E, e7: E, e8: E, e9: E, e10: E): E[];
  /**
   * Returns an unmodifiable list containing an arbitrary number of elements.
   * See Unmodifiable Lists for details.
   *
   * @apiNote
   * This method also accepts a single array as an argument. The element type of
   * the resulting list will be the component type of the array, and the size of
   * the list will be equal to the length of the array. To create a list with
   * a single element that is an array, do the following:
   *
   * {@code
   *     String[] array = ... ;
   *     List list = List.of(array);
   * }
   *
   * This will cause the {@link List#of(Object) List.of(E)} method
   * to be invoked instead.
   *
   * @param  the `List`'s element type
   * @param elements the elements to be contained in the list
   * @return a `List` containing the specified elements
   * @throws NullPointerException if an element is `null` or if the array is `null`
   *
   * @since 9
  */
  static of<E>(...elements: E[]): E[];
  /**
   * Returns an unmodifiable List containing the elements of
   * the given Collection, in its iteration order. The given Collection must not be null,
   * and it must not contain any null elements. If the given Collection is subsequently
   * modified, the returned List will not reflect such modifications.
   *
   * @implNote
   * If the given Collection is an unmodifiable List,
   * calling copyOf will generally not create a copy.
   *
   * @param  the `List`'s element type
   * @param coll a `Collection` from which elements are drawn, must be non-null
   * @return a `List` containing the elements of the given `Collection`
   * @throws NullPointerException if coll is null, or if it contains any nulls
   * @since 10
  */
  static copyOf<E>(coll: Collection<E>): E[];
  /**
   * Returns an array containing all of the elements in this collection,
   * using the provided `generator` function to allocate the returned array.
   *
   * If this collection makes any guarantees as to what order its elements
   * are returned by its iterator, this method must return the elements in
   * the same order.
   *
   * @apiNote
   * This method acts as a bridge between array-based and collection-based APIs.
   * It allows creation of an array of a particular runtime type. Use
   * {@link #toArray()} to create an array whose runtime type is `Object[]`,
   * or use {@link #toArray(Object[]) toArray(T[])} to reuse an existing array.
   *
   * Suppose `x` is a collection known to contain only strings.
   * The following code can be used to dump the collection into a newly
   * allocated array of `String`:
   *
   *      *     String[] y = x.toArray(String[]::new);
   *
   * @implSpec
   * The default implementation calls the generator function with zero
   * and then passes the resulting array to {@link #toArray(Object[]) toArray(T[])}.
   *
   * @param  the component type of the array to contain the collection
   * @param generator a function which produces a new array of the desired
   *                  type and the provided length
   * @return an array containing all of the elements in this collection
   * @throws ArrayStoreException if the runtime type of any element in this
   *         collection is not assignable to the {@linkplain Class#getComponentType
   *         runtime component type} of the generated array
   * @throws NullPointerException if the generator function is null
   * @since 11
  */
  toArray<T>(generator: IntFunction<T[]>): T[];
}
export class SortedMap<K, V> extends Map<K, V> {
  /**
   * Returns the comparator used to order the keys in this map, or
   * `null` if this map uses the {@linkplain Comparable
   * natural ordering} of its keys.
   *
   * @return the comparator used to order the keys in this map,
   *         or `null` if this map uses the natural ordering
   *         of its keys
  */
  comparator(): Comparator<any>;
  /**
   * Returns a view of the portion of this map whose keys range from
   * `fromKey`, inclusive, to `toKey`, exclusive.  (If
   * `fromKey` and `toKey` are equal, the returned map
   * is empty.)  The returned map is backed by this map, so changes
   * in the returned map are reflected in this map, and vice-versa.
   * The returned map supports all optional map operations that this
   * map supports.
   *
   * The returned map will throw an `IllegalArgumentException`
   * on an attempt to insert a key outside its range.
   *
   * @param fromKey low endpoint (inclusive) of the keys in the returned map
   * @param toKey high endpoint (exclusive) of the keys in the returned map
   * @return a view of the portion of this map whose keys range from
   *         `fromKey`, inclusive, to `toKey`, exclusive
   * @throws ClassCastException if `fromKey` and `toKey`
   *         cannot be compared to one another using this map's comparator
   *         (or, if the map has no comparator, using natural ordering).
   *         Implementations may, but are not required to, throw this
   *         exception if `fromKey` or `toKey`
   *         cannot be compared to keys currently in the map.
   * @throws NullPointerException if `fromKey` or `toKey`
   *         is null and this map does not permit null keys
   * @throws IllegalArgumentException if `fromKey` is greater than
   *         `toKey`; or if this map itself has a restricted
   *         range, and `fromKey` or `toKey` lies
   *         outside the bounds of the range
  */
  subMap(fromKey: K, toKey: K): SortedMap<K, V>;
  /**
   * Returns a view of the portion of this map whose keys are
   * strictly less than `toKey`.  The returned map is backed
   * by this map, so changes in the returned map are reflected in
   * this map, and vice-versa.  The returned map supports all
   * optional map operations that this map supports.
   *
   * The returned map will throw an `IllegalArgumentException`
   * on an attempt to insert a key outside its range.
   *
   * @param toKey high endpoint (exclusive) of the keys in the returned map
   * @return a view of the portion of this map whose keys are strictly
   *         less than `toKey`
   * @throws ClassCastException if `toKey` is not compatible
   *         with this map's comparator (or, if the map has no comparator,
   *         if `toKey` does not implement {@link Comparable}).
   *         Implementations may, but are not required to, throw this
   *         exception if `toKey` cannot be compared to keys
   *         currently in the map.
   * @throws NullPointerException if `toKey` is null and
   *         this map does not permit null keys
   * @throws IllegalArgumentException if this map itself has a
   *         restricted range, and `toKey` lies outside the
   *         bounds of the range
  */
  headMap(toKey: K): SortedMap<K, V>;
  /**
   * Returns a view of the portion of this map whose keys are
   * greater than or equal to `fromKey`.  The returned map is
   * backed by this map, so changes in the returned map are
   * reflected in this map, and vice-versa.  The returned map
   * supports all optional map operations that this map supports.
   *
   * The returned map will throw an `IllegalArgumentException`
   * on an attempt to insert a key outside its range.
   *
   * @param fromKey low endpoint (inclusive) of the keys in the returned map
   * @return a view of the portion of this map whose keys are greater
   *         than or equal to `fromKey`
   * @throws ClassCastException if `fromKey` is not compatible
   *         with this map's comparator (or, if the map has no comparator,
   *         if `fromKey` does not implement {@link Comparable}).
   *         Implementations may, but are not required to, throw this
   *         exception if `fromKey` cannot be compared to keys
   *         currently in the map.
   * @throws NullPointerException if `fromKey` is null and
   *         this map does not permit null keys
   * @throws IllegalArgumentException if this map itself has a
   *         restricted range, and `fromKey` lies outside the
   *         bounds of the range
  */
  tailMap(fromKey: K): SortedMap<K, V>;
  /**
   * Returns the first (lowest) key currently in this map.
   *
   * @return the first (lowest) key currently in this map
   * @throws NoSuchElementException if this map is empty
  */
  firstKey(): K;
  /**
   * Returns the last (highest) key currently in this map.
   *
   * @return the last (highest) key currently in this map
   * @throws NoSuchElementException if this map is empty
  */
  lastKey(): K;
  /**
   * Returns a {@link Set} view of the keys contained in this map.
   * The set's iterator returns the keys in ascending order.
   * The set is backed by the map, so changes to the map are
   * reflected in the set, and vice-versa.  If the map is modified
   * while an iteration over the set is in progress (except through
   * the iterator's own `remove` operation), the results of
   * the iteration are undefined.  The set supports element removal,
   * which removes the corresponding mapping from the map, via the
   * `Iterator.remove`, `Set.remove`,
   * `removeAll`, `retainAll`, and `clear`
   * operations.  It does not support the `add` or `addAll`
   * operations.
   *
   * @return a set view of the keys contained in this map, sorted in
   *         ascending order
  */
  keySet(): Set<K>;
  /**
   * Returns a {@link Collection} view of the values contained in this map.
   * The collection's iterator returns the values in ascending order
   * of the corresponding keys.
   * The collection is backed by the map, so changes to the map are
   * reflected in the collection, and vice-versa.  If the map is
   * modified while an iteration over the collection is in progress
   * (except through the iterator's own `remove` operation),
   * the results of the iteration are undefined.  The collection
   * supports element removal, which removes the corresponding
   * mapping from the map, via the `Iterator.remove`,
   * `Collection.remove`, `removeAll`,
   * `retainAll` and `clear` operations.  It does not
   * support the `add` or `addAll` operations.
   *
   * @return a collection view of the values contained in this map,
   *         sorted in ascending key order
  */
  values(): Collection<V>;
  /**
   * Returns a {@link Set} view of the mappings contained in this map.
   * The set's iterator returns the entries in ascending key order.
   * The set is backed by the map, so changes to the map are
   * reflected in the set, and vice-versa.  If the map is modified
   * while an iteration over the set is in progress (except through
   * the iterator's own `remove` operation, or through the
   * `setValue` operation on a map entry returned by the
   * iterator) the results of the iteration are undefined.  The set
   * supports element removal, which removes the corresponding
   * mapping from the map, via the `Iterator.remove`,
   * `Set.remove`, `removeAll`, `retainAll` and
   * `clear` operations.  It does not support the
   * `add` or `addAll` operations.
   *
   * @return a set view of the mappings contained in this map,
   *         sorted in ascending key order
  */
  entrySet(): Set<java_util_Map_Entry<K, V>>;
}
/**
 * The `Formattable` interface must be implemented by any class that
 * needs to perform custom formatting using the `'s'` conversion
 * specifier of {@link java.util.Formatter}.  This interface allows basic
 * control for formatting arbitrary objects.
 *
 * For example, the following class prints out different representations of a
 * stock's name depending on the flags and length constraints:
 *
 *  {@code
 *   import java.nio.CharBuffer;
 *   import java.util.Formatter;
 *   import java.util.Formattable;
 *   import java.util.Locale;
 *   import static java.util.FormattableFlags.*;
 *
 *   ...
 *
 *   public class StockName implements Formattable {
 *       private String symbol, companyName, frenchCompanyName;
 *       public StockName(String symbol, String companyName,
 *                        String frenchCompanyName) {
 *           ...
 *       }
 *
 *       ...
 *
 *       public void formatTo(Formatter fmt, int f, int width, int precision) {
 *           StringBuilder sb = new StringBuilder();
 *
 *           // decide form of name
 *           String name = companyName;
 *           if (fmt.locale().equals(Locale.FRANCE))
 *               name = frenchCompanyName;
 *           boolean alternate = (f & ALTERNATE) == ALTERNATE;
 *           boolean usesymbol = alternate || (precision != -1 && precision < 10);
 *           String out = (usesymbol ? symbol : name);
 *
 *           // apply precision
 *           if (precision == -1 || out.length() < precision) {
 *               // write it all
 *               sb.append(out);
 *           } else {
 *               sb.append(out.substring(0, precision - 1)).append('*');
 *           }
 *
 *           // apply width and justification
 *           int len = sb.length();
 *           if (len < width)
 *               for (int i = 0; i < width - len; i++)
 *                   if ((f & LEFT_JUSTIFY) == LEFT_JUSTIFY)
 *                       sb.append(' ');
 *                   else
 *                       sb.insert(0, ' ');
 *
 *           fmt.format(sb.toString());
 *       }
 *
 *       public String toString() {
 *           return String.format("%s - %s", symbol, companyName);
 *       }
 *   }
 * }
 *
 *  When used in conjunction with the {@link java.util.Formatter}, the above
 * class produces the following output for various format strings.
 *
 *  {@code
 *   Formatter fmt = new Formatter();
 *   StockName sn = new StockName("HUGE", "Huge Fruit, Inc.",
 *                                "Fruit Titanesque, Inc.");
 *   fmt.format("%s", sn);                   //   -> "Huge Fruit, Inc."
 *   fmt.format("%s", sn.toString());        //   -> "HUGE - Huge Fruit, Inc."
 *   fmt.format("%#s", sn);                  //   -> "HUGE"
 *   fmt.format("%-10.8s", sn);              //   -> "HUGE      "
 *   fmt.format("%.12s", sn);                //   -> "Huge Fruit,*"
 *   fmt.format(Locale.FRANCE, "%25s", sn);  //   -> "   Fruit Titanesque, Inc."
 * }
 *
 *  Formattables are not necessarily safe for multithreaded access.  Thread
 * safety is optional and may be enforced by classes that extend and implement
 * this interface.
 *
 *  Unless otherwise specified, passing a `null` argument to
 * any method in this interface will cause a {@link
 * NullPointerException} to be thrown.
 *
 * @since  1.5
*/
export class Formattable {
  /**
   * Formats the object using the provided {@link Formatter formatter}.
   *
   * @param  formatter
   *         The {@link Formatter formatter}.  Implementing classes may call
   *         {@link Formatter#out() formatter.out()} or {@link
   *         Formatter#locale() formatter.locale()} to obtain the {@link
   *         Appendable} or {@link Locale} used by this
   *         `formatter` respectively.
   *
   * @param  flags
   *         The flags modify the output format.  The value is interpreted as
   *         a bitmask.  Any combination of the following flags may be set:
   *         {@link FormattableFlags#LEFT_JUSTIFY}, {@link
   *         FormattableFlags#UPPERCASE}, and {@link
   *         FormattableFlags#ALTERNATE}.  If no flags are set, the default
   *         formatting of the implementing class will apply.
   *
   * @param  width
   *         The minimum number of characters to be written to the output.
   *         If the length of the converted value is less than the
   *         `width` then the output will be padded by
   *         '  ' until the total number of characters
   *         equals width.  The padding is at the beginning by default.  If
   *         the {@link FormattableFlags#LEFT_JUSTIFY} flag is set then the
   *         padding will be at the end.  If `width` is `-1`
   *         then there is no minimum.
   *
   * @param  precision
   *         The maximum number of characters to be written to the output.
   *         The precision is applied before the width, thus the output will
   *         be truncated to `precision` characters even if the
   *         `width` is greater than the `precision`.  If
   *         `precision` is `-1` then there is no explicit
   *         limit on the number of characters.
   *
   * @throws  IllegalFormatException
   *          If any of the parameters are invalid.  For specification of all
   *          possible formatting errors, see the Details section of the
   *          formatter class specification.
  */
  formatTo(formatter: Formatter, flags: number, width: number, precision: number): void;
}
export class AbstractSet<E> extends AbstractCollection<E> {
  /**
   * Compares the specified object with this set for equality.  Returns
   * `true` if the given object is also a set, the two sets have
   * the same size, and every member of the given set is contained in
   * this set.  This ensures that the `equals` method works
   * properly across different implementations of the `Set`
   * interface.
   *
   * This implementation first checks if the specified object is this
   * set; if so it returns `true`.  Then, it checks if the
   * specified object is a set whose size is identical to the size of
   * this set; if not, it returns false.  If so, it returns
   * `containsAll((Collection) o)`.
   *
   * @param o object to be compared for equality with this set
   * @return `true` if the specified object is equal to this set
  */
  equals(o: any): boolean;
  /**
   * Returns the hash code value for this set.  The hash code of a set is
   * defined to be the sum of the hash codes of the elements in the set,
   * where the hash code of a `null` element is defined to be zero.
   * This ensures that `s1.equals(s2)` implies that
   * `s1.hashCode()==s2.hashCode()` for any two sets `s1`
   * and `s2`, as required by the general contract of
   * {@link Object#hashCode}.
   *
   * This implementation iterates over the set, calling the
   * `hashCode` method on each element in the set, and adding up
   * the results.
   *
   * @return the hash code value for this set
   * @see Object#equals(Object)
   * @see Set#equals(Object)
  */
  hashCode(): number;
  /**
   * Removes from this set all of its elements that are contained in the
   * specified collection (optional operation).  If the specified
   * collection is also a set, this operation effectively modifies this
   * set so that its value is the asymmetric set difference of
   * the two sets.
   *
   * This implementation determines which is the smaller of this set
   * and the specified collection, by invoking the `size`
   * method on each.  If this set has fewer elements, then the
   * implementation iterates over this set, checking each element
   * returned by the iterator in turn to see if it is contained in
   * the specified collection.  If it is so contained, it is removed
   * from this set with the iterator's `remove` method.  If
   * the specified collection has fewer elements, then the
   * implementation iterates over the specified collection, removing
   * from this set each element returned by the iterator, using this
   * set's `remove` method.
   *
   * Note that this implementation will throw an
   * `UnsupportedOperationException` if the iterator returned by the
   * `iterator` method does not implement the `remove` method.
   *
   * @param  c collection containing elements to be removed from this set
   * @return `true` if this set changed as a result of the call
   * @throws UnsupportedOperationException if the `removeAll` operation
   *         is not supported by this set
   * @throws ClassCastException if the class of an element of this set
   *         is incompatible with the specified collection
   * (optional)
   * @throws NullPointerException if this set contains a null element and the
   *         specified collection does not permit null elements
   * (optional),
   *         or if the specified collection is null
   * @see #remove(Object)
   * @see #contains(Object)
  */
  removeAll(c: Collection<any>): boolean;
}
export interface AbstractSet<E> extends AbstractCollection<E>, Set<E> {}
/**
 * A linear collection that supports element insertion and removal at
 * both ends.  The name deque is short for "double ended queue"
 * and is usually pronounced "deck".  Most `Deque`
 * implementations place no fixed limits on the number of elements
 * they may contain, but this interface supports capacity-restricted
 * deques as well as those with no fixed size limit.
 *
 * This interface defines methods to access the elements at both
 * ends of the deque.  Methods are provided to insert, remove, and
 * examine the element.  Each of these methods exists in two forms:
 * one throws an exception if the operation fails, the other returns a
 * special value (either `null` or `false`, depending on
 * the operation).  The latter form of the insert operation is
 * designed specifically for use with capacity-restricted
 * `Deque` implementations; in most implementations, insert
 * operations cannot fail.
 *
 * The twelve methods described above are summarized in the
 * following table:
 *
 * 
 * Summary of Deque methods
 *  
 *  
 *    
 *     First Element (Head)
 *     Last Element (Tail)
 *  
 *  
 *    Throws exception
 *    Special value
 *    Throws exception
 *    Special value
 *  
 *  
 *  
 *  
 *    Insert
 *    {@link #addFirst(Object) addFirst(e)}
 *    {@link #offerFirst(Object) offerFirst(e)}
 *    {@link #addLast(Object) addLast(e)}
 *    {@link #offerLast(Object) offerLast(e)}
 *  
 *  
 *    Remove
 *    {@link #removeFirst() removeFirst()}
 *    {@link #pollFirst() pollFirst()}
 *    {@link #removeLast() removeLast()}
 *    {@link #pollLast() pollLast()}
 *  
 *  
 *    Examine
 *    {@link #getFirst() getFirst()}
 *    {@link #peekFirst() peekFirst()}
 *    {@link #getLast() getLast()}
 *    {@link #peekLast() peekLast()}
 *  
 *  
 * 
 *
 * This interface extends the {@link Queue} interface.  When a deque is
 * used as a queue, FIFO (First-In-First-Out) behavior results.  Elements are
 * added at the end of the deque and removed from the beginning.  The methods
 * inherited from the `Queue` interface are precisely equivalent to
 * `Deque` methods as indicated in the following table:
 *
 * 
 * Comparison of Queue and Deque methods
 *  
 *  
 *     `Queue` Method
 *     Equivalent `Deque` Method
 *  
 *  
 *  
 *  
 *    {@link #add(Object) add(e)}
 *    {@link #addLast(Object) addLast(e)}
 *  
 *  
 *    {@link #offer(Object) offer(e)}
 *    {@link #offerLast(Object) offerLast(e)}
 *  
 *  
 *    {@link #remove() remove()}
 *    {@link #removeFirst() removeFirst()}
 *  
 *  
 *    {@link #poll() poll()}
 *    {@link #pollFirst() pollFirst()}
 *  
 *  
 *    {@link #element() element()}
 *    {@link #getFirst() getFirst()}
 *  
 *  
 *    {@link #peek() peek()}
 *    {@link #peekFirst() peekFirst()}
 *  
 *  
 * 
 *
 * Deques can also be used as LIFO (Last-In-First-Out) stacks.  This
 * interface should be used in preference to the legacy {@link Stack} class.
 * When a deque is used as a stack, elements are pushed and popped from the
 * beginning of the deque.  Stack methods are equivalent to `Deque`
 * methods as indicated in the table below:
 *
 * 
 * Comparison of Stack and Deque methods
 *  
 *  
 *     Stack Method
 *     Equivalent `Deque` Method
 *  
 *  
 *  
 *  
 *    {@link #push(Object) push(e)}
 *    {@link #addFirst(Object) addFirst(e)}
 *  
 *  
 *    {@link #pop() pop()}
 *    {@link #removeFirst() removeFirst()}
 *  
 *  
 *    {@link #peek() peek()}
 *    {@link #getFirst() getFirst()}
 *  
 *  
 * 
 *
 * Note that the {@link #peek peek} method works equally well when
 * a deque is used as a queue or a stack; in either case, elements are
 * drawn from the beginning of the deque.
 *
 * This interface provides two methods to remove interior
 * elements, {@link #removeFirstOccurrence removeFirstOccurrence} and
 * {@link #removeLastOccurrence removeLastOccurrence}.
 *
 * Unlike the {@link List} interface, this interface does not
 * provide support for indexed access to elements.
 *
 * While `Deque` implementations are not strictly required
 * to prohibit the insertion of null elements, they are strongly
 * encouraged to do so.  Users of any `Deque` implementations
 * that do allow null elements are strongly encouraged not to
 * take advantage of the ability to insert nulls.  This is so because
 * `null` is used as a special return value by various methods
 * to indicate that the deque is empty.
 *
 * `Deque` implementations generally do not define
 * element-based versions of the `equals` and `hashCode`
 * methods, but instead inherit the identity-based versions from class
 * `Object`.
 *
 * This interface is a member of the
 * 
 * Java Collections Framework.
 *
 * @author Doug Lea
 * @author Josh Bloch
 * @since  1.6
 * @param  the type of elements held in this deque
*/
export class Deque<E> extends Queue<E> {
  /**
   * Inserts the specified element at the front of this deque if it is
   * possible to do so immediately without violating capacity restrictions,
   * throwing an `IllegalStateException` if no space is currently
   * available.  When using a capacity-restricted deque, it is generally
   * preferable to use method {@link #offerFirst}.
   *
   * @param e the element to add
   * @throws IllegalStateException if the element cannot be added at this
   *         time due to capacity restrictions
   * @throws ClassCastException if the class of the specified element
   *         prevents it from being added to this deque
   * @throws NullPointerException if the specified element is null and this
   *         deque does not permit null elements
   * @throws IllegalArgumentException if some property of the specified
   *         element prevents it from being added to this deque
  */
  addFirst(e: E): void;
  /**
   * Inserts the specified element at the end of this deque if it is
   * possible to do so immediately without violating capacity restrictions,
   * throwing an `IllegalStateException` if no space is currently
   * available.  When using a capacity-restricted deque, it is generally
   * preferable to use method {@link #offerLast}.
   *
   * This method is equivalent to {@link #add}.
   *
   * @param e the element to add
   * @throws IllegalStateException if the element cannot be added at this
   *         time due to capacity restrictions
   * @throws ClassCastException if the class of the specified element
   *         prevents it from being added to this deque
   * @throws NullPointerException if the specified element is null and this
   *         deque does not permit null elements
   * @throws IllegalArgumentException if some property of the specified
   *         element prevents it from being added to this deque
  */
  addLast(e: E): void;
  /**
   * Inserts the specified element at the front of this deque unless it would
   * violate capacity restrictions.  When using a capacity-restricted deque,
   * this method is generally preferable to the {@link #addFirst} method,
   * which can fail to insert an element only by throwing an exception.
   *
   * @param e the element to add
   * @return `true` if the element was added to this deque, else
   *         `false`
   * @throws ClassCastException if the class of the specified element
   *         prevents it from being added to this deque
   * @throws NullPointerException if the specified element is null and this
   *         deque does not permit null elements
   * @throws IllegalArgumentException if some property of the specified
   *         element prevents it from being added to this deque
  */
  offerFirst(e: E): boolean;
  /**
   * Inserts the specified element at the end of this deque unless it would
   * violate capacity restrictions.  When using a capacity-restricted deque,
   * this method is generally preferable to the {@link #addLast} method,
   * which can fail to insert an element only by throwing an exception.
   *
   * @param e the element to add
   * @return `true` if the element was added to this deque, else
   *         `false`
   * @throws ClassCastException if the class of the specified element
   *         prevents it from being added to this deque
   * @throws NullPointerException if the specified element is null and this
   *         deque does not permit null elements
   * @throws IllegalArgumentException if some property of the specified
   *         element prevents it from being added to this deque
  */
  offerLast(e: E): boolean;
  /**
   * Retrieves and removes the first element of this deque.  This method
   * differs from {@link #pollFirst pollFirst} only in that it throws an
   * exception if this deque is empty.
   *
   * @return the head of this deque
   * @throws NoSuchElementException if this deque is empty
  */
  removeFirst(): E;
  /**
   * Retrieves and removes the last element of this deque.  This method
   * differs from {@link #pollLast pollLast} only in that it throws an
   * exception if this deque is empty.
   *
   * @return the tail of this deque
   * @throws NoSuchElementException if this deque is empty
  */
  removeLast(): E;
  /**
   * Retrieves and removes the first element of this deque,
   * or returns `null` if this deque is empty.
   *
   * @return the head of this deque, or `null` if this deque is empty
  */
  pollFirst(): E;
  /**
   * Retrieves and removes the last element of this deque,
   * or returns `null` if this deque is empty.
   *
   * @return the tail of this deque, or `null` if this deque is empty
  */
  pollLast(): E;
  /**
   * Retrieves, but does not remove, the first element of this deque.
   *
   * This method differs from {@link #peekFirst peekFirst} only in that it
   * throws an exception if this deque is empty.
   *
   * @return the head of this deque
   * @throws NoSuchElementException if this deque is empty
  */
  getFirst(): E;
  /**
   * Retrieves, but does not remove, the last element of this deque.
   * This method differs from {@link #peekLast peekLast} only in that it
   * throws an exception if this deque is empty.
   *
   * @return the tail of this deque
   * @throws NoSuchElementException if this deque is empty
  */
  getLast(): E;
  /**
   * Retrieves, but does not remove, the first element of this deque,
   * or returns `null` if this deque is empty.
   *
   * @return the head of this deque, or `null` if this deque is empty
  */
  peekFirst(): E;
  /**
   * Retrieves, but does not remove, the last element of this deque,
   * or returns `null` if this deque is empty.
   *
   * @return the tail of this deque, or `null` if this deque is empty
  */
  peekLast(): E;
  /**
   * Removes the first occurrence of the specified element from this deque.
   * If the deque does not contain the element, it is unchanged.
   * More formally, removes the first element `e` such that
   * `Objects.equals(o, e)` (if such an element exists).
   * Returns `true` if this deque contained the specified element
   * (or equivalently, if this deque changed as a result of the call).
   *
   * @param o element to be removed from this deque, if present
   * @return `true` if an element was removed as a result of this call
   * @throws ClassCastException if the class of the specified element
   *         is incompatible with this deque
   * (optional)
   * @throws NullPointerException if the specified element is null and this
   *         deque does not permit null elements
   * (optional)
  */
  removeFirstOccurrence(o: any): boolean;
  /**
   * Removes the last occurrence of the specified element from this deque.
   * If the deque does not contain the element, it is unchanged.
   * More formally, removes the last element `e` such that
   * `Objects.equals(o, e)` (if such an element exists).
   * Returns `true` if this deque contained the specified element
   * (or equivalently, if this deque changed as a result of the call).
   *
   * @param o element to be removed from this deque, if present
   * @return `true` if an element was removed as a result of this call
   * @throws ClassCastException if the class of the specified element
   *         is incompatible with this deque
   * (optional)
   * @throws NullPointerException if the specified element is null and this
   *         deque does not permit null elements
   * (optional)
  */
  removeLastOccurrence(o: any): boolean;
  /**
   * Inserts the specified element into the queue represented by this deque
   * (in other words, at the tail of this deque) if it is possible to do so
   * immediately without violating capacity restrictions, returning
   * `true` upon success and throwing an
   * `IllegalStateException` if no space is currently available.
   * When using a capacity-restricted deque, it is generally preferable to
   * use {@link #offer(Object) offer}.
   *
   * This method is equivalent to {@link #addLast}.
   *
   * @param e the element to add
   * @return `true` (as specified by {@link Collection#add})
   * @throws IllegalStateException if the element cannot be added at this
   *         time due to capacity restrictions
   * @throws ClassCastException if the class of the specified element
   *         prevents it from being added to this deque
   * @throws NullPointerException if the specified element is null and this
   *         deque does not permit null elements
   * @throws IllegalArgumentException if some property of the specified
   *         element prevents it from being added to this deque
  */
  add(e: E): boolean;
  /**
   * Inserts the specified element into the queue represented by this deque
   * (in other words, at the tail of this deque) if it is possible to do so
   * immediately without violating capacity restrictions, returning
   * `true` upon success and `false` if no space is currently
   * available.  When using a capacity-restricted deque, this method is
   * generally preferable to the {@link #add} method, which can fail to
   * insert an element only by throwing an exception.
   *
   * This method is equivalent to {@link #offerLast}.
   *
   * @param e the element to add
   * @return `true` if the element was added to this deque, else
   *         `false`
   * @throws ClassCastException if the class of the specified element
   *         prevents it from being added to this deque
   * @throws NullPointerException if the specified element is null and this
   *         deque does not permit null elements
   * @throws IllegalArgumentException if some property of the specified
   *         element prevents it from being added to this deque
  */
  offer(e: E): boolean;
  /**
   * Retrieves and removes the head of the queue represented by this deque
   * (in other words, the first element of this deque).
   * This method differs from {@link #poll() poll()} only in that it
   * throws an exception if this deque is empty.
   *
   * This method is equivalent to {@link #removeFirst()}.
   *
   * @return the head of the queue represented by this deque
   * @throws NoSuchElementException if this deque is empty
  */
  remove(): E;
  /**
   * Retrieves and removes the head of the queue represented by this deque
   * (in other words, the first element of this deque), or returns
   * `null` if this deque is empty.
   *
   * This method is equivalent to {@link #pollFirst()}.
   *
   * @return the first element of this deque, or `null` if
   *         this deque is empty
  */
  poll(): E;
  /**
   * Retrieves, but does not remove, the head of the queue represented by
   * this deque (in other words, the first element of this deque).
   * This method differs from {@link #peek peek} only in that it throws an
   * exception if this deque is empty.
   *
   * This method is equivalent to {@link #getFirst()}.
   *
   * @return the head of the queue represented by this deque
   * @throws NoSuchElementException if this deque is empty
  */
  element(): E;
  /**
   * Retrieves, but does not remove, the head of the queue represented by
   * this deque (in other words, the first element of this deque), or
   * returns `null` if this deque is empty.
   *
   * This method is equivalent to {@link #peekFirst()}.
   *
   * @return the head of the queue represented by this deque, or
   *         `null` if this deque is empty
  */
  peek(): E;
  /**
   * Adds all of the elements in the specified collection at the end
   * of this deque, as if by calling {@link #addLast} on each one,
   * in the order that they are returned by the collection's iterator.
   *
   * When using a capacity-restricted deque, it is generally preferable
   * to call {@link #offer(Object) offer} separately on each element.
   *
   * An exception encountered while trying to add an element may result
   * in only some of the elements having been successfully added when
   * the associated exception is thrown.
   *
   * @param c the elements to be inserted into this deque
   * @return `true` if this deque changed as a result of the call
   * @throws IllegalStateException if not all the elements can be added at
   *         this time due to insertion restrictions
   * @throws ClassCastException if the class of an element of the specified
   *         collection prevents it from being added to this deque
   * @throws NullPointerException if the specified collection contains a
   *         null element and this deque does not permit null elements,
   *         or if the specified collection is null
   * @throws IllegalArgumentException if some property of an element of the
   *         specified collection prevents it from being added to this deque
  */
  addAll(c: Collection<E>): boolean;
  /**
   * Pushes an element onto the stack represented by this deque (in other
   * words, at the head of this deque) if it is possible to do so
   * immediately without violating capacity restrictions, throwing an
   * `IllegalStateException` if no space is currently available.
   *
   * This method is equivalent to {@link #addFirst}.
   *
   * @param e the element to push
   * @throws IllegalStateException if the element cannot be added at this
   *         time due to capacity restrictions
   * @throws ClassCastException if the class of the specified element
   *         prevents it from being added to this deque
   * @throws NullPointerException if the specified element is null and this
   *         deque does not permit null elements
   * @throws IllegalArgumentException if some property of the specified
   *         element prevents it from being added to this deque
  */
  push(e: E): void;
  /**
   * Pops an element from the stack represented by this deque.  In other
   * words, removes and returns the first element of this deque.
   *
   * This method is equivalent to {@link #removeFirst()}.
   *
   * @return the element at the front of this deque (which is the top
   *         of the stack represented by this deque)
   * @throws NoSuchElementException if this deque is empty
  */
  pop(): E;
  /**
   * Removes the first occurrence of the specified element from this deque.
   * If the deque does not contain the element, it is unchanged.
   * More formally, removes the first element `e` such that
   * `Objects.equals(o, e)` (if such an element exists).
   * Returns `true` if this deque contained the specified element
   * (or equivalently, if this deque changed as a result of the call).
   *
   * This method is equivalent to {@link #removeFirstOccurrence(Object)}.
   *
   * @param o element to be removed from this deque, if present
   * @return `true` if an element was removed as a result of this call
   * @throws ClassCastException if the class of the specified element
   *         is incompatible with this deque
   * (optional)
   * @throws NullPointerException if the specified element is null and this
   *         deque does not permit null elements
   * (optional)
  */
  remove(o: any): boolean;
  /**
   * Returns `true` if this deque contains the specified element.
   * More formally, returns `true` if and only if this deque contains
   * at least one element `e` such that `Objects.equals(o, e)`.
   *
   * @param o element whose presence in this deque is to be tested
   * @return `true` if this deque contains the specified element
   * @throws ClassCastException if the class of the specified element
   *         is incompatible with this deque
   * (optional)
   * @throws NullPointerException if the specified element is null and this
   *         deque does not permit null elements
   * (optional)
  */
  contains(o: any): boolean;
  /**
   * Returns the number of elements in this deque.
   *
   * @return the number of elements in this deque
  */
  size(): number;
  /**
   * Returns an iterator over the elements in this deque in proper sequence.
   * The elements will be returned in order from first (head) to last (tail).
   *
   * @return an iterator over the elements in this deque in proper sequence
  */
  iterator(): Iterator<E>;
  /**
   * Returns an iterator over the elements in this deque in reverse
   * sequential order.  The elements will be returned in order from
   * last (tail) to first (head).
   *
   * @return an iterator over the elements in this deque in reverse
   * sequence
  */
  descendingIterator(): Iterator<E>;
}
/**
 * A state object for collecting statistics such as count, min, max, sum, and
 * average.
 *
 * This class is designed to work with (though does not require)
 * {@linkplain java.util.stream streams}. For example, you can compute
 * summary statistics on a stream of longs with:
 *  {@code
 * LongSummaryStatistics stats = longStream.collect(LongSummaryStatistics::new,
 *                                                  LongSummaryStatistics::accept,
 *                                                  LongSummaryStatistics::combine);
 * }
 *
 * `LongSummaryStatistics` can be used as a
 * {@linkplain java.util.stream.Stream#collect(Collector) reduction}
 * target for a {@linkplain java.util.stream.Stream stream}. For example:
 *
 *  {@code
 * LongSummaryStatistics stats = people.stream()
 *                                     .collect(Collectors.summarizingLong(Person::getAge));
 *}
 *
 * This computes, in a single pass, the count of people, as well as the minimum,
 * maximum, sum, and average of their ages.
 *
 * @implNote This implementation is not thread safe. However, it is safe to use
 * {@link java.util.stream.Collectors#summarizingLong(java.util.function.ToLongFunction)
 * Collectors.summarizingLong()} on a parallel stream, because the parallel
 * implementation of {@link java.util.stream.Stream#collect Stream.collect()}
 * provides the necessary partitioning, isolation, and merging of results for
 * safe and efficient parallel execution.
 *
 * This implementation does not check for overflow of the count or the sum.
 * @since 1.8
*/
export class LongSummaryStatistics extends LongConsumer {
  /**
   * Constructs an empty instance with zero count, zero sum,
   * `Long.MAX_VALUE` min, `Long.MIN_VALUE` max and zero
   * average.
  */
  constructor();
  /**
   * Constructs a non-empty instance with the specified `count`,
   * `min`, `max`, and `sum`.
   *
   * If `count` is zero then the remaining arguments are ignored and
   * an empty instance is constructed.
   *
   * If the arguments are inconsistent then an `IllegalArgumentException`
   * is thrown.  The necessary consistent argument conditions are:
   * 
   *   `count >= 0`
   *   `min <= max`
   * 
   * @apiNote
   * The enforcement of argument correctness means that the retrieved set of
   * recorded values obtained from a `LongSummaryStatistics` source
   * instance may not be a legal set of arguments for this constructor due to
   * arithmetic overflow of the source's recorded count of values.
   * The consistent argument conditions are not sufficient to prevent the
   * creation of an internally inconsistent instance.  An example of such a
   * state would be an instance with: `count` = 2, `min` = 1,
   * `max` = 2, and `sum` = 0.
   *
   * @param count the count of values
   * @param min the minimum value
   * @param max the maximum value
   * @param sum the sum of all values
   * @throws IllegalArgumentException if the arguments are inconsistent
   * @since 10
  */
  constructor(count: number, min: number, max: number, sum: number);
  /**
   * Records a new `int` value into the summary information.
   *
   * @param value the input value
  */
  accept(value: number): void;
  /**
   * Combines the state of another `LongSummaryStatistics` into this
   * one.
   *
   * @param other another `LongSummaryStatistics`
   * @throws NullPointerException if `other` is null
  */
  combine(other: LongSummaryStatistics): void;
  /**
   * Returns the count of values recorded.
   *
   * @return the count of values
  */
  getCount(): number;
  /**
   * Returns the sum of values recorded, or zero if no values have been
   * recorded.
   *
   * @return the sum of values, or zero if none
  */
  getSum(): number;
  /**
   * Returns the minimum value recorded, or `Long.MAX_VALUE` if no
   * values have been recorded.
   *
   * @return the minimum value, or `Long.MAX_VALUE` if none
  */
  getMin(): number;
  /**
   * Returns the maximum value recorded, or `Long.MIN_VALUE` if no
   * values have been recorded
   *
   * @return the maximum value, or `Long.MIN_VALUE` if none
  */
  getMax(): number;
  /**
   * Returns the arithmetic mean of values recorded, or zero if no values have been
   * recorded.
   *
   * @return The arithmetic mean of values, or zero if none
  */
  getAverage(): number;
  /**
   * Returns a non-empty string representation of this object suitable for
   * debugging. The exact presentation format is unspecified and may vary
   * between implementations and versions.
  */
  toString(): string;
}
export interface LongSummaryStatistics extends LongConsumer, IntConsumer {}
/**
 * `ListResourceBundle` is an abstract subclass of
 * `ResourceBundle` that manages resources for a locale
 * in a convenient and easy to use list. See `ResourceBundle` for
 * more information about resource bundles in general.
 *
 * 
 * Subclasses must override `getContents` and provide an array,
 * where each item in the array is a pair of objects.
 * The first element of each pair is the key, which must be a
 * `String`, and the second element is the value associated with
 * that key.
 *
 * 
 * The following example shows two members of a resource
 * bundle family with the base name "MyResources".
 * "MyResources" is the default member of the bundle family, and
 * "MyResources_fr" is the French member.
 * These members are based on `ListResourceBundle`
 * (a related example shows
 * how you can add a bundle to this family that's based on a properties file).
 * The keys in this example are of the form "s1" etc. The actual
 * keys are entirely up to your choice, so long as they are the same as
 * the keys you use in your program to retrieve the objects from the bundle.
 * Keys are case-sensitive.
 * 
 *  *
 * public class MyResources extends ListResourceBundle {
 *     protected Object[][] getContents() {
 *         return new Object[][] {
 *         // LOCALIZE THIS
 *             {"s1", "The disk \"{1}\" contains {0}."},  // MessageFormat pattern
 *             {"s2", "1"},                               // location of {0} in pattern
 *             {"s3", "My Disk"},                         // sample disk name
 *             {"s4", "no files"},                        // first ChoiceFormat choice
 *             {"s5", "one file"},                        // second ChoiceFormat choice
 *             {"s6", "{0,number} files"},                // third ChoiceFormat choice
 *             {"s7", "3 Mar 96"},                        // sample date
 *             {"s8", new Dimension(1,5)}                 // real object, not just string
 *         // END OF MATERIAL TO LOCALIZE
 *         };
 *     }
 * }
 *
 * public class MyResources_fr extends ListResourceBundle {
 *     protected Object[][] getContents() {
 *         return new Object[][] {
 *         // LOCALIZE THIS
 *             {"s1", "Le disque \"{1}\" {0}."},          // MessageFormat pattern
 *             {"s2", "1"},                               // location of {0} in pattern
 *             {"s3", "Mon disque"},                      // sample disk name
 *             {"s4", "ne contient pas de fichiers"},     // first ChoiceFormat choice
 *             {"s5", "contient un fichier"},             // second ChoiceFormat choice
 *             {"s6", "contient {0,number} fichiers"},    // third ChoiceFormat choice
 *             {"s7", "3 mars 1996"},                     // sample date
 *             {"s8", new Dimension(1,3)}                 // real object, not just string
 *         // END OF MATERIAL TO LOCALIZE
 *         };
 *     }
 * }
 * 
 * 
 *
 * 
 * The implementation of a `ListResourceBundle` subclass must be thread-safe
 * if it's simultaneously used by multiple threads. The default implementations
 * of the methods in this class are thread-safe.
 *
 * @see ResourceBundle
 * @see PropertyResourceBundle
 * @since 1.1
*/
export class ListResourceBundle extends ResourceBundle {
  /**
   * Sole constructor.  (For invocation by subclass constructors, typically
   * implicit.)
  */
  constructor();
  handleGetObject(key: string): any;
  /**
   * Returns an `Enumeration` of the keys contained in
   * this `ResourceBundle` and its parent bundles.
   *
   * @return an `Enumeration` of the keys contained in
   *         this `ResourceBundle` and its parent bundles.
   * @see #keySet()
  */
  getKeys(): Enumeration<string>;
}
/**
 * This class represents an observable object, or "data"
 * in the model-view paradigm. It can be subclassed to represent an
 * object that the application wants to have observed.
 * 
 * An observable object can have one or more observers. An observer
 * may be any object that implements interface `Observer`. After an
 * observable instance changes, an application calling the
 * `Observable`'s `notifyObservers` method
 * causes all of its observers to be notified of the change by a call
 * to their `update` method.
 * 
 * The order in which notifications will be delivered is unspecified.
 * The default implementation provided in the Observable class will
 * notify Observers in the order in which they registered interest, but
 * subclasses may change this order, use no guaranteed order, deliver
 * notifications on separate threads, or may guarantee that their
 * subclass follows this order, as they choose.
 * 
 * Note that this notification mechanism has nothing to do with threads
 * and is completely separate from the `wait` and `notify`
 * mechanism of class `Object`.
 * 
 * When an observable object is newly created, its set of observers is
 * empty. Two observers are considered the same if and only if the
 * `equals` method returns true for them.
 *
 * @author  Chris Warth
 * @see     java.util.Observable#notifyObservers()
 * @see     java.util.Observable#notifyObservers(java.lang.Object)
 * @see     java.util.Observer
 * @see     java.util.Observer#update(java.util.Observable, java.lang.Object)
 * @since   1.0
 *
 * @deprecated
 * This class and the {@link Observer} interface have been deprecated.
 * The event model supported by `Observer` and `Observable`
 * is quite limited, the order of notifications delivered by
 * `Observable` is unspecified, and state changes are not in
 * one-for-one correspondence with notifications.
 * For a richer event model, consider using the
 * {@link java.beans} package.  For reliable and ordered
 * messaging among threads, consider using one of the concurrent data
 * structures in the {@link java.util.concurrent} package.
 * For reactive streams style programming, see the
 * {@link java.util.concurrent.Flow} API.
*/
export class Observable {
  constructor();
  /**
   * Adds an observer to the set of observers for this object, provided
   * that it is not the same as some observer already in the set.
   * The order in which notifications will be delivered to multiple
   * observers is not specified. See the class comment.
   *
   * @param   o   an observer to be added.
   * @throws NullPointerException   if the parameter o is null.
  */
  addObserver(o: Observer): void;
  /**
   * Deletes an observer from the set of observers of this object.
   * Passing `null` to this method will have no effect.
   * @param   o   the observer to be deleted.
  */
  deleteObserver(o: Observer): void;
  /**
   * If this object has changed, as indicated by the
   * `hasChanged` method, then notify all of its observers
   * and then call the `clearChanged` method to
   * indicate that this object has no longer changed.
   * 
   * Each observer has its `update` method called with two
   * arguments: this observable object and `null`. In other
   * words, this method is equivalent to:
   * `     * notifyObservers(null)`
   *
   * @see     java.util.Observable#clearChanged()
   * @see     java.util.Observable#hasChanged()
   * @see     java.util.Observer#update(java.util.Observable, java.lang.Object)
  */
  notifyObservers(): void;
  /**
   * If this object has changed, as indicated by the
   * `hasChanged` method, then notify all of its observers
   * and then call the `clearChanged` method to indicate
   * that this object has no longer changed.
   * 
   * Each observer has its `update` method called with two
   * arguments: this observable object and the `arg` argument.
   *
   * @param   arg   any object.
   * @see     java.util.Observable#clearChanged()
   * @see     java.util.Observable#hasChanged()
   * @see     java.util.Observer#update(java.util.Observable, java.lang.Object)
  */
  notifyObservers(arg: any): void;
  /**
   * Clears the observer list so that this object no longer has any observers.
  */
  deleteObservers(): void;
  /**
   * Tests if this object has changed.
   *
   * @return  `true` if and only if the `setChanged`
   *          method has been called more recently than the
   *          `clearChanged` method on this object;
   *          `false` otherwise.
   * @see     java.util.Observable#clearChanged()
   * @see     java.util.Observable#setChanged()
  */
  hasChanged(): boolean;
  /**
   * Returns the number of observers of this `Observable` object.
   *
   * @return  the number of observers of this object.
  */
  countObservers(): number;
}
/**
 * Thrown by a `Scanner` to indicate that the token
 * retrieved does not match the pattern for the expected type, or
 * that the token is out of range for the expected type.
 *
 * @see     java.util.Scanner
 * @since   1.5
*/
export class InputMismatchException extends NoSuchElementException {
  /**
   * Constructs an `InputMismatchException` with `null`
   * as its error message string.
  */
  constructor();
  /**
   * Constructs an `InputMismatchException`, saving a reference
   * to the error message string `s` for later retrieval by the
   * `getMessage` method.
   *
   * @param   s   the detail message.
  */
  constructor(s: string);
}
/**
 * An object that maps keys to values.  A map cannot contain duplicate keys;
 * each key can map to at most one value.
 *
 * This interface takes the place of the `Dictionary` class, which
 * was a totally abstract class rather than an interface.
 *
 * The `Map` interface provides three collection views, which
 * allow a map's contents to be viewed as a set of keys, collection of values,
 * or set of key-value mappings.  The order of a map is defined as
 * the order in which the iterators on the map's collection views return their
 * elements.  Some map implementations, like the `TreeMap` class, make
 * specific guarantees as to their order; others, like the `HashMap`
 * class, do not.
 *
 * Note: great care must be exercised if mutable objects are used as map
 * keys.  The behavior of a map is not specified if the value of an object is
 * changed in a manner that affects `equals` comparisons while the
 * object is a key in the map.  A special case of this prohibition is that it
 * is not permissible for a map to contain itself as a key.  While it is
 * permissible for a map to contain itself as a value, extreme caution is
 * advised: the `equals` and `hashCode` methods are no longer
 * well defined on such a map.
 *
 * All general-purpose map implementation classes should provide two
 * "standard" constructors: a void (no arguments) constructor which creates an
 * empty map, and a constructor with a single argument of type `Map`,
 * which creates a new map with the same key-value mappings as its argument.
 * In effect, the latter constructor allows the user to copy any map,
 * producing an equivalent map of the desired class.  There is no way to
 * enforce this recommendation (as interfaces cannot contain constructors) but
 * all of the general-purpose map implementations in the JDK comply.
 *
 * The "destructive" methods contained in this interface, that is, the
 * methods that modify the map on which they operate, are specified to throw
 * `UnsupportedOperationException` if this map does not support the
 * operation.  If this is the case, these methods may, but are not required
 * to, throw an `UnsupportedOperationException` if the invocation would
 * have no effect on the map.  For example, invoking the {@link #putAll(Map)}
 * method on an unmodifiable map may, but is not required to, throw the
 * exception if the map whose mappings are to be "superimposed" is empty.
 *
 * Some map implementations have restrictions on the keys and values they
 * may contain.  For example, some implementations prohibit null keys and
 * values, and some have restrictions on the types of their keys.  Attempting
 * to insert an ineligible key or value throws an unchecked exception,
 * typically `NullPointerException` or `ClassCastException`.
 * Attempting to query the presence of an ineligible key or value may throw an
 * exception, or it may simply return false; some implementations will exhibit
 * the former behavior and some will exhibit the latter.  More generally,
 * attempting an operation on an ineligible key or value whose completion
 * would not result in the insertion of an ineligible element into the map may
 * throw an exception or it may succeed, at the option of the implementation.
 * Such exceptions are marked as "optional" in the specification for this
 * interface.
 *
 * Many methods in Collections Framework interfaces are defined
 * in terms of the {@link Object#equals(Object) equals} method.  For
 * example, the specification for the {@link #containsKey(Object)
 * containsKey(Object key)} method says: "returns `true` if and
 * only if this map contains a mapping for a key `k` such that
 * `(key==null ? k==null : key.equals(k))`." This specification should
 * not be construed to imply that invoking `Map.containsKey`
 * with a non-null argument `key` will cause `key.equals(k)` to
 * be invoked for any key `k`.  Implementations are free to
 * implement optimizations whereby the `equals` invocation is avoided,
 * for example, by first comparing the hash codes of the two keys.  (The
 * {@link Object#hashCode()} specification guarantees that two objects with
 * unequal hash codes cannot be equal.)  More generally, implementations of
 * the various Collections Framework interfaces are free to take advantage of
 * the specified behavior of underlying {@link Object} methods wherever the
 * implementor deems it appropriate.
 *
 * Some map operations which perform recursive traversal of the map may fail
 * with an exception for self-referential instances where the map directly or
 * indirectly contains itself. This includes the `clone()`,
 * `equals()`, `hashCode()` and `toString()` methods.
 * Implementations may optionally handle the self-referential scenario, however
 * most current implementations do not do so.
 *
 * Unmodifiable Maps
 * The {@link Map#of() Map.of},
 * {@link Map#ofEntries(Map.Entry...) Map.ofEntries}, and
 * {@link Map#copyOf Map.copyOf}
 * static factory methods provide a convenient way to create unmodifiable maps.
 * The `Map`
 * instances created by these methods have the following characteristics:
 *
 * 
 * They are unmodifiable. Keys and values
 * cannot be added, removed, or updated. Calling any mutator method on the Map
 * will always cause `UnsupportedOperationException` to be thrown.
 * However, if the contained keys or values are themselves mutable, this may cause the
 * Map to behave inconsistently or its contents to appear to change.
 * They disallow `null` keys and values. Attempts to create them with
 * `null` keys or values result in `NullPointerException`.
 * They are serializable if all keys and values are serializable.
 * They reject duplicate keys at creation time. Duplicate keys
 * passed to a static factory method result in `IllegalArgumentException`.
 * The iteration order of mappings is unspecified and is subject to change.
 * They are value-based.
 * Programmers should treat instances that are {@linkplain #equals(Object) equal}
 * as interchangeable and should not use them for synchronization, or
 * unpredictable behavior may occur. For example, in a future release,
 * synchronization may fail. Callers should make no assumptions
 * about the identity of the returned instances. Factories are free to
 * create new instances or reuse existing ones.
 * They are serialized as specified on the
 * Serialized Form
 * page.
 * 
 *
 * This interface is a member of the
 * 
 * Java Collections Framework.
 *
 * @param  the type of keys maintained by this map
 * @param  the type of mapped values
 *
 * @author  Josh Bloch
 * @see HashMap
 * @see TreeMap
 * @see Hashtable
 * @see SortedMap
 * @see Collection
 * @see Set
 * @since 1.2
*/
export class Map<K, V> {
  /**
   * Returns the number of key-value mappings in this map.  If the
   * map contains more than `Integer.MAX_VALUE` elements, returns
   * `Integer.MAX_VALUE`.
   *
   * @return the number of key-value mappings in this map
  */
  size(): number;
  /**
   * Returns `true` if this map contains no key-value mappings.
   *
   * @return `true` if this map contains no key-value mappings
  */
  isEmpty(): boolean;
  /**
   * Returns `true` if this map contains a mapping for the specified
   * key.  More formally, returns `true` if and only if
   * this map contains a mapping for a key `k` such that
   * `Objects.equals(key, k)`.  (There can be
   * at most one such mapping.)
   *
   * @param key key whose presence in this map is to be tested
   * @return `true` if this map contains a mapping for the specified
   *         key
   * @throws ClassCastException if the key is of an inappropriate type for
   *         this map
   * (optional)
   * @throws NullPointerException if the specified key is null and this map
   *         does not permit null keys
   * (optional)
  */
  containsKey(key: any): boolean;
  /**
   * Returns `true` if this map maps one or more keys to the
   * specified value.  More formally, returns `true` if and only if
   * this map contains at least one mapping to a value `v` such that
   * `Objects.equals(value, v)`.  This operation
   * will probably require time linear in the map size for most
   * implementations of the `Map` interface.
   *
   * @param value value whose presence in this map is to be tested
   * @return `true` if this map maps one or more keys to the
   *         specified value
   * @throws ClassCastException if the value is of an inappropriate type for
   *         this map
   * (optional)
   * @throws NullPointerException if the specified value is null and this
   *         map does not permit null values
   * (optional)
  */
  containsValue(value: any): boolean;
  /**
   * Returns the value to which the specified key is mapped,
   * or `null` if this map contains no mapping for the key.
   *
   * More formally, if this map contains a mapping from a key
   * `k` to a value `v` such that
   * `Objects.equals(key, k)`,
   * then this method returns `v`; otherwise
   * it returns `null`.  (There can be at most one such mapping.)
   *
   * If this map permits null values, then a return value of
   * `null` does not necessarily indicate that the map
   * contains no mapping for the key; it's also possible that the map
   * explicitly maps the key to `null`.  The {@link #containsKey
   * containsKey} operation may be used to distinguish these two cases.
   *
   * @param key the key whose associated value is to be returned
   * @return the value to which the specified key is mapped, or
   *         `null` if this map contains no mapping for the key
   * @throws ClassCastException if the key is of an inappropriate type for
   *         this map
   * (optional)
   * @throws NullPointerException if the specified key is null and this map
   *         does not permit null keys
   * (optional)
  */
  get(key: any): V;
  /**
   * Associates the specified value with the specified key in this map
   * (optional operation).  If the map previously contained a mapping for
   * the key, the old value is replaced by the specified value.  (A map
   * `m` is said to contain a mapping for a key `k` if and only
   * if {@link #containsKey(Object) m.containsKey(k)} would return
   * `true`.)
   *
   * @param key key with which the specified value is to be associated
   * @param value value to be associated with the specified key
   * @return the previous value associated with `key`, or
   *         `null` if there was no mapping for `key`.
   *         (A `null` return can also indicate that the map
   *         previously associated `null` with `key`,
   *         if the implementation supports `null` values.)
   * @throws UnsupportedOperationException if the `put` operation
   *         is not supported by this map
   * @throws ClassCastException if the class of the specified key or value
   *         prevents it from being stored in this map
   * @throws NullPointerException if the specified key or value is null
   *         and this map does not permit null keys or values
   * @throws IllegalArgumentException if some property of the specified key
   *         or value prevents it from being stored in this map
  */
  put(key: K, value: V): V;
  /**
   * Removes the mapping for a key from this map if it is present
   * (optional operation).   More formally, if this map contains a mapping
   * from key `k` to value `v` such that
   * `Objects.equals(key, k)`, that mapping
   * is removed.  (The map can contain at most one such mapping.)
   *
   * Returns the value to which this map previously associated the key,
   * or `null` if the map contained no mapping for the key.
   *
   * If this map permits null values, then a return value of
   * `null` does not necessarily indicate that the map
   * contained no mapping for the key; it's also possible that the map
   * explicitly mapped the key to `null`.
   *
   * The map will not contain a mapping for the specified key once the
   * call returns.
   *
   * @param key key whose mapping is to be removed from the map
   * @return the previous value associated with `key`, or
   *         `null` if there was no mapping for `key`.
   * @throws UnsupportedOperationException if the `remove` operation
   *         is not supported by this map
   * @throws ClassCastException if the key is of an inappropriate type for
   *         this map
   * (optional)
   * @throws NullPointerException if the specified key is null and this
   *         map does not permit null keys
   * (optional)
  */
  remove(key: any): V;
  /**
   * Copies all of the mappings from the specified map to this map
   * (optional operation).  The effect of this call is equivalent to that
   * of calling {@link #put(Object,Object) put(k, v)} on this map once
   * for each mapping from key `k` to value `v` in the
   * specified map.  The behavior of this operation is undefined if the
   * specified map is modified while the operation is in progress.
   *
   * @param m mappings to be stored in this map
   * @throws UnsupportedOperationException if the `putAll` operation
   *         is not supported by this map
   * @throws ClassCastException if the class of a key or value in the
   *         specified map prevents it from being stored in this map
   * @throws NullPointerException if the specified map is null, or if
   *         this map does not permit null keys or values, and the
   *         specified map contains null keys or values
   * @throws IllegalArgumentException if some property of a key or value in
   *         the specified map prevents it from being stored in this map
  */
  putAll(m: Map<K, V>): void;
  /**
   * Removes all of the mappings from this map (optional operation).
   * The map will be empty after this call returns.
   *
   * @throws UnsupportedOperationException if the `clear` operation
   *         is not supported by this map
  */
  clear(): void;
  /**
   * Returns a {@link Set} view of the keys contained in this map.
   * The set is backed by the map, so changes to the map are
   * reflected in the set, and vice-versa.  If the map is modified
   * while an iteration over the set is in progress (except through
   * the iterator's own `remove` operation), the results of
   * the iteration are undefined.  The set supports element removal,
   * which removes the corresponding mapping from the map, via the
   * `Iterator.remove`, `Set.remove`,
   * `removeAll`, `retainAll`, and `clear`
   * operations.  It does not support the `add` or `addAll`
   * operations.
   *
   * @return a set view of the keys contained in this map
  */
  keySet(): Set<K>;
  /**
   * Returns a {@link Collection} view of the values contained in this map.
   * The collection is backed by the map, so changes to the map are
   * reflected in the collection, and vice-versa.  If the map is
   * modified while an iteration over the collection is in progress
   * (except through the iterator's own `remove` operation),
   * the results of the iteration are undefined.  The collection
   * supports element removal, which removes the corresponding
   * mapping from the map, via the `Iterator.remove`,
   * `Collection.remove`, `removeAll`,
   * `retainAll` and `clear` operations.  It does not
   * support the `add` or `addAll` operations.
   *
   * @return a collection view of the values contained in this map
  */
  values(): Collection<V>;
  /**
   * Returns a {@link Set} view of the mappings contained in this map.
   * The set is backed by the map, so changes to the map are
   * reflected in the set, and vice-versa.  If the map is modified
   * while an iteration over the set is in progress (except through
   * the iterator's own `remove` operation, or through the
   * `setValue` operation on a map entry returned by the
   * iterator) the results of the iteration are undefined.  The set
   * supports element removal, which removes the corresponding
   * mapping from the map, via the `Iterator.remove`,
   * `Set.remove`, `removeAll`, `retainAll` and
   * `clear` operations.  It does not support the
   * `add` or `addAll` operations.
   *
   * @return a set view of the mappings contained in this map
  */
  entrySet(): Set<java_util_Map_Entry<K, V>>;
  /**
   * Compares the specified object with this map for equality.  Returns
   * `true` if the given object is also a map and the two maps
   * represent the same mappings.  More formally, two maps `m1` and
   * `m2` represent the same mappings if
   * `m1.entrySet().equals(m2.entrySet())`.  This ensures that the
   * `equals` method works properly across different implementations
   * of the `Map` interface.
   *
   * @param o object to be compared for equality with this map
   * @return `true` if the specified object is equal to this map
  */
  equals(o: any): boolean;
  /**
   * Returns the hash code value for this map.  The hash code of a map is
   * defined to be the sum of the hash codes of each entry in the map's
   * `entrySet()` view.  This ensures that `m1.equals(m2)`
   * implies that `m1.hashCode()==m2.hashCode()` for any two maps
   * `m1` and `m2`, as required by the general contract of
   * {@link Object#hashCode}.
   *
   * @return the hash code value for this map
   * @see Map.Entry#hashCode()
   * @see Object#equals(Object)
   * @see #equals(Object)
  */
  hashCode(): number;
  /**
   * Returns the value to which the specified key is mapped, or
   * `defaultValue` if this map contains no mapping for the key.
   *
   * @implSpec
   * The default implementation makes no guarantees about synchronization
   * or atomicity properties of this method. Any implementation providing
   * atomicity guarantees must override this method and document its
   * concurrency properties.
   *
   * @param key the key whose associated value is to be returned
   * @param defaultValue the default mapping of the key
   * @return the value to which the specified key is mapped, or
   * `defaultValue` if this map contains no mapping for the key
   * @throws ClassCastException if the key is of an inappropriate type for
   * this map
   * (optional)
   * @throws NullPointerException if the specified key is null and this map
   * does not permit null keys
   * (optional)
   * @since 1.8
  */
  getOrDefault(key: any, defaultValue: V): V;
  /**
   * Performs the given action for each entry in this map until all entries
   * have been processed or the action throws an exception.   Unless
   * otherwise specified by the implementing class, actions are performed in
   * the order of entry set iteration (if an iteration order is specified.)
   * Exceptions thrown by the action are relayed to the caller.
   *
   * @implSpec
   * The default implementation is equivalent to, for this `map`:
   *  {@code
   * for (Map.Entry entry : map.entrySet())
   *     action.accept(entry.getKey(), entry.getValue());
   * }
   *
   * The default implementation makes no guarantees about synchronization
   * or atomicity properties of this method. Any implementation providing
   * atomicity guarantees must override this method and document its
   * concurrency properties.
   *
   * @param action The action to be performed for each entry
   * @throws NullPointerException if the specified action is null
   * @throws ConcurrentModificationException if an entry is found to be
   * removed during iteration
   * @since 1.8
  */
  forEach(action: BiConsumer<any, any>): void;
  /**
   * Replaces each entry's value with the result of invoking the given
   * function on that entry until all entries have been processed or the
   * function throws an exception.  Exceptions thrown by the function are
   * relayed to the caller.
   *
   * @implSpec
   * The default implementation is equivalent to, for this `map`:
   *  {@code
   * for (Map.Entry entry : map.entrySet())
   *     entry.setValue(function.apply(entry.getKey(), entry.getValue()));
   * }
   *
   * The default implementation makes no guarantees about synchronization
   * or atomicity properties of this method. Any implementation providing
   * atomicity guarantees must override this method and document its
   * concurrency properties.
   *
   * @param function the function to apply to each entry
   * @throws UnsupportedOperationException if the `set` operation
   * is not supported by this map's entry set iterator.
   * @throws ClassCastException if the class of a replacement value
   * prevents it from being stored in this map
   * @throws NullPointerException if the specified function is null, or the
   * specified replacement value is null, and this map does not permit null
   * values
   * @throws ClassCastException if a replacement value is of an inappropriate
   *         type for this map
   *         (optional)
   * @throws NullPointerException if function or a replacement value is null,
   *         and this map does not permit null keys or values
   *         (optional)
   * @throws IllegalArgumentException if some property of a replacement value
   *         prevents it from being stored in this map
   *         (optional)
   * @throws ConcurrentModificationException if an entry is found to be
   * removed during iteration
   * @since 1.8
  */
  replaceAll(func: BiFunction<any, any, V>): void;
  /**
   * If the specified key is not already associated with a value (or is mapped
   * to `null`) associates it with the given value and returns
   * `null`, else returns the current value.
   *
   * @implSpec
   * The default implementation is equivalent to, for this `map`:
   *
   *  {@code
   * V v = map.get(key);
   * if (v == null)
   *     v = map.put(key, value);
   *
   * return v;
   * }
   *
   * The default implementation makes no guarantees about synchronization
   * or atomicity properties of this method. Any implementation providing
   * atomicity guarantees must override this method and document its
   * concurrency properties.
   *
   * @param key key with which the specified value is to be associated
   * @param value value to be associated with the specified key
   * @return the previous value associated with the specified key, or
   *         `null` if there was no mapping for the key.
   *         (A `null` return can also indicate that the map
   *         previously associated `null` with the key,
   *         if the implementation supports null values.)
   * @throws UnsupportedOperationException if the `put` operation
   *         is not supported by this map
   *         (optional)
   * @throws ClassCastException if the key or value is of an inappropriate
   *         type for this map
   *         (optional)
   * @throws NullPointerException if the specified key or value is null,
   *         and this map does not permit null keys or values
   *         (optional)
   * @throws IllegalArgumentException if some property of the specified key
   *         or value prevents it from being stored in this map
   *         (optional)
   * @since 1.8
  */
  putIfAbsent(key: K, value: V): V;
  /**
   * Removes the entry for the specified key only if it is currently
   * mapped to the specified value.
   *
   * @implSpec
   * The default implementation is equivalent to, for this `map`:
   *
   *  {@code
   * if (map.containsKey(key) && Objects.equals(map.get(key), value)) {
   *     map.remove(key);
   *     return true;
   * } else
   *     return false;
   * }
   *
   * The default implementation makes no guarantees about synchronization
   * or atomicity properties of this method. Any implementation providing
   * atomicity guarantees must override this method and document its
   * concurrency properties.
   *
   * @param key key with which the specified value is associated
   * @param value value expected to be associated with the specified key
   * @return `true` if the value was removed
   * @throws UnsupportedOperationException if the `remove` operation
   *         is not supported by this map
   *         (optional)
   * @throws ClassCastException if the key or value is of an inappropriate
   *         type for this map
   *         (optional)
   * @throws NullPointerException if the specified key or value is null,
   *         and this map does not permit null keys or values
   *         (optional)
   * @since 1.8
  */
  remove(key: any, value: any): boolean;
  /**
   * Replaces the entry for the specified key only if currently
   * mapped to the specified value.
   *
   * @implSpec
   * The default implementation is equivalent to, for this `map`:
   *
   *  {@code
   * if (map.containsKey(key) && Objects.equals(map.get(key), oldValue)) {
   *     map.put(key, newValue);
   *     return true;
   * } else
   *     return false;
   * }
   *
   * The default implementation does not throw NullPointerException
   * for maps that do not support null values if oldValue is null unless
   * newValue is also null.
   *
   * The default implementation makes no guarantees about synchronization
   * or atomicity properties of this method. Any implementation providing
   * atomicity guarantees must override this method and document its
   * concurrency properties.
   *
   * @param key key with which the specified value is associated
   * @param oldValue value expected to be associated with the specified key
   * @param newValue value to be associated with the specified key
   * @return `true` if the value was replaced
   * @throws UnsupportedOperationException if the `put` operation
   *         is not supported by this map
   *         (optional)
   * @throws ClassCastException if the class of a specified key or value
   *         prevents it from being stored in this map
   * @throws NullPointerException if a specified key or newValue is null,
   *         and this map does not permit null keys or values
   * @throws NullPointerException if oldValue is null and this map does not
   *         permit null values
   *         (optional)
   * @throws IllegalArgumentException if some property of a specified key
   *         or value prevents it from being stored in this map
   * @since 1.8
  */
  replace(key: K, oldValue: V, newValue: V): boolean;
  /**
   * Replaces the entry for the specified key only if it is
   * currently mapped to some value.
   *
   * @implSpec
   * The default implementation is equivalent to, for this `map`:
   *
   *  {@code
   * if (map.containsKey(key)) {
   *     return map.put(key, value);
   * } else
   *     return null;
   * }
   *
   * The default implementation makes no guarantees about synchronization
   * or atomicity properties of this method. Any implementation providing
   * atomicity guarantees must override this method and document its
   * concurrency properties.
   *
   * @param key key with which the specified value is associated
   * @param value value to be associated with the specified key
   * @return the previous value associated with the specified key, or
   *         `null` if there was no mapping for the key.
   *         (A `null` return can also indicate that the map
   *         previously associated `null` with the key,
   *         if the implementation supports null values.)
   * @throws UnsupportedOperationException if the `put` operation
   *         is not supported by this map
   *         (optional)
   * @throws ClassCastException if the class of the specified key or value
   *         prevents it from being stored in this map
   *         (optional)
   * @throws NullPointerException if the specified key or value is null,
   *         and this map does not permit null keys or values
   * @throws IllegalArgumentException if some property of the specified key
   *         or value prevents it from being stored in this map
   * @since 1.8
  */
  replace(key: K, value: V): V;
  /**
   * If the specified key is not already associated with a value (or is mapped
   * to `null`), attempts to compute its value using the given mapping
   * function and enters it into this map unless `null`.
   *
   * If the mapping function returns `null`, no mapping is recorded.
   * If the mapping function itself throws an (unchecked) exception, the
   * exception is rethrown, and no mapping is recorded.  The most
   * common usage is to construct a new object serving as an initial
   * mapped value or memoized result, as in:
   *
   *  {@code
   * map.computeIfAbsent(key, k -> new Value(f(k)));
   * }
   *
   * Or to implement a multi-value map, `Map>`,
   * supporting multiple values per key:
   *
   *  {@code
   * map.computeIfAbsent(key, k -> new HashSet()).add(v);
   * }
   *
   * The mapping function should not modify this map during computation.
   *
   * @implSpec
   * The default implementation is equivalent to the following steps for this
   * `map`, then returning the current value or `null` if now
   * absent:
   *
   *  {@code
   * if (map.get(key) == null) {
   *     V newValue = mappingFunction.apply(key);
   *     if (newValue != null)
   *         map.put(key, newValue);
   * }
   * }
   *
   * The default implementation makes no guarantees about detecting if the
   * mapping function modifies this map during computation and, if
   * appropriate, reporting an error. Non-concurrent implementations should
   * override this method and, on a best-effort basis, throw a
   * `ConcurrentModificationException` if it is detected that the
   * mapping function modifies this map during computation. Concurrent
   * implementations should override this method and, on a best-effort basis,
   * throw an `IllegalStateException` if it is detected that the
   * mapping function modifies this map during computation and as a result
   * computation would never complete.
   *
   * The default implementation makes no guarantees about synchronization
   * or atomicity properties of this method. Any implementation providing
   * atomicity guarantees must override this method and document its
   * concurrency properties. In particular, all implementations of
   * subinterface {@link java.util.concurrent.ConcurrentMap} must document
   * whether the mapping function is applied once atomically only if the value
   * is not present.
   *
   * @param key key with which the specified value is to be associated
   * @param mappingFunction the mapping function to compute a value
   * @return the current (existing or computed) value associated with
   *         the specified key, or null if the computed value is null
   * @throws NullPointerException if the specified key is null and
   *         this map does not support null keys, or the mappingFunction
   *         is null
   * @throws UnsupportedOperationException if the `put` operation
   *         is not supported by this map
   *         (optional)
   * @throws ClassCastException if the class of the specified key or value
   *         prevents it from being stored in this map
   *         (optional)
   * @throws IllegalArgumentException if some property of the specified key
   *         or value prevents it from being stored in this map
   *         (optional)
   * @since 1.8
  */
  computeIfAbsent(key: K, mappingFunction: Function<any, V>): V;
  /**
   * If the value for the specified key is present and non-null, attempts to
   * compute a new mapping given the key and its current mapped value.
   *
   * If the remapping function returns `null`, the mapping is removed.
   * If the remapping function itself throws an (unchecked) exception, the
   * exception is rethrown, and the current mapping is left unchanged.
   *
   * The remapping function should not modify this map during computation.
   *
   * @implSpec
   * The default implementation is equivalent to performing the following
   * steps for this `map`, then returning the current value or
   * `null` if now absent:
   *
   *  {@code
   * if (map.get(key) != null) {
   *     V oldValue = map.get(key);
   *     V newValue = remappingFunction.apply(key, oldValue);
   *     if (newValue != null)
   *         map.put(key, newValue);
   *     else
   *         map.remove(key);
   * }
   * }
   *
   * The default implementation makes no guarantees about detecting if the
   * remapping function modifies this map during computation and, if
   * appropriate, reporting an error. Non-concurrent implementations should
   * override this method and, on a best-effort basis, throw a
   * `ConcurrentModificationException` if it is detected that the
   * remapping function modifies this map during computation. Concurrent
   * implementations should override this method and, on a best-effort basis,
   * throw an `IllegalStateException` if it is detected that the
   * remapping function modifies this map during computation and as a result
   * computation would never complete.
   *
   * The default implementation makes no guarantees about synchronization
   * or atomicity properties of this method. Any implementation providing
   * atomicity guarantees must override this method and document its
   * concurrency properties. In particular, all implementations of
   * subinterface {@link java.util.concurrent.ConcurrentMap} must document
   * whether the remapping function is applied once atomically only if the
   * value is not present.
   *
   * @param key key with which the specified value is to be associated
   * @param remappingFunction the remapping function to compute a value
   * @return the new value associated with the specified key, or null if none
   * @throws NullPointerException if the specified key is null and
   *         this map does not support null keys, or the
   *         remappingFunction is null
   * @throws UnsupportedOperationException if the `put` operation
   *         is not supported by this map
   *         (optional)
   * @throws ClassCastException if the class of the specified key or value
   *         prevents it from being stored in this map
   *         (optional)
   * @throws IllegalArgumentException if some property of the specified key
   *         or value prevents it from being stored in this map
   *         (optional)
   * @since 1.8
  */
  computeIfPresent(key: K, remappingFunction: BiFunction<any, any, V>): V;
  /**
   * Attempts to compute a mapping for the specified key and its current
   * mapped value (or `null` if there is no current mapping). For
   * example, to either create or append a `String` msg to a value
   * mapping:
   *
   *  `     * map.compute(key, (k, v) -> (v == null) ? msg : v.concat(msg))`
   * (Method {@link #merge merge()} is often simpler to use for such purposes.)
   *
   * If the remapping function returns `null`, the mapping is removed
   * (or remains absent if initially absent).  If the remapping function
   * itself throws an (unchecked) exception, the exception is rethrown, and
   * the current mapping is left unchanged.
   *
   * The remapping function should not modify this map during computation.
   *
   * @implSpec
   * The default implementation is equivalent to performing the following
   * steps for this `map`, then returning the current value or
   * `null` if absent:
   *
   *  {@code
   * V oldValue = map.get(key);
   * V newValue = remappingFunction.apply(key, oldValue);
   * if (oldValue != null) {
   *    if (newValue != null)
   *       map.put(key, newValue);
   *    else
   *       map.remove(key);
   * } else {
   *    if (newValue != null)
   *       map.put(key, newValue);
   *    else
   *       return null;
   * }
   * }
   *
   * The default implementation makes no guarantees about detecting if the
   * remapping function modifies this map during computation and, if
   * appropriate, reporting an error. Non-concurrent implementations should
   * override this method and, on a best-effort basis, throw a
   * `ConcurrentModificationException` if it is detected that the
   * remapping function modifies this map during computation. Concurrent
   * implementations should override this method and, on a best-effort basis,
   * throw an `IllegalStateException` if it is detected that the
   * remapping function modifies this map during computation and as a result
   * computation would never complete.
   *
   * The default implementation makes no guarantees about synchronization
   * or atomicity properties of this method. Any implementation providing
   * atomicity guarantees must override this method and document its
   * concurrency properties. In particular, all implementations of
   * subinterface {@link java.util.concurrent.ConcurrentMap} must document
   * whether the remapping function is applied once atomically only if the
   * value is not present.
   *
   * @param key key with which the specified value is to be associated
   * @param remappingFunction the remapping function to compute a value
   * @return the new value associated with the specified key, or null if none
   * @throws NullPointerException if the specified key is null and
   *         this map does not support null keys, or the
   *         remappingFunction is null
   * @throws UnsupportedOperationException if the `put` operation
   *         is not supported by this map
   *         (optional)
   * @throws ClassCastException if the class of the specified key or value
   *         prevents it from being stored in this map
   *         (optional)
   * @throws IllegalArgumentException if some property of the specified key
   *         or value prevents it from being stored in this map
   *         (optional)
   * @since 1.8
  */
  compute(key: K, remappingFunction: BiFunction<any, any, V>): V;
  /**
   * If the specified key is not already associated with a value or is
   * associated with null, associates it with the given non-null value.
   * Otherwise, replaces the associated value with the results of the given
   * remapping function, or removes if the result is `null`. This
   * method may be of use when combining multiple mapped values for a key.
   * For example, to either create or append a `String msg` to a
   * value mapping:
   *
   *  {@code
   * map.merge(key, msg, String::concat)
   * }
   *
   * If the remapping function returns `null`, the mapping is removed.
   * If the remapping function itself throws an (unchecked) exception, the
   * exception is rethrown, and the current mapping is left unchanged.
   *
   * The remapping function should not modify this map during computation.
   *
   * @implSpec
   * The default implementation is equivalent to performing the following
   * steps for this `map`, then returning the current value or
   * `null` if absent:
   *
   *  {@code
   * V oldValue = map.get(key);
   * V newValue = (oldValue == null) ? value :
   *              remappingFunction.apply(oldValue, value);
   * if (newValue == null)
   *     map.remove(key);
   * else
   *     map.put(key, newValue);
   * }
   *
   * The default implementation makes no guarantees about detecting if the
   * remapping function modifies this map during computation and, if
   * appropriate, reporting an error. Non-concurrent implementations should
   * override this method and, on a best-effort basis, throw a
   * `ConcurrentModificationException` if it is detected that the
   * remapping function modifies this map during computation. Concurrent
   * implementations should override this method and, on a best-effort basis,
   * throw an `IllegalStateException` if it is detected that the
   * remapping function modifies this map during computation and as a result
   * computation would never complete.
   *
   * The default implementation makes no guarantees about synchronization
   * or atomicity properties of this method. Any implementation providing
   * atomicity guarantees must override this method and document its
   * concurrency properties. In particular, all implementations of
   * subinterface {@link java.util.concurrent.ConcurrentMap} must document
   * whether the remapping function is applied once atomically only if the
   * value is not present.
   *
   * @param key key with which the resulting value is to be associated
   * @param value the non-null value to be merged with the existing value
   *        associated with the key or, if no existing value or a null value
   *        is associated with the key, to be associated with the key
   * @param remappingFunction the remapping function to recompute a value if
   *        present
   * @return the new value associated with the specified key, or null if no
   *         value is associated with the key
   * @throws UnsupportedOperationException if the `put` operation
   *         is not supported by this map
   *         (optional)
   * @throws ClassCastException if the class of the specified key or value
   *         prevents it from being stored in this map
   *         (optional)
   * @throws IllegalArgumentException if some property of the specified key
   *         or value prevents it from being stored in this map
   *         (optional)
   * @throws NullPointerException if the specified key is null and this map
   *         does not support null keys or the value or remappingFunction is
   *         null
   * @since 1.8
  */
  merge(key: K, value: V, remappingFunction: BiFunction<any, any, V>): V;
  /**
   * Returns an unmodifiable map containing zero mappings.
   * See Unmodifiable Maps for details.
   *
   * @param  the `Map`'s key type
   * @param  the `Map`'s value type
   * @return an empty `Map`
   *
   * @since 9
  */
  static of<K, V>(): Map<K, V>;
  /**
   * Returns an unmodifiable map containing a single mapping.
   * See Unmodifiable Maps for details.
   *
   * @param  the `Map`'s key type
   * @param  the `Map`'s value type
   * @param k1 the mapping's key
   * @param v1 the mapping's value
   * @return a `Map` containing the specified mapping
   * @throws NullPointerException if the key or the value is `null`
   *
   * @since 9
  */
  static of<K, V>(k1: K, v1: V): Map<K, V>;
  /**
   * Returns an unmodifiable map containing two mappings.
   * See Unmodifiable Maps for details.
   *
   * @param  the `Map`'s key type
   * @param  the `Map`'s value type
   * @param k1 the first mapping's key
   * @param v1 the first mapping's value
   * @param k2 the second mapping's key
   * @param v2 the second mapping's value
   * @return a `Map` containing the specified mappings
   * @throws IllegalArgumentException if the keys are duplicates
   * @throws NullPointerException if any key or value is `null`
   *
   * @since 9
  */
  static of<K, V>(k1: K, v1: V, k2: K, v2: V): Map<K, V>;
  /**
   * Returns an unmodifiable map containing three mappings.
   * See Unmodifiable Maps for details.
   *
   * @param  the `Map`'s key type
   * @param  the `Map`'s value type
   * @param k1 the first mapping's key
   * @param v1 the first mapping's value
   * @param k2 the second mapping's key
   * @param v2 the second mapping's value
   * @param k3 the third mapping's key
   * @param v3 the third mapping's value
   * @return a `Map` containing the specified mappings
   * @throws IllegalArgumentException if there are any duplicate keys
   * @throws NullPointerException if any key or value is `null`
   *
   * @since 9
  */
  static of<K, V>(k1: K, v1: V, k2: K, v2: V, k3: K, v3: V): Map<K, V>;
  /**
   * Returns an unmodifiable map containing four mappings.
   * See Unmodifiable Maps for details.
   *
   * @param  the `Map`'s key type
   * @param  the `Map`'s value type
   * @param k1 the first mapping's key
   * @param v1 the first mapping's value
   * @param k2 the second mapping's key
   * @param v2 the second mapping's value
   * @param k3 the third mapping's key
   * @param v3 the third mapping's value
   * @param k4 the fourth mapping's key
   * @param v4 the fourth mapping's value
   * @return a `Map` containing the specified mappings
   * @throws IllegalArgumentException if there are any duplicate keys
   * @throws NullPointerException if any key or value is `null`
   *
   * @since 9
  */
  static of<K, V>(k1: K, v1: V, k2: K, v2: V, k3: K, v3: V, k4: K, v4: V): Map<K, V>;
  /**
   * Returns an unmodifiable map containing five mappings.
   * See Unmodifiable Maps for details.
   *
   * @param  the `Map`'s key type
   * @param  the `Map`'s value type
   * @param k1 the first mapping's key
   * @param v1 the first mapping's value
   * @param k2 the second mapping's key
   * @param v2 the second mapping's value
   * @param k3 the third mapping's key
   * @param v3 the third mapping's value
   * @param k4 the fourth mapping's key
   * @param v4 the fourth mapping's value
   * @param k5 the fifth mapping's key
   * @param v5 the fifth mapping's value
   * @return a `Map` containing the specified mappings
   * @throws IllegalArgumentException if there are any duplicate keys
   * @throws NullPointerException if any key or value is `null`
   *
   * @since 9
  */
  static of<K, V>(k1: K, v1: V, k2: K, v2: V, k3: K, v3: V, k4: K, v4: V, k5: K, v5: V): Map<K, V>;
  /**
   * Returns an unmodifiable map containing six mappings.
   * See Unmodifiable Maps for details.
   *
   * @param  the `Map`'s key type
   * @param  the `Map`'s value type
   * @param k1 the first mapping's key
   * @param v1 the first mapping's value
   * @param k2 the second mapping's key
   * @param v2 the second mapping's value
   * @param k3 the third mapping's key
   * @param v3 the third mapping's value
   * @param k4 the fourth mapping's key
   * @param v4 the fourth mapping's value
   * @param k5 the fifth mapping's key
   * @param v5 the fifth mapping's value
   * @param k6 the sixth mapping's key
   * @param v6 the sixth mapping's value
   * @return a `Map` containing the specified mappings
   * @throws IllegalArgumentException if there are any duplicate keys
   * @throws NullPointerException if any key or value is `null`
   *
   * @since 9
  */
  static of<K, V>(k1: K, v1: V, k2: K, v2: V, k3: K, v3: V, k4: K, v4: V, k5: K, v5: V, k6: K, v6: V): Map<K, V>;
  /**
   * Returns an unmodifiable map containing seven mappings.
   * See Unmodifiable Maps for details.
   *
   * @param  the `Map`'s key type
   * @param  the `Map`'s value type
   * @param k1 the first mapping's key
   * @param v1 the first mapping's value
   * @param k2 the second mapping's key
   * @param v2 the second mapping's value
   * @param k3 the third mapping's key
   * @param v3 the third mapping's value
   * @param k4 the fourth mapping's key
   * @param v4 the fourth mapping's value
   * @param k5 the fifth mapping's key
   * @param v5 the fifth mapping's value
   * @param k6 the sixth mapping's key
   * @param v6 the sixth mapping's value
   * @param k7 the seventh mapping's key
   * @param v7 the seventh mapping's value
   * @return a `Map` containing the specified mappings
   * @throws IllegalArgumentException if there are any duplicate keys
   * @throws NullPointerException if any key or value is `null`
   *
   * @since 9
  */
  static of<K, V>(k1: K, v1: V, k2: K, v2: V, k3: K, v3: V, k4: K, v4: V, k5: K, v5: V, k6: K, v6: V, k7: K, v7: V): Map<K, V>;
  /**
   * Returns an unmodifiable map containing eight mappings.
   * See Unmodifiable Maps for details.
   *
   * @param  the `Map`'s key type
   * @param  the `Map`'s value type
   * @param k1 the first mapping's key
   * @param v1 the first mapping's value
   * @param k2 the second mapping's key
   * @param v2 the second mapping's value
   * @param k3 the third mapping's key
   * @param v3 the third mapping's value
   * @param k4 the fourth mapping's key
   * @param v4 the fourth mapping's value
   * @param k5 the fifth mapping's key
   * @param v5 the fifth mapping's value
   * @param k6 the sixth mapping's key
   * @param v6 the sixth mapping's value
   * @param k7 the seventh mapping's key
   * @param v7 the seventh mapping's value
   * @param k8 the eighth mapping's key
   * @param v8 the eighth mapping's value
   * @return a `Map` containing the specified mappings
   * @throws IllegalArgumentException if there are any duplicate keys
   * @throws NullPointerException if any key or value is `null`
   *
   * @since 9
  */
  static of<K, V>(k1: K, v1: V, k2: K, v2: V, k3: K, v3: V, k4: K, v4: V, k5: K, v5: V, k6: K, v6: V, k7: K, v7: V, k8: K, v8: V): Map<K, V>;
  /**
   * Returns an unmodifiable map containing nine mappings.
   * See Unmodifiable Maps for details.
   *
   * @param  the `Map`'s key type
   * @param  the `Map`'s value type
   * @param k1 the first mapping's key
   * @param v1 the first mapping's value
   * @param k2 the second mapping's key
   * @param v2 the second mapping's value
   * @param k3 the third mapping's key
   * @param v3 the third mapping's value
   * @param k4 the fourth mapping's key
   * @param v4 the fourth mapping's value
   * @param k5 the fifth mapping's key
   * @param v5 the fifth mapping's value
   * @param k6 the sixth mapping's key
   * @param v6 the sixth mapping's value
   * @param k7 the seventh mapping's key
   * @param v7 the seventh mapping's value
   * @param k8 the eighth mapping's key
   * @param v8 the eighth mapping's value
   * @param k9 the ninth mapping's key
   * @param v9 the ninth mapping's value
   * @return a `Map` containing the specified mappings
   * @throws IllegalArgumentException if there are any duplicate keys
   * @throws NullPointerException if any key or value is `null`
   *
   * @since 9
  */
  static of<K, V>(k1: K, v1: V, k2: K, v2: V, k3: K, v3: V, k4: K, v4: V, k5: K, v5: V, k6: K, v6: V, k7: K, v7: V, k8: K, v8: V, k9: K, v9: V): Map<K, V>;
  /**
   * Returns an unmodifiable map containing ten mappings.
   * See Unmodifiable Maps for details.
   *
   * @param  the `Map`'s key type
   * @param  the `Map`'s value type
   * @param k1 the first mapping's key
   * @param v1 the first mapping's value
   * @param k2 the second mapping's key
   * @param v2 the second mapping's value
   * @param k3 the third mapping's key
   * @param v3 the third mapping's value
   * @param k4 the fourth mapping's key
   * @param v4 the fourth mapping's value
   * @param k5 the fifth mapping's key
   * @param v5 the fifth mapping's value
   * @param k6 the sixth mapping's key
   * @param v6 the sixth mapping's value
   * @param k7 the seventh mapping's key
   * @param v7 the seventh mapping's value
   * @param k8 the eighth mapping's key
   * @param v8 the eighth mapping's value
   * @param k9 the ninth mapping's key
   * @param v9 the ninth mapping's value
   * @param k10 the tenth mapping's key
   * @param v10 the tenth mapping's value
   * @return a `Map` containing the specified mappings
   * @throws IllegalArgumentException if there are any duplicate keys
   * @throws NullPointerException if any key or value is `null`
   *
   * @since 9
  */
  static of<K, V>(k1: K, v1: V, k2: K, v2: V, k3: K, v3: V, k4: K, v4: V, k5: K, v5: V, k6: K, v6: V, k7: K, v7: V, k8: K, v8: V, k9: K, v9: V, k10: K, v10: V): Map<K, V>;
  /**
   * Returns an unmodifiable map containing keys and values extracted from the given entries.
   * The entries themselves are not stored in the map.
   * See Unmodifiable Maps for details.
   *
   * @apiNote
   * It is convenient to create the map entries using the {@link Map#entry Map.entry()} method.
   * For example,
   *
   * {@code
   *     import static java.util.Map.entry;
   *
   *     Map map = Map.ofEntries(
   *         entry(1, "a"),
   *         entry(2, "b"),
   *         entry(3, "c"),
   *         ...
   *         entry(26, "z"));
   * }
   *
   * @param  the `Map`'s key type
   * @param  the `Map`'s value type
   * @param entries `Map.Entry`s containing the keys and values from which the map is populated
   * @return a `Map` containing the specified mappings
   * @throws IllegalArgumentException if there are any duplicate keys
   * @throws NullPointerException if any entry, key, or value is `null`, or if
   *         the `entries` array is `null`
   *
   * @see Map#entry Map.entry()
   * @since 9
  */
  static ofEntries<K, V>(...entries: java_util_Map_Entry[]): Map<K, V>;
  /**
   * Returns an unmodifiable {@link Entry} containing the given key and value.
   * These entries are suitable for populating `Map` instances using the
   * {@link Map#ofEntries Map.ofEntries()} method.
   * The `Entry` instances created by this method have the following characteristics:
   *
   * 
   * They disallow `null` keys and values. Attempts to create them using a `null`
   * key or value result in `NullPointerException`.
   * They are unmodifiable. Calls to {@link Entry#setValue Entry.setValue()}
   * on a returned `Entry` result in `UnsupportedOperationException`.
   * They are not serializable.
   * They are value-based.
   * Programmers should treat instances that are {@linkplain #equals(Object) equal}
   * as interchangeable and should not use them for synchronization, or
   * unpredictable behavior may occur. For example, in a future release,
   * synchronization may fail. Callers should make no assumptions
   * about the identity of the returned instances. This method is free to
   * create new instances or reuse existing ones.
   * 
   *
   * @apiNote
   * For a serializable `Entry`, see {@link AbstractMap.SimpleEntry} or
   * {@link AbstractMap.SimpleImmutableEntry}.
   *
   * @param  the key's type
   * @param  the value's type
   * @param k the key
   * @param v the value
   * @return an `Entry` containing the specified key and value
   * @throws NullPointerException if the key or value is `null`
   *
   * @see Map#ofEntries Map.ofEntries()
   * @since 9
  */
  static entry<K, V>(k: K, v: V): java_util_Map_Entry<K, V>;
  /**
   * Returns an unmodifiable Map containing the entries
   * of the given Map. The given Map must not be null, and it must not contain any
   * null keys or values. If the given Map is subsequently modified, the returned
   * Map will not reflect such modifications.
   *
   * @implNote
   * If the given Map is an unmodifiable Map,
   * calling copyOf will generally not create a copy.
   *
   * @param  the `Map`'s key type
   * @param  the `Map`'s value type
   * @param map a `Map` from which entries are drawn, must be non-null
   * @return a `Map` containing the entries of the given `Map`
   * @throws NullPointerException if map is null, or if it contains any null keys or values
   * @since 10
  */
  static copyOf<K, V>(map: Map<K, V>): Map<K, V>;
}
/**
 * A specialized {@link Set} implementation for use with enum types.  All of
 * the elements in an enum set must come from a single enum type that is
 * specified, explicitly or implicitly, when the set is created.  Enum sets
 * are represented internally as bit vectors.  This representation is
 * extremely compact and efficient. The space and time performance of this
 * class should be good enough to allow its use as a high-quality, typesafe
 * alternative to traditional `int`-based "bit flags."  Even bulk
 * operations (such as `containsAll` and `retainAll`) should
 * run very quickly if their argument is also an enum set.
 *
 * The iterator returned by the `iterator` method traverses the
 * elements in their natural order (the order in which the enum
 * constants are declared).  The returned iterator is weakly
 * consistent: it will never throw {@link ConcurrentModificationException}
 * and it may or may not show the effects of any modifications to the set that
 * occur while the iteration is in progress.
 *
 * Null elements are not permitted.  Attempts to insert a null element
 * will throw {@link NullPointerException}.  Attempts to test for the
 * presence of a null element or to remove one will, however, function
 * properly.
 *
 * Like most collection implementations, `EnumSet` is not
 * synchronized.  If multiple threads access an enum set concurrently, and at
 * least one of the threads modifies the set, it should be synchronized
 * externally.  This is typically accomplished by synchronizing on some
 * object that naturally encapsulates the enum set.  If no such object exists,
 * the set should be "wrapped" using the {@link Collections#synchronizedSet}
 * method.  This is best done at creation time, to prevent accidental
 * unsynchronized access:
 *
 *  * Set<MyEnum> s = Collections.synchronizedSet(EnumSet.noneOf(MyEnum.class));
 * 
 *
 * Implementation note: All basic operations execute in constant time.
 * They are likely (though not guaranteed) to be much faster than their
 * {@link HashSet} counterparts.  Even bulk operations execute in
 * constant time if their argument is also an enum set.
 *
 * This class is a member of the
 * 
 * Java Collections Framework.
 *
 * @author Josh Bloch
 * @since 1.5
 * @see EnumMap
*/
export class EnumSet<E> extends AbstractSet<E> {
  /**
   * Creates an empty enum set with the specified element type.
   *
   * @param  The class of the elements in the set
   * @param elementType the class object of the element type for this enum
   *     set
   * @return An empty enum set of the specified type.
   * @throws NullPointerException if `elementType` is null
  */
  static noneOf<E>(elementType: Class<E>): EnumSet<E>;
  /**
   * Creates an enum set containing all of the elements in the specified
   * element type.
   *
   * @param  The class of the elements in the set
   * @param elementType the class object of the element type for this enum
   *     set
   * @return An enum set containing all the elements in the specified type.
   * @throws NullPointerException if `elementType` is null
  */
  static allOf<E>(elementType: Class<E>): EnumSet<E>;
  /**
   * Creates an enum set with the same element type as the specified enum
   * set, initially containing the same elements (if any).
   *
   * @param  The class of the elements in the set
   * @param s the enum set from which to initialize this enum set
   * @return A copy of the specified enum set.
   * @throws NullPointerException if `s` is null
  */
  static copyOf<E>(s: EnumSet<E>): EnumSet<E>;
  /**
   * Creates an enum set initialized from the specified collection.  If
   * the specified collection is an `EnumSet` instance, this static
   * factory method behaves identically to {@link #copyOf(EnumSet)}.
   * Otherwise, the specified collection must contain at least one element
   * (in order to determine the new enum set's element type).
   *
   * @param  The class of the elements in the collection
   * @param c the collection from which to initialize this enum set
   * @return An enum set initialized from the given collection.
   * @throws IllegalArgumentException if `c` is not an
   *     `EnumSet` instance and contains no elements
   * @throws NullPointerException if `c` is null
  */
  static copyOf<E>(c: Collection<E>): EnumSet<E>;
  /**
   * Creates an enum set with the same element type as the specified enum
   * set, initially containing all the elements of this type that are
   * not contained in the specified set.
   *
   * @param  The class of the elements in the enum set
   * @param s the enum set from whose complement to initialize this enum set
   * @return The complement of the specified set in this set
   * @throws NullPointerException if `s` is null
  */
  static complementOf<E>(s: EnumSet<E>): EnumSet<E>;
  /**
   * Creates an enum set initially containing the specified element.
   *
   * Overloadings of this method exist to initialize an enum set with
   * one through five elements.  A sixth overloading is provided that
   * uses the varargs feature.  This overloading may be used to create
   * an enum set initially containing an arbitrary number of elements, but
   * is likely to run slower than the overloadings that do not use varargs.
   *
   * @param  The class of the specified element and of the set
   * @param e the element that this set is to contain initially
   * @throws NullPointerException if `e` is null
   * @return an enum set initially containing the specified element
  */
  static of<E>(e: E): EnumSet<E>;
  /**
   * Creates an enum set initially containing the specified elements.
   *
   * Overloadings of this method exist to initialize an enum set with
   * one through five elements.  A sixth overloading is provided that
   * uses the varargs feature.  This overloading may be used to create
   * an enum set initially containing an arbitrary number of elements, but
   * is likely to run slower than the overloadings that do not use varargs.
   *
   * @param  The class of the parameter elements and of the set
   * @param e1 an element that this set is to contain initially
   * @param e2 another element that this set is to contain initially
   * @throws NullPointerException if any parameters are null
   * @return an enum set initially containing the specified elements
  */
  static of<E>(e1: E, e2: E): EnumSet<E>;
  /**
   * Creates an enum set initially containing the specified elements.
   *
   * Overloadings of this method exist to initialize an enum set with
   * one through five elements.  A sixth overloading is provided that
   * uses the varargs feature.  This overloading may be used to create
   * an enum set initially containing an arbitrary number of elements, but
   * is likely to run slower than the overloadings that do not use varargs.
   *
   * @param  The class of the parameter elements and of the set
   * @param e1 an element that this set is to contain initially
   * @param e2 another element that this set is to contain initially
   * @param e3 another element that this set is to contain initially
   * @throws NullPointerException if any parameters are null
   * @return an enum set initially containing the specified elements
  */
  static of<E>(e1: E, e2: E, e3: E): EnumSet<E>;
  /**
   * Creates an enum set initially containing the specified elements.
   *
   * Overloadings of this method exist to initialize an enum set with
   * one through five elements.  A sixth overloading is provided that
   * uses the varargs feature.  This overloading may be used to create
   * an enum set initially containing an arbitrary number of elements, but
   * is likely to run slower than the overloadings that do not use varargs.
   *
   * @param  The class of the parameter elements and of the set
   * @param e1 an element that this set is to contain initially
   * @param e2 another element that this set is to contain initially
   * @param e3 another element that this set is to contain initially
   * @param e4 another element that this set is to contain initially
   * @throws NullPointerException if any parameters are null
   * @return an enum set initially containing the specified elements
  */
  static of<E>(e1: E, e2: E, e3: E, e4: E): EnumSet<E>;
  /**
   * Creates an enum set initially containing the specified elements.
   *
   * Overloadings of this method exist to initialize an enum set with
   * one through five elements.  A sixth overloading is provided that
   * uses the varargs feature.  This overloading may be used to create
   * an enum set initially containing an arbitrary number of elements, but
   * is likely to run slower than the overloadings that do not use varargs.
   *
   * @param  The class of the parameter elements and of the set
   * @param e1 an element that this set is to contain initially
   * @param e2 another element that this set is to contain initially
   * @param e3 another element that this set is to contain initially
   * @param e4 another element that this set is to contain initially
   * @param e5 another element that this set is to contain initially
   * @throws NullPointerException if any parameters are null
   * @return an enum set initially containing the specified elements
  */
  static of<E>(e1: E, e2: E, e3: E, e4: E, e5: E): EnumSet<E>;
  /**
   * Creates an enum set initially containing the specified elements.
   * This factory, whose parameter list uses the varargs feature, may
   * be used to create an enum set initially containing an arbitrary
   * number of elements, but it is likely to run slower than the overloadings
   * that do not use varargs.
   *
   * @param  The class of the parameter elements and of the set
   * @param first an element that the set is to contain initially
   * @param rest the remaining elements the set is to contain initially
   * @throws NullPointerException if any of the specified elements are null,
   *     or if `rest` is null
   * @return an enum set initially containing the specified elements
  */
  static of<E>(first: E, ...rest: E[]): EnumSet<E>;
  /**
   * Creates an enum set initially containing all of the elements in the
   * range defined by the two specified endpoints.  The returned set will
   * contain the endpoints themselves, which may be identical but must not
   * be out of order.
   *
   * @param  The class of the parameter elements and of the set
   * @param from the first element in the range
   * @param to the last element in the range
   * @throws NullPointerException if `from` or `to` are null
   * @throws IllegalArgumentException if `from.compareTo(to) > 0`
   * @return an enum set initially containing all of the elements in the
   *         range defined by the two specified endpoints
  */
  static range<E>(from: E, to: E): EnumSet<E>;
  /**
   * Returns a copy of this set.
   *
   * @return a copy of this set
  */
  clone(): EnumSet<E>;
  /**
   * Returns an unmodifiable set containing zero elements.
   * See Unmodifiable Sets for details.
   *
   * @param  the `Set`'s element type
   * @return an empty `Set`
   *
   * @since 9
  */
  static of<E>(): Set<E>;
  /**
   * Returns an unmodifiable set containing six elements.
   * See Unmodifiable Sets for details.
   *
   * @param  the `Set`'s element type
   * @param e1 the first element
   * @param e2 the second element
   * @param e3 the third element
   * @param e4 the fourth element
   * @param e5 the fifth element
   * @param e6 the sixth element
   * @return a `Set` containing the specified elements
   * @throws IllegalArgumentException if there are any duplicate elements
   * @throws NullPointerException if an element is `null`
   *
   * @since 9
  */
  static of<E>(e1: E, e2: E, e3: E, e4: E, e5: E, e6: E): Set<E>;
  /**
   * Returns an unmodifiable set containing seven elements.
   * See Unmodifiable Sets for details.
   *
   * @param  the `Set`'s element type
   * @param e1 the first element
   * @param e2 the second element
   * @param e3 the third element
   * @param e4 the fourth element
   * @param e5 the fifth element
   * @param e6 the sixth element
   * @param e7 the seventh element
   * @return a `Set` containing the specified elements
   * @throws IllegalArgumentException if there are any duplicate elements
   * @throws NullPointerException if an element is `null`
   *
   * @since 9
  */
  static of<E>(e1: E, e2: E, e3: E, e4: E, e5: E, e6: E, e7: E): Set<E>;
  /**
   * Returns an unmodifiable set containing eight elements.
   * See Unmodifiable Sets for details.
   *
   * @param  the `Set`'s element type
   * @param e1 the first element
   * @param e2 the second element
   * @param e3 the third element
   * @param e4 the fourth element
   * @param e5 the fifth element
   * @param e6 the sixth element
   * @param e7 the seventh element
   * @param e8 the eighth element
   * @return a `Set` containing the specified elements
   * @throws IllegalArgumentException if there are any duplicate elements
   * @throws NullPointerException if an element is `null`
   *
   * @since 9
  */
  static of<E>(e1: E, e2: E, e3: E, e4: E, e5: E, e6: E, e7: E, e8: E): Set<E>;
  /**
   * Returns an unmodifiable set containing nine elements.
   * See Unmodifiable Sets for details.
   *
   * @param  the `Set`'s element type
   * @param e1 the first element
   * @param e2 the second element
   * @param e3 the third element
   * @param e4 the fourth element
   * @param e5 the fifth element
   * @param e6 the sixth element
   * @param e7 the seventh element
   * @param e8 the eighth element
   * @param e9 the ninth element
   * @return a `Set` containing the specified elements
   * @throws IllegalArgumentException if there are any duplicate elements
   * @throws NullPointerException if an element is `null`
   *
   * @since 9
  */
  static of<E>(e1: E, e2: E, e3: E, e4: E, e5: E, e6: E, e7: E, e8: E, e9: E): Set<E>;
  /**
   * Returns an unmodifiable set containing ten elements.
   * See Unmodifiable Sets for details.
   *
   * @param  the `Set`'s element type
   * @param e1 the first element
   * @param e2 the second element
   * @param e3 the third element
   * @param e4 the fourth element
   * @param e5 the fifth element
   * @param e6 the sixth element
   * @param e7 the seventh element
   * @param e8 the eighth element
   * @param e9 the ninth element
   * @param e10 the tenth element
   * @return a `Set` containing the specified elements
   * @throws IllegalArgumentException if there are any duplicate elements
   * @throws NullPointerException if an element is `null`
   *
   * @since 9
  */
  static of<E>(e1: E, e2: E, e3: E, e4: E, e5: E, e6: E, e7: E, e8: E, e9: E, e10: E): Set<E>;
  /**
   * Returns an unmodifiable set containing an arbitrary number of elements.
   * See Unmodifiable Sets for details.
   *
   * @apiNote
   * This method also accepts a single array as an argument. The element type of
   * the resulting set will be the component type of the array, and the size of
   * the set will be equal to the length of the array. To create a set with
   * a single element that is an array, do the following:
   *
   * {@code
   *     String[] array = ... ;
   *     Set list = Set.of(array);
   * }
   *
   * This will cause the {@link Set#of(Object) Set.of(E)} method
   * to be invoked instead.
   *
   * @param  the `Set`'s element type
   * @param elements the elements to be contained in the set
   * @return a `Set` containing the specified elements
   * @throws IllegalArgumentException if there are any duplicate elements
   * @throws NullPointerException if an element is `null` or if the array is `null`
   *
   * @since 9
  */
  static of<E>(...elements: E[]): Set<E>;
}
export interface EnumSet<E> extends AbstractSet<E>, Cloneable, Serializable {}
/**
 * `GregorianCalendar` is a concrete subclass of
 * `Calendar` and provides the standard calendar system
 * used by most of the world.
 *
 *  `GregorianCalendar` is a hybrid calendar that
 * supports both the Julian and Gregorian calendar systems with the
 * support of a single discontinuity, which corresponds by default to
 * the Gregorian date when the Gregorian calendar was instituted
 * (October 15, 1582 in some countries, later in others).  The cutover
 * date may be changed by the caller by calling {@link
 * #setGregorianChange(Date) setGregorianChange()}.
 *
 * 
 * Historically, in those countries which adopted the Gregorian calendar first,
 * October 4, 1582 (Julian) was thus followed by October 15, 1582 (Gregorian). This calendar models
 * this correctly.  Before the Gregorian cutover, `GregorianCalendar`
 * implements the Julian calendar.  The only difference between the Gregorian
 * and the Julian calendar is the leap year rule. The Julian calendar specifies
 * leap years every four years, whereas the Gregorian calendar omits century
 * years which are not divisible by 400.
 *
 * 
 * `GregorianCalendar` implements proleptic Gregorian and
 * Julian calendars. That is, dates are computed by extrapolating the current
 * rules indefinitely far backward and forward in time. As a result,
 * `GregorianCalendar` may be used for all years to generate
 * meaningful and consistent results. However, dates obtained using
 * `GregorianCalendar` are historically accurate only from March 1, 4
 * AD onward, when modern Julian calendar rules were adopted.  Before this date,
 * leap year rules were applied irregularly, and before 45 BC the Julian
 * calendar did not even exist.
 *
 * 
 * Prior to the institution of the Gregorian calendar, New Year's Day was
 * March 25. To avoid confusion, this calendar always uses January 1. A manual
 * adjustment may be made if desired for dates that are prior to the Gregorian
 * changeover and which fall between January 1 and March 24.
 *
 * Week Of Year and Week Year
 *
 * Values calculated for the {@link Calendar#WEEK_OF_YEAR
 * WEEK_OF_YEAR} field range from 1 to 53. The first week of a
 * calendar year is the earliest seven day period starting on {@link
 * Calendar#getFirstDayOfWeek() getFirstDayOfWeek()} that contains at
 * least {@link Calendar#getMinimalDaysInFirstWeek()
 * getMinimalDaysInFirstWeek()} days from that year. It thus depends
 * on the values of `getMinimalDaysInFirstWeek()`, ` * getFirstDayOfWeek()`, and the day of the week of January 1. Weeks
 * between week 1 of one year and week 1 of the following year
 * (exclusive) are numbered sequentially from 2 to 52 or 53 (except
 * for year(s) involved in the Julian-Gregorian transition).
 *
 * The `getFirstDayOfWeek()` and ` * getMinimalDaysInFirstWeek()` values are initialized using
 * locale-dependent resources when constructing a ` * GregorianCalendar`. The week
 * determination is compatible with the ISO 8601 standard when ` * getFirstDayOfWeek()` is `MONDAY` and ` * getMinimalDaysInFirstWeek()` is 4, which values are used in locales
 * where the standard is preferred. These values can explicitly be set by
 * calling {@link Calendar#setFirstDayOfWeek(int) setFirstDayOfWeek()} and
 * {@link Calendar#setMinimalDaysInFirstWeek(int)
 * setMinimalDaysInFirstWeek()}.
 *
 * A week year is in sync with a
 * `WEEK_OF_YEAR` cycle. All weeks between the first and last
 * weeks (inclusive) have the same week year value.
 * Therefore, the first and last days of a week year may have
 * different calendar year values.
 *
 * For example, January 1, 1998 is a Thursday. If ` * getFirstDayOfWeek()` is `MONDAY` and ` * getMinimalDaysInFirstWeek()` is 4 (ISO 8601 standard compatible
 * setting), then week 1 of 1998 starts on December 29, 1997, and ends
 * on January 4, 1998. The week year is 1998 for the last three days
 * of calendar year 1997. If, however, `getFirstDayOfWeek()` is
 * `SUNDAY`, then week 1 of 1998 starts on January 4, 1998, and
 * ends on January 10, 1998; the first three days of 1998 then are
 * part of week 53 of 1997 and their week year is 1997.
 *
 * Week Of Month
 *
 * Values calculated for the `WEEK_OF_MONTH` field range from 0
 * to 6.  Week 1 of a month (the days with WEEK_OF_MONTH =
 * 1) is the earliest set of at least
 * `getMinimalDaysInFirstWeek()` contiguous days in that month,
 * ending on the day before `getFirstDayOfWeek()`.  Unlike
 * week 1 of a year, week 1 of a month may be shorter than 7 days, need
 * not start on `getFirstDayOfWeek()`, and will not include days of
 * the previous month.  Days of a month before week 1 have a
 * `WEEK_OF_MONTH` of 0.
 *
 * For example, if `getFirstDayOfWeek()` is `SUNDAY`
 * and `getMinimalDaysInFirstWeek()` is 4, then the first week of
 * January 1998 is Sunday, January 4 through Saturday, January 10.  These days
 * have a `WEEK_OF_MONTH` of 1.  Thursday, January 1 through
 * Saturday, January 3 have a `WEEK_OF_MONTH` of 0.  If
 * `getMinimalDaysInFirstWeek()` is changed to 3, then January 1
 * through January 3 have a `WEEK_OF_MONTH` of 1.
 *
 * Default Fields Values
 *
 * The `clear` method sets calendar field(s)
 * undefined. `GregorianCalendar` uses the following
 * default value for each calendar field if its value is undefined.
 *
 * 
 * GregorianCalendar default field values
 *   
 *     
 *       
 *          Field
 *       
 *       
 *          Default Value
 *       
 *     
 *   
 *   
 *     
 *       
 *              `ERA`
 *       
 *       
 *              `AD`
 *       
 *     
 *     
 *       
 *              `YEAR`
 *       
 *       
 *              `1970`
 *       
 *     
 *     
 *       
 *              `MONTH`
 *       
 *       
 *              `JANUARY`
 *       
 *     
 *     
 *       
 *              `DAY_OF_MONTH`
 *       
 *       
 *              `1`
 *       
 *     
 *     
 *       
 *              `DAY_OF_WEEK`
 *       
 *       
 *              `the first day of week`
 *       
 *     
 *     
 *       
 *              `WEEK_OF_MONTH`
 *       
 *       
 *              `0`
 *       
 *     
 *     
 *       
 *              `DAY_OF_WEEK_IN_MONTH`
 *       
 *       
 *              `1`
 *       
 *     
 *     
 *       
 *              `AM_PM`
 *       
 *       
 *              `AM`
 *       
 *     
 *     
 *       
 *              `HOUR, HOUR_OF_DAY, MINUTE, SECOND, MILLISECOND`
 *       
 *       
 *              `0`
 *       
 *     
 *   
 * 
 * Default values are not applicable for the fields not listed above.
 *
 * 
 * Example:
 * 
 *  * // get the supported ids for GMT-08:00 (Pacific Standard Time)
 * String[] ids = TimeZone.getAvailableIDs(-8 * 60 * 60 * 1000);
 * // if no ids were returned, something is wrong. get out.
 * if (ids.length == 0)
 *     System.exit(0);
 *
 *  // begin output
 * System.out.println("Current Time");
 *
 * // create a Pacific Standard Time time zone
 * SimpleTimeZone pdt = new SimpleTimeZone(-8 * 60 * 60 * 1000, ids[0]);
 *
 * // set up rules for Daylight Saving Time
 * pdt.setStartRule(Calendar.APRIL, 1, Calendar.SUNDAY, 2 * 60 * 60 * 1000);
 * pdt.setEndRule(Calendar.OCTOBER, -1, Calendar.SUNDAY, 2 * 60 * 60 * 1000);
 *
 * // create a GregorianCalendar with the Pacific Daylight time zone
 * // and the current date and time
 * Calendar calendar = new GregorianCalendar(pdt);
 * Date trialTime = new Date();
 * calendar.setTime(trialTime);
 *
 * // print out a bunch of interesting things
 * System.out.println("ERA: " + calendar.get(Calendar.ERA));
 * System.out.println("YEAR: " + calendar.get(Calendar.YEAR));
 * System.out.println("MONTH: " + calendar.get(Calendar.MONTH));
 * System.out.println("WEEK_OF_YEAR: " + calendar.get(Calendar.WEEK_OF_YEAR));
 * System.out.println("WEEK_OF_MONTH: " + calendar.get(Calendar.WEEK_OF_MONTH));
 * System.out.println("DATE: " + calendar.get(Calendar.DATE));
 * System.out.println("DAY_OF_MONTH: " + calendar.get(Calendar.DAY_OF_MONTH));
 * System.out.println("DAY_OF_YEAR: " + calendar.get(Calendar.DAY_OF_YEAR));
 * System.out.println("DAY_OF_WEEK: " + calendar.get(Calendar.DAY_OF_WEEK));
 * System.out.println("DAY_OF_WEEK_IN_MONTH: "
 *                    + calendar.get(Calendar.DAY_OF_WEEK_IN_MONTH));
 * System.out.println("AM_PM: " + calendar.get(Calendar.AM_PM));
 * System.out.println("HOUR: " + calendar.get(Calendar.HOUR));
 * System.out.println("HOUR_OF_DAY: " + calendar.get(Calendar.HOUR_OF_DAY));
 * System.out.println("MINUTE: " + calendar.get(Calendar.MINUTE));
 * System.out.println("SECOND: " + calendar.get(Calendar.SECOND));
 * System.out.println("MILLISECOND: " + calendar.get(Calendar.MILLISECOND));
 * System.out.println("ZONE_OFFSET: "
 *                    + (calendar.get(Calendar.ZONE_OFFSET)/(60*60*1000)));
 * System.out.println("DST_OFFSET: "
 *                    + (calendar.get(Calendar.DST_OFFSET)/(60*60*1000)));
 * System.out.println("Current Time, with hour reset to 3");
 * calendar.clear(Calendar.HOUR_OF_DAY); // so doesn't override
 * calendar.set(Calendar.HOUR, 3);
 * System.out.println("ERA: " + calendar.get(Calendar.ERA));
 * System.out.println("YEAR: " + calendar.get(Calendar.YEAR));
 * System.out.println("MONTH: " + calendar.get(Calendar.MONTH));
 * System.out.println("WEEK_OF_YEAR: " + calendar.get(Calendar.WEEK_OF_YEAR));
 * System.out.println("WEEK_OF_MONTH: " + calendar.get(Calendar.WEEK_OF_MONTH));
 * System.out.println("DATE: " + calendar.get(Calendar.DATE));
 * System.out.println("DAY_OF_MONTH: " + calendar.get(Calendar.DAY_OF_MONTH));
 * System.out.println("DAY_OF_YEAR: " + calendar.get(Calendar.DAY_OF_YEAR));
 * System.out.println("DAY_OF_WEEK: " + calendar.get(Calendar.DAY_OF_WEEK));
 * System.out.println("DAY_OF_WEEK_IN_MONTH: "
 *                    + calendar.get(Calendar.DAY_OF_WEEK_IN_MONTH));
 * System.out.println("AM_PM: " + calendar.get(Calendar.AM_PM));
 * System.out.println("HOUR: " + calendar.get(Calendar.HOUR));
 * System.out.println("HOUR_OF_DAY: " + calendar.get(Calendar.HOUR_OF_DAY));
 * System.out.println("MINUTE: " + calendar.get(Calendar.MINUTE));
 * System.out.println("SECOND: " + calendar.get(Calendar.SECOND));
 * System.out.println("MILLISECOND: " + calendar.get(Calendar.MILLISECOND));
 * System.out.println("ZONE_OFFSET: "
 *        + (calendar.get(Calendar.ZONE_OFFSET)/(60*60*1000))); // in hours
 * System.out.println("DST_OFFSET: "
 *        + (calendar.get(Calendar.DST_OFFSET)/(60*60*1000))); // in hours
 * 
 * 
 *
 * @see          TimeZone
 * @author David Goldsmith, Mark Davis, Chen-Lieh Huang, Alan Liu
 * @since 1.1
*/
export class GregorianCalendar extends Calendar {
  /**
   * Value of the `ERA` field indicating
   * the period before the common era (before Christ), also known as BCE.
   * The sequence of years at the transition from `BC` to `AD` is
   * ..., 2 BC, 1 BC, 1 AD, 2 AD,...
   *
   * @see #ERA
  */
  static readonly BC: number;
  /**
   * Value of the `ERA` field indicating
   * the common era (Anno Domini), also known as CE.
   * The sequence of years at the transition from `BC` to `AD` is
   * ..., 2 BC, 1 BC, 1 AD, 2 AD,...
   *
   * @see #ERA
  */
  static readonly AD: number;
  /**
   * Constructs a default `GregorianCalendar` using the current time
   * in the default time zone with the default
   * {@link Locale.Category#FORMAT FORMAT} locale.
  */
  constructor();
  /**
   * Constructs a `GregorianCalendar` based on the current time
   * in the given time zone with the default
   * {@link Locale.Category#FORMAT FORMAT} locale.
   *
   * @param zone the given time zone.
  */
  constructor(zone: TimeZone);
  /**
   * Constructs a `GregorianCalendar` based on the current time
   * in the default time zone with the given locale.
   *
   * @param aLocale the given locale.
  */
  constructor(aLocale: Locale);
  /**
   * Constructs a `GregorianCalendar` based on the current time
   * in the given time zone with the given locale.
   *
   * @param zone the given time zone.
   * @param aLocale the given locale.
  */
  constructor(zone: TimeZone, aLocale: Locale);
  /**
   * Constructs a `GregorianCalendar` with the given date set
   * in the default time zone with the default locale.
   *
   * @param year the value used to set the `YEAR` calendar field in the calendar.
   * @param month the value used to set the `MONTH` calendar field in the calendar.
   * Month value is 0-based. e.g., 0 for January.
   * @param dayOfMonth the value used to set the `DAY_OF_MONTH` calendar field in the calendar.
  */
  constructor(year: number, month: number, dayOfMonth: number);
  /**
   * Constructs a `GregorianCalendar` with the given date
   * and time set for the default time zone with the default locale.
   *
   * @param year the value used to set the `YEAR` calendar field in the calendar.
   * @param month the value used to set the `MONTH` calendar field in the calendar.
   * Month value is 0-based. e.g., 0 for January.
   * @param dayOfMonth the value used to set the `DAY_OF_MONTH` calendar field in the calendar.
   * @param hourOfDay the value used to set the `HOUR_OF_DAY` calendar field
   * in the calendar.
   * @param minute the value used to set the `MINUTE` calendar field
   * in the calendar.
  */
  constructor(year: number, month: number, dayOfMonth: number, hourOfDay: number, minute: number);
  /**
   * Constructs a GregorianCalendar with the given date
   * and time set for the default time zone with the default locale.
   *
   * @param year the value used to set the `YEAR` calendar field in the calendar.
   * @param month the value used to set the `MONTH` calendar field in the calendar.
   * Month value is 0-based. e.g., 0 for January.
   * @param dayOfMonth the value used to set the `DAY_OF_MONTH` calendar field in the calendar.
   * @param hourOfDay the value used to set the `HOUR_OF_DAY` calendar field
   * in the calendar.
   * @param minute the value used to set the `MINUTE` calendar field
   * in the calendar.
   * @param second the value used to set the `SECOND` calendar field
   * in the calendar.
  */
  constructor(year: number, month: number, dayOfMonth: number, hourOfDay: number, minute: number, second: number);
  /**
   * Sets the `GregorianCalendar` change date. This is the point when the switch
   * from Julian dates to Gregorian dates occurred. Default is October 15,
   * 1582 (Gregorian). Previous to this, dates will be in the Julian calendar.
   * 
   * To obtain a pure Julian calendar, set the change date to
   * `Date(Long.MAX_VALUE)`.  To obtain a pure Gregorian calendar,
   * set the change date to `Date(Long.MIN_VALUE)`.
   *
   * @param date the given Gregorian cutover date.
  */
  setGregorianChange(gregorianChange: Date);
  /**
   * Gets the Gregorian Calendar change date.  This is the point when the
   * switch from Julian dates to Gregorian dates occurred. Default is
   * October 15, 1582 (Gregorian). Previous to this, dates will be in the Julian
   * calendar.
   *
   * @return the Gregorian cutover date for this `GregorianCalendar` object.
  */
  getGregorianChange(): Date;
  /**
   * Determines if the given year is a leap year. Returns `true` if
   * the given year is a leap year. To specify BC year numbers,
   * `1 - year number` must be given. For example, year BC 4 is
   * specified as -3.
   *
   * @param year the given year.
   * @return `true` if the given year is a leap year; `false` otherwise.
  */
  isLeapYear(year: number): boolean;
  /**
   * Returns `"gregory"` as the calendar type.
   *
   * @return `"gregory"`
   * @since 1.8
  */
  getCalendarType(): string;
  /**
   * Compares this `GregorianCalendar` to the specified
   * `Object`. The result is `true` if and
   * only if the argument is a `GregorianCalendar` object
   * that represents the same time value (millisecond offset from
   * the Epoch) under the same
   * `Calendar` parameters and Gregorian change date as
   * this object.
   *
   * @param obj the object to compare with.
   * @return `true` if this object is equal to `obj`;
   * `false` otherwise.
   * @see Calendar#compareTo(Calendar)
  */
  equals(obj: any): boolean;
  /**
   * Generates the hash code for this `GregorianCalendar` object.
  */
  hashCode(): number;
  /**
   * Adds the specified (signed) amount of time to the given calendar field,
   * based on the calendar's rules.
   *
   * Add rule 1. The value of `field`
   * after the call minus the value of `field` before the
   * call is `amount`, modulo any overflow that has occurred in
   * `field`. Overflow occurs when a field value exceeds its
   * range and, as a result, the next larger field is incremented or
   * decremented and the field value is adjusted back into its range.
   *
   * Add rule 2. If a smaller field is expected to be
   * invariant, but it is impossible for it to be equal to its
   * prior value because of changes in its minimum or maximum after
   * `field` is changed, then its value is adjusted to be as close
   * as possible to its expected value. A smaller field represents a
   * smaller unit of time. `HOUR` is a smaller field than
   * `DAY_OF_MONTH`. No adjustment is made to smaller fields
   * that are not expected to be invariant. The calendar system
   * determines what fields are expected to be invariant.
   *
   * @param field the calendar field.
   * @param amount the amount of date or time to be added to the field.
   * @throws    IllegalArgumentException if `field` is
   * `ZONE_OFFSET`, `DST_OFFSET`, or unknown,
   * or if any calendar fields have out-of-range values in
   * non-lenient mode.
  */
  add(field: number, amount: number): void;
  /**
   * Adds or subtracts (up/down) a single unit of time on the given time
   * field without changing larger fields.
   * 
   * Example: Consider a `GregorianCalendar`
   * originally set to December 31, 1999. Calling {@link #roll(int,boolean) roll(Calendar.MONTH, true)}
   * sets the calendar to January 31, 1999.  The `YEAR` field is unchanged
   * because it is a larger field than `MONTH`.
   *
   * @param up indicates if the value of the specified calendar field is to be
   * rolled up or rolled down. Use `true` if rolling up, `false` otherwise.
   * @throws    IllegalArgumentException if `field` is
   * `ZONE_OFFSET`, `DST_OFFSET`, or unknown,
   * or if any calendar fields have out-of-range values in
   * non-lenient mode.
   * @see #add(int,int)
   * @see #set(int,int)
  */
  roll(field: number, up: boolean): void;
  /**
   * Adds a signed amount to the specified calendar field without changing larger fields.
   * A negative roll amount means to subtract from field without changing
   * larger fields. If the specified amount is 0, this method performs nothing.
   *
   * This method calls {@link #complete()} before adding the
   * amount so that all the calendar fields are normalized. If there
   * is any calendar field having an out-of-range value in non-lenient mode, then an
   * `IllegalArgumentException` is thrown.
   *
   * 
   * Example: Consider a `GregorianCalendar`
   * originally set to August 31, 1999. Calling roll(Calendar.MONTH,
   * 8) sets the calendar to April 30, 1999. Using a
   * `GregorianCalendar`, the `DAY_OF_MONTH` field cannot
   * be 31 in the month April. `DAY_OF_MONTH` is set to the closest possible
   * value, 30. The `YEAR` field maintains the value of 1999 because it
   * is a larger field than `MONTH`.
   * 
   * Example: Consider a `GregorianCalendar`
   * originally set to Sunday June 6, 1999. Calling
   * `roll(Calendar.WEEK_OF_MONTH, -1)` sets the calendar to
   * Tuesday June 1, 1999, whereas calling
   * `add(Calendar.WEEK_OF_MONTH, -1)` sets the calendar to
   * Sunday May 30, 1999. This is because the roll rule imposes an
   * additional constraint: The `MONTH` must not change when the
   * `WEEK_OF_MONTH` is rolled. Taken together with add rule 1,
   * the resultant date must be between Tuesday June 1 and Saturday June
   * 5. According to add rule 2, the `DAY_OF_WEEK`, an invariant
   * when changing the `WEEK_OF_MONTH`, is set to Tuesday, the
   * closest possible value to Sunday (where Sunday is the first day of the
   * week).
   *
   * @param field the calendar field.
   * @param amount the signed amount to add to `field`.
   * @throws    IllegalArgumentException if `field` is
   * `ZONE_OFFSET`, `DST_OFFSET`, or unknown,
   * or if any calendar fields have out-of-range values in
   * non-lenient mode.
   * @see #roll(int,boolean)
   * @see #add(int,int)
   * @see #set(int,int)
   * @since 1.2
  */
  roll(field: number, amount: number): void;
  /**
   * Returns the minimum value for the given calendar field of this
   * `GregorianCalendar` instance. The minimum value is
   * defined as the smallest value returned by the {@link
   * Calendar#get(int) get} method for any possible time value,
   * taking into consideration the current values of the
   * {@link Calendar#getFirstDayOfWeek() getFirstDayOfWeek},
   * {@link Calendar#getMinimalDaysInFirstWeek() getMinimalDaysInFirstWeek},
   * {@link #getGregorianChange() getGregorianChange} and
   * {@link Calendar#getTimeZone() getTimeZone} methods.
   *
   * @param field the calendar field.
   * @return the minimum value for the given calendar field.
   * @see #getMaximum(int)
   * @see #getGreatestMinimum(int)
   * @see #getLeastMaximum(int)
   * @see #getActualMinimum(int)
   * @see #getActualMaximum(int)
  */
  getMinimum(field: number): number;
  /**
   * Returns the maximum value for the given calendar field of this
   * `GregorianCalendar` instance. The maximum value is
   * defined as the largest value returned by the {@link
   * Calendar#get(int) get} method for any possible time value,
   * taking into consideration the current values of the
   * {@link Calendar#getFirstDayOfWeek() getFirstDayOfWeek},
   * {@link Calendar#getMinimalDaysInFirstWeek() getMinimalDaysInFirstWeek},
   * {@link #getGregorianChange() getGregorianChange} and
   * {@link Calendar#getTimeZone() getTimeZone} methods.
   *
   * @param field the calendar field.
   * @return the maximum value for the given calendar field.
   * @see #getMinimum(int)
   * @see #getGreatestMinimum(int)
   * @see #getLeastMaximum(int)
   * @see #getActualMinimum(int)
   * @see #getActualMaximum(int)
  */
  getMaximum(field: number): number;
  /**
   * Returns the highest minimum value for the given calendar field
   * of this `GregorianCalendar` instance. The highest
   * minimum value is defined as the largest value returned by
   * {@link #getActualMinimum(int)} for any possible time value,
   * taking into consideration the current values of the
   * {@link Calendar#getFirstDayOfWeek() getFirstDayOfWeek},
   * {@link Calendar#getMinimalDaysInFirstWeek() getMinimalDaysInFirstWeek},
   * {@link #getGregorianChange() getGregorianChange} and
   * {@link Calendar#getTimeZone() getTimeZone} methods.
   *
   * @param field the calendar field.
   * @return the highest minimum value for the given calendar field.
   * @see #getMinimum(int)
   * @see #getMaximum(int)
   * @see #getLeastMaximum(int)
   * @see #getActualMinimum(int)
   * @see #getActualMaximum(int)
  */
  getGreatestMinimum(field: number): number;
  /**
   * Returns the lowest maximum value for the given calendar field
   * of this `GregorianCalendar` instance. The lowest
   * maximum value is defined as the smallest value returned by
   * {@link #getActualMaximum(int)} for any possible time value,
   * taking into consideration the current values of the
   * {@link Calendar#getFirstDayOfWeek() getFirstDayOfWeek},
   * {@link Calendar#getMinimalDaysInFirstWeek() getMinimalDaysInFirstWeek},
   * {@link #getGregorianChange() getGregorianChange} and
   * {@link Calendar#getTimeZone() getTimeZone} methods.
   *
   * @param field the calendar field
   * @return the lowest maximum value for the given calendar field.
   * @see #getMinimum(int)
   * @see #getMaximum(int)
   * @see #getGreatestMinimum(int)
   * @see #getActualMinimum(int)
   * @see #getActualMaximum(int)
  */
  getLeastMaximum(field: number): number;
  /**
   * Returns the minimum value that this calendar field could have,
   * taking into consideration the given time value and the current
   * values of the
   * {@link Calendar#getFirstDayOfWeek() getFirstDayOfWeek},
   * {@link Calendar#getMinimalDaysInFirstWeek() getMinimalDaysInFirstWeek},
   * {@link #getGregorianChange() getGregorianChange} and
   * {@link Calendar#getTimeZone() getTimeZone} methods.
   *
   * For example, if the Gregorian change date is January 10,
   * 1970 and the date of this `GregorianCalendar` is
   * January 20, 1970, the actual minimum value of the
   * `DAY_OF_MONTH` field is 10 because the previous date
   * of January 10, 1970 is December 27, 1996 (in the Julian
   * calendar). Therefore, December 28, 1969 to January 9, 1970
   * don't exist.
   *
   * @param field the calendar field
   * @return the minimum of the given field for the time value of
   * this `GregorianCalendar`
   * @see #getMinimum(int)
   * @see #getMaximum(int)
   * @see #getGreatestMinimum(int)
   * @see #getLeastMaximum(int)
   * @see #getActualMaximum(int)
   * @since 1.2
  */
  getActualMinimum(field: number): number;
  /**
   * Returns the maximum value that this calendar field could have,
   * taking into consideration the given time value and the current
   * values of the
   * {@link Calendar#getFirstDayOfWeek() getFirstDayOfWeek},
   * {@link Calendar#getMinimalDaysInFirstWeek() getMinimalDaysInFirstWeek},
   * {@link #getGregorianChange() getGregorianChange} and
   * {@link Calendar#getTimeZone() getTimeZone} methods.
   * For example, if the date of this instance is February 1, 2004,
   * the actual maximum value of the `DAY_OF_MONTH` field
   * is 29 because 2004 is a leap year, and if the date of this
   * instance is February 1, 2005, it's 28.
   *
   * This method calculates the maximum value of {@link
   * Calendar#WEEK_OF_YEAR WEEK_OF_YEAR} based on the {@link
   * Calendar#YEAR YEAR} (calendar year) value, not the week year. Call {@link
   * #getWeeksInWeekYear()} to get the maximum value of `     * WEEK_OF_YEAR` in the week year of this `GregorianCalendar`.
   *
   * @param field the calendar field
   * @return the maximum of the given field for the time value of
   * this `GregorianCalendar`
   * @see #getMinimum(int)
   * @see #getMaximum(int)
   * @see #getGreatestMinimum(int)
   * @see #getLeastMaximum(int)
   * @see #getActualMinimum(int)
   * @since 1.2
  */
  getActualMaximum(field: number): number;
  clone(): any;
  getTimeZone(): TimeZone;
  setTimeZone(timeZone: TimeZone);
  /**
   * Returns `true` indicating this `GregorianCalendar`
   * supports week dates.
   *
   * @return `true` (always)
   * @see #getWeekYear()
   * @see #setWeekDate(int,int,int)
   * @see #getWeeksInWeekYear()
   * @since 1.7
  */
  isWeekDateSupported(): boolean;
  /**
   * Returns the week year represented by this
   * `GregorianCalendar`. The dates in the weeks between 1 and the
   * maximum week number of the week year have the same week year value
   * that may be one year before or after the {@link Calendar#YEAR YEAR}
   * (calendar year) value.
   *
   * This method calls {@link Calendar#complete()} before
   * calculating the week year.
   *
   * @return the week year represented by this `GregorianCalendar`.
   *         If the {@link Calendar#ERA ERA} value is {@link #BC}, the year is
   *         represented by 0 or a negative number: BC 1 is 0, BC 2
   *         is -1, BC 3 is -2, and so on.
   * @throws IllegalArgumentException
   *         if any of the calendar fields is invalid in non-lenient mode.
   * @see #isWeekDateSupported()
   * @see #getWeeksInWeekYear()
   * @see Calendar#getFirstDayOfWeek()
   * @see Calendar#getMinimalDaysInFirstWeek()
   * @since 1.7
  */
  getWeekYear(): number;
  /**
   * Sets this `GregorianCalendar` to the date given by the
   * date specifiers - `weekYear`,
   * `weekOfYear`, and `dayOfWeek`. `weekOfYear`
   * follows the `WEEK_OF_YEAR`
   * numbering.  The `dayOfWeek` value must be one of the
   * {@link Calendar#DAY_OF_WEEK DAY_OF_WEEK} values: {@link
   * Calendar#SUNDAY SUNDAY} to {@link Calendar#SATURDAY SATURDAY}.
   *
   * Note that the numeric day-of-week representation differs from
   * the ISO 8601 standard, and that the `weekOfYear`
   * numbering is compatible with the standard when `     * getFirstDayOfWeek()` is `MONDAY` and `     * getMinimalDaysInFirstWeek()` is 4.
   *
   * Unlike the `set` method, all of the calendar fields
   * and the instant of time value are calculated upon return.
   *
   * If `weekOfYear` is out of the valid week-of-year
   * range in `weekYear`, the `weekYear`
   * and `weekOfYear` values are adjusted in lenient
   * mode, or an `IllegalArgumentException` is thrown in
   * non-lenient mode.
   *
   * @param weekYear    the week year
   * @param weekOfYear  the week number based on `weekYear`
   * @param dayOfWeek   the day of week value: one of the constants
   *                    for the {@link #DAY_OF_WEEK DAY_OF_WEEK} field:
   *                    {@link Calendar#SUNDAY SUNDAY}, ...,
   *                    {@link Calendar#SATURDAY SATURDAY}.
   * @throws    IllegalArgumentException
   *            if any of the given date specifiers is invalid,
   *            or if any of the calendar fields are inconsistent
   *            with the given date specifiers in non-lenient mode
   * @see GregorianCalendar#isWeekDateSupported()
   * @see Calendar#getFirstDayOfWeek()
   * @see Calendar#getMinimalDaysInFirstWeek()
   * @since 1.7
  */
  setWeekDate(weekYear: number, weekOfYear: number, dayOfWeek: number): void;
  /**
   * Returns the number of weeks in the week year
   * represented by this `GregorianCalendar`.
   *
   * For example, if this `GregorianCalendar`'s date is
   * December 31, 2008 with the ISO
   * 8601 compatible setting, this method will return 53 for the
   * period: December 29, 2008 to January 3, 2010 while {@link
   * #getActualMaximum(int) getActualMaximum(WEEK_OF_YEAR)} will return
   * 52 for the period: December 31, 2007 to December 28, 2008.
   *
   * @return the number of weeks in the week year.
   * @see Calendar#WEEK_OF_YEAR
   * @see #getWeekYear()
   * @see #getActualMaximum(int)
   * @since 1.7
  */
  getWeeksInWeekYear(): number;
  /**
   * Converts this object to a `ZonedDateTime` that represents
   * the same point on the time-line as this `GregorianCalendar`.
   * 
   * Since this object supports a Julian-Gregorian cutover date and
   * `ZonedDateTime` does not, it is possible that the resulting year,
   * month and day will have different values.  The result will represent the
   * correct date in the ISO calendar system, which will also be the same value
   * for Modified Julian Days.
   *
   * @return a zoned date-time representing the same point on the time-line
   *  as this gregorian calendar
   * @since 1.8
  */
  toZonedDateTime(): ZonedDateTime;
  /**
   * Obtains an instance of `GregorianCalendar` with the default locale
   * from a `ZonedDateTime` object.
   * 
   * Since `ZonedDateTime` does not support a Julian-Gregorian cutover
   * date and uses ISO calendar system, the return GregorianCalendar is a pure
   * Gregorian calendar and uses ISO 8601 standard for week definitions,
   * which has `MONDAY` as the {@link Calendar#getFirstDayOfWeek()
   * FirstDayOfWeek} and `4` as the value of the
   * {@link Calendar#getMinimalDaysInFirstWeek() MinimalDaysInFirstWeek}.
   * 
   * `ZoneDateTime` can store points on the time-line further in the
   * future and further in the past than `GregorianCalendar`. In this
   * scenario, this method will throw an `IllegalArgumentException`
   * exception.
   *
   * @param zdt  the zoned date-time object to convert
   * @return  the gregorian calendar representing the same point on the
   *  time-line as the zoned date-time provided
   * @throws    NullPointerException if `zdt` is null
   * @throws    IllegalArgumentException if the zoned date-time is too
   * large to represent as a `GregorianCalendar`
   * @since 1.8
  */
  static from(zdt: ZonedDateTime): GregorianCalendar;
}
/**
 * `PropertyResourceBundle` is a concrete subclass of
 * `ResourceBundle` that manages resources for a locale
 * using a set of static strings from a property file. See
 * {@link ResourceBundle ResourceBundle} for more information about resource
 * bundles.
 *
 * 
 * Unlike other types of resource bundle, you don't subclass
 * `PropertyResourceBundle`.  Instead, you supply properties
 * files containing the resource data.  `ResourceBundle.getBundle`
 * will automatically look for the appropriate properties file and create a
 * `PropertyResourceBundle` that refers to it. See
 * {@link ResourceBundle#getBundle(String, Locale, ClassLoader) ResourceBundle.getBundle}
 * for a complete description of the search and instantiation strategy.
 *
 * 
 * The following example shows a member of a resource
 * bundle family with the base name "MyResources".
 * The text defines the bundle "MyResources_de",
 * the German member of the bundle family.
 * This member is based on `PropertyResourceBundle`, and the text
 * therefore is the content of the file "MyResources_de.properties"
 * (a related example shows
 * how you can add bundles to this family that are implemented as subclasses
 * of `ListResourceBundle`).
 * The keys in this example are of the form "s1" etc. The actual
 * keys are entirely up to your choice, so long as they are the same as
 * the keys you use in your program to retrieve the objects from the bundle.
 * Keys are case-sensitive.
 * 
 *  * # MessageFormat pattern
 * s1=Die Platte \"{1}\" enthält {0}.
 *
 * # location of {0} in pattern
 * s2=1
 *
 * # sample disk name
 * s3=Meine Platte
 *
 * # first ChoiceFormat choice
 * s4=keine Dateien
 *
 * # second ChoiceFormat choice
 * s5=eine Datei
 *
 * # third ChoiceFormat choice
 * s6={0,number} Dateien
 *
 * # sample date
 * s7=3. März 1996
 * 
 * 
 *
 * @apiNote
 * `PropertyResourceBundle` can be constructed either
 * from an `InputStream` or a `Reader`, which represents a property file.
 * Constructing a `PropertyResourceBundle` instance from an `InputStream`
 * requires that the input stream be encoded in `UTF-8`. By default, if a
 * {@link java.nio.charset.MalformedInputException} or an
 * {@link java.nio.charset.UnmappableCharacterException} occurs on reading the
 * input stream, then the `PropertyResourceBundle` instance resets to the state
 * before the exception, re-reads the input stream in `ISO-8859-1`, and
 * continues reading. If the system property
 * {@systemProperty java.util.PropertyResourceBundle.encoding} is set to either
 * "ISO-8859-1" or "UTF-8", the input stream is solely read in that encoding,
 * and throws the exception if it encounters an invalid sequence.
 * If "ISO-8859-1" is specified, characters that cannot be represented in
 * ISO-8859-1 encoding must be represented by Unicode Escapes as defined in section
 * {@jls 3.3} of The Java Language Specification
 * whereas the other constructor which takes a `Reader` does not have that limitation.
 * Other encoding values are ignored for this system property.
 * The system property is read and evaluated when initializing this class.
 * Changing or removing the property has no effect after the initialization.
 *
 * @implSpec
 * The implementation of a `PropertyResourceBundle` subclass must be
 * thread-safe if it's simultaneously used by multiple threads. The default
 * implementations of the non-abstract methods in this class are thread-safe.
 *
 * @see ResourceBundle
 * @see ListResourceBundle
 * @see Properties
 * @since 1.1
*/
export class PropertyResourceBundle extends ResourceBundle {
  /**
   * Creates a property resource bundle from an {@link java.io.InputStream
   * InputStream}. This constructor reads the property file in UTF-8 by default.
   * If a {@link java.nio.charset.MalformedInputException} or an
   * {@link java.nio.charset.UnmappableCharacterException} occurs on reading the
   * input stream, then the PropertyResourceBundle instance resets to the state
   * before the exception, re-reads the input stream in `ISO-8859-1` and
   * continues reading. If the system property
   * `java.util.PropertyResourceBundle.encoding` is set to either
   * "ISO-8859-1" or "UTF-8", the input stream is solely read in that encoding,
   * and throws the exception if it encounters an invalid sequence. Other
   * encoding values are ignored for this system property.
   * The system property is read and evaluated when initializing this class.
   * Changing or removing the property has no effect after the initialization.
   *
   * @param stream an InputStream that represents a property file
   *        to read from.
   * @throws IOException if an I/O error occurs
   * @throws NullPointerException if `stream` is null
   * @throws IllegalArgumentException if `stream` contains a
   *     malformed Unicode escape sequence.
   * @throws MalformedInputException if the system property
   *     `java.util.PropertyResourceBundle.encoding` is set to "UTF-8"
   *     and `stream` contains an invalid UTF-8 byte sequence.
   * @throws UnmappableCharacterException if the system property
   *     `java.util.PropertyResourceBundle.encoding` is set to "UTF-8"
   *     and `stream` contains an unmappable UTF-8 byte sequence.
  */
  constructor(stream: InputStream);
  /**
   * Creates a property resource bundle from a {@link java.io.Reader
   * Reader}.  Unlike the constructor
   * {@link #PropertyResourceBundle(java.io.InputStream) PropertyResourceBundle(InputStream)},
   * there is no limitation as to the encoding of the input property file.
   *
   * @param reader a Reader that represents a property file to
   *        read from.
   * @throws IOException if an I/O error occurs
   * @throws NullPointerException if `reader` is null
   * @throws IllegalArgumentException if a malformed Unicode escape sequence appears
   *     from `reader`.
   * @since 1.6
  */
  constructor(reader: Reader);
  handleGetObject(key: string): any;
  /**
   * Returns an `Enumeration` of the keys contained in
   * this `ResourceBundle` and its parent bundles.
   *
   * @return an `Enumeration` of the keys contained in
   *         this `ResourceBundle` and its parent bundles.
   * @see #keySet()
  */
  getKeys(): Enumeration<string>;
}
/**
 * A tagging interface that all event listener interfaces must extend.
 * @since 1.1
*/
export class EventListener {

}
/**
 * This exception may be thrown by methods that have detected concurrent
 * modification of an object when such modification is not permissible.
 * 
 * For example, it is not generally permissible for one thread to modify a Collection
 * while another thread is iterating over it.  In general, the results of the
 * iteration are undefined under these circumstances.  Some Iterator
 * implementations (including those of all the general purpose collection implementations
 * provided by the JRE) may choose to throw this exception if this behavior is
 * detected.  Iterators that do this are known as fail-fast iterators,
 * as they fail quickly and cleanly, rather that risking arbitrary,
 * non-deterministic behavior at an undetermined time in the future.
 * 
 * Note that this exception does not always indicate that an object has
 * been concurrently modified by a different thread.  If a single
 * thread issues a sequence of method invocations that violates the
 * contract of an object, the object may throw this exception.  For
 * example, if a thread modifies a collection directly while it is
 * iterating over the collection with a fail-fast iterator, the iterator
 * will throw this exception.
 *
 * Note that fail-fast behavior cannot be guaranteed as it is, generally
 * speaking, impossible to make any hard guarantees in the presence of
 * unsynchronized concurrent modification.  Fail-fast operations
 * throw `ConcurrentModificationException` on a best-effort basis.
 * Therefore, it would be wrong to write a program that depended on this
 * exception for its correctness: `ConcurrentModificationException`
 * should be used only to detect bugs.
 *
 * @author  Josh Bloch
 * @see     Collection
 * @see     Iterator
 * @see     Spliterator
 * @see     ListIterator
 * @see     Vector
 * @see     LinkedList
 * @see     HashSet
 * @see     Hashtable
 * @see     TreeMap
 * @see     AbstractList
 * @since   1.2
*/
export class ConcurrentModificationException extends RuntimeException {
  /**
   * Constructs a ConcurrentModificationException with no
   * detail message.
  */
  constructor();
  /**
   * Constructs a `ConcurrentModificationException` with the
   * specified detail message.
   *
   * @param message the detail message pertaining to this exception.
  */
  constructor(message: string);
  /**
   * Constructs a new exception with the specified cause and a detail
   * message of `(cause==null ? null : cause.toString())` (which
   * typically contains the class and detail message of `cause`.
   *
   * @param  cause the cause (which is saved for later retrieval by the
   *         {@link Throwable#getCause()} method).  (A `null` value is
   *         permitted, and indicates that the cause is nonexistent or
   *         unknown.)
   * @since  1.7
  */
  constructor(cause: Throwable);
  /**
   * Constructs a new exception with the specified detail message and
   * cause.
   *
   * Note that the detail message associated with `cause` is
   * not automatically incorporated in this exception's detail
   * message.
   *
   * @param  message the detail message (which is saved for later retrieval
   *         by the {@link Throwable#getMessage()} method).
   * @param  cause the cause (which is saved for later retrieval by the
   *         {@link Throwable#getCause()} method).  (A `null` value
   *         is permitted, and indicates that the cause is nonexistent or
   *         unknown.)
   * @since 1.7
  */
  constructor(message: string, cause: Throwable);
}
/**
 * The string tokenizer class allows an application to break a
 * string into tokens. The tokenization method is much simpler than
 * the one used by the `StreamTokenizer` class. The
 * `StringTokenizer` methods do not distinguish among
 * identifiers, numbers, and quoted strings, nor do they recognize
 * and skip comments.
 * 
 * The set of delimiters (the characters that separate tokens) may
 * be specified either at creation time or on a per-token basis.
 * 
 * An instance of `StringTokenizer` behaves in one of two
 * ways, depending on whether it was created with the
 * `returnDelims` flag having the value `true`
 * or `false`:
 * 
 * If the flag is `false`, delimiter characters serve to
 *     separate tokens. A token is a maximal sequence of consecutive
 *     characters that are not delimiters.
 * If the flag is `true`, delimiter characters are themselves
 *     considered to be tokens. A token is thus either one delimiter
 *     character, or a maximal sequence of consecutive characters that are
 *     not delimiters.
 * 
 * A `StringTokenizer` object internally maintains a current
 * position within the string to be tokenized. Some operations advance this
 * current position past the characters processed.
 * A token is returned by taking a substring of the string that was used to
 * create the `StringTokenizer` object.
 * 
 * The following is one example of the use of the tokenizer. The code:
 *  *     StringTokenizer st = new StringTokenizer("this is a test");
 *     while (st.hasMoreTokens()) {
 *         System.out.println(st.nextToken());
 *     }
 * 
 * 
 * prints the following output:
 *  *     this
 *     is
 *     a
 *     test
 * 
 *
 * 
 * `StringTokenizer` is a legacy class that is retained for
 * compatibility reasons although its use is discouraged in new code. It is
 * recommended that anyone seeking this functionality use the `split`
 * method of `String` or the java.util.regex package instead.
 * 
 * The following example illustrates how the `String.split`
 * method can be used to break up a string into its basic tokens:
 *  *     String[] result = "this is a test".split("\\s");
 *     for (int x=0; x<result.length; x++)
 *         System.out.println(result[x]);
 * 
 * 
 * prints the following output:
 *  *     this
 *     is
 *     a
 *     test
 * 
 *
 * @see     java.io.StreamTokenizer
 * @since   1.0
*/
export class StringTokenizer extends Enumeration<any> {
  /**
   * Constructs a string tokenizer for the specified string. All
   * characters in the `delim` argument are the delimiters
   * for separating tokens.
   * 
   * If the `returnDelims` flag is `true`, then
   * the delimiter characters are also returned as tokens. Each
   * delimiter is returned as a string of length one. If the flag is
   * `false`, the delimiter characters are skipped and only
   * serve as separators between tokens.
   * 
   * Note that if `delim` is `null`, this constructor does
   * not throw an exception. However, trying to invoke other methods on the
   * resulting `StringTokenizer` may result in a
   * `NullPointerException`.
   *
   * @param   str            a string to be parsed.
   * @param   delim          the delimiters.
   * @param   returnDelims   flag indicating whether to return the delimiters
   *                         as tokens.
   * @throws    NullPointerException if str is `null`
  */
  constructor(str: string, delim: string, returnDelims: boolean);
  /**
   * Constructs a string tokenizer for the specified string. The
   * characters in the `delim` argument are the delimiters
   * for separating tokens. Delimiter characters themselves will not
   * be treated as tokens.
   * 
   * Note that if `delim` is `null`, this constructor does
   * not throw an exception. However, trying to invoke other methods on the
   * resulting `StringTokenizer` may result in a
   * `NullPointerException`.
   *
   * @param   str     a string to be parsed.
   * @param   delim   the delimiters.
   * @throws    NullPointerException if str is `null`
  */
  constructor(str: string, delim: string);
  /**
   * Constructs a string tokenizer for the specified string. The
   * tokenizer uses the default delimiter set, which is
   * " \t\n\r\f": the space character,
   * the tab character, the newline character, the carriage-return character,
   * and the form-feed character. Delimiter characters themselves will
   * not be treated as tokens.
   *
   * @param   str   a string to be parsed.
   * @throws    NullPointerException if str is `null`
  */
  constructor(str: string);
  /**
   * Tests if there are more tokens available from this tokenizer's string.
   * If this method returns `true`, then a subsequent call to
   * `nextToken` with no argument will successfully return a token.
   *
   * @return  `true` if and only if there is at least one token
   *          in the string after the current position; `false`
   *          otherwise.
  */
  hasMoreTokens(): boolean;
  /**
   * Returns the next token from this string tokenizer.
   *
   * @return     the next token from this string tokenizer.
   * @throws     NoSuchElementException  if there are no more tokens in this
   *               tokenizer's string.
  */
  nextToken(): string;
  /**
   * Returns the next token in this string tokenizer's string. First,
   * the set of characters considered to be delimiters by this
   * `StringTokenizer` object is changed to be the characters in
   * the string `delim`. Then the next token in the string
   * after the current position is returned. The current position is
   * advanced beyond the recognized token.  The new delimiter set
   * remains the default after this call.
   *
   * @param      delim   the new delimiters.
   * @return     the next token, after switching to the new delimiter set.
   * @throws     NoSuchElementException  if there are no more tokens in this
   *               tokenizer's string.
   * @throws    NullPointerException if delim is `null`
  */
  nextToken(delim: string): string;
  /**
   * Returns the same value as the `hasMoreTokens`
   * method. It exists so that this class can implement the
   * `Enumeration` interface.
   *
   * @return  `true` if there are more tokens;
   *          `false` otherwise.
   * @see     java.util.Enumeration
   * @see     java.util.StringTokenizer#hasMoreTokens()
  */
  hasMoreElements(): boolean;
  /**
   * Returns the same value as the `nextToken` method,
   * except that its declared return value is `Object` rather than
   * `String`. It exists so that this class can implement the
   * `Enumeration` interface.
   *
   * @return     the next token in the string.
   * @throws     NoSuchElementException  if there are no more tokens in this
   *               tokenizer's string.
   * @see        java.util.Enumeration
   * @see        java.util.StringTokenizer#nextToken()
  */
  nextElement(): any;
  /**
   * Calculates the number of times that this tokenizer's
   * `nextToken` method can be called before it generates an
   * exception. The current position is not advanced.
   *
   * @return  the number of tokens remaining in the string using the current
   *          delimiter set.
   * @see     java.util.StringTokenizer#nextToken()
  */
  countTokens(): number;
}
/**
 * Unchecked exception thrown when an unknown flag is given.
 *
 *  Unless otherwise specified, passing a `null` argument to any
 * method or constructor in this class will cause a {@link
 * NullPointerException} to be thrown.
 *
 * @since 1.5
*/
export class UnknownFormatFlagsException extends IllegalFormatException {
  /**
   * Constructs an instance of this class with the specified flags.
   *
   * @param  f
   *         The set of format flags which contain an unknown flag
  */
  constructor(f: string);
  /**
   * Returns the set of flags which contains an unknown flag.
   *
   * @return  The flags
  */
  getFlags(): string;
  getMessage(): string;
}
/**
 * An iterator for lists that allows the programmer
 * to traverse the list in either direction, modify
 * the list during iteration, and obtain the iterator's
 * current position in the list. A `ListIterator`
 * has no current element; its cursor position always
 * lies between the element that would be returned by a call
 * to `previous()` and the element that would be
 * returned by a call to `next()`.
 * An iterator for a list of length `n` has `n+1` possible
 * cursor positions, as illustrated by the carets (`^`) below:
 *  *                      Element(0)   Element(1)   Element(2)   ... Element(n-1)
 * cursor positions:  ^            ^            ^            ^                  ^
 * 
 * Note that the {@link #remove} and {@link #set(Object)} methods are
 * not defined in terms of the cursor position;  they are defined to
 * operate on the last element returned by a call to {@link #next} or
 * {@link #previous()}.
 *
 * This interface is a member of the
 * 
 * Java Collections Framework.
 *
 * @author  Josh Bloch
 * @see Collection
 * @see List
 * @see Iterator
 * @see Enumeration
 * @see List#listIterator()
 * @since   1.2
*/
export class ListIterator<E> extends Iterator<E> {
  /**
   * Returns `true` if this list iterator has more elements when
   * traversing the list in the forward direction. (In other words,
   * returns `true` if {@link #next} would return an element rather
   * than throwing an exception.)
   *
   * @return `true` if the list iterator has more elements when
   *         traversing the list in the forward direction
  */
  hasNext(): boolean;
  /**
   * Returns the next element in the list and advances the cursor position.
   * This method may be called repeatedly to iterate through the list,
   * or intermixed with calls to {@link #previous} to go back and forth.
   * (Note that alternating calls to `next` and `previous`
   * will return the same element repeatedly.)
   *
   * @return the next element in the list
   * @throws NoSuchElementException if the iteration has no next element
  */
  next(): E;
  /**
   * Returns `true` if this list iterator has more elements when
   * traversing the list in the reverse direction.  (In other words,
   * returns `true` if {@link #previous} would return an element
   * rather than throwing an exception.)
   *
   * @return `true` if the list iterator has more elements when
   *         traversing the list in the reverse direction
  */
  hasPrevious(): boolean;
  /**
   * Returns the previous element in the list and moves the cursor
   * position backwards.  This method may be called repeatedly to
   * iterate through the list backwards, or intermixed with calls to
   * {@link #next} to go back and forth.  (Note that alternating calls
   * to `next` and `previous` will return the same
   * element repeatedly.)
   *
   * @return the previous element in the list
   * @throws NoSuchElementException if the iteration has no previous
   *         element
  */
  previous(): E;
  /**
   * Returns the index of the element that would be returned by a
   * subsequent call to {@link #next}. (Returns list size if the list
   * iterator is at the end of the list.)
   *
   * @return the index of the element that would be returned by a
   *         subsequent call to `next`, or list size if the list
   *         iterator is at the end of the list
  */
  nextIndex(): number;
  /**
   * Returns the index of the element that would be returned by a
   * subsequent call to {@link #previous}. (Returns -1 if the list
   * iterator is at the beginning of the list.)
   *
   * @return the index of the element that would be returned by a
   *         subsequent call to `previous`, or -1 if the list
   *         iterator is at the beginning of the list
  */
  previousIndex(): number;
  /**
   * Removes from the list the last element that was returned by {@link
   * #next} or {@link #previous} (optional operation).  This call can
   * only be made once per call to `next` or `previous`.
   * It can be made only if {@link #add} has not been
   * called after the last call to `next` or `previous`.
   *
   * @throws UnsupportedOperationException if the `remove`
   *         operation is not supported by this list iterator
   * @throws IllegalStateException if neither `next` nor
   *         `previous` have been called, or `remove` or
   *         `add` have been called after the last call to
   *         `next` or `previous`
  */
  remove(): void;
  /**
   * Replaces the last element returned by {@link #next} or
   * {@link #previous} with the specified element (optional operation).
   * This call can be made only if neither {@link #remove} nor {@link
   * #add} have been called after the last call to `next` or
   * `previous`.
   *
   * @param e the element with which to replace the last element returned by
   *          `next` or `previous`
   * @throws UnsupportedOperationException if the `set` operation
   *         is not supported by this list iterator
   * @throws ClassCastException if the class of the specified element
   *         prevents it from being added to this list
   * @throws IllegalArgumentException if some aspect of the specified
   *         element prevents it from being added to this list
   * @throws IllegalStateException if neither `next` nor
   *         `previous` have been called, or `remove` or
   *         `add` have been called after the last call to
   *         `next` or `previous`
  */
  set(e: E): void;
  /**
   * Inserts the specified element into the list (optional operation).
   * The element is inserted immediately before the element that
   * would be returned by {@link #next}, if any, and after the element
   * that would be returned by {@link #previous}, if any.  (If the
   * list contains no elements, the new element becomes the sole element
   * on the list.)  The new element is inserted before the implicit
   * cursor: a subsequent call to `next` would be unaffected, and a
   * subsequent call to `previous` would return the new element.
   * (This call increases by one the value that would be returned by a
   * call to `nextIndex` or `previousIndex`.)
   *
   * @param e the element to insert
   * @throws UnsupportedOperationException if the `add` method is
   *         not supported by this list iterator
   * @throws ClassCastException if the class of the specified element
   *         prevents it from being added to this list
   * @throws IllegalArgumentException if some aspect of this element
   *         prevents it from being added to this list
  */
  add(e: E): void;
}
/**
 * Static classes and methods for operating on or creating instances of
 * {@link Spliterator} and its primitive specializations
 * {@link Spliterator.OfInt}, {@link Spliterator.OfLong}, and
 * {@link Spliterator.OfDouble}.
 *
 * @see Spliterator
 * @since 1.8
*/
export class Spliterators {
  /**
   * Creates an empty `Spliterator`
   *
   * The empty spliterator reports {@link Spliterator#SIZED} and
   * {@link Spliterator#SUBSIZED}.  Calls to
   * {@link java.util.Spliterator#trySplit()} always return `null`.
   *
   * @param  Type of elements
   * @return An empty spliterator
  */
  static emptySpliterator<T>(): Spliterator<T>;
  /**
   * Creates an empty `Spliterator.OfInt`
   *
   * The empty spliterator reports {@link Spliterator#SIZED} and
   * {@link Spliterator#SUBSIZED}.  Calls to
   * {@link java.util.Spliterator#trySplit()} always return `null`.
   *
   * @return An empty spliterator
  */
  static emptyIntSpliterator(): OfInt;
  /**
   * Creates an empty `Spliterator.OfLong`
   *
   * The empty spliterator reports {@link Spliterator#SIZED} and
   * {@link Spliterator#SUBSIZED}.  Calls to
   * {@link java.util.Spliterator#trySplit()} always return `null`.
   *
   * @return An empty spliterator
  */
  static emptyLongSpliterator(): OfLong;
  /**
   * Creates an empty `Spliterator.OfDouble`
   *
   * The empty spliterator reports {@link Spliterator#SIZED} and
   * {@link Spliterator#SUBSIZED}.  Calls to
   * {@link java.util.Spliterator#trySplit()} always return `null`.
   *
   * @return An empty spliterator
  */
  static emptyDoubleSpliterator(): OfDouble;
  /**
   * Creates a `Spliterator` covering the elements of a given array,
   * using a customized set of spliterator characteristics.
   *
   * This method is provided as an implementation convenience for
   * Spliterators which store portions of their elements in arrays, and need
   * fine control over Spliterator characteristics.  Most other situations in
   * which a Spliterator for an array is needed should use
   * {@link Arrays#spliterator(Object[])}.
   *
   * The returned spliterator always reports the characteristics
   * `SIZED` and `SUBSIZED`.  The caller may provide additional
   * characteristics for the spliterator to report; it is common to
   * additionally specify `IMMUTABLE` and `ORDERED`.
   *
   * @param  Type of elements
   * @param array The array, assumed to be unmodified during use
   * @param additionalCharacteristics Additional spliterator characteristics
   *        of this spliterator's source or elements beyond `SIZED` and
   *        `SUBSIZED` which are always reported
   * @return A spliterator for an array
   * @throws NullPointerException if the given array is `null`
   * @see Arrays#spliterator(Object[])
  */
  static spliterator<T>(array: any[], additionalCharacteristics: number): Spliterator<T>;
  /**
   * Creates a `Spliterator` covering a range of elements of a given
   * array, using a customized set of spliterator characteristics.
   *
   * This method is provided as an implementation convenience for
   * Spliterators which store portions of their elements in arrays, and need
   * fine control over Spliterator characteristics.  Most other situations in
   * which a Spliterator for an array is needed should use
   * {@link Arrays#spliterator(Object[])}.
   *
   * The returned spliterator always reports the characteristics
   * `SIZED` and `SUBSIZED`.  The caller may provide additional
   * characteristics for the spliterator to report; it is common to
   * additionally specify `IMMUTABLE` and `ORDERED`.
   *
   * @param  Type of elements
   * @param array The array, assumed to be unmodified during use
   * @param fromIndex The least index (inclusive) to cover
   * @param toIndex One past the greatest index to cover
   * @param additionalCharacteristics Additional spliterator characteristics
   *        of this spliterator's source or elements beyond `SIZED` and
   *        `SUBSIZED` which are always reported
   * @return A spliterator for an array
   * @throws NullPointerException if the given array is `null`
   * @throws ArrayIndexOutOfBoundsException if `fromIndex` is negative,
   *         `toIndex` is less than `fromIndex`, or
   *         `toIndex` is greater than the array size
   * @see Arrays#spliterator(Object[], int, int)
  */
  static spliterator<T>(array: any[], fromIndex: number, toIndex: number, additionalCharacteristics: number): Spliterator<T>;
  /**
   * Creates a `Spliterator.OfInt` covering the elements of a given array,
   * using a customized set of spliterator characteristics.
   *
   * This method is provided as an implementation convenience for
   * Spliterators which store portions of their elements in arrays, and need
   * fine control over Spliterator characteristics.  Most other situations in
   * which a Spliterator for an array is needed should use
   * {@link Arrays#spliterator(int[])}.
   *
   * The returned spliterator always reports the characteristics
   * `SIZED` and `SUBSIZED`.  The caller may provide additional
   * characteristics for the spliterator to report; it is common to
   * additionally specify `IMMUTABLE` and `ORDERED`.
   *
   * @param array The array, assumed to be unmodified during use
   * @param additionalCharacteristics Additional spliterator characteristics
   *        of this spliterator's source or elements beyond `SIZED` and
   *        `SUBSIZED` which are always reported
   * @return A spliterator for an array
   * @throws NullPointerException if the given array is `null`
   * @see Arrays#spliterator(int[])
  */
  static spliterator(array: number[], additionalCharacteristics: number): OfInt;
  /**
   * Creates a `Spliterator.OfInt` covering a range of elements of a
   * given array, using a customized set of spliterator characteristics.
   *
   * This method is provided as an implementation convenience for
   * Spliterators which store portions of their elements in arrays, and need
   * fine control over Spliterator characteristics.  Most other situations in
   * which a Spliterator for an array is needed should use
   * {@link Arrays#spliterator(int[], int, int)}.
   *
   * The returned spliterator always reports the characteristics
   * `SIZED` and `SUBSIZED`.  The caller may provide additional
   * characteristics for the spliterator to report; it is common to
   * additionally specify `IMMUTABLE` and `ORDERED`.
   *
   * @param array The array, assumed to be unmodified during use
   * @param fromIndex The least index (inclusive) to cover
   * @param toIndex One past the greatest index to cover
   * @param additionalCharacteristics Additional spliterator characteristics
   *        of this spliterator's source or elements beyond `SIZED` and
   *        `SUBSIZED` which are always reported
   * @return A spliterator for an array
   * @throws NullPointerException if the given array is `null`
   * @throws ArrayIndexOutOfBoundsException if `fromIndex` is negative,
   *         `toIndex` is less than `fromIndex`, or
   *         `toIndex` is greater than the array size
   * @see Arrays#spliterator(int[], int, int)
  */
  static spliterator(array: number[], fromIndex: number, toIndex: number, additionalCharacteristics: number): OfInt;
  /**
   * Creates a `Spliterator.OfLong` covering the elements of a given array,
   * using a customized set of spliterator characteristics.
   *
   * This method is provided as an implementation convenience for
   * Spliterators which store portions of their elements in arrays, and need
   * fine control over Spliterator characteristics.  Most other situations in
   * which a Spliterator for an array is needed should use
   * {@link Arrays#spliterator(long[])}.
   *
   * The returned spliterator always reports the characteristics
   * `SIZED` and `SUBSIZED`.  The caller may provide additional
   * characteristics for the spliterator to report; it is common to
   * additionally specify `IMMUTABLE` and `ORDERED`.
   *
   * @param array The array, assumed to be unmodified during use
   * @param additionalCharacteristics Additional spliterator characteristics
   *        of this spliterator's source or elements beyond `SIZED` and
   *        `SUBSIZED` which are always reported
   * @return A spliterator for an array
   * @throws NullPointerException if the given array is `null`
   * @see Arrays#spliterator(long[])
  */
  static spliterator(array: number[], additionalCharacteristics: number): OfLong;
  /**
   * Creates a `Spliterator.OfLong` covering a range of elements of a
   * given array, using a customized set of spliterator characteristics.
   *
   * This method is provided as an implementation convenience for
   * Spliterators which store portions of their elements in arrays, and need
   * fine control over Spliterator characteristics.  Most other situations in
   * which a Spliterator for an array is needed should use
   * {@link Arrays#spliterator(long[], int, int)}.
   *
   * The returned spliterator always reports the characteristics
   * `SIZED` and `SUBSIZED`.  The caller may provide additional
   * characteristics for the spliterator to report.  (For example, if it is
   * known the array will not be further modified, specify `IMMUTABLE`;
   * if the array data is considered to have an encounter order, specify
   * `ORDERED`).  The method {@link Arrays#spliterator(long[], int, int)} can
   * often be used instead, which returns a spliterator that reports
   * `SIZED`, `SUBSIZED`, `IMMUTABLE`, and `ORDERED`.
   *
   * @param array The array, assumed to be unmodified during use
   * @param fromIndex The least index (inclusive) to cover
   * @param toIndex One past the greatest index to cover
   * @param additionalCharacteristics Additional spliterator characteristics
   *        of this spliterator's source or elements beyond `SIZED` and
   *        `SUBSIZED` which are always reported
   * @return A spliterator for an array
   * @throws NullPointerException if the given array is `null`
   * @throws ArrayIndexOutOfBoundsException if `fromIndex` is negative,
   *         `toIndex` is less than `fromIndex`, or
   *         `toIndex` is greater than the array size
   * @see Arrays#spliterator(long[], int, int)
  */
  static spliterator(array: number[], fromIndex: number, toIndex: number, additionalCharacteristics: number): OfLong;
  /**
   * Creates a `Spliterator.OfDouble` covering the elements of a given array,
   * using a customized set of spliterator characteristics.
   *
   * This method is provided as an implementation convenience for
   * Spliterators which store portions of their elements in arrays, and need
   * fine control over Spliterator characteristics.  Most other situations in
   * which a Spliterator for an array is needed should use
   * {@link Arrays#spliterator(double[])}.
   *
   * The returned spliterator always reports the characteristics
   * `SIZED` and `SUBSIZED`.  The caller may provide additional
   * characteristics for the spliterator to report; it is common to
   * additionally specify `IMMUTABLE` and `ORDERED`.
   *
   * @param array The array, assumed to be unmodified during use
   * @param additionalCharacteristics Additional spliterator characteristics
   *        of this spliterator's source or elements beyond `SIZED` and
   *        `SUBSIZED` which are always reported
   * @return A spliterator for an array
   * @throws NullPointerException if the given array is `null`
   * @see Arrays#spliterator(double[])
  */
  static spliterator(array: number[], additionalCharacteristics: number): OfDouble;
  /**
   * Creates a `Spliterator.OfDouble` covering a range of elements of a
   * given array, using a customized set of spliterator characteristics.
   *
   * This method is provided as an implementation convenience for
   * Spliterators which store portions of their elements in arrays, and need
   * fine control over Spliterator characteristics.  Most other situations in
   * which a Spliterator for an array is needed should use
   * {@link Arrays#spliterator(double[], int, int)}.
   *
   * The returned spliterator always reports the characteristics
   * `SIZED` and `SUBSIZED`.  The caller may provide additional
   * characteristics for the spliterator to report.  (For example, if it is
   * known the array will not be further modified, specify `IMMUTABLE`;
   * if the array data is considered to have an encounter order, specify
   * `ORDERED`).  The method {@link Arrays#spliterator(long[], int, int)} can
   * often be used instead, which returns a spliterator that reports
   * `SIZED`, `SUBSIZED`, `IMMUTABLE`, and `ORDERED`.
   *
   * @param array The array, assumed to be unmodified during use
   * @param fromIndex The least index (inclusive) to cover
   * @param toIndex One past the greatest index to cover
   * @param additionalCharacteristics Additional spliterator characteristics
   *        of this spliterator's source or elements beyond `SIZED` and
   *        `SUBSIZED` which are always reported
   * @return A spliterator for an array
   * @throws NullPointerException if the given array is `null`
   * @throws ArrayIndexOutOfBoundsException if `fromIndex` is negative,
   *         `toIndex` is less than `fromIndex`, or
   *         `toIndex` is greater than the array size
   * @see Arrays#spliterator(double[], int, int)
  */
  static spliterator(array: number[], fromIndex: number, toIndex: number, additionalCharacteristics: number): OfDouble;
  /**
   * Creates a `Spliterator` using the given collection's
   * {@link java.util.Collection#iterator()} as the source of elements, and
   * reporting its {@link java.util.Collection#size()} as its initial size.
   *
   * The spliterator is
   * late-binding, inherits
   * the fail-fast properties of the collection's iterator, and
   * implements `trySplit` to permit limited parallelism.
   *
   * @param  Type of elements
   * @param c The collection
   * @param characteristics Characteristics of this spliterator's source or
   *        elements.  The characteristics `SIZED` and `SUBSIZED`
   *        are additionally reported unless `CONCURRENT` is supplied.
   * @return A spliterator from an iterator
   * @throws NullPointerException if the given collection is `null`
  */
  static spliterator<T>(c: Collection<T>, characteristics: number): Spliterator<T>;
  /**
   * Creates a `Spliterator` using a given `Iterator`
   * as the source of elements, and with a given initially reported size.
   *
   * The spliterator is not
   * late-binding, inherits
   * the fail-fast properties of the iterator, and implements
   * `trySplit` to permit limited parallelism.
   *
   * Traversal of elements should be accomplished through the spliterator.
   * The behaviour of splitting and traversal is undefined if the iterator is
   * operated on after the spliterator is returned, or the initially reported
   * size is not equal to the actual number of elements in the source.
   *
   * @param  Type of elements
   * @param iterator The iterator for the source
   * @param size The number of elements in the source, to be reported as
   *        initial `estimateSize`
   * @param characteristics Characteristics of this spliterator's source or
   *        elements.  The characteristics `SIZED` and `SUBSIZED`
   *        are additionally reported unless `CONCURRENT` is supplied.
   * @return A spliterator from an iterator
   * @throws NullPointerException if the given iterator is `null`
  */
  static spliterator<T>(iterator: Iterator<T>, size: number, characteristics: number): Spliterator<T>;
  /**
   * Creates a `Spliterator` using a given `Iterator`
   * as the source of elements, with no initial size estimate.
   *
   * The spliterator is not
   * late-binding, inherits
   * the fail-fast properties of the iterator, and implements
   * `trySplit` to permit limited parallelism.
   *
   * Traversal of elements should be accomplished through the spliterator.
   * The behaviour of splitting and traversal is undefined if the iterator is
   * operated on after the spliterator is returned.
   *
   * @param  Type of elements
   * @param iterator The iterator for the source
   * @param characteristics Characteristics of this spliterator's source
   *        or elements (`SIZED` and `SUBSIZED`, if supplied, are
   *        ignored and are not reported.)
   * @return A spliterator from an iterator
   * @throws NullPointerException if the given iterator is `null`
  */
  static spliteratorUnknownSize<T>(iterator: Iterator<T>, characteristics: number): Spliterator<T>;
  /**
   * Creates a `Spliterator.OfInt` using a given
   * `IntStream.IntIterator` as the source of elements, and with a given
   * initially reported size.
   *
   * The spliterator is not
   * late-binding, inherits
   * the fail-fast properties of the iterator, and implements
   * `trySplit` to permit limited parallelism.
   *
   * Traversal of elements should be accomplished through the spliterator.
   * The behaviour of splitting and traversal is undefined if the iterator is
   * operated on after the spliterator is returned, or the initially reported
   * size is not equal to the actual number of elements in the source.
   *
   * @param iterator The iterator for the source
   * @param size The number of elements in the source, to be reported as
   *        initial `estimateSize`.
   * @param characteristics Characteristics of this spliterator's source or
   *        elements.  The characteristics `SIZED` and `SUBSIZED`
   *        are additionally reported unless `CONCURRENT` is supplied.
   * @return A spliterator from an iterator
   * @throws NullPointerException if the given iterator is `null`
  */
  static spliterator(iterator: java_util_PrimitiveIterator_OfInt, size: number, characteristics: number): OfInt;
  /**
   * Creates a `Spliterator.OfInt` using a given
   * `IntStream.IntIterator` as the source of elements, with no initial
   * size estimate.
   *
   * The spliterator is not
   * late-binding, inherits
   * the fail-fast properties of the iterator, and implements
   * `trySplit` to permit limited parallelism.
   *
   * Traversal of elements should be accomplished through the spliterator.
   * The behaviour of splitting and traversal is undefined if the iterator is
   * operated on after the spliterator is returned.
   *
   * @param iterator The iterator for the source
   * @param characteristics Characteristics of this spliterator's source
   *        or elements (`SIZED` and `SUBSIZED`, if supplied, are
   *        ignored and are not reported.)
   * @return A spliterator from an iterator
   * @throws NullPointerException if the given iterator is `null`
  */
  static spliteratorUnknownSize(iterator: java_util_PrimitiveIterator_OfInt, characteristics: number): OfInt;
  /**
   * Creates a `Spliterator.OfLong` using a given
   * `LongStream.LongIterator` as the source of elements, and with a
   * given initially reported size.
   *
   * The spliterator is not
   * late-binding, inherits
   * the fail-fast properties of the iterator, and implements
   * `trySplit` to permit limited parallelism.
   *
   * Traversal of elements should be accomplished through the spliterator.
   * The behaviour of splitting and traversal is undefined if the iterator is
   * operated on after the spliterator is returned, or the initially reported
   * size is not equal to the actual number of elements in the source.
   *
   * @param iterator The iterator for the source
   * @param size The number of elements in the source, to be reported as
   *        initial `estimateSize`.
   * @param characteristics Characteristics of this spliterator's source or
   *        elements.  The characteristics `SIZED` and `SUBSIZED`
   *        are additionally reported unless `CONCURRENT` is supplied.
   * @return A spliterator from an iterator
   * @throws NullPointerException if the given iterator is `null`
  */
  static spliterator(iterator: java_util_PrimitiveIterator_OfLong, size: number, characteristics: number): OfLong;
  /**
   * Creates a `Spliterator.OfLong` using a given
   * `LongStream.LongIterator` as the source of elements, with no
   * initial size estimate.
   *
   * The spliterator is not
   * late-binding, inherits
   * the fail-fast properties of the iterator, and implements
   * `trySplit` to permit limited parallelism.
   *
   * Traversal of elements should be accomplished through the spliterator.
   * The behaviour of splitting and traversal is undefined if the iterator is
   * operated on after the spliterator is returned.
   *
   * @param iterator The iterator for the source
   * @param characteristics Characteristics of this spliterator's source
   *        or elements (`SIZED` and `SUBSIZED`, if supplied, are
   *        ignored and are not reported.)
   * @return A spliterator from an iterator
   * @throws NullPointerException if the given iterator is `null`
  */
  static spliteratorUnknownSize(iterator: java_util_PrimitiveIterator_OfLong, characteristics: number): OfLong;
  /**
   * Creates a `Spliterator.OfDouble` using a given
   * `DoubleStream.DoubleIterator` as the source of elements, and with a
   * given initially reported size.
   *
   * The spliterator is not
   * late-binding, inherits
   * the fail-fast properties of the iterator, and implements
   * `trySplit` to permit limited parallelism.
   *
   * Traversal of elements should be accomplished through the spliterator.
   * The behaviour of splitting and traversal is undefined if the iterator is
   * operated on after the spliterator is returned, or the initially reported
   * size is not equal to the actual number of elements in the source.
   *
   * @param iterator The iterator for the source
   * @param size The number of elements in the source, to be reported as
   *        initial `estimateSize`
   * @param characteristics Characteristics of this spliterator's source or
   *        elements.  The characteristics `SIZED` and `SUBSIZED`
   *        are additionally reported unless `CONCURRENT` is supplied.
   * @return A spliterator from an iterator
   * @throws NullPointerException if the given iterator is `null`
  */
  static spliterator(iterator: java_util_PrimitiveIterator_OfDouble, size: number, characteristics: number): OfDouble;
  /**
   * Creates a `Spliterator.OfDouble` using a given
   * `DoubleStream.DoubleIterator` as the source of elements, with no
   * initial size estimate.
   *
   * The spliterator is not
   * late-binding, inherits
   * the fail-fast properties of the iterator, and implements
   * `trySplit` to permit limited parallelism.
   *
   * Traversal of elements should be accomplished through the spliterator.
   * The behaviour of splitting and traversal is undefined if the iterator is
   * operated on after the spliterator is returned.
   *
   * @param iterator The iterator for the source
   * @param characteristics Characteristics of this spliterator's source
   *        or elements (`SIZED` and `SUBSIZED`, if supplied, are
   *        ignored and are not reported.)
   * @return A spliterator from an iterator
   * @throws NullPointerException if the given iterator is `null`
  */
  static spliteratorUnknownSize(iterator: java_util_PrimitiveIterator_OfDouble, characteristics: number): OfDouble;
  /**
   * Creates an `Iterator` from a `Spliterator`.
   *
   * Traversal of elements should be accomplished through the iterator.
   * The behaviour of traversal is undefined if the spliterator is operated
   * after the iterator is returned.
   *
   * @param  Type of elements
   * @param spliterator The spliterator
   * @return An iterator
   * @throws NullPointerException if the given spliterator is `null`
  */
  static iterator<T>(spliterator: Spliterator<T>): Iterator<T>;
  /**
   * Creates an `PrimitiveIterator.OfInt` from a
   * `Spliterator.OfInt`.
   *
   * Traversal of elements should be accomplished through the iterator.
   * The behaviour of traversal is undefined if the spliterator is operated
   * after the iterator is returned.
   *
   * @param spliterator The spliterator
   * @return An iterator
   * @throws NullPointerException if the given spliterator is `null`
  */
  static iterator(spliterator: OfInt): java_util_PrimitiveIterator_OfInt;
  /**
   * Creates an `PrimitiveIterator.OfLong` from a
   * `Spliterator.OfLong`.
   *
   * Traversal of elements should be accomplished through the iterator.
   * The behaviour of traversal is undefined if the spliterator is operated
   * after the iterator is returned.
   *
   * @param spliterator The spliterator
   * @return An iterator
   * @throws NullPointerException if the given spliterator is `null`
  */
  static iterator(spliterator: OfLong): java_util_PrimitiveIterator_OfLong;
  /**
   * Creates an `PrimitiveIterator.OfDouble` from a
   * `Spliterator.OfDouble`.
   *
   * Traversal of elements should be accomplished through the iterator.
   * The behaviour of traversal is undefined if the spliterator is operated
   * after the iterator is returned.
   *
   * @param spliterator The spliterator
   * @return An iterator
   * @throws NullPointerException if the given spliterator is `null`
  */
  static iterator(spliterator: OfDouble): java_util_PrimitiveIterator_OfDouble;
}
/**
 * The class `Date` represents a specific instant
 * in time, with millisecond precision.
 * 
 * Prior to JDK 1.1, the class `Date` had two additional
 * functions.  It allowed the interpretation of dates as year, month, day, hour,
 * minute, and second values.  It also allowed the formatting and parsing
 * of date strings.  Unfortunately, the API for these functions was not
 * amenable to internationalization.  As of JDK 1.1, the
 * `Calendar` class should be used to convert between dates and time
 * fields and the `DateFormat` class should be used to format and
 * parse date strings.
 * The corresponding methods in `Date` are deprecated.
 * 
 * Although the `Date` class is intended to reflect
 * coordinated universal time (UTC), it may not do so exactly,
 * depending on the host environment of the Java Virtual Machine.
 * Nearly all modern operating systems assume that 1 day =
 * 24 × 60 × 60 = 86400 seconds
 * in all cases. In UTC, however, about once every year or two there
 * is an extra second, called a "leap second." The leap
 * second is always added as the last second of the day, and always
 * on December 31 or June 30. For example, the last minute of the
 * year 1995 was 61 seconds long, thanks to an added leap second.
 * Most computer clocks are not accurate enough to be able to reflect
 * the leap-second distinction.
 * 
 * Some computer standards are defined in terms of Greenwich mean
 * time (GMT), which is equivalent to universal time (UT).  GMT is
 * the "civil" name for the standard; UT is the
 * "scientific" name for the same standard. The
 * distinction between UTC and UT is that UTC is based on an atomic
 * clock and UT is based on astronomical observations, which for all
 * practical purposes is an invisibly fine hair to split. Because the
 * earth's rotation is not uniform (it slows down and speeds up
 * in complicated ways), UT does not always flow uniformly. Leap
 * seconds are introduced as needed into UTC so as to keep UTC within
 * 0.9 seconds of UT1, which is a version of UT with certain
 * corrections applied. There are other time and date systems as
 * well; for example, the time scale used by the satellite-based
 * global positioning system (GPS) is synchronized to UTC but is
 * not adjusted for leap seconds. An interesting source of
 * further information is the United States Naval Observatory (USNO):
 *  *     https://www.usno.navy.mil/USNO
 * 
 * 
 * and the material regarding "Systems of Time" at:
 *  *     https://www.usno.navy.mil/USNO/time/master-clock/systems-of-time
 * 
 * 
 * which has descriptions of various different time systems including
 * UT, UT1, and UTC.
 * 
 * In all methods of class `Date` that accept or return
 * year, month, date, hours, minutes, and seconds values, the
 * following representations are used:
 * 
 * A year y is represented by the integer
 *     y `- 1900`.
 * A month is represented by an integer from 0 to 11; 0 is January,
 *     1 is February, and so forth; thus 11 is December.
 * A date (day of month) is represented by an integer from 1 to 31
 *     in the usual manner.
 * An hour is represented by an integer from 0 to 23. Thus, the hour
 *     from midnight to 1 a.m. is hour 0, and the hour from noon to 1
 *     p.m. is hour 12.
 * A minute is represented by an integer from 0 to 59 in the usual manner.
 * A second is represented by an integer from 0 to 61; the values 60 and
 *     61 occur only for leap seconds and even then only in Java
 *     implementations that actually track leap seconds correctly. Because
 *     of the manner in which leap seconds are currently introduced, it is
 *     extremely unlikely that two leap seconds will occur in the same
 *     minute, but this specification follows the date and time conventions
 *     for ISO C.
 * 
 * 
 * In all cases, arguments given to methods for these purposes need
 * not fall within the indicated ranges; for example, a date may be
 * specified as January 32 and is interpreted as meaning February 1.
 *
 * @author  James Gosling
 * @author  Arthur van Hoff
 * @author  Alan Liu
 * @see     java.text.DateFormat
 * @see     java.util.Calendar
 * @see     java.util.TimeZone
 * @since   1.0
*/
export class Date extends Serializable {
  /**
   * Allocates a `Date` object and initializes it so that
   * it represents the time at which it was allocated, measured to the
   * nearest millisecond.
   *
   * @see     java.lang.System#currentTimeMillis()
  */
  constructor();
  /**
   * Allocates a `Date` object and initializes it to
   * represent the specified number of milliseconds since the
   * standard base time known as "the epoch", namely January 1,
   * 1970, 00:00:00 GMT.
   *
   * @param   date   the milliseconds since January 1, 1970, 00:00:00 GMT.
   * @see     java.lang.System#currentTimeMillis()
  */
  constructor(date: number);
  /**
   * Allocates a `Date` object and initializes it so that
   * it represents midnight, local time, at the beginning of the day
   * specified by the `year`, `month`, and
   * `date` arguments.
   *
   * @param   year    the year minus 1900.
   * @param   month   the month between 0-11.
   * @param   date    the day of the month between 1-31.
   * @see     java.util.Calendar
   * @deprecated As of JDK version 1.1,
   * replaced by `Calendar.set(year + 1900, month, date)`
   * or `GregorianCalendar(year + 1900, month, date)`.
  */
  constructor(year: number, month: number, date: number);
  /**
   * Allocates a `Date` object and initializes it so that
   * it represents the instant at the start of the minute specified by
   * the `year`, `month`, `date`,
   * `hrs`, and `min` arguments, in the local
   * time zone.
   *
   * @param   year    the year minus 1900.
   * @param   month   the month between 0-11.
   * @param   date    the day of the month between 1-31.
   * @param   hrs     the hours between 0-23.
   * @param   min     the minutes between 0-59.
   * @see     java.util.Calendar
   * @deprecated As of JDK version 1.1,
   * replaced by `Calendar.set(year + 1900, month, date, hrs, min)`
   * or `GregorianCalendar(year + 1900, month, date, hrs, min)`.
  */
  constructor(year: number, month: number, date: number, hrs: number, min: number);
  /**
   * Allocates a `Date` object and initializes it so that
   * it represents the instant at the start of the second specified
   * by the `year`, `month`, `date`,
   * `hrs`, `min`, and `sec` arguments,
   * in the local time zone.
   *
   * @param   year    the year minus 1900.
   * @param   month   the month between 0-11.
   * @param   date    the day of the month between 1-31.
   * @param   hrs     the hours between 0-23.
   * @param   min     the minutes between 0-59.
   * @param   sec     the seconds between 0-59.
   * @see     java.util.Calendar
   * @deprecated As of JDK version 1.1,
   * replaced by `Calendar.set(year + 1900, month, date, hrs, min, sec)`
   * or `GregorianCalendar(year + 1900, month, date, hrs, min, sec)`.
  */
  constructor(year: number, month: number, date: number, hrs: number, min: number, sec: number);
  /**
   * Allocates a `Date` object and initializes it so that
   * it represents the date and time indicated by the string
   * `s`, which is interpreted as if by the
   * {@link Date#parse} method.
   *
   * @param   s   a string representation of the date.
   * @see     java.text.DateFormat
   * @see     java.util.Date#parse(java.lang.String)
   * @deprecated As of JDK version 1.1,
   * replaced by `DateFormat.parse(String s)`.
  */
  constructor(s: string);
  /**
   * Return a copy of this object.
  */
  clone(): any;
  /**
   * Determines the date and time based on the arguments. The
   * arguments are interpreted as a year, month, day of the month,
   * hour of the day, minute within the hour, and second within the
   * minute, exactly as for the `Date` constructor with six
   * arguments, except that the arguments are interpreted relative
   * to UTC rather than to the local time zone. The time indicated is
   * returned represented as the distance, measured in milliseconds,
   * of that time from the epoch (00:00:00 GMT on January 1, 1970).
   *
   * @param   year    the year minus 1900.
   * @param   month   the month between 0-11.
   * @param   date    the day of the month between 1-31.
   * @param   hrs     the hours between 0-23.
   * @param   min     the minutes between 0-59.
   * @param   sec     the seconds between 0-59.
   * @return  the number of milliseconds since January 1, 1970, 00:00:00 GMT for
   *          the date and time specified by the arguments.
   * @see     java.util.Calendar
   * @deprecated As of JDK version 1.1,
   * replaced by `Calendar.set(year + 1900, month, date, hrs, min, sec)`
   * or `GregorianCalendar(year + 1900, month, date, hrs, min, sec)`, using a UTC
   * `TimeZone`, followed by `Calendar.getTime().getTime()`.
  */
  static UTC(year: number, month: number, date: number, hrs: number, min: number, sec: number): number;
  /**
   * Attempts to interpret the string `s` as a representation
   * of a date and time. If the attempt is successful, the time
   * indicated is returned represented as the distance, measured in
   * milliseconds, of that time from the epoch (00:00:00 GMT on
   * January 1, 1970). If the attempt fails, an
   * `IllegalArgumentException` is thrown.
   * 
   * It accepts many syntaxes; in particular, it recognizes the IETF
   * standard date syntax: "Sat, 12 Aug 1995 13:30:00 GMT". It also
   * understands the continental U.S. time-zone abbreviations, but for
   * general use, a time-zone offset should be used: "Sat, 12 Aug 1995
   * 13:30:00 GMT+0430" (4 hours, 30 minutes west of the Greenwich
   * meridian). If no time zone is specified, the local time zone is
   * assumed. GMT and UTC are considered equivalent.
   * 
   * The string `s` is processed from left to right, looking for
   * data of interest. Any material in `s` that is within the
   * ASCII parenthesis characters `(` and `)` is ignored.
   * Parentheses may be nested. Otherwise, the only characters permitted
   * within `s` are these ASCII characters:
   *      * abcdefghijklmnopqrstuvwxyz
   * ABCDEFGHIJKLMNOPQRSTUVWXYZ
   * 0123456789,+-:/
   * and whitespace characters.
   * A consecutive sequence of decimal digits is treated as a decimal
   * number:
   * If a number is preceded by `+` or `-` and a year
   *     has already been recognized, then the number is a time-zone
   *     offset. If the number is less than 24, it is an offset measured
   *     in hours. Otherwise, it is regarded as an offset in minutes,
   *     expressed in 24-hour time format without punctuation. A
   *     preceding `-` means a westward offset. Time zone offsets
   *     are always relative to UTC (Greenwich). Thus, for example,
   *     `-5` occurring in the string would mean "five hours west
   *     of Greenwich" and `+0430` would mean "four hours and
   *     thirty minutes east of Greenwich." It is permitted for the
   *     string to specify `GMT`, `UT`, or `UTC`
   *     redundantly-for example, `GMT-5` or `utc+0430`.
   * The number is regarded as a year number if one of the
   *     following conditions is true:
   * 
   *     The number is equal to or greater than 70 and followed by a
   *         space, comma, slash, or end of string
   *     The number is less than 70, and both a month and a day of
   *         the month have already been recognized
   * 
   *     If the recognized year number is less than 100, it is
   *     interpreted as an abbreviated year relative to a century of
   *     which dates are within 80 years before and 19 years after
   *     the time when the Date class is initialized.
   *     After adjusting the year number, 1900 is subtracted from
   *     it. For example, if the current year is 1999 then years in
   *     the range 19 to 99 are assumed to mean 1919 to 1999, while
   *     years from 0 to 18 are assumed to mean 2000 to 2018.  Note
   *     that this is slightly different from the interpretation of
   *     years less than 100 that is used in {@link java.text.SimpleDateFormat}.
   * If the number is followed by a colon, it is regarded as an hour,
   *     unless an hour has already been recognized, in which case it is
   *     regarded as a minute.
   * If the number is followed by a slash, it is regarded as a month
   *     (it is decreased by 1 to produce a number in the range `0`
   *     to `11`), unless a month has already been recognized, in
   *     which case it is regarded as a day of the month.
   * If the number is followed by whitespace, a comma, a hyphen, or
   *     end of string, then if an hour has been recognized but not a
   *     minute, it is regarded as a minute; otherwise, if a minute has
   *     been recognized but not a second, it is regarded as a second;
   *     otherwise, it is regarded as a day of the month. 
   * A consecutive sequence of letters is regarded as a word and treated
   * as follows:
   * A word that matches `AM`, ignoring case, is ignored (but
   *     the parse fails if an hour has not been recognized or is less
   *     than `1` or greater than `12`).
   * A word that matches `PM`, ignoring case, adds `12`
   *     to the hour (but the parse fails if an hour has not been
   *     recognized or is less than `1` or greater than `12`).
   * Any word that matches any prefix of {@code SUNDAY, MONDAY, TUESDAY,
   *     WEDNESDAY, THURSDAY, FRIDAY}, or `SATURDAY`, ignoring
   *     case, is ignored. For example, `sat, Friday, TUE`, and
   *     `Thurs` are ignored.
   * Otherwise, any word that matches any prefix of {@code JANUARY,
   *     FEBRUARY, MARCH, APRIL, MAY, JUNE, JULY, AUGUST, SEPTEMBER,
   *     OCTOBER, NOVEMBER}, or `DECEMBER`, ignoring case, and
   *     considering them in the order given here, is recognized as
   *     specifying a month and is converted to a number (`0` to
   *     `11`). For example, `aug, Sept, april`, and
   *     `NOV` are recognized as months. So is `Ma`, which
   *     is recognized as `MARCH`, not `MAY`.
   * Any word that matches `GMT, UT`, or `UTC`, ignoring
   *     case, is treated as referring to UTC.
   * Any word that matches `EST, CST, MST`, or `PST`,
   *     ignoring case, is recognized as referring to the time zone in
   *     North America that is five, six, seven, or eight hours west of
   *     Greenwich, respectively. Any word that matches {@code EDT, CDT,
   *     MDT}, or `PDT`, ignoring case, is recognized as
   *     referring to the same time zone, respectively, during daylight
   *     saving time.
   * Once the entire string s has been scanned, it is converted to a time
   * result in one of two ways. If a time zone or time-zone offset has been
   * recognized, then the year, month, day of month, hour, minute, and
   * second are interpreted in UTC and then the time-zone offset is
   * applied. Otherwise, the year, month, day of month, hour, minute, and
   * second are interpreted in the local time zone.
   *
   * @param   s   a string to be parsed as a date.
   * @return  the number of milliseconds since January 1, 1970, 00:00:00 GMT
   *          represented by the string argument.
   * @see     java.text.DateFormat
   * @deprecated As of JDK version 1.1,
   * replaced by `DateFormat.parse(String s)`.
  */
  static parse(s: string): number;
  /**
   * Returns a value that is the result of subtracting 1900 from the
   * year that contains or begins with the instant in time represented
   * by this `Date` object, as interpreted in the local
   * time zone.
   *
   * @return  the year represented by this date, minus 1900.
   * @see     java.util.Calendar
   * @deprecated As of JDK version 1.1,
   * replaced by `Calendar.get(Calendar.YEAR) - 1900`.
  */
  getYear(): number;
  /**
   * Sets the year of this `Date` object to be the specified
   * value plus 1900. This `Date` object is modified so
   * that it represents a point in time within the specified year,
   * with the month, date, hour, minute, and second the same as
   * before, as interpreted in the local time zone. (Of course, if
   * the date was February 29, for example, and the year is set to a
   * non-leap year, then the new date will be treated as if it were
   * on March 1.)
   *
   * @param   year    the year value.
   * @see     java.util.Calendar
   * @deprecated As of JDK version 1.1,
   * replaced by `Calendar.set(Calendar.YEAR, year + 1900)`.
  */
  setYear(year: number);
  /**
   * Returns a number representing the month that contains or begins
   * with the instant in time represented by this `Date` object.
   * The value returned is between `0` and `11`,
   * with the value `0` representing January.
   *
   * @return  the month represented by this date.
   * @see     java.util.Calendar
   * @deprecated As of JDK version 1.1,
   * replaced by `Calendar.get(Calendar.MONTH)`.
  */
  getMonth(): number;
  /**
   * Sets the month of this date to the specified value. This
   * `Date` object is modified so that it represents a point
   * in time within the specified month, with the year, date, hour,
   * minute, and second the same as before, as interpreted in the
   * local time zone. If the date was October 31, for example, and
   * the month is set to June, then the new date will be treated as
   * if it were on July 1, because June has only 30 days.
   *
   * @param   month   the month value between 0-11.
   * @see     java.util.Calendar
   * @deprecated As of JDK version 1.1,
   * replaced by `Calendar.set(Calendar.MONTH, int month)`.
  */
  setMonth(month: number);
  /**
   * Returns the day of the month represented by this `Date` object.
   * The value returned is between `1` and `31`
   * representing the day of the month that contains or begins with the
   * instant in time represented by this `Date` object, as
   * interpreted in the local time zone.
   *
   * @return  the day of the month represented by this date.
   * @see     java.util.Calendar
   * @deprecated As of JDK version 1.1,
   * replaced by `Calendar.get(Calendar.DAY_OF_MONTH)`.
  */
  getDate(): number;
  /**
   * Sets the day of the month of this `Date` object to the
   * specified value. This `Date` object is modified so that
   * it represents a point in time within the specified day of the
   * month, with the year, month, hour, minute, and second the same
   * as before, as interpreted in the local time zone. If the date
   * was April 30, for example, and the date is set to 31, then it
   * will be treated as if it were on May 1, because April has only
   * 30 days.
   *
   * @param   date   the day of the month value between 1-31.
   * @see     java.util.Calendar
   * @deprecated As of JDK version 1.1,
   * replaced by `Calendar.set(Calendar.DAY_OF_MONTH, int date)`.
  */
  setDate(date: number);
  /**
   * Returns the day of the week represented by this date. The
   * returned value (`0` = Sunday, `1` = Monday,
   * `2` = Tuesday, `3` = Wednesday, `4` =
   * Thursday, `5` = Friday, `6` = Saturday)
   * represents the day of the week that contains or begins with
   * the instant in time represented by this `Date` object,
   * as interpreted in the local time zone.
   *
   * @return  the day of the week represented by this date.
   * @see     java.util.Calendar
   * @deprecated As of JDK version 1.1,
   * replaced by `Calendar.get(Calendar.DAY_OF_WEEK)`.
  */
  getDay(): number;
  /**
   * Returns the hour represented by this `Date` object. The
   * returned value is a number (`0` through `23`)
   * representing the hour within the day that contains or begins
   * with the instant in time represented by this `Date`
   * object, as interpreted in the local time zone.
   *
   * @return  the hour represented by this date.
   * @see     java.util.Calendar
   * @deprecated As of JDK version 1.1,
   * replaced by `Calendar.get(Calendar.HOUR_OF_DAY)`.
  */
  getHours(): number;
  /**
   * Sets the hour of this `Date` object to the specified value.
   * This `Date` object is modified so that it represents a point
   * in time within the specified hour of the day, with the year, month,
   * date, minute, and second the same as before, as interpreted in the
   * local time zone.
   *
   * @param   hours   the hour value.
   * @see     java.util.Calendar
   * @deprecated As of JDK version 1.1,
   * replaced by `Calendar.set(Calendar.HOUR_OF_DAY, int hours)`.
  */
  setHours(hours: number);
  /**
   * Returns the number of minutes past the hour represented by this date,
   * as interpreted in the local time zone.
   * The value returned is between `0` and `59`.
   *
   * @return  the number of minutes past the hour represented by this date.
   * @see     java.util.Calendar
   * @deprecated As of JDK version 1.1,
   * replaced by `Calendar.get(Calendar.MINUTE)`.
  */
  getMinutes(): number;
  /**
   * Sets the minutes of this `Date` object to the specified value.
   * This `Date` object is modified so that it represents a point
   * in time within the specified minute of the hour, with the year, month,
   * date, hour, and second the same as before, as interpreted in the
   * local time zone.
   *
   * @param   minutes   the value of the minutes.
   * @see     java.util.Calendar
   * @deprecated As of JDK version 1.1,
   * replaced by `Calendar.set(Calendar.MINUTE, int minutes)`.
  */
  setMinutes(minutes: number);
  /**
   * Returns the number of seconds past the minute represented by this date.
   * The value returned is between `0` and `61`. The
   * values `60` and `61` can only occur on those
   * Java Virtual Machines that take leap seconds into account.
   *
   * @return  the number of seconds past the minute represented by this date.
   * @see     java.util.Calendar
   * @deprecated As of JDK version 1.1,
   * replaced by `Calendar.get(Calendar.SECOND)`.
  */
  getSeconds(): number;
  /**
   * Sets the seconds of this `Date` to the specified value.
   * This `Date` object is modified so that it represents a
   * point in time within the specified second of the minute, with
   * the year, month, date, hour, and minute the same as before, as
   * interpreted in the local time zone.
   *
   * @param   seconds   the seconds value.
   * @see     java.util.Calendar
   * @deprecated As of JDK version 1.1,
   * replaced by `Calendar.set(Calendar.SECOND, int seconds)`.
  */
  setSeconds(seconds: number);
  /**
   * Returns the number of milliseconds since January 1, 1970, 00:00:00 GMT
   * represented by this `Date` object.
   *
   * @return  the number of milliseconds since January 1, 1970, 00:00:00 GMT
   *          represented by this date.
  */
  getTime(): number;
  /**
   * Sets this `Date` object to represent a point in time that is
   * `time` milliseconds after January 1, 1970 00:00:00 GMT.
   *
   * @param   time   the number of milliseconds.
  */
  setTime(time: number);
  /**
   * Tests if this date is before the specified date.
   *
   * @param   when   a date.
   * @return  `true` if and only if the instant of time
   *            represented by this `Date` object is strictly
   *            earlier than the instant represented by `when`;
   *          `false` otherwise.
   * @throws    NullPointerException if `when` is null.
  */
  before(when: Date): boolean;
  /**
   * Tests if this date is after the specified date.
   *
   * @param   when   a date.
   * @return  `true` if and only if the instant represented
   *          by this `Date` object is strictly later than the
   *          instant represented by `when`;
   *          `false` otherwise.
   * @throws    NullPointerException if `when` is null.
  */
  after(when: Date): boolean;
  /**
   * Compares two dates for equality.
   * The result is `true` if and only if the argument is
   * not `null` and is a `Date` object that
   * represents the same point in time, to the millisecond, as this object.
   * 
   * Thus, two `Date` objects are equal if and only if the
   * `getTime` method returns the same `long`
   * value for both.
   *
   * @param   obj   the object to compare with.
   * @return  `true` if the objects are the same;
   *          `false` otherwise.
   * @see     java.util.Date#getTime()
  */
  equals(obj: any): boolean;
  /**
   * Compares two Dates for ordering.
   *
   * @param   anotherDate   the `Date` to be compared.
   * @return  the value `0` if the argument Date is equal to
   *          this Date; a value less than `0` if this Date
   *          is before the Date argument; and a value greater than
   *      `0` if this Date is after the Date argument.
   * @since   1.2
   * @throws    NullPointerException if `anotherDate` is null.
  */
  compareTo(anotherDate: Date): number;
  /**
   * Returns a hash code value for this object. The result is the
   * exclusive OR of the two halves of the primitive `long`
   * value returned by the {@link Date#getTime}
   * method. That is, the hash code is the value of the expression:
   * {@code
   * (int)(this.getTime()^(this.getTime() >>> 32))
   * }
   *
   * @return  a hash code value for this object.
  */
  hashCode(): number;
  /**
   * Converts this `Date` object to a `String`
   * of the form:
   *      * dow mon dd hh:mm:ss zzz yyyy
   * where:
   * `dow` is the day of the week ({@code Sun, Mon, Tue, Wed,
   *     Thu, Fri, Sat}).
   * `mon` is the month ({@code Jan, Feb, Mar, Apr, May, Jun,
   *     Jul, Aug, Sep, Oct, Nov, Dec}).
   * `dd` is the day of the month (`01` through
   *     `31`), as two decimal digits.
   * `hh` is the hour of the day (`00` through
   *     `23`), as two decimal digits.
   * `mm` is the minute within the hour (`00` through
   *     `59`), as two decimal digits.
   * `ss` is the second within the minute (`00` through
   *     `61`, as two decimal digits.
   * `zzz` is the time zone (and may reflect daylight saving
   *     time). Standard time zone abbreviations include those
   *     recognized by the method `parse`. If time zone
   *     information is not available, then `zzz` is empty -
   *     that is, it consists of no characters at all.
   * `yyyy` is the year, as four decimal digits.
   * 
   *
   * @return  a string representation of this date.
   * @see     java.util.Date#toLocaleString()
   * @see     java.util.Date#toGMTString()
  */
  toString(): string;
  /**
   * Creates a string representation of this `Date` object in an
   * implementation-dependent form. The intent is that the form should
   * be familiar to the user of the Java application, wherever it may
   * happen to be running. The intent is comparable to that of the
   * "`%c`" format supported by the `strftime()`
   * function of ISO C.
   *
   * @return  a string representation of this date, using the locale
   *          conventions.
   * @see     java.text.DateFormat
   * @see     java.util.Date#toString()
   * @see     java.util.Date#toGMTString()
   * @deprecated As of JDK version 1.1,
   * replaced by `DateFormat.format(Date date)`.
  */
  toLocaleString(): string;
  /**
   * Creates a string representation of this `Date` object of
   * the form:
   *      * d mon yyyy hh:mm:ss GMT
   * where:
   * d is the day of the month (`1` through `31`),
   *     as one or two decimal digits.
   * mon is the month ({@code Jan, Feb, Mar, Apr, May, Jun, Jul,
   *     Aug, Sep, Oct, Nov, Dec}).
   * yyyy is the year, as four decimal digits.
   * hh is the hour of the day (`00` through `23`),
   *     as two decimal digits.
   * mm is the minute within the hour (`00` through
   *     `59`), as two decimal digits.
   * ss is the second within the minute (`00` through
   *     `61`), as two decimal digits.
   * GMT is exactly the ASCII letters "`GMT`" to indicate
   *     Greenwich Mean Time.
   * 
   * The result does not depend on the local time zone.
   *
   * @return  a string representation of this date, using the Internet GMT
   *          conventions.
   * @see     java.text.DateFormat
   * @see     java.util.Date#toString()
   * @see     java.util.Date#toLocaleString()
   * @deprecated As of JDK version 1.1,
   * replaced by `DateFormat.format(Date date)`, using a
   * GMT `TimeZone`.
  */
  toGMTString(): string;
  /**
   * Returns the offset, measured in minutes, for the local time zone
   * relative to UTC that is appropriate for the time represented by
   * this `Date` object.
   * 
   * For example, in Massachusetts, five time zones west of Greenwich:
   *      * new Date(96, 1, 14).getTimezoneOffset() returns 300
   * because on February 14, 1996, standard time (Eastern Standard Time)
   * is in use, which is offset five hours from UTC; but:
   *      * new Date(96, 5, 1).getTimezoneOffset() returns 240
   * because on June 1, 1996, daylight saving time (Eastern Daylight Time)
   * is in use, which is offset only four hours from UTC.
   * This method produces the same result as if it computed:
   *      * (this.getTime() - UTC(this.getYear(),
   *                       this.getMonth(),
   *                       this.getDate(),
   *                       this.getHours(),
   *                       this.getMinutes(),
   *                       this.getSeconds())) / (60 * 1000)
   * 
   *
   * @return  the time-zone offset, in minutes, for the current time zone.
   * @see     java.util.Calendar#ZONE_OFFSET
   * @see     java.util.Calendar#DST_OFFSET
   * @see     java.util.TimeZone#getDefault
   * @deprecated As of JDK version 1.1,
   * replaced by {@code -(Calendar.get(Calendar.ZONE_OFFSET) +
   * Calendar.get(Calendar.DST_OFFSET)) / (60 * 1000)}.
  */
  getTimezoneOffset(): number;
  /**
   * Obtains an instance of `Date` from an `Instant` object.
   * 
   * `Instant` uses a precision of nanoseconds, whereas `Date`
   * uses a precision of milliseconds.  The conversion will truncate any
   * excess precision information as though the amount in nanoseconds was
   * subject to integer division by one million.
   * 
   * `Instant` can store points on the time-line further in the future
   * and further in the past than `Date`. In this scenario, this method
   * will throw an exception.
   *
   * @param instant  the instant to convert
   * @return a `Date` representing the same point on the time-line as
   *  the provided instant
   * @throws    NullPointerException if `instant` is null.
   * @throws    IllegalArgumentException if the instant is too large to
   *  represent as a `Date`
   * @since 1.8
  */
  static from(instant: Instant): Date;
  /**
   * Converts this `Date` object to an `Instant`.
   * 
   * The conversion creates an `Instant` that represents the same
   * point on the time-line as this `Date`.
   *
   * @return an instant representing the same point on the time-line as
   *  this `Date` object
   * @since 1.8
  */
  toInstant(): Instant;
  /**
   * Compares this object with the specified object for order.  Returns a
   * negative integer, zero, or a positive integer as this object is less
   * than, equal to, or greater than the specified object.
   *
   * The implementor must ensure
   * `sgn(x.compareTo(y)) == -sgn(y.compareTo(x))`
   * for all `x` and `y`.  (This
   * implies that `x.compareTo(y)` must throw an exception iff
   * `y.compareTo(x)` throws an exception.)
   *
   * The implementor must also ensure that the relation is transitive:
   * `(x.compareTo(y) > 0 && y.compareTo(z) > 0)` implies
   * `x.compareTo(z) > 0`.
   *
   * Finally, the implementor must ensure that `x.compareTo(y)==0`
   * implies that `sgn(x.compareTo(z)) == sgn(y.compareTo(z))`, for
   * all `z`.
   *
   * It is strongly recommended, but not strictly required that
   * `(x.compareTo(y)==0) == (x.equals(y))`.  Generally speaking, any
   * class that implements the `Comparable` interface and violates
   * this condition should clearly indicate this fact.  The recommended
   * language is "Note: this class has a natural ordering that is
   * inconsistent with equals."
   *
   * In the foregoing description, the notation
   * `sgn(`expression`)` designates the mathematical
   * signum function, which is defined to return one of `-1`,
   * `0`, or `1` according to whether the value of
   * expression is negative, zero, or positive, respectively.
   *
   * @param   o the object to be compared.
   * @return  a negative integer, zero, or a positive integer as this object
   *          is less than, equal to, or greater than the specified object.
   *
   * @throws NullPointerException if the specified object is null
   * @throws ClassCastException if the specified object's type prevents it
   *         from being compared to this object.
  */
  compareTo(o: T): number;
}
export interface Date extends Serializable, Cloneable, Comparable<Date> {}
/**
 * An instance of this class is used to generate a stream of
 * pseudorandom numbers. The class uses a 48-bit seed, which is
 * modified using a linear congruential formula. (See Donald Knuth,
 * The Art of Computer Programming, Volume 2, Section 3.2.1.)
 * 
 * If two instances of `Random` are created with the same
 * seed, and the same sequence of method calls is made for each, they
 * will generate and return identical sequences of numbers. In order to
 * guarantee this property, particular algorithms are specified for the
 * class `Random`. Java implementations must use all the algorithms
 * shown here for the class `Random`, for the sake of absolute
 * portability of Java code. However, subclasses of class `Random`
 * are permitted to use other algorithms, so long as they adhere to the
 * general contracts for all the methods.
 * 
 * The algorithms implemented by class `Random` use a
 * `protected` utility method that on each invocation can supply
 * up to 32 pseudorandomly generated bits.
 * 
 * Many applications will find the method {@link Math#random} simpler to use.
 *
 * Instances of `java.util.Random` are threadsafe.
 * However, the concurrent use of the same `java.util.Random`
 * instance across threads may encounter contention and consequent
 * poor performance. Consider instead using
 * {@link java.util.concurrent.ThreadLocalRandom} in multithreaded
 * designs.
 *
 * Instances of `java.util.Random` are not cryptographically
 * secure.  Consider instead using {@link java.security.SecureRandom} to
 * get a cryptographically secure pseudo-random number generator for use
 * by security-sensitive applications.
 *
 * @author  Frank Yellin
 * @since   1.0
*/
export class Random extends Serializable {
  /**
   * Creates a new random number generator. This constructor sets
   * the seed of the random number generator to a value very likely
   * to be distinct from any other invocation of this constructor.
  */
  constructor();
  /**
   * Creates a new random number generator using a single `long` seed.
   * The seed is the initial value of the internal state of the pseudorandom
   * number generator which is maintained by method {@link #next}.
   *
   * The invocation `new Random(seed)` is equivalent to:
   *   {@code
   * Random rnd = new Random();
   * rnd.setSeed(seed);}
   *
   * @param seed the initial seed
   * @see   #setSeed(long)
  */
  constructor(seed: number);
  /**
   * Sets the seed of this random number generator using a single
   * `long` seed. The general contract of `setSeed` is
   * that it alters the state of this random number generator object
   * so as to be in exactly the same state as if it had just been
   * created with the argument `seed` as a seed. The method
   * `setSeed` is implemented by class `Random` by
   * atomically updating the seed to
   *  `(seed ^ 0x5DEECE66DL) & ((1L << 48) - 1)`
   * and clearing the `haveNextNextGaussian` flag used by {@link
   * #nextGaussian}.
   *
   * The implementation of `setSeed` by class `Random`
   * happens to use only 48 bits of the given seed. In general, however,
   * an overriding method may use all 64 bits of the `long`
   * argument as a seed value.
   *
   * @param seed the initial seed
  */
  setSeed(seed: number);
  /**
   * Generates random bytes and places them into a user-supplied
   * byte array.  The number of random bytes produced is equal to
   * the length of the byte array.
   *
   * The method `nextBytes` is implemented by class `Random`
   * as if by:
   *   {@code
   * public void nextBytes(byte[] bytes) {
   *   for (int i = 0; i < bytes.length; )
   *     for (int rnd = nextInt(), n = Math.min(bytes.length - i, 4);
   *          n-- > 0; rnd >>= 8)
   *       bytes[i++] = (byte)rnd;
   * }}
   *
   * @param  bytes the byte array to fill with random bytes
   * @throws NullPointerException if the byte array is null
   * @since  1.1
  */
  nextBytes(bytes: number[]): void;
  /**
   * Returns the next pseudorandom, uniformly distributed `int`
   * value from this random number generator's sequence. The general
   * contract of `nextInt` is that one `int` value is
   * pseudorandomly generated and returned. All 232 possible
   * `int` values are produced with (approximately) equal probability.
   *
   * The method `nextInt` is implemented by class `Random`
   * as if by:
   *   {@code
   * public int nextInt() {
   *   return next(32);
   * }}
   *
   * @return the next pseudorandom, uniformly distributed `int`
   *         value from this random number generator's sequence
  */
  nextInt(): number;
  /**
   * Returns a pseudorandom, uniformly distributed `int` value
   * between 0 (inclusive) and the specified value (exclusive), drawn from
   * this random number generator's sequence.  The general contract of
   * `nextInt` is that one `int` value in the specified range
   * is pseudorandomly generated and returned.  All `bound` possible
   * `int` values are produced with (approximately) equal
   * probability.  The method `nextInt(int bound)` is implemented by
   * class `Random` as if by:
   *   {@code
   * public int nextInt(int bound) {
   *   if (bound <= 0)
   *     throw new IllegalArgumentException("bound must be positive");
   *
   *   if ((bound & -bound) == bound)  // i.e., bound is a power of 2
   *     return (int)((bound * (long)next(31)) >> 31);
   *
   *   int bits, val;
   *   do {
   *       bits = next(31);
   *       val = bits % bound;
   *   } while (bits - val + (bound-1) < 0);
   *   return val;
   * }}
   *
   * The hedge "approximately" is used in the foregoing description only
   * because the next method is only approximately an unbiased source of
   * independently chosen bits.  If it were a perfect source of randomly
   * chosen bits, then the algorithm shown would choose `int`
   * values from the stated range with perfect uniformity.
   * 
   * The algorithm is slightly tricky.  It rejects values that would result
   * in an uneven distribution (due to the fact that 2^31 is not divisible
   * by n). The probability of a value being rejected depends on n.  The
   * worst case is n=2^30+1, for which the probability of a reject is 1/2,
   * and the expected number of iterations before the loop terminates is 2.
   * 
   * The algorithm treats the case where n is a power of two specially: it
   * returns the correct number of high-order bits from the underlying
   * pseudo-random number generator.  In the absence of special treatment,
   * the correct number of low-order bits would be returned.  Linear
   * congruential pseudo-random number generators such as the one
   * implemented by this class are known to have short periods in the
   * sequence of values of their low-order bits.  Thus, this special case
   * greatly increases the length of the sequence of values returned by
   * successive calls to this method if n is a small power of two.
   *
   * @param bound the upper bound (exclusive).  Must be positive.
   * @return the next pseudorandom, uniformly distributed `int`
   *         value between zero (inclusive) and `bound` (exclusive)
   *         from this random number generator's sequence
   * @throws IllegalArgumentException if bound is not positive
   * @since 1.2
  */
  nextInt(bound: number): number;
  /**
   * Returns the next pseudorandom, uniformly distributed `long`
   * value from this random number generator's sequence. The general
   * contract of `nextLong` is that one `long` value is
   * pseudorandomly generated and returned.
   *
   * The method `nextLong` is implemented by class `Random`
   * as if by:
   *   {@code
   * public long nextLong() {
   *   return ((long)next(32) << 32) + next(32);
   * }}
   *
   * Because class `Random` uses a seed with only 48 bits,
   * this algorithm will not return all possible `long` values.
   *
   * @return the next pseudorandom, uniformly distributed `long`
   *         value from this random number generator's sequence
  */
  nextLong(): number;
  /**
   * Returns the next pseudorandom, uniformly distributed
   * `boolean` value from this random number generator's
   * sequence. The general contract of `nextBoolean` is that one
   * `boolean` value is pseudorandomly generated and returned.  The
   * values `true` and `false` are produced with
   * (approximately) equal probability.
   *
   * The method `nextBoolean` is implemented by class `Random`
   * as if by:
   *   {@code
   * public boolean nextBoolean() {
   *   return next(1) != 0;
   * }}
   *
   * @return the next pseudorandom, uniformly distributed
   *         `boolean` value from this random number generator's
   *         sequence
   * @since 1.2
  */
  nextBoolean(): boolean;
  /**
   * Returns the next pseudorandom, uniformly distributed `float`
   * value between `0.0` and `1.0` from this random
   * number generator's sequence.
   *
   * The general contract of `nextFloat` is that one
   * `float` value, chosen (approximately) uniformly from the
   * range `0.0f` (inclusive) to `1.0f` (exclusive), is
   * pseudorandomly generated and returned. All 224 possible
   * `float` values of the form m x 2-24,
   * where m is a positive integer less than 224, are
   * produced with (approximately) equal probability.
   *
   * The method `nextFloat` is implemented by class `Random`
   * as if by:
   *   {@code
   * public float nextFloat() {
   *   return next(24) / ((float)(1 << 24));
   * }}
   *
   * The hedge "approximately" is used in the foregoing description only
   * because the next method is only approximately an unbiased source of
   * independently chosen bits. If it were a perfect source of randomly
   * chosen bits, then the algorithm shown would choose `float`
   * values from the stated range with perfect uniformity.
   * [In early versions of Java, the result was incorrectly calculated as:
   *   `     *   return next(30) / ((float)(1 << 30));`
   * This might seem to be equivalent, if not better, but in fact it
   * introduced a slight nonuniformity because of the bias in the rounding
   * of floating-point numbers: it was slightly more likely that the
   * low-order bit of the significand would be 0 than that it would be 1.]
   *
   * @return the next pseudorandom, uniformly distributed `float`
   *         value between `0.0` and `1.0` from this
   *         random number generator's sequence
  */
  nextFloat(): number;
  /**
   * Returns the next pseudorandom, uniformly distributed
   * `double` value between `0.0` and
   * `1.0` from this random number generator's sequence.
   *
   * The general contract of `nextDouble` is that one
   * `double` value, chosen (approximately) uniformly from the
   * range `0.0d` (inclusive) to `1.0d` (exclusive), is
   * pseudorandomly generated and returned.
   *
   * The method `nextDouble` is implemented by class `Random`
   * as if by:
   *   {@code
   * public double nextDouble() {
   *   return (((long)next(26) << 27) + next(27))
   *     / (double)(1L << 53);
   * }}
   *
   * The hedge "approximately" is used in the foregoing description only
   * because the `next` method is only approximately an unbiased
   * source of independently chosen bits. If it were a perfect source of
   * randomly chosen bits, then the algorithm shown would choose
   * `double` values from the stated range with perfect uniformity.
   * [In early versions of Java, the result was incorrectly calculated as:
   *   {@code
   *   return (((long)next(27) << 27) + next(27))
   *     / (double)(1L << 54);}
   * This might seem to be equivalent, if not better, but in fact it
   * introduced a large nonuniformity because of the bias in the rounding
   * of floating-point numbers: it was three times as likely that the
   * low-order bit of the significand would be 0 than that it would be 1!
   * This nonuniformity probably doesn't matter much in practice, but we
   * strive for perfection.]
   *
   * @return the next pseudorandom, uniformly distributed `double`
   *         value between `0.0` and `1.0` from this
   *         random number generator's sequence
   * @see Math#random
  */
  nextDouble(): number;
  /**
   * Returns the next pseudorandom, Gaussian ("normally") distributed
   * `double` value with mean `0.0` and standard
   * deviation `1.0` from this random number generator's sequence.
   * 
   * The general contract of `nextGaussian` is that one
   * `double` value, chosen from (approximately) the usual
   * normal distribution with mean `0.0` and standard deviation
   * `1.0`, is pseudorandomly generated and returned.
   *
   * The method `nextGaussian` is implemented by class
   * `Random` as if by a threadsafe version of the following:
   *   {@code
   * private double nextNextGaussian;
   * private boolean haveNextNextGaussian = false;
   *
   * public double nextGaussian() {
   *   if (haveNextNextGaussian) {
   *     haveNextNextGaussian = false;
   *     return nextNextGaussian;
   *   } else {
   *     double v1, v2, s;
   *     do {
   *       v1 = 2 * nextDouble() - 1;   // between -1.0 and 1.0
   *       v2 = 2 * nextDouble() - 1;   // between -1.0 and 1.0
   *       s = v1 * v1 + v2 * v2;
   *     } while (s >= 1 || s == 0);
   *     double multiplier = StrictMath.sqrt(-2 * StrictMath.log(s)/s);
   *     nextNextGaussian = v2 * multiplier;
   *     haveNextNextGaussian = true;
   *     return v1 * multiplier;
   *   }
   * }}
   * This uses the polar method of G. E. P. Box, M. E. Muller, and
   * G. Marsaglia, as described by Donald E. Knuth in The Art of
   * Computer Programming, Volume 2: Seminumerical Algorithms,
   * section 3.4.1, subsection C, algorithm P. Note that it generates two
   * independent values at the cost of only one call to `StrictMath.log`
   * and one call to `StrictMath.sqrt`.
   *
   * @return the next pseudorandom, Gaussian ("normally") distributed
   *         `double` value with mean `0.0` and
   *         standard deviation `1.0` from this random number
   *         generator's sequence
  */
  nextGaussian(): number;
  /**
   * Returns a stream producing the given `streamSize` number of
   * pseudorandom `int` values.
   *
   * A pseudorandom `int` value is generated as if it's the result of
   * calling the method {@link #nextInt()}.
   *
   * @param streamSize the number of values to generate
   * @return a stream of pseudorandom `int` values
   * @throws IllegalArgumentException if `streamSize` is
   *         less than zero
   * @since 1.8
  */
  ints(streamSize: number): IntStream;
  /**
   * Returns an effectively unlimited stream of pseudorandom `int`
   * values.
   *
   * A pseudorandom `int` value is generated as if it's the result of
   * calling the method {@link #nextInt()}.
   *
   * @implNote This method is implemented to be equivalent to `     * ints(Long.MAX_VALUE)`.
   *
   * @return a stream of pseudorandom `int` values
   * @since 1.8
  */
  ints(): IntStream;
  /**
   * Returns a stream producing the given `streamSize` number
   * of pseudorandom `int` values, each conforming to the given
   * origin (inclusive) and bound (exclusive).
   *
   * A pseudorandom `int` value is generated as if it's the result of
   * calling the following method with the origin and bound:
   *  {@code
   * int nextInt(int origin, int bound) {
   *   int n = bound - origin;
   *   if (n > 0) {
   *     return nextInt(n) + origin;
   *   }
   *   else {  // range not representable as int
   *     int r;
   *     do {
   *       r = nextInt();
   *     } while (r < origin || r >= bound);
   *     return r;
   *   }
   * }}
   *
   * @param streamSize the number of values to generate
   * @param randomNumberOrigin the origin (inclusive) of each random value
   * @param randomNumberBound the bound (exclusive) of each random value
   * @return a stream of pseudorandom `int` values,
   *         each with the given origin (inclusive) and bound (exclusive)
   * @throws IllegalArgumentException if `streamSize` is
   *         less than zero, or `randomNumberOrigin`
   *         is greater than or equal to `randomNumberBound`
   * @since 1.8
  */
  ints(streamSize: number, randomNumberOrigin: number, randomNumberBound: number): IntStream;
  /**
   * Returns an effectively unlimited stream of pseudorandom `     * int` values, each conforming to the given origin (inclusive) and bound
   * (exclusive).
   *
   * A pseudorandom `int` value is generated as if it's the result of
   * calling the following method with the origin and bound:
   *  {@code
   * int nextInt(int origin, int bound) {
   *   int n = bound - origin;
   *   if (n > 0) {
   *     return nextInt(n) + origin;
   *   }
   *   else {  // range not representable as int
   *     int r;
   *     do {
   *       r = nextInt();
   *     } while (r < origin || r >= bound);
   *     return r;
   *   }
   * }}
   *
   * @implNote This method is implemented to be equivalent to `     * ints(Long.MAX_VALUE, randomNumberOrigin, randomNumberBound)`.
   *
   * @param randomNumberOrigin the origin (inclusive) of each random value
   * @param randomNumberBound the bound (exclusive) of each random value
   * @return a stream of pseudorandom `int` values,
   *         each with the given origin (inclusive) and bound (exclusive)
   * @throws IllegalArgumentException if `randomNumberOrigin`
   *         is greater than or equal to `randomNumberBound`
   * @since 1.8
  */
  ints(randomNumberOrigin: number, randomNumberBound: number): IntStream;
  /**
   * Returns a stream producing the given `streamSize` number of
   * pseudorandom `long` values.
   *
   * A pseudorandom `long` value is generated as if it's the result
   * of calling the method {@link #nextLong()}.
   *
   * @param streamSize the number of values to generate
   * @return a stream of pseudorandom `long` values
   * @throws IllegalArgumentException if `streamSize` is
   *         less than zero
   * @since 1.8
  */
  longs(streamSize: number): LongStream;
  /**
   * Returns an effectively unlimited stream of pseudorandom `long`
   * values.
   *
   * A pseudorandom `long` value is generated as if it's the result
   * of calling the method {@link #nextLong()}.
   *
   * @implNote This method is implemented to be equivalent to `     * longs(Long.MAX_VALUE)`.
   *
   * @return a stream of pseudorandom `long` values
   * @since 1.8
  */
  longs(): LongStream;
  /**
   * Returns a stream producing the given `streamSize` number of
   * pseudorandom `long`, each conforming to the given origin
   * (inclusive) and bound (exclusive).
   *
   * A pseudorandom `long` value is generated as if it's the result
   * of calling the following method with the origin and bound:
   *  {@code
   * long nextLong(long origin, long bound) {
   *   long r = nextLong();
   *   long n = bound - origin, m = n - 1;
   *   if ((n & m) == 0L)  // power of two
   *     r = (r & m) + origin;
   *   else if (n > 0L) {  // reject over-represented candidates
   *     for (long u = r >>> 1;            // ensure nonnegative
   *          u + m - (r = u % n) < 0L;    // rejection check
   *          u = nextLong() >>> 1) // retry
   *         ;
   *     r += origin;
   *   }
   *   else {              // range not representable as long
   *     while (r < origin || r >= bound)
   *       r = nextLong();
   *   }
   *   return r;
   * }}
   *
   * @param streamSize the number of values to generate
   * @param randomNumberOrigin the origin (inclusive) of each random value
   * @param randomNumberBound the bound (exclusive) of each random value
   * @return a stream of pseudorandom `long` values,
   *         each with the given origin (inclusive) and bound (exclusive)
   * @throws IllegalArgumentException if `streamSize` is
   *         less than zero, or `randomNumberOrigin`
   *         is greater than or equal to `randomNumberBound`
   * @since 1.8
  */
  longs(streamSize: number, randomNumberOrigin: number, randomNumberBound: number): LongStream;
  /**
   * Returns an effectively unlimited stream of pseudorandom `     * long` values, each conforming to the given origin (inclusive) and bound
   * (exclusive).
   *
   * A pseudorandom `long` value is generated as if it's the result
   * of calling the following method with the origin and bound:
   *  {@code
   * long nextLong(long origin, long bound) {
   *   long r = nextLong();
   *   long n = bound - origin, m = n - 1;
   *   if ((n & m) == 0L)  // power of two
   *     r = (r & m) + origin;
   *   else if (n > 0L) {  // reject over-represented candidates
   *     for (long u = r >>> 1;            // ensure nonnegative
   *          u + m - (r = u % n) < 0L;    // rejection check
   *          u = nextLong() >>> 1) // retry
   *         ;
   *     r += origin;
   *   }
   *   else {              // range not representable as long
   *     while (r < origin || r >= bound)
   *       r = nextLong();
   *   }
   *   return r;
   * }}
   *
   * @implNote This method is implemented to be equivalent to `     * longs(Long.MAX_VALUE, randomNumberOrigin, randomNumberBound)`.
   *
   * @param randomNumberOrigin the origin (inclusive) of each random value
   * @param randomNumberBound the bound (exclusive) of each random value
   * @return a stream of pseudorandom `long` values,
   *         each with the given origin (inclusive) and bound (exclusive)
   * @throws IllegalArgumentException if `randomNumberOrigin`
   *         is greater than or equal to `randomNumberBound`
   * @since 1.8
  */
  longs(randomNumberOrigin: number, randomNumberBound: number): LongStream;
  /**
   * Returns a stream producing the given `streamSize` number of
   * pseudorandom `double` values, each between zero
   * (inclusive) and one (exclusive).
   *
   * A pseudorandom `double` value is generated as if it's the result
   * of calling the method {@link #nextDouble()}.
   *
   * @param streamSize the number of values to generate
   * @return a stream of `double` values
   * @throws IllegalArgumentException if `streamSize` is
   *         less than zero
   * @since 1.8
  */
  doubles(streamSize: number): DoubleStream;
  /**
   * Returns an effectively unlimited stream of pseudorandom `     * double` values, each between zero (inclusive) and one
   * (exclusive).
   *
   * A pseudorandom `double` value is generated as if it's the result
   * of calling the method {@link #nextDouble()}.
   *
   * @implNote This method is implemented to be equivalent to `     * doubles(Long.MAX_VALUE)`.
   *
   * @return a stream of pseudorandom `double` values
   * @since 1.8
  */
  doubles(): DoubleStream;
  /**
   * Returns a stream producing the given `streamSize` number of
   * pseudorandom `double` values, each conforming to the given origin
   * (inclusive) and bound (exclusive).
   *
   * A pseudorandom `double` value is generated as if it's the result
   * of calling the following method with the origin and bound:
   *  {@code
   * double nextDouble(double origin, double bound) {
   *   double r = nextDouble();
   *   r = r * (bound - origin) + origin;
   *   if (r >= bound) // correct for rounding
   *     r = Math.nextDown(bound);
   *   return r;
   * }}
   *
   * @param streamSize the number of values to generate
   * @param randomNumberOrigin the origin (inclusive) of each random value
   * @param randomNumberBound the bound (exclusive) of each random value
   * @return a stream of pseudorandom `double` values,
   *         each with the given origin (inclusive) and bound (exclusive)
   * @throws IllegalArgumentException if `streamSize` is
   *         less than zero
   * @throws IllegalArgumentException if `randomNumberOrigin`
   *         is greater than or equal to `randomNumberBound`
   * @since 1.8
  */
  doubles(streamSize: number, randomNumberOrigin: number, randomNumberBound: number): DoubleStream;
  /**
   * Returns an effectively unlimited stream of pseudorandom `     * double` values, each conforming to the given origin (inclusive) and bound
   * (exclusive).
   *
   * A pseudorandom `double` value is generated as if it's the result
   * of calling the following method with the origin and bound:
   *  {@code
   * double nextDouble(double origin, double bound) {
   *   double r = nextDouble();
   *   r = r * (bound - origin) + origin;
   *   if (r >= bound) // correct for rounding
   *     r = Math.nextDown(bound);
   *   return r;
   * }}
   *
   * @implNote This method is implemented to be equivalent to `     * doubles(Long.MAX_VALUE, randomNumberOrigin, randomNumberBound)`.
   *
   * @param randomNumberOrigin the origin (inclusive) of each random value
   * @param randomNumberBound the bound (exclusive) of each random value
   * @return a stream of pseudorandom `double` values,
   *         each with the given origin (inclusive) and bound (exclusive)
   * @throws IllegalArgumentException if `randomNumberOrigin`
   *         is greater than or equal to `randomNumberBound`
   * @since 1.8
  */
  doubles(randomNumberOrigin: number, randomNumberBound: number): DoubleStream;
}
/**
 * A `Locale` object represents a specific geographical, political,
 * or cultural region. An operation that requires a `Locale` to perform
 * its task is called locale-sensitive and uses the `Locale`
 * to tailor information for the user. For example, displaying a number
 * is a locale-sensitive operation— the number should be formatted
 * according to the customs and conventions of the user's native country,
 * region, or culture.
 *
 *  The `Locale` class implements IETF BCP 47 which is composed of
 * RFC 4647 "Matching of Language
 * Tags" and RFC 5646 "Tags
 * for Identifying Languages" with support for the LDML (UTS#35, "Unicode
 * Locale Data Markup Language") BCP 47-compatible extensions for locale data
 * exchange.
 *
 *  A `Locale` object logically consists of the fields
 * described below.
 *
 * 
 *   language
 *
 *   ISO 639 alpha-2 or alpha-3 language code, or registered
 *   language subtags up to 8 alpha letters (for future enhancements).
 *   When a language has both an alpha-2 code and an alpha-3 code, the
 *   alpha-2 code must be used.  You can find a full list of valid
 *   language codes in the IANA Language Subtag Registry (search for
 *   "Type: language").  The language field is case insensitive, but
 *   `Locale` always canonicalizes to lower case.
 *
 *   Well-formed language values have the form
 *   [a-zA-Z]{2,8}.  Note that this is not the full
 *   BCP47 language production, since it excludes extlang.  They are
 *   not needed since modern three-letter language codes replace
 *   them.
 *
 *   Example: "en" (English), "ja" (Japanese), "kok" (Konkani)
 *
 *   script
 *
 *   ISO 15924 alpha-4 script code.  You can find a full list of
 *   valid script codes in the IANA Language Subtag Registry (search
 *   for "Type: script").  The script field is case insensitive, but
 *   `Locale` always canonicalizes to title case (the first
 *   letter is upper case and the rest of the letters are lower
 *   case).
 *
 *   Well-formed script values have the form
 *   [a-zA-Z]{4}
 *
 *   Example: "Latn" (Latin), "Cyrl" (Cyrillic)
 *
 *   country (region)
 *
 *   ISO 3166 alpha-2 country code or UN M.49 numeric-3 area code.
 *   You can find a full list of valid country and region codes in the
 *   IANA Language Subtag Registry (search for "Type: region").  The
 *   country (region) field is case insensitive, but
 *   `Locale` always canonicalizes to upper case.
 *
 *   Well-formed country/region values have
 *   the form [a-zA-Z]{2} | [0-9]{3}
 *
 *   Example: "US" (United States), "FR" (France), "029"
 *   (Caribbean)
 *
 *   variant
 *
 *   Any arbitrary value used to indicate a variation of a
 *   `Locale`.  Where there are two or more variant values
 *   each indicating its own semantics, these values should be ordered
 *   by importance, with most important first, separated by
 *   underscore('_').  The variant field is case sensitive.
 *
 *   Note: IETF BCP 47 places syntactic restrictions on variant
 *   subtags.  Also BCP 47 subtags are strictly used to indicate
 *   additional variations that define a language or its dialects that
 *   are not covered by any combinations of language, script and
 *   region subtags.  You can find a full list of valid variant codes
 *   in the IANA Language Subtag Registry (search for "Type: variant").
 *
 *   However, the variant field in `Locale` has
 *   historically been used for any kind of variation, not just
 *   language variations.  For example, some supported variants
 *   available in Java SE Runtime Environments indicate alternative
 *   cultural behaviors such as calendar type or number script.  In
 *   BCP 47 this kind of information, which does not identify the
 *   language, is supported by extension subtags or private use
 *   subtags.
 *
 *   Well-formed variant values have the form SUBTAG
 *   (('_'|'-') SUBTAG)* where SUBTAG =
 *   [0-9][0-9a-zA-Z]{3} | [0-9a-zA-Z]{5,8}. (Note: BCP 47 only
 *   uses hyphen ('-') as a delimiter, this is more lenient).
 *
 *   Example: "polyton" (Polytonic Greek), "POSIX"
 *
 *   extensions
 *
 *   A map from single character keys to string values, indicating
 *   extensions apart from language identification.  The extensions in
 *   `Locale` implement the semantics and syntax of BCP 47
 *   extension subtags and private use subtags. The extensions are
 *   case insensitive, but `Locale` canonicalizes all
 *   extension keys and values to lower case. Note that extensions
 *   cannot have empty values.
 *
 *   Well-formed keys are single characters from the set
 *   `[0-9a-zA-Z]`.  Well-formed values have the form
 *   `SUBTAG ('-' SUBTAG)*` where for the key 'x'
 *   SUBTAG = [0-9a-zA-Z]{1,8} and for other keys
 *   SUBTAG = [0-9a-zA-Z]{2,8} (that is, 'x' allows
 *   single-character subtags).
 *
 *   Example: key="u"/value="ca-japanese" (Japanese Calendar),
 *   key="x"/value="java-1-7"
 * 
 *
 * Note: Although BCP 47 requires field values to be registered
 * in the IANA Language Subtag Registry, the `Locale` class
 * does not provide any validation features.  The `Builder`
 * only checks if an individual field satisfies the syntactic
 * requirement (is well-formed), but does not validate the value
 * itself.  See {@link Builder} for details.
 *
 * Unicode locale/language extension
 *
 * UTS#35, "Unicode Locale Data Markup Language" defines optional
 * attributes and keywords to override or refine the default behavior
 * associated with a locale.  A keyword is represented by a pair of
 * key and type.  For example, "nu-thai" indicates that Thai local
 * digits (value:"thai") should be used for formatting numbers
 * (key:"nu").
 *
 * The keywords are mapped to a BCP 47 extension value using the
 * extension key 'u' ({@link #UNICODE_LOCALE_EXTENSION}).  The above
 * example, "nu-thai", becomes the extension "u-nu-thai".
 *
 * Thus, when a `Locale` object contains Unicode locale
 * attributes and keywords,
 * `getExtension(UNICODE_LOCALE_EXTENSION)` will return a
 * String representing this information, for example, "nu-thai".  The
 * `Locale` class also provides {@link
 * #getUnicodeLocaleAttributes}, {@link #getUnicodeLocaleKeys}, and
 * {@link #getUnicodeLocaleType} which allow you to access Unicode
 * locale attributes and key/type pairs directly.  When represented as
 * a string, the Unicode Locale Extension lists attributes
 * alphabetically, followed by key/type sequences with keys listed
 * alphabetically (the order of subtags comprising a key's type is
 * fixed when the type is defined)
 *
 * A well-formed locale key has the form
 * [0-9a-zA-Z]{2}.  A well-formed locale type has the
 * form "" | [0-9a-zA-Z]{3,8} ('-' [0-9a-zA-Z]{3,8})* (it
 * can be empty, or a series of subtags 3-8 alphanums in length).  A
 * well-formed locale attribute has the form
 * [0-9a-zA-Z]{3,8} (it is a single subtag with the same
 * form as a locale type subtag).
 *
 * The Unicode locale extension specifies optional behavior in
 * locale-sensitive services.  Although the LDML specification defines
 * various keys and values, actual locale-sensitive service
 * implementations in a Java Runtime Environment might not support any
 * particular Unicode locale attributes or key/type pairs.
 *
 * Creating a Locale
 *
 * There are several different ways to create a `Locale`
 * object.
 *
 * Builder
 *
 * Using {@link Builder} you can construct a `Locale` object
 * that conforms to BCP 47 syntax.
 *
 * Constructors
 *
 * The `Locale` class provides three constructors:
 * 
 *  *     {@link #Locale(String language)}
 *     {@link #Locale(String language, String country)}
 *     {@link #Locale(String language, String country, String variant)}
 * 
 * 
 * These constructors allow you to create a `Locale` object
 * with language, country and variant, but you cannot specify
 * script or extensions.
 *
 * Factory Methods
 *
 * The method {@link #forLanguageTag} creates a `Locale`
 * object for a well-formed BCP 47 language tag.
 *
 * Locale Constants
 *
 * The `Locale` class provides a number of convenient constants
 * that you can use to create `Locale` objects for commonly used
 * locales. For example, the following creates a `Locale` object
 * for the United States:
 * 
 *  *     Locale.US
 * 
 * 
 *
 * Locale Matching
 *
 * If an application or a system is internationalized and provides localized
 * resources for multiple locales, it sometimes needs to find one or more
 * locales (or language tags) which meet each user's specific preferences. Note
 * that a term "language tag" is used interchangeably with "locale" in this
 * locale matching documentation.
 *
 * In order to do matching a user's preferred locales to a set of language
 * tags, RFC 4647 Matching of
 * Language Tags defines two mechanisms: filtering and lookup.
 * Filtering is used to get all matching locales, whereas
 * lookup is to choose the best matching locale.
 * Matching is done case-insensitively. These matching mechanisms are described
 * in the following sections.
 *
 * A user's preference is called a Language Priority List and is
 * expressed as a list of language ranges. There are syntactically two types of
 * language ranges: basic and extended. See
 * {@link Locale.LanguageRange Locale.LanguageRange} for details.
 *
 * Filtering
 *
 * The filtering operation returns all matching language tags. It is defined
 * in RFC 4647 as follows:
 * "In filtering, each language range represents the least specific language
 * tag (that is, the language tag with fewest number of subtags) that is an
 * acceptable match. All of the language tags in the matching set of tags will
 * have an equal or greater number of subtags than the language range. Every
 * non-wildcard subtag in the language range will appear in every one of the
 * matching language tags."
 *
 * There are two types of filtering: filtering for basic language ranges
 * (called "basic filtering") and filtering for extended language ranges
 * (called "extended filtering"). They may return different results by what
 * kind of language ranges are included in the given Language Priority List.
 * {@link Locale.FilteringMode} is a parameter to specify how filtering should
 * be done.
 *
 * Lookup
 *
 * The lookup operation returns the best matching language tags. It is
 * defined in RFC 4647 as follows:
 * "By contrast with filtering, each language range represents the most
 * specific tag that is an acceptable match.  The first matching tag found,
 * according to the user's priority, is considered the closest match and is the
 * item returned."
 *
 * For example, if a Language Priority List consists of two language ranges,
 * `"zh-Hant-TW"` and `"en-US"`, in prioritized order, lookup
 * method progressively searches the language tags below in order to find the
 * best matching language tag.
 * 
 *  *    1. zh-Hant-TW
 *    2. zh-Hant
 *    3. zh
 *    4. en-US
 *    5. en
 * 
 * 
 * If there is a language tag which matches completely to a language range
 * above, the language tag is returned.
 *
 * `"*"` is the special language range, and it is ignored in lookup.
 *
 * If multiple language tags match as a result of the subtag `'*'`
 * included in a language range, the first matching language tag returned by
 * an {@link Iterator} over a {@link Collection} of language tags is treated as
 * the best matching one.
 *
 * Use of Locale
 *
 * Once you've created a `Locale` you can query it for information
 * about itself. Use `getCountry` to get the country (or region)
 * code and `getLanguage` to get the language code.
 * You can use `getDisplayCountry` to get the
 * name of the country suitable for displaying to the user. Similarly,
 * you can use `getDisplayLanguage` to get the name of
 * the language suitable for displaying to the user. Interestingly,
 * the `getDisplayXXX` methods are themselves locale-sensitive
 * and have two versions: one that uses the default
 * {@link Locale.Category#DISPLAY DISPLAY} locale and one
 * that uses the locale specified as an argument.
 *
 * The Java Platform provides a number of classes that perform locale-sensitive
 * operations. For example, the `NumberFormat` class formats
 * numbers, currency, and percentages in a locale-sensitive manner. Classes
 * such as `NumberFormat` have several convenience methods
 * for creating a default object of that type. For example, the
 * `NumberFormat` class provides these three convenience methods
 * for creating a default `NumberFormat` object:
 * 
 *  *     NumberFormat.getInstance()
 *     NumberFormat.getCurrencyInstance()
 *     NumberFormat.getPercentInstance()
 * 
 * 
 * Each of these methods has two variants; one with an explicit locale
 * and one without; the latter uses the default
 * {@link Locale.Category#FORMAT FORMAT} locale:
 * 
 *  *     NumberFormat.getInstance(myLocale)
 *     NumberFormat.getCurrencyInstance(myLocale)
 *     NumberFormat.getPercentInstance(myLocale)
 * 
 * 
 * A `Locale` is the mechanism for identifying the kind of object
 * (`NumberFormat`) that you would like to get. The locale is
 * just a mechanism for identifying objects,
 * not a container for the objects themselves.
 *
 * Compatibility
 *
 * In order to maintain compatibility with existing usage, Locale's
 * constructors retain their behavior prior to the Java Runtime
 * Environment version 1.7.  The same is largely true for the
 * `toString` method. Thus Locale objects can continue to
 * be used as they were. In particular, clients who parse the output
 * of toString into language, country, and variant fields can continue
 * to do so (although this is strongly discouraged), although the
 * variant field will have additional information in it if script or
 * extensions are present.
 *
 * In addition, BCP 47 imposes syntax restrictions that are not
 * imposed by Locale's constructors. This means that conversions
 * between some Locales and BCP 47 language tags cannot be made without
 * losing information. Thus `toLanguageTag` cannot
 * represent the state of locales whose language, country, or variant
 * do not conform to BCP 47.
 *
 * Because of these issues, it is recommended that clients migrate
 * away from constructing non-conforming locales and use the
 * `forLanguageTag` and `Locale.Builder` APIs instead.
 * Clients desiring a string representation of the complete locale can
 * then always rely on `toLanguageTag` for this purpose.
 *
 * Special cases
 *
 * For compatibility reasons, two
 * non-conforming locales are treated as special cases.  These are
 * `ja_JP_JP` and `th_TH_TH`. These are ill-formed
 * in BCP 47 since the variants are too short. To ease migration to BCP 47,
 * these are treated specially during construction.  These two cases (and only
 * these) cause a constructor to generate an extension, all other values behave
 * exactly as they did prior to Java 7.
 *
 * Java has used `ja_JP_JP` to represent Japanese as used in
 * Japan together with the Japanese Imperial calendar. This is now
 * representable using a Unicode locale extension, by specifying the
 * Unicode locale key `ca` (for "calendar") and type
 * `japanese`. When the Locale constructor is called with the
 * arguments "ja", "JP", "JP", the extension "u-ca-japanese" is
 * automatically added.
 *
 * Java has used `th_TH_TH` to represent Thai as used in
 * Thailand together with Thai digits. This is also now representable using
 * a Unicode locale extension, by specifying the Unicode locale key
 * `nu` (for "number") and value `thai`. When the Locale
 * constructor is called with the arguments "th", "TH", "TH", the
 * extension "u-nu-thai" is automatically added.
 *
 * Serialization
 *
 * During serialization, writeObject writes all fields to the output
 * stream, including extensions.
 *
 * During deserialization, readResolve adds extensions as described
 * in Special Cases, only
 * for the two cases th_TH_TH and ja_JP_JP.
 *
 * Legacy language codes
 *
 * Locale's constructor has always converted three language codes to
 * their earlier, obsoleted forms: `he` maps to `iw`,
 * `yi` maps to `ji`, and `id` maps to
 * `in`.  This continues to be the case, in order to not break
 * backwards compatibility.
 *
 * The APIs added in 1.7 map between the old and new language codes,
 * maintaining the old codes internal to Locale (so that
 * `getLanguage` and `toString` reflect the old
 * code), but using the new codes in the BCP 47 language tag APIs (so
 * that `toLanguageTag` reflects the new one). This
 * preserves the equivalence between Locales no matter which code or
 * API is used to construct them. Java's default resource bundle
 * lookup mechanism also implements this mapping, so that resources
 * can be named using either convention, see {@link ResourceBundle.Control}.
 *
 * Three-letter language/country(region) codes
 *
 * The Locale constructors have always specified that the language
 * and the country param be two characters in length, although in
 * practice they have accepted any length.  The specification has now
 * been relaxed to allow language codes of two to eight characters and
 * country (region) codes of two to three characters, and in
 * particular, three-letter language codes and three-digit region
 * codes as specified in the IANA Language Subtag Registry.  For
 * compatibility, the implementation still does not impose a length
 * constraint.
 *
 * @see Builder
 * @see ResourceBundle
 * @see java.text.Format
 * @see java.text.NumberFormat
 * @see java.text.Collator
 * @author Mark Davis
 * @since 1.1
*/
export class Locale extends Cloneable {
  /**
   Useful constant for language.
  */
  static readonly ENGLISH: Locale;
  /**
   Useful constant for language.
  */
  static readonly FRENCH: Locale;
  /**
   Useful constant for language.
  */
  static readonly GERMAN: Locale;
  /**
   Useful constant for language.
  */
  static readonly ITALIAN: Locale;
  /**
   Useful constant for language.
  */
  static readonly JAPANESE: Locale;
  /**
   Useful constant for language.
  */
  static readonly KOREAN: Locale;
  /**
   Useful constant for language.
  */
  static readonly CHINESE: Locale;
  /**
   Useful constant for language.
  */
  static readonly SIMPLIFIED_CHINESE: Locale;
  /**
   Useful constant for language.
  */
  static readonly TRADITIONAL_CHINESE: Locale;
  /**
   Useful constant for country.
  */
  static readonly FRANCE: Locale;
  /**
   Useful constant for country.
  */
  static readonly GERMANY: Locale;
  /**
   Useful constant for country.
  */
  static readonly ITALY: Locale;
  /**
   Useful constant for country.
  */
  static readonly JAPAN: Locale;
  /**
   Useful constant for country.
  */
  static readonly KOREA: Locale;
  /**
   Useful constant for country.
  */
  static readonly UK: Locale;
  /**
   Useful constant for country.
  */
  static readonly US: Locale;
  /**
   Useful constant for country.
  */
  static readonly CANADA: Locale;
  /**
   Useful constant for country.
  */
  static readonly CANADA_FRENCH: Locale;
  /**
   * Useful constant for the root locale.  The root locale is the locale whose
   * language, country, and variant are empty ("") strings.  This is regarded
   * as the base locale of all locales, and is used as the language/country
   * neutral locale for the locale sensitive operations.
   *
   * @since 1.6
  */
  static readonly ROOT: Locale;
  /**
   Useful constant for country.
  */
  static readonly CHINA: Locale;
  /**
   Useful constant for country.
  */
  static readonly PRC: Locale;
  /**
   Useful constant for country.
  */
  static readonly TAIWAN: Locale;
  /**
   * The key for the private use extension ('x').
   *
   * @see #getExtension(char)
   * @see Builder#setExtension(char, String)
   * @since 1.7
  */
  static readonly PRIVATE_USE_EXTENSION: string;
  /**
   * The key for Unicode locale extension ('u').
   *
   * @see #getExtension(char)
   * @see Builder#setExtension(char, String)
   * @since 1.7
  */
  static readonly UNICODE_LOCALE_EXTENSION: string;
  /**
   * Construct a locale from language, country and variant.
   * This constructor normalizes the language value to lowercase and
   * the country value to uppercase.
   * 
   * Note:
   * 
   * ISO 639 is not a stable standard; some of the language codes it defines
   * (specifically "iw", "ji", and "in") have changed.  This constructor accepts both the
   * old codes ("iw", "ji", and "in") and the new codes ("he", "yi", and "id"), but all other
   * API on Locale will return only the OLD codes.
   * For backward compatibility reasons, this constructor does not make
   * any syntactic checks on the input.
   * The two cases ("ja", "JP", "JP") and ("th", "TH", "TH") are handled specially,
   * see Special Cases for more information.
   * 
   *
   * @param language An ISO 639 alpha-2 or alpha-3 language code, or a language subtag
   * up to 8 characters in length.  See the `Locale` class description about
   * valid language values.
   * @param country An ISO 3166 alpha-2 country code or a UN M.49 numeric-3 area code.
   * See the `Locale` class description about valid country values.
   * @param variant Any arbitrary value used to indicate a variation of a `Locale`.
   * See the `Locale` class description for the details.
   * @throws    NullPointerException thrown if any argument is null.
  */
  constructor(language: string, country: string, variant: string);
  /**
   * Construct a locale from language and country.
   * This constructor normalizes the language value to lowercase and
   * the country value to uppercase.
   * 
   * Note:
   * 
   * ISO 639 is not a stable standard; some of the language codes it defines
   * (specifically "iw", "ji", and "in") have changed.  This constructor accepts both the
   * old codes ("iw", "ji", and "in") and the new codes ("he", "yi", and "id"), but all other
   * API on Locale will return only the OLD codes.
   * For backward compatibility reasons, this constructor does not make
   * any syntactic checks on the input.
   * 
   *
   * @param language An ISO 639 alpha-2 or alpha-3 language code, or a language subtag
   * up to 8 characters in length.  See the `Locale` class description about
   * valid language values.
   * @param country An ISO 3166 alpha-2 country code or a UN M.49 numeric-3 area code.
   * See the `Locale` class description about valid country values.
   * @throws    NullPointerException thrown if either argument is null.
  */
  constructor(language: string, country: string);
  /**
   * Construct a locale from a language code.
   * This constructor normalizes the language value to lowercase.
   * 
   * Note:
   * 
   * ISO 639 is not a stable standard; some of the language codes it defines
   * (specifically "iw", "ji", and "in") have changed.  This constructor accepts both the
   * old codes ("iw", "ji", and "in") and the new codes ("he", "yi", and "id"), but all other
   * API on Locale will return only the OLD codes.
   * For backward compatibility reasons, this constructor does not make
   * any syntactic checks on the input.
   * 
   *
   * @param language An ISO 639 alpha-2 or alpha-3 language code, or a language subtag
   * up to 8 characters in length.  See the `Locale` class description about
   * valid language values.
   * @throws    NullPointerException thrown if argument is null.
   * @since 1.4
  */
  constructor(language: string);
  /**
   * Gets the current value of the default locale for this instance
   * of the Java Virtual Machine.
   * 
   * The Java Virtual Machine sets the default locale during startup
   * based on the host environment. It is used by many locale-sensitive
   * methods if no locale is explicitly specified.
   * It can be changed using the
   * {@link #setDefault(java.util.Locale) setDefault} method.
   *
   * @return the default locale for this instance of the Java Virtual Machine
  */
  static getDefault(): Locale;
  /**
   * Gets the current value of the default locale for the specified Category
   * for this instance of the Java Virtual Machine.
   * 
   * The Java Virtual Machine sets the default locale during startup based
   * on the host environment. It is used by many locale-sensitive methods
   * if no locale is explicitly specified. It can be changed using the
   * setDefault(Locale.Category, Locale) method.
   *
   * @param category the specified category to get the default locale
   * @throws NullPointerException if category is null
   * @return the default locale for the specified Category for this instance
   *     of the Java Virtual Machine
   * @see #setDefault(Locale.Category, Locale)
   * @since 1.7
  */
  static getDefault(category: Category): Locale;
  /**
   * Sets the default locale for this instance of the Java Virtual Machine.
   * This does not affect the host locale.
   * 
   * If there is a security manager, its `checkPermission`
   * method is called with a `PropertyPermission("user.language", "write")`
   * permission before the default locale is changed.
   * 
   * The Java Virtual Machine sets the default locale during startup
   * based on the host environment. It is used by many locale-sensitive
   * methods if no locale is explicitly specified.
   * 
   * Since changing the default locale may affect many different areas
   * of functionality, this method should only be used if the caller
   * is prepared to reinitialize locale-sensitive code running
   * within the same Java Virtual Machine.
   * 
   * By setting the default locale with this method, all of the default
   * locales for each Category are also set to the specified default locale.
   *
   * @throws SecurityException
   *        if a security manager exists and its
   *        `checkPermission` method doesn't allow the operation.
   * @throws NullPointerException if `newLocale` is null
   * @param newLocale the new default locale
   * @see SecurityManager#checkPermission
   * @see java.util.PropertyPermission
  */
  static setDefault(default_: Locale);
  /**
   * Sets the default locale for the specified Category for this instance
   * of the Java Virtual Machine. This does not affect the host locale.
   * 
   * If there is a security manager, its checkPermission method is called
   * with a PropertyPermission("user.language", "write") permission before
   * the default locale is changed.
   * 
   * The Java Virtual Machine sets the default locale during startup based
   * on the host environment. It is used by many locale-sensitive methods
   * if no locale is explicitly specified.
   * 
   * Since changing the default locale may affect many different areas of
   * functionality, this method should only be used if the caller is
   * prepared to reinitialize locale-sensitive code running within the
   * same Java Virtual Machine.
   *
   * @param category the specified category to set the default locale
   * @param newLocale the new default locale
   * @throws SecurityException if a security manager exists and its
   *     checkPermission method doesn't allow the operation.
   * @throws NullPointerException if category and/or newLocale is null
   * @see SecurityManager#checkPermission(java.security.Permission)
   * @see PropertyPermission
   * @see #getDefault(Locale.Category)
   * @since 1.7
  */
  static setDefault(category: Category, newLocale: Locale): void;
  /**
   * Returns an array of all installed locales.
   * The returned array represents the union of locales supported
   * by the Java runtime environment and by installed
   * {@link java.util.spi.LocaleServiceProvider LocaleServiceProvider}
   * implementations.  It must contain at least a `Locale`
   * instance equal to {@link java.util.Locale#US Locale.US}.
   *
   * @return An array of installed locales.
  */
  static getAvailableLocales(): Locale[];
  /**
   * Returns a list of all 2-letter country codes defined in ISO 3166.
   * Can be used to create Locales.
   * This method is equivalent to {@link #getISOCountries(Locale.IsoCountryCode type)}
   * with `type`  {@link IsoCountryCode#PART1_ALPHA2}.
   * 
   * Note: The `Locale` class also supports other codes for
   * country (region), such as 3-letter numeric UN M.49 area codes.
   * Therefore, the list returned by this method does not contain ALL valid
   * codes that can be used to create Locales.
   * 
   * Note that this method does not return obsolete 2-letter country codes.
   * ISO3166-3 codes which designate country codes for those obsolete codes,
   * can be retrieved from {@link #getISOCountries(Locale.IsoCountryCode type)} with
   * `type`  {@link IsoCountryCode#PART3}.
   * @return An array of ISO 3166 two-letter country codes.
  */
  static getISOCountries(): string[];
  /**
   * Returns a `Set` of ISO3166 country codes for the specified type.
   *
   * @param type {@link Locale.IsoCountryCode} specified ISO code type.
   * @see java.util.Locale.IsoCountryCode
   * @throws NullPointerException if type is null
   * @return a `Set` of ISO country codes for the specified type.
   * @since 9
  */
  static getISOCountries(type: IsoCountryCode): Set<string>;
  /**
   * Returns a list of all 2-letter language codes defined in ISO 639.
   * Can be used to create Locales.
   * 
   * Note:
   * 
   * ISO 639 is not a stable standard— some languages' codes have changed.
   * The list this function returns includes both the new and the old codes for the
   * languages whose codes have changed.
   * The `Locale` class also supports language codes up to
   * 8 characters in length.  Therefore, the list returned by this method does
   * not contain ALL valid codes that can be used to create Locales.
   * 
   *
   * @return An array of ISO 639 two-letter language codes.
  */
  static getISOLanguages(): string[];
  /**
   * Returns the language code of this Locale.
   *
   * Note: ISO 639 is not a stable standard— some languages' codes have changed.
   * Locale's constructor recognizes both the new and the old codes for the languages
   * whose codes have changed, but this function always returns the old code.  If you
   * want to check for a specific language whose code has changed, don't do
   *      * if (locale.getLanguage().equals("he")) // BAD!
   *    ...
   * 
   * Instead, do
   *      * if (locale.getLanguage().equals(new Locale("he").getLanguage()))
   *    ...
   * 
   * @return The language code, or the empty string if none is defined.
   * @see #getDisplayLanguage
  */
  getLanguage(): string;
  /**
   * Returns the script for this locale, which should
   * either be the empty string or an ISO 15924 4-letter script
   * code. The first letter is uppercase and the rest are
   * lowercase, for example, 'Latn', 'Cyrl'.
   *
   * @return The script code, or the empty string if none is defined.
   * @see #getDisplayScript
   * @since 1.7
  */
  getScript(): string;
  /**
   * Returns the country/region code for this locale, which should
   * either be the empty string, an uppercase ISO 3166 2-letter code,
   * or a UN M.49 3-digit code.
   *
   * @return The country/region code, or the empty string if none is defined.
   * @see #getDisplayCountry
  */
  getCountry(): string;
  /**
   * Returns the variant code for this locale.
   *
   * @return The variant code, or the empty string if none is defined.
   * @see #getDisplayVariant
  */
  getVariant(): string;
  /**
   * Returns `true` if this `Locale` has any 
   * extensions.
   *
   * @return `true` if this `Locale` has any extensions
   * @since 1.8
  */
  hasExtensions(): boolean;
  /**
   * Returns a copy of this `Locale` with no 
   * extensions. If this `Locale` has no extensions, this `Locale`
   * is returned.
   *
   * @return a copy of this `Locale` with no extensions, or `this`
   *         if `this` has no extensions
   * @since 1.8
  */
  stripExtensions(): Locale;
  /**
   * Returns the extension (or private use) value associated with
   * the specified key, or null if there is no extension
   * associated with the key. To be well-formed, the key must be one
   * of `[0-9A-Za-z]`. Keys are case-insensitive, so
   * for example 'z' and 'Z' represent the same extension.
   *
   * @param key the extension key
   * @return The extension, or null if this locale defines no
   * extension for the specified key.
   * @throws IllegalArgumentException if key is not well-formed
   * @see #PRIVATE_USE_EXTENSION
   * @see #UNICODE_LOCALE_EXTENSION
   * @since 1.7
  */
  getExtension(key: string): string;
  /**
   * Returns the set of extension keys associated with this locale, or the
   * empty set if it has no extensions. The returned set is unmodifiable.
   * The keys will all be lower-case.
   *
   * @return The set of extension keys, or the empty set if this locale has
   * no extensions.
   * @since 1.7
  */
  getExtensionKeys(): Set<string>;
  /**
   * Returns the set of unicode locale attributes associated with
   * this locale, or the empty set if it has no attributes. The
   * returned set is unmodifiable.
   *
   * @return The set of attributes.
   * @since 1.7
  */
  getUnicodeLocaleAttributes(): Set<string>;
  /**
   * Returns the Unicode locale type associated with the specified Unicode locale key
   * for this locale. Returns the empty string for keys that are defined with no type.
   * Returns null if the key is not defined. Keys are case-insensitive. The key must
   * be two alphanumeric characters ([0-9a-zA-Z]), or an IllegalArgumentException is
   * thrown.
   *
   * @param key the Unicode locale key
   * @return The Unicode locale type associated with the key, or null if the
   * locale does not define the key.
   * @throws IllegalArgumentException if the key is not well-formed
   * @throws NullPointerException if `key` is null
   * @since 1.7
  */
  getUnicodeLocaleType(key: string): string;
  /**
   * Returns the set of Unicode locale keys defined by this locale, or the empty set if
   * this locale has none.  The returned set is immutable.  Keys are all lower case.
   *
   * @return The set of Unicode locale keys, or the empty set if this locale has
   * no Unicode locale keywords.
   * @since 1.7
  */
  getUnicodeLocaleKeys(): Set<string>;
  /**
   * Returns a string representation of this `Locale`
   * object, consisting of language, country, variant, script,
   * and extensions as below:
   * 
   * language + "_" + country + "_" + (variant + "_#" | "#") + script + "_" + extensions
   * 
   *
   * Language is always lower case, country is always upper case, script is always title
   * case, and extensions are always lower case.  Extensions and private use subtags
   * will be in canonical order as explained in {@link #toLanguageTag}.
   *
   * When the locale has neither script nor extensions, the result is the same as in
   * Java 6 and prior.
   *
   * If both the language and country fields are missing, this function will return
   * the empty string, even if the variant, script, or extensions field is present (you
   * can't have a locale with just a variant, the variant must accompany a well-formed
   * language or country code).
   *
   * If script or extensions are present and variant is missing, no underscore is
   * added before the "#".
   *
   * This behavior is designed to support debugging and to be compatible with
   * previous uses of `toString` that expected language, country, and variant
   * fields only.  To represent a Locale as a String for interchange purposes, use
   * {@link #toLanguageTag}.
   *
   * Examples: 
   * `en`
   * `de_DE`
   * `_GB`
   * `en_US_WIN`
   * `de__POSIX`
   * `zh_CN_#Hans`
   * `zh_TW_#Hant_x-java`
   * `th_TH_TH_#u-nu-thai`
   *
   * @return A string representation of the Locale, for debugging.
   * @see #getDisplayName
   * @see #toLanguageTag
  */
  toString(): string;
  /**
   * Returns a well-formed IETF BCP 47 language tag representing
   * this locale.
   *
   * If this `Locale` has a language, country, or
   * variant that does not satisfy the IETF BCP 47 language tag
   * syntax requirements, this method handles these fields as
   * described below:
   *
   * Language: If language is empty, or not well-formed (for example "a" or
   * "e2"), it will be emitted as "und" (Undetermined).
   *
   * Country: If country is not well-formed (for example "12" or "USA"),
   * it will be omitted.
   *
   * Variant: If variant is well-formed, each sub-segment
   * (delimited by '-' or '_') is emitted as a subtag.  Otherwise:
   * 
   *
   * if all sub-segments match [0-9a-zA-Z]{1,8}
   * (for example "WIN" or "Oracle_JDK_Standard_Edition"), the first
   * ill-formed sub-segment and all following will be appended to
   * the private use subtag.  The first appended subtag will be
   * "lvariant", followed by the sub-segments in order, separated by
   * hyphen. For example, "x-lvariant-WIN",
   * "Oracle-x-lvariant-JDK-Standard-Edition".
   *
   * if any sub-segment does not match
   * [0-9a-zA-Z]{1,8}, the variant will be truncated
   * and the problematic sub-segment and all following sub-segments
   * will be omitted.  If the remainder is non-empty, it will be
   * emitted as a private use subtag as above (even if the remainder
   * turns out to be well-formed).  For example,
   * "Solaris_isjustthecoolestthing" is emitted as
   * "x-lvariant-Solaris", not as "solaris".
   *
   * Special Conversions: Java supports some old locale
   * representations, including deprecated ISO language codes,
   * for compatibility. This method performs the following
   * conversions:
   * 
   *
   * Deprecated ISO language codes "iw", "ji", and "in" are
   * converted to "he", "yi", and "id", respectively.
   *
   * A locale with language "no", country "NO", and variant
   * "NY", representing Norwegian Nynorsk (Norway), is converted
   * to a language tag "nn-NO".
   *
   * Note: Although the language tag created by this
   * method is well-formed (satisfies the syntax requirements
   * defined by the IETF BCP 47 specification), it is not
   * necessarily a valid BCP 47 language tag.  For example,
   *      *   new Locale("xx", "YY").toLanguageTag();
   *
   * will return "xx-YY", but the language subtag "xx" and the
   * region subtag "YY" are invalid because they are not registered
   * in the IANA Language Subtag Registry.
   *
   * @return a BCP47 language tag representing the locale
   * @see #forLanguageTag(String)
   * @since 1.7
  */
  toLanguageTag(): string;
  /**
   * Returns a locale for the specified IETF BCP 47 language tag string.
   *
   * If the specified language tag contains any ill-formed subtags,
   * the first such subtag and all following subtags are ignored.  Compare
   * to {@link Locale.Builder#setLanguageTag} which throws an exception
   * in this case.
   *
   * The following conversions are performed:
   *
   * The language code "und" is mapped to language "".
   *
   * The language codes "he", "yi", and "id" are mapped to "iw",
   * "ji", and "in" respectively. (This is the same canonicalization
   * that's done in Locale's constructors.)
   *
   * The portion of a private use subtag prefixed by "lvariant",
   * if any, is removed and appended to the variant field in the
   * result locale (without case normalization).  If it is then
   * empty, the private use subtag is discarded:
   *
   *      *     Locale loc;
   *     loc = Locale.forLanguageTag("en-US-x-lvariant-POSIX");
   *     loc.getVariant(); // returns "POSIX"
   *     loc.getExtension('x'); // returns null
   *
   *     loc = Locale.forLanguageTag("de-POSIX-x-URP-lvariant-Abc-Def");
   *     loc.getVariant(); // returns "POSIX_Abc_Def"
   *     loc.getExtension('x'); // returns "urp"
   * 
   *
   * When the languageTag argument contains an extlang subtag,
   * the first such subtag is used as the language, and the primary
   * language subtag and other extlang subtags are ignored:
   *
   *      *     Locale.forLanguageTag("ar-aao").getLanguage(); // returns "aao"
   *     Locale.forLanguageTag("en-abc-def-us").toString(); // returns "abc_US"
   * 
   *
   * Case is normalized except for variant tags, which are left
   * unchanged.  Language is normalized to lower case, script to
   * title case, country to upper case, and extensions to lower
   * case.
   *
   * If, after processing, the locale would exactly match either
   * ja_JP_JP or th_TH_TH with no extensions, the appropriate
   * extensions are added as though the constructor had been called:
   *
   *      *    Locale.forLanguageTag("ja-JP-x-lvariant-JP").toLanguageTag();
   *    // returns "ja-JP-u-ca-japanese-x-lvariant-JP"
   *    Locale.forLanguageTag("th-TH-x-lvariant-TH").toLanguageTag();
   *    // returns "th-TH-u-nu-thai-x-lvariant-TH"
   * 
   *
   * This implements the 'Language-Tag' production of BCP47, and
   * so supports grandfathered (regular and irregular) as well as
   * private use language tags.  Stand alone private use tags are
   * represented as empty language and extension 'x-whatever',
   * and grandfathered tags are converted to their canonical replacements
   * where they exist.
   *
   * Grandfathered tags with canonical replacements are as follows:
   *
   * 
   * Grandfathered tags with canonical replacements
   * 
   * grandfathered tagmodern replacement
   * 
   * 
   * art-lojbanjbo
   * i-amiami
   * i-bnnbnn
   * i-hakhak
   * i-klingontlh
   * i-luxlb
   * i-navajonv
   * i-pwnpwn
   * i-taotao
   * i-taytay
   * i-tsutsu
   * no-boknb
   * no-nynnn
   * sgn-BE-FRsfb
   * sgn-BE-NLvgt
   * sgn-CH-DEsgg
   * zh-guoyucmn
   * zh-hakkahak
   * zh-min-nannan
   * zh-xianghsn
   * 
   * 
   *
   * Grandfathered tags with no modern replacement will be
   * converted as follows:
   *
   * 
   * Grandfathered tags with no modern replacement
   * 
   * grandfathered tagconverts to
   * 
   * 
   * cel-gaulishxtg-x-cel-gaulish
   * en-GB-oeden-GB-x-oed
   * i-defaulten-x-i-default
   * i-enochianund-x-i-enochian
   * i-mingosee-x-i-mingo
   * zh-minnan-x-zh-min
   * 
   * 
   *
   * For a list of all grandfathered tags, see the
   * IANA Language Subtag Registry (search for "Type: grandfathered").
   *
   * Note: there is no guarantee that `toLanguageTag`
   * and `forLanguageTag` will round-trip.
   *
   * @param languageTag the language tag
   * @return The locale that best represents the language tag.
   * @throws NullPointerException if `languageTag` is `null`
   * @see #toLanguageTag()
   * @see java.util.Locale.Builder#setLanguageTag(String)
   * @since 1.7
  */
  static forLanguageTag(languageTag: string): Locale;
  /**
   * Returns a three-letter abbreviation of this locale's language.
   * If the language matches an ISO 639-1 two-letter code, the
   * corresponding ISO 639-2/T three-letter lowercase code is
   * returned.  The ISO 639-2 language codes can be found on-line,
   * see "Codes for the Representation of Names of Languages Part 2:
   * Alpha-3 Code".  If the locale specifies a three-letter
   * language, the language is returned as is.  If the locale does
   * not specify a language the empty string is returned.
   *
   * @return A three-letter abbreviation of this locale's language.
   * @throws    MissingResourceException Throws MissingResourceException if
   * three-letter language abbreviation is not available for this locale.
  */
  getISO3Language(): string;
  /**
   * Returns a three-letter abbreviation for this locale's country.
   * If the country matches an ISO 3166-1 alpha-2 code, the
   * corresponding ISO 3166-1 alpha-3 uppercase code is returned.
   * If the locale doesn't specify a country, this will be the empty
   * string.
   *
   * The ISO 3166-1 codes can be found on-line.
   *
   * @return A three-letter abbreviation of this locale's country.
   * @throws    MissingResourceException Throws MissingResourceException if the
   * three-letter country abbreviation is not available for this locale.
  */
  getISO3Country(): string;
  /**
   * Returns a name for the locale's language that is appropriate for display to the
   * user.
   * If possible, the name returned will be localized for the default
   * {@link Locale.Category#DISPLAY DISPLAY} locale.
   * For example, if the locale is fr_FR and the default
   * {@link Locale.Category#DISPLAY DISPLAY} locale
   * is en_US, getDisplayLanguage() will return "French"; if the locale is en_US and
   * the default {@link Locale.Category#DISPLAY DISPLAY} locale is fr_FR,
   * getDisplayLanguage() will return "anglais".
   * If the name returned cannot be localized for the default
   * {@link Locale.Category#DISPLAY DISPLAY} locale,
   * (say, we don't have a Japanese name for Croatian),
   * this function falls back on the English name, and uses the ISO code as a last-resort
   * value.  If the locale doesn't specify a language, this function returns the empty string.
   *
   * @return The name of the display language.
  */
  getDisplayLanguage(): string;
  /**
   * Returns a name for the locale's language that is appropriate for display to the
   * user.
   * If possible, the name returned will be localized according to inLocale.
   * For example, if the locale is fr_FR and inLocale
   * is en_US, getDisplayLanguage() will return "French"; if the locale is en_US and
   * inLocale is fr_FR, getDisplayLanguage() will return "anglais".
   * If the name returned cannot be localized according to inLocale,
   * (say, we don't have a Japanese name for Croatian),
   * this function falls back on the English name, and finally
   * on the ISO code as a last-resort value.  If the locale doesn't specify a language,
   * this function returns the empty string.
   *
   * @param inLocale The locale for which to retrieve the display language.
   * @return The name of the display language appropriate to the given locale.
   * @throws    NullPointerException if `inLocale` is `null`
  */
  getDisplayLanguage(inLocale: Locale): string;
  /**
   * Returns a name for the locale's script that is appropriate for display to
   * the user. If possible, the name will be localized for the default
   * {@link Locale.Category#DISPLAY DISPLAY} locale.  Returns
   * the empty string if this locale doesn't specify a script code.
   *
   * @return the display name of the script code for the current default
   *     {@link Locale.Category#DISPLAY DISPLAY} locale
   * @since 1.7
  */
  getDisplayScript(): string;
  /**
   * Returns a name for the locale's script that is appropriate
   * for display to the user. If possible, the name will be
   * localized for the given locale. Returns the empty string if
   * this locale doesn't specify a script code.
   *
   * @param inLocale The locale for which to retrieve the display script.
   * @return the display name of the script code for the current default
   * {@link Locale.Category#DISPLAY DISPLAY} locale
   * @throws NullPointerException if `inLocale` is `null`
   * @since 1.7
  */
  getDisplayScript(inLocale: Locale): string;
  /**
   * Returns a name for the locale's country that is appropriate for display to the
   * user.
   * If possible, the name returned will be localized for the default
   * {@link Locale.Category#DISPLAY DISPLAY} locale.
   * For example, if the locale is fr_FR and the default
   * {@link Locale.Category#DISPLAY DISPLAY} locale
   * is en_US, getDisplayCountry() will return "France"; if the locale is en_US and
   * the default {@link Locale.Category#DISPLAY DISPLAY} locale is fr_FR,
   * getDisplayCountry() will return "Etats-Unis".
   * If the name returned cannot be localized for the default
   * {@link Locale.Category#DISPLAY DISPLAY} locale,
   * (say, we don't have a Japanese name for Croatia),
   * this function falls back on the English name, and uses the ISO code as a last-resort
   * value.  If the locale doesn't specify a country, this function returns the empty string.
   *
   * @return The name of the country appropriate to the locale.
  */
  getDisplayCountry(): string;
  /**
   * Returns a name for the locale's country that is appropriate for display to the
   * user.
   * If possible, the name returned will be localized according to inLocale.
   * For example, if the locale is fr_FR and inLocale
   * is en_US, getDisplayCountry() will return "France"; if the locale is en_US and
   * inLocale is fr_FR, getDisplayCountry() will return "Etats-Unis".
   * If the name returned cannot be localized according to inLocale.
   * (say, we don't have a Japanese name for Croatia),
   * this function falls back on the English name, and finally
   * on the ISO code as a last-resort value.  If the locale doesn't specify a country,
   * this function returns the empty string.
   *
   * @param inLocale The locale for which to retrieve the display country.
   * @return The name of the country appropriate to the given locale.
   * @throws    NullPointerException if `inLocale` is `null`
  */
  getDisplayCountry(inLocale: Locale): string;
  /**
   * Returns a name for the locale's variant code that is appropriate for display to the
   * user.  If possible, the name will be localized for the default
   * {@link Locale.Category#DISPLAY DISPLAY} locale.  If the locale
   * doesn't specify a variant code, this function returns the empty string.
   *
   * @return The name of the display variant code appropriate to the locale.
  */
  getDisplayVariant(): string;
  /**
   * Returns a name for the locale's variant code that is appropriate for display to the
   * user.  If possible, the name will be localized for inLocale.  If the locale
   * doesn't specify a variant code, this function returns the empty string.
   *
   * @param inLocale The locale for which to retrieve the display variant code.
   * @return The name of the display variant code appropriate to the given locale.
   * @throws    NullPointerException if `inLocale` is `null`
  */
  getDisplayVariant(inLocale: Locale): string;
  /**
   * Returns a name for the locale that is appropriate for display to the
   * user. This will be the values returned by getDisplayLanguage(),
   * getDisplayScript(), getDisplayCountry(), getDisplayVariant() and
   * optional Unicode extensions
   * assembled into a single string. The non-empty values are used in order, with
   * the second and subsequent names in parentheses.  For example:
   * 
   * language (script, country, variant(, extension)*)
   * language (country(, extension)*)
   * language (variant(, extension)*)
   * script (country(, extension)*)
   * country (extension)*
   * 
   * depending on which fields are specified in the locale. The field
   * separator in the above parentheses, denoted as a comma character, may
   * be localized depending on the locale. If the language, script, country,
   * and variant fields are all empty, this function returns the empty string.
   *
   * @return The name of the locale appropriate to display.
  */
  getDisplayName(): string;
  /**
   * Returns a name for the locale that is appropriate for display
   * to the user.  This will be the values returned by
   * getDisplayLanguage(), getDisplayScript(),getDisplayCountry()
   * getDisplayVariant(), and optional 
   * Unicode extensions assembled into a single string. The non-empty
   * values are used in order, with the second and subsequent names in
   * parentheses.  For example:
   * 
   * language (script, country, variant(, extension)*)
   * language (country(, extension)*)
   * language (variant(, extension)*)
   * script (country(, extension)*)
   * country (extension)*
   * 
   * depending on which fields are specified in the locale. The field
   * separator in the above parentheses, denoted as a comma character, may
   * be localized depending on the locale. If the language, script, country,
   * and variant fields are all empty, this function returns the empty string.
   *
   * @param inLocale The locale for which to retrieve the display name.
   * @return The name of the locale appropriate to display.
   * @throws NullPointerException if `inLocale` is `null`
  */
  getDisplayName(inLocale: Locale): string;
  /**
   * Overrides Cloneable.
  */
  clone(): any;
  /**
   * Override hashCode.
   * Since Locales are often used in hashtables, caches the value
   * for speed.
  */
  hashCode(): number;
  /**
   * Returns true if this Locale is equal to another object.  A Locale is
   * deemed equal to another Locale with identical language, script, country,
   * variant and extensions, and unequal to all other objects.
   *
   * @return true if this Locale is equal to the specified object.
  */
  equals(obj: any): boolean;
  /**
   * Returns a list of matching `Locale` instances using the filtering
   * mechanism defined in RFC 4647.
   *
   * This filter operation on the given `locales` ensures that only
   * unique matching locale(s) are returned.
   *
   * @param priorityList user's Language Priority List in which each language
   *     tag is sorted in descending order based on priority or weight
   * @param locales `Locale` instances used for matching
   * @param mode filtering mode
   * @return a list of `Locale` instances for matching language tags
   *     sorted in descending order based on priority or weight, or an empty
   *     list if nothing matches. The list is modifiable.
   * @throws NullPointerException if `priorityList` or `locales`
   *     is `null`
   * @throws IllegalArgumentException if one or more extended language ranges
   *     are included in the given list when
   *     {@link FilteringMode#REJECT_EXTENDED_RANGES} is specified
   *
   * @since 1.8
  */
  static filter(priorityList: LanguageRange[], locales: Collection<Locale>, mode: FilteringMode): Locale[];
  /**
   * Returns a list of matching `Locale` instances using the filtering
   * mechanism defined in RFC 4647. This is equivalent to
   * {@link #filter(List, Collection, FilteringMode)} when `mode` is
   * {@link FilteringMode#AUTOSELECT_FILTERING}.
   *
   * This filter operation on the given `locales` ensures that only
   * unique matching locale(s) are returned.
   *
   * @param priorityList user's Language Priority List in which each language
   *     tag is sorted in descending order based on priority or weight
   * @param locales `Locale` instances used for matching
   * @return a list of `Locale` instances for matching language tags
   *     sorted in descending order based on priority or weight, or an empty
   *     list if nothing matches. The list is modifiable.
   * @throws NullPointerException if `priorityList` or `locales`
   *     is `null`
   *
   * @since 1.8
  */
  static filter(priorityList: LanguageRange[], locales: Collection<Locale>): Locale[];
  /**
   * Returns a list of matching languages tags using the basic filtering
   * mechanism defined in RFC 4647.
   *
   * This filter operation on the given `tags` ensures that only
   * unique matching tag(s) are returned with preserved case. In case of
   * duplicate matching tags with the case difference, the first matching
   * tag with preserved case is returned.
   * For example, "de-ch" is returned out of the duplicate matching tags
   * "de-ch" and "de-CH", if "de-ch" is checked first for matching in the
   * given `tags`. Note that if the given `tags` is an unordered
   * `Collection`, the returned matching tag out of duplicate tags is
   * subject to change, depending on the implementation of the
   * `Collection`.
   *
   * @param priorityList user's Language Priority List in which each language
   *     tag is sorted in descending order based on priority or weight
   * @param tags language tags
   * @param mode filtering mode
   * @return a list of matching language tags sorted in descending order
   *     based on priority or weight, or an empty list if nothing matches.
   *     The list is modifiable.
   * @throws NullPointerException if `priorityList` or `tags` is
   *     `null`
   * @throws IllegalArgumentException if one or more extended language ranges
   *     are included in the given list when
   *     {@link FilteringMode#REJECT_EXTENDED_RANGES} is specified
   *
   * @since 1.8
  */
  static filterTags(priorityList: LanguageRange[], tags: Collection<string>, mode: FilteringMode): string[];
  /**
   * Returns a list of matching languages tags using the basic filtering
   * mechanism defined in RFC 4647. This is equivalent to
   * {@link #filterTags(List, Collection, FilteringMode)} when `mode`
   * is {@link FilteringMode#AUTOSELECT_FILTERING}.
   *
   * This filter operation on the given `tags` ensures that only
   * unique matching tag(s) are returned with preserved case. In case of
   * duplicate matching tags with the case difference, the first matching
   * tag with preserved case is returned.
   * For example, "de-ch" is returned out of the duplicate matching tags
   * "de-ch" and "de-CH", if "de-ch" is checked first for matching in the
   * given `tags`. Note that if the given `tags` is an unordered
   * `Collection`, the returned matching tag out of duplicate tags is
   * subject to change, depending on the implementation of the
   * `Collection`.
   *
   * @param priorityList user's Language Priority List in which each language
   *     tag is sorted in descending order based on priority or weight
   * @param tags language tags
   * @return a list of matching language tags sorted in descending order
   *     based on priority or weight, or an empty list if nothing matches.
   *     The list is modifiable.
   * @throws NullPointerException if `priorityList` or `tags` is
   *     `null`
   *
   * @since 1.8
  */
  static filterTags(priorityList: LanguageRange[], tags: Collection<string>): string[];
  /**
   * Returns a `Locale` instance for the best-matching language
   * tag using the lookup mechanism defined in RFC 4647.
   *
   * @param priorityList user's Language Priority List in which each language
   *     tag is sorted in descending order based on priority or weight
   * @param locales `Locale` instances used for matching
   * @return the best matching `Locale` instance chosen based on
   *     priority or weight, or `null` if nothing matches.
   * @throws NullPointerException if `priorityList` or `tags` is
   *     `null`
   *
   * @since 1.8
  */
  static lookup(priorityList: LanguageRange[], locales: Collection<Locale>): Locale;
  /**
   * Returns the best-matching language tag using the lookup mechanism
   * defined in RFC 4647.
   *
   * This lookup operation on the given `tags` ensures that the
   * first matching tag with preserved case is returned.
   *
   * @param priorityList user's Language Priority List in which each language
   *     tag is sorted in descending order based on priority or weight
   * @param tags language tangs used for matching
   * @return the best matching language tag chosen based on priority or
   *     weight, or `null` if nothing matches.
   * @throws NullPointerException if `priorityList` or `tags` is
   *     `null`
   *
   * @since 1.8
  */
  static lookupTag(priorityList: LanguageRange[], tags: Collection<string>): string;
}
export interface Locale extends Cloneable, Serializable {}
/**
 * `TimeZone` represents a time zone offset, and also figures out daylight
 * savings.
 *
 * 
 * Typically, you get a `TimeZone` using `getDefault`
 * which creates a `TimeZone` based on the time zone where the program
 * is running. For example, for a program running in Japan, `getDefault`
 * creates a `TimeZone` object based on Japanese Standard Time.
 *
 * 
 * You can also get a `TimeZone` using `getTimeZone`
 * along with a time zone ID. For instance, the time zone ID for the
 * U.S. Pacific Time zone is "America/Los_Angeles". So, you can get a
 * U.S. Pacific Time `TimeZone` object with:
 *  * TimeZone tz = TimeZone.getTimeZone("America/Los_Angeles");
 * 
 * You can use the `getAvailableIDs` method to iterate through
 * all the supported time zone IDs. You can then choose a
 * supported ID to get a `TimeZone`.
 * If the time zone you want is not represented by one of the
 * supported IDs, then a custom time zone ID can be specified to
 * produce a TimeZone. The syntax of a custom time zone ID is:
 *
 *  * CustomID:
 *         `GMT` Sign Hours `:` Minutes
 *         `GMT` Sign Hours Minutes
 *         `GMT` Sign Hours
 * Sign: one of
 *         `+ -`
 * Hours:
 *         Digit
 *         Digit Digit
 * Minutes:
 *         Digit Digit
 * Digit: one of
 *         `0 1 2 3 4 5 6 7 8 9`
 * 
 *
 * Hours must be between 0 to 23 and Minutes must be
 * between 00 to 59.  For example, "GMT+10" and "GMT+0010" mean ten
 * hours and ten minutes ahead of GMT, respectively.
 * 
 * The format is locale independent and digits must be taken from the
 * Basic Latin block of the Unicode standard. No daylight saving time
 * transition schedule can be specified with a custom time zone ID. If
 * the specified string doesn't match the syntax, `"GMT"`
 * is used.
 * 
 * When creating a `TimeZone`, the specified custom time
 * zone ID is normalized in the following syntax:
 *  * NormalizedCustomID:
 *         `GMT` Sign TwoDigitHours `:` Minutes
 * Sign: one of
 *         `+ -`
 * TwoDigitHours:
 *         Digit Digit
 * Minutes:
 *         Digit Digit
 * Digit: one of
 *         `0 1 2 3 4 5 6 7 8 9`
 * 
 * For example, TimeZone.getTimeZone("GMT-8").getID() returns "GMT-08:00".
 *
 * Three-letter time zone IDs
 *
 * For compatibility with JDK 1.1.x, some other three-letter time zone IDs
 * (such as "PST", "CTT", "AST") are also supported. However, their
 * use is deprecated because the same abbreviation is often used
 * for multiple time zones (for example, "CST" could be U.S. "Central Standard
 * Time" and "China Standard Time"), and the Java platform can then only
 * recognize one of them.
 *
 *
 * @see          Calendar
 * @see          GregorianCalendar
 * @see          SimpleTimeZone
 * @author       Mark Davis, David Goldsmith, Chen-Lieh Huang, Alan Liu
 * @since        1.1
*/
export class TimeZone extends Serializable {
  /**
   * Sole constructor.  (For invocation by subclass constructors, typically
   * implicit.)
  */
  constructor();
  /**
   * A style specifier for `getDisplayName()` indicating
   * a short name, such as "PST."
   * @see #LONG
   * @since 1.2
  */
  static readonly SHORT: number;
  /**
   * A style specifier for `getDisplayName()` indicating
   * a long name, such as "Pacific Standard Time."
   * @see #SHORT
   * @since 1.2
  */
  static readonly LONG: number;
  /**
   * Gets the time zone offset, for current date, modified in case of
   * daylight savings. This is the offset to add to UTC to get local time.
   * 
   * This method returns a historically correct offset if an
   * underlying `TimeZone` implementation subclass
   * supports historical Daylight Saving Time schedule and GMT
   * offset changes.
   *
   * @param era the era of the given date.
   * @param year the year in the given date.
   * @param month the month in the given date.
   * Month is 0-based. e.g., 0 for January.
   * @param day the day-in-month of the given date.
   * @param dayOfWeek the day-of-week of the given date.
   * @param milliseconds the milliseconds in day in standard
   * local time.
   *
   * @return the offset in milliseconds to add to GMT to get local time.
   *
   * @see Calendar#ZONE_OFFSET
   * @see Calendar#DST_OFFSET
  */
  getOffset(era: number, year: number, month: number, day: number, dayOfWeek: number, milliseconds: number): number;
  /**
   * Returns the offset of this time zone from UTC at the specified
   * date. If Daylight Saving Time is in effect at the specified
   * date, the offset value is adjusted with the amount of daylight
   * saving.
   * 
   * This method returns a historically correct offset value if an
   * underlying TimeZone implementation subclass supports historical
   * Daylight Saving Time schedule and GMT offset changes.
   *
   * @param date the date represented in milliseconds since January 1, 1970 00:00:00 GMT
   * @return the amount of time in milliseconds to add to UTC to get local time.
   *
   * @see Calendar#ZONE_OFFSET
   * @see Calendar#DST_OFFSET
   * @since 1.4
  */
  getOffset(date: number): number;
  /**
   * Sets the base time zone offset to GMT.
   * This is the offset to add to UTC to get local time.
   * 
   * If an underlying `TimeZone` implementation subclass
   * supports historical GMT offset changes, the specified GMT
   * offset is set as the latest GMT offset and the difference from
   * the known latest GMT offset value is used to adjust all
   * historical GMT offset values.
   *
   * @param offsetMillis the given base time zone offset to GMT.
  */
  setRawOffset(rawOffset: number);
  /**
   * Returns the amount of time in milliseconds to add to UTC to get
   * standard time in this time zone. Because this value is not
   * affected by daylight saving time, it is called raw
   * offset.
   * 
   * If an underlying `TimeZone` implementation subclass
   * supports historical GMT offset changes, the method returns the
   * raw offset value of the current date. In Honolulu, for example,
   * its raw offset changed from GMT-10:30 to GMT-10:00 in 1947, and
   * this method always returns -36000000 milliseconds (i.e., -10
   * hours).
   *
   * @return the amount of raw offset time in milliseconds to add to UTC.
   * @see Calendar#ZONE_OFFSET
  */
  getRawOffset(): number;
  /**
   * Gets the ID of this time zone.
   * @return the ID of this time zone.
  */
  getID(): string;
  /**
   * Sets the time zone ID. This does not change any other data in
   * the time zone object.
   * @param ID the new time zone ID.
  */
  setID(iD: string);
  /**
   * Returns a long standard time name of this `TimeZone` suitable for
   * presentation to the user in the default locale.
   *
   * This method is equivalent to:
   *      * getDisplayName(false, {@link #LONG},
   *                Locale.getDefault({@link Locale.Category#DISPLAY}))
   * 
   *
   * @return the human-readable name of this time zone in the default locale.
   * @since 1.2
   * @see #getDisplayName(boolean, int, Locale)
   * @see Locale#getDefault(Locale.Category)
   * @see Locale.Category
  */
  getDisplayName(): string;
  /**
   * Returns a long standard time name of this `TimeZone` suitable for
   * presentation to the user in the specified `locale`.
   *
   * This method is equivalent to:
   *      * getDisplayName(false, {@link #LONG}, locale)
   * 
   *
   * @param locale the locale in which to supply the display name.
   * @return the human-readable name of this time zone in the given locale.
   * @throws    NullPointerException if `locale` is `null`.
   * @since 1.2
   * @see #getDisplayName(boolean, int, Locale)
  */
  getDisplayName(locale: Locale): string;
  /**
   * Returns a name in the specified `style` of this `TimeZone`
   * suitable for presentation to the user in the default locale. If the
   * specified `daylight` is `true`, a Daylight Saving Time name
   * is returned (even if this `TimeZone` doesn't observe Daylight Saving
   * Time). Otherwise, a Standard Time name is returned.
   *
   * This method is equivalent to:
   *      * getDisplayName(daylight, style,
   *                Locale.getDefault({@link Locale.Category#DISPLAY}))
   * 
   *
   * @param daylight `true` specifying a Daylight Saving Time name, or
   *                 `false` specifying a Standard Time name
   * @param style either {@link #LONG} or {@link #SHORT}
   * @return the human-readable name of this time zone in the default locale.
   * @throws    IllegalArgumentException if `style` is invalid.
   * @since 1.2
   * @see #getDisplayName(boolean, int, Locale)
   * @see Locale#getDefault(Locale.Category)
   * @see Locale.Category
   * @see java.text.DateFormatSymbols#getZoneStrings()
  */
  getDisplayName(daylight: boolean, style: number): string;
  /**
   * Returns a name in the specified `style` of this `TimeZone`
   * suitable for presentation to the user in the specified `     * locale`. If the specified `daylight` is `true`, a Daylight
   * Saving Time name is returned (even if this `TimeZone` doesn't
   * observe Daylight Saving Time). Otherwise, a Standard Time name is
   * returned.
   *
   * When looking up a time zone name, the {@linkplain
   * ResourceBundle.Control#getCandidateLocales(String,Locale) default
   * `Locale` search path of `ResourceBundle`} derived
   * from the specified `locale` is used. (No {@linkplain
   * ResourceBundle.Control#getFallbackLocale(String,Locale) fallback
   * `Locale`} search is performed.) If a time zone name in any
   * `Locale` of the search path, including {@link Locale#ROOT}, is
   * found, the name is returned. Otherwise, a string in the
   * normalized custom ID format is returned.
   *
   * @param daylight `true` specifying a Daylight Saving Time name, or
   *                 `false` specifying a Standard Time name
   * @param style either {@link #LONG} or {@link #SHORT}
   * @param locale   the locale in which to supply the display name.
   * @return the human-readable name of this time zone in the given locale.
   * @throws    IllegalArgumentException if `style` is invalid.
   * @throws    NullPointerException if `locale` is `null`.
   * @since 1.2
   * @see java.text.DateFormatSymbols#getZoneStrings()
  */
  getDisplayName(daylight: boolean, style: number, locale: Locale): string;
  /**
   * Returns the amount of time to be added to local standard time
   * to get local wall clock time.
   *
   * The default implementation returns 3600000 milliseconds
   * (i.e., one hour) if a call to {@link #useDaylightTime()}
   * returns `true`. Otherwise, 0 (zero) is returned.
   *
   * If an underlying `TimeZone` implementation subclass
   * supports historical and future Daylight Saving Time schedule
   * changes, this method returns the amount of saving time of the
   * last known Daylight Saving Time rule that can be a future
   * prediction.
   *
   * If the amount of saving time at any given time stamp is
   * required, construct a {@link Calendar} with this `     * TimeZone` and the time stamp, and call {@link Calendar#get(int)
   * Calendar.get}`(`{@link Calendar#DST_OFFSET}`)`.
   *
   * @return the amount of saving time in milliseconds
   * @since 1.4
   * @see #inDaylightTime(Date)
   * @see #getOffset(long)
   * @see #getOffset(int,int,int,int,int,int)
   * @see Calendar#ZONE_OFFSET
  */
  getDSTSavings(): number;
  /**
   * Queries if this `TimeZone` uses Daylight Saving Time.
   *
   * If an underlying `TimeZone` implementation subclass
   * supports historical and future Daylight Saving Time schedule
   * changes, this method refers to the last known Daylight Saving Time
   * rule that can be a future prediction and may not be the same as
   * the current rule. Consider calling {@link #observesDaylightTime()}
   * if the current rule should also be taken into account.
   *
   * @return `true` if this `TimeZone` uses Daylight Saving Time,
   *         `false`, otherwise.
   * @see #inDaylightTime(Date)
   * @see Calendar#DST_OFFSET
  */
  useDaylightTime(): boolean;
  /**
   * Returns `true` if this `TimeZone` is currently in
   * Daylight Saving Time, or if a transition from Standard Time to
   * Daylight Saving Time occurs at any future time.
   *
   * The default implementation returns `true` if
   * `useDaylightTime()` or `inDaylightTime(new Date())`
   * returns `true`.
   *
   * @return `true` if this `TimeZone` is currently in
   * Daylight Saving Time, or if a transition from Standard Time to
   * Daylight Saving Time occurs at any future time; `false`
   * otherwise.
   * @since 1.7
   * @see #useDaylightTime()
   * @see #inDaylightTime(Date)
   * @see Calendar#DST_OFFSET
  */
  observesDaylightTime(): boolean;
  /**
   * Queries if the given `date` is in Daylight Saving Time in
   * this time zone.
   *
   * @param date the given Date.
   * @return `true` if the given date is in Daylight Saving Time,
   *         `false`, otherwise.
  */
  inDaylightTime(date: Date): boolean;
  /**
   * Gets the `TimeZone` for the given ID.
   *
   * @param ID the ID for a `TimeZone`, either an abbreviation
   * such as "PST", a full name such as "America/Los_Angeles", or a custom
   * ID such as "GMT-8:00". Note that the support of abbreviations is
   * for JDK 1.1.x compatibility only and full names should be used.
   *
   * @return the specified `TimeZone`, or the GMT zone if the given ID
   * cannot be understood.
  */
  static getTimeZone(ID: string): TimeZone;
  /**
   * Gets the `TimeZone` for the given `zoneId`.
   *
   * @param zoneId a {@link ZoneId} from which the time zone ID is obtained
   * @return the specified `TimeZone`, or the GMT zone if the given ID
   *         cannot be understood.
   * @throws NullPointerException if `zoneId` is `null`
   * @since 1.8
  */
  static getTimeZone(zoneId: ZoneId): TimeZone;
  /**
   * Converts this `TimeZone` object to a `ZoneId`.
   *
   * @return a `ZoneId` representing the same time zone as this
   *         `TimeZone`
   * @since 1.8
  */
  toZoneId(): ZoneId;
  /**
   * Gets the available IDs according to the given time zone offset in milliseconds.
   *
   * @param rawOffset the given time zone GMT offset in milliseconds.
   * @return an array of IDs, where the time zone for that ID has
   * the specified GMT offset. For example, "America/Phoenix" and "America/Denver"
   * both have GMT-07:00, but differ in daylight saving behavior.
   * @see #getRawOffset()
  */
  static getAvailableIDs(rawOffset: number): string[];
  /**
   * Gets all the available IDs supported.
   * @return an array of IDs.
  */
  static getAvailableIDs(): string[];
  /**
   * Gets the default `TimeZone` of the Java virtual machine. If the
   * cached default `TimeZone` is available, its clone is returned.
   * Otherwise, the method takes the following steps to determine the default
   * time zone.
   *
   * 
   * Use the `user.timezone` property value as the default
   * time zone ID if it's available.
   * Detect the platform time zone ID. The source of the
   * platform time zone and ID mapping may vary with implementation.
   * Use `GMT` as the last resort if the given or detected
   * time zone ID is unknown.
   * 
   *
   * The default `TimeZone` created from the ID is cached,
   * and its clone is returned. The `user.timezone` property
   * value is set to the ID upon return.
   *
   * @return the default `TimeZone`
   * @see #setDefault(TimeZone)
  */
  static getDefault(): TimeZone;
  /**
   * Sets the `TimeZone` that is returned by the `getDefault`
   * method. `zone` is cached. If `zone` is null, the cached
   * default `TimeZone` is cleared. This method doesn't change the value
   * of the `user.timezone` property.
   *
   * @param zone the new default `TimeZone`, or null
   * @throws SecurityException if the security manager's `checkPermission`
   *                           denies {@code PropertyPermission("user.timezone",
   *                           "write")}
   * @see #getDefault
   * @see PropertyPermission
  */
  static setDefault(default_: TimeZone);
  /**
   * Returns true if this zone has the same rule and offset as another zone.
   * That is, if this zone differs only in ID, if at all.  Returns false
   * if the other zone is null.
   * @param other the `TimeZone` object to be compared with
   * @return true if the other zone is not null and is the same as this one,
   * with the possible exception of the ID
   * @since 1.2
  */
  hasSameRules(other: TimeZone): boolean;
  /**
   * Creates a copy of this `TimeZone`.
   *
   * @return a clone of this `TimeZone`
  */
  clone(): any;
}
export interface TimeZone extends Serializable, Cloneable {}
export class Collection<E> extends Iterable<E> {
  /**
   * Returns the number of elements in this collection.  If this collection
   * contains more than `Integer.MAX_VALUE` elements, returns
   * `Integer.MAX_VALUE`.
   *
   * @return the number of elements in this collection
  */
  size(): number;
  /**
   * Returns `true` if this collection contains no elements.
   *
   * @return `true` if this collection contains no elements
  */
  isEmpty(): boolean;
  /**
   * Returns `true` if this collection contains the specified element.
   * More formally, returns `true` if and only if this collection
   * contains at least one element `e` such that
   * `Objects.equals(o, e)`.
   *
   * @param o element whose presence in this collection is to be tested
   * @return `true` if this collection contains the specified
   *         element
   * @throws ClassCastException if the type of the specified element
   *         is incompatible with this collection
   *         (optional)
   * @throws NullPointerException if the specified element is null and this
   *         collection does not permit null elements
   *         (optional)
  */
  contains(o: any): boolean;
  /**
   * Returns an iterator over the elements in this collection.  There are no
   * guarantees concerning the order in which the elements are returned
   * (unless this collection is an instance of some class that provides a
   * guarantee).
   *
   * @return an `Iterator` over the elements in this collection
  */
  iterator(): Iterator<E>;
  /**
   * Returns an array containing all of the elements in this collection.
   * If this collection makes any guarantees as to what order its elements
   * are returned by its iterator, this method must return the elements in
   * the same order. The returned array's {@linkplain Class#getComponentType
   * runtime component type} is `Object`.
   *
   * The returned array will be "safe" in that no references to it are
   * maintained by this collection.  (In other words, this method must
   * allocate a new array even if this collection is backed by an array).
   * The caller is thus free to modify the returned array.
   *
   * @apiNote
   * This method acts as a bridge between array-based and collection-based APIs.
   * It returns an array whose runtime type is `Object[]`.
   * Use {@link #toArray(Object[]) toArray(T[])} to reuse an existing
   * array, or use {@link #toArray(IntFunction)} to control the runtime type
   * of the array.
   *
   * @return an array, whose {@linkplain Class#getComponentType runtime component
   * type} is `Object`, containing all of the elements in this collection
  */
  toArray(): any[];
  /**
   * Returns an array containing all of the elements in this collection;
   * the runtime type of the returned array is that of the specified array.
   * If the collection fits in the specified array, it is returned therein.
   * Otherwise, a new array is allocated with the runtime type of the
   * specified array and the size of this collection.
   *
   * If this collection fits in the specified array with room to spare
   * (i.e., the array has more elements than this collection), the element
   * in the array immediately following the end of the collection is set to
   * `null`.  (This is useful in determining the length of this
   * collection only if the caller knows that this collection does
   * not contain any `null` elements.)
   *
   * If this collection makes any guarantees as to what order its elements
   * are returned by its iterator, this method must return the elements in
   * the same order.
   *
   * @apiNote
   * This method acts as a bridge between array-based and collection-based APIs.
   * It allows an existing array to be reused under certain circumstances.
   * Use {@link #toArray()} to create an array whose runtime type is `Object[]`,
   * or use {@link #toArray(IntFunction)} to control the runtime type of
   * the array.
   *
   * Suppose `x` is a collection known to contain only strings.
   * The following code can be used to dump the collection into a previously
   * allocated `String` array:
   *
   *      *     String[] y = new String[SIZE];
   *     ...
   *     y = x.toArray(y);
   *
   * The return value is reassigned to the variable `y`, because a
   * new array will be allocated and returned if the collection `x` has
   * too many elements to fit into the existing array `y`.
   *
   * Note that `toArray(new Object[0])` is identical in function to
   * `toArray()`.
   *
   * @param  the component type of the array to contain the collection
   * @param a the array into which the elements of this collection are to be
   *        stored, if it is big enough; otherwise, a new array of the same
   *        runtime type is allocated for this purpose.
   * @return an array containing all of the elements in this collection
   * @throws ArrayStoreException if the runtime type of any element in this
   *         collection is not assignable to the {@linkplain Class#getComponentType
   *         runtime component type} of the specified array
   * @throws NullPointerException if the specified array is null
  */
  toArray<T>(a: T[]): T[];
  /**
   * Returns an array containing all of the elements in this collection,
   * using the provided `generator` function to allocate the returned array.
   *
   * If this collection makes any guarantees as to what order its elements
   * are returned by its iterator, this method must return the elements in
   * the same order.
   *
   * @apiNote
   * This method acts as a bridge between array-based and collection-based APIs.
   * It allows creation of an array of a particular runtime type. Use
   * {@link #toArray()} to create an array whose runtime type is `Object[]`,
   * or use {@link #toArray(Object[]) toArray(T[])} to reuse an existing array.
   *
   * Suppose `x` is a collection known to contain only strings.
   * The following code can be used to dump the collection into a newly
   * allocated array of `String`:
   *
   *      *     String[] y = x.toArray(String[]::new);
   *
   * @implSpec
   * The default implementation calls the generator function with zero
   * and then passes the resulting array to {@link #toArray(Object[]) toArray(T[])}.
   *
   * @param  the component type of the array to contain the collection
   * @param generator a function which produces a new array of the desired
   *                  type and the provided length
   * @return an array containing all of the elements in this collection
   * @throws ArrayStoreException if the runtime type of any element in this
   *         collection is not assignable to the {@linkplain Class#getComponentType
   *         runtime component type} of the generated array
   * @throws NullPointerException if the generator function is null
   * @since 11
  */
  toArray<T>(generator: IntFunction<T[]>): T[];
  /**
   * Ensures that this collection contains the specified element (optional
   * operation).  Returns `true` if this collection changed as a
   * result of the call.  (Returns `false` if this collection does
   * not permit duplicates and already contains the specified element.)
   *
   * Collections that support this operation may place limitations on what
   * elements may be added to this collection.  In particular, some
   * collections will refuse to add `null` elements, and others will
   * impose restrictions on the type of elements that may be added.
   * Collection classes should clearly specify in their documentation any
   * restrictions on what elements may be added.
   *
   * If a collection refuses to add a particular element for any reason
   * other than that it already contains the element, it must throw
   * an exception (rather than returning `false`).  This preserves
   * the invariant that a collection always contains the specified element
   * after this call returns.
   *
   * @param e element whose presence in this collection is to be ensured
   * @return `true` if this collection changed as a result of the
   *         call
   * @throws UnsupportedOperationException if the `add` operation
   *         is not supported by this collection
   * @throws ClassCastException if the class of the specified element
   *         prevents it from being added to this collection
   * @throws NullPointerException if the specified element is null and this
   *         collection does not permit null elements
   * @throws IllegalArgumentException if some property of the element
   *         prevents it from being added to this collection
   * @throws IllegalStateException if the element cannot be added at this
   *         time due to insertion restrictions
  */
  add(e: E): boolean;
  /**
   * Removes a single instance of the specified element from this
   * collection, if it is present (optional operation).  More formally,
   * removes an element `e` such that
   * `Objects.equals(o, e)`, if
   * this collection contains one or more such elements.  Returns
   * `true` if this collection contained the specified element (or
   * equivalently, if this collection changed as a result of the call).
   *
   * @param o element to be removed from this collection, if present
   * @return `true` if an element was removed as a result of this call
   * @throws ClassCastException if the type of the specified element
   *         is incompatible with this collection
   *         (optional)
   * @throws NullPointerException if the specified element is null and this
   *         collection does not permit null elements
   *         (optional)
   * @throws UnsupportedOperationException if the `remove` operation
   *         is not supported by this collection
  */
  remove(o: any): boolean;
  /**
   * Returns `true` if this collection contains all of the elements
   * in the specified collection.
   *
   * @param  c collection to be checked for containment in this collection
   * @return `true` if this collection contains all of the elements
   *         in the specified collection
   * @throws ClassCastException if the types of one or more elements
   *         in the specified collection are incompatible with this
   *         collection
   *         (optional)
   * @throws NullPointerException if the specified collection contains one
   *         or more null elements and this collection does not permit null
   *         elements
   *         (optional),
   *         or if the specified collection is null.
   * @see    #contains(Object)
  */
  containsAll(c: Collection<any>): boolean;
  /**
   * Adds all of the elements in the specified collection to this collection
   * (optional operation).  The behavior of this operation is undefined if
   * the specified collection is modified while the operation is in progress.
   * (This implies that the behavior of this call is undefined if the
   * specified collection is this collection, and this collection is
   * nonempty.)
   *
   * @param c collection containing elements to be added to this collection
   * @return `true` if this collection changed as a result of the call
   * @throws UnsupportedOperationException if the `addAll` operation
   *         is not supported by this collection
   * @throws ClassCastException if the class of an element of the specified
   *         collection prevents it from being added to this collection
   * @throws NullPointerException if the specified collection contains a
   *         null element and this collection does not permit null elements,
   *         or if the specified collection is null
   * @throws IllegalArgumentException if some property of an element of the
   *         specified collection prevents it from being added to this
   *         collection
   * @throws IllegalStateException if not all the elements can be added at
   *         this time due to insertion restrictions
   * @see #add(Object)
  */
  addAll(c: Collection<E>): boolean;
  /**
   * Removes all of this collection's elements that are also contained in the
   * specified collection (optional operation).  After this call returns,
   * this collection will contain no elements in common with the specified
   * collection.
   *
   * @param c collection containing elements to be removed from this collection
   * @return `true` if this collection changed as a result of the
   *         call
   * @throws UnsupportedOperationException if the `removeAll` method
   *         is not supported by this collection
   * @throws ClassCastException if the types of one or more elements
   *         in this collection are incompatible with the specified
   *         collection
   *         (optional)
   * @throws NullPointerException if this collection contains one or more
   *         null elements and the specified collection does not support
   *         null elements
   *         (optional),
   *         or if the specified collection is null
   * @see #remove(Object)
   * @see #contains(Object)
  */
  removeAll(c: Collection<any>): boolean;
  /**
   * Removes all of the elements of this collection that satisfy the given
   * predicate.  Errors or runtime exceptions thrown during iteration or by
   * the predicate are relayed to the caller.
   *
   * @implSpec
   * The default implementation traverses all elements of the collection using
   * its {@link #iterator}.  Each matching element is removed using
   * {@link Iterator#remove()}.  If the collection's iterator does not
   * support removal then an `UnsupportedOperationException` will be
   * thrown on the first matching element.
   *
   * @param filter a predicate which returns `true` for elements to be
   *        removed
   * @return `true` if any elements were removed
   * @throws NullPointerException if the specified filter is null
   * @throws UnsupportedOperationException if elements cannot be removed
   *         from this collection.  Implementations may throw this exception if a
   *         matching element cannot be removed or if, in general, removal is not
   *         supported.
   * @since 1.8
  */
  removeIf(filter: Predicate<any>): boolean;
  /**
   * Retains only the elements in this collection that are contained in the
   * specified collection (optional operation).  In other words, removes from
   * this collection all of its elements that are not contained in the
   * specified collection.
   *
   * @param c collection containing elements to be retained in this collection
   * @return `true` if this collection changed as a result of the call
   * @throws UnsupportedOperationException if the `retainAll` operation
   *         is not supported by this collection
   * @throws ClassCastException if the types of one or more elements
   *         in this collection are incompatible with the specified
   *         collection
   *         (optional)
   * @throws NullPointerException if this collection contains one or more
   *         null elements and the specified collection does not permit null
   *         elements
   *         (optional),
   *         or if the specified collection is null
   * @see #remove(Object)
   * @see #contains(Object)
  */
  retainAll(c: Collection<any>): boolean;
  /**
   * Removes all of the elements from this collection (optional operation).
   * The collection will be empty after this method returns.
   *
   * @throws UnsupportedOperationException if the `clear` operation
   *         is not supported by this collection
  */
  clear(): void;
  /**
   * Compares the specified object with this collection for equality. 
   *
   * While the `Collection` interface adds no stipulations to the
   * general contract for the `Object.equals`, programmers who
   * implement the `Collection` interface "directly" (in other words,
   * create a class that is a `Collection` but is not a `Set`
   * or a `List`) must exercise care if they choose to override the
   * `Object.equals`.  It is not necessary to do so, and the simplest
   * course of action is to rely on `Object`'s implementation, but
   * the implementor may wish to implement a "value comparison" in place of
   * the default "reference comparison."  (The `List` and
   * `Set` interfaces mandate such value comparisons.)
   *
   * The general contract for the `Object.equals` method states that
   * equals must be symmetric (in other words, `a.equals(b)` if and
   * only if `b.equals(a)`).  The contracts for `List.equals`
   * and `Set.equals` state that lists are only equal to other lists,
   * and sets to other sets.  Thus, a custom `equals` method for a
   * collection class that implements neither the `List` nor
   * `Set` interface must return `false` when this collection
   * is compared to any list or set.  (By the same logic, it is not possible
   * to write a class that correctly implements both the `Set` and
   * `List` interfaces.)
   *
   * @param o object to be compared for equality with this collection
   * @return `true` if the specified object is equal to this
   * collection
   *
   * @see Object#equals(Object)
   * @see Set#equals(Object)
   * @see List#equals(Object)
  */
  equals(o: any): boolean;
  /**
   * Returns the hash code value for this collection.  While the
   * `Collection` interface adds no stipulations to the general
   * contract for the `Object.hashCode` method, programmers should
   * take note that any class that overrides the `Object.equals`
   * method must also override the `Object.hashCode` method in order
   * to satisfy the general contract for the `Object.hashCode` method.
   * In particular, `c1.equals(c2)` implies that
   * `c1.hashCode()==c2.hashCode()`.
   *
   * @return the hash code value for this collection
   *
   * @see Object#hashCode()
   * @see Object#equals(Object)
  */
  hashCode(): number;
  /**
   * Creates a {@link Spliterator} over the elements in this collection.
   *
   * Implementations should document characteristic values reported by the
   * spliterator.  Such characteristic values are not required to be reported
   * if the spliterator reports {@link Spliterator#SIZED} and this collection
   * contains no elements.
   *
   * The default implementation should be overridden by subclasses that
   * can return a more efficient spliterator.  In order to
   * preserve expected laziness behavior for the {@link #stream()} and
   * {@link #parallelStream()} methods, spliterators should either have the
   * characteristic of `IMMUTABLE` or `CONCURRENT`, or be
   * late-binding.
   * If none of these is practical, the overriding class should describe the
   * spliterator's documented policy of binding and structural interference,
   * and should override the {@link #stream()} and {@link #parallelStream()}
   * methods to create streams using a `Supplier` of the spliterator,
   * as in:
   * {@code
   *     Stream s = StreamSupport.stream(() -> spliterator(), spliteratorCharacteristics)
   * }
   * These requirements ensure that streams produced by the
   * {@link #stream()} and {@link #parallelStream()} methods will reflect the
   * contents of the collection as of initiation of the terminal stream
   * operation.
   *
   * @implSpec
   * The default implementation creates a
   * late-binding spliterator
   * from the collection's `Iterator`.  The spliterator inherits the
   * fail-fast properties of the collection's iterator.
   * 
   * The created `Spliterator` reports {@link Spliterator#SIZED}.
   *
   * @implNote
   * The created `Spliterator` additionally reports
   * {@link Spliterator#SUBSIZED}.
   *
   * If a spliterator covers no elements then the reporting of additional
   * characteristic values, beyond that of `SIZED` and `SUBSIZED`,
   * does not aid clients to control, specialize or simplify computation.
   * However, this does enable shared use of an immutable and empty
   * spliterator instance (see {@link Spliterators#emptySpliterator()}) for
   * empty collections, and enables clients to determine if such a spliterator
   * covers no elements.
   *
   * @return a `Spliterator` over the elements in this collection
   * @since 1.8
  */
  spliterator(): Spliterator<E>;
  /**
   * Returns a sequential `Stream` with this collection as its source.
   *
   * This method should be overridden when the {@link #spliterator()}
   * method cannot return a spliterator that is `IMMUTABLE`,
   * `CONCURRENT`, or late-binding. (See {@link #spliterator()}
   * for details.)
   *
   * @implSpec
   * The default implementation creates a sequential `Stream` from the
   * collection's `Spliterator`.
   *
   * @return a sequential `Stream` over the elements in this collection
   * @since 1.8
  */
  stream(): Stream<E>;
  /**
   * Returns a possibly parallel `Stream` with this collection as its
   * source.  It is allowable for this method to return a sequential stream.
   *
   * This method should be overridden when the {@link #spliterator()}
   * method cannot return a spliterator that is `IMMUTABLE`,
   * `CONCURRENT`, or late-binding. (See {@link #spliterator()}
   * for details.)
   *
   * @implSpec
   * The default implementation creates a parallel `Stream` from the
   * collection's `Spliterator`.
   *
   * @return a possibly parallel `Stream` over the elements in this
   * collection
   * @since 1.8
  */
  parallelStream(): Stream<E>;
}
export class ServiceLoader<S> extends Iterable<S> {
  /**
   * Returns an iterator to lazily load and instantiate the available
   * providers of this loader's service.
   *
   *  To achieve laziness the actual work of locating and instantiating
   * providers is done by the iterator itself. Its {@link Iterator#hasNext
   * hasNext} and {@link Iterator#next next} methods can therefore throw a
   * {@link ServiceConfigurationError} for any of the reasons specified in
   * the Errors section above. To write robust code it
   * is only necessary to catch `ServiceConfigurationError` when using
   * the iterator. If an error is thrown then subsequent invocations of the
   * iterator will make a best effort to locate and instantiate the next
   * available provider, but in general such recovery cannot be guaranteed.
   *
   *  Caching: The iterator returned by this method first yields all of
   * the elements of the provider cache, in the order that they were loaded.
   * It then lazily loads and instantiates any remaining service providers,
   * adding each one to the cache in turn. If this loader's provider caches are
   * cleared by invoking the {@link #reload() reload} method then existing
   * iterators for this service loader should be discarded.
   * The ` hasNext` and `next` methods of the iterator throw {@link
   * java.util.ConcurrentModificationException ConcurrentModificationException}
   * if used after the provider cache has been cleared.
   *
   *  The iterator returned by this method does not support removal.
   * Invoking its {@link java.util.Iterator#remove() remove} method will
   * cause an {@link UnsupportedOperationException} to be thrown.
   *
   * @apiNote Throwing an error in these cases may seem extreme.  The rationale
   * for this behavior is that a malformed provider-configuration file, like a
   * malformed class file, indicates a serious problem with the way the Java
   * virtual machine is configured or is being used.  As such it is preferable
   * to throw an error rather than try to recover or, even worse, fail silently.
   *
   * @return  An iterator that lazily loads providers for this loader's
   *          service
   *
   * @revised 9
  */
  iterator(): Iterator<S>;
  /**
   * Returns a stream to lazily load available providers of this loader's
   * service. The stream elements are of type {@link Provider Provider}, the
   * `Provider`'s {@link Provider#get() get} method must be invoked to
   * get or instantiate the provider.
   *
   *  To achieve laziness the actual work of locating providers is done
   * when processing the stream. If a service provider cannot be loaded for any
   * of the reasons specified in the Errors section
   * above then {@link ServiceConfigurationError} is thrown by whatever method
   * caused the service provider to be loaded. 
   *
   *  Caching: When processing the stream then providers that were previously
   * loaded by stream operations are processed first, in load order. It then
   * lazily loads any remaining service providers. If this loader's provider
   * caches are cleared by invoking the {@link #reload() reload} method then
   * existing streams for this service loader should be discarded. The returned
   * stream's source {@link Spliterator spliterator} is fail-fast and
   * will throw {@link ConcurrentModificationException} if the provider cache
   * has been cleared. 
   *
   *  The following examples demonstrate usage. The first example creates
   * a stream of `CodecFactory` objects, the second example is the same
   * except that it sorts the providers by provider class name (and so locate
   * all providers).
   * {@code
   *    Stream providers = ServiceLoader.load(CodecFactory.class)
   *            .stream()
   *            .map(Provider::get);
   *
   *    Stream providers = ServiceLoader.load(CodecFactory.class)
   *            .stream()
   *            .sorted(Comparator.comparing(p -> p.type().getName()))
   *            .map(Provider::get);
   * }
   *
   * @return  A stream that lazily loads providers for this loader's service
   *
   * @since 9
  */
  stream(): Stream<Provider<S>>;
  /**
   * Creates a new service loader for the given service. The service loader
   * uses the given class loader as the starting point to locate service
   * providers for the service. The service loader's {@link #iterator()
   * iterator} and {@link #stream() stream} locate providers in both named
   * and unnamed modules, as follows:
   *
   * 
   *     Step 1: Locate providers in named modules. 
   *
   *    Service providers are located in all named modules of the class
   *   loader or to any class loader reachable via parent delegation. 
   *
   *    In addition, if the class loader is not the bootstrap or {@linkplain
   *   ClassLoader#getPlatformClassLoader() platform class loader}, then service
   *   providers may be located in the named modules of other class loaders.
   *   Specifically, if the class loader, or any class loader reachable via
   *   parent delegation, has a module in a {@linkplain ModuleLayer module
   *   layer}, then service providers in all modules in the module layer are
   *   located.  
   *
   *    For example, suppose there is a module layer where each module is
   *   in its own class loader (see {@link ModuleLayer#defineModulesWithManyLoaders
   *   defineModulesWithManyLoaders}). If this `ServiceLoader.load` method
   *   is invoked to locate providers using any of the class loaders created for
   *   the module layer, then it will locate all of the providers in the module
   *   layer, irrespective of their defining class loader. 
   *
   *    Ordering: The service loader will first locate any service providers
   *   in modules defined to the class loader, then its parent class loader,
   *   its parent parent, and so on to the bootstrap class loader. If a class
   *   loader has modules in a module layer then all providers in that module
   *   layer are located (irrespective of their class loader) before the
   *   providers in the parent class loader are located. The ordering of
   *   modules in same class loader, or the ordering of modules in a module
   *   layer, is not defined. 
   *
   *    If a module declares more than one provider then the providers
   *   are located in the order that its module descriptor {@linkplain
   *   java.lang.module.ModuleDescriptor.Provides#providers() lists the
   *   providers}. Providers added dynamically by instrumentation agents (see
   *   {@link java.lang.instrument.Instrumentation#redefineModule redefineModule})
   *   are always located after providers declared by the module.  
   *
   *     Step 2: Locate providers in unnamed modules. 
   *
   *    Service providers in unnamed modules are located if their class names
   *   are listed in provider-configuration files located by the class loader's
   *   {@link ClassLoader#getResources(String) getResources} method. 
   *
   *    The ordering is based on the order that the class loader's `     *   getResources` method finds the service configuration files and within
   *   that, the order that the class names are listed in the file. 
   *
   *    In a provider-configuration file, any mention of a service provider
   *   that is deployed in a named module is ignored. This is to avoid
   *   duplicates that would otherwise arise when a named module has both a
   *   provides directive and a provider-configuration file that mention
   *   the same service provider. 
   *
   *    The provider class must be visible to the class loader.  
   *
   * 
   *
   * @apiNote If the class path of the class loader includes remote network
   * URLs then those URLs may be dereferenced in the process of searching for
   * provider-configuration files.
   *
   *  This activity is normal, although it may cause puzzling entries to be
   * created in web-server logs.  If a web server is not configured correctly,
   * however, then this activity may cause the provider-loading algorithm to fail
   * spuriously.
   *
   *  A web server should return an HTTP 404 (Not Found) response when a
   * requested resource does not exist.  Sometimes, however, web servers are
   * erroneously configured to return an HTTP 200 (OK) response along with a
   * helpful HTML error page in such cases.  This will cause a {@link
   * ServiceConfigurationError} to be thrown when this class attempts to parse
   * the HTML page as a provider-configuration file.  The best solution to this
   * problem is to fix the misconfigured web server to return the correct
   * response code (HTTP 404) along with the HTML error page.
   *
   * @param   the class of the service type
   *
   * @param  service
   *         The interface or abstract class representing the service
   *
   * @param  loader
   *         The class loader to be used to load provider-configuration files
   *         and provider classes, or `null` if the system class
   *         loader (or, failing that, the bootstrap class loader) is to be
   *         used
   *
   * @return A new service loader
   *
   * @throws ServiceConfigurationError
   *         if the service type is not accessible to the caller or the
   *         caller is in an explicit module and its module descriptor does
   *         not declare that it uses `service`
   *
   * @revised 9
  */
  static load<S>(service: Class<S>, loader: ClassLoader): ServiceLoader<S>;
  /**
   * Creates a new service loader for the given service type, using the
   * current thread's {@linkplain java.lang.Thread#getContextClassLoader
   * context class loader}.
   *
   *  An invocation of this convenience method of the form
   * {@code
   *     ServiceLoader.load(service)
   * }
   *
   * is equivalent to
   *
   * {@code
   *     ServiceLoader.load(service, Thread.currentThread().getContextClassLoader())
   * }
   *
   * @apiNote Service loader objects obtained with this method should not be
   * cached VM-wide. For example, different applications in the same VM may
   * have different thread context class loaders. A lookup by one application
   * may locate a service provider that is only visible via its thread
   * context class loader and so is not suitable to be located by the other
   * application. Memory leaks can also arise. A thread local may be suited
   * to some applications.
   *
   * @param   the class of the service type
   *
   * @param  service
   *         The interface or abstract class representing the service
   *
   * @return A new service loader
   *
   * @throws ServiceConfigurationError
   *         if the service type is not accessible to the caller or the
   *         caller is in an explicit module and its module descriptor does
   *         not declare that it uses `service`
   *
   * @revised 9
  */
  static load<S>(service: Class<S>): ServiceLoader<S>;
  /**
   * Creates a new service loader for the given service type, using the
   * {@linkplain ClassLoader#getPlatformClassLoader() platform class loader}.
   *
   *  This convenience method is equivalent to: 
   *
   * {@code
   *     ServiceLoader.load(service, ClassLoader.getPlatformClassLoader())
   * }
   *
   *  This method is intended for use when only installed providers are
   * desired.  The resulting service will only find and load providers that
   * have been installed into the current Java virtual machine; providers on
   * the application's module path or class path will be ignored.
   *
   * @param   the class of the service type
   *
   * @param  service
   *         The interface or abstract class representing the service
   *
   * @return A new service loader
   *
   * @throws ServiceConfigurationError
   *         if the service type is not accessible to the caller or the
   *         caller is in an explicit module and its module descriptor does
   *         not declare that it uses `service`
   *
   * @revised 9
  */
  static loadInstalled<S>(service: Class<S>): ServiceLoader<S>;
  /**
   * Creates a new service loader for the given service type to load service
   * providers from modules in the given module layer and its ancestors. It
   * does not locate providers in unnamed modules. The ordering that the service
   * loader's {@link #iterator() iterator} and {@link #stream() stream} locate
   * providers and yield elements is as follows:
   *
   * 
   *    Providers are located in a module layer before locating providers
   *   in parent layers. Traversal of parent layers is depth-first with each
   *   layer visited at most once. For example, suppose L0 is the boot layer, L1
   *   and L2 are modules layers with L0 as their parent. Now suppose that L3 is
   *   created with L1 and L2 as the parents (in that order). Using a service
   *   loader to locate providers with L3 as the context will locate providers
   *   in the following order: L3, L1, L0, L2. 
   *
   *    If a module declares more than one provider then the providers
   *   are located in the order that its module descriptor
   *   {@linkplain java.lang.module.ModuleDescriptor.Provides#providers()
   *   lists the providers}. Providers added dynamically by instrumentation
   *   agents are always located after providers declared by the module. 
   *
   *    The ordering of modules in a module layer is not defined. 
   * 
   *
   * @apiNote Unlike the other load methods defined here, the service type
   * is the second parameter. The reason for this is to avoid source
   * compatibility issues for code that uses `load(S, null)`.
   *
   * @param   the class of the service type
   *
   * @param  layer
   *         The module layer
   *
   * @param  service
   *         The interface or abstract class representing the service
   *
   * @return A new service loader
   *
   * @throws ServiceConfigurationError
   *         if the service type is not accessible to the caller or the
   *         caller is in an explicit module and its module descriptor does
   *         not declare that it uses `service`
   *
   * @since 9
  */
  static load<S>(layer: ModuleLayer, service: Class<S>): ServiceLoader<S>;
  /**
   * Load the first available service provider of this loader's service. This
   * convenience method is equivalent to invoking the {@link #iterator()
   * iterator()} method and obtaining the first element. It therefore
   * returns the first element from the provider cache if possible, it
   * otherwise attempts to load and instantiate the first provider.
   *
   *  The following example loads the first available service provider. If
   * no service providers are located then it uses a default implementation.
   * {@code
   *    CodecFactory factory = ServiceLoader.load(CodecFactory.class)
   *                                        .findFirst()
   *                                        .orElse(DEFAULT_CODECSET_FACTORY);
   * }
   * @return The first service provider or empty `Optional` if no
   *         service providers are located
   *
   * @throws ServiceConfigurationError
   *         If a provider class cannot be loaded for any of the reasons
   *         specified in the Errors section above.
   *
   * @since 9
  */
  findFirst(): Optional<S>;
  /**
   * Clear this loader's provider cache so that all providers will be
   * reloaded.
   *
   *  After invoking this method, subsequent invocations of the {@link
   * #iterator() iterator} or {@link #stream() stream} methods will lazily
   * locate providers (and instantiate in the case of `iterator`)
   * from scratch, just as is done by a newly-created service loader.
   *
   *  This method is intended for use in situations in which new service
   * providers can be installed into a running Java virtual machine.
  */
  reload(): void;
  /**
   * Returns a string describing this service.
   *
   * @return  A descriptive string
  */
  toString(): string;
}
/**
 * A class that represents an immutable universally unique identifier (UUID).
 * A UUID represents a 128-bit value.
 *
 *  There exist different variants of these global identifiers.  The methods
 * of this class are for manipulating the Leach-Salz variant, although the
 * constructors allow the creation of any variant of UUID (described below).
 *
 *  The layout of a variant 2 (Leach-Salz) UUID is as follows:
 *
 * The most significant long consists of the following unsigned fields:
 *  * 0xFFFFFFFF00000000 time_low
 * 0x00000000FFFF0000 time_mid
 * 0x000000000000F000 version
 * 0x0000000000000FFF time_hi
 * 
 * The least significant long consists of the following unsigned fields:
 *  * 0xC000000000000000 variant
 * 0x3FFF000000000000 clock_seq
 * 0x0000FFFFFFFFFFFF node
 * 
 *
 *  The variant field contains a value which identifies the layout of the
 * `UUID`.  The bit layout described above is valid only for a ` * UUID` with a variant value of 2, which indicates the Leach-Salz variant.
 *
 *  The version field holds a value that describes the type of this ` * UUID`.  There are four different basic types of UUIDs: time-based, DCE
 * security, name-based, and randomly generated UUIDs.  These types have a
 * version value of 1, 2, 3 and 4, respectively.
 *
 *  For more information including algorithms used to create `UUID`s,
 * see  RFC 4122: A
 * Universally Unique IDentifier (UUID) URN Namespace, section 4.2
 * "Algorithms for Creating a Time-Based UUID".
 *
 * @since   1.5
*/
export class UUID extends Serializable {
  /**
   * Constructs a new `UUID` using the specified data.  `     * mostSigBits` is used for the most significant 64 bits of the `     * UUID` and `leastSigBits` becomes the least significant 64 bits of
   * the `UUID`.
   *
   * @param  mostSigBits
   *         The most significant bits of the `UUID`
   *
   * @param  leastSigBits
   *         The least significant bits of the `UUID`
  */
  constructor(mostSigBits: number, leastSigBits: number);
  /**
   * Static factory to retrieve a type 4 (pseudo randomly generated) UUID.
   *
   * The `UUID` is generated using a cryptographically strong pseudo
   * random number generator.
   *
   * @return  A randomly generated `UUID`
  */
  static randomUUID(): UUID;
  /**
   * Static factory to retrieve a type 3 (name based) `UUID` based on
   * the specified byte array.
   *
   * @param  name
   *         A byte array to be used to construct a `UUID`
   *
   * @return  A `UUID` generated from the specified array
  */
  static nameUUIDFromBytes(name: number[]): UUID;
  /**
   * Creates a `UUID` from the string standard representation as
   * described in the {@link #toString} method.
   *
   * @param  name
   *         A string that specifies a `UUID`
   *
   * @return  A `UUID` with the specified value
   *
   * @throws  IllegalArgumentException
   *          If name does not conform to the string representation as
   *          described in {@link #toString}
   *
  */
  static fromString(name: string): UUID;
  /**
   * Returns the least significant 64 bits of this UUID's 128 bit value.
   *
   * @return  The least significant 64 bits of this UUID's 128 bit value
  */
  getLeastSignificantBits(): number;
  /**
   * Returns the most significant 64 bits of this UUID's 128 bit value.
   *
   * @return  The most significant 64 bits of this UUID's 128 bit value
  */
  getMostSignificantBits(): number;
  /**
   * The version number associated with this `UUID`.  The version
   * number describes how this `UUID` was generated.
   *
   * The version number has the following meaning:
   * 
   * 1    Time-based UUID
   * 2    DCE security UUID
   * 3    Name-based UUID
   * 4    Randomly generated UUID
   * 
   *
   * @return  The version number of this `UUID`
  */
  version(): number;
  /**
   * The variant number associated with this `UUID`.  The variant
   * number describes the layout of the `UUID`.
   *
   * The variant number has the following meaning:
   * 
   * 0    Reserved for NCS backward compatibility
   * 2    IETF RFC 4122
   * (Leach-Salz), used by this class
   * 6    Reserved, Microsoft Corporation backward compatibility
   * 7    Reserved for future definition
   * 
   *
   * @return  The variant number of this `UUID`
  */
  variant(): number;
  /**
   * The timestamp value associated with this UUID.
   *
   *  The 60 bit timestamp value is constructed from the time_low,
   * time_mid, and time_hi fields of this `UUID`.  The resulting
   * timestamp is measured in 100-nanosecond units since midnight,
   * October 15, 1582 UTC.
   *
   *  The timestamp value is only meaningful in a time-based UUID, which
   * has version type 1.  If this `UUID` is not a time-based UUID then
   * this method throws UnsupportedOperationException.
   *
   * @throws UnsupportedOperationException
   *         If this UUID is not a version 1 UUID
   * @return The timestamp of this `UUID`.
  */
  timestamp(): number;
  /**
   * The clock sequence value associated with this UUID.
   *
   *  The 14 bit clock sequence value is constructed from the clock
   * sequence field of this UUID.  The clock sequence field is used to
   * guarantee temporal uniqueness in a time-based UUID.
   *
   *  The `clockSequence` value is only meaningful in a time-based
   * UUID, which has version type 1.  If this UUID is not a time-based UUID
   * then this method throws UnsupportedOperationException.
   *
   * @return  The clock sequence of this `UUID`
   *
   * @throws  UnsupportedOperationException
   *          If this UUID is not a version 1 UUID
  */
  clockSequence(): number;
  /**
   * The node value associated with this UUID.
   *
   *  The 48 bit node value is constructed from the node field of this
   * UUID.  This field is intended to hold the IEEE 802 address of the machine
   * that generated this UUID to guarantee spatial uniqueness.
   *
   *  The node value is only meaningful in a time-based UUID, which has
   * version type 1.  If this UUID is not a time-based UUID then this method
   * throws UnsupportedOperationException.
   *
   * @return  The node value of this `UUID`
   *
   * @throws  UnsupportedOperationException
   *          If this UUID is not a version 1 UUID
  */
  node(): number;
  /**
   * Returns a `String` object representing this `UUID`.
   *
   *  The UUID string representation is as described by this BNF:
   *      * {@code
   * UUID                   =  "-"  "-"
   *                           "-"
   *                           "-"
   *                          
   * time_low               = 4*
   * time_mid               = 2*
   * time_high_and_version  = 2*
   * variant_and_sequence   = 2*
   * node                   = 6*
   * hexOctet               = 
   * hexDigit               =
   *       "0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9"
   *       | "a" | "b" | "c" | "d" | "e" | "f"
   *       | "A" | "B" | "C" | "D" | "E" | "F"
   * }
   *
   * @return  A string representation of this `UUID`
  */
  toString(): string;
  /**
   * Returns a hash code for this `UUID`.
   *
   * @return  A hash code value for this `UUID`
  */
  hashCode(): number;
  /**
   * Compares this object to the specified object.  The result is `     * true` if and only if the argument is not `null`, is a `UUID`
   * object, has the same variant, and contains the same value, bit for bit,
   * as this `UUID`.
   *
   * @param  obj
   *         The object to be compared
   *
   * @return  `true` if the objects are the same; `false`
   *          otherwise
  */
  equals(obj: any): boolean;
  /**
   * Compares this UUID with the specified UUID.
   *
   *  The first of two UUIDs is greater than the second if the most
   * significant field in which the UUIDs differ is greater for the first
   * UUID.
   *
   * @param  val
   *         `UUID` to which this `UUID` is to be compared
   *
   * @return  -1, 0 or 1 as this `UUID` is less than, equal to, or
   *          greater than `val`
   *
  */
  compareTo(val: UUID): number;
  /**
   * Compares this object with the specified object for order.  Returns a
   * negative integer, zero, or a positive integer as this object is less
   * than, equal to, or greater than the specified object.
   *
   * The implementor must ensure
   * `sgn(x.compareTo(y)) == -sgn(y.compareTo(x))`
   * for all `x` and `y`.  (This
   * implies that `x.compareTo(y)` must throw an exception iff
   * `y.compareTo(x)` throws an exception.)
   *
   * The implementor must also ensure that the relation is transitive:
   * `(x.compareTo(y) > 0 && y.compareTo(z) > 0)` implies
   * `x.compareTo(z) > 0`.
   *
   * Finally, the implementor must ensure that `x.compareTo(y)==0`
   * implies that `sgn(x.compareTo(z)) == sgn(y.compareTo(z))`, for
   * all `z`.
   *
   * It is strongly recommended, but not strictly required that
   * `(x.compareTo(y)==0) == (x.equals(y))`.  Generally speaking, any
   * class that implements the `Comparable` interface and violates
   * this condition should clearly indicate this fact.  The recommended
   * language is "Note: this class has a natural ordering that is
   * inconsistent with equals."
   *
   * In the foregoing description, the notation
   * `sgn(`expression`)` designates the mathematical
   * signum function, which is defined to return one of `-1`,
   * `0`, or `1` according to whether the value of
   * expression is negative, zero, or positive, respectively.
   *
   * @param   o the object to be compared.
   * @return  a negative integer, zero, or a positive integer as this object
   *          is less than, equal to, or greater than the specified object.
   *
   * @throws NullPointerException if the specified object is null
   * @throws ClassCastException if the specified object's type prevents it
   *         from being compared to this object.
  */
  compareTo(o: T): number;
}
export interface UUID extends Serializable, Comparable<UUID> {}
/**
 * A collection designed for holding elements prior to processing.
 * Besides basic {@link Collection} operations, queues provide
 * additional insertion, extraction, and inspection operations.
 * Each of these methods exists in two forms: one throws an exception
 * if the operation fails, the other returns a special value (either
 * `null` or `false`, depending on the operation).  The
 * latter form of the insert operation is designed specifically for
 * use with capacity-restricted `Queue` implementations; in most
 * implementations, insert operations cannot fail.
 *
 * 
 * Summary of Queue methods
 *  
 *  
 *    
 *    Throws exception
 *    Returns special value
 *  
 *  
 *  
 *  
 *    Insert
 *    {@link #add(Object) add(e)}
 *    {@link #offer(Object) offer(e)}
 *  
 *  
 *    Remove
 *    {@link #remove() remove()}
 *    {@link #poll() poll()}
 *  
 *  
 *    Examine
 *    {@link #element() element()}
 *    {@link #peek() peek()}
 *  
 *  
 * 
 *
 * Queues typically, but do not necessarily, order elements in a
 * FIFO (first-in-first-out) manner.  Among the exceptions are
 * priority queues, which order elements according to a supplied
 * comparator, or the elements' natural ordering, and LIFO queues (or
 * stacks) which order the elements LIFO (last-in-first-out).
 * Whatever the ordering used, the head of the queue is that
 * element which would be removed by a call to {@link #remove()} or
 * {@link #poll()}.  In a FIFO queue, all new elements are inserted at
 * the tail of the queue. Other kinds of queues may use
 * different placement rules.  Every `Queue` implementation
 * must specify its ordering properties.
 *
 * The {@link #offer offer} method inserts an element if possible,
 * otherwise returning `false`.  This differs from the {@link
 * java.util.Collection#add Collection.add} method, which can fail to
 * add an element only by throwing an unchecked exception.  The
 * `offer` method is designed for use when failure is a normal,
 * rather than exceptional occurrence, for example, in fixed-capacity
 * (or "bounded") queues.
 *
 * The {@link #remove()} and {@link #poll()} methods remove and
 * return the head of the queue.
 * Exactly which element is removed from the queue is a
 * function of the queue's ordering policy, which differs from
 * implementation to implementation. The `remove()` and
 * `poll()` methods differ only in their behavior when the
 * queue is empty: the `remove()` method throws an exception,
 * while the `poll()` method returns `null`.
 *
 * The {@link #element()} and {@link #peek()} methods return, but do
 * not remove, the head of the queue.
 *
 * The `Queue` interface does not define the blocking queue
 * methods, which are common in concurrent programming.  These methods,
 * which wait for elements to appear or for space to become available, are
 * defined in the {@link java.util.concurrent.BlockingQueue} interface, which
 * extends this interface.
 *
 * `Queue` implementations generally do not allow insertion
 * of `null` elements, although some implementations, such as
 * {@link LinkedList}, do not prohibit insertion of `null`.
 * Even in the implementations that permit it, `null` should
 * not be inserted into a `Queue`, as `null` is also
 * used as a special return value by the `poll` method to
 * indicate that the queue contains no elements.
 *
 * `Queue` implementations generally do not define
 * element-based versions of methods `equals` and
 * `hashCode` but instead inherit the identity based versions
 * from class `Object`, because element-based equality is not
 * always well-defined for queues with the same elements but different
 * ordering properties.
 *
 * This interface is a member of the
 * 
 * Java Collections Framework.
 *
 * @since 1.5
 * @author Doug Lea
 * @param  the type of elements held in this queue
*/
export class Queue<E> extends Collection<E> {
  /**
   * Inserts the specified element into this queue if it is possible to do so
   * immediately without violating capacity restrictions, returning
   * `true` upon success and throwing an `IllegalStateException`
   * if no space is currently available.
   *
   * @param e the element to add
   * @return `true` (as specified by {@link Collection#add})
   * @throws IllegalStateException if the element cannot be added at this
   *         time due to capacity restrictions
   * @throws ClassCastException if the class of the specified element
   *         prevents it from being added to this queue
   * @throws NullPointerException if the specified element is null and
   *         this queue does not permit null elements
   * @throws IllegalArgumentException if some property of this element
   *         prevents it from being added to this queue
  */
  add(e: E): boolean;
  /**
   * Inserts the specified element into this queue if it is possible to do
   * so immediately without violating capacity restrictions.
   * When using a capacity-restricted queue, this method is generally
   * preferable to {@link #add}, which can fail to insert an element only
   * by throwing an exception.
   *
   * @param e the element to add
   * @return `true` if the element was added to this queue, else
   *         `false`
   * @throws ClassCastException if the class of the specified element
   *         prevents it from being added to this queue
   * @throws NullPointerException if the specified element is null and
   *         this queue does not permit null elements
   * @throws IllegalArgumentException if some property of this element
   *         prevents it from being added to this queue
  */
  offer(e: E): boolean;
  /**
   * Retrieves and removes the head of this queue.  This method differs
   * from {@link #poll() poll()} only in that it throws an exception if
   * this queue is empty.
   *
   * @return the head of this queue
   * @throws NoSuchElementException if this queue is empty
  */
  remove(): E;
  /**
   * Retrieves and removes the head of this queue,
   * or returns `null` if this queue is empty.
   *
   * @return the head of this queue, or `null` if this queue is empty
  */
  poll(): E;
  /**
   * Retrieves, but does not remove, the head of this queue.  This method
   * differs from {@link #peek peek} only in that it throws an exception
   * if this queue is empty.
   *
   * @return the head of this queue
   * @throws NoSuchElementException if this queue is empty
  */
  element(): E;
  /**
   * Retrieves, but does not remove, the head of this queue,
   * or returns `null` if this queue is empty.
   *
   * @return the head of this queue, or `null` if this queue is empty
  */
  peek(): E;
  /**
   * Removes a single instance of the specified element from this
   * collection, if it is present (optional operation).  More formally,
   * removes an element `e` such that
   * `Objects.equals(o, e)`, if
   * this collection contains one or more such elements.  Returns
   * `true` if this collection contained the specified element (or
   * equivalently, if this collection changed as a result of the call).
   *
   * @param o element to be removed from this collection, if present
   * @return `true` if an element was removed as a result of this call
   * @throws ClassCastException if the type of the specified element
   *         is incompatible with this collection
   *         (optional)
   * @throws NullPointerException if the specified element is null and this
   *         collection does not permit null elements
   *         (optional)
   * @throws UnsupportedOperationException if the `remove` operation
   *         is not supported by this collection
  */
  remove(o: any): boolean;
}
/**
 * An object for traversing and partitioning elements of a source.  The source
 * of elements covered by a Spliterator could be, for example, an array, a
 * {@link Collection}, an IO channel, or a generator function.
 *
 * A Spliterator may traverse elements individually ({@link
 * #tryAdvance tryAdvance()}) or sequentially in bulk
 * ({@link #forEachRemaining forEachRemaining()}).
 *
 * A Spliterator may also partition off some of its elements (using
 * {@link #trySplit}) as another Spliterator, to be used in
 * possibly-parallel operations.  Operations using a Spliterator that
 * cannot split, or does so in a highly imbalanced or inefficient
 * manner, are unlikely to benefit from parallelism.  Traversal
 * and splitting exhaust elements; each Spliterator is useful for only a single
 * bulk computation.
 *
 * A Spliterator also reports a set of {@link #characteristics()} of its
 * structure, source, and elements from among {@link #ORDERED},
 * {@link #DISTINCT}, {@link #SORTED}, {@link #SIZED}, {@link #NONNULL},
 * {@link #IMMUTABLE}, {@link #CONCURRENT}, and {@link #SUBSIZED}. These may
 * be employed by Spliterator clients to control, specialize or simplify
 * computation.  For example, a Spliterator for a {@link Collection} would
 * report `SIZED`, a Spliterator for a {@link Set} would report
 * `DISTINCT`, and a Spliterator for a {@link SortedSet} would also
 * report `SORTED`.  Characteristics are reported as a simple unioned bit
 * set.
 *
 * Some characteristics additionally constrain method behavior; for example if
 * `ORDERED`, traversal methods must conform to their documented ordering.
 * New characteristics may be defined in the future, so implementors should not
 * assign meanings to unlisted values.
 *
 * A Spliterator that does not report `IMMUTABLE` or
 * `CONCURRENT` is expected to have a documented policy concerning:
 * when the spliterator binds to the element source; and detection of
 * structural interference of the element source detected after binding.  A
 * late-binding Spliterator binds to the source of elements at the
 * point of first traversal, first split, or first query for estimated size,
 * rather than at the time the Spliterator is created.  A Spliterator that is
 * not late-binding binds to the source of elements at the point of
 * construction or first invocation of any method.  Modifications made to the
 * source prior to binding are reflected when the Spliterator is traversed.
 * After binding a Spliterator should, on a best-effort basis, throw
 * {@link ConcurrentModificationException} if structural interference is
 * detected.  Spliterators that do this are called fail-fast.  The
 * bulk traversal method ({@link #forEachRemaining forEachRemaining()}) of a
 * Spliterator may optimize traversal and check for structural interference
 * after all elements have been traversed, rather than checking per-element and
 * failing immediately.
 *
 * Spliterators can provide an estimate of the number of remaining elements
 * via the {@link #estimateSize} method.  Ideally, as reflected in characteristic
 * {@link #SIZED}, this value corresponds exactly to the number of elements
 * that would be encountered in a successful traversal.  However, even when not
 * exactly known, an estimated value may still be useful to operations
 * being performed on the source, such as helping to determine whether it is
 * preferable to split further or traverse the remaining elements sequentially.
 *
 * Despite their obvious utility in parallel algorithms, spliterators are not
 * expected to be thread-safe; instead, implementations of parallel algorithms
 * using spliterators should ensure that the spliterator is only used by one
 * thread at a time.  This is generally easy to attain via serial
 * thread-confinement, which often is a natural consequence of typical
 * parallel algorithms that work by recursive decomposition.  A thread calling
 * {@link #trySplit()} may hand over the returned Spliterator to another thread,
 * which in turn may traverse or further split that Spliterator.  The behaviour
 * of splitting and traversal is undefined if two or more threads operate
 * concurrently on the same spliterator.  If the original thread hands a
 * spliterator off to another thread for processing, it is best if that handoff
 * occurs before any elements are consumed with {@link #tryAdvance(Consumer)
 * tryAdvance()}, as certain guarantees (such as the accuracy of
 * {@link #estimateSize()} for `SIZED` spliterators) are only valid before
 * traversal has begun.
 *
 * Primitive subtype specializations of `Spliterator` are provided for
 * {@link OfInt int}, {@link OfLong long}, and {@link OfDouble double} values.
 * The subtype default implementations of
 * {@link Spliterator#tryAdvance(java.util.function.Consumer)}
 * and {@link Spliterator#forEachRemaining(java.util.function.Consumer)} box
 * primitive values to instances of their corresponding wrapper class.  Such
 * boxing may undermine any performance advantages gained by using the primitive
 * specializations.  To avoid boxing, the corresponding primitive-based methods
 * should be used.  For example,
 * {@link Spliterator.OfInt#tryAdvance(java.util.function.IntConsumer)}
 * and {@link Spliterator.OfInt#forEachRemaining(java.util.function.IntConsumer)}
 * should be used in preference to
 * {@link Spliterator.OfInt#tryAdvance(java.util.function.Consumer)} and
 * {@link Spliterator.OfInt#forEachRemaining(java.util.function.Consumer)}.
 * Traversal of primitive values using boxing-based methods
 * {@link #tryAdvance tryAdvance()} and
 * {@link #forEachRemaining(java.util.function.Consumer) forEachRemaining()}
 * does not affect the order in which the values, transformed to boxed values,
 * are encountered.
 *
 * @apiNote
 * Spliterators, like `Iterator`s, are for traversing the elements of
 * a source.  The `Spliterator` API was designed to support efficient
 * parallel traversal in addition to sequential traversal, by supporting
 * decomposition as well as single-element iteration.  In addition, the
 * protocol for accessing elements via a Spliterator is designed to impose
 * smaller per-element overhead than `Iterator`, and to avoid the inherent
 * race involved in having separate methods for `hasNext()` and
 * `next()`.
 *
 * For mutable sources, arbitrary and non-deterministic behavior may occur if
 * the source is structurally interfered with (elements added, replaced, or
 * removed) between the time that the Spliterator binds to its data source and
 * the end of traversal.  For example, such interference will produce arbitrary,
 * non-deterministic results when using the `java.util.stream` framework.
 *
 * Structural interference of a source can be managed in the following ways
 * (in approximate order of decreasing desirability):
 * 
 * The source cannot be structurally interfered with.
 * For example, an instance of
 * {@link java.util.concurrent.CopyOnWriteArrayList} is an immutable source.
 * A Spliterator created from the source reports a characteristic of
 * `IMMUTABLE`.
 * The source manages concurrent modifications.
 * For example, a key set of a {@link java.util.concurrent.ConcurrentHashMap}
 * is a concurrent source.  A Spliterator created from the source reports a
 * characteristic of `CONCURRENT`.
 * The mutable source provides a late-binding and fail-fast Spliterator.
 * Late binding narrows the window during which interference can affect
 * the calculation; fail-fast detects, on a best-effort basis, that structural
 * interference has occurred after traversal has commenced and throws
 * {@link ConcurrentModificationException}.  For example, {@link ArrayList},
 * and many other non-concurrent `Collection` classes in the JDK, provide
 * a late-binding, fail-fast spliterator.
 * The mutable source provides a non-late-binding but fail-fast Spliterator.
 * The source increases the likelihood of throwing
 * `ConcurrentModificationException` since the window of potential
 * interference is larger.
 * The mutable source provides a late-binding and non-fail-fast Spliterator.
 * The source risks arbitrary, non-deterministic behavior after traversal
 * has commenced since interference is not detected.
 * 
 * The mutable source provides a non-late-binding and non-fail-fast
 * Spliterator.
 * The source increases the risk of arbitrary, non-deterministic behavior
 * since non-detected interference may occur after construction.
 * 
 * 
 *
 * Example. Here is a class (not a very useful one, except
 * for illustration) that maintains an array in which the actual data
 * are held in even locations, and unrelated tag data are held in odd
 * locations. Its Spliterator ignores the tags.
 *
 *  {@code
 * class TaggedArray {
 *   private final Object[] elements; // immutable after construction
 *   TaggedArray(T[] data, Object[] tags) {
 *     int size = data.length;
 *     if (tags.length != size) throw new IllegalArgumentException();
 *     this.elements = new Object[2 * size];
 *     for (int i = 0, j = 0; i < size; ++i) {
 *       elements[j++] = data[i];
 *       elements[j++] = tags[i];
 *     }
 *   }
 *
 *   public Spliterator spliterator() {
 *     return new TaggedArraySpliterator<>(elements, 0, elements.length);
 *   }
 *
 *   static class TaggedArraySpliterator implements Spliterator {
 *     private final Object[] array;
 *     private int origin; // current index, advanced on split or traversal
 *     private final int fence; // one past the greatest index
 *
 *     TaggedArraySpliterator(Object[] array, int origin, int fence) {
 *       this.array = array; this.origin = origin; this.fence = fence;
 *     }
 *
 *     public void forEachRemaining(Consumer action) {
 *       for (; origin < fence; origin += 2)
 *         action.accept((T) array[origin]);
 *     }
 *
 *     public boolean tryAdvance(Consumer action) {
 *       if (origin < fence) {
 *         action.accept((T) array[origin]);
 *         origin += 2;
 *         return true;
 *       }
 *       else // cannot advance
 *         return false;
 *     }
 *
 *     public Spliterator trySplit() {
 *       int lo = origin; // divide range in half
 *       int mid = ((lo + fence) >>> 1) & ~1; // force midpoint to be even
 *       if (lo < mid) { // split out left half
 *         origin = mid; // reset this Spliterator's origin
 *         return new TaggedArraySpliterator<>(array, lo, mid);
 *       }
 *       else       // too small to split
 *         return null;
 *     }
 *
 *     public long estimateSize() {
 *       return (long)((fence - origin) / 2);
 *     }
 *
 *     public int characteristics() {
 *       return ORDERED | SIZED | IMMUTABLE | SUBSIZED;
 *     }
 *   }
 * }}
 *
 * As an example how a parallel computation framework, such as the
 * `java.util.stream` package, would use Spliterator in a parallel
 * computation, here is one way to implement an associated parallel forEach,
 * that illustrates the primary usage idiom of splitting off subtasks until
 * the estimated amount of work is small enough to perform
 * sequentially. Here we assume that the order of processing across
 * subtasks doesn't matter; different (forked) tasks may further split
 * and process elements concurrently in undetermined order.  This
 * example uses a {@link java.util.concurrent.CountedCompleter};
 * similar usages apply to other parallel task constructions.
 *
 * {@code
 * static  void parEach(TaggedArray a, Consumer action) {
 *   Spliterator s = a.spliterator();
 *   long targetBatchSize = s.estimateSize() / (ForkJoinPool.getCommonPoolParallelism() * 8);
 *   new ParEach(null, s, action, targetBatchSize).invoke();
 * }
 *
 * static class ParEach extends CountedCompleter {
 *   final Spliterator spliterator;
 *   final Consumer action;
 *   final long targetBatchSize;
 *
 *   ParEach(ParEach parent, Spliterator spliterator,
 *           Consumer action, long targetBatchSize) {
 *     super(parent);
 *     this.spliterator = spliterator; this.action = action;
 *     this.targetBatchSize = targetBatchSize;
 *   }
 *
 *   public void compute() {
 *     Spliterator sub;
 *     while (spliterator.estimateSize() > targetBatchSize &&
 *            (sub = spliterator.trySplit()) != null) {
 *       addToPendingCount(1);
 *       new ParEach<>(this, sub, action, targetBatchSize).fork();
 *     }
 *     spliterator.forEachRemaining(action);
 *     propagateCompletion();
 *   }
 * }}
 *
 * @implNote
 * If the boolean system property {@systemProperty org.openjdk.java.util.stream.tripwire}
 * is set to `true` then diagnostic warnings are reported if boxing of
 * primitive values occur when operating on primitive subtype specializations.
 *
 * @param  the type of elements returned by this Spliterator
 *
 * @see Collection
 * @since 1.8
*/
export class Spliterator<T> {
  /**
   * If a remaining element exists, performs the given action on it,
   * returning `true`; else returns `false`.  If this
   * Spliterator is {@link #ORDERED} the action is performed on the
   * next element in encounter order.  Exceptions thrown by the
   * action are relayed to the caller.
   *
   * @param action The action
   * @return `false` if no remaining elements existed
   * upon entry to this method, else `true`.
   * @throws NullPointerException if the specified action is null
  */
  tryAdvance(action: Consumer<any>): boolean;
  /**
   * Performs the given action for each remaining element, sequentially in
   * the current thread, until all elements have been processed or the action
   * throws an exception.  If this Spliterator is {@link #ORDERED}, actions
   * are performed in encounter order.  Exceptions thrown by the action
   * are relayed to the caller.
   *
   * @implSpec
   * The default implementation repeatedly invokes {@link #tryAdvance} until
   * it returns `false`.  It should be overridden whenever possible.
   *
   * @param action The action
   * @throws NullPointerException if the specified action is null
  */
  forEachRemaining(action: Consumer<any>): void;
  /**
   * If this spliterator can be partitioned, returns a Spliterator
   * covering elements, that will, upon return from this method, not
   * be covered by this Spliterator.
   *
   * If this Spliterator is {@link #ORDERED}, the returned Spliterator
   * must cover a strict prefix of the elements.
   *
   * Unless this Spliterator covers an infinite number of elements,
   * repeated calls to `trySplit()` must eventually return `null`.
   * Upon non-null return:
   * 
   * the value reported for `estimateSize()` before splitting,
   * must, after splitting, be greater than or equal to `estimateSize()`
   * for this and the returned Spliterator; and
   * if this Spliterator is `SUBSIZED`, then `estimateSize()`
   * for this spliterator before splitting must be equal to the sum of
   * `estimateSize()` for this and the returned Spliterator after
   * splitting.
   * 
   *
   * This method may return `null` for any reason,
   * including emptiness, inability to split after traversal has
   * commenced, data structure constraints, and efficiency
   * considerations.
   *
   * @apiNote
   * An ideal `trySplit` method efficiently (without
   * traversal) divides its elements exactly in half, allowing
   * balanced parallel computation.  Many departures from this ideal
   * remain highly effective; for example, only approximately
   * splitting an approximately balanced tree, or for a tree in
   * which leaf nodes may contain either one or two elements,
   * failing to further split these nodes.  However, large
   * deviations in balance and/or overly inefficient `     * trySplit` mechanics typically result in poor parallel
   * performance.
   *
   * @return a `Spliterator` covering some portion of the
   * elements, or `null` if this spliterator cannot be split
  */
  trySplit(): Spliterator<T>;
  /**
   * Returns an estimate of the number of elements that would be
   * encountered by a {@link #forEachRemaining} traversal, or returns {@link
   * Long#MAX_VALUE} if infinite, unknown, or too expensive to compute.
   *
   * If this Spliterator is {@link #SIZED} and has not yet been partially
   * traversed or split, or this Spliterator is {@link #SUBSIZED} and has
   * not yet been partially traversed, this estimate must be an accurate
   * count of elements that would be encountered by a complete traversal.
   * Otherwise, this estimate may be arbitrarily inaccurate, but must decrease
   * as specified across invocations of {@link #trySplit}.
   *
   * @apiNote
   * Even an inexact estimate is often useful and inexpensive to compute.
   * For example, a sub-spliterator of an approximately balanced binary tree
   * may return a value that estimates the number of elements to be half of
   * that of its parent; if the root Spliterator does not maintain an
   * accurate count, it could estimate size to be the power of two
   * corresponding to its maximum depth.
   *
   * @return the estimated size, or `Long.MAX_VALUE` if infinite,
   *         unknown, or too expensive to compute.
  */
  estimateSize(): number;
  /**
   * Convenience method that returns {@link #estimateSize()} if this
   * Spliterator is {@link #SIZED}, else `-1`.
   * @implSpec
   * The default implementation returns the result of `estimateSize()`
   * if the Spliterator reports a characteristic of `SIZED`, and
   * `-1` otherwise.
   *
   * @return the exact size, if known, else `-1`.
  */
  getExactSizeIfKnown(): number;
  /**
   * Returns a set of characteristics of this Spliterator and its
   * elements. The result is represented as ORed values from {@link
   * #ORDERED}, {@link #DISTINCT}, {@link #SORTED}, {@link #SIZED},
   * {@link #NONNULL}, {@link #IMMUTABLE}, {@link #CONCURRENT},
   * {@link #SUBSIZED}.  Repeated calls to `characteristics()` on
   * a given spliterator, prior to or in-between calls to `trySplit`,
   * should always return the same result.
   *
   * If a Spliterator reports an inconsistent set of
   * characteristics (either those returned from a single invocation
   * or across multiple invocations), no guarantees can be made
   * about any computation using this Spliterator.
   *
   * @apiNote The characteristics of a given spliterator before splitting
   * may differ from the characteristics after splitting.  For specific
   * examples see the characteristic values {@link #SIZED}, {@link #SUBSIZED}
   * and {@link #CONCURRENT}.
   *
   * @return a representation of characteristics
  */
  characteristics(): number;
  /**
   * Returns `true` if this Spliterator's {@link
   * #characteristics} contain all of the given characteristics.
   *
   * @implSpec
   * The default implementation returns true if the corresponding bits
   * of the given characteristics are set.
   *
   * @param characteristics the characteristics to check for
   * @return `true` if all the specified characteristics are present,
   * else `false`
  */
  hasCharacteristics(characteristics: number): boolean;
  /**
   * If this Spliterator's source is {@link #SORTED} by a {@link Comparator},
   * returns that `Comparator`. If the source is `SORTED` in
   * {@linkplain Comparable natural order}, returns `null`.  Otherwise,
   * if the source is not `SORTED`, throws {@link IllegalStateException}.
   *
   * @implSpec
   * The default implementation always throws {@link IllegalStateException}.
   *
   * @return a Comparator, or `null` if the elements are sorted in the
   * natural order.
   * @throws IllegalStateException if the spliterator does not report
   *         a characteristic of `SORTED`.
  */
  getComparator(): Comparator<any>;
  /**
   * Characteristic value signifying that an encounter order is defined for
   * elements. If so, this Spliterator guarantees that method
   * {@link #trySplit} splits a strict prefix of elements, that method
   * {@link #tryAdvance} steps by one element in prefix order, and that
   * {@link #forEachRemaining} performs actions in encounter order.
   *
   * A {@link Collection} has an encounter order if the corresponding
   * {@link Collection#iterator} documents an order. If so, the encounter
   * order is the same as the documented order. Otherwise, a collection does
   * not have an encounter order.
   *
   * @apiNote Encounter order is guaranteed to be ascending index order for
   * any {@link List}. But no order is guaranteed for hash-based collections
   * such as {@link HashSet}. Clients of a Spliterator that reports
   * `ORDERED` are expected to preserve ordering constraints in
   * non-commutative parallel computations.
  */
  static readonly ORDERED: number;
  /**
   * Characteristic value signifying that, for each pair of
   * encountered elements `x, y`, `!x.equals(y)`. This
   * applies for example, to a Spliterator based on a {@link Set}.
  */
  static readonly DISTINCT: number;
  /**
   * Characteristic value signifying that encounter order follows a defined
   * sort order. If so, method {@link #getComparator()} returns the associated
   * Comparator, or `null` if all elements are {@link Comparable} and
   * are sorted by their natural ordering.
   *
   * A Spliterator that reports `SORTED` must also report
   * `ORDERED`.
   *
   * @apiNote The spliterators for `Collection` classes in the JDK that
   * implement {@link NavigableSet} or {@link SortedSet} report `SORTED`.
  */
  static readonly SORTED: number;
  /**
   * Characteristic value signifying that the value returned from
   * `estimateSize()` prior to traversal or splitting represents a
   * finite size that, in the absence of structural source modification,
   * represents an exact count of the number of elements that would be
   * encountered by a complete traversal.
   *
   * @apiNote Most Spliterators for Collections, that cover all elements of a
   * `Collection` report this characteristic. Sub-spliterators, such as
   * those for {@link HashSet}, that cover a sub-set of elements and
   * approximate their reported size do not.
  */
  static readonly SIZED: number;
  /**
   * Characteristic value signifying that the source guarantees that
   * encountered elements will not be `null`. (This applies,
   * for example, to most concurrent collections, queues, and maps.)
  */
  static readonly NONNULL: number;
  /**
   * Characteristic value signifying that the element source cannot be
   * structurally modified; that is, elements cannot be added, replaced, or
   * removed, so such changes cannot occur during traversal. A Spliterator
   * that does not report `IMMUTABLE` or `CONCURRENT` is expected
   * to have a documented policy (for example throwing
   * {@link ConcurrentModificationException}) concerning structural
   * interference detected during traversal.
  */
  static readonly IMMUTABLE: number;
  /**
   * Characteristic value signifying that the element source may be safely
   * concurrently modified (allowing additions, replacements, and/or removals)
   * by multiple threads without external synchronization. If so, the
   * Spliterator is expected to have a documented policy concerning the impact
   * of modifications during traversal.
   *
   * A top-level Spliterator should not report both `CONCURRENT` and
   * `SIZED`, since the finite size, if known, may change if the source
   * is concurrently modified during traversal. Such a Spliterator is
   * inconsistent and no guarantees can be made about any computation using
   * that Spliterator. Sub-spliterators may report `SIZED` if the
   * sub-split size is known and additions or removals to the source are not
   * reflected when traversing.
   *
   * A top-level Spliterator should not report both `CONCURRENT` and
   * `IMMUTABLE`, since they are mutually exclusive. Such a Spliterator
   * is inconsistent and no guarantees can be made about any computation using
   * that Spliterator. Sub-spliterators may report `IMMUTABLE` if
   * additions or removals to the source are not reflected when traversing.
   *
   * @apiNote Most concurrent collections maintain a consistency policy
   * guaranteeing accuracy with respect to elements present at the point of
   * Spliterator construction, but possibly not reflecting subsequent
   * additions or removals.
  */
  static readonly CONCURRENT: number;
  /**
   * Characteristic value signifying that all Spliterators resulting from
   * `trySplit()` will be both {@link #SIZED} and {@link #SUBSIZED}.
   * (This means that all child Spliterators, whether direct or indirect, will
   * be `SIZED`.)
   *
   * A Spliterator that does not report `SIZED` as required by
   * `SUBSIZED` is inconsistent and no guarantees can be made about any
   * computation using that Spliterator.
   *
   * @apiNote Some spliterators, such as the top-level spliterator for an
   * approximately balanced binary tree, will report `SIZED` but not
   * `SUBSIZED`, since it is common to know the size of the entire tree
   * but not the exact sizes of subtrees.
  */
  static readonly SUBSIZED: number;
}
/**
 * A container object which may or may not contain an `int` value.
 * If a value is present, `isPresent()` returns `true`. If no
 * value is present, the object is considered empty and
 * `isPresent()` returns `false`.
 *
 * Additional methods that depend on the presence or absence of a contained
 * value are provided, such as {@link #orElse(int) orElse()}
 * (returns a default value if no value is present) and
 * {@link #ifPresent(IntConsumer) ifPresent()} (performs an
 * action if a value is present).
 *
 * This is a value-based
 * class; programmers should treat instances that are
 * {@linkplain #equals(Object) equal} as interchangeable and should not
 * use instances for synchronization, or unpredictable behavior may
 * occur. For example, in a future release, synchronization may fail.
 *
 * @apiNote
 * `OptionalInt` is primarily intended for use as a method return type where
 * there is a clear need to represent "no result." A variable whose type is
 * `OptionalInt` should never itself be `null`; it should always point
 * to an `OptionalInt` instance.
 *
 * @since 1.8
*/
export class OptionalInt {
  /**
   * Returns an empty `OptionalInt` instance.  No value is present for
   * this `OptionalInt`.
   *
   * @apiNote
   * Though it may be tempting to do so, avoid testing if an object is empty
   * by comparing with `==` or `!=` against instances returned by
   * `OptionalInt.empty()`.  There is no guarantee that it is a singleton.
   * Instead, use {@link #isEmpty()} or {@link #isPresent()}.
   *
   * @return an empty `OptionalInt`
  */
  static empty(): OptionalInt;
  /**
   * Returns an `OptionalInt` describing the given value.
   *
   * @param value the value to describe
   * @return an `OptionalInt` with the value present
  */
  static of(value: number): OptionalInt;
  /**
   * If a value is present, returns the value, otherwise throws
   * `NoSuchElementException`.
   *
   * @apiNote
   * The preferred alternative to this method is {@link #orElseThrow()}.
   *
   * @return the value described by this `OptionalInt`
   * @throws NoSuchElementException if no value is present
  */
  getAsInt(): number;
  /**
   * If a value is present, returns `true`, otherwise `false`.
   *
   * @return `true` if a value is present, otherwise `false`
  */
  isPresent(): boolean;
  /**
   * If a value is not present, returns `true`, otherwise
   * `false`.
   *
   * @return  `true` if a value is not present, otherwise `false`
   * @since   11
  */
  isEmpty(): boolean;
  /**
   * If a value is present, performs the given action with the value,
   * otherwise does nothing.
   *
   * @param action the action to be performed, if a value is present
   * @throws NullPointerException if value is present and the given action is
   *         `null`
  */
  ifPresent(action: IntConsumer): void;
  /**
   * If a value is present, performs the given action with the value,
   * otherwise performs the given empty-based action.
   *
   * @param action the action to be performed, if a value is present
   * @param emptyAction the empty-based action to be performed, if no value is
   *        present
   * @throws NullPointerException if a value is present and the given action
   *         is `null`, or no value is present and the given empty-based
   *         action is `null`.
   * @since 9
  */
  ifPresentOrElse(action: IntConsumer, emptyAction: Runnable): void;
  /**
   * If a value is present, returns a sequential {@link IntStream} containing
   * only that value, otherwise returns an empty `IntStream`.
   *
   * @apiNote
   * This method can be used to transform a `Stream` of optional
   * integers to an `IntStream` of present integers:
   * {@code
   *     Stream os = ..
   *     IntStream s = os.flatMapToInt(OptionalInt::stream)
   * }
   *
   * @return the optional value as an `IntStream`
   * @since 9
  */
  stream(): IntStream;
  /**
   * If a value is present, returns the value, otherwise returns
   * `other`.
   *
   * @param other the value to be returned, if no value is present
   * @return the value, if present, otherwise `other`
  */
  orElse(other: number): number;
  /**
   * If a value is present, returns the value, otherwise returns the result
   * produced by the supplying function.
   *
   * @param supplier the supplying function that produces a value to be returned
   * @return the value, if present, otherwise the result produced by the
   *         supplying function
   * @throws NullPointerException if no value is present and the supplying
   *         function is `null`
  */
  orElseGet(supplier: IntSupplier): number;
  /**
   * If a value is present, returns the value, otherwise throws
   * `NoSuchElementException`.
   *
   * @return the value described by this `OptionalInt`
   * @throws NoSuchElementException if no value is present
   * @since 10
  */
  orElseThrow(): number;
  /**
   * If a value is present, returns the value, otherwise throws an exception
   * produced by the exception supplying function.
   *
   * @apiNote
   * A method reference to the exception constructor with an empty argument
   * list can be used as the supplier. For example,
   * `IllegalStateException::new`
   *
   * @param  Type of the exception to be thrown
   * @param exceptionSupplier the supplying function that produces an
   *        exception to be thrown
   * @return the value, if present
   * @throws X if no value is present
   * @throws NullPointerException if no value is present and the exception
   *         supplying function is `null`
  */
  orElseThrow<X>(exceptionSupplier: Supplier<X>): number;
  /**
   * Indicates whether some other object is "equal to" this
   * `OptionalInt`.  The other object is considered equal if:
   * 
   * it is also an `OptionalInt` and;
   * both instances have no value present or;
   * the present values are "equal to" each other via `==`.
   * 
   *
   * @param obj an object to be tested for equality
   * @return `true` if the other object is "equal to" this object
   *         otherwise `false`
  */
  equals(obj: any): boolean;
  /**
   * Returns the hash code of the value, if present, otherwise `0`
   * (zero) if no value is present.
   *
   * @return hash code value of the present value or `0` if no value is
   *         present
  */
  hashCode(): number;
  /**
   * Returns a non-empty string representation of this `OptionalInt`
   * suitable for debugging.  The exact presentation format is unspecified and
   * may vary between implementations and versions.
   *
   * @implSpec
   * If a value is present the result must include its string representation
   * in the result.  Empty and present `OptionalInt`s must be
   * unambiguously differentiable.
   *
   * @return the string representation of this instance
  */
  toString(): string;
}
/**
 * Unchecked exception thrown when there is a format specifier which does not
 * have a corresponding argument or if an argument index refers to an argument
 * that does not exist.
 *
 *  Unless otherwise specified, passing a `null` argument to any
 * method or constructor in this class will cause a {@link
 * NullPointerException} to be thrown.
 *
 * @since 1.5
*/
export class MissingFormatArgumentException extends IllegalFormatException {
  /**
   * Constructs an instance of this class with the unmatched format
   * specifier.
   *
   * @param  s
   *         Format specifier which does not have a corresponding argument
  */
  constructor(s: string);
  /**
   * Returns the unmatched format specifier.
   *
   * @return  The unmatched format specifier
  */
  getFormatSpecifier(): string;
  getMessage(): string;
}
/**
 * The `Stack` class represents a last-in-first-out
 * (LIFO) stack of objects. It extends class `Vector` with five
 * operations that allow a vector to be treated as a stack. The usual
 * `push` and `pop` operations are provided, as well as a
 * method to `peek` at the top item on the stack, a method to test
 * for whether the stack is `empty`, and a method to `search`
 * the stack for an item and discover how far it is from the top.
 * 
 * When a stack is first created, it contains no items.
 *
 * A more complete and consistent set of LIFO stack operations is
 * provided by the {@link Deque} interface and its implementations, which
 * should be used in preference to this class.  For example:
 *    ` *   Deque stack = new ArrayDeque();`
 *
 * @author  Jonathan Payne
 * @since   1.0
*/
export class Stack<E> extends Vector<E> {
  /**
   * Creates an empty Stack.
  */
  constructor();
  /**
   * Pushes an item onto the top of this stack. This has exactly
   * the same effect as:
   *      * addElement(item)
   *
   * @param   item   the item to be pushed onto this stack.
   * @return  the `item` argument.
   * @see     java.util.Vector#addElement
  */
  push(item: E): E;
  /**
   * Removes the object at the top of this stack and returns that
   * object as the value of this function.
   *
   * @return  The object at the top of this stack (the last item
   *          of the `Vector` object).
   * @throws  EmptyStackException  if this stack is empty.
  */
  pop(): E;
  /**
   * Looks at the object at the top of this stack without removing it
   * from the stack.
   *
   * @return  the object at the top of this stack (the last item
   *          of the `Vector` object).
   * @throws  EmptyStackException  if this stack is empty.
  */
  peek(): E;
  /**
   * Tests if this stack is empty.
   *
   * @return  `true` if and only if this stack contains
   *          no items; `false` otherwise.
  */
  empty(): boolean;
  /**
   * Returns the 1-based position where an object is on this stack.
   * If the object `o` occurs as an item in this stack, this
   * method returns the distance from the top of the stack of the
   * occurrence nearest the top of the stack; the topmost item on the
   * stack is considered to be at distance `1`. The `equals`
   * method is used to compare `o` to the
   * items in this stack.
   *
   * @param   o   the desired object.
   * @return  the 1-based position from the top of the stack where
   *          the object is located; the return value `-1`
   *          indicates that the object is not on the stack.
  */
  search(o: any): number;
}
export class HashSet<E> extends AbstractSet<E> {
  /**
   * Constructs a new, empty set; the backing `HashMap` instance has
   * default initial capacity (16) and load factor (0.75).
  */
  constructor();
  /**
   * Constructs a new set containing the elements in the specified
   * collection.  The `HashMap` is created with default load factor
   * (0.75) and an initial capacity sufficient to contain the elements in
   * the specified collection.
   *
   * @param c the collection whose elements are to be placed into this set
   * @throws NullPointerException if the specified collection is null
  */
  constructor(c: Collection<E>);
  /**
   * Constructs a new, empty set; the backing `HashMap` instance has
   * the specified initial capacity and the specified load factor.
   *
   * @param      initialCapacity   the initial capacity of the hash map
   * @param      loadFactor        the load factor of the hash map
   * @throws     IllegalArgumentException if the initial capacity is less
   *             than zero, or if the load factor is nonpositive
  */
  constructor(initialCapacity: number, loadFactor: number);
  /**
   * Constructs a new, empty set; the backing `HashMap` instance has
   * the specified initial capacity and default load factor (0.75).
   *
   * @param      initialCapacity   the initial capacity of the hash table
   * @throws     IllegalArgumentException if the initial capacity is less
   *             than zero
  */
  constructor(initialCapacity: number);
  /**
   * Returns an iterator over the elements in this set.  The elements
   * are returned in no particular order.
   *
   * @return an Iterator over the elements in this set
   * @see ConcurrentModificationException
  */
  iterator(): Iterator<E>;
  /**
   * Returns the number of elements in this set (its cardinality).
   *
   * @return the number of elements in this set (its cardinality)
  */
  size(): number;
  /**
   * Returns `true` if this set contains no elements.
   *
   * @return `true` if this set contains no elements
  */
  isEmpty(): boolean;
  /**
   * Returns `true` if this set contains the specified element.
   * More formally, returns `true` if and only if this set
   * contains an element `e` such that
   * `Objects.equals(o, e)`.
   *
   * @param o element whose presence in this set is to be tested
   * @return `true` if this set contains the specified element
  */
  contains(o: any): boolean;
  /**
   * Adds the specified element to this set if it is not already present.
   * More formally, adds the specified element `e` to this set if
   * this set contains no element `e2` such that
   * `Objects.equals(e, e2)`.
   * If this set already contains the element, the call leaves the set
   * unchanged and returns `false`.
   *
   * @param e element to be added to this set
   * @return `true` if this set did not already contain the specified
   * element
  */
  add(e: E): boolean;
  /**
   * Removes the specified element from this set if it is present.
   * More formally, removes an element `e` such that
   * `Objects.equals(o, e)`,
   * if this set contains such an element.  Returns `true` if
   * this set contained the element (or equivalently, if this set
   * changed as a result of the call).  (This set will not contain the
   * element once the call returns.)
   *
   * @param o object to be removed from this set, if present
   * @return `true` if the set contained the specified element
  */
  remove(o: any): boolean;
  /**
   * Removes all of the elements from this set.
   * The set will be empty after this call returns.
  */
  clear(): void;
  /**
   * Returns a shallow copy of this `HashSet` instance: the elements
   * themselves are not cloned.
   *
   * @return a shallow copy of this set
  */
  clone(): any;
  /**
   * Creates a late-binding
   * and fail-fast {@link Spliterator} over the elements in this
   * set.
   *
   * The `Spliterator` reports {@link Spliterator#SIZED} and
   * {@link Spliterator#DISTINCT}.  Overriding implementations should document
   * the reporting of additional characteristic values.
   *
   * @return a `Spliterator` over the elements in this set
   * @since 1.8
  */
  spliterator(): Spliterator<E>;
  /**
   * Returns an array containing all of the elements in this set.
   * If this set makes any guarantees as to what order its elements
   * are returned by its iterator, this method must return the
   * elements in the same order.
   *
   * The returned array will be "safe" in that no references to it
   * are maintained by this set.  (In other words, this method must
   * allocate a new array even if this set is backed by an array).
   * The caller is thus free to modify the returned array.
   *
   * This method acts as bridge between array-based and collection-based
   * APIs.
   *
   * @return an array containing all the elements in this set
  */
  toArray(): any[];
  /**
   * Returns an array containing all of the elements in this set.
   * If this set makes any guarantees as to what order its elements
   * are returned by its iterator, this method must return the
   * elements in the same order.
   *
   * The returned array will be "safe" in that no references to it
   * are maintained by this set.  (In other words, this method must
   * allocate a new array even if this set is backed by an array).
   * The caller is thus free to modify the returned array.
   *
   * This method acts as bridge between array-based and collection-based
   * APIs.
   *
   * @return an array containing all the elements in this set
  */
  toArray<T>(a: T[]): T[];
  /**
   * Returns an array containing all of the elements in this collection,
   * using the provided `generator` function to allocate the returned array.
   *
   * If this collection makes any guarantees as to what order its elements
   * are returned by its iterator, this method must return the elements in
   * the same order.
   *
   * @apiNote
   * This method acts as a bridge between array-based and collection-based APIs.
   * It allows creation of an array of a particular runtime type. Use
   * {@link #toArray()} to create an array whose runtime type is `Object[]`,
   * or use {@link #toArray(Object[]) toArray(T[])} to reuse an existing array.
   *
   * Suppose `x` is a collection known to contain only strings.
   * The following code can be used to dump the collection into a newly
   * allocated array of `String`:
   *
   *      *     String[] y = x.toArray(String[]::new);
   *
   * @implSpec
   * The default implementation calls the generator function with zero
   * and then passes the resulting array to {@link #toArray(Object[]) toArray(T[])}.
   *
   * @param  the component type of the array to contain the collection
   * @param generator a function which produces a new array of the desired
   *                  type and the provided length
   * @return an array containing all of the elements in this collection
   * @throws ArrayStoreException if the runtime type of any element in this
   *         collection is not assignable to the {@linkplain Class#getComponentType
   *         runtime component type} of the generated array
   * @throws NullPointerException if the generator function is null
   * @since 11
  */
  toArray<T>(generator: IntFunction<T[]>): T[];
}
export interface HashSet<E> extends AbstractSet<E>, Set<E>, Cloneable, Serializable {}
export class LinkedList<E> extends AbstractSequentialList<E> {
  /**
   * Constructs an empty list.
  */
  constructor();
  /**
   * Constructs a list containing the elements of the specified
   * collection, in the order they are returned by the collection's
   * iterator.
   *
   * @param  c the collection whose elements are to be placed into this list
   * @throws NullPointerException if the specified collection is null
  */
  constructor(c: Collection<E>);
  /**
   * Returns the first element in this list.
   *
   * @return the first element in this list
   * @throws NoSuchElementException if this list is empty
  */
  getFirst(): E;
  /**
   * Returns the last element in this list.
   *
   * @return the last element in this list
   * @throws NoSuchElementException if this list is empty
  */
  getLast(): E;
  /**
   * Removes and returns the first element from this list.
   *
   * @return the first element from this list
   * @throws NoSuchElementException if this list is empty
  */
  removeFirst(): E;
  /**
   * Removes and returns the last element from this list.
   *
   * @return the last element from this list
   * @throws NoSuchElementException if this list is empty
  */
  removeLast(): E;
  /**
   * Inserts the specified element at the beginning of this list.
   *
   * @param e the element to add
  */
  addFirst(e: E): void;
  /**
   * Appends the specified element to the end of this list.
   *
   * This method is equivalent to {@link #add}.
   *
   * @param e the element to add
  */
  addLast(e: E): void;
  /**
   * Returns `true` if this list contains the specified element.
   * More formally, returns `true` if and only if this list contains
   * at least one element `e` such that
   * `Objects.equals(o, e)`.
   *
   * @param o element whose presence in this list is to be tested
   * @return `true` if this list contains the specified element
  */
  contains(o: any): boolean;
  /**
   * Returns the number of elements in this list.
   *
   * @return the number of elements in this list
  */
  size(): number;
  /**
   * Appends the specified element to the end of this list.
   *
   * This method is equivalent to {@link #addLast}.
   *
   * @param e element to be appended to this list
   * @return `true` (as specified by {@link Collection#add})
  */
  add(e: E): boolean;
  /**
   * Removes the first occurrence of the specified element from this list,
   * if it is present.  If this list does not contain the element, it is
   * unchanged.  More formally, removes the element with the lowest index
   * `i` such that
   * `Objects.equals(o, get(i))`
   * (if such an element exists).  Returns `true` if this list
   * contained the specified element (or equivalently, if this list
   * changed as a result of the call).
   *
   * @param o element to be removed from this list, if present
   * @return `true` if this list contained the specified element
  */
  remove(o: any): boolean;
  /**
   * Appends all of the elements in the specified collection to the end of
   * this list, in the order that they are returned by the specified
   * collection's iterator.  The behavior of this operation is undefined if
   * the specified collection is modified while the operation is in
   * progress.  (Note that this will occur if the specified collection is
   * this list, and it's nonempty.)
   *
   * @param c collection containing elements to be added to this list
   * @return `true` if this list changed as a result of the call
   * @throws NullPointerException if the specified collection is null
  */
  addAll(c: Collection<E>): boolean;
  /**
   * Inserts all of the elements in the specified collection into this
   * list, starting at the specified position.  Shifts the element
   * currently at that position (if any) and any subsequent elements to
   * the right (increases their indices).  The new elements will appear
   * in the list in the order that they are returned by the
   * specified collection's iterator.
   *
   * @param index index at which to insert the first element
   *              from the specified collection
   * @param c collection containing elements to be added to this list
   * @return `true` if this list changed as a result of the call
   * @throws IndexOutOfBoundsException {@inheritDoc}
   * @throws NullPointerException if the specified collection is null
  */
  addAll(index: number, c: Collection<E>): boolean;
  /**
   * Removes all of the elements from this list.
   * The list will be empty after this call returns.
  */
  clear(): void;
  /**
   * Returns the element at the specified position in this list.
   *
   * @param index index of the element to return
   * @return the element at the specified position in this list
   * @throws IndexOutOfBoundsException {@inheritDoc}
  */
  get(index: number): E;
  /**
   * Replaces the element at the specified position in this list with the
   * specified element.
   *
   * @param index index of the element to replace
   * @param element element to be stored at the specified position
   * @return the element previously at the specified position
   * @throws IndexOutOfBoundsException {@inheritDoc}
  */
  set(index: number, element: E): E;
  /**
   * Inserts the specified element at the specified position in this list.
   * Shifts the element currently at that position (if any) and any
   * subsequent elements to the right (adds one to their indices).
   *
   * @param index index at which the specified element is to be inserted
   * @param element element to be inserted
   * @throws IndexOutOfBoundsException {@inheritDoc}
  */
  add(index: number, element: E): void;
  /**
   * Removes the element at the specified position in this list.  Shifts any
   * subsequent elements to the left (subtracts one from their indices).
   * Returns the element that was removed from the list.
   *
   * @param index the index of the element to be removed
   * @return the element previously at the specified position
   * @throws IndexOutOfBoundsException {@inheritDoc}
  */
  remove(index: number): E;
  /**
   * Returns the index of the first occurrence of the specified element
   * in this list, or -1 if this list does not contain the element.
   * More formally, returns the lowest index `i` such that
   * `Objects.equals(o, get(i))`,
   * or -1 if there is no such index.
   *
   * @param o element to search for
   * @return the index of the first occurrence of the specified element in
   *         this list, or -1 if this list does not contain the element
  */
  indexOf(o: any): number;
  /**
   * Returns the index of the last occurrence of the specified element
   * in this list, or -1 if this list does not contain the element.
   * More formally, returns the highest index `i` such that
   * `Objects.equals(o, get(i))`,
   * or -1 if there is no such index.
   *
   * @param o element to search for
   * @return the index of the last occurrence of the specified element in
   *         this list, or -1 if this list does not contain the element
  */
  lastIndexOf(o: any): number;
  /**
   * Retrieves, but does not remove, the head (first element) of this list.
   *
   * @return the head of this list, or `null` if this list is empty
   * @since 1.5
  */
  peek(): E;
  /**
   * Retrieves, but does not remove, the head (first element) of this list.
   *
   * @return the head of this list
   * @throws NoSuchElementException if this list is empty
   * @since 1.5
  */
  element(): E;
  /**
   * Retrieves and removes the head (first element) of this list.
   *
   * @return the head of this list, or `null` if this list is empty
   * @since 1.5
  */
  poll(): E;
  /**
   * Retrieves and removes the head (first element) of this list.
   *
   * @return the head of this list
   * @throws NoSuchElementException if this list is empty
   * @since 1.5
  */
  remove(): E;
  /**
   * Adds the specified element as the tail (last element) of this list.
   *
   * @param e the element to add
   * @return `true` (as specified by {@link Queue#offer})
   * @since 1.5
  */
  offer(e: E): boolean;
  /**
   * Inserts the specified element at the front of this list.
   *
   * @param e the element to insert
   * @return `true` (as specified by {@link Deque#offerFirst})
   * @since 1.6
  */
  offerFirst(e: E): boolean;
  /**
   * Inserts the specified element at the end of this list.
   *
   * @param e the element to insert
   * @return `true` (as specified by {@link Deque#offerLast})
   * @since 1.6
  */
  offerLast(e: E): boolean;
  /**
   * Retrieves, but does not remove, the first element of this list,
   * or returns `null` if this list is empty.
   *
   * @return the first element of this list, or `null`
   *         if this list is empty
   * @since 1.6
  */
  peekFirst(): E;
  /**
   * Retrieves, but does not remove, the last element of this list,
   * or returns `null` if this list is empty.
   *
   * @return the last element of this list, or `null`
   *         if this list is empty
   * @since 1.6
  */
  peekLast(): E;
  /**
   * Retrieves and removes the first element of this list,
   * or returns `null` if this list is empty.
   *
   * @return the first element of this list, or `null` if
   *     this list is empty
   * @since 1.6
  */
  pollFirst(): E;
  /**
   * Retrieves and removes the last element of this list,
   * or returns `null` if this list is empty.
   *
   * @return the last element of this list, or `null` if
   *     this list is empty
   * @since 1.6
  */
  pollLast(): E;
  /**
   * Pushes an element onto the stack represented by this list.  In other
   * words, inserts the element at the front of this list.
   *
   * This method is equivalent to {@link #addFirst}.
   *
   * @param e the element to push
   * @since 1.6
  */
  push(e: E): void;
  /**
   * Pops an element from the stack represented by this list.  In other
   * words, removes and returns the first element of this list.
   *
   * This method is equivalent to {@link #removeFirst()}.
   *
   * @return the element at the front of this list (which is the top
   *         of the stack represented by this list)
   * @throws NoSuchElementException if this list is empty
   * @since 1.6
  */
  pop(): E;
  /**
   * Removes the first occurrence of the specified element in this
   * list (when traversing the list from head to tail).  If the list
   * does not contain the element, it is unchanged.
   *
   * @param o element to be removed from this list, if present
   * @return `true` if the list contained the specified element
   * @since 1.6
  */
  removeFirstOccurrence(o: any): boolean;
  /**
   * Removes the last occurrence of the specified element in this
   * list (when traversing the list from head to tail).  If the list
   * does not contain the element, it is unchanged.
   *
   * @param o element to be removed from this list, if present
   * @return `true` if the list contained the specified element
   * @since 1.6
  */
  removeLastOccurrence(o: any): boolean;
  /**
   * Returns a list-iterator of the elements in this list (in proper
   * sequence), starting at the specified position in the list.
   * Obeys the general contract of `List.listIterator(int)`.
   *
   * The list-iterator is fail-fast: if the list is structurally
   * modified at any time after the Iterator is created, in any way except
   * through the list-iterator's own `remove` or `add`
   * methods, the list-iterator will throw a
   * `ConcurrentModificationException`.  Thus, in the face of
   * concurrent modification, the iterator fails quickly and cleanly, rather
   * than risking arbitrary, non-deterministic behavior at an undetermined
   * time in the future.
   *
   * @param index index of the first element to be returned from the
   *              list-iterator (by a call to `next`)
   * @return a ListIterator of the elements in this list (in proper
   *         sequence), starting at the specified position in the list
   * @throws IndexOutOfBoundsException {@inheritDoc}
   * @see List#listIterator(int)
  */
  listIterator(index: number): ListIterator<E>;
  /**
   * @since 1.6
  */
  descendingIterator(): Iterator<E>;
  /**
   * Returns a shallow copy of this `LinkedList`. (The elements
   * themselves are not cloned.)
   *
   * @return a shallow copy of this `LinkedList` instance
  */
  clone(): any;
  /**
   * Returns an array containing all of the elements in this list
   * in proper sequence (from first to last element).
   *
   * The returned array will be "safe" in that no references to it are
   * maintained by this list.  (In other words, this method must allocate
   * a new array).  The caller is thus free to modify the returned array.
   *
   * This method acts as bridge between array-based and collection-based
   * APIs.
   *
   * @return an array containing all of the elements in this list
   *         in proper sequence
  */
  toArray(): any[];
  /**
   * Returns an array containing all of the elements in this list in
   * proper sequence (from first to last element); the runtime type of
   * the returned array is that of the specified array.  If the list fits
   * in the specified array, it is returned therein.  Otherwise, a new
   * array is allocated with the runtime type of the specified array and
   * the size of this list.
   *
   * If the list fits in the specified array with room to spare (i.e.,
   * the array has more elements than the list), the element in the array
   * immediately following the end of the list is set to `null`.
   * (This is useful in determining the length of the list only if
   * the caller knows that the list does not contain any null elements.)
   *
   * Like the {@link #toArray()} method, this method acts as bridge between
   * array-based and collection-based APIs.  Further, this method allows
   * precise control over the runtime type of the output array, and may,
   * under certain circumstances, be used to save allocation costs.
   *
   * Suppose `x` is a list known to contain only strings.
   * The following code can be used to dump the list into a newly
   * allocated array of `String`:
   *
   *      *     String[] y = x.toArray(new String[0]);
   *
   * Note that `toArray(new Object[0])` is identical in function to
   * `toArray()`.
   *
   * @param a the array into which the elements of the list are to
   *          be stored, if it is big enough; otherwise, a new array of the
   *          same runtime type is allocated for this purpose.
   * @return an array containing the elements of the list
   * @throws ArrayStoreException if the runtime type of the specified array
   *         is not a supertype of the runtime type of every element in
   *         this list
   * @throws NullPointerException if the specified array is null
  */
  toArray<T>(a: T[]): T[];
  /**
   * Creates a late-binding
   * and fail-fast {@link Spliterator} over the elements in this
   * list.
   *
   * The `Spliterator` reports {@link Spliterator#SIZED} and
   * {@link Spliterator#ORDERED}.  Overriding implementations should document
   * the reporting of additional characteristic values.
   *
   * @implNote
   * The `Spliterator` additionally reports {@link Spliterator#SUBSIZED}
   * and implements `trySplit` to permit limited parallelism..
   *
   * @return a `Spliterator` over the elements in this list
   * @since 1.8
  */
  spliterator(): Spliterator<E>;
  /**
   * {@inheritDoc}
   *
   * @implSpec
   * This implementation returns `listIterator(0)`.
   *
   * @see #listIterator(int)
  */
  listIterator(): ListIterator<E>;
  /**
   * Returns an array containing all of the elements in this collection,
   * using the provided `generator` function to allocate the returned array.
   *
   * If this collection makes any guarantees as to what order its elements
   * are returned by its iterator, this method must return the elements in
   * the same order.
   *
   * @apiNote
   * This method acts as a bridge between array-based and collection-based APIs.
   * It allows creation of an array of a particular runtime type. Use
   * {@link #toArray()} to create an array whose runtime type is `Object[]`,
   * or use {@link #toArray(Object[]) toArray(T[])} to reuse an existing array.
   *
   * Suppose `x` is a collection known to contain only strings.
   * The following code can be used to dump the collection into a newly
   * allocated array of `String`:
   *
   *      *     String[] y = x.toArray(String[]::new);
   *
   * @implSpec
   * The default implementation calls the generator function with zero
   * and then passes the resulting array to {@link #toArray(Object[]) toArray(T[])}.
   *
   * @param  the component type of the array to contain the collection
   * @param generator a function which produces a new array of the desired
   *                  type and the provided length
   * @return an array containing all of the elements in this collection
   * @throws ArrayStoreException if the runtime type of any element in this
   *         collection is not assignable to the {@linkplain Class#getComponentType
   *         runtime component type} of the generated array
   * @throws NullPointerException if the generator function is null
   * @since 11
  */
  toArray<T>(generator: IntFunction<T[]>): T[];
}
export interface LinkedList<E> extends AbstractSequentialList<E>, Deque<E>, Cloneable, Serializable {}
/**
 * Unchecked exception thrown when the argument corresponding to the format
 * specifier is of an incompatible type.
 *
 *  Unless otherwise specified, passing a `null` argument to any
 * method or constructor in this class will cause a {@link
 * NullPointerException} to be thrown.
 *
 * @since 1.5
*/
export class IllegalFormatConversionException extends IllegalFormatException {
  /**
   * Constructs an instance of this class with the mismatched conversion and
   * the corresponding argument class.
   *
   * @param  c
   *         Inapplicable conversion
   *
   * @param  arg
   *         Class of the mismatched argument
  */
  constructor(c: string, arg: Class<any>);
  /**
   * Returns the inapplicable conversion.
   *
   * @return  The inapplicable conversion
  */
  getConversion(): string;
  /**
   * Returns the class of the mismatched argument.
   *
   * @return   The class of the mismatched argument
  */
  getArgumentClass(): Class<any>;
  getMessage(): string;
}
/**
 * A base type for primitive specializations of `Iterator`.  Specialized
 * subtypes are provided for {@link OfInt int}, {@link OfLong long}, and
 * {@link OfDouble double} values.
 *
 * The specialized subtype default implementations of {@link Iterator#next}
 * and {@link Iterator#forEachRemaining(java.util.function.Consumer)} box
 * primitive values to instances of their corresponding wrapper class.  Such
 * boxing may offset any advantages gained when using the primitive
 * specializations.  To avoid boxing, the corresponding primitive-based methods
 * should be used.  For example, {@link PrimitiveIterator.OfInt#nextInt()} and
 * {@link PrimitiveIterator.OfInt#forEachRemaining(java.util.function.IntConsumer)}
 * should be used in preference to {@link PrimitiveIterator.OfInt#next()} and
 * {@link PrimitiveIterator.OfInt#forEachRemaining(java.util.function.Consumer)}.
 *
 * Iteration of primitive values using boxing-based methods
 * {@link Iterator#next next()} and
 * {@link Iterator#forEachRemaining(java.util.function.Consumer) forEachRemaining()},
 * does not affect the order in which the values, transformed to boxed values,
 * are encountered.
 *
 * @implNote
 * If the boolean system property `org.openjdk.java.util.stream.tripwire`
 * is set to `true` then diagnostic warnings are reported if boxing of
 * primitive values occur when operating on primitive subtype specializations.
 *
 * @param  the type of elements returned by this PrimitiveIterator.  The
 *        type must be a wrapper type for a primitive type, such as
 *        `Integer` for the primitive `int` type.
 * @param  the type of primitive consumer.  The type must be a
 *        primitive specialization of {@link java.util.function.Consumer} for
 *        `T`, such as {@link java.util.function.IntConsumer} for
 *        `Integer`.
 *
 * @since 1.8
*/
export class PrimitiveIterator<T, T_CONS> extends Iterator<T> {
  /**
   * Performs the given action for each remaining element, in the order
   * elements occur when iterating, until all elements have been processed
   * or the action throws an exception.  Errors or runtime exceptions
   * thrown by the action are relayed to the caller.
   *
   * @param action The action to be performed for each element
   * @throws NullPointerException if the specified action is null
  */
  forEachRemaining(action: T_CONS): void;
  /**
   * Performs the given action for each remaining element until all elements
   * have been processed or the action throws an exception.  Actions are
   * performed in the order of iteration, if that order is specified.
   * Exceptions thrown by the action are relayed to the caller.
   * 
   * The behavior of an iterator is unspecified if the action modifies the
   * collection in any way (even by calling the {@link #remove remove} method
   * or other mutator methods of `Iterator` subtypes),
   * unless an overriding class has specified a concurrent modification policy.
   * 
   * Subsequent behavior of an iterator is unspecified if the action throws an
   * exception.
   *
   * @implSpec
   * The default implementation behaves as if:
   * {@code
   *     while (hasNext())
   *         action.accept(next());
   * }
   *
   * @param action The action to be performed for each element
   * @throws NullPointerException if the specified action is null
   * @since 1.8
  */
  forEachRemaining(action: Consumer<any>): void;
}
export class AbstractMap<K, V> extends Map<K, V> {
  /**
   * {@inheritDoc}
   *
   * @implSpec
   * This implementation returns `entrySet().size()`.
  */
  size(): number;
  /**
   * {@inheritDoc}
   *
   * @implSpec
   * This implementation returns `size() == 0`.
  */
  isEmpty(): boolean;
  /**
   * {@inheritDoc}
   *
   * @implSpec
   * This implementation iterates over `entrySet()` searching
   * for an entry with the specified value.  If such an entry is found,
   * `true` is returned.  If the iteration terminates without
   * finding such an entry, `false` is returned.  Note that this
   * implementation requires linear time in the size of the map.
   *
   * @throws ClassCastException   {@inheritDoc}
   * @throws NullPointerException {@inheritDoc}
  */
  containsValue(value: any): boolean;
  /**
   * {@inheritDoc}
   *
   * @implSpec
   * This implementation iterates over `entrySet()` searching
   * for an entry with the specified key.  If such an entry is found,
   * `true` is returned.  If the iteration terminates without
   * finding such an entry, `false` is returned.  Note that this
   * implementation requires linear time in the size of the map; many
   * implementations will override this method.
   *
   * @throws ClassCastException   {@inheritDoc}
   * @throws NullPointerException {@inheritDoc}
  */
  containsKey(key: any): boolean;
  /**
   * {@inheritDoc}
   *
   * @implSpec
   * This implementation iterates over `entrySet()` searching
   * for an entry with the specified key.  If such an entry is found,
   * the entry's value is returned.  If the iteration terminates without
   * finding such an entry, `null` is returned.  Note that this
   * implementation requires linear time in the size of the map; many
   * implementations will override this method.
   *
   * @throws ClassCastException            {@inheritDoc}
   * @throws NullPointerException          {@inheritDoc}
  */
  get(key: any): V;
  /**
   * {@inheritDoc}
   *
   * @implSpec
   * This implementation always throws an
   * `UnsupportedOperationException`.
   *
   * @throws UnsupportedOperationException {@inheritDoc}
   * @throws ClassCastException            {@inheritDoc}
   * @throws NullPointerException          {@inheritDoc}
   * @throws IllegalArgumentException      {@inheritDoc}
  */
  put(key: K, value: V): V;
  /**
   * {@inheritDoc}
   *
   * @implSpec
   * This implementation iterates over `entrySet()` searching for an
   * entry with the specified key.  If such an entry is found, its value is
   * obtained with its `getValue` operation, the entry is removed
   * from the collection (and the backing map) with the iterator's
   * `remove` operation, and the saved value is returned.  If the
   * iteration terminates without finding such an entry, `null` is
   * returned.  Note that this implementation requires linear time in the
   * size of the map; many implementations will override this method.
   *
   * Note that this implementation throws an
   * `UnsupportedOperationException` if the `entrySet`
   * iterator does not support the `remove` method and this map
   * contains a mapping for the specified key.
   *
   * @throws UnsupportedOperationException {@inheritDoc}
   * @throws ClassCastException            {@inheritDoc}
   * @throws NullPointerException          {@inheritDoc}
  */
  remove(key: any): V;
  /**
   * {@inheritDoc}
   *
   * @implSpec
   * This implementation iterates over the specified map's
   * `entrySet()` collection, and calls this map's `put`
   * operation once for each entry returned by the iteration.
   *
   * Note that this implementation throws an
   * `UnsupportedOperationException` if this map does not support
   * the `put` operation and the specified map is nonempty.
   *
   * @throws UnsupportedOperationException {@inheritDoc}
   * @throws ClassCastException            {@inheritDoc}
   * @throws NullPointerException          {@inheritDoc}
   * @throws IllegalArgumentException      {@inheritDoc}
  */
  putAll(m: Map<K, V>): void;
  /**
   * {@inheritDoc}
   *
   * @implSpec
   * This implementation calls `entrySet().clear()`.
   *
   * Note that this implementation throws an
   * `UnsupportedOperationException` if the `entrySet`
   * does not support the `clear` operation.
   *
   * @throws UnsupportedOperationException {@inheritDoc}
  */
  clear(): void;
  /**
   * {@inheritDoc}
   *
   * @implSpec
   * This implementation returns a set that subclasses {@link AbstractSet}.
   * The subclass's iterator method returns a "wrapper object" over this
   * map's `entrySet()` iterator.  The `size` method
   * delegates to this map's `size` method and the
   * `contains` method delegates to this map's
   * `containsKey` method.
   *
   * The set is created the first time this method is called,
   * and returned in response to all subsequent calls.  No synchronization
   * is performed, so there is a slight chance that multiple calls to this
   * method will not all return the same set.
  */
  keySet(): Set<K>;
  /**
   * {@inheritDoc}
   *
   * @implSpec
   * This implementation returns a collection that subclasses {@link
   * AbstractCollection}.  The subclass's iterator method returns a
   * "wrapper object" over this map's `entrySet()` iterator.
   * The `size` method delegates to this map's `size`
   * method and the `contains` method delegates to this map's
   * `containsValue` method.
   *
   * The collection is created the first time this method is called, and
   * returned in response to all subsequent calls.  No synchronization is
   * performed, so there is a slight chance that multiple calls to this
   * method will not all return the same collection.
  */
  values(): Collection<V>;
  entrySet(): Set<java_util_Map_Entry<K, V>>;
  /**
   * Compares the specified object with this map for equality.  Returns
   * `true` if the given object is also a map and the two maps
   * represent the same mappings.  More formally, two maps `m1` and
   * `m2` represent the same mappings if
   * `m1.entrySet().equals(m2.entrySet())`.  This ensures that the
   * `equals` method works properly across different implementations
   * of the `Map` interface.
   *
   * @implSpec
   * This implementation first checks if the specified object is this map;
   * if so it returns `true`.  Then, it checks if the specified
   * object is a map whose size is identical to the size of this map; if
   * not, it returns `false`.  If so, it iterates over this map's
   * `entrySet` collection, and checks that the specified map
   * contains each mapping that this map contains.  If the specified map
   * fails to contain such a mapping, `false` is returned.  If the
   * iteration completes, `true` is returned.
   *
   * @param o object to be compared for equality with this map
   * @return `true` if the specified object is equal to this map
  */
  equals(o: any): boolean;
  /**
   * Returns the hash code value for this map.  The hash code of a map is
   * defined to be the sum of the hash codes of each entry in the map's
   * `entrySet()` view.  This ensures that `m1.equals(m2)`
   * implies that `m1.hashCode()==m2.hashCode()` for any two maps
   * `m1` and `m2`, as required by the general contract of
   * {@link Object#hashCode}.
   *
   * @implSpec
   * This implementation iterates over `entrySet()`, calling
   * {@link Map.Entry#hashCode hashCode()} on each element (entry) in the
   * set, and adding up the results.
   *
   * @return the hash code value for this map
   * @see Map.Entry#hashCode()
   * @see Object#equals(Object)
   * @see Set#equals(Object)
  */
  hashCode(): number;
  /**
   * Returns a string representation of this map.  The string representation
   * consists of a list of key-value mappings in the order returned by the
   * map's `entrySet` view's iterator, enclosed in braces
   * (`"{`"}).  Adjacent mappings are separated by the characters
   * `", "` (comma and space).  Each key-value mapping is rendered as
   * the key followed by an equals sign (`"="`) followed by the
   * associated value.  Keys and values are converted to strings as by
   * {@link String#valueOf(Object)}.
   *
   * @return a string representation of this map
  */
  toString(): string;
  /**
   * Removes the entry for the specified key only if it is currently
   * mapped to the specified value.
   *
   * @implSpec
   * The default implementation is equivalent to, for this `map`:
   *
   *  {@code
   * if (map.containsKey(key) && Objects.equals(map.get(key), value)) {
   *     map.remove(key);
   *     return true;
   * } else
   *     return false;
   * }
   *
   * The default implementation makes no guarantees about synchronization
   * or atomicity properties of this method. Any implementation providing
   * atomicity guarantees must override this method and document its
   * concurrency properties.
   *
   * @param key key with which the specified value is associated
   * @param value value expected to be associated with the specified key
   * @return `true` if the value was removed
   * @throws UnsupportedOperationException if the `remove` operation
   *         is not supported by this map
   *         (optional)
   * @throws ClassCastException if the key or value is of an inappropriate
   *         type for this map
   *         (optional)
   * @throws NullPointerException if the specified key or value is null,
   *         and this map does not permit null keys or values
   *         (optional)
   * @since 1.8
  */
  remove(key: any, value: any): boolean;
}
/**
 * A comparison function, which imposes a total ordering on some
 * collection of objects.  Comparators can be passed to a sort method (such
 * as {@link Collections#sort(List,Comparator) Collections.sort} or {@link
 * Arrays#sort(Object[],Comparator) Arrays.sort}) to allow precise control
 * over the sort order.  Comparators can also be used to control the order of
 * certain data structures (such as {@link SortedSet sorted sets} or {@link
 * SortedMap sorted maps}), or to provide an ordering for collections of
 * objects that don't have a {@link Comparable natural ordering}.
 *
 * The ordering imposed by a comparator `c` on a set of elements
 * `S` is said to be consistent with equals if and only if
 * `c.compare(e1, e2)==0` has the same boolean value as
 * `e1.equals(e2)` for every `e1` and `e2` in
 * `S`.
 *
 * Caution should be exercised when using a comparator capable of imposing an
 * ordering inconsistent with equals to order a sorted set (or sorted map).
 * Suppose a sorted set (or sorted map) with an explicit comparator `c`
 * is used with elements (or keys) drawn from a set `S`.  If the
 * ordering imposed by `c` on `S` is inconsistent with equals,
 * the sorted set (or sorted map) will behave "strangely."  In particular the
 * sorted set (or sorted map) will violate the general contract for set (or
 * map), which is defined in terms of `equals`.
 *
 * For example, suppose one adds two elements `a` and `b` such that
 * `(a.equals(b) && c.compare(a, b) != 0)`
 * to an empty `TreeSet` with comparator `c`.
 * The second `add` operation will return
 * true (and the size of the tree set will increase) because `a` and
 * `b` are not equivalent from the tree set's perspective, even though
 * this is contrary to the specification of the
 * {@link Set#add Set.add} method.
 *
 * Note: It is generally a good idea for comparators to also implement
 * `java.io.Serializable`, as they may be used as ordering methods in
 * serializable data structures (like {@link TreeSet}, {@link TreeMap}).  In
 * order for the data structure to serialize successfully, the comparator (if
 * provided) must implement `Serializable`.
 *
 * For the mathematically inclined, the relation that defines the
 * imposed ordering that a given comparator `c` imposes on a
 * given set of objects `S` is: *       {(x, y) such that c.compare(x, y) <= 0}.
 *  The quotient for this total order is: *       {(x, y) such that c.compare(x, y) == 0}.
 * 
 *
 * It follows immediately from the contract for `compare` that the
 * quotient is an equivalence relation on `S`, and that the
 * imposed ordering is a total order on `S`.  When we say that
 * the ordering imposed by `c` on `S` is consistent with
 * equals, we mean that the quotient for the ordering is the equivalence
 * relation defined by the objects' {@link Object#equals(Object)
 * equals(Object)} method(s): *     {(x, y) such that x.equals(y)}. 
 *
 * Unlike `Comparable`, a comparator may optionally permit
 * comparison of null arguments, while maintaining the requirements for
 * an equivalence relation.
 *
 * This interface is a member of the
 * 
 * Java Collections Framework.
 *
 * @param  the type of objects that may be compared by this comparator
 *
 * @author  Josh Bloch
 * @author  Neal Gafter
 * @see Comparable
 * @see java.io.Serializable
 * @since 1.2
*/
export class Comparator<T> {
  /**
   * Compares its two arguments for order.  Returns a negative integer,
   * zero, or a positive integer as the first argument is less than, equal
   * to, or greater than the second.
   *
   * The implementor must ensure that {@code sgn(compare(x, y)) ==
   * -sgn(compare(y, x))} for all `x` and `y`.  (This
   * implies that `compare(x, y)` must throw an exception if and only
   * if `compare(y, x)` throws an exception.)
   *
   * The implementor must also ensure that the relation is transitive:
   * `((compare(x, y)>0) && (compare(y, z)>0))` implies
   * `compare(x, z)>0`.
   *
   * Finally, the implementor must ensure that `compare(x, y)==0`
   * implies that `sgn(compare(x, z))==sgn(compare(y, z))` for all
   * `z`.
   *
   * It is generally the case, but not strictly required that
   * `(compare(x, y)==0) == (x.equals(y))`.  Generally speaking,
   * any comparator that violates this condition should clearly indicate
   * this fact.  The recommended language is "Note: this comparator
   * imposes orderings that are inconsistent with equals."
   *
   * In the foregoing description, the notation
   * `sgn(`expression`)` designates the mathematical
   * signum function, which is defined to return one of `-1`,
   * `0`, or `1` according to whether the value of
   * expression is negative, zero, or positive, respectively.
   *
   * @param o1 the first object to be compared.
   * @param o2 the second object to be compared.
   * @return a negative integer, zero, or a positive integer as the
   *         first argument is less than, equal to, or greater than the
   *         second.
   * @throws NullPointerException if an argument is null and this
   *         comparator does not permit null arguments
   * @throws ClassCastException if the arguments' types prevent them from
   *         being compared by this comparator.
  */
  compare(o1: T, o2: T): number;
  /**
   * Indicates whether some other object is "equal to" this
   * comparator.  This method must obey the general contract of
   * {@link Object#equals(Object)}.  Additionally, this method can return
   * `true` only if the specified object is also a comparator
   * and it imposes the same ordering as this comparator.  Thus,
   * `comp1.equals(comp2)` implies that {@code sgn(comp1.compare(o1,
   * o2))==sgn(comp2.compare(o1, o2))} for every object reference
   * `o1` and `o2`.
   *
   * Note that it is always safe not to override
   * `Object.equals(Object)`.  However, overriding this method may,
   * in some cases, improve performance by allowing programs to determine
   * that two distinct comparators impose the same order.
   *
   * @param   obj   the reference object with which to compare.
   * @return  `true` only if the specified object is also
   *          a comparator and it imposes the same ordering as this
   *          comparator.
   * @see Object#equals(Object)
   * @see Object#hashCode()
  */
  equals(obj: any): boolean;
  /**
   * Returns a comparator that imposes the reverse ordering of this
   * comparator.
   *
   * @return a comparator that imposes the reverse ordering of this
   *         comparator.
   * @since 1.8
  */
  reversed(): Comparator<T>;
  /**
   * Returns a lexicographic-order comparator with another comparator.
   * If this `Comparator` considers two elements equal, i.e.
   * `compare(a, b) == 0`, `other` is used to determine the order.
   *
   * The returned comparator is serializable if the specified comparator
   * is also serializable.
   *
   * @apiNote
   * For example, to sort a collection of `String` based on the length
   * and then case-insensitive natural ordering, the comparator can be
   * composed using following code,
   *
   * {@code
   *     Comparator cmp = Comparator.comparingInt(String::length)
   *             .thenComparing(String.CASE_INSENSITIVE_ORDER);
   * }
   *
   * @param  other the other comparator to be used when this comparator
   *         compares two objects that are equal.
   * @return a lexicographic-order comparator composed of this and then the
   *         other comparator
   * @throws NullPointerException if the argument is null.
   * @since 1.8
  */
  thenComparing(other: Comparator<any>): Comparator<T>;
  /**
   * Returns a lexicographic-order comparator with a function that
   * extracts a key to be compared with the given `Comparator`.
   *
   * @implSpec This default implementation behaves as if `     *           thenComparing(comparing(keyExtractor, cmp))`.
   *
   * @param    the type of the sort key
   * @param  keyExtractor the function used to extract the sort key
   * @param  keyComparator the `Comparator` used to compare the sort key
   * @return a lexicographic-order comparator composed of this comparator
   *         and then comparing on the key extracted by the keyExtractor function
   * @throws NullPointerException if either argument is null.
   * @see #comparing(Function, Comparator)
   * @see #thenComparing(Comparator)
   * @since 1.8
  */
  thenComparing<U>(keyExtractor: Function<any, U>, keyComparator: Comparator<any>): Comparator<T>;
  /**
   * Returns a lexicographic-order comparator with a function that
   * extracts a `Comparable` sort key.
   *
   * @implSpec This default implementation behaves as if `     *           thenComparing(comparing(keyExtractor))`.
   *
   * @param    the type of the {@link Comparable} sort key
   * @param  keyExtractor the function used to extract the {@link
   *         Comparable} sort key
   * @return a lexicographic-order comparator composed of this and then the
   *         {@link Comparable} sort key.
   * @throws NullPointerException if the argument is null.
   * @see #comparing(Function)
   * @see #thenComparing(Comparator)
   * @since 1.8
  */
  thenComparing<U>(keyExtractor: Function<any, U>): Comparator<T>;
  /**
   * Returns a lexicographic-order comparator with a function that
   * extracts an `int` sort key.
   *
   * @implSpec This default implementation behaves as if `     *           thenComparing(comparingInt(keyExtractor))`.
   *
   * @param  keyExtractor the function used to extract the integer sort key
   * @return a lexicographic-order comparator composed of this and then the
   *         `int` sort key
   * @throws NullPointerException if the argument is null.
   * @see #comparingInt(ToIntFunction)
   * @see #thenComparing(Comparator)
   * @since 1.8
  */
  thenComparingInt(keyExtractor: ToIntFunction<any>): Comparator<T>;
  /**
   * Returns a lexicographic-order comparator with a function that
   * extracts a `long` sort key.
   *
   * @implSpec This default implementation behaves as if `     *           thenComparing(comparingLong(keyExtractor))`.
   *
   * @param  keyExtractor the function used to extract the long sort key
   * @return a lexicographic-order comparator composed of this and then the
   *         `long` sort key
   * @throws NullPointerException if the argument is null.
   * @see #comparingLong(ToLongFunction)
   * @see #thenComparing(Comparator)
   * @since 1.8
  */
  thenComparingLong(keyExtractor: ToLongFunction<any>): Comparator<T>;
  /**
   * Returns a lexicographic-order comparator with a function that
   * extracts a `double` sort key.
   *
   * @implSpec This default implementation behaves as if `     *           thenComparing(comparingDouble(keyExtractor))`.
   *
   * @param  keyExtractor the function used to extract the double sort key
   * @return a lexicographic-order comparator composed of this and then the
   *         `double` sort key
   * @throws NullPointerException if the argument is null.
   * @see #comparingDouble(ToDoubleFunction)
   * @see #thenComparing(Comparator)
   * @since 1.8
  */
  thenComparingDouble(keyExtractor: ToDoubleFunction<any>): Comparator<T>;
  /**
   * Returns a comparator that imposes the reverse of the natural
   * ordering.
   *
   * The returned comparator is serializable and throws {@link
   * NullPointerException} when comparing `null`.
   *
   * @param   the {@link Comparable} type of element to be compared
   * @return a comparator that imposes the reverse of the natural
   *         ordering on `Comparable` objects.
   * @see Comparable
   * @since 1.8
  */
  static reverseOrder<T>(): Comparator<T>;
  /**
   * Returns a comparator that compares {@link Comparable} objects in natural
   * order.
   *
   * The returned comparator is serializable and throws {@link
   * NullPointerException} when comparing `null`.
   *
   * @param   the {@link Comparable} type of element to be compared
   * @return a comparator that imposes the natural ordering on `     *         Comparable` objects.
   * @see Comparable
   * @since 1.8
  */
  static naturalOrder<T>(): Comparator<T>;
  /**
   * Returns a null-friendly comparator that considers `null` to be
   * less than non-null. When both are `null`, they are considered
   * equal. If both are non-null, the specified `Comparator` is used
   * to determine the order. If the specified comparator is `null`,
   * then the returned comparator considers all non-null values to be equal.
   *
   * The returned comparator is serializable if the specified comparator
   * is serializable.
   *
   * @param   the type of the elements to be compared
   * @param  comparator a `Comparator` for comparing non-null values
   * @return a comparator that considers `null` to be less than
   *         non-null, and compares non-null objects with the supplied
   *         `Comparator`.
   * @since 1.8
  */
  static nullsFirst<T>(comparator: Comparator<any>): Comparator<T>;
  /**
   * Returns a null-friendly comparator that considers `null` to be
   * greater than non-null. When both are `null`, they are considered
   * equal. If both are non-null, the specified `Comparator` is used
   * to determine the order. If the specified comparator is `null`,
   * then the returned comparator considers all non-null values to be equal.
   *
   * The returned comparator is serializable if the specified comparator
   * is serializable.
   *
   * @param   the type of the elements to be compared
   * @param  comparator a `Comparator` for comparing non-null values
   * @return a comparator that considers `null` to be greater than
   *         non-null, and compares non-null objects with the supplied
   *         `Comparator`.
   * @since 1.8
  */
  static nullsLast<T>(comparator: Comparator<any>): Comparator<T>;
  /**
   * Accepts a function that extracts a sort key from a type `T`, and
   * returns a `Comparator` that compares by that sort key using
   * the specified {@link Comparator}.
   *
   * The returned comparator is serializable if the specified function
   * and comparator are both serializable.
   *
   * @apiNote
   * For example, to obtain a `Comparator` that compares `     * Person` objects by their last name ignoring case differences,
   *
   * {@code
   *     Comparator cmp = Comparator.comparing(
   *             Person::getLastName,
   *             String.CASE_INSENSITIVE_ORDER);
   * }
   *
   * @param   the type of element to be compared
   * @param   the type of the sort key
   * @param  keyExtractor the function used to extract the sort key
   * @param  keyComparator the `Comparator` used to compare the sort key
   * @return a comparator that compares by an extracted key using the
   *         specified `Comparator`
   * @throws NullPointerException if either argument is null
   * @since 1.8
  */
  static comparing<T, U>(keyExtractor: Function<any, U>, keyComparator: Comparator<any>): Comparator<T>;
  /**
   * Accepts a function that extracts a {@link java.lang.Comparable
   * Comparable} sort key from a type `T`, and returns a `     * Comparator` that compares by that sort key.
   *
   * The returned comparator is serializable if the specified function
   * is also serializable.
   *
   * @apiNote
   * For example, to obtain a `Comparator` that compares `     * Person` objects by their last name,
   *
   * {@code
   *     Comparator byLastName = Comparator.comparing(Person::getLastName);
   * }
   *
   * @param   the type of element to be compared
   * @param   the type of the `Comparable` sort key
   * @param  keyExtractor the function used to extract the {@link
   *         Comparable} sort key
   * @return a comparator that compares by an extracted key
   * @throws NullPointerException if the argument is null
   * @since 1.8
  */
  static comparing<T, U>(keyExtractor: Function<any, U>): Comparator<T>;
  /**
   * Accepts a function that extracts an `int` sort key from a type
   * `T`, and returns a `Comparator` that compares by that
   * sort key.
   *
   * The returned comparator is serializable if the specified function
   * is also serializable.
   *
   * @param   the type of element to be compared
   * @param  keyExtractor the function used to extract the integer sort key
   * @return a comparator that compares by an extracted key
   * @see #comparing(Function)
   * @throws NullPointerException if the argument is null
   * @since 1.8
  */
  static comparingInt<T>(keyExtractor: ToIntFunction<any>): Comparator<T>;
  /**
   * Accepts a function that extracts a `long` sort key from a type
   * `T`, and returns a `Comparator` that compares by that
   * sort key.
   *
   * The returned comparator is serializable if the specified function is
   * also serializable.
   *
   * @param   the type of element to be compared
   * @param  keyExtractor the function used to extract the long sort key
   * @return a comparator that compares by an extracted key
   * @see #comparing(Function)
   * @throws NullPointerException if the argument is null
   * @since 1.8
  */
  static comparingLong<T>(keyExtractor: ToLongFunction<any>): Comparator<T>;
  /**
   * Accepts a function that extracts a `double` sort key from a type
   * `T`, and returns a `Comparator` that compares by that
   * sort key.
   *
   * The returned comparator is serializable if the specified function
   * is also serializable.
   *
   * @param   the type of element to be compared
   * @param  keyExtractor the function used to extract the double sort key
   * @return a comparator that compares by an extracted key
   * @see #comparing(Function)
   * @throws NullPointerException if the argument is null
   * @since 1.8
  */
  static comparingDouble<T>(keyExtractor: ToDoubleFunction<any>): Comparator<T>;
}
/**
 * This class provides skeletal implementations of some {@link Queue}
 * operations. The implementations in this class are appropriate when
 * the base implementation does not allow `null`
 * elements.  Methods {@link #add add}, {@link #remove remove}, and
 * {@link #element element} are based on {@link #offer offer}, {@link
 * #poll poll}, and {@link #peek peek}, respectively, but throw
 * exceptions instead of indicating failure via `false` or
 * `null` returns.
 *
 * A `Queue` implementation that extends this class must
 * minimally define a method {@link Queue#offer} which does not permit
 * insertion of `null` elements, along with methods {@link
 * Queue#peek}, {@link Queue#poll}, {@link Collection#size}, and
 * {@link Collection#iterator}.  Typically, additional methods will be
 * overridden as well.  If these requirements cannot be met, consider
 * instead subclassing {@link AbstractCollection}.
 *
 * This class is a member of the
 * 
 * Java Collections Framework.
 *
 * @since 1.5
 * @author Doug Lea
 * @param  the type of elements held in this queue
*/
export class AbstractQueue<E> extends AbstractCollection<E> {
  /**
   * Inserts the specified element into this queue if it is possible to do so
   * immediately without violating capacity restrictions, returning
   * `true` upon success and throwing an `IllegalStateException`
   * if no space is currently available.
   *
   * This implementation returns `true` if `offer` succeeds,
   * else throws an `IllegalStateException`.
   *
   * @param e the element to add
   * @return `true` (as specified by {@link Collection#add})
   * @throws IllegalStateException if the element cannot be added at this
   *         time due to capacity restrictions
   * @throws ClassCastException if the class of the specified element
   *         prevents it from being added to this queue
   * @throws NullPointerException if the specified element is null and
   *         this queue does not permit null elements
   * @throws IllegalArgumentException if some property of this element
   *         prevents it from being added to this queue
  */
  add(e: E): boolean;
  /**
   * Retrieves and removes the head of this queue.  This method differs
   * from {@link #poll poll} only in that it throws an exception if this
   * queue is empty.
   *
   * This implementation returns the result of `poll`
   * unless the queue is empty.
   *
   * @return the head of this queue
   * @throws NoSuchElementException if this queue is empty
  */
  remove(): E;
  /**
   * Retrieves, but does not remove, the head of this queue.  This method
   * differs from {@link #peek peek} only in that it throws an exception if
   * this queue is empty.
   *
   * This implementation returns the result of `peek`
   * unless the queue is empty.
   *
   * @return the head of this queue
   * @throws NoSuchElementException if this queue is empty
  */
  element(): E;
  /**
   * Removes all of the elements from this queue.
   * The queue will be empty after this call returns.
   *
   * This implementation repeatedly invokes {@link #poll poll} until it
   * returns `null`.
  */
  clear(): void;
  /**
   * Adds all of the elements in the specified collection to this
   * queue.  Attempts to addAll of a queue to itself result in
   * `IllegalArgumentException`. Further, the behavior of
   * this operation is undefined if the specified collection is
   * modified while the operation is in progress.
   *
   * This implementation iterates over the specified collection,
   * and adds each element returned by the iterator to this
   * queue, in turn.  A runtime exception encountered while
   * trying to add an element (including, in particular, a
   * `null` element) may result in only some of the elements
   * having been successfully added when the associated exception is
   * thrown.
   *
   * @param c collection containing elements to be added to this queue
   * @return `true` if this queue changed as a result of the call
   * @throws ClassCastException if the class of an element of the specified
   *         collection prevents it from being added to this queue
   * @throws NullPointerException if the specified collection contains a
   *         null element and this queue does not permit null elements,
   *         or if the specified collection is null
   * @throws IllegalArgumentException if some property of an element of the
   *         specified collection prevents it from being added to this
   *         queue, or if the specified collection is this queue
   * @throws IllegalStateException if not all the elements can be added at
   *         this time due to insertion restrictions
   * @see #add(Object)
  */
  addAll(c: Collection<E>): boolean;
  /**
   * {@inheritDoc}
   *
   * @implSpec
   * This implementation iterates over the collection looking for the
   * specified element.  If it finds the element, it removes the element
   * from the collection using the iterator's remove method.
   *
   * Note that this implementation throws an
   * `UnsupportedOperationException` if the iterator returned by this
   * collection's iterator method does not implement the `remove`
   * method and this collection contains the specified object.
   *
   * @throws UnsupportedOperationException {@inheritDoc}
   * @throws ClassCastException            {@inheritDoc}
   * @throws NullPointerException          {@inheritDoc}
  */
  remove(o: any): boolean;
}
export interface AbstractQueue<E> extends AbstractCollection<E>, Queue<E> {}
/**
 * A state object for collecting statistics such as count, min, max, sum, and
 * average.
 *
 * This class is designed to work with (though does not require)
 * {@linkplain java.util.stream streams}. For example, you can compute
 * summary statistics on a stream of doubles with:
 *  {@code
 * DoubleSummaryStatistics stats = doubleStream.collect(DoubleSummaryStatistics::new,
 *                                                      DoubleSummaryStatistics::accept,
 *                                                      DoubleSummaryStatistics::combine);
 * }
 *
 * `DoubleSummaryStatistics` can be used as a
 * {@linkplain java.util.stream.Stream#collect(Collector) reduction}
 * target for a {@linkplain java.util.stream.Stream stream}. For example:
 *
 *  {@code
 * DoubleSummaryStatistics stats = people.stream()
 *     .collect(Collectors.summarizingDouble(Person::getWeight));
 *}
 *
 * This computes, in a single pass, the count of people, as well as the minimum,
 * maximum, sum, and average of their weights.
 *
 * @implNote This implementation is not thread safe. However, it is safe to use
 * {@link java.util.stream.Collectors#summarizingDouble(java.util.function.ToDoubleFunction)
 * Collectors.summarizingDouble()} on a parallel stream, because the parallel
 * implementation of {@link java.util.stream.Stream#collect Stream.collect()}
 * provides the necessary partitioning, isolation, and merging of results for
 * safe and efficient parallel execution.
 *
 * This implementation does not check for overflow of the count.
 * @since 1.8
*/
export class DoubleSummaryStatistics extends DoubleConsumer {
  /**
   * Constructs an empty instance with zero count, zero sum,
   * `Double.POSITIVE_INFINITY` min, `Double.NEGATIVE_INFINITY`
   * max and zero average.
  */
  constructor();
  /**
   * Constructs a non-empty instance with the specified `count`,
   * `min`, `max`, and `sum`.
   *
   * If `count` is zero then the remaining arguments are ignored and
   * an empty instance is constructed.
   *
   * If the arguments are inconsistent then an `IllegalArgumentException`
   * is thrown.  The necessary consistent argument conditions are:
   * 
   *   `count >= 0`
   *   `(min <= max && !isNaN(sum)) || (isNaN(min) && isNaN(max) && isNaN(sum))`
   * 
   * @apiNote
   * The enforcement of argument correctness means that the retrieved set of
   * recorded values obtained from a `DoubleSummaryStatistics` source
   * instance may not be a legal set of arguments for this constructor due to
   * arithmetic overflow of the source's recorded count of values.
   * The consistent argument conditions are not sufficient to prevent the
   * creation of an internally inconsistent instance.  An example of such a
   * state would be an instance with: `count` = 2, `min` = 1,
   * `max` = 2, and `sum` = 0.
   *
   * @param count the count of values
   * @param min the minimum value
   * @param max the maximum value
   * @param sum the sum of all values
   * @throws IllegalArgumentException if the arguments are inconsistent
   * @since 10
  */
  constructor(count: number, min: number, max: number, sum: number);
  /**
   * Records another value into the summary information.
   *
   * @param value the input value
  */
  accept(value: number): void;
  /**
   * Combines the state of another `DoubleSummaryStatistics` into this
   * one.
   *
   * @param other another `DoubleSummaryStatistics`
   * @throws NullPointerException if `other` is null
  */
  combine(other: DoubleSummaryStatistics): void;
  /**
   * Return the count of values recorded.
   *
   * @return the count of values
  */
  getCount(): number;
  /**
   * Returns the sum of values recorded, or zero if no values have been
   * recorded.
   *
   *  The value of a floating-point sum is a function both of the
   * input values as well as the order of addition operations. The
   * order of addition operations of this method is intentionally
   * not defined to allow for implementation flexibility to improve
   * the speed and accuracy of the computed result.
   *
   * In particular, this method may be implemented using compensated
   * summation or other technique to reduce the error bound in the
   * numerical sum compared to a simple summation of `double`
   * values.
   *
   * Because of the unspecified order of operations and the
   * possibility of using differing summation schemes, the output of
   * this method may vary on the same input values.
   *
   * Various conditions can result in a non-finite sum being
   * computed. This can occur even if the all the recorded values
   * being summed are finite. If any recorded value is non-finite,
   * the sum will be non-finite:
   *
   * 
   *
   * If any recorded value is a NaN, then the final sum will be
   * NaN.
   *
   * If the recorded values contain one or more infinities, the
   * sum will be infinite or NaN.
   *
   * 
   *
   * If the recorded values contain infinities of opposite sign,
   * the sum will be NaN.
   *
   * If the recorded values contain infinities of one sign and
   * an intermediate sum overflows to an infinity of the opposite
   * sign, the sum may be NaN.
   *
   * 
   *
   * 
   *
   * It is possible for intermediate sums of finite values to
   * overflow into opposite-signed infinities; if that occurs, the
   * final sum will be NaN even if the recorded values are all
   * finite.
   *
   * If all the recorded values are zero, the sign of zero is
   * not guaranteed to be preserved in the final sum.
   *
   * @apiNote Values sorted by increasing absolute magnitude tend to yield
   * more accurate results.
   *
   * @return the sum of values, or zero if none
  */
  getSum(): number;
  /**
   * Returns the minimum recorded value, `Double.NaN` if any recorded
   * value was NaN or `Double.POSITIVE_INFINITY` if no values were
   * recorded. Unlike the numerical comparison operators, this method
   * considers negative zero to be strictly smaller than positive zero.
   *
   * @return the minimum recorded value, `Double.NaN` if any recorded
   * value was NaN or `Double.POSITIVE_INFINITY` if no values were
   * recorded
  */
  getMin(): number;
  /**
   * Returns the maximum recorded value, `Double.NaN` if any recorded
   * value was NaN or `Double.NEGATIVE_INFINITY` if no values were
   * recorded. Unlike the numerical comparison operators, this method
   * considers negative zero to be strictly smaller than positive zero.
   *
   * @return the maximum recorded value, `Double.NaN` if any recorded
   * value was NaN or `Double.NEGATIVE_INFINITY` if no values were
   * recorded
  */
  getMax(): number;
  /**
   * Returns the arithmetic mean of values recorded, or zero if no
   * values have been recorded.
   *
   *  The computed average can vary numerically and have the
   * special case behavior as computing the sum; see {@link #getSum}
   * for details.
   *
   * @apiNote Values sorted by increasing absolute magnitude tend to yield
   * more accurate results.
   *
   * @return the arithmetic mean of values, or zero if none
  */
  getAverage(): number;
  /**
   * Returns a non-empty string representation of this object suitable for
   * debugging. The exact presentation format is unspecified and may vary
   * between implementations and versions.
  */
  toString(): string;
}
/**
 * Unchecked exception thrown when duplicate flags are provided in the format
 * specifier.
 *
 *  Unless otherwise specified, passing a `null` argument to any
 * method or constructor in this class will cause a {@link
 * NullPointerException} to be thrown.
 *
 * @since 1.5
*/
export class DuplicateFormatFlagsException extends IllegalFormatException {
  /**
   * Constructs an instance of this class with the specified flags.
   *
   * @param  f
   *         The set of format flags which contain a duplicate flag.
  */
  constructor(f: string);
  /**
   * Returns the set of flags which contains a duplicate flag.
   *
   * @return  The flags
  */
  getFlags(): string;
  getMessage(): string;
}
/**
 * Unchecked exception thrown when the format width is required.
 *
 *  Unless otherwise specified, passing a `null` argument to any
 * method or constructor in this class will cause a {@link
 * NullPointerException} to be thrown.
 *
 * @since 1.5
*/
export class MissingFormatWidthException extends IllegalFormatException {
  /**
   * Constructs an instance of this class with the specified format
   * specifier.
   *
   * @param  s
   *         The format specifier which does not have a width
  */
  constructor(s: string);
  /**
   * Returns the format specifier which does not have a width.
   *
   * @return  The format specifier which does not have a width
  */
  getFormatSpecifier(): string;
  getMessage(): string;
}
/**
 * FormattableFlags are passed to the {@link Formattable#formatTo
 * Formattable.formatTo()} method and modify the output format for {@linkplain
 * Formattable Formattables}.  Implementations of {@link Formattable} are
 * responsible for interpreting and validating any flags.
 *
 * @since  1.5
*/
export class FormattableFlags {
  static readonly LEFT_JUSTIFY: number;
  static readonly UPPERCASE: number;
  static readonly ALTERNATE: number;
}
export class Set<E> extends Collection<E> {
  /**
   * Returns the number of elements in this set (its cardinality).  If this
   * set contains more than `Integer.MAX_VALUE` elements, returns
   * `Integer.MAX_VALUE`.
   *
   * @return the number of elements in this set (its cardinality)
  */
  size(): number;
  /**
   * Returns `true` if this set contains no elements.
   *
   * @return `true` if this set contains no elements
  */
  isEmpty(): boolean;
  /**
   * Returns `true` if this set contains the specified element.
   * More formally, returns `true` if and only if this set
   * contains an element `e` such that
   * `Objects.equals(o, e)`.
   *
   * @param o element whose presence in this set is to be tested
   * @return `true` if this set contains the specified element
   * @throws ClassCastException if the type of the specified element
   *         is incompatible with this set
   * (optional)
   * @throws NullPointerException if the specified element is null and this
   *         set does not permit null elements
   * (optional)
  */
  contains(o: any): boolean;
  /**
   * Returns an iterator over the elements in this set.  The elements are
   * returned in no particular order (unless this set is an instance of some
   * class that provides a guarantee).
   *
   * @return an iterator over the elements in this set
  */
  iterator(): Iterator<E>;
  /**
   * Returns an array containing all of the elements in this set.
   * If this set makes any guarantees as to what order its elements
   * are returned by its iterator, this method must return the
   * elements in the same order.
   *
   * The returned array will be "safe" in that no references to it
   * are maintained by this set.  (In other words, this method must
   * allocate a new array even if this set is backed by an array).
   * The caller is thus free to modify the returned array.
   *
   * This method acts as bridge between array-based and collection-based
   * APIs.
   *
   * @return an array containing all the elements in this set
  */
  toArray(): any[];
  /**
   * Returns an array containing all of the elements in this set; the
   * runtime type of the returned array is that of the specified array.
   * If the set fits in the specified array, it is returned therein.
   * Otherwise, a new array is allocated with the runtime type of the
   * specified array and the size of this set.
   *
   * If this set fits in the specified array with room to spare
   * (i.e., the array has more elements than this set), the element in
   * the array immediately following the end of the set is set to
   * `null`.  (This is useful in determining the length of this
   * set only if the caller knows that this set does not contain
   * any null elements.)
   *
   * If this set makes any guarantees as to what order its elements
   * are returned by its iterator, this method must return the elements
   * in the same order.
   *
   * Like the {@link #toArray()} method, this method acts as bridge between
   * array-based and collection-based APIs.  Further, this method allows
   * precise control over the runtime type of the output array, and may,
   * under certain circumstances, be used to save allocation costs.
   *
   * Suppose `x` is a set known to contain only strings.
   * The following code can be used to dump the set into a newly allocated
   * array of `String`:
   *
   *      *     String[] y = x.toArray(new String[0]);
   *
   * Note that `toArray(new Object[0])` is identical in function to
   * `toArray()`.
   *
   * @param a the array into which the elements of this set are to be
   *        stored, if it is big enough; otherwise, a new array of the same
   *        runtime type is allocated for this purpose.
   * @return an array containing all the elements in this set
   * @throws ArrayStoreException if the runtime type of the specified array
   *         is not a supertype of the runtime type of every element in this
   *         set
   * @throws NullPointerException if the specified array is null
  */
  toArray<T>(a: T[]): T[];
  /**
   * Adds the specified element to this set if it is not already present
   * (optional operation).  More formally, adds the specified element
   * `e` to this set if the set contains no element `e2`
   * such that
   * `Objects.equals(e, e2)`.
   * If this set already contains the element, the call leaves the set
   * unchanged and returns `false`.  In combination with the
   * restriction on constructors, this ensures that sets never contain
   * duplicate elements.
   *
   * The stipulation above does not imply that sets must accept all
   * elements; sets may refuse to add any particular element, including
   * `null`, and throw an exception, as described in the
   * specification for {@link Collection#add Collection.add}.
   * Individual set implementations should clearly document any
   * restrictions on the elements that they may contain.
   *
   * @param e element to be added to this set
   * @return `true` if this set did not already contain the specified
   *         element
   * @throws UnsupportedOperationException if the `add` operation
   *         is not supported by this set
   * @throws ClassCastException if the class of the specified element
   *         prevents it from being added to this set
   * @throws NullPointerException if the specified element is null and this
   *         set does not permit null elements
   * @throws IllegalArgumentException if some property of the specified element
   *         prevents it from being added to this set
  */
  add(e: E): boolean;
  /**
   * Removes the specified element from this set if it is present
   * (optional operation).  More formally, removes an element `e`
   * such that
   * `Objects.equals(o, e)`, if
   * this set contains such an element.  Returns `true` if this set
   * contained the element (or equivalently, if this set changed as a
   * result of the call).  (This set will not contain the element once the
   * call returns.)
   *
   * @param o object to be removed from this set, if present
   * @return `true` if this set contained the specified element
   * @throws ClassCastException if the type of the specified element
   *         is incompatible with this set
   * (optional)
   * @throws NullPointerException if the specified element is null and this
   *         set does not permit null elements
   * (optional)
   * @throws UnsupportedOperationException if the `remove` operation
   *         is not supported by this set
  */
  remove(o: any): boolean;
  /**
   * Returns `true` if this set contains all of the elements of the
   * specified collection.  If the specified collection is also a set, this
   * method returns `true` if it is a subset of this set.
   *
   * @param  c collection to be checked for containment in this set
   * @return `true` if this set contains all of the elements of the
   *         specified collection
   * @throws ClassCastException if the types of one or more elements
   *         in the specified collection are incompatible with this
   *         set
   * (optional)
   * @throws NullPointerException if the specified collection contains one
   *         or more null elements and this set does not permit null
   *         elements
   * (optional),
   *         or if the specified collection is null
   * @see    #contains(Object)
  */
  containsAll(c: Collection<any>): boolean;
  /**
   * Adds all of the elements in the specified collection to this set if
   * they're not already present (optional operation).  If the specified
   * collection is also a set, the `addAll` operation effectively
   * modifies this set so that its value is the union of the two
   * sets.  The behavior of this operation is undefined if the specified
   * collection is modified while the operation is in progress.
   *
   * @param  c collection containing elements to be added to this set
   * @return `true` if this set changed as a result of the call
   *
   * @throws UnsupportedOperationException if the `addAll` operation
   *         is not supported by this set
   * @throws ClassCastException if the class of an element of the
   *         specified collection prevents it from being added to this set
   * @throws NullPointerException if the specified collection contains one
   *         or more null elements and this set does not permit null
   *         elements, or if the specified collection is null
   * @throws IllegalArgumentException if some property of an element of the
   *         specified collection prevents it from being added to this set
   * @see #add(Object)
  */
  addAll(c: Collection<E>): boolean;
  /**
   * Retains only the elements in this set that are contained in the
   * specified collection (optional operation).  In other words, removes
   * from this set all of its elements that are not contained in the
   * specified collection.  If the specified collection is also a set, this
   * operation effectively modifies this set so that its value is the
   * intersection of the two sets.
   *
   * @param  c collection containing elements to be retained in this set
   * @return `true` if this set changed as a result of the call
   * @throws UnsupportedOperationException if the `retainAll` operation
   *         is not supported by this set
   * @throws ClassCastException if the class of an element of this set
   *         is incompatible with the specified collection
   * (optional)
   * @throws NullPointerException if this set contains a null element and the
   *         specified collection does not permit null elements
   *         (optional),
   *         or if the specified collection is null
   * @see #remove(Object)
  */
  retainAll(c: Collection<any>): boolean;
  /**
   * Removes from this set all of its elements that are contained in the
   * specified collection (optional operation).  If the specified
   * collection is also a set, this operation effectively modifies this
   * set so that its value is the asymmetric set difference of
   * the two sets.
   *
   * @param  c collection containing elements to be removed from this set
   * @return `true` if this set changed as a result of the call
   * @throws UnsupportedOperationException if the `removeAll` operation
   *         is not supported by this set
   * @throws ClassCastException if the class of an element of this set
   *         is incompatible with the specified collection
   * (optional)
   * @throws NullPointerException if this set contains a null element and the
   *         specified collection does not permit null elements
   *         (optional),
   *         or if the specified collection is null
   * @see #remove(Object)
   * @see #contains(Object)
  */
  removeAll(c: Collection<any>): boolean;
  /**
   * Removes all of the elements from this set (optional operation).
   * The set will be empty after this call returns.
   *
   * @throws UnsupportedOperationException if the `clear` method
   *         is not supported by this set
  */
  clear(): void;
  /**
   * Compares the specified object with this set for equality.  Returns
   * `true` if the specified object is also a set, the two sets
   * have the same size, and every member of the specified set is
   * contained in this set (or equivalently, every member of this set is
   * contained in the specified set).  This definition ensures that the
   * equals method works properly across different implementations of the
   * set interface.
   *
   * @param o object to be compared for equality with this set
   * @return `true` if the specified object is equal to this set
  */
  equals(o: any): boolean;
  /**
   * Returns the hash code value for this set.  The hash code of a set is
   * defined to be the sum of the hash codes of the elements in the set,
   * where the hash code of a `null` element is defined to be zero.
   * This ensures that `s1.equals(s2)` implies that
   * `s1.hashCode()==s2.hashCode()` for any two sets `s1`
   * and `s2`, as required by the general contract of
   * {@link Object#hashCode}.
   *
   * @return the hash code value for this set
   * @see Object#equals(Object)
   * @see Set#equals(Object)
  */
  hashCode(): number;
  /**
   * Creates a `Spliterator` over the elements in this set.
   *
   * The `Spliterator` reports {@link Spliterator#DISTINCT}.
   * Implementations should document the reporting of additional
   * characteristic values.
   *
   * @implSpec
   * The default implementation creates a
   * late-binding spliterator
   * from the set's `Iterator`.  The spliterator inherits the
   * fail-fast properties of the set's iterator.
   * 
   * The created `Spliterator` additionally reports
   * {@link Spliterator#SIZED}.
   *
   * @implNote
   * The created `Spliterator` additionally reports
   * {@link Spliterator#SUBSIZED}.
   *
   * @return a `Spliterator` over the elements in this set
   * @since 1.8
  */
  spliterator(): Spliterator<E>;
  /**
   * Returns an unmodifiable set containing zero elements.
   * See Unmodifiable Sets for details.
   *
   * @param  the `Set`'s element type
   * @return an empty `Set`
   *
   * @since 9
  */
  static of<E>(): Set<E>;
  /**
   * Returns an unmodifiable set containing one element.
   * See Unmodifiable Sets for details.
   *
   * @param  the `Set`'s element type
   * @param e1 the single element
   * @return a `Set` containing the specified element
   * @throws NullPointerException if the element is `null`
   *
   * @since 9
  */
  static of<E>(e1: E): Set<E>;
  /**
   * Returns an unmodifiable set containing two elements.
   * See Unmodifiable Sets for details.
   *
   * @param  the `Set`'s element type
   * @param e1 the first element
   * @param e2 the second element
   * @return a `Set` containing the specified elements
   * @throws IllegalArgumentException if the elements are duplicates
   * @throws NullPointerException if an element is `null`
   *
   * @since 9
  */
  static of<E>(e1: E, e2: E): Set<E>;
  /**
   * Returns an unmodifiable set containing three elements.
   * See Unmodifiable Sets for details.
   *
   * @param  the `Set`'s element type
   * @param e1 the first element
   * @param e2 the second element
   * @param e3 the third element
   * @return a `Set` containing the specified elements
   * @throws IllegalArgumentException if there are any duplicate elements
   * @throws NullPointerException if an element is `null`
   *
   * @since 9
  */
  static of<E>(e1: E, e2: E, e3: E): Set<E>;
  /**
   * Returns an unmodifiable set containing four elements.
   * See Unmodifiable Sets for details.
   *
   * @param  the `Set`'s element type
   * @param e1 the first element
   * @param e2 the second element
   * @param e3 the third element
   * @param e4 the fourth element
   * @return a `Set` containing the specified elements
   * @throws IllegalArgumentException if there are any duplicate elements
   * @throws NullPointerException if an element is `null`
   *
   * @since 9
  */
  static of<E>(e1: E, e2: E, e3: E, e4: E): Set<E>;
  /**
   * Returns an unmodifiable set containing five elements.
   * See Unmodifiable Sets for details.
   *
   * @param  the `Set`'s element type
   * @param e1 the first element
   * @param e2 the second element
   * @param e3 the third element
   * @param e4 the fourth element
   * @param e5 the fifth element
   * @return a `Set` containing the specified elements
   * @throws IllegalArgumentException if there are any duplicate elements
   * @throws NullPointerException if an element is `null`
   *
   * @since 9
  */
  static of<E>(e1: E, e2: E, e3: E, e4: E, e5: E): Set<E>;
  /**
   * Returns an unmodifiable set containing six elements.
   * See Unmodifiable Sets for details.
   *
   * @param  the `Set`'s element type
   * @param e1 the first element
   * @param e2 the second element
   * @param e3 the third element
   * @param e4 the fourth element
   * @param e5 the fifth element
   * @param e6 the sixth element
   * @return a `Set` containing the specified elements
   * @throws IllegalArgumentException if there are any duplicate elements
   * @throws NullPointerException if an element is `null`
   *
   * @since 9
  */
  static of<E>(e1: E, e2: E, e3: E, e4: E, e5: E, e6: E): Set<E>;
  /**
   * Returns an unmodifiable set containing seven elements.
   * See Unmodifiable Sets for details.
   *
   * @param  the `Set`'s element type
   * @param e1 the first element
   * @param e2 the second element
   * @param e3 the third element
   * @param e4 the fourth element
   * @param e5 the fifth element
   * @param e6 the sixth element
   * @param e7 the seventh element
   * @return a `Set` containing the specified elements
   * @throws IllegalArgumentException if there are any duplicate elements
   * @throws NullPointerException if an element is `null`
   *
   * @since 9
  */
  static of<E>(e1: E, e2: E, e3: E, e4: E, e5: E, e6: E, e7: E): Set<E>;
  /**
   * Returns an unmodifiable set containing eight elements.
   * See Unmodifiable Sets for details.
   *
   * @param  the `Set`'s element type
   * @param e1 the first element
   * @param e2 the second element
   * @param e3 the third element
   * @param e4 the fourth element
   * @param e5 the fifth element
   * @param e6 the sixth element
   * @param e7 the seventh element
   * @param e8 the eighth element
   * @return a `Set` containing the specified elements
   * @throws IllegalArgumentException if there are any duplicate elements
   * @throws NullPointerException if an element is `null`
   *
   * @since 9
  */
  static of<E>(e1: E, e2: E, e3: E, e4: E, e5: E, e6: E, e7: E, e8: E): Set<E>;
  /**
   * Returns an unmodifiable set containing nine elements.
   * See Unmodifiable Sets for details.
   *
   * @param  the `Set`'s element type
   * @param e1 the first element
   * @param e2 the second element
   * @param e3 the third element
   * @param e4 the fourth element
   * @param e5 the fifth element
   * @param e6 the sixth element
   * @param e7 the seventh element
   * @param e8 the eighth element
   * @param e9 the ninth element
   * @return a `Set` containing the specified elements
   * @throws IllegalArgumentException if there are any duplicate elements
   * @throws NullPointerException if an element is `null`
   *
   * @since 9
  */
  static of<E>(e1: E, e2: E, e3: E, e4: E, e5: E, e6: E, e7: E, e8: E, e9: E): Set<E>;
  /**
   * Returns an unmodifiable set containing ten elements.
   * See Unmodifiable Sets for details.
   *
   * @param  the `Set`'s element type
   * @param e1 the first element
   * @param e2 the second element
   * @param e3 the third element
   * @param e4 the fourth element
   * @param e5 the fifth element
   * @param e6 the sixth element
   * @param e7 the seventh element
   * @param e8 the eighth element
   * @param e9 the ninth element
   * @param e10 the tenth element
   * @return a `Set` containing the specified elements
   * @throws IllegalArgumentException if there are any duplicate elements
   * @throws NullPointerException if an element is `null`
   *
   * @since 9
  */
  static of<E>(e1: E, e2: E, e3: E, e4: E, e5: E, e6: E, e7: E, e8: E, e9: E, e10: E): Set<E>;
  /**
   * Returns an unmodifiable set containing an arbitrary number of elements.
   * See Unmodifiable Sets for details.
   *
   * @apiNote
   * This method also accepts a single array as an argument. The element type of
   * the resulting set will be the component type of the array, and the size of
   * the set will be equal to the length of the array. To create a set with
   * a single element that is an array, do the following:
   *
   * {@code
   *     String[] array = ... ;
   *     Set list = Set.of(array);
   * }
   *
   * This will cause the {@link Set#of(Object) Set.of(E)} method
   * to be invoked instead.
   *
   * @param  the `Set`'s element type
   * @param elements the elements to be contained in the set
   * @return a `Set` containing the specified elements
   * @throws IllegalArgumentException if there are any duplicate elements
   * @throws NullPointerException if an element is `null` or if the array is `null`
   *
   * @since 9
  */
  static of<E>(...elements: E[]): Set<E>;
  /**
   * Returns an unmodifiable Set containing the elements
   * of the given Collection. The given Collection must not be null, and it must not
   * contain any null elements. If the given Collection contains duplicate elements,
   * an arbitrary element of the duplicates is preserved. If the given Collection is
   * subsequently modified, the returned Set will not reflect such modifications.
   *
   * @implNote
   * If the given Collection is an unmodifiable Set,
   * calling copyOf will generally not create a copy.
   *
   * @param  the `Set`'s element type
   * @param coll a `Collection` from which elements are drawn, must be non-null
   * @return a `Set` containing the elements of the given `Collection`
   * @throws NullPointerException if coll is null, or if it contains any nulls
   * @since 10
  */
  static copyOf<E>(coll: Collection<E>): Set<E>;
  /**
   * Returns an array containing all of the elements in this collection,
   * using the provided `generator` function to allocate the returned array.
   *
   * If this collection makes any guarantees as to what order its elements
   * are returned by its iterator, this method must return the elements in
   * the same order.
   *
   * @apiNote
   * This method acts as a bridge between array-based and collection-based APIs.
   * It allows creation of an array of a particular runtime type. Use
   * {@link #toArray()} to create an array whose runtime type is `Object[]`,
   * or use {@link #toArray(Object[]) toArray(T[])} to reuse an existing array.
   *
   * Suppose `x` is a collection known to contain only strings.
   * The following code can be used to dump the collection into a newly
   * allocated array of `String`:
   *
   *      *     String[] y = x.toArray(String[]::new);
   *
   * @implSpec
   * The default implementation calls the generator function with zero
   * and then passes the resulting array to {@link #toArray(Object[]) toArray(T[])}.
   *
   * @param  the component type of the array to contain the collection
   * @param generator a function which produces a new array of the desired
   *                  type and the provided length
   * @return an array containing all of the elements in this collection
   * @throws ArrayStoreException if the runtime type of any element in this
   *         collection is not assignable to the {@linkplain Class#getComponentType
   *         runtime component type} of the generated array
   * @throws NullPointerException if the generator function is null
   * @since 11
  */
  toArray<T>(generator: IntFunction<T[]>): T[];
}
/**
 * The `Dictionary` class is the abstract parent of any
 * class, such as `Hashtable`, which maps keys to values.
 * Every key and every value is an object. In any one `Dictionary`
 * object, every key is associated with at most one value. Given a
 * `Dictionary` and a key, the associated element can be looked up.
 * Any non-`null` object can be used as a key and as a value.
 * 
 * As a rule, the `equals` method should be used by
 * implementations of this class to decide if two keys are the same.
 * 
 * NOTE: This class is obsolete.  New implementations should
 * implement the Map interface, rather than extending this class.
 *
 * @see     java.util.Map
 * @see     java.lang.Object#equals(java.lang.Object)
 * @see     java.lang.Object#hashCode()
 * @see     java.util.Hashtable
 * @since   1.0
*/
export class Dictionary<K, V> {
  /**
   * Sole constructor.  (For invocation by subclass constructors, typically
   * implicit.)
  */
  constructor();
  /**
   * Returns the number of entries (distinct keys) in this dictionary.
   *
   * @return  the number of keys in this dictionary.
  */
  size(): number;
  /**
   * Tests if this dictionary maps no keys to value. The general contract
   * for the `isEmpty` method is that the result is true if and only
   * if this dictionary contains no entries.
   *
   * @return  `true` if this dictionary maps no keys to values;
   *          `false` otherwise.
  */
  isEmpty(): boolean;
  /**
   * Returns an enumeration of the keys in this dictionary. The general
   * contract for the keys method is that an `Enumeration` object
   * is returned that will generate all the keys for which this dictionary
   * contains entries.
   *
   * @return  an enumeration of the keys in this dictionary.
   * @see     java.util.Dictionary#elements()
   * @see     java.util.Enumeration
  */
  keys(): Enumeration<K>;
  /**
   * Returns an enumeration of the values in this dictionary. The general
   * contract for the `elements` method is that an
   * `Enumeration` is returned that will generate all the elements
   * contained in entries in this dictionary.
   *
   * @return  an enumeration of the values in this dictionary.
   * @see     java.util.Dictionary#keys()
   * @see     java.util.Enumeration
  */
  elements(): Enumeration<V>;
  /**
   * Returns the value to which the key is mapped in this dictionary.
   * The general contract for the `isEmpty` method is that if this
   * dictionary contains an entry for the specified key, the associated
   * value is returned; otherwise, `null` is returned.
   *
   * @return  the value to which the key is mapped in this dictionary;
   * @param   key   a key in this dictionary.
   *          `null` if the key is not mapped to any value in
   *          this dictionary.
   * @throws    NullPointerException if the `key` is `null`.
   * @see     java.util.Dictionary#put(java.lang.Object, java.lang.Object)
  */
  get(key: any): V;
  /**
   * Maps the specified `key` to the specified
   * `value` in this dictionary. Neither the key nor the
   * value can be `null`.
   * 
   * If this dictionary already contains an entry for the specified
   * `key`, the value already in this dictionary for that
   * `key` is returned, after modifying the entry to contain the
   *  new element. If this dictionary does not already have an entry
   *  for the specified `key`, an entry is created for the
   *  specified `key` and `value`, and `null` is
   *  returned.
   * 
   * The `value` can be retrieved by calling the
   * `get` method with a `key` that is equal to
   * the original `key`.
   *
   * @param      key     the hashtable key.
   * @param      value   the value.
   * @return     the previous value to which the `key` was mapped
   *             in this dictionary, or `null` if the key did not
   *             have a previous mapping.
   * @throws     NullPointerException  if the `key` or
   *               `value` is `null`.
   * @see        java.lang.Object#equals(java.lang.Object)
   * @see        java.util.Dictionary#get(java.lang.Object)
  */
  put(key: K, value: V): V;
  /**
   * Removes the `key` (and its corresponding
   * `value`) from this dictionary. This method does nothing
   * if the `key` is not in this dictionary.
   *
   * @param   key   the key that needs to be removed.
   * @return  the value to which the `key` had been mapped in this
   *          dictionary, or `null` if the key did not have a
   *          mapping.
   * @throws    NullPointerException if `key` is `null`.
  */
  remove(key: any): V;
}
/**
 * Marker interface used by `List` implementations to indicate that
 * they support fast (generally constant time) random access.  The primary
 * purpose of this interface is to allow generic algorithms to alter their
 * behavior to provide good performance when applied to either random or
 * sequential access lists.
 *
 * The best algorithms for manipulating random access lists (such as
 * `ArrayList`) can produce quadratic behavior when applied to
 * sequential access lists (such as `LinkedList`).  Generic list
 * algorithms are encouraged to check whether the given list is an
 * `instanceof` this interface before applying an algorithm that would
 * provide poor performance if it were applied to a sequential access list,
 * and to alter their behavior if necessary to guarantee acceptable
 * performance.
 *
 * It is recognized that the distinction between random and sequential
 * access is often fuzzy.  For example, some `List` implementations
 * provide asymptotically linear access times if they get huge, but constant
 * access times in practice.  Such a `List` implementation
 * should generally implement this interface.  As a rule of thumb, a
 * `List` implementation should implement this interface if,
 * for typical instances of the class, this loop:
 *  *     for (int i=0, n=list.size(); i < n; i++)
 *         list.get(i);
 * 
 * runs faster than this loop:
 *  *     for (Iterator i=list.iterator(); i.hasNext(); )
 *         i.next();
 * 
 *
 * This interface is a member of the
 * 
 * Java Collections Framework.
 *
 * @since 1.4
*/
export class RandomAccess {

}
/**
 * Unchecked exception thrown when the formatter has been closed.
 *
 *  Unless otherwise specified, passing a `null` argument to any
 * method or constructor in this class will cause a {@link
 * NullPointerException} to be thrown.
 *
 * @since 1.5
*/
export class FormatterClosedException extends IllegalStateException {
  /**
   * Constructs an instance of this class.
  */
  constructor();
}
export class AbstractList<E> extends AbstractCollection<E> {
  /**
   * Appends the specified element to the end of this list (optional
   * operation).
   *
   * Lists that support this operation may place limitations on what
   * elements may be added to this list.  In particular, some
   * lists will refuse to add null elements, and others will impose
   * restrictions on the type of elements that may be added.  List
   * classes should clearly specify in their documentation any restrictions
   * on what elements may be added.
   *
   * @implSpec
   * This implementation calls `add(size(), e)`.
   *
   * Note that this implementation throws an
   * `UnsupportedOperationException` unless
   * {@link #add(int, Object) add(int, E)} is overridden.
   *
   * @param e element to be appended to this list
   * @return `true` (as specified by {@link Collection#add})
   * @throws UnsupportedOperationException if the `add` operation
   *         is not supported by this list
   * @throws ClassCastException if the class of the specified element
   *         prevents it from being added to this list
   * @throws NullPointerException if the specified element is null and this
   *         list does not permit null elements
   * @throws IllegalArgumentException if some property of this element
   *         prevents it from being added to this list
  */
  add(e: E): boolean;
  /**
   * {@inheritDoc}
   *
   * @throws IndexOutOfBoundsException {@inheritDoc}
  */
  get(index: number): E;
  /**
   * {@inheritDoc}
   *
   * @implSpec
   * This implementation always throws an
   * `UnsupportedOperationException`.
   *
   * @throws UnsupportedOperationException {@inheritDoc}
   * @throws ClassCastException            {@inheritDoc}
   * @throws NullPointerException          {@inheritDoc}
   * @throws IllegalArgumentException      {@inheritDoc}
   * @throws IndexOutOfBoundsException     {@inheritDoc}
  */
  set(index: number, element: E): E;
  /**
   * {@inheritDoc}
   *
   * @implSpec
   * This implementation always throws an
   * `UnsupportedOperationException`.
   *
   * @throws UnsupportedOperationException {@inheritDoc}
   * @throws ClassCastException            {@inheritDoc}
   * @throws NullPointerException          {@inheritDoc}
   * @throws IllegalArgumentException      {@inheritDoc}
   * @throws IndexOutOfBoundsException     {@inheritDoc}
  */
  add(index: number, element: E): void;
  /**
   * {@inheritDoc}
   *
   * @implSpec
   * This implementation always throws an
   * `UnsupportedOperationException`.
   *
   * @throws UnsupportedOperationException {@inheritDoc}
   * @throws IndexOutOfBoundsException     {@inheritDoc}
  */
  remove(index: number): E;
  /**
   * {@inheritDoc}
   *
   * @implSpec
   * This implementation first gets a list iterator (with
   * `listIterator()`).  Then, it iterates over the list until the
   * specified element is found or the end of the list is reached.
   *
   * @throws ClassCastException   {@inheritDoc}
   * @throws NullPointerException {@inheritDoc}
  */
  indexOf(o: any): number;
  /**
   * {@inheritDoc}
   *
   * @implSpec
   * This implementation first gets a list iterator that points to the end
   * of the list (with `listIterator(size())`).  Then, it iterates
   * backwards over the list until the specified element is found, or the
   * beginning of the list is reached.
   *
   * @throws ClassCastException   {@inheritDoc}
   * @throws NullPointerException {@inheritDoc}
  */
  lastIndexOf(o: any): number;
  /**
   * Removes all of the elements from this list (optional operation).
   * The list will be empty after this call returns.
   *
   * @implSpec
   * This implementation calls `removeRange(0, size())`.
   *
   * Note that this implementation throws an
   * `UnsupportedOperationException` unless {@code remove(int
   * index)} or `removeRange(int fromIndex, int toIndex)` is
   * overridden.
   *
   * @throws UnsupportedOperationException if the `clear` operation
   *         is not supported by this list
  */
  clear(): void;
  /**
   * {@inheritDoc}
   *
   * @implSpec
   * This implementation gets an iterator over the specified collection
   * and iterates over it, inserting the elements obtained from the
   * iterator into this list at the appropriate position, one at a time,
   * using `add(int, E)`.
   * Many implementations will override this method for efficiency.
   *
   * Note that this implementation throws an
   * `UnsupportedOperationException` unless
   * {@link #add(int, Object) add(int, E)} is overridden.
   *
   * @throws UnsupportedOperationException {@inheritDoc}
   * @throws ClassCastException            {@inheritDoc}
   * @throws NullPointerException          {@inheritDoc}
   * @throws IllegalArgumentException      {@inheritDoc}
   * @throws IndexOutOfBoundsException     {@inheritDoc}
  */
  addAll(index: number, c: Collection<E>): boolean;
  /**
   * Returns an iterator over the elements in this list in proper sequence.
   *
   * @implSpec
   * This implementation returns a straightforward implementation of the
   * iterator interface, relying on the backing list's `size()`,
   * `get(int)`, and `remove(int)` methods.
   *
   * Note that the iterator returned by this method will throw an
   * {@link UnsupportedOperationException} in response to its
   * `remove` method unless the list's `remove(int)` method is
   * overridden.
   *
   * This implementation can be made to throw runtime exceptions in the
   * face of concurrent modification, as described in the specification
   * for the (protected) {@link #modCount} field.
   *
   * @return an iterator over the elements in this list in proper sequence
  */
  iterator(): Iterator<E>;
  /**
   * {@inheritDoc}
   *
   * @implSpec
   * This implementation returns `listIterator(0)`.
   *
   * @see #listIterator(int)
  */
  listIterator(): ListIterator<E>;
  /**
   * {@inheritDoc}
   *
   * @implSpec
   * This implementation returns a straightforward implementation of the
   * `ListIterator` interface that extends the implementation of the
   * `Iterator` interface returned by the `iterator()` method.
   * The `ListIterator` implementation relies on the backing list's
   * `get(int)`, `set(int, E)`, `add(int, E)`
   * and `remove(int)` methods.
   *
   * Note that the list iterator returned by this implementation will
   * throw an {@link UnsupportedOperationException} in response to its
   * `remove`, `set` and `add` methods unless the
   * list's `remove(int)`, `set(int, E)`, and
   * `add(int, E)` methods are overridden.
   *
   * This implementation can be made to throw runtime exceptions in the
   * face of concurrent modification, as described in the specification for
   * the (protected) {@link #modCount} field.
   *
   * @throws IndexOutOfBoundsException {@inheritDoc}
  */
  listIterator(index: number): ListIterator<E>;
  /**
   * {@inheritDoc}
   *
   * @implSpec
   * This implementation returns a list that subclasses
   * `AbstractList`.  The subclass stores, in private fields, the
   * size of the subList (which can change over its lifetime), and the
   * expected `modCount` value of the backing list.  There are two
   * variants of the subclass, one of which implements `RandomAccess`.
   * If this list implements `RandomAccess` the returned list will
   * be an instance of the subclass that implements `RandomAccess`.
   *
   * The subclass's `set(int, E)`, `get(int)`,
   * `add(int, E)`, `remove(int)`, {@code addAll(int,
   * Collection)} and `removeRange(int, int)` methods all
   * delegate to the corresponding methods on the backing abstract list,
   * after bounds-checking the index and adjusting for the offset.  The
   * `addAll(Collection c)` method merely returns {@code addAll(size,
   * c)}.
   *
   * The `listIterator(int)` method returns a "wrapper object"
   * over a list iterator on the backing list, which is created with the
   * corresponding method on the backing list.  The `iterator` method
   * merely returns `listIterator()`, and the `size` method
   * merely returns the subclass's `size` field.
   *
   * All methods first check to see if the actual `modCount` of
   * the backing list is equal to its expected value, and throw a
   * `ConcurrentModificationException` if it is not.
   *
   * @throws IndexOutOfBoundsException if an endpoint index value is out of range
   *         `(fromIndex < 0 || toIndex > size)`
   * @throws IllegalArgumentException if the endpoint indices are out of order
   *         `(fromIndex > toIndex)`
  */
  subList(fromIndex: number, toIndex: number): E[];
  /**
   * Compares the specified object with this list for equality.  Returns
   * `true` if and only if the specified object is also a list, both
   * lists have the same size, and all corresponding pairs of elements in
   * the two lists are equal.  (Two elements `e1` and
   * `e2` are equal if {@code (e1==null ? e2==null :
   * e1.equals(e2))}.)  In other words, two lists are defined to be
   * equal if they contain the same elements in the same order.
   *
   * @implSpec
   * This implementation first checks if the specified object is this
   * list. If so, it returns `true`; if not, it checks if the
   * specified object is a list. If not, it returns `false`; if so,
   * it iterates over both lists, comparing corresponding pairs of elements.
   * If any comparison returns `false`, this method returns
   * `false`.  If either iterator runs out of elements before the
   * other it returns `false` (as the lists are of unequal length);
   * otherwise it returns `true` when the iterations complete.
   *
   * @param o the object to be compared for equality with this list
   * @return `true` if the specified object is equal to this list
  */
  equals(o: any): boolean;
  /**
   * Returns the hash code value for this list.
   *
   * @implSpec
   * This implementation uses exactly the code that is used to define the
   * list hash function in the documentation for the {@link List#hashCode}
   * method.
   *
   * @return the hash code value for this list
  */
  hashCode(): number;
  /**
   * {@inheritDoc}
   *
   * @implSpec
   * This implementation iterates over the collection looking for the
   * specified element.  If it finds the element, it removes the element
   * from the collection using the iterator's remove method.
   *
   * Note that this implementation throws an
   * `UnsupportedOperationException` if the iterator returned by this
   * collection's iterator method does not implement the `remove`
   * method and this collection contains the specified object.
   *
   * @throws UnsupportedOperationException {@inheritDoc}
   * @throws ClassCastException            {@inheritDoc}
   * @throws NullPointerException          {@inheritDoc}
  */
  remove(o: any): boolean;
  /**
   * {@inheritDoc}
   *
   * @implSpec
   * This implementation iterates over the specified collection, and adds
   * each object returned by the iterator to this collection, in turn.
   *
   * Note that this implementation will throw an
   * `UnsupportedOperationException` unless `add` is
   * overridden (assuming the specified collection is non-empty).
   *
   * @throws UnsupportedOperationException {@inheritDoc}
   * @throws ClassCastException            {@inheritDoc}
   * @throws NullPointerException          {@inheritDoc}
   * @throws IllegalArgumentException      {@inheritDoc}
   * @throws IllegalStateException         {@inheritDoc}
   *
   * @see #add(Object)
  */
  addAll(c: Collection<E>): boolean;
}
export interface AbstractList<E> extends AbstractCollection<E> {}
export class Timer {
  /**
   * Creates a new timer.  The associated thread does not
   * {@linkplain Thread#setDaemon run as a daemon}.
  */
  constructor();
  /**
   * Creates a new timer whose associated thread may be specified to
   * {@linkplain Thread#setDaemon run as a daemon}.
   * A daemon thread is called for if the timer will be used to
   * schedule repeating "maintenance activities", which must be
   * performed as long as the application is running, but should not
   * prolong the lifetime of the application.
   *
   * @param isDaemon true if the associated thread should run as a daemon.
  */
  constructor(isDaemon: boolean);
  /**
   * Creates a new timer whose associated thread has the specified name.
   * The associated thread does not
   * {@linkplain Thread#setDaemon run as a daemon}.
   *
   * @param name the name of the associated thread
   * @throws NullPointerException if `name` is null
   * @since 1.5
  */
  constructor(name: string);
  /**
   * Creates a new timer whose associated thread has the specified name,
   * and may be specified to
   * {@linkplain Thread#setDaemon run as a daemon}.
   *
   * @param name the name of the associated thread
   * @param isDaemon true if the associated thread should run as a daemon
   * @throws NullPointerException if `name` is null
   * @since 1.5
  */
  constructor(name: string, isDaemon: boolean);
  /**
   * Schedules the specified task for execution after the specified delay.
   *
   * @param task  task to be scheduled.
   * @param delay delay in milliseconds before task is to be executed.
   * @throws IllegalArgumentException if `delay` is negative, or
   *         `delay + System.currentTimeMillis()` is negative.
   * @throws IllegalStateException if task was already scheduled or
   *         cancelled, timer was cancelled, or timer thread terminated.
   * @throws NullPointerException if `task` is null
  */
  schedule(task: TimerTask, delay: number): void;
  /**
   * Schedules the specified task for execution at the specified time.  If
   * the time is in the past, the task is scheduled for immediate execution.
   *
   * @param task task to be scheduled.
   * @param time time at which task is to be executed.
   * @throws IllegalArgumentException if `time.getTime()` is negative.
   * @throws IllegalStateException if task was already scheduled or
   *         cancelled, timer was cancelled, or timer thread terminated.
   * @throws NullPointerException if `task` or `time` is null
  */
  schedule(task: TimerTask, time: Date): void;
  /**
   * Schedules the specified task for repeated fixed-delay execution,
   * beginning after the specified delay.  Subsequent executions take place
   * at approximately regular intervals separated by the specified period.
   *
   * In fixed-delay execution, each execution is scheduled relative to
   * the actual execution time of the previous execution.  If an execution
   * is delayed for any reason (such as garbage collection or other
   * background activity), subsequent executions will be delayed as well.
   * In the long run, the frequency of execution will generally be slightly
   * lower than the reciprocal of the specified period (assuming the system
   * clock underlying `Object.wait(long)` is accurate).
   *
   * Fixed-delay execution is appropriate for recurring activities
   * that require "smoothness."  In other words, it is appropriate for
   * activities where it is more important to keep the frequency accurate
   * in the short run than in the long run.  This includes most animation
   * tasks, such as blinking a cursor at regular intervals.  It also includes
   * tasks wherein regular activity is performed in response to human
   * input, such as automatically repeating a character as long as a key
   * is held down.
   *
   * @param task   task to be scheduled.
   * @param delay  delay in milliseconds before task is to be executed.
   * @param period time in milliseconds between successive task executions.
   * @throws IllegalArgumentException if `delay < 0`, or
   *         `delay + System.currentTimeMillis() < 0`, or
   *         `period <= 0`
   * @throws IllegalStateException if task was already scheduled or
   *         cancelled, timer was cancelled, or timer thread terminated.
   * @throws NullPointerException if `task` is null
  */
  schedule(task: TimerTask, delay: number, period: number): void;
  /**
   * Schedules the specified task for repeated fixed-delay execution,
   * beginning at the specified time. Subsequent executions take place at
   * approximately regular intervals, separated by the specified period.
   *
   * In fixed-delay execution, each execution is scheduled relative to
   * the actual execution time of the previous execution.  If an execution
   * is delayed for any reason (such as garbage collection or other
   * background activity), subsequent executions will be delayed as well.
   * In the long run, the frequency of execution will generally be slightly
   * lower than the reciprocal of the specified period (assuming the system
   * clock underlying `Object.wait(long)` is accurate).  As a
   * consequence of the above, if the scheduled first time is in the past,
   * it is scheduled for immediate execution.
   *
   * Fixed-delay execution is appropriate for recurring activities
   * that require "smoothness."  In other words, it is appropriate for
   * activities where it is more important to keep the frequency accurate
   * in the short run than in the long run.  This includes most animation
   * tasks, such as blinking a cursor at regular intervals.  It also includes
   * tasks wherein regular activity is performed in response to human
   * input, such as automatically repeating a character as long as a key
   * is held down.
   *
   * @param task   task to be scheduled.
   * @param firstTime First time at which task is to be executed.
   * @param period time in milliseconds between successive task executions.
   * @throws IllegalArgumentException if `firstTime.getTime() < 0`, or
   *         `period <= 0`
   * @throws IllegalStateException if task was already scheduled or
   *         cancelled, timer was cancelled, or timer thread terminated.
   * @throws NullPointerException if `task` or `firstTime` is null
  */
  schedule(task: TimerTask, firstTime: Date, period: number): void;
  /**
   * Schedules the specified task for repeated fixed-rate execution,
   * beginning after the specified delay.  Subsequent executions take place
   * at approximately regular intervals, separated by the specified period.
   *
   * In fixed-rate execution, each execution is scheduled relative to the
   * scheduled execution time of the initial execution.  If an execution is
   * delayed for any reason (such as garbage collection or other background
   * activity), two or more executions will occur in rapid succession to
   * "catch up."  In the long run, the frequency of execution will be
   * exactly the reciprocal of the specified period (assuming the system
   * clock underlying `Object.wait(long)` is accurate).
   *
   * Fixed-rate execution is appropriate for recurring activities that
   * are sensitive to absolute time, such as ringing a chime every
   * hour on the hour, or running scheduled maintenance every day at a
   * particular time.  It is also appropriate for recurring activities
   * where the total time to perform a fixed number of executions is
   * important, such as a countdown timer that ticks once every second for
   * ten seconds.  Finally, fixed-rate execution is appropriate for
   * scheduling multiple repeating timer tasks that must remain synchronized
   * with respect to one another.
   *
   * @param task   task to be scheduled.
   * @param delay  delay in milliseconds before task is to be executed.
   * @param period time in milliseconds between successive task executions.
   * @throws IllegalArgumentException if `delay < 0`, or
   *         `delay + System.currentTimeMillis() < 0`, or
   *         `period <= 0`
   * @throws IllegalStateException if task was already scheduled or
   *         cancelled, timer was cancelled, or timer thread terminated.
   * @throws NullPointerException if `task` is null
  */
  scheduleAtFixedRate(task: TimerTask, delay: number, period: number): void;
  /**
   * Schedules the specified task for repeated fixed-rate execution,
   * beginning at the specified time. Subsequent executions take place at
   * approximately regular intervals, separated by the specified period.
   *
   * In fixed-rate execution, each execution is scheduled relative to the
   * scheduled execution time of the initial execution.  If an execution is
   * delayed for any reason (such as garbage collection or other background
   * activity), two or more executions will occur in rapid succession to
   * "catch up."  In the long run, the frequency of execution will be
   * exactly the reciprocal of the specified period (assuming the system
   * clock underlying `Object.wait(long)` is accurate).  As a
   * consequence of the above, if the scheduled first time is in the past,
   * then any "missed" executions will be scheduled for immediate "catch up"
   * execution.
   *
   * Fixed-rate execution is appropriate for recurring activities that
   * are sensitive to absolute time, such as ringing a chime every
   * hour on the hour, or running scheduled maintenance every day at a
   * particular time.  It is also appropriate for recurring activities
   * where the total time to perform a fixed number of executions is
   * important, such as a countdown timer that ticks once every second for
   * ten seconds.  Finally, fixed-rate execution is appropriate for
   * scheduling multiple repeating timer tasks that must remain synchronized
   * with respect to one another.
   *
   * @param task   task to be scheduled.
   * @param firstTime First time at which task is to be executed.
   * @param period time in milliseconds between successive task executions.
   * @throws IllegalArgumentException if `firstTime.getTime() < 0` or
   *         `period <= 0`
   * @throws IllegalStateException if task was already scheduled or
   *         cancelled, timer was cancelled, or timer thread terminated.
   * @throws NullPointerException if `task` or `firstTime` is null
  */
  scheduleAtFixedRate(task: TimerTask, firstTime: Date, period: number): void;
  /**
   * Terminates this timer, discarding any currently scheduled tasks.
   * Does not interfere with a currently executing task (if it exists).
   * Once a timer has been terminated, its execution thread terminates
   * gracefully, and no more tasks may be scheduled on it.
   *
   * Note that calling this method from within the run method of a
   * timer task that was invoked by this timer absolutely guarantees that
   * the ongoing task execution is the last task execution that will ever
   * be performed by this timer.
   *
   * This method may be called repeatedly; the second and subsequent
   * calls have no effect.
  */
  cancel(): void;
  /**
   * Removes all cancelled tasks from this timer's task queue.  Calling
   * this method has no effect on the behavior of the timer, but
   * eliminates the references to the cancelled tasks from the queue.
   * If there are no external references to these tasks, they become
   * eligible for garbage collection.
   *
   * Most programs will have no need to call this method.
   * It is designed for use by the rare application that cancels a large
   * number of tasks.  Calling this method trades time for space: the
   * runtime of the method may be proportional to n + c log n, where n
   * is the number of tasks in the queue and c is the number of cancelled
   * tasks.
   *
   * Note that it is permissible to call this method from within
   * a task scheduled on this timer.
   *
   * @return the number of tasks removed from the queue.
   * @since 1.5
  */
  purge(): number;
}
/**
 * A generator of uniform pseudorandom values applicable for use in
 * (among other contexts) isolated parallel computations that may
 * generate subtasks. Class `SplittableRandom` supports methods for
 * producing pseudorandom numbers of type `int`, `long`,
 * and `double` with similar usages as for class
 * {@link java.util.Random} but differs in the following ways:
 *
 * 
 *
 * Series of generated values pass the DieHarder suite testing
 * independence and uniformity properties of random number generators.
 * (Most recently validated with  version
 * 3.31.1.) These tests validate only the methods for certain
 * types and ranges, but similar properties are expected to hold, at
 * least approximately, for others as well. The period
 * (length of any series of generated values before it repeats) is at
 * least 264.
 *
 * Method {@link #split} constructs and returns a new
 * SplittableRandom instance that shares no mutable state with the
 * current instance. However, with very high probability, the
 * values collectively generated by the two objects have the same
 * statistical properties as if the same quantity of values were
 * generated by a single thread using a single ` * SplittableRandom` object.
 *
 * Instances of SplittableRandom are not thread-safe.
 * They are designed to be split, not shared, across threads. For
 * example, a {@link java.util.concurrent.ForkJoinTask
 * fork/join-style} computation using random numbers might include a
 * construction of the form {@code new
 * Subtask(aSplittableRandom.split()).fork()}.
 *
 * This class provides additional methods for generating random
 * streams, that employ the above techniques when used in ` * stream.parallel()` mode.
 *
 * 
 *
 * Instances of `SplittableRandom` are not cryptographically
 * secure.  Consider instead using {@link java.security.SecureRandom}
 * in security-sensitive applications. Additionally,
 * default-constructed instances do not use a cryptographically random
 * seed unless the {@linkplain System#getProperty system property}
 * {@systemProperty java.util.secureRandomSeed} is set to `true`.
 *
 * @author  Guy Steele
 * @author  Doug Lea
 * @since   1.8
*/
export class SplittableRandom {
  /**
   * Creates a new SplittableRandom instance using the specified
   * initial seed. SplittableRandom instances created with the same
   * seed in the same program generate identical sequences of values.
   *
   * @param seed the initial seed
  */
  constructor(seed: number);
  /**
   * Creates a new SplittableRandom instance that is likely to
   * generate sequences of values that are statistically independent
   * of those of any other instances in the current program; and
   * may, and typically does, vary across program invocations.
  */
  constructor();
  /**
   * Constructs and returns a new SplittableRandom instance that
   * shares no mutable state with this instance. However, with very
   * high probability, the set of values collectively generated by
   * the two objects has the same statistical properties as if the
   * same quantity of values were generated by a single thread using
   * a single SplittableRandom object.  Either or both of the two
   * objects may be further split using the `split()` method,
   * and the same expected statistical properties apply to the
   * entire set of generators constructed by such recursive
   * splitting.
   *
   * @return the new SplittableRandom instance
  */
  split(): SplittableRandom;
  /**
   * Fills a user-supplied byte array with generated pseudorandom bytes.
   *
   * @param  bytes the byte array to fill with pseudorandom bytes
   * @throws NullPointerException if bytes is null
   * @since  10
  */
  nextBytes(bytes: number[]): void;
  /**
   * Returns a pseudorandom `int` value.
   *
   * @return a pseudorandom `int` value
  */
  nextInt(): number;
  /**
   * Returns a pseudorandom `int` value between zero (inclusive)
   * and the specified bound (exclusive).
   *
   * @param bound the upper bound (exclusive).  Must be positive.
   * @return a pseudorandom `int` value between zero
   *         (inclusive) and the bound (exclusive)
   * @throws IllegalArgumentException if `bound` is not positive
  */
  nextInt(bound: number): number;
  /**
   * Returns a pseudorandom `int` value between the specified
   * origin (inclusive) and the specified bound (exclusive).
   *
   * @param origin the least value returned
   * @param bound the upper bound (exclusive)
   * @return a pseudorandom `int` value between the origin
   *         (inclusive) and the bound (exclusive)
   * @throws IllegalArgumentException if `origin` is greater than
   *         or equal to `bound`
  */
  nextInt(origin: number, bound: number): number;
  /**
   * Returns a pseudorandom `long` value.
   *
   * @return a pseudorandom `long` value
  */
  nextLong(): number;
  /**
   * Returns a pseudorandom `long` value between zero (inclusive)
   * and the specified bound (exclusive).
   *
   * @param bound the upper bound (exclusive).  Must be positive.
   * @return a pseudorandom `long` value between zero
   *         (inclusive) and the bound (exclusive)
   * @throws IllegalArgumentException if `bound` is not positive
  */
  nextLong(bound: number): number;
  /**
   * Returns a pseudorandom `long` value between the specified
   * origin (inclusive) and the specified bound (exclusive).
   *
   * @param origin the least value returned
   * @param bound the upper bound (exclusive)
   * @return a pseudorandom `long` value between the origin
   *         (inclusive) and the bound (exclusive)
   * @throws IllegalArgumentException if `origin` is greater than
   *         or equal to `bound`
  */
  nextLong(origin: number, bound: number): number;
  /**
   * Returns a pseudorandom `double` value between zero
   * (inclusive) and one (exclusive).
   *
   * @return a pseudorandom `double` value between zero
   *         (inclusive) and one (exclusive)
  */
  nextDouble(): number;
  /**
   * Returns a pseudorandom `double` value between 0.0
   * (inclusive) and the specified bound (exclusive).
   *
   * @param bound the upper bound (exclusive).  Must be positive.
   * @return a pseudorandom `double` value between zero
   *         (inclusive) and the bound (exclusive)
   * @throws IllegalArgumentException if `bound` is not positive
  */
  nextDouble(bound: number): number;
  /**
   * Returns a pseudorandom `double` value between the specified
   * origin (inclusive) and bound (exclusive).
   *
   * @param origin the least value returned
   * @param bound the upper bound (exclusive)
   * @return a pseudorandom `double` value between the origin
   *         (inclusive) and the bound (exclusive)
   * @throws IllegalArgumentException if `origin` is greater than
   *         or equal to `bound`
  */
  nextDouble(origin: number, bound: number): number;
  /**
   * Returns a pseudorandom `boolean` value.
   *
   * @return a pseudorandom `boolean` value
  */
  nextBoolean(): boolean;
  /**
   * Returns a stream producing the given `streamSize` number
   * of pseudorandom `int` values from this generator and/or
   * one split from it.
   *
   * @param streamSize the number of values to generate
   * @return a stream of pseudorandom `int` values
   * @throws IllegalArgumentException if `streamSize` is
   *         less than zero
  */
  ints(streamSize: number): IntStream;
  /**
   * Returns an effectively unlimited stream of pseudorandom `int`
   * values from this generator and/or one split from it.
   *
   * @implNote This method is implemented to be equivalent to `     * ints(Long.MAX_VALUE)`.
   *
   * @return a stream of pseudorandom `int` values
  */
  ints(): IntStream;
  /**
   * Returns a stream producing the given `streamSize` number
   * of pseudorandom `int` values from this generator and/or one split
   * from it; each value conforms to the given origin (inclusive) and bound
   * (exclusive).
   *
   * @param streamSize the number of values to generate
   * @param randomNumberOrigin the origin (inclusive) of each random value
   * @param randomNumberBound the bound (exclusive) of each random value
   * @return a stream of pseudorandom `int` values,
   *         each with the given origin (inclusive) and bound (exclusive)
   * @throws IllegalArgumentException if `streamSize` is
   *         less than zero, or `randomNumberOrigin`
   *         is greater than or equal to `randomNumberBound`
  */
  ints(streamSize: number, randomNumberOrigin: number, randomNumberBound: number): IntStream;
  /**
   * Returns an effectively unlimited stream of pseudorandom `     * int` values from this generator and/or one split from it; each value
   * conforms to the given origin (inclusive) and bound (exclusive).
   *
   * @implNote This method is implemented to be equivalent to `     * ints(Long.MAX_VALUE, randomNumberOrigin, randomNumberBound)`.
   *
   * @param randomNumberOrigin the origin (inclusive) of each random value
   * @param randomNumberBound the bound (exclusive) of each random value
   * @return a stream of pseudorandom `int` values,
   *         each with the given origin (inclusive) and bound (exclusive)
   * @throws IllegalArgumentException if `randomNumberOrigin`
   *         is greater than or equal to `randomNumberBound`
  */
  ints(randomNumberOrigin: number, randomNumberBound: number): IntStream;
  /**
   * Returns a stream producing the given `streamSize` number
   * of pseudorandom `long` values from this generator and/or
   * one split from it.
   *
   * @param streamSize the number of values to generate
   * @return a stream of pseudorandom `long` values
   * @throws IllegalArgumentException if `streamSize` is
   *         less than zero
  */
  longs(streamSize: number): LongStream;
  /**
   * Returns an effectively unlimited stream of pseudorandom `     * long` values from this generator and/or one split from it.
   *
   * @implNote This method is implemented to be equivalent to `     * longs(Long.MAX_VALUE)`.
   *
   * @return a stream of pseudorandom `long` values
  */
  longs(): LongStream;
  /**
   * Returns a stream producing the given `streamSize` number of
   * pseudorandom `long` values from this generator and/or one split
   * from it; each value conforms to the given origin (inclusive) and bound
   * (exclusive).
   *
   * @param streamSize the number of values to generate
   * @param randomNumberOrigin the origin (inclusive) of each random value
   * @param randomNumberBound the bound (exclusive) of each random value
   * @return a stream of pseudorandom `long` values,
   *         each with the given origin (inclusive) and bound (exclusive)
   * @throws IllegalArgumentException if `streamSize` is
   *         less than zero, or `randomNumberOrigin`
   *         is greater than or equal to `randomNumberBound`
  */
  longs(streamSize: number, randomNumberOrigin: number, randomNumberBound: number): LongStream;
  /**
   * Returns an effectively unlimited stream of pseudorandom `     * long` values from this generator and/or one split from it; each value
   * conforms to the given origin (inclusive) and bound (exclusive).
   *
   * @implNote This method is implemented to be equivalent to `     * longs(Long.MAX_VALUE, randomNumberOrigin, randomNumberBound)`.
   *
   * @param randomNumberOrigin the origin (inclusive) of each random value
   * @param randomNumberBound the bound (exclusive) of each random value
   * @return a stream of pseudorandom `long` values,
   *         each with the given origin (inclusive) and bound (exclusive)
   * @throws IllegalArgumentException if `randomNumberOrigin`
   *         is greater than or equal to `randomNumberBound`
  */
  longs(randomNumberOrigin: number, randomNumberBound: number): LongStream;
  /**
   * Returns a stream producing the given `streamSize` number of
   * pseudorandom `double` values from this generator and/or one split
   * from it; each value is between zero (inclusive) and one (exclusive).
   *
   * @param streamSize the number of values to generate
   * @return a stream of `double` values
   * @throws IllegalArgumentException if `streamSize` is
   *         less than zero
  */
  doubles(streamSize: number): DoubleStream;
  /**
   * Returns an effectively unlimited stream of pseudorandom `     * double` values from this generator and/or one split from it; each value
   * is between zero (inclusive) and one (exclusive).
   *
   * @implNote This method is implemented to be equivalent to `     * doubles(Long.MAX_VALUE)`.
   *
   * @return a stream of pseudorandom `double` values
  */
  doubles(): DoubleStream;
  /**
   * Returns a stream producing the given `streamSize` number of
   * pseudorandom `double` values from this generator and/or one split
   * from it; each value conforms to the given origin (inclusive) and bound
   * (exclusive).
   *
   * @param streamSize the number of values to generate
   * @param randomNumberOrigin the origin (inclusive) of each random value
   * @param randomNumberBound the bound (exclusive) of each random value
   * @return a stream of pseudorandom `double` values,
   *         each with the given origin (inclusive) and bound (exclusive)
   * @throws IllegalArgumentException if `streamSize` is
   *         less than zero, or `randomNumberOrigin`
   *         is greater than or equal to `randomNumberBound`
  */
  doubles(streamSize: number, randomNumberOrigin: number, randomNumberBound: number): DoubleStream;
  /**
   * Returns an effectively unlimited stream of pseudorandom `     * double` values from this generator and/or one split from it; each value
   * conforms to the given origin (inclusive) and bound (exclusive).
   *
   * @implNote This method is implemented to be equivalent to `     * doubles(Long.MAX_VALUE, randomNumberOrigin, randomNumberBound)`.
   *
   * @param randomNumberOrigin the origin (inclusive) of each random value
   * @param randomNumberBound the bound (exclusive) of each random value
   * @return a stream of pseudorandom `double` values,
   *         each with the given origin (inclusive) and bound (exclusive)
   * @throws IllegalArgumentException if `randomNumberOrigin`
   *         is greater than or equal to `randomNumberBound`
  */
  doubles(randomNumberOrigin: number, randomNumberBound: number): DoubleStream;
}
/**
 * Unchecked exception thrown when a format string contains an illegal syntax
 * or a format specifier that is incompatible with the given arguments.  Only
 * explicit subtypes of this exception which correspond to specific errors
 * should be instantiated.
 *
 * @since 1.5
*/
export class IllegalFormatException extends IllegalArgumentException {

}
export class IdentityHashMap<K, V> extends AbstractMap<K, V> {
  /**
   * Constructs a new, empty identity hash map with a default expected
   * maximum size (21).
  */
  constructor();
  /**
   * Constructs a new, empty map with the specified expected maximum size.
   * Putting more than the expected number of key-value mappings into
   * the map may cause the internal data structure to grow, which may be
   * somewhat time-consuming.
   *
   * @param expectedMaxSize the expected maximum size of the map
   * @throws IllegalArgumentException if `expectedMaxSize` is negative
  */
  constructor(expectedMaxSize: number);
  /**
   * Constructs a new identity hash map containing the keys-value mappings
   * in the specified map.
   *
   * @param m the map whose mappings are to be placed into this map
   * @throws NullPointerException if the specified map is null
  */
  constructor(m: Map<K, V>);
  /**
   * Returns the number of key-value mappings in this identity hash map.
   *
   * @return the number of key-value mappings in this map
  */
  size(): number;
  /**
   * Returns `true` if this identity hash map contains no key-value
   * mappings.
   *
   * @return `true` if this identity hash map contains no key-value
   *         mappings
  */
  isEmpty(): boolean;
  /**
   * Returns the value to which the specified key is mapped,
   * or `null` if this map contains no mapping for the key.
   *
   * More formally, if this map contains a mapping from a key
   * `k` to a value `v` such that `(key == k)`,
   * then this method returns `v`; otherwise it returns
   * `null`.  (There can be at most one such mapping.)
   *
   * A return value of `null` does not necessarily
   * indicate that the map contains no mapping for the key; it's also
   * possible that the map explicitly maps the key to `null`.
   * The {@link #containsKey containsKey} operation may be used to
   * distinguish these two cases.
   *
   * @see #put(Object, Object)
  */
  get(key: any): V;
  /**
   * Tests whether the specified object reference is a key in this identity
   * hash map.
   *
   * @param   key   possible key
   * @return  `true` if the specified object reference is a key
   *          in this map
   * @see     #containsValue(Object)
  */
  containsKey(key: any): boolean;
  /**
   * Tests whether the specified object reference is a value in this identity
   * hash map.
   *
   * @param value value whose presence in this map is to be tested
   * @return `true` if this map maps one or more keys to the
   *         specified object reference
   * @see     #containsKey(Object)
  */
  containsValue(value: any): boolean;
  /**
   * Associates the specified value with the specified key in this identity
   * hash map.  If the map previously contained a mapping for the key, the
   * old value is replaced.
   *
   * @param key the key with which the specified value is to be associated
   * @param value the value to be associated with the specified key
   * @return the previous value associated with `key`, or
   *         `null` if there was no mapping for `key`.
   *         (A `null` return can also indicate that the map
   *         previously associated `null` with `key`.)
   * @see     Object#equals(Object)
   * @see     #get(Object)
   * @see     #containsKey(Object)
  */
  put(key: K, value: V): V;
  /**
   * Copies all of the mappings from the specified map to this map.
   * These mappings will replace any mappings that this map had for
   * any of the keys currently in the specified map.
   *
   * @param m mappings to be stored in this map
   * @throws NullPointerException if the specified map is null
  */
  putAll(m: Map<K, V>): void;
  /**
   * Removes the mapping for this key from this map if present.
   *
   * @param key key whose mapping is to be removed from the map
   * @return the previous value associated with `key`, or
   *         `null` if there was no mapping for `key`.
   *         (A `null` return can also indicate that the map
   *         previously associated `null` with `key`.)
  */
  remove(key: any): V;
  /**
   * Removes all of the mappings from this map.
   * The map will be empty after this call returns.
  */
  clear(): void;
  /**
   * Compares the specified object with this map for equality.  Returns
   * `true` if the given object is also a map and the two maps
   * represent identical object-reference mappings.  More formally, this
   * map is equal to another map `m` if and only if
   * `this.entrySet().equals(m.entrySet())`.
   *
   * Owing to the reference-equality-based semantics of this map it is
   * possible that the symmetry and transitivity requirements of the
   * `Object.equals` contract may be violated if this map is compared
   * to a normal map.  However, the `Object.equals` contract is
   * guaranteed to hold among `IdentityHashMap` instances.
   *
   * @param  o object to be compared for equality with this map
   * @return `true` if the specified object is equal to this map
   * @see Object#equals(Object)
  */
  equals(o: any): boolean;
  /**
   * Returns the hash code value for this map.  The hash code of a map is
   * defined to be the sum of the hash codes of each entry in the map's
   * `entrySet()` view.  This ensures that `m1.equals(m2)`
   * implies that `m1.hashCode()==m2.hashCode()` for any two
   * `IdentityHashMap` instances `m1` and `m2`, as
   * required by the general contract of {@link Object#hashCode}.
   *
   * Owing to the reference-equality-based semantics of the
   * `Map.Entry` instances in the set returned by this map's
   * `entrySet` method, it is possible that the contractual
   * requirement of `Object.hashCode` mentioned in the previous
   * paragraph will be violated if one of the two objects being compared is
   * an `IdentityHashMap` instance and the other is a normal map.
   *
   * @return the hash code value for this map
   * @see Object#equals(Object)
   * @see #equals(Object)
  */
  hashCode(): number;
  /**
   * Returns a shallow copy of this identity hash map: the keys and values
   * themselves are not cloned.
   *
   * @return a shallow copy of this map
  */
  clone(): any;
  /**
   * Returns an identity-based set view of the keys contained in this map.
   * The set is backed by the map, so changes to the map are reflected in
   * the set, and vice-versa.  If the map is modified while an iteration
   * over the set is in progress, the results of the iteration are
   * undefined.  The set supports element removal, which removes the
   * corresponding mapping from the map, via the `Iterator.remove`,
   * `Set.remove`, `removeAll`, `retainAll`, and
   * `clear` methods.  It does not support the `add` or
   * `addAll` methods.
   *
   * While the object returned by this method implements the
   * `Set` interface, it does not obey `Set's` general
   * contract.  Like its backing map, the set returned by this method
   * defines element equality as reference-equality rather than
   * object-equality.  This affects the behavior of its `contains`,
   * `remove`, `containsAll`, `equals`, and
   * `hashCode` methods.
   *
   * The `equals` method of the returned set returns `true`
   * only if the specified object is a set containing exactly the same
   * object references as the returned set.  The symmetry and transitivity
   * requirements of the `Object.equals` contract may be violated if
   * the set returned by this method is compared to a normal set.  However,
   * the `Object.equals` contract is guaranteed to hold among sets
   * returned by this method.
   *
   * The `hashCode` method of the returned set returns the sum of
   * the identity hashcodes of the elements in the set, rather than
   * the sum of their hashcodes.  This is mandated by the change in the
   * semantics of the `equals` method, in order to enforce the
   * general contract of the `Object.hashCode` method among sets
   * returned by this method.
   *
   * @return an identity-based set view of the keys contained in this map
   * @see Object#equals(Object)
   * @see System#identityHashCode(Object)
  */
  keySet(): Set<K>;
  /**
   * Returns a {@link Collection} view of the values contained in this map.
   * The collection is backed by the map, so changes to the map are
   * reflected in the collection, and vice-versa.  If the map is
   * modified while an iteration over the collection is in progress,
   * the results of the iteration are undefined.  The collection
   * supports element removal, which removes the corresponding
   * mapping from the map, via the `Iterator.remove`,
   * `Collection.remove`, `removeAll`,
   * `retainAll` and `clear` methods.  It does not
   * support the `add` or `addAll` methods.
   *
   * While the object returned by this method implements the
   * `Collection` interface, it does not obey
   * `Collection's` general contract.  Like its backing map,
   * the collection returned by this method defines element equality as
   * reference-equality rather than object-equality.  This affects the
   * behavior of its `contains`, `remove` and
   * `containsAll` methods.
  */
  values(): Collection<V>;
  /**
   * Returns a {@link Set} view of the mappings contained in this map.
   * Each element in the returned set is a reference-equality-based
   * `Map.Entry`.  The set is backed by the map, so changes
   * to the map are reflected in the set, and vice-versa.  If the
   * map is modified while an iteration over the set is in progress,
   * the results of the iteration are undefined.  The set supports
   * element removal, which removes the corresponding mapping from
   * the map, via the `Iterator.remove`, `Set.remove`,
   * `removeAll`, `retainAll` and `clear`
   * methods.  It does not support the `add` or
   * `addAll` methods.
   *
   * Like the backing map, the `Map.Entry` objects in the set
   * returned by this method define key and value equality as
   * reference-equality rather than object-equality.  This affects the
   * behavior of the `equals` and `hashCode` methods of these
   * `Map.Entry` objects.  A reference-equality based {@code Map.Entry
   * e} is equal to an object `o` if and only if `o` is a
   * `Map.Entry` and {@code e.getKey()==o.getKey() &&
   * e.getValue()==o.getValue()}.  To accommodate these equals
   * semantics, the `hashCode` method returns
   * {@code System.identityHashCode(e.getKey()) ^
   * System.identityHashCode(e.getValue())}.
   *
   * Owing to the reference-equality-based semantics of the
   * `Map.Entry` instances in the set returned by this method,
   * it is possible that the symmetry and transitivity requirements of
   * the {@link Object#equals(Object)} contract may be violated if any of
   * the entries in the set is compared to a normal map entry, or if
   * the set returned by this method is compared to a set of normal map
   * entries (such as would be returned by a call to this method on a normal
   * map).  However, the `Object.equals` contract is guaranteed to
   * hold among identity-based map entries, and among sets of such entries.
   * 
   *
   * @return a set view of the identity-mappings contained in this map
  */
  entrySet(): Set<java_util_Map_Entry<K, V>>;
  /**
   * Performs the given action for each entry in this map until all entries
   * have been processed or the action throws an exception.   Unless
   * otherwise specified by the implementing class, actions are performed in
   * the order of entry set iteration (if an iteration order is specified.)
   * Exceptions thrown by the action are relayed to the caller.
   *
   * @implSpec
   * The default implementation is equivalent to, for this `map`:
   *  {@code
   * for (Map.Entry entry : map.entrySet())
   *     action.accept(entry.getKey(), entry.getValue());
   * }
   *
   * The default implementation makes no guarantees about synchronization
   * or atomicity properties of this method. Any implementation providing
   * atomicity guarantees must override this method and document its
   * concurrency properties.
   *
   * @param action The action to be performed for each entry
   * @throws NullPointerException if the specified action is null
   * @throws ConcurrentModificationException if an entry is found to be
   * removed during iteration
   * @since 1.8
  */
  forEach(action: BiConsumer<any, any>): void;
  /**
   * Replaces each entry's value with the result of invoking the given
   * function on that entry until all entries have been processed or the
   * function throws an exception.  Exceptions thrown by the function are
   * relayed to the caller.
   *
   * @implSpec
   * The default implementation is equivalent to, for this `map`:
   *  {@code
   * for (Map.Entry entry : map.entrySet())
   *     entry.setValue(function.apply(entry.getKey(), entry.getValue()));
   * }
   *
   * The default implementation makes no guarantees about synchronization
   * or atomicity properties of this method. Any implementation providing
   * atomicity guarantees must override this method and document its
   * concurrency properties.
   *
   * @param function the function to apply to each entry
   * @throws UnsupportedOperationException if the `set` operation
   * is not supported by this map's entry set iterator.
   * @throws ClassCastException if the class of a replacement value
   * prevents it from being stored in this map
   * @throws NullPointerException if the specified function is null, or the
   * specified replacement value is null, and this map does not permit null
   * values
   * @throws ClassCastException if a replacement value is of an inappropriate
   *         type for this map
   *         (optional)
   * @throws NullPointerException if function or a replacement value is null,
   *         and this map does not permit null keys or values
   *         (optional)
   * @throws IllegalArgumentException if some property of a replacement value
   *         prevents it from being stored in this map
   *         (optional)
   * @throws ConcurrentModificationException if an entry is found to be
   * removed during iteration
   * @since 1.8
  */
  replaceAll(func: BiFunction<any, any, V>): void;
  /**
   * Removes the entry for the specified key only if it is currently
   * mapped to the specified value.
   *
   * @implSpec
   * The default implementation is equivalent to, for this `map`:
   *
   *  {@code
   * if (map.containsKey(key) && Objects.equals(map.get(key), value)) {
   *     map.remove(key);
   *     return true;
   * } else
   *     return false;
   * }
   *
   * The default implementation makes no guarantees about synchronization
   * or atomicity properties of this method. Any implementation providing
   * atomicity guarantees must override this method and document its
   * concurrency properties.
   *
   * @param key key with which the specified value is associated
   * @param value value expected to be associated with the specified key
   * @return `true` if the value was removed
   * @throws UnsupportedOperationException if the `remove` operation
   *         is not supported by this map
   *         (optional)
   * @throws ClassCastException if the key or value is of an inappropriate
   *         type for this map
   *         (optional)
   * @throws NullPointerException if the specified key or value is null,
   *         and this map does not permit null keys or values
   *         (optional)
   * @since 1.8
  */
  remove(key: any, value: any): boolean;
}
export interface IdentityHashMap<K, V> extends AbstractMap<K, V>, Map<K, V>, Serializable, Cloneable {}
/**
 * A {@link SortedSet} extended with navigation methods reporting
 * closest matches for given search targets. Methods {@link #lower},
 * {@link #floor}, {@link #ceiling}, and {@link #higher} return elements
 * respectively less than, less than or equal, greater than or equal,
 * and greater than a given element, returning `null` if there
 * is no such element.
 *
 * A `NavigableSet` may be accessed and traversed in either
 * ascending or descending order.  The {@link #descendingSet} method
 * returns a view of the set with the senses of all relational and
 * directional methods inverted. The performance of ascending
 * operations and views is likely to be faster than that of descending
 * ones.  This interface additionally defines methods {@link
 * #pollFirst} and {@link #pollLast} that return and remove the lowest
 * and highest element, if one exists, else returning `null`.
 * Methods
 * {@link #subSet(Object, boolean, Object, boolean) subSet(E, boolean, E, boolean)},
 * {@link #headSet(Object, boolean) headSet(E, boolean)}, and
 * {@link #tailSet(Object, boolean) tailSet(E, boolean)}
 * differ from the like-named `SortedSet` methods in accepting
 * additional arguments describing whether lower and upper bounds are
 * inclusive versus exclusive.  Subsets of any `NavigableSet`
 * must implement the `NavigableSet` interface.
 *
 * The return values of navigation methods may be ambiguous in
 * implementations that permit `null` elements. However, even
 * in this case the result can be disambiguated by checking
 * `contains(null)`. To avoid such issues, implementations of
 * this interface are encouraged to not permit insertion of
 * `null` elements. (Note that sorted sets of {@link
 * Comparable} elements intrinsically do not permit `null`.)
 *
 * Methods
 * {@link #subSet(Object, Object) subSet(E, E)},
 * {@link #headSet(Object) headSet(E)}, and
 * {@link #tailSet(Object) tailSet(E)}
 * are specified to return `SortedSet` to allow existing
 * implementations of `SortedSet` to be compatibly retrofitted to
 * implement `NavigableSet`, but extensions and implementations
 * of this interface are encouraged to override these methods to return
 * `NavigableSet`.
 *
 * This interface is a member of the
 * 
 * Java Collections Framework.
 *
 * @author Doug Lea
 * @author Josh Bloch
 * @param  the type of elements maintained by this set
 * @since 1.6
*/
export class NavigableSet<E> extends SortedSet<E> {
  /**
   * Returns the greatest element in this set strictly less than the
   * given element, or `null` if there is no such element.
   *
   * @param e the value to match
   * @return the greatest element less than `e`,
   *         or `null` if there is no such element
   * @throws ClassCastException if the specified element cannot be
   *         compared with the elements currently in the set
   * @throws NullPointerException if the specified element is null
   *         and this set does not permit null elements
  */
  lower(e: E): E;
  /**
   * Returns the greatest element in this set less than or equal to
   * the given element, or `null` if there is no such element.
   *
   * @param e the value to match
   * @return the greatest element less than or equal to `e`,
   *         or `null` if there is no such element
   * @throws ClassCastException if the specified element cannot be
   *         compared with the elements currently in the set
   * @throws NullPointerException if the specified element is null
   *         and this set does not permit null elements
  */
  floor(e: E): E;
  /**
   * Returns the least element in this set greater than or equal to
   * the given element, or `null` if there is no such element.
   *
   * @param e the value to match
   * @return the least element greater than or equal to `e`,
   *         or `null` if there is no such element
   * @throws ClassCastException if the specified element cannot be
   *         compared with the elements currently in the set
   * @throws NullPointerException if the specified element is null
   *         and this set does not permit null elements
  */
  ceiling(e: E): E;
  /**
   * Returns the least element in this set strictly greater than the
   * given element, or `null` if there is no such element.
   *
   * @param e the value to match
   * @return the least element greater than `e`,
   *         or `null` if there is no such element
   * @throws ClassCastException if the specified element cannot be
   *         compared with the elements currently in the set
   * @throws NullPointerException if the specified element is null
   *         and this set does not permit null elements
  */
  higher(e: E): E;
  /**
   * Retrieves and removes the first (lowest) element,
   * or returns `null` if this set is empty.
   *
   * @return the first element, or `null` if this set is empty
  */
  pollFirst(): E;
  /**
   * Retrieves and removes the last (highest) element,
   * or returns `null` if this set is empty.
   *
   * @return the last element, or `null` if this set is empty
  */
  pollLast(): E;
  /**
   * Returns an iterator over the elements in this set, in ascending order.
   *
   * @return an iterator over the elements in this set, in ascending order
  */
  iterator(): Iterator<E>;
  /**
   * Returns a reverse order view of the elements contained in this set.
   * The descending set is backed by this set, so changes to the set are
   * reflected in the descending set, and vice-versa.  If either set is
   * modified while an iteration over either set is in progress (except
   * through the iterator's own `remove` operation), the results of
   * the iteration are undefined.
   *
   * The returned set has an ordering equivalent to
   * {@link Collections#reverseOrder(Comparator) Collections.reverseOrder}`(comparator())`.
   * The expression `s.descendingSet().descendingSet()` returns a
   * view of `s` essentially equivalent to `s`.
   *
   * @return a reverse order view of this set
  */
  descendingSet(): NavigableSet<E>;
  /**
   * Returns an iterator over the elements in this set, in descending order.
   * Equivalent in effect to `descendingSet().iterator()`.
   *
   * @return an iterator over the elements in this set, in descending order
  */
  descendingIterator(): Iterator<E>;
  /**
   * Returns a view of the portion of this set whose elements range from
   * `fromElement` to `toElement`.  If `fromElement` and
   * `toElement` are equal, the returned set is empty unless `     * fromInclusive` and `toInclusive` are both true.  The returned set
   * is backed by this set, so changes in the returned set are reflected in
   * this set, and vice-versa.  The returned set supports all optional set
   * operations that this set supports.
   *
   * The returned set will throw an `IllegalArgumentException`
   * on an attempt to insert an element outside its range.
   *
   * @param fromElement low endpoint of the returned set
   * @param fromInclusive `true` if the low endpoint
   *        is to be included in the returned view
   * @param toElement high endpoint of the returned set
   * @param toInclusive `true` if the high endpoint
   *        is to be included in the returned view
   * @return a view of the portion of this set whose elements range from
   *         `fromElement`, inclusive, to `toElement`, exclusive
   * @throws ClassCastException if `fromElement` and
   *         `toElement` cannot be compared to one another using this
   *         set's comparator (or, if the set has no comparator, using
   *         natural ordering).  Implementations may, but are not required
   *         to, throw this exception if `fromElement` or
   *         `toElement` cannot be compared to elements currently in
   *         the set.
   * @throws NullPointerException if `fromElement` or
   *         `toElement` is null and this set does
   *         not permit null elements
   * @throws IllegalArgumentException if `fromElement` is
   *         greater than `toElement`; or if this set itself
   *         has a restricted range, and `fromElement` or
   *         `toElement` lies outside the bounds of the range.
  */
  subSet(fromElement: E, fromInclusive: boolean, toElement: E, toInclusive: boolean): NavigableSet<E>;
  /**
   * Returns a view of the portion of this set whose elements are less than
   * (or equal to, if `inclusive` is true) `toElement`.  The
   * returned set is backed by this set, so changes in the returned set are
   * reflected in this set, and vice-versa.  The returned set supports all
   * optional set operations that this set supports.
   *
   * The returned set will throw an `IllegalArgumentException`
   * on an attempt to insert an element outside its range.
   *
   * @param toElement high endpoint of the returned set
   * @param inclusive `true` if the high endpoint
   *        is to be included in the returned view
   * @return a view of the portion of this set whose elements are less than
   *         (or equal to, if `inclusive` is true) `toElement`
   * @throws ClassCastException if `toElement` is not compatible
   *         with this set's comparator (or, if the set has no comparator,
   *         if `toElement` does not implement {@link Comparable}).
   *         Implementations may, but are not required to, throw this
   *         exception if `toElement` cannot be compared to elements
   *         currently in the set.
   * @throws NullPointerException if `toElement` is null and
   *         this set does not permit null elements
   * @throws IllegalArgumentException if this set itself has a
   *         restricted range, and `toElement` lies outside the
   *         bounds of the range
  */
  headSet(toElement: E, inclusive: boolean): NavigableSet<E>;
  /**
   * Returns a view of the portion of this set whose elements are greater
   * than (or equal to, if `inclusive` is true) `fromElement`.
   * The returned set is backed by this set, so changes in the returned set
   * are reflected in this set, and vice-versa.  The returned set supports
   * all optional set operations that this set supports.
   *
   * The returned set will throw an `IllegalArgumentException`
   * on an attempt to insert an element outside its range.
   *
   * @param fromElement low endpoint of the returned set
   * @param inclusive `true` if the low endpoint
   *        is to be included in the returned view
   * @return a view of the portion of this set whose elements are greater
   *         than or equal to `fromElement`
   * @throws ClassCastException if `fromElement` is not compatible
   *         with this set's comparator (or, if the set has no comparator,
   *         if `fromElement` does not implement {@link Comparable}).
   *         Implementations may, but are not required to, throw this
   *         exception if `fromElement` cannot be compared to elements
   *         currently in the set.
   * @throws NullPointerException if `fromElement` is null
   *         and this set does not permit null elements
   * @throws IllegalArgumentException if this set itself has a
   *         restricted range, and `fromElement` lies outside the
   *         bounds of the range
  */
  tailSet(fromElement: E, inclusive: boolean): NavigableSet<E>;
  /**
   * {@inheritDoc}
   *
   * Equivalent to `subSet(fromElement, true, toElement, false)`.
   *
   * @throws ClassCastException       {@inheritDoc}
   * @throws NullPointerException     {@inheritDoc}
   * @throws IllegalArgumentException {@inheritDoc}
  */
  subSet(fromElement: E, toElement: E): SortedSet<E>;
  /**
   * {@inheritDoc}
   *
   * Equivalent to `headSet(toElement, false)`.
   *
   * @throws ClassCastException       {@inheritDoc}
   * @throws NullPointerException     {@inheritDoc}
   * @throws IllegalArgumentException {@inheritDoc}
  */
  headSet(toElement: E): SortedSet<E>;
  /**
   * {@inheritDoc}
   *
   * Equivalent to `tailSet(fromElement, true)`.
   *
   * @throws ClassCastException       {@inheritDoc}
   * @throws NullPointerException     {@inheritDoc}
   * @throws IllegalArgumentException {@inheritDoc}
  */
  tailSet(fromElement: E): SortedSet<E>;
}
export class Base64 {
  /**
   * Returns a {@link Encoder} that encodes using the
   * Basic type base64 encoding scheme.
   *
   * @return  A Base64 encoder.
  */
  static getEncoder(): Encoder;
  /**
   * Returns a {@link Encoder} that encodes using the
   * URL and Filename safe type base64
   * encoding scheme.
   *
   * @return  A Base64 encoder.
  */
  static getUrlEncoder(): Encoder;
  /**
   * Returns a {@link Encoder} that encodes using the
   * MIME type base64 encoding scheme.
   *
   * @return  A Base64 encoder.
  */
  static getMimeEncoder(): Encoder;
  /**
   * Returns a {@link Encoder} that encodes using the
   * MIME type base64 encoding scheme
   * with specified line length and line separators.
   *
   * @param   lineLength
   *          the length of each output line (rounded down to nearest multiple
   *          of 4). If the rounded down line length is not a positive value,
   *          the output will not be separated in lines
   * @param   lineSeparator
   *          the line separator for each output line
   *
   * @return  A Base64 encoder.
   *
   * @throws  IllegalArgumentException if `lineSeparator` includes any
   *          character of "The Base64 Alphabet" as specified in Table 1 of
   *          RFC 2045.
  */
  static getMimeEncoder(lineLength: number, lineSeparator: number[]): Encoder;
  /**
   * Returns a {@link Decoder} that decodes using the
   * Basic type base64 encoding scheme.
   *
   * @return  A Base64 decoder.
  */
  static getDecoder(): Decoder;
  /**
   * Returns a {@link Decoder} that decodes using the
   * URL and Filename safe type base64
   * encoding scheme.
   *
   * @return  A Base64 decoder.
  */
  static getUrlDecoder(): Decoder;
  /**
   * Returns a {@link Decoder} that decodes using the
   * MIME type base64 decoding scheme.
   *
   * @return  A Base64 decoder.
  */
  static getMimeDecoder(): Decoder;
}
/**
 * A container object which may or may not contain a non-`null` value.
 * If a value is present, `isPresent()` returns `true`. If no
 * value is present, the object is considered empty and
 * `isPresent()` returns `false`.
 *
 * Additional methods that depend on the presence or absence of a contained
 * value are provided, such as {@link #orElse(Object) orElse()}
 * (returns a default value if no value is present) and
 * {@link #ifPresent(Consumer) ifPresent()} (performs an
 * action if a value is present).
 *
 * This is a value-based
 * class; programmers should treat instances that are
 * {@linkplain #equals(Object) equal} as interchangeable and should not
 * use instances for synchronization, or unpredictable behavior may
 * occur. For example, in a future release, synchronization may fail.
 *
 * @apiNote
 * `Optional` is primarily intended for use as a method return type where
 * there is a clear need to represent "no result," and where using `null`
 * is likely to cause errors. A variable whose type is `Optional` should
 * never itself be `null`; it should always point to an `Optional`
 * instance.
 *
 * @param  the type of value
 * @since 1.8
*/
export class Optional<T> {
  /**
   * Returns an empty `Optional` instance.  No value is present for this
   * `Optional`.
   *
   * @apiNote
   * Though it may be tempting to do so, avoid testing if an object is empty
   * by comparing with `==` or `!=` against instances returned by
   * `Optional.empty()`.  There is no guarantee that it is a singleton.
   * Instead, use {@link #isEmpty()} or {@link #isPresent()}.
   *
   * @param  The type of the non-existent value
   * @return an empty `Optional`
  */
  static empty<T>(): Optional<T>;
  /**
   * Returns an `Optional` describing the given non-`null`
   * value.
   *
   * @param value the value to describe, which must be non-`null`
   * @param  the type of the value
   * @return an `Optional` with the value present
   * @throws NullPointerException if value is `null`
  */
  static of<T>(value: T): Optional<T>;
  /**
   * Returns an `Optional` describing the given value, if
   * non-`null`, otherwise returns an empty `Optional`.
   *
   * @param value the possibly-`null` value to describe
   * @param  the type of the value
   * @return an `Optional` with a present value if the specified value
   *         is non-`null`, otherwise an empty `Optional`
  */
  static ofNullable<T>(value: T): Optional<T>;
  /**
   * If a value is present, returns the value, otherwise throws
   * `NoSuchElementException`.
   *
   * @apiNote
   * The preferred alternative to this method is {@link #orElseThrow()}.
   *
   * @return the non-`null` value described by this `Optional`
   * @throws NoSuchElementException if no value is present
  */
  get(): T;
  /**
   * If a value is present, returns `true`, otherwise `false`.
   *
   * @return `true` if a value is present, otherwise `false`
  */
  isPresent(): boolean;
  /**
   * If a value is  not present, returns `true`, otherwise
   * `false`.
   *
   * @return  `true` if a value is not present, otherwise `false`
   * @since   11
  */
  isEmpty(): boolean;
  /**
   * If a value is present, performs the given action with the value,
   * otherwise does nothing.
   *
   * @param action the action to be performed, if a value is present
   * @throws NullPointerException if value is present and the given action is
   *         `null`
  */
  ifPresent(action: Consumer<any>): void;
  /**
   * If a value is present, performs the given action with the value,
   * otherwise performs the given empty-based action.
   *
   * @param action the action to be performed, if a value is present
   * @param emptyAction the empty-based action to be performed, if no value is
   *        present
   * @throws NullPointerException if a value is present and the given action
   *         is `null`, or no value is present and the given empty-based
   *         action is `null`.
   * @since 9
  */
  ifPresentOrElse(action: Consumer<any>, emptyAction: Runnable): void;
  /**
   * If a value is present, and the value matches the given predicate,
   * returns an `Optional` describing the value, otherwise returns an
   * empty `Optional`.
   *
   * @param predicate the predicate to apply to a value, if present
   * @return an `Optional` describing the value of this
   *         `Optional`, if a value is present and the value matches the
   *         given predicate, otherwise an empty `Optional`
   * @throws NullPointerException if the predicate is `null`
  */
  filter(predicate: Predicate<any>): Optional<T>;
  /**
   * If a value is present, returns an `Optional` describing (as if by
   * {@link #ofNullable}) the result of applying the given mapping function to
   * the value, otherwise returns an empty `Optional`.
   *
   * If the mapping function returns a `null` result then this method
   * returns an empty `Optional`.
   *
   * @apiNote
   * This method supports post-processing on `Optional` values, without
   * the need to explicitly check for a return status.  For example, the
   * following code traverses a stream of URIs, selects one that has not
   * yet been processed, and creates a path from that URI, returning
   * an `Optional`:
   *
   * {@code
   *     Optional p =
   *         uris.stream().filter(uri -> !isProcessedYet(uri))
   *                       .findFirst()
   *                       .map(Paths::get);
   * }
   *
   * Here, `findFirst` returns an `Optional`, and then
   * `map` returns an `Optional` for the desired
   * URI if one exists.
   *
   * @param mapper the mapping function to apply to a value, if present
   * @param  The type of the value returned from the mapping function
   * @return an `Optional` describing the result of applying a mapping
   *         function to the value of this `Optional`, if a value is
   *         present, otherwise an empty `Optional`
   * @throws NullPointerException if the mapping function is `null`
  */
  map<U>(mapper: Function<any, U>): Optional<U>;
  /**
   * If a value is present, returns the result of applying the given
   * `Optional`-bearing mapping function to the value, otherwise returns
   * an empty `Optional`.
   *
   * This method is similar to {@link #map(Function)}, but the mapping
   * function is one whose result is already an `Optional`, and if
   * invoked, `flatMap` does not wrap it within an additional
   * `Optional`.
   *
   * @param  The type of value of the `Optional` returned by the
   *            mapping function
   * @param mapper the mapping function to apply to a value, if present
   * @return the result of applying an `Optional`-bearing mapping
   *         function to the value of this `Optional`, if a value is
   *         present, otherwise an empty `Optional`
   * @throws NullPointerException if the mapping function is `null` or
   *         returns a `null` result
  */
  flatMap<U>(mapper: Function<any, Optional<U>>): Optional<U>;
  /**
   * If a value is present, returns an `Optional` describing the value,
   * otherwise returns an `Optional` produced by the supplying function.
   *
   * @param supplier the supplying function that produces an `Optional`
   *        to be returned
   * @return returns an `Optional` describing the value of this
   *         `Optional`, if a value is present, otherwise an
   *         `Optional` produced by the supplying function.
   * @throws NullPointerException if the supplying function is `null` or
   *         produces a `null` result
   * @since 9
  */
  or(supplier: Supplier<Optional<T>>): Optional<T>;
  /**
   * If a value is present, returns a sequential {@link Stream} containing
   * only that value, otherwise returns an empty `Stream`.
   *
   * @apiNote
   * This method can be used to transform a `Stream` of optional
   * elements to a `Stream` of present value elements:
   * {@code
   *     Stream> os = ..
   *     Stream s = os.flatMap(Optional::stream)
   * }
   *
   * @return the optional value as a `Stream`
   * @since 9
  */
  stream(): Stream<T>;
  /**
   * If a value is present, returns the value, otherwise returns
   * `other`.
   *
   * @param other the value to be returned, if no value is present.
   *        May be `null`.
   * @return the value, if present, otherwise `other`
  */
  orElse(other: T): T;
  /**
   * If a value is present, returns the value, otherwise returns the result
   * produced by the supplying function.
   *
   * @param supplier the supplying function that produces a value to be returned
   * @return the value, if present, otherwise the result produced by the
   *         supplying function
   * @throws NullPointerException if no value is present and the supplying
   *         function is `null`
  */
  orElseGet(supplier: Supplier<T>): T;
  /**
   * If a value is present, returns the value, otherwise throws
   * `NoSuchElementException`.
   *
   * @return the non-`null` value described by this `Optional`
   * @throws NoSuchElementException if no value is present
   * @since 10
  */
  orElseThrow(): T;
  /**
   * If a value is present, returns the value, otherwise throws an exception
   * produced by the exception supplying function.
   *
   * @apiNote
   * A method reference to the exception constructor with an empty argument
   * list can be used as the supplier. For example,
   * `IllegalStateException::new`
   *
   * @param  Type of the exception to be thrown
   * @param exceptionSupplier the supplying function that produces an
   *        exception to be thrown
   * @return the value, if present
   * @throws X if no value is present
   * @throws NullPointerException if no value is present and the exception
   *          supplying function is `null`
  */
  orElseThrow<X>(exceptionSupplier: Supplier<X>): T;
  /**
   * Indicates whether some other object is "equal to" this `Optional`.
   * The other object is considered equal if:
   * 
   * it is also an `Optional` and;
   * both instances have no value present or;
   * the present values are "equal to" each other via `equals()`.
   * 
   *
   * @param obj an object to be tested for equality
   * @return `true` if the other object is "equal to" this object
   *         otherwise `false`
  */
  equals(obj: any): boolean;
  /**
   * Returns the hash code of the value, if present, otherwise `0`
   * (zero) if no value is present.
   *
   * @return hash code value of the present value or `0` if no value is
   *         present
  */
  hashCode(): number;
  /**
   * Returns a non-empty string representation of this `Optional`
   * suitable for debugging.  The exact presentation format is unspecified and
   * may vary between implementations and versions.
   *
   * @implSpec
   * If a value is present the result must include its string representation
   * in the result.  Empty and present `Optional`s must be unambiguously
   * differentiable.
   *
   * @return the string representation of this instance
  */
  toString(): string;
}
/**
 * Hash table based implementation of the `Map` interface.  This
 * implementation provides all of the optional map operations, and permits
 * `null` values and the `null` key.  (The `HashMap`
 * class is roughly equivalent to `Hashtable`, except that it is
 * unsynchronized and permits nulls.)  This class makes no guarantees as to
 * the order of the map; in particular, it does not guarantee that the order
 * will remain constant over time.
 *
 * This implementation provides constant-time performance for the basic
 * operations (`get` and `put`), assuming the hash function
 * disperses the elements properly among the buckets.  Iteration over
 * collection views requires time proportional to the "capacity" of the
 * `HashMap` instance (the number of buckets) plus its size (the number
 * of key-value mappings).  Thus, it's very important not to set the initial
 * capacity too high (or the load factor too low) if iteration performance is
 * important.
 *
 * An instance of `HashMap` has two parameters that affect its
 * performance: initial capacity and load factor.  The
 * capacity is the number of buckets in the hash table, and the initial
 * capacity is simply the capacity at the time the hash table is created.  The
 * load factor is a measure of how full the hash table is allowed to
 * get before its capacity is automatically increased.  When the number of
 * entries in the hash table exceeds the product of the load factor and the
 * current capacity, the hash table is rehashed (that is, internal data
 * structures are rebuilt) so that the hash table has approximately twice the
 * number of buckets.
 *
 * As a general rule, the default load factor (.75) offers a good
 * tradeoff between time and space costs.  Higher values decrease the
 * space overhead but increase the lookup cost (reflected in most of
 * the operations of the `HashMap` class, including
 * `get` and `put`).  The expected number of entries in
 * the map and its load factor should be taken into account when
 * setting its initial capacity, so as to minimize the number of
 * rehash operations.  If the initial capacity is greater than the
 * maximum number of entries divided by the load factor, no rehash
 * operations will ever occur.
 *
 * If many mappings are to be stored in a `HashMap`
 * instance, creating it with a sufficiently large capacity will allow
 * the mappings to be stored more efficiently than letting it perform
 * automatic rehashing as needed to grow the table.  Note that using
 * many keys with the same `hashCode()` is a sure way to slow
 * down performance of any hash table. To ameliorate impact, when keys
 * are {@link Comparable}, this class may use comparison order among
 * keys to help break ties.
 *
 * Note that this implementation is not synchronized.
 * If multiple threads access a hash map concurrently, and at least one of
 * the threads modifies the map structurally, it must be
 * synchronized externally.  (A structural modification is any operation
 * that adds or deletes one or more mappings; merely changing the value
 * associated with a key that an instance already contains is not a
 * structural modification.)  This is typically accomplished by
 * synchronizing on some object that naturally encapsulates the map.
 *
 * If no such object exists, the map should be "wrapped" using the
 * {@link Collections#synchronizedMap Collections.synchronizedMap}
 * method.  This is best done at creation time, to prevent accidental
 * unsynchronized access to the map: *   Map m = Collections.synchronizedMap(new HashMap(...));
 *
 * The iterators returned by all of this class's "collection view methods"
 * are fail-fast: if the map is structurally modified at any time after
 * the iterator is created, in any way except through the iterator's own
 * `remove` method, the iterator will throw a
 * {@link ConcurrentModificationException}.  Thus, in the face of concurrent
 * modification, the iterator fails quickly and cleanly, rather than risking
 * arbitrary, non-deterministic behavior at an undetermined time in the
 * future.
 *
 * Note that the fail-fast behavior of an iterator cannot be guaranteed
 * as it is, generally speaking, impossible to make any hard guarantees in the
 * presence of unsynchronized concurrent modification.  Fail-fast iterators
 * throw `ConcurrentModificationException` on a best-effort basis.
 * Therefore, it would be wrong to write a program that depended on this
 * exception for its correctness: the fail-fast behavior of iterators
 * should be used only to detect bugs.
 *
 * This class is a member of the
 * 
 * Java Collections Framework.
 *
 * @param  the type of keys maintained by this map
 * @param  the type of mapped values
 *
 * @author  Doug Lea
 * @author  Josh Bloch
 * @author  Arthur van Hoff
 * @author  Neal Gafter
 * @see     Object#hashCode()
 * @see     Collection
 * @see     Map
 * @see     TreeMap
 * @see     Hashtable
 * @since   1.2
*/
export class HashMap<K, V> extends AbstractMap<K, V> {
  /**
   * Constructs an empty `HashMap` with the specified initial
   * capacity and load factor.
   *
   * @param  initialCapacity the initial capacity
   * @param  loadFactor      the load factor
   * @throws IllegalArgumentException if the initial capacity is negative
   *         or the load factor is nonpositive
  */
  constructor(initialCapacity: number, loadFactor: number);
  /**
   * Constructs an empty `HashMap` with the specified initial
   * capacity and the default load factor (0.75).
   *
   * @param  initialCapacity the initial capacity.
   * @throws IllegalArgumentException if the initial capacity is negative.
  */
  constructor(initialCapacity: number);
  /**
   * Constructs an empty `HashMap` with the default initial capacity
   * (16) and the default load factor (0.75).
  */
  constructor();
  /**
   * Constructs a new `HashMap` with the same mappings as the
   * specified `Map`.  The `HashMap` is created with
   * default load factor (0.75) and an initial capacity sufficient to
   * hold the mappings in the specified `Map`.
   *
   * @param   m the map whose mappings are to be placed in this map
   * @throws  NullPointerException if the specified map is null
  */
  constructor(m: Map<K, V>);
  /**
   * Returns the number of key-value mappings in this map.
   *
   * @return the number of key-value mappings in this map
  */
  size(): number;
  /**
   * Returns `true` if this map contains no key-value mappings.
   *
   * @return `true` if this map contains no key-value mappings
  */
  isEmpty(): boolean;
  /**
   * Returns the value to which the specified key is mapped,
   * or `null` if this map contains no mapping for the key.
   *
   * More formally, if this map contains a mapping from a key
   * `k` to a value `v` such that {@code (key==null ? k==null :
   * key.equals(k))}, then this method returns `v`; otherwise
   * it returns `null`.  (There can be at most one such mapping.)
   *
   * A return value of `null` does not necessarily
   * indicate that the map contains no mapping for the key; it's also
   * possible that the map explicitly maps the key to `null`.
   * The {@link #containsKey containsKey} operation may be used to
   * distinguish these two cases.
   *
   * @see #put(Object, Object)
  */
  get(key: any): V;
  /**
   * Returns `true` if this map contains a mapping for the
   * specified key.
   *
   * @param   key   The key whose presence in this map is to be tested
   * @return `true` if this map contains a mapping for the specified
   * key.
  */
  containsKey(key: any): boolean;
  /**
   * Associates the specified value with the specified key in this map.
   * If the map previously contained a mapping for the key, the old
   * value is replaced.
   *
   * @param key key with which the specified value is to be associated
   * @param value value to be associated with the specified key
   * @return the previous value associated with `key`, or
   *         `null` if there was no mapping for `key`.
   *         (A `null` return can also indicate that the map
   *         previously associated `null` with `key`.)
  */
  put(key: K, value: V): V;
  /**
   * Copies all of the mappings from the specified map to this map.
   * These mappings will replace any mappings that this map had for
   * any of the keys currently in the specified map.
   *
   * @param m mappings to be stored in this map
   * @throws NullPointerException if the specified map is null
  */
  putAll(m: Map<K, V>): void;
  /**
   * Removes the mapping for the specified key from this map if present.
   *
   * @param  key key whose mapping is to be removed from the map
   * @return the previous value associated with `key`, or
   *         `null` if there was no mapping for `key`.
   *         (A `null` return can also indicate that the map
   *         previously associated `null` with `key`.)
  */
  remove(key: any): V;
  /**
   * Removes all of the mappings from this map.
   * The map will be empty after this call returns.
  */
  clear(): void;
  /**
   * Returns `true` if this map maps one or more keys to the
   * specified value.
   *
   * @param value value whose presence in this map is to be tested
   * @return `true` if this map maps one or more keys to the
   *         specified value
  */
  containsValue(value: any): boolean;
  /**
   * Returns a {@link Set} view of the keys contained in this map.
   * The set is backed by the map, so changes to the map are
   * reflected in the set, and vice-versa.  If the map is modified
   * while an iteration over the set is in progress (except through
   * the iterator's own `remove` operation), the results of
   * the iteration are undefined.  The set supports element removal,
   * which removes the corresponding mapping from the map, via the
   * `Iterator.remove`, `Set.remove`,
   * `removeAll`, `retainAll`, and `clear`
   * operations.  It does not support the `add` or `addAll`
   * operations.
   *
   * @return a set view of the keys contained in this map
  */
  keySet(): Set<K>;
  /**
   * Returns a {@link Collection} view of the values contained in this map.
   * The collection is backed by the map, so changes to the map are
   * reflected in the collection, and vice-versa.  If the map is
   * modified while an iteration over the collection is in progress
   * (except through the iterator's own `remove` operation),
   * the results of the iteration are undefined.  The collection
   * supports element removal, which removes the corresponding
   * mapping from the map, via the `Iterator.remove`,
   * `Collection.remove`, `removeAll`,
   * `retainAll` and `clear` operations.  It does not
   * support the `add` or `addAll` operations.
   *
   * @return a view of the values contained in this map
  */
  values(): Collection<V>;
  /**
   * Returns a {@link Set} view of the mappings contained in this map.
   * The set is backed by the map, so changes to the map are
   * reflected in the set, and vice-versa.  If the map is modified
   * while an iteration over the set is in progress (except through
   * the iterator's own `remove` operation, or through the
   * `setValue` operation on a map entry returned by the
   * iterator) the results of the iteration are undefined.  The set
   * supports element removal, which removes the corresponding
   * mapping from the map, via the `Iterator.remove`,
   * `Set.remove`, `removeAll`, `retainAll` and
   * `clear` operations.  It does not support the
   * `add` or `addAll` operations.
   *
   * @return a set view of the mappings contained in this map
  */
  entrySet(): Set<java_util_Map_Entry<K, V>>;
  /**
   * Returns the value to which the specified key is mapped, or
   * `defaultValue` if this map contains no mapping for the key.
   *
   * @implSpec
   * The default implementation makes no guarantees about synchronization
   * or atomicity properties of this method. Any implementation providing
   * atomicity guarantees must override this method and document its
   * concurrency properties.
   *
   * @param key the key whose associated value is to be returned
   * @param defaultValue the default mapping of the key
   * @return the value to which the specified key is mapped, or
   * `defaultValue` if this map contains no mapping for the key
   * @throws ClassCastException if the key is of an inappropriate type for
   * this map
   * (optional)
   * @throws NullPointerException if the specified key is null and this map
   * does not permit null keys
   * (optional)
   * @since 1.8
  */
  getOrDefault(key: any, defaultValue: V): V;
  /**
   * If the specified key is not already associated with a value (or is mapped
   * to `null`) associates it with the given value and returns
   * `null`, else returns the current value.
   *
   * @implSpec
   * The default implementation is equivalent to, for this `map`:
   *
   *  {@code
   * V v = map.get(key);
   * if (v == null)
   *     v = map.put(key, value);
   *
   * return v;
   * }
   *
   * The default implementation makes no guarantees about synchronization
   * or atomicity properties of this method. Any implementation providing
   * atomicity guarantees must override this method and document its
   * concurrency properties.
   *
   * @param key key with which the specified value is to be associated
   * @param value value to be associated with the specified key
   * @return the previous value associated with the specified key, or
   *         `null` if there was no mapping for the key.
   *         (A `null` return can also indicate that the map
   *         previously associated `null` with the key,
   *         if the implementation supports null values.)
   * @throws UnsupportedOperationException if the `put` operation
   *         is not supported by this map
   *         (optional)
   * @throws ClassCastException if the key or value is of an inappropriate
   *         type for this map
   *         (optional)
   * @throws NullPointerException if the specified key or value is null,
   *         and this map does not permit null keys or values
   *         (optional)
   * @throws IllegalArgumentException if some property of the specified key
   *         or value prevents it from being stored in this map
   *         (optional)
   * @since 1.8
  */
  putIfAbsent(key: K, value: V): V;
  /**
   * Removes the mapping for a key from this map if it is present
   * (optional operation).   More formally, if this map contains a mapping
   * from key `k` to value `v` such that
   * `Objects.equals(key, k)`, that mapping
   * is removed.  (The map can contain at most one such mapping.)
   *
   * Returns the value to which this map previously associated the key,
   * or `null` if the map contained no mapping for the key.
   *
   * If this map permits null values, then a return value of
   * `null` does not necessarily indicate that the map
   * contained no mapping for the key; it's also possible that the map
   * explicitly mapped the key to `null`.
   *
   * The map will not contain a mapping for the specified key once the
   * call returns.
   *
   * @param key key whose mapping is to be removed from the map
   * @return the previous value associated with `key`, or
   *         `null` if there was no mapping for `key`.
   * @throws UnsupportedOperationException if the `remove` operation
   *         is not supported by this map
   * @throws ClassCastException if the key is of an inappropriate type for
   *         this map
   * (optional)
   * @throws NullPointerException if the specified key is null and this
   *         map does not permit null keys
   * (optional)
  */
  remove(key: any, value: any): boolean;
  /**
   * Replaces the entry for the specified key only if currently
   * mapped to the specified value.
   *
   * @implSpec
   * The default implementation is equivalent to, for this `map`:
   *
   *  {@code
   * if (map.containsKey(key) && Objects.equals(map.get(key), oldValue)) {
   *     map.put(key, newValue);
   *     return true;
   * } else
   *     return false;
   * }
   *
   * The default implementation does not throw NullPointerException
   * for maps that do not support null values if oldValue is null unless
   * newValue is also null.
   *
   * The default implementation makes no guarantees about synchronization
   * or atomicity properties of this method. Any implementation providing
   * atomicity guarantees must override this method and document its
   * concurrency properties.
   *
   * @param key key with which the specified value is associated
   * @param oldValue value expected to be associated with the specified key
   * @param newValue value to be associated with the specified key
   * @return `true` if the value was replaced
   * @throws UnsupportedOperationException if the `put` operation
   *         is not supported by this map
   *         (optional)
   * @throws ClassCastException if the class of a specified key or value
   *         prevents it from being stored in this map
   * @throws NullPointerException if a specified key or newValue is null,
   *         and this map does not permit null keys or values
   * @throws NullPointerException if oldValue is null and this map does not
   *         permit null values
   *         (optional)
   * @throws IllegalArgumentException if some property of a specified key
   *         or value prevents it from being stored in this map
   * @since 1.8
  */
  replace(key: K, oldValue: V, newValue: V): boolean;
  /**
   * Replaces the entry for the specified key only if currently
   * mapped to the specified value.
   *
   * @implSpec
   * The default implementation is equivalent to, for this `map`:
   *
   *  {@code
   * if (map.containsKey(key) && Objects.equals(map.get(key), oldValue)) {
   *     map.put(key, newValue);
   *     return true;
   * } else
   *     return false;
   * }
   *
   * The default implementation does not throw NullPointerException
   * for maps that do not support null values if oldValue is null unless
   * newValue is also null.
   *
   * The default implementation makes no guarantees about synchronization
   * or atomicity properties of this method. Any implementation providing
   * atomicity guarantees must override this method and document its
   * concurrency properties.
   *
   * @param key key with which the specified value is associated
   * @param oldValue value expected to be associated with the specified key
   * @param newValue value to be associated with the specified key
   * @return `true` if the value was replaced
   * @throws UnsupportedOperationException if the `put` operation
   *         is not supported by this map
   *         (optional)
   * @throws ClassCastException if the class of a specified key or value
   *         prevents it from being stored in this map
   * @throws NullPointerException if a specified key or newValue is null,
   *         and this map does not permit null keys or values
   * @throws NullPointerException if oldValue is null and this map does not
   *         permit null values
   *         (optional)
   * @throws IllegalArgumentException if some property of a specified key
   *         or value prevents it from being stored in this map
   * @since 1.8
  */
  replace(key: K, value: V): V;
  /**
   * {@inheritDoc}
   *
   * This method will, on a best-effort basis, throw a
   * {@link ConcurrentModificationException} if it is detected that the
   * mapping function modifies this map during computation.
   *
   * @throws ConcurrentModificationException if it is detected that the
   * mapping function modified this map
  */
  computeIfAbsent(key: K, mappingFunction: Function<any, V>): V;
  /**
   * {@inheritDoc}
   *
   * This method will, on a best-effort basis, throw a
   * {@link ConcurrentModificationException} if it is detected that the
   * remapping function modifies this map during computation.
   *
   * @throws ConcurrentModificationException if it is detected that the
   * remapping function modified this map
  */
  computeIfPresent(key: K, remappingFunction: BiFunction<any, any, V>): V;
  /**
   * {@inheritDoc}
   *
   * This method will, on a best-effort basis, throw a
   * {@link ConcurrentModificationException} if it is detected that the
   * remapping function modifies this map during computation.
   *
   * @throws ConcurrentModificationException if it is detected that the
   * remapping function modified this map
  */
  compute(key: K, remappingFunction: BiFunction<any, any, V>): V;
  /**
   * {@inheritDoc}
   *
   * This method will, on a best-effort basis, throw a
   * {@link ConcurrentModificationException} if it is detected that the
   * remapping function modifies this map during computation.
   *
   * @throws ConcurrentModificationException if it is detected that the
   * remapping function modified this map
  */
  merge(key: K, value: V, remappingFunction: BiFunction<any, any, V>): V;
  /**
   * Performs the given action for each entry in this map until all entries
   * have been processed or the action throws an exception.   Unless
   * otherwise specified by the implementing class, actions are performed in
   * the order of entry set iteration (if an iteration order is specified.)
   * Exceptions thrown by the action are relayed to the caller.
   *
   * @implSpec
   * The default implementation is equivalent to, for this `map`:
   *  {@code
   * for (Map.Entry entry : map.entrySet())
   *     action.accept(entry.getKey(), entry.getValue());
   * }
   *
   * The default implementation makes no guarantees about synchronization
   * or atomicity properties of this method. Any implementation providing
   * atomicity guarantees must override this method and document its
   * concurrency properties.
   *
   * @param action The action to be performed for each entry
   * @throws NullPointerException if the specified action is null
   * @throws ConcurrentModificationException if an entry is found to be
   * removed during iteration
   * @since 1.8
  */
  forEach(action: BiConsumer<any, any>): void;
  /**
   * Replaces each entry's value with the result of invoking the given
   * function on that entry until all entries have been processed or the
   * function throws an exception.  Exceptions thrown by the function are
   * relayed to the caller.
   *
   * @implSpec
   * The default implementation is equivalent to, for this `map`:
   *  {@code
   * for (Map.Entry entry : map.entrySet())
   *     entry.setValue(function.apply(entry.getKey(), entry.getValue()));
   * }
   *
   * The default implementation makes no guarantees about synchronization
   * or atomicity properties of this method. Any implementation providing
   * atomicity guarantees must override this method and document its
   * concurrency properties.
   *
   * @param function the function to apply to each entry
   * @throws UnsupportedOperationException if the `set` operation
   * is not supported by this map's entry set iterator.
   * @throws ClassCastException if the class of a replacement value
   * prevents it from being stored in this map
   * @throws NullPointerException if the specified function is null, or the
   * specified replacement value is null, and this map does not permit null
   * values
   * @throws ClassCastException if a replacement value is of an inappropriate
   *         type for this map
   *         (optional)
   * @throws NullPointerException if function or a replacement value is null,
   *         and this map does not permit null keys or values
   *         (optional)
   * @throws IllegalArgumentException if some property of a replacement value
   *         prevents it from being stored in this map
   *         (optional)
   * @throws ConcurrentModificationException if an entry is found to be
   * removed during iteration
   * @since 1.8
  */
  replaceAll(func: BiFunction<any, any, V>): void;
  /**
   * Returns a shallow copy of this `HashMap` instance: the keys and
   * values themselves are not cloned.
   *
   * @return a shallow copy of this map
  */
  clone(): any;
}
export interface HashMap<K, V> extends AbstractMap<K, V>, Map<K, V>, Cloneable, Serializable {}
export class ServiceConfigurationError extends Error {
  /**
   * Constructs a new instance with the specified message.
   *
   * @param  msg  The message, or `null` if there is no message
   *
  */
  constructor(msg: string);
  /**
   * Constructs a new instance with the specified message and cause.
   *
   * @param  msg  The message, or `null` if there is no message
   *
   * @param  cause  The cause, or `null` if the cause is nonexistent
   *                or unknown
  */
  constructor(msg: string, cause: Throwable);
}
/**
 * Hash table based implementation of the `Map` interface, with
 * weak keys.
 * An entry in a `WeakHashMap` will automatically be removed when
 * its key is no longer in ordinary use.  More precisely, the presence of a
 * mapping for a given key will not prevent the key from being discarded by the
 * garbage collector, that is, made finalizable, finalized, and then reclaimed.
 * When a key has been discarded its entry is effectively removed from the map,
 * so this class behaves somewhat differently from other `Map`
 * implementations.
 *
 *  Both null values and the null key are supported. This class has
 * performance characteristics similar to those of the `HashMap`
 * class, and has the same efficiency parameters of initial capacity
 * and load factor.
 *
 *  Like most collection classes, this class is not synchronized.
 * A synchronized `WeakHashMap` may be constructed using the
 * {@link Collections#synchronizedMap Collections.synchronizedMap}
 * method.
 *
 *  This class is intended primarily for use with key objects whose
 * `equals` methods test for object identity using the
 * `==` operator.  Once such a key is discarded it can never be
 * recreated, so it is impossible to do a lookup of that key in a
 * `WeakHashMap` at some later time and be surprised that its entry
 * has been removed.  This class will work perfectly well with key objects
 * whose `equals` methods are not based upon object identity, such
 * as `String` instances.  With such recreatable key objects,
 * however, the automatic removal of `WeakHashMap` entries whose
 * keys have been discarded may prove to be confusing.
 *
 *  The behavior of the `WeakHashMap` class depends in part upon
 * the actions of the garbage collector, so several familiar (though not
 * required) `Map` invariants do not hold for this class.  Because
 * the garbage collector may discard keys at any time, a
 * `WeakHashMap` may behave as though an unknown thread is silently
 * removing entries.  In particular, even if you synchronize on a
 * `WeakHashMap` instance and invoke none of its mutator methods, it
 * is possible for the `size` method to return smaller values over
 * time, for the `isEmpty` method to return `false` and
 * then `true`, for the `containsKey` method to return
 * `true` and later `false` for a given key, for the
 * `get` method to return a value for a given key but later return
 * `null`, for the `put` method to return
 * `null` and the `remove` method to return
 * `false` for a key that previously appeared to be in the map, and
 * for successive examinations of the key set, the value collection, and
 * the entry set to yield successively smaller numbers of elements.
 *
 *  Each key object in a `WeakHashMap` is stored indirectly as
 * the referent of a weak reference.  Therefore a key will automatically be
 * removed only after the weak references to it, both inside and outside of the
 * map, have been cleared by the garbage collector.
 *
 *  Implementation note: The value objects in a
 * `WeakHashMap` are held by ordinary strong references.  Thus care
 * should be taken to ensure that value objects do not strongly refer to their
 * own keys, either directly or indirectly, since that will prevent the keys
 * from being discarded.  Note that a value object may refer indirectly to its
 * key via the `WeakHashMap` itself; that is, a value object may
 * strongly refer to some other key object whose associated value object, in
 * turn, strongly refers to the key of the first value object.  If the values
 * in the map do not rely on the map holding strong references to them, one way
 * to deal with this is to wrap values themselves within
 * `WeakReferences` before
 * inserting, as in: `m.put(key, new WeakReference(value))`,
 * and then unwrapping upon each `get`.
 *
 * The iterators returned by the `iterator` method of the collections
 * returned by all of this class's "collection view methods" are
 * fail-fast: if the map is structurally modified at any time after the
 * iterator is created, in any way except through the iterator's own
 * `remove` method, the iterator will throw a {@link
 * ConcurrentModificationException}.  Thus, in the face of concurrent
 * modification, the iterator fails quickly and cleanly, rather than risking
 * arbitrary, non-deterministic behavior at an undetermined time in the future.
 *
 * Note that the fail-fast behavior of an iterator cannot be guaranteed
 * as it is, generally speaking, impossible to make any hard guarantees in the
 * presence of unsynchronized concurrent modification.  Fail-fast iterators
 * throw `ConcurrentModificationException` on a best-effort basis.
 * Therefore, it would be wrong to write a program that depended on this
 * exception for its correctness:  the fail-fast behavior of iterators
 * should be used only to detect bugs.
 *
 * This class is a member of the
 * 
 * Java Collections Framework.
 *
 * @param  the type of keys maintained by this map
 * @param  the type of mapped values
 *
 * @author      Doug Lea
 * @author      Josh Bloch
 * @author      Mark Reinhold
 * @since       1.2
 * @see         java.util.HashMap
 * @see         java.lang.ref.WeakReference
*/
export class WeakHashMap<K, V> extends AbstractMap<K, V> {
  /**
   * Constructs a new, empty `WeakHashMap` with the given initial
   * capacity and the given load factor.
   *
   * @param  initialCapacity The initial capacity of the `WeakHashMap`
   * @param  loadFactor      The load factor of the `WeakHashMap`
   * @throws IllegalArgumentException if the initial capacity is negative,
   *         or if the load factor is nonpositive.
  */
  constructor(initialCapacity: number, loadFactor: number);
  /**
   * Constructs a new, empty `WeakHashMap` with the given initial
   * capacity and the default load factor (0.75).
   *
   * @param  initialCapacity The initial capacity of the `WeakHashMap`
   * @throws IllegalArgumentException if the initial capacity is negative
  */
  constructor(initialCapacity: number);
  /**
   * Constructs a new, empty `WeakHashMap` with the default initial
   * capacity (16) and load factor (0.75).
  */
  constructor();
  /**
   * Constructs a new `WeakHashMap` with the same mappings as the
   * specified map.  The `WeakHashMap` is created with the default
   * load factor (0.75) and an initial capacity sufficient to hold the
   * mappings in the specified map.
   *
   * @param   m the map whose mappings are to be placed in this map
   * @throws  NullPointerException if the specified map is null
   * @since   1.3
  */
  constructor(m: Map<K, V>);
  /**
   * Returns the number of key-value mappings in this map.
   * This result is a snapshot, and may not reflect unprocessed
   * entries that will be removed before next attempted access
   * because they are no longer referenced.
  */
  size(): number;
  /**
   * Returns `true` if this map contains no key-value mappings.
   * This result is a snapshot, and may not reflect unprocessed
   * entries that will be removed before next attempted access
   * because they are no longer referenced.
  */
  isEmpty(): boolean;
  /**
   * Returns the value to which the specified key is mapped,
   * or `null` if this map contains no mapping for the key.
   *
   * More formally, if this map contains a mapping from a key
   * `k` to a value `v` such that
   * `Objects.equals(key, k)`,
   * then this method returns `v`; otherwise
   * it returns `null`.  (There can be at most one such mapping.)
   *
   * A return value of `null` does not necessarily
   * indicate that the map contains no mapping for the key; it's also
   * possible that the map explicitly maps the key to `null`.
   * The {@link #containsKey containsKey} operation may be used to
   * distinguish these two cases.
   *
   * @see #put(Object, Object)
  */
  get(key: any): V;
  /**
   * Returns `true` if this map contains a mapping for the
   * specified key.
   *
   * @param  key   The key whose presence in this map is to be tested
   * @return `true` if there is a mapping for `key`;
   *         `false` otherwise
  */
  containsKey(key: any): boolean;
  /**
   * Associates the specified value with the specified key in this map.
   * If the map previously contained a mapping for this key, the old
   * value is replaced.
   *
   * @param key key with which the specified value is to be associated.
   * @param value value to be associated with the specified key.
   * @return the previous value associated with `key`, or
   *         `null` if there was no mapping for `key`.
   *         (A `null` return can also indicate that the map
   *         previously associated `null` with `key`.)
  */
  put(key: K, value: V): V;
  /**
   * Copies all of the mappings from the specified map to this map.
   * These mappings will replace any mappings that this map had for any
   * of the keys currently in the specified map.
   *
   * @param m mappings to be stored in this map.
   * @throws  NullPointerException if the specified map is null.
  */
  putAll(m: Map<K, V>): void;
  /**
   * Removes the mapping for a key from this weak hash map if it is present.
   * More formally, if this map contains a mapping from key `k` to
   * value `v` such that (key==null ?  k==null :
   * key.equals(k)), that mapping is removed.  (The map can contain
   * at most one such mapping.)
   *
   * Returns the value to which this map previously associated the key,
   * or `null` if the map contained no mapping for the key.  A
   * return value of `null` does not necessarily indicate
   * that the map contained no mapping for the key; it's also possible
   * that the map explicitly mapped the key to `null`.
   *
   * The map will not contain a mapping for the specified key once the
   * call returns.
   *
   * @param key key whose mapping is to be removed from the map
   * @return the previous value associated with `key`, or
   *         `null` if there was no mapping for `key`
  */
  remove(key: any): V;
  /**
   * Removes all of the mappings from this map.
   * The map will be empty after this call returns.
  */
  clear(): void;
  /**
   * Returns `true` if this map maps one or more keys to the
   * specified value.
   *
   * @param value value whose presence in this map is to be tested
   * @return `true` if this map maps one or more keys to the
   *         specified value
  */
  containsValue(value: any): boolean;
  /**
   * Returns a {@link Set} view of the keys contained in this map.
   * The set is backed by the map, so changes to the map are
   * reflected in the set, and vice-versa.  If the map is modified
   * while an iteration over the set is in progress (except through
   * the iterator's own `remove` operation), the results of
   * the iteration are undefined.  The set supports element removal,
   * which removes the corresponding mapping from the map, via the
   * `Iterator.remove`, `Set.remove`,
   * `removeAll`, `retainAll`, and `clear`
   * operations.  It does not support the `add` or `addAll`
   * operations.
  */
  keySet(): Set<K>;
  /**
   * Returns a {@link Collection} view of the values contained in this map.
   * The collection is backed by the map, so changes to the map are
   * reflected in the collection, and vice-versa.  If the map is
   * modified while an iteration over the collection is in progress
   * (except through the iterator's own `remove` operation),
   * the results of the iteration are undefined.  The collection
   * supports element removal, which removes the corresponding
   * mapping from the map, via the `Iterator.remove`,
   * `Collection.remove`, `removeAll`,
   * `retainAll` and `clear` operations.  It does not
   * support the `add` or `addAll` operations.
  */
  values(): Collection<V>;
  /**
   * Returns a {@link Set} view of the mappings contained in this map.
   * The set is backed by the map, so changes to the map are
   * reflected in the set, and vice-versa.  If the map is modified
   * while an iteration over the set is in progress (except through
   * the iterator's own `remove` operation, or through the
   * `setValue` operation on a map entry returned by the
   * iterator) the results of the iteration are undefined.  The set
   * supports element removal, which removes the corresponding
   * mapping from the map, via the `Iterator.remove`,
   * `Set.remove`, `removeAll`, `retainAll` and
   * `clear` operations.  It does not support the
   * `add` or `addAll` operations.
  */
  entrySet(): Set<java_util_Map_Entry<K, V>>;
  /**
   * Performs the given action for each entry in this map until all entries
   * have been processed or the action throws an exception.   Unless
   * otherwise specified by the implementing class, actions are performed in
   * the order of entry set iteration (if an iteration order is specified.)
   * Exceptions thrown by the action are relayed to the caller.
   *
   * @implSpec
   * The default implementation is equivalent to, for this `map`:
   *  {@code
   * for (Map.Entry entry : map.entrySet())
   *     action.accept(entry.getKey(), entry.getValue());
   * }
   *
   * The default implementation makes no guarantees about synchronization
   * or atomicity properties of this method. Any implementation providing
   * atomicity guarantees must override this method and document its
   * concurrency properties.
   *
   * @param action The action to be performed for each entry
   * @throws NullPointerException if the specified action is null
   * @throws ConcurrentModificationException if an entry is found to be
   * removed during iteration
   * @since 1.8
  */
  forEach(action: BiConsumer<any, any>): void;
  /**
   * Replaces each entry's value with the result of invoking the given
   * function on that entry until all entries have been processed or the
   * function throws an exception.  Exceptions thrown by the function are
   * relayed to the caller.
   *
   * @implSpec
   * The default implementation is equivalent to, for this `map`:
   *  {@code
   * for (Map.Entry entry : map.entrySet())
   *     entry.setValue(function.apply(entry.getKey(), entry.getValue()));
   * }
   *
   * The default implementation makes no guarantees about synchronization
   * or atomicity properties of this method. Any implementation providing
   * atomicity guarantees must override this method and document its
   * concurrency properties.
   *
   * @param function the function to apply to each entry
   * @throws UnsupportedOperationException if the `set` operation
   * is not supported by this map's entry set iterator.
   * @throws ClassCastException if the class of a replacement value
   * prevents it from being stored in this map
   * @throws NullPointerException if the specified function is null, or the
   * specified replacement value is null, and this map does not permit null
   * values
   * @throws ClassCastException if a replacement value is of an inappropriate
   *         type for this map
   *         (optional)
   * @throws NullPointerException if function or a replacement value is null,
   *         and this map does not permit null keys or values
   *         (optional)
   * @throws IllegalArgumentException if some property of a replacement value
   *         prevents it from being stored in this map
   *         (optional)
   * @throws ConcurrentModificationException if an entry is found to be
   * removed during iteration
   * @since 1.8
  */
  replaceAll(func: BiFunction<any, any, V>): void;
  /**
   * Removes the entry for the specified key only if it is currently
   * mapped to the specified value.
   *
   * @implSpec
   * The default implementation is equivalent to, for this `map`:
   *
   *  {@code
   * if (map.containsKey(key) && Objects.equals(map.get(key), value)) {
   *     map.remove(key);
   *     return true;
   * } else
   *     return false;
   * }
   *
   * The default implementation makes no guarantees about synchronization
   * or atomicity properties of this method. Any implementation providing
   * atomicity guarantees must override this method and document its
   * concurrency properties.
   *
   * @param key key with which the specified value is associated
   * @param value value expected to be associated with the specified key
   * @return `true` if the value was removed
   * @throws UnsupportedOperationException if the `remove` operation
   *         is not supported by this map
   *         (optional)
   * @throws ClassCastException if the key or value is of an inappropriate
   *         type for this map
   *         (optional)
   * @throws NullPointerException if the specified key or value is null,
   *         and this map does not permit null keys or values
   *         (optional)
   * @since 1.8
  */
  remove(key: any, value: any): boolean;
}
export interface WeakHashMap<K, V> extends AbstractMap<K, V>, Map<K, V> {}
/**
 * This class implements a hash table, which maps keys to values. Any
 * non-`null` object can be used as a key or as a value. 
 *
 * To successfully store and retrieve objects from a hashtable, the
 * objects used as keys must implement the `hashCode`
 * method and the `equals` method. 
 *
 * An instance of `Hashtable` has two parameters that affect its
 * performance: initial capacity and load factor.  The
 * capacity is the number of buckets in the hash table, and the
 * initial capacity is simply the capacity at the time the hash table
 * is created.  Note that the hash table is open: in the case of a "hash
 * collision", a single bucket stores multiple entries, which must be searched
 * sequentially.  The load factor is a measure of how full the hash
 * table is allowed to get before its capacity is automatically increased.
 * The initial capacity and load factor parameters are merely hints to
 * the implementation.  The exact details as to when and whether the rehash
 * method is invoked are implementation-dependent.
 *
 * Generally, the default load factor (.75) offers a good tradeoff between
 * time and space costs.  Higher values decrease the space overhead but
 * increase the time cost to look up an entry (which is reflected in most
 * `Hashtable` operations, including `get` and `put`).
 *
 * The initial capacity controls a tradeoff between wasted space and the
 * need for `rehash` operations, which are time-consuming.
 * No `rehash` operations will ever occur if the initial
 * capacity is greater than the maximum number of entries the
 * `Hashtable` will contain divided by its load factor.  However,
 * setting the initial capacity too high can waste space.
 *
 * If many entries are to be made into a `Hashtable`,
 * creating it with a sufficiently large capacity may allow the
 * entries to be inserted more efficiently than letting it perform
 * automatic rehashing as needed to grow the table. 
 *
 * This example creates a hashtable of numbers. It uses the names of
 * the numbers as keys:
 *    {@code
 *   Hashtable numbers
 *     = new Hashtable();
 *   numbers.put("one", 1);
 *   numbers.put("two", 2);
 *   numbers.put("three", 3);}
 *
 * To retrieve a number, use the following code:
 *    {@code
 *   Integer n = numbers.get("two");
 *   if (n != null) {
 *     System.out.println("two = " + n);
 *   }}
 *
 * The iterators returned by the `iterator` method of the collections
 * returned by all of this class's "collection view methods" are
 * fail-fast: if the Hashtable is structurally modified at any time
 * after the iterator is created, in any way except through the iterator's own
 * `remove` method, the iterator will throw a {@link
 * ConcurrentModificationException}.  Thus, in the face of concurrent
 * modification, the iterator fails quickly and cleanly, rather than risking
 * arbitrary, non-deterministic behavior at an undetermined time in the future.
 * The Enumerations returned by Hashtable's {@link #keys keys} and
 * {@link #elements elements} methods are not fail-fast; if the
 * Hashtable is structurally modified at any time after the enumeration is
 * created then the results of enumerating are undefined.
 *
 * Note that the fail-fast behavior of an iterator cannot be guaranteed
 * as it is, generally speaking, impossible to make any hard guarantees in the
 * presence of unsynchronized concurrent modification.  Fail-fast iterators
 * throw `ConcurrentModificationException` on a best-effort basis.
 * Therefore, it would be wrong to write a program that depended on this
 * exception for its correctness: the fail-fast behavior of iterators
 * should be used only to detect bugs.
 *
 * As of the Java 2 platform v1.2, this class was retrofitted to
 * implement the {@link Map} interface, making it a member of the
 * 
 *
 * Java Collections Framework.  Unlike the new collection
 * implementations, `Hashtable` is synchronized.  If a
 * thread-safe implementation is not needed, it is recommended to use
 * {@link HashMap} in place of `Hashtable`.  If a thread-safe
 * highly-concurrent implementation is desired, then it is recommended
 * to use {@link java.util.concurrent.ConcurrentHashMap} in place of
 * `Hashtable`.
 *
 * @param  the type of keys maintained by this map
 * @param  the type of mapped values
 *
 * @author  Arthur van Hoff
 * @author  Josh Bloch
 * @author  Neal Gafter
 * @see     Object#equals(java.lang.Object)
 * @see     Object#hashCode()
 * @see     Hashtable#rehash()
 * @see     Collection
 * @see     Map
 * @see     HashMap
 * @see     TreeMap
 * @since 1.0
*/
export class Hashtable<K, V> extends Dictionary<K, V> {
  /**
   * Constructs a new, empty hashtable with the specified initial
   * capacity and the specified load factor.
   *
   * @param      initialCapacity   the initial capacity of the hashtable.
   * @param      loadFactor        the load factor of the hashtable.
   * @throws     IllegalArgumentException  if the initial capacity is less
   *             than zero, or if the load factor is nonpositive.
  */
  constructor(initialCapacity: number, loadFactor: number);
  /**
   * Constructs a new, empty hashtable with the specified initial capacity
   * and default load factor (0.75).
   *
   * @param     initialCapacity   the initial capacity of the hashtable.
   * @throws    IllegalArgumentException if the initial capacity is less
   *              than zero.
  */
  constructor(initialCapacity: number);
  /**
   * Constructs a new, empty hashtable with a default initial capacity (11)
   * and load factor (0.75).
  */
  constructor();
  /**
   * Constructs a new hashtable with the same mappings as the given
   * Map.  The hashtable is created with an initial capacity sufficient to
   * hold the mappings in the given Map and a default load factor (0.75).
   *
   * @param t the map whose mappings are to be placed in this map.
   * @throws NullPointerException if the specified map is null.
   * @since   1.2
  */
  constructor(t: Map<K, V>);
  /**
   * Returns the number of keys in this hashtable.
   *
   * @return  the number of keys in this hashtable.
  */
  size(): number;
  /**
   * Tests if this hashtable maps no keys to values.
   *
   * @return  `true` if this hashtable maps no keys to values;
   *          `false` otherwise.
  */
  isEmpty(): boolean;
  /**
   * Returns an enumeration of the keys in this hashtable.
   * Use the Enumeration methods on the returned object to fetch the keys
   * sequentially. If the hashtable is structurally modified while enumerating
   * over the keys then the results of enumerating are undefined.
   *
   * @return  an enumeration of the keys in this hashtable.
   * @see     Enumeration
   * @see     #elements()
   * @see     #keySet()
   * @see     Map
  */
  keys(): Enumeration<K>;
  /**
   * Returns an enumeration of the values in this hashtable.
   * Use the Enumeration methods on the returned object to fetch the elements
   * sequentially. If the hashtable is structurally modified while enumerating
   * over the values then the results of enumerating are undefined.
   *
   * @return  an enumeration of the values in this hashtable.
   * @see     java.util.Enumeration
   * @see     #keys()
   * @see     #values()
   * @see     Map
  */
  elements(): Enumeration<V>;
  /**
   * Tests if some key maps into the specified value in this hashtable.
   * This operation is more expensive than the {@link #containsKey
   * containsKey} method.
   *
   * Note that this method is identical in functionality to
   * {@link #containsValue containsValue}, (which is part of the
   * {@link Map} interface in the collections framework).
   *
   * @param      value   a value to search for
   * @return     `true` if and only if some key maps to the
   *             `value` argument in this hashtable as
   *             determined by the `equals` method;
   *             `false` otherwise.
   * @throws     NullPointerException  if the value is `null`
  */
  contains(value: any): boolean;
  /**
   * Returns true if this hashtable maps one or more keys to this value.
   *
   * Note that this method is identical in functionality to {@link
   * #contains contains} (which predates the {@link Map} interface).
   *
   * @param value value whose presence in this hashtable is to be tested
   * @return `true` if this map maps one or more keys to the
   *         specified value
   * @throws NullPointerException  if the value is `null`
   * @since 1.2
  */
  containsValue(value: any): boolean;
  /**
   * Tests if the specified object is a key in this hashtable.
   *
   * @param   key   possible key
   * @return  `true` if and only if the specified object
   *          is a key in this hashtable, as determined by the
   *          `equals` method; `false` otherwise.
   * @throws  NullPointerException  if the key is `null`
   * @see     #contains(Object)
  */
  containsKey(key: any): boolean;
  /**
   * Returns the value to which the specified key is mapped,
   * or `null` if this map contains no mapping for the key.
   *
   * More formally, if this map contains a mapping from a key
   * `k` to a value `v` such that `(key.equals(k))`,
   * then this method returns `v`; otherwise it returns
   * `null`.  (There can be at most one such mapping.)
   *
   * @param key the key whose associated value is to be returned
   * @return the value to which the specified key is mapped, or
   *         `null` if this map contains no mapping for the key
   * @throws NullPointerException if the specified key is null
   * @see     #put(Object, Object)
  */
  get(key: any): V;
  /**
   * Maps the specified `key` to the specified
   * `value` in this hashtable. Neither the key nor the
   * value can be `null`. 
   *
   * The value can be retrieved by calling the `get` method
   * with a key that is equal to the original key.
   *
   * @param      key     the hashtable key
   * @param      value   the value
   * @return     the previous value of the specified key in this hashtable,
   *             or `null` if it did not have one
   * @throws     NullPointerException  if the key or value is
   *               `null`
   * @see     Object#equals(Object)
   * @see     #get(Object)
  */
  put(key: K, value: V): V;
  /**
   * Removes the key (and its corresponding value) from this
   * hashtable. This method does nothing if the key is not in the hashtable.
   *
   * @param   key   the key that needs to be removed
   * @return  the value to which the key had been mapped in this hashtable,
   *          or `null` if the key did not have a mapping
   * @throws  NullPointerException  if the key is `null`
  */
  remove(key: any): V;
  /**
   * Copies all of the mappings from the specified map to this hashtable.
   * These mappings will replace any mappings that this hashtable had for any
   * of the keys currently in the specified map.
   *
   * @param t mappings to be stored in this map
   * @throws NullPointerException if the specified map is null
   * @since 1.2
  */
  putAll(t: Map<K, V>): void;
  /**
   * Clears this hashtable so that it contains no keys.
  */
  clear(): void;
  /**
   * Creates a shallow copy of this hashtable. All the structure of the
   * hashtable itself is copied, but the keys and values are not cloned.
   * This is a relatively expensive operation.
   *
   * @return  a clone of the hashtable
  */
  clone(): any;
  /**
   * Returns a string representation of this `Hashtable` object
   * in the form of a set of entries, enclosed in braces and separated
   * by the ASCII characters " , " (comma and space). Each
   * entry is rendered as the key, an equals sign `=`, and the
   * associated element, where the `toString` method is used to
   * convert the key and element to strings.
   *
   * @return  a string representation of this hashtable
  */
  toString(): string;
  /**
   * Returns a {@link Set} view of the keys contained in this map.
   * The set is backed by the map, so changes to the map are
   * reflected in the set, and vice-versa.  If the map is modified
   * while an iteration over the set is in progress (except through
   * the iterator's own `remove` operation), the results of
   * the iteration are undefined.  The set supports element removal,
   * which removes the corresponding mapping from the map, via the
   * `Iterator.remove`, `Set.remove`,
   * `removeAll`, `retainAll`, and `clear`
   * operations.  It does not support the `add` or `addAll`
   * operations.
   *
   * @since 1.2
  */
  keySet(): Set<K>;
  /**
   * Returns a {@link Set} view of the mappings contained in this map.
   * The set is backed by the map, so changes to the map are
   * reflected in the set, and vice-versa.  If the map is modified
   * while an iteration over the set is in progress (except through
   * the iterator's own `remove` operation, or through the
   * `setValue` operation on a map entry returned by the
   * iterator) the results of the iteration are undefined.  The set
   * supports element removal, which removes the corresponding
   * mapping from the map, via the `Iterator.remove`,
   * `Set.remove`, `removeAll`, `retainAll` and
   * `clear` operations.  It does not support the
   * `add` or `addAll` operations.
   *
   * @since 1.2
  */
  entrySet(): Set<java_util_Map_Entry<K, V>>;
  /**
   * Returns a {@link Collection} view of the values contained in this map.
   * The collection is backed by the map, so changes to the map are
   * reflected in the collection, and vice-versa.  If the map is
   * modified while an iteration over the collection is in progress
   * (except through the iterator's own `remove` operation),
   * the results of the iteration are undefined.  The collection
   * supports element removal, which removes the corresponding
   * mapping from the map, via the `Iterator.remove`,
   * `Collection.remove`, `removeAll`,
   * `retainAll` and `clear` operations.  It does not
   * support the `add` or `addAll` operations.
   *
   * @since 1.2
  */
  values(): Collection<V>;
  /**
   * Compares the specified Object with this Map for equality,
   * as per the definition in the Map interface.
   *
   * @param  o object to be compared for equality with this hashtable
   * @return true if the specified Object is equal to this Map
   * @see Map#equals(Object)
   * @since 1.2
  */
  equals(o: any): boolean;
  /**
   * Returns the hash code value for this Map as per the definition in the
   * Map interface.
   *
   * @see Map#hashCode()
   * @since 1.2
  */
  hashCode(): number;
  /**
   * Returns the value to which the specified key is mapped, or
   * `defaultValue` if this map contains no mapping for the key.
   *
   * @implSpec
   * The default implementation makes no guarantees about synchronization
   * or atomicity properties of this method. Any implementation providing
   * atomicity guarantees must override this method and document its
   * concurrency properties.
   *
   * @param key the key whose associated value is to be returned
   * @param defaultValue the default mapping of the key
   * @return the value to which the specified key is mapped, or
   * `defaultValue` if this map contains no mapping for the key
   * @throws ClassCastException if the key is of an inappropriate type for
   * this map
   * (optional)
   * @throws NullPointerException if the specified key is null and this map
   * does not permit null keys
   * (optional)
   * @since 1.8
  */
  getOrDefault(key: any, defaultValue: V): V;
  /**
   * Performs the given action for each entry in this map until all entries
   * have been processed or the action throws an exception.   Unless
   * otherwise specified by the implementing class, actions are performed in
   * the order of entry set iteration (if an iteration order is specified.)
   * Exceptions thrown by the action are relayed to the caller.
   *
   * @implSpec
   * The default implementation is equivalent to, for this `map`:
   *  {@code
   * for (Map.Entry entry : map.entrySet())
   *     action.accept(entry.getKey(), entry.getValue());
   * }
   *
   * The default implementation makes no guarantees about synchronization
   * or atomicity properties of this method. Any implementation providing
   * atomicity guarantees must override this method and document its
   * concurrency properties.
   *
   * @param action The action to be performed for each entry
   * @throws NullPointerException if the specified action is null
   * @throws ConcurrentModificationException if an entry is found to be
   * removed during iteration
   * @since 1.8
  */
  forEach(action: BiConsumer<any, any>): void;
  /**
   * Replaces each entry's value with the result of invoking the given
   * function on that entry until all entries have been processed or the
   * function throws an exception.  Exceptions thrown by the function are
   * relayed to the caller.
   *
   * @implSpec
   * The default implementation is equivalent to, for this `map`:
   *  {@code
   * for (Map.Entry entry : map.entrySet())
   *     entry.setValue(function.apply(entry.getKey(), entry.getValue()));
   * }
   *
   * The default implementation makes no guarantees about synchronization
   * or atomicity properties of this method. Any implementation providing
   * atomicity guarantees must override this method and document its
   * concurrency properties.
   *
   * @param function the function to apply to each entry
   * @throws UnsupportedOperationException if the `set` operation
   * is not supported by this map's entry set iterator.
   * @throws ClassCastException if the class of a replacement value
   * prevents it from being stored in this map
   * @throws NullPointerException if the specified function is null, or the
   * specified replacement value is null, and this map does not permit null
   * values
   * @throws ClassCastException if a replacement value is of an inappropriate
   *         type for this map
   *         (optional)
   * @throws NullPointerException if function or a replacement value is null,
   *         and this map does not permit null keys or values
   *         (optional)
   * @throws IllegalArgumentException if some property of a replacement value
   *         prevents it from being stored in this map
   *         (optional)
   * @throws ConcurrentModificationException if an entry is found to be
   * removed during iteration
   * @since 1.8
  */
  replaceAll(func: BiFunction<any, any, V>): void;
  /**
   * If the specified key is not already associated with a value (or is mapped
   * to `null`) associates it with the given value and returns
   * `null`, else returns the current value.
   *
   * @implSpec
   * The default implementation is equivalent to, for this `map`:
   *
   *  {@code
   * V v = map.get(key);
   * if (v == null)
   *     v = map.put(key, value);
   *
   * return v;
   * }
   *
   * The default implementation makes no guarantees about synchronization
   * or atomicity properties of this method. Any implementation providing
   * atomicity guarantees must override this method and document its
   * concurrency properties.
   *
   * @param key key with which the specified value is to be associated
   * @param value value to be associated with the specified key
   * @return the previous value associated with the specified key, or
   *         `null` if there was no mapping for the key.
   *         (A `null` return can also indicate that the map
   *         previously associated `null` with the key,
   *         if the implementation supports null values.)
   * @throws UnsupportedOperationException if the `put` operation
   *         is not supported by this map
   *         (optional)
   * @throws ClassCastException if the key or value is of an inappropriate
   *         type for this map
   *         (optional)
   * @throws NullPointerException if the specified key or value is null,
   *         and this map does not permit null keys or values
   *         (optional)
   * @throws IllegalArgumentException if some property of the specified key
   *         or value prevents it from being stored in this map
   *         (optional)
   * @since 1.8
  */
  putIfAbsent(key: K, value: V): V;
  /**
   * Removes the mapping for a key from this map if it is present
   * (optional operation).   More formally, if this map contains a mapping
   * from key `k` to value `v` such that
   * `Objects.equals(key, k)`, that mapping
   * is removed.  (The map can contain at most one such mapping.)
   *
   * Returns the value to which this map previously associated the key,
   * or `null` if the map contained no mapping for the key.
   *
   * If this map permits null values, then a return value of
   * `null` does not necessarily indicate that the map
   * contained no mapping for the key; it's also possible that the map
   * explicitly mapped the key to `null`.
   *
   * The map will not contain a mapping for the specified key once the
   * call returns.
   *
   * @param key key whose mapping is to be removed from the map
   * @return the previous value associated with `key`, or
   *         `null` if there was no mapping for `key`.
   * @throws UnsupportedOperationException if the `remove` operation
   *         is not supported by this map
   * @throws ClassCastException if the key is of an inappropriate type for
   *         this map
   * (optional)
   * @throws NullPointerException if the specified key is null and this
   *         map does not permit null keys
   * (optional)
  */
  remove(key: any, value: any): boolean;
  /**
   * Replaces the entry for the specified key only if currently
   * mapped to the specified value.
   *
   * @implSpec
   * The default implementation is equivalent to, for this `map`:
   *
   *  {@code
   * if (map.containsKey(key) && Objects.equals(map.get(key), oldValue)) {
   *     map.put(key, newValue);
   *     return true;
   * } else
   *     return false;
   * }
   *
   * The default implementation does not throw NullPointerException
   * for maps that do not support null values if oldValue is null unless
   * newValue is also null.
   *
   * The default implementation makes no guarantees about synchronization
   * or atomicity properties of this method. Any implementation providing
   * atomicity guarantees must override this method and document its
   * concurrency properties.
   *
   * @param key key with which the specified value is associated
   * @param oldValue value expected to be associated with the specified key
   * @param newValue value to be associated with the specified key
   * @return `true` if the value was replaced
   * @throws UnsupportedOperationException if the `put` operation
   *         is not supported by this map
   *         (optional)
   * @throws ClassCastException if the class of a specified key or value
   *         prevents it from being stored in this map
   * @throws NullPointerException if a specified key or newValue is null,
   *         and this map does not permit null keys or values
   * @throws NullPointerException if oldValue is null and this map does not
   *         permit null values
   *         (optional)
   * @throws IllegalArgumentException if some property of a specified key
   *         or value prevents it from being stored in this map
   * @since 1.8
  */
  replace(key: K, oldValue: V, newValue: V): boolean;
  /**
   * Replaces the entry for the specified key only if currently
   * mapped to the specified value.
   *
   * @implSpec
   * The default implementation is equivalent to, for this `map`:
   *
   *  {@code
   * if (map.containsKey(key) && Objects.equals(map.get(key), oldValue)) {
   *     map.put(key, newValue);
   *     return true;
   * } else
   *     return false;
   * }
   *
   * The default implementation does not throw NullPointerException
   * for maps that do not support null values if oldValue is null unless
   * newValue is also null.
   *
   * The default implementation makes no guarantees about synchronization
   * or atomicity properties of this method. Any implementation providing
   * atomicity guarantees must override this method and document its
   * concurrency properties.
   *
   * @param key key with which the specified value is associated
   * @param oldValue value expected to be associated with the specified key
   * @param newValue value to be associated with the specified key
   * @return `true` if the value was replaced
   * @throws UnsupportedOperationException if the `put` operation
   *         is not supported by this map
   *         (optional)
   * @throws ClassCastException if the class of a specified key or value
   *         prevents it from being stored in this map
   * @throws NullPointerException if a specified key or newValue is null,
   *         and this map does not permit null keys or values
   * @throws NullPointerException if oldValue is null and this map does not
   *         permit null values
   *         (optional)
   * @throws IllegalArgumentException if some property of a specified key
   *         or value prevents it from being stored in this map
   * @since 1.8
  */
  replace(key: K, value: V): V;
  /**
   * {@inheritDoc}
   *
   * This method will, on a best-effort basis, throw a
   * {@link java.util.ConcurrentModificationException} if the mapping
   * function modified this map during computation.
   *
   * @throws ConcurrentModificationException if it is detected that the
   * mapping function modified this map
  */
  computeIfAbsent(key: K, mappingFunction: Function<any, V>): V;
  /**
   * {@inheritDoc}
   *
   * This method will, on a best-effort basis, throw a
   * {@link java.util.ConcurrentModificationException} if the remapping
   * function modified this map during computation.
   *
   * @throws ConcurrentModificationException if it is detected that the
   * remapping function modified this map
  */
  computeIfPresent(key: K, remappingFunction: BiFunction<any, any, V>): V;
  /**
   * {@inheritDoc}
   *
   * This method will, on a best-effort basis, throw a
   * {@link java.util.ConcurrentModificationException} if the remapping
   * function modified this map during computation.
   *
   * @throws ConcurrentModificationException if it is detected that the
   * remapping function modified this map
  */
  compute(key: K, remappingFunction: BiFunction<any, any, V>): V;
  /**
   * {@inheritDoc}
   *
   * This method will, on a best-effort basis, throw a
   * {@link java.util.ConcurrentModificationException} if the remapping
   * function modified this map during computation.
   *
   * @throws ConcurrentModificationException if it is detected that the
   * remapping function modified this map
  */
  merge(key: K, value: V, remappingFunction: BiFunction<any, any, V>): V;
}
export interface Hashtable<K, V> extends Dictionary<K, V>, Map<K, V>, Cloneable, Serializable {}
/**
 * An iterator over a collection.  `Iterator` takes the place of
 * {@link Enumeration} in the Java Collections Framework.  Iterators
 * differ from enumerations in two ways:
 *
 * 
 *       Iterators allow the caller to remove elements from the
 *           underlying collection during the iteration with well-defined
 *           semantics.
 *       Method names have been improved.
 * 
 *
 * This interface is a member of the
 * 
 * Java Collections Framework.
 *
 * @apiNote
 * An {@link Enumeration} can be converted into an `Iterator` by
 * using the {@link Enumeration#asIterator} method.
 *
 * @param  the type of elements returned by this iterator
 *
 * @author  Josh Bloch
 * @see Collection
 * @see ListIterator
 * @see Iterable
 * @since 1.2
*/
export class Iterator<E> {
  /**
   * Returns `true` if the iteration has more elements.
   * (In other words, returns `true` if {@link #next} would
   * return an element rather than throwing an exception.)
   *
   * @return `true` if the iteration has more elements
  */
  hasNext(): boolean;
  /**
   * Returns the next element in the iteration.
   *
   * @return the next element in the iteration
   * @throws NoSuchElementException if the iteration has no more elements
  */
  next(): E;
  /**
   * Removes from the underlying collection the last element returned
   * by this iterator (optional operation).  This method can be called
   * only once per call to {@link #next}.
   * 
   * The behavior of an iterator is unspecified if the underlying collection
   * is modified while the iteration is in progress in any way other than by
   * calling this method, unless an overriding class has specified a
   * concurrent modification policy.
   * 
   * The behavior of an iterator is unspecified if this method is called
   * after a call to the {@link #forEachRemaining forEachRemaining} method.
   *
   * @implSpec
   * The default implementation throws an instance of
   * {@link UnsupportedOperationException} and performs no other action.
   *
   * @throws UnsupportedOperationException if the `remove`
   *         operation is not supported by this iterator
   *
   * @throws IllegalStateException if the `next` method has not
   *         yet been called, or the `remove` method has already
   *         been called after the last call to the `next`
   *         method
  */
  remove(): void;
  /**
   * Performs the given action for each remaining element until all elements
   * have been processed or the action throws an exception.  Actions are
   * performed in the order of iteration, if that order is specified.
   * Exceptions thrown by the action are relayed to the caller.
   * 
   * The behavior of an iterator is unspecified if the action modifies the
   * collection in any way (even by calling the {@link #remove remove} method
   * or other mutator methods of `Iterator` subtypes),
   * unless an overriding class has specified a concurrent modification policy.
   * 
   * Subsequent behavior of an iterator is unspecified if the action throws an
   * exception.
   *
   * @implSpec
   * The default implementation behaves as if:
   * {@code
   *     while (hasNext())
   *         action.accept(next());
   * }
   *
   * @param action The action to be performed for each element
   * @throws NullPointerException if the specified action is null
   * @since 1.8
  */
  forEachRemaining(action: Consumer<any>): void;
}
/**
 * Unchecked exception thrown when an illegal combination flags is given.
 *
 *  Unless otherwise specified, passing a `null` argument to any
 * method or constructor in this class will cause a {@link
 * NullPointerException} to be thrown.
 *
 * @since 1.5
*/
export class IllegalFormatFlagsException extends IllegalFormatException {
  /**
   * Constructs an instance of this class with the specified flags.
   *
   * @param  f
   *         The set of format flags which contain an illegal combination
  */
  constructor(f: string);
  /**
   * Returns the set of flags which contains an illegal combination.
   *
   * @return  The flags
  */
  getFlags(): string;
  getMessage(): string;
}
export class Collections {
  /**
   * Sorts the specified list into ascending order, according to the
   * {@linkplain Comparable natural ordering} of its elements.
   * All elements in the list must implement the {@link Comparable}
   * interface.  Furthermore, all elements in the list must be
   * mutually comparable (that is, `e1.compareTo(e2)`
   * must not throw a `ClassCastException` for any elements
   * `e1` and `e2` in the list).
   *
   * This sort is guaranteed to be stable:  equal elements will
   * not be reordered as a result of the sort.
   *
   * The specified list must be modifiable, but need not be resizable.
   *
   * @implNote
   * This implementation defers to the {@link List#sort(Comparator)}
   * method using the specified list and a `null` comparator.
   *
   * @param   the class of the objects in the list
   * @param  list the list to be sorted.
   * @throws ClassCastException if the list contains elements that are not
   *         mutually comparable (for example, strings and integers).
   * @throws UnsupportedOperationException if the specified list's
   *         list-iterator does not support the `set` operation.
   * @throws IllegalArgumentException (optional) if the implementation
   *         detects that the natural ordering of the list elements is
   *         found to violate the {@link Comparable} contract
   * @see List#sort(Comparator)
  */
  static sort<T>(list: T[]): void;
  /**
   * Sorts the specified list according to the order induced by the
   * specified comparator.  All elements in the list must be mutually
   * comparable using the specified comparator (that is,
   * `c.compare(e1, e2)` must not throw a `ClassCastException`
   * for any elements `e1` and `e2` in the list).
   *
   * This sort is guaranteed to be stable:  equal elements will
   * not be reordered as a result of the sort.
   *
   * The specified list must be modifiable, but need not be resizable.
   *
   * @implNote
   * This implementation defers to the {@link List#sort(Comparator)}
   * method using the specified list and comparator.
   *
   * @param   the class of the objects in the list
   * @param  list the list to be sorted.
   * @param  c the comparator to determine the order of the list.  A
   *        `null` value indicates that the elements' natural
   *        ordering should be used.
   * @throws ClassCastException if the list contains elements that are not
   *         mutually comparable using the specified comparator.
   * @throws UnsupportedOperationException if the specified list's
   *         list-iterator does not support the `set` operation.
   * @throws IllegalArgumentException (optional) if the comparator is
   *         found to violate the {@link Comparator} contract
   * @see List#sort(Comparator)
  */
  static sort<T>(list: T[], c: Comparator<any>): void;
  /**
   * Searches the specified list for the specified object using the binary
   * search algorithm.  The list must be sorted into ascending order
   * according to the {@linkplain Comparable natural ordering} of its
   * elements (as by the {@link #sort(List)} method) prior to making this
   * call.  If it is not sorted, the results are undefined.  If the list
   * contains multiple elements equal to the specified object, there is no
   * guarantee which one will be found.
   *
   * This method runs in log(n) time for a "random access" list (which
   * provides near-constant-time positional access).  If the specified list
   * does not implement the {@link RandomAccess} interface and is large,
   * this method will do an iterator-based binary search that performs
   * O(n) link traversals and O(log n) element comparisons.
   *
   * @param   the class of the objects in the list
   * @param  list the list to be searched.
   * @param  key the key to be searched for.
   * @return the index of the search key, if it is contained in the list;
   *         otherwise, (-(insertion point) - 1).  The
   *         insertion point is defined as the point at which the
   *         key would be inserted into the list: the index of the first
   *         element greater than the key, or `list.size()` if all
   *         elements in the list are less than the specified key.  Note
   *         that this guarantees that the return value will be >= 0 if
   *         and only if the key is found.
   * @throws ClassCastException if the list contains elements that are not
   *         mutually comparable (for example, strings and
   *         integers), or the search key is not mutually comparable
   *         with the elements of the list.
  */
  static binarySearch<T>(list: Comparable<any>[], key: T): number;
  /**
   * Searches the specified list for the specified object using the binary
   * search algorithm.  The list must be sorted into ascending order
   * according to the specified comparator (as by the
   * {@link #sort(List, Comparator) sort(List, Comparator)}
   * method), prior to making this call.  If it is
   * not sorted, the results are undefined.  If the list contains multiple
   * elements equal to the specified object, there is no guarantee which one
   * will be found.
   *
   * This method runs in log(n) time for a "random access" list (which
   * provides near-constant-time positional access).  If the specified list
   * does not implement the {@link RandomAccess} interface and is large,
   * this method will do an iterator-based binary search that performs
   * O(n) link traversals and O(log n) element comparisons.
   *
   * @param   the class of the objects in the list
   * @param  list the list to be searched.
   * @param  key the key to be searched for.
   * @param  c the comparator by which the list is ordered.
   *         A `null` value indicates that the elements'
   *         {@linkplain Comparable natural ordering} should be used.
   * @return the index of the search key, if it is contained in the list;
   *         otherwise, (-(insertion point) - 1).  The
   *         insertion point is defined as the point at which the
   *         key would be inserted into the list: the index of the first
   *         element greater than the key, or `list.size()` if all
   *         elements in the list are less than the specified key.  Note
   *         that this guarantees that the return value will be >= 0 if
   *         and only if the key is found.
   * @throws ClassCastException if the list contains elements that are not
   *         mutually comparable using the specified comparator,
   *         or the search key is not mutually comparable with the
   *         elements of the list using this comparator.
  */
  static binarySearch<T>(list: T[], key: T, c: Comparator<any>): number;
  /**
   * Reverses the order of the elements in the specified list.
   *
   * This method runs in linear time.
   *
   * @param  list the list whose elements are to be reversed.
   * @throws UnsupportedOperationException if the specified list or
   *         its list-iterator does not support the `set` operation.
  */
  static reverse(list: any[]): void;
  /**
   * Randomly permutes the specified list using a default source of
   * randomness.  All permutations occur with approximately equal
   * likelihood.
   *
   * The hedge "approximately" is used in the foregoing description because
   * default source of randomness is only approximately an unbiased source
   * of independently chosen bits. If it were a perfect source of randomly
   * chosen bits, then the algorithm would choose permutations with perfect
   * uniformity.
   *
   * This implementation traverses the list backwards, from the last
   * element up to the second, repeatedly swapping a randomly selected element
   * into the "current position".  Elements are randomly selected from the
   * portion of the list that runs from the first element to the current
   * position, inclusive.
   *
   * This method runs in linear time.  If the specified list does not
   * implement the {@link RandomAccess} interface and is large, this
   * implementation dumps the specified list into an array before shuffling
   * it, and dumps the shuffled array back into the list.  This avoids the
   * quadratic behavior that would result from shuffling a "sequential
   * access" list in place.
   *
   * @param  list the list to be shuffled.
   * @throws UnsupportedOperationException if the specified list or
   *         its list-iterator does not support the `set` operation.
  */
  static shuffle(list: any[]): void;
  /**
   * Randomly permute the specified list using the specified source of
   * randomness.  All permutations occur with equal likelihood
   * assuming that the source of randomness is fair.
   *
   * This implementation traverses the list backwards, from the last element
   * up to the second, repeatedly swapping a randomly selected element into
   * the "current position".  Elements are randomly selected from the
   * portion of the list that runs from the first element to the current
   * position, inclusive.
   *
   * This method runs in linear time.  If the specified list does not
   * implement the {@link RandomAccess} interface and is large, this
   * implementation dumps the specified list into an array before shuffling
   * it, and dumps the shuffled array back into the list.  This avoids the
   * quadratic behavior that would result from shuffling a "sequential
   * access" list in place.
   *
   * @param  list the list to be shuffled.
   * @param  rnd the source of randomness to use to shuffle the list.
   * @throws UnsupportedOperationException if the specified list or its
   *         list-iterator does not support the `set` operation.
  */
  static shuffle(list: any[], rnd: Random): void;
  /**
   * Swaps the elements at the specified positions in the specified list.
   * (If the specified positions are equal, invoking this method leaves
   * the list unchanged.)
   *
   * @param list The list in which to swap elements.
   * @param i the index of one element to be swapped.
   * @param j the index of the other element to be swapped.
   * @throws IndexOutOfBoundsException if either `i` or `j`
   *         is out of range (i < 0 || i >= list.size()
   *         || j < 0 || j >= list.size()).
   * @since 1.4
  */
  static swap(list: any[], i: number, j: number): void;
  /**
   * Replaces all of the elements of the specified list with the specified
   * element. 
   *
   * This method runs in linear time.
   *
   * @param   the class of the objects in the list
   * @param  list the list to be filled with the specified element.
   * @param  obj The element with which to fill the specified list.
   * @throws UnsupportedOperationException if the specified list or its
   *         list-iterator does not support the `set` operation.
  */
  static fill<T>(list: any[], obj: T): void;
  /**
   * Copies all of the elements from one list into another.  After the
   * operation, the index of each copied element in the destination list
   * will be identical to its index in the source list.  The destination
   * list's size must be greater than or equal to the source list's size.
   * If it is greater, the remaining elements in the destination list are
   * unaffected. 
   *
   * This method runs in linear time.
   *
   * @param   the class of the objects in the lists
   * @param  dest The destination list.
   * @param  src The source list.
   * @throws IndexOutOfBoundsException if the destination list is too small
   *         to contain the entire source List.
   * @throws UnsupportedOperationException if the destination list's
   *         list-iterator does not support the `set` operation.
  */
  static copy<T>(dest: any[], src: T[]): void;
  /**
   * Returns the minimum element of the given collection, according to the
   * natural ordering of its elements.  All elements in the
   * collection must implement the `Comparable` interface.
   * Furthermore, all elements in the collection must be mutually
   * comparable (that is, `e1.compareTo(e2)` must not throw a
   * `ClassCastException` for any elements `e1` and
   * `e2` in the collection).
   *
   * This method iterates over the entire collection, hence it requires
   * time proportional to the size of the collection.
   *
   * @param   the class of the objects in the collection
   * @param  coll the collection whose minimum element is to be determined.
   * @return the minimum element of the given collection, according
   *         to the natural ordering of its elements.
   * @throws ClassCastException if the collection contains elements that are
   *         not mutually comparable (for example, strings and
   *         integers).
   * @throws NoSuchElementException if the collection is empty.
   * @see Comparable
  */
  static min<T>(coll: Collection<T>): T;
  /**
   * Returns the minimum element of the given collection, according to the
   * order induced by the specified comparator.  All elements in the
   * collection must be mutually comparable by the specified
   * comparator (that is, `comp.compare(e1, e2)` must not throw a
   * `ClassCastException` for any elements `e1` and
   * `e2` in the collection).
   *
   * This method iterates over the entire collection, hence it requires
   * time proportional to the size of the collection.
   *
   * @param   the class of the objects in the collection
   * @param  coll the collection whose minimum element is to be determined.
   * @param  comp the comparator with which to determine the minimum element.
   *         A `null` value indicates that the elements' natural
   *         ordering should be used.
   * @return the minimum element of the given collection, according
   *         to the specified comparator.
   * @throws ClassCastException if the collection contains elements that are
   *         not mutually comparable using the specified comparator.
   * @throws NoSuchElementException if the collection is empty.
   * @see Comparable
  */
  static min<T>(coll: Collection<T>, comp: Comparator<any>): T;
  /**
   * Returns the maximum element of the given collection, according to the
   * natural ordering of its elements.  All elements in the
   * collection must implement the `Comparable` interface.
   * Furthermore, all elements in the collection must be mutually
   * comparable (that is, `e1.compareTo(e2)` must not throw a
   * `ClassCastException` for any elements `e1` and
   * `e2` in the collection).
   *
   * This method iterates over the entire collection, hence it requires
   * time proportional to the size of the collection.
   *
   * @param   the class of the objects in the collection
   * @param  coll the collection whose maximum element is to be determined.
   * @return the maximum element of the given collection, according
   *         to the natural ordering of its elements.
   * @throws ClassCastException if the collection contains elements that are
   *         not mutually comparable (for example, strings and
   *         integers).
   * @throws NoSuchElementException if the collection is empty.
   * @see Comparable
  */
  static max<T>(coll: Collection<T>): T;
  /**
   * Returns the maximum element of the given collection, according to the
   * order induced by the specified comparator.  All elements in the
   * collection must be mutually comparable by the specified
   * comparator (that is, `comp.compare(e1, e2)` must not throw a
   * `ClassCastException` for any elements `e1` and
   * `e2` in the collection).
   *
   * This method iterates over the entire collection, hence it requires
   * time proportional to the size of the collection.
   *
   * @param   the class of the objects in the collection
   * @param  coll the collection whose maximum element is to be determined.
   * @param  comp the comparator with which to determine the maximum element.
   *         A `null` value indicates that the elements' natural
   *        ordering should be used.
   * @return the maximum element of the given collection, according
   *         to the specified comparator.
   * @throws ClassCastException if the collection contains elements that are
   *         not mutually comparable using the specified comparator.
   * @throws NoSuchElementException if the collection is empty.
   * @see Comparable
  */
  static max<T>(coll: Collection<T>, comp: Comparator<any>): T;
  /**
   * Rotates the elements in the specified list by the specified distance.
   * After calling this method, the element at index `i` will be
   * the element previously at index `(i - distance)` mod
   * `list.size()`, for all values of `i` between `0`
   * and `list.size()-1`, inclusive.  (This method has no effect on
   * the size of the list.)
   *
   * For example, suppose `list` comprises` [t, a, n, k, s]`.
   * After invoking `Collections.rotate(list, 1)` (or
   * `Collections.rotate(list, -4)`), `list` will comprise
   * `[s, t, a, n, k]`.
   *
   * Note that this method can usefully be applied to sublists to
   * move one or more elements within a list while preserving the
   * order of the remaining elements.  For example, the following idiom
   * moves the element at index `j` forward to position
   * `k` (which must be greater than or equal to `j`):
   *      *     Collections.rotate(list.subList(j, k+1), -1);
   * 
   * To make this concrete, suppose `list` comprises
   * `[a, b, c, d, e]`.  To move the element at index `1`
   * (`b`) forward two positions, perform the following invocation:
   *      *     Collections.rotate(l.subList(1, 4), -1);
   * 
   * The resulting list is `[a, c, d, b, e]`.
   *
   * To move more than one element forward, increase the absolute value
   * of the rotation distance.  To move elements backward, use a positive
   * shift distance.
   *
   * If the specified list is small or implements the {@link
   * RandomAccess} interface, this implementation exchanges the first
   * element into the location it should go, and then repeatedly exchanges
   * the displaced element into the location it should go until a displaced
   * element is swapped into the first element.  If necessary, the process
   * is repeated on the second and successive elements, until the rotation
   * is complete.  If the specified list is large and doesn't implement the
   * `RandomAccess` interface, this implementation breaks the
   * list into two sublist views around index `-distance mod size`.
   * Then the {@link #reverse(List)} method is invoked on each sublist view,
   * and finally it is invoked on the entire list.  For a more complete
   * description of both algorithms, see Section 2.3 of Jon Bentley's
   * Programming Pearls (Addison-Wesley, 1986).
   *
   * @param list the list to be rotated.
   * @param distance the distance to rotate the list.  There are no
   *        constraints on this value; it may be zero, negative, or
   *        greater than `list.size()`.
   * @throws UnsupportedOperationException if the specified list or
   *         its list-iterator does not support the `set` operation.
   * @since 1.4
  */
  static rotate(list: any[], distance: number): void;
  /**
   * Replaces all occurrences of one specified value in a list with another.
   * More formally, replaces with `newVal` each element `e`
   * in `list` such that
   * `(oldVal==null ? e==null : oldVal.equals(e))`.
   * (This method has no effect on the size of the list.)
   *
   * @param   the class of the objects in the list
   * @param list the list in which replacement is to occur.
   * @param oldVal the old value to be replaced.
   * @param newVal the new value with which `oldVal` is to be
   *        replaced.
   * @return `true` if `list` contained one or more elements
   *         `e` such that
   *         `(oldVal==null ?  e==null : oldVal.equals(e))`.
   * @throws UnsupportedOperationException if the specified list or
   *         its list-iterator does not support the `set` operation.
   * @since  1.4
  */
  static replaceAll<T>(list: T[], oldVal: T, newVal: T): boolean;
  /**
   * Returns the starting position of the first occurrence of the specified
   * target list within the specified source list, or -1 if there is no
   * such occurrence.  More formally, returns the lowest index `i`
   * such that `source.subList(i, i+target.size()).equals(target)`,
   * or -1 if there is no such index.  (Returns -1 if
   * `target.size() > source.size()`)
   *
   * This implementation uses the "brute force" technique of scanning
   * over the source list, looking for a match with the target at each
   * location in turn.
   *
   * @param source the list in which to search for the first occurrence
   *        of `target`.
   * @param target the list to search for as a subList of `source`.
   * @return the starting position of the first occurrence of the specified
   *         target list within the specified source list, or -1 if there
   *         is no such occurrence.
   * @since  1.4
  */
  static indexOfSubList(source: any[], target: any[]): number;
  /**
   * Returns the starting position of the last occurrence of the specified
   * target list within the specified source list, or -1 if there is no such
   * occurrence.  More formally, returns the highest index `i`
   * such that `source.subList(i, i+target.size()).equals(target)`,
   * or -1 if there is no such index.  (Returns -1 if
   * `target.size() > source.size()`)
   *
   * This implementation uses the "brute force" technique of iterating
   * over the source list, looking for a match with the target at each
   * location in turn.
   *
   * @param source the list in which to search for the last occurrence
   *        of `target`.
   * @param target the list to search for as a subList of `source`.
   * @return the starting position of the last occurrence of the specified
   *         target list within the specified source list, or -1 if there
   *         is no such occurrence.
   * @since  1.4
  */
  static lastIndexOfSubList(source: any[], target: any[]): number;
  /**
   * Returns an unmodifiable view of the
   * specified collection. Query operations on the returned collection "read through"
   * to the specified collection, and attempts to modify the returned
   * collection, whether direct or via its iterator, result in an
   * `UnsupportedOperationException`.
   *
   * The returned collection does not pass the hashCode and equals
   * operations through to the backing collection, but relies on
   * `Object`'s `equals` and `hashCode` methods.  This
   * is necessary to preserve the contracts of these operations in the case
   * that the backing collection is a set or a list.
   *
   * The returned collection will be serializable if the specified collection
   * is serializable.
   *
   * @param   the class of the objects in the collection
   * @param  c the collection for which an unmodifiable view is to be
   *         returned.
   * @return an unmodifiable view of the specified collection.
  */
  static unmodifiableCollection<T>(c: Collection<T>): Collection<T>;
  /**
   * Returns an unmodifiable view of the
   * specified set. Query operations on the returned set "read through" to the specified
   * set, and attempts to modify the returned set, whether direct or via its
   * iterator, result in an `UnsupportedOperationException`.
   *
   * The returned set will be serializable if the specified set
   * is serializable.
   *
   * @param   the class of the objects in the set
   * @param  s the set for which an unmodifiable view is to be returned.
   * @return an unmodifiable view of the specified set.
  */
  static unmodifiableSet<T>(s: Set<T>): Set<T>;
  /**
   * Returns an unmodifiable view of the
   * specified sorted set. Query operations on the returned sorted set "read
   * through" to the specified sorted set.  Attempts to modify the returned
   * sorted set, whether direct, via its iterator, or via its
   * `subSet`, `headSet`, or `tailSet` views, result in
   * an `UnsupportedOperationException`.
   *
   * The returned sorted set will be serializable if the specified sorted set
   * is serializable.
   *
   * @param   the class of the objects in the set
   * @param s the sorted set for which an unmodifiable view is to be
   *        returned.
   * @return an unmodifiable view of the specified sorted set.
  */
  static unmodifiableSortedSet<T>(s: SortedSet<T>): SortedSet<T>;
  /**
   * Returns an unmodifiable view of the
   * specified navigable set. Query operations on the returned navigable set "read
   * through" to the specified navigable set.  Attempts to modify the returned
   * navigable set, whether direct, via its iterator, or via its
   * `subSet`, `headSet`, or `tailSet` views, result in
   * an `UnsupportedOperationException`.
   *
   * The returned navigable set will be serializable if the specified
   * navigable set is serializable.
   *
   * @param   the class of the objects in the set
   * @param s the navigable set for which an unmodifiable view is to be
   *        returned
   * @return an unmodifiable view of the specified navigable set
   * @since 1.8
  */
  static unmodifiableNavigableSet<T>(s: NavigableSet<T>): NavigableSet<T>;
  /**
   * Returns an unmodifiable view of the
   * specified list. Query operations on the returned list "read through" to the
   * specified list, and attempts to modify the returned list, whether
   * direct or via its iterator, result in an
   * `UnsupportedOperationException`.
   *
   * The returned list will be serializable if the specified list
   * is serializable. Similarly, the returned list will implement
   * {@link RandomAccess} if the specified list does.
   *
   * @param   the class of the objects in the list
   * @param  list the list for which an unmodifiable view is to be returned.
   * @return an unmodifiable view of the specified list.
  */
  static unmodifiableList<T>(list: T[]): T[];
  /**
   * Returns an unmodifiable view of the
   * specified map. Query operations on the returned map "read through"
   * to the specified map, and attempts to modify the returned
   * map, whether direct or via its collection views, result in an
   * `UnsupportedOperationException`.
   *
   * The returned map will be serializable if the specified map
   * is serializable.
   *
   * @param  the class of the map keys
   * @param  the class of the map values
   * @param  m the map for which an unmodifiable view is to be returned.
   * @return an unmodifiable view of the specified map.
  */
  static unmodifiableMap<K, V>(m: Map<K, V>): Map<K, V>;
  /**
   * Returns an unmodifiable view of the
   * specified sorted map. Query operations on the returned sorted map "read through"
   * to the specified sorted map.  Attempts to modify the returned
   * sorted map, whether direct, via its collection views, or via its
   * `subMap`, `headMap`, or `tailMap` views, result in
   * an `UnsupportedOperationException`.
   *
   * The returned sorted map will be serializable if the specified sorted map
   * is serializable.
   *
   * @param  the class of the map keys
   * @param  the class of the map values
   * @param m the sorted map for which an unmodifiable view is to be
   *        returned.
   * @return an unmodifiable view of the specified sorted map.
  */
  static unmodifiableSortedMap<K, V>(m: SortedMap<K, V>): SortedMap<K, V>;
  /**
   * Returns an unmodifiable view of the
   * specified navigable map. Query operations on the returned navigable map "read
   * through" to the specified navigable map.  Attempts to modify the returned
   * navigable map, whether direct, via its collection views, or via its
   * `subMap`, `headMap`, or `tailMap` views, result in
   * an `UnsupportedOperationException`.
   *
   * The returned navigable map will be serializable if the specified
   * navigable map is serializable.
   *
   * @param  the class of the map keys
   * @param  the class of the map values
   * @param m the navigable map for which an unmodifiable view is to be
   *        returned
   * @return an unmodifiable view of the specified navigable map
   * @since 1.8
  */
  static unmodifiableNavigableMap<K, V>(m: NavigableMap<K, V>): NavigableMap<K, V>;
  /**
   * Returns a synchronized (thread-safe) collection backed by the specified
   * collection.  In order to guarantee serial access, it is critical that
   * all access to the backing collection is accomplished
   * through the returned collection.
   *
   * It is imperative that the user manually synchronize on the returned
   * collection when traversing it via {@link Iterator}, {@link Spliterator}
   * or {@link Stream}:
   *      *  Collection c = Collections.synchronizedCollection(myCollection);
   *     ...
   *  synchronized (c) {
   *      Iterator i = c.iterator(); // Must be in the synchronized block
   *      while (i.hasNext())
   *         foo(i.next());
   *  }
   * 
   * Failure to follow this advice may result in non-deterministic behavior.
   *
   * The returned collection does not pass the `hashCode`
   * and `equals` operations through to the backing collection, but
   * relies on `Object`'s equals and hashCode methods.  This is
   * necessary to preserve the contracts of these operations in the case
   * that the backing collection is a set or a list.
   *
   * The returned collection will be serializable if the specified collection
   * is serializable.
   *
   * @param   the class of the objects in the collection
   * @param  c the collection to be "wrapped" in a synchronized collection.
   * @return a synchronized view of the specified collection.
  */
  static synchronizedCollection<T>(c: Collection<T>): Collection<T>;
  /**
   * Returns a synchronized (thread-safe) set backed by the specified
   * set.  In order to guarantee serial access, it is critical that
   * all access to the backing set is accomplished
   * through the returned set.
   *
   * It is imperative that the user manually synchronize on the returned
   * collection when traversing it via {@link Iterator}, {@link Spliterator}
   * or {@link Stream}:
   *      *  Set s = Collections.synchronizedSet(new HashSet());
   *      ...
   *  synchronized (s) {
   *      Iterator i = s.iterator(); // Must be in the synchronized block
   *      while (i.hasNext())
   *          foo(i.next());
   *  }
   * 
   * Failure to follow this advice may result in non-deterministic behavior.
   *
   * The returned set will be serializable if the specified set is
   * serializable.
   *
   * @param   the class of the objects in the set
   * @param  s the set to be "wrapped" in a synchronized set.
   * @return a synchronized view of the specified set.
  */
  static synchronizedSet<T>(s: Set<T>): Set<T>;
  /**
   * Returns a synchronized (thread-safe) sorted set backed by the specified
   * sorted set.  In order to guarantee serial access, it is critical that
   * all access to the backing sorted set is accomplished
   * through the returned sorted set (or its views).
   *
   * It is imperative that the user manually synchronize on the returned
   * sorted set when traversing it or any of its `subSet`,
   * `headSet`, or `tailSet` views via {@link Iterator},
   * {@link Spliterator} or {@link Stream}:
   *      *  SortedSet s = Collections.synchronizedSortedSet(new TreeSet());
   *      ...
   *  synchronized (s) {
   *      Iterator i = s.iterator(); // Must be in the synchronized block
   *      while (i.hasNext())
   *          foo(i.next());
   *  }
   * 
   * or:
   *      *  SortedSet s = Collections.synchronizedSortedSet(new TreeSet());
   *  SortedSet s2 = s.headSet(foo);
   *      ...
   *  synchronized (s) {  // Note: s, not s2!!!
   *      Iterator i = s2.iterator(); // Must be in the synchronized block
   *      while (i.hasNext())
   *          foo(i.next());
   *  }
   * 
   * Failure to follow this advice may result in non-deterministic behavior.
   *
   * The returned sorted set will be serializable if the specified
   * sorted set is serializable.
   *
   * @param   the class of the objects in the set
   * @param  s the sorted set to be "wrapped" in a synchronized sorted set.
   * @return a synchronized view of the specified sorted set.
  */
  static synchronizedSortedSet<T>(s: SortedSet<T>): SortedSet<T>;
  /**
   * Returns a synchronized (thread-safe) navigable set backed by the
   * specified navigable set.  In order to guarantee serial access, it is
   * critical that all access to the backing navigable set is
   * accomplished through the returned navigable set (or its views).
   *
   * It is imperative that the user manually synchronize on the returned
   * navigable set when traversing it, or any of its `subSet`,
   * `headSet`, or `tailSet` views, via {@link Iterator},
   * {@link Spliterator} or {@link Stream}:
   *      *  NavigableSet s = Collections.synchronizedNavigableSet(new TreeSet());
   *      ...
   *  synchronized (s) {
   *      Iterator i = s.iterator(); // Must be in the synchronized block
   *      while (i.hasNext())
   *          foo(i.next());
   *  }
   * 
   * or:
   *      *  NavigableSet s = Collections.synchronizedNavigableSet(new TreeSet());
   *  NavigableSet s2 = s.headSet(foo, true);
   *      ...
   *  synchronized (s) {  // Note: s, not s2!!!
   *      Iterator i = s2.iterator(); // Must be in the synchronized block
   *      while (i.hasNext())
   *          foo(i.next());
   *  }
   * 
   * Failure to follow this advice may result in non-deterministic behavior.
   *
   * The returned navigable set will be serializable if the specified
   * navigable set is serializable.
   *
   * @param   the class of the objects in the set
   * @param  s the navigable set to be "wrapped" in a synchronized navigable
   * set
   * @return a synchronized view of the specified navigable set
   * @since 1.8
  */
  static synchronizedNavigableSet<T>(s: NavigableSet<T>): NavigableSet<T>;
  /**
   * Returns a synchronized (thread-safe) list backed by the specified
   * list.  In order to guarantee serial access, it is critical that
   * all access to the backing list is accomplished
   * through the returned list.
   *
   * It is imperative that the user manually synchronize on the returned
   * list when traversing it via {@link Iterator}, {@link Spliterator}
   * or {@link Stream}:
   *      *  List list = Collections.synchronizedList(new ArrayList());
   *      ...
   *  synchronized (list) {
   *      Iterator i = list.iterator(); // Must be in synchronized block
   *      while (i.hasNext())
   *          foo(i.next());
   *  }
   * 
   * Failure to follow this advice may result in non-deterministic behavior.
   *
   * The returned list will be serializable if the specified list is
   * serializable.
   *
   * @param   the class of the objects in the list
   * @param  list the list to be "wrapped" in a synchronized list.
   * @return a synchronized view of the specified list.
  */
  static synchronizedList<T>(list: T[]): T[];
  /**
   * Returns a synchronized (thread-safe) map backed by the specified
   * map.  In order to guarantee serial access, it is critical that
   * all access to the backing map is accomplished
   * through the returned map.
   *
   * It is imperative that the user manually synchronize on the returned
   * map when traversing any of its collection views via {@link Iterator},
   * {@link Spliterator} or {@link Stream}:
   *      *  Map m = Collections.synchronizedMap(new HashMap());
   *      ...
   *  Set s = m.keySet();  // Needn't be in synchronized block
   *      ...
   *  synchronized (m) {  // Synchronizing on m, not s!
   *      Iterator i = s.iterator(); // Must be in synchronized block
   *      while (i.hasNext())
   *          foo(i.next());
   *  }
   * 
   * Failure to follow this advice may result in non-deterministic behavior.
   *
   * The returned map will be serializable if the specified map is
   * serializable.
   *
   * @param  the class of the map keys
   * @param  the class of the map values
   * @param  m the map to be "wrapped" in a synchronized map.
   * @return a synchronized view of the specified map.
  */
  static synchronizedMap<K, V>(m: Map<K, V>): Map<K, V>;
  /**
   * Returns a synchronized (thread-safe) sorted map backed by the specified
   * sorted map.  In order to guarantee serial access, it is critical that
   * all access to the backing sorted map is accomplished
   * through the returned sorted map (or its views).
   *
   * It is imperative that the user manually synchronize on the returned
   * sorted map when traversing any of its collection views, or the
   * collections views of any of its `subMap`, `headMap` or
   * `tailMap` views, via {@link Iterator}, {@link Spliterator} or
   * {@link Stream}:
   *      *  SortedMap m = Collections.synchronizedSortedMap(new TreeMap());
   *      ...
   *  Set s = m.keySet();  // Needn't be in synchronized block
   *      ...
   *  synchronized (m) {  // Synchronizing on m, not s!
   *      Iterator i = s.iterator(); // Must be in synchronized block
   *      while (i.hasNext())
   *          foo(i.next());
   *  }
   * 
   * or:
   *      *  SortedMap m = Collections.synchronizedSortedMap(new TreeMap());
   *  SortedMap m2 = m.subMap(foo, bar);
   *      ...
   *  Set s2 = m2.keySet();  // Needn't be in synchronized block
   *      ...
   *  synchronized (m) {  // Synchronizing on m, not m2 or s2!
   *      Iterator i = s2.iterator(); // Must be in synchronized block
   *      while (i.hasNext())
   *          foo(i.next());
   *  }
   * 
   * Failure to follow this advice may result in non-deterministic behavior.
   *
   * The returned sorted map will be serializable if the specified
   * sorted map is serializable.
   *
   * @param  the class of the map keys
   * @param  the class of the map values
   * @param  m the sorted map to be "wrapped" in a synchronized sorted map.
   * @return a synchronized view of the specified sorted map.
  */
  static synchronizedSortedMap<K, V>(m: SortedMap<K, V>): SortedMap<K, V>;
  /**
   * Returns a synchronized (thread-safe) navigable map backed by the
   * specified navigable map.  In order to guarantee serial access, it is
   * critical that all access to the backing navigable map is
   * accomplished through the returned navigable map (or its views).
   *
   * It is imperative that the user manually synchronize on the returned
   * navigable map when traversing any of its collection views, or the
   * collections views of any of its `subMap`, `headMap` or
   * `tailMap` views, via {@link Iterator}, {@link Spliterator} or
   * {@link Stream}:
   *      *  NavigableMap m = Collections.synchronizedNavigableMap(new TreeMap());
   *      ...
   *  Set s = m.keySet();  // Needn't be in synchronized block
   *      ...
   *  synchronized (m) {  // Synchronizing on m, not s!
   *      Iterator i = s.iterator(); // Must be in synchronized block
   *      while (i.hasNext())
   *          foo(i.next());
   *  }
   * 
   * or:
   *      *  NavigableMap m = Collections.synchronizedNavigableMap(new TreeMap());
   *  NavigableMap m2 = m.subMap(foo, true, bar, false);
   *      ...
   *  Set s2 = m2.keySet();  // Needn't be in synchronized block
   *      ...
   *  synchronized (m) {  // Synchronizing on m, not m2 or s2!
   *      Iterator i = s.iterator(); // Must be in synchronized block
   *      while (i.hasNext())
   *          foo(i.next());
   *  }
   * 
   * Failure to follow this advice may result in non-deterministic behavior.
   *
   * The returned navigable map will be serializable if the specified
   * navigable map is serializable.
   *
   * @param  the class of the map keys
   * @param  the class of the map values
   * @param  m the navigable map to be "wrapped" in a synchronized navigable
   *              map
   * @return a synchronized view of the specified navigable map.
   * @since 1.8
  */
  static synchronizedNavigableMap<K, V>(m: NavigableMap<K, V>): NavigableMap<K, V>;
  /**
   * Returns a dynamically typesafe view of the specified collection.
   * Any attempt to insert an element of the wrong type will result in an
   * immediate {@link ClassCastException}.  Assuming a collection
   * contains no incorrectly typed elements prior to the time a
   * dynamically typesafe view is generated, and that all subsequent
   * access to the collection takes place through the view, it is
   * guaranteed that the collection cannot contain an incorrectly
   * typed element.
   *
   * The generics mechanism in the language provides compile-time
   * (static) type checking, but it is possible to defeat this mechanism
   * with unchecked casts.  Usually this is not a problem, as the compiler
   * issues warnings on all such unchecked operations.  There are, however,
   * times when static type checking alone is not sufficient.  For example,
   * suppose a collection is passed to a third-party library and it is
   * imperative that the library code not corrupt the collection by
   * inserting an element of the wrong type.
   *
   * Another use of dynamically typesafe views is debugging.  Suppose a
   * program fails with a `ClassCastException`, indicating that an
   * incorrectly typed element was put into a parameterized collection.
   * Unfortunately, the exception can occur at any time after the erroneous
   * element is inserted, so it typically provides little or no information
   * as to the real source of the problem.  If the problem is reproducible,
   * one can quickly determine its source by temporarily modifying the
   * program to wrap the collection with a dynamically typesafe view.
   * For example, this declaration:
   *   {@code
   *     Collection c = new HashSet<>();
   * }
   * may be replaced temporarily by this one:
   *   {@code
   *     Collection c = Collections.checkedCollection(
   *         new HashSet<>(), String.class);
   * }
   * Running the program again will cause it to fail at the point where
   * an incorrectly typed element is inserted into the collection, clearly
   * identifying the source of the problem.  Once the problem is fixed, the
   * modified declaration may be reverted back to the original.
   *
   * The returned collection does not pass the hashCode and equals
   * operations through to the backing collection, but relies on
   * `Object`'s `equals` and `hashCode` methods.  This
   * is necessary to preserve the contracts of these operations in the case
   * that the backing collection is a set or a list.
   *
   * The returned collection will be serializable if the specified
   * collection is serializable.
   *
   * Since `null` is considered to be a value of any reference
   * type, the returned collection permits insertion of null elements
   * whenever the backing collection does.
   *
   * @param  the class of the objects in the collection
   * @param c the collection for which a dynamically typesafe view is to be
   *          returned
   * @param type the type of element that `c` is permitted to hold
   * @return a dynamically typesafe view of the specified collection
   * @since 1.5
  */
  static checkedCollection<E>(c: Collection<E>, type: Class<E>): Collection<E>;
  /**
   * Returns a dynamically typesafe view of the specified queue.
   * Any attempt to insert an element of the wrong type will result in
   * an immediate {@link ClassCastException}.  Assuming a queue contains
   * no incorrectly typed elements prior to the time a dynamically typesafe
   * view is generated, and that all subsequent access to the queue
   * takes place through the view, it is guaranteed that the
   * queue cannot contain an incorrectly typed element.
   *
   * A discussion of the use of dynamically typesafe views may be
   * found in the documentation for the {@link #checkedCollection
   * checkedCollection} method.
   *
   * The returned queue will be serializable if the specified queue
   * is serializable.
   *
   * Since `null` is considered to be a value of any reference
   * type, the returned queue permits insertion of `null` elements
   * whenever the backing queue does.
   *
   * @param  the class of the objects in the queue
   * @param queue the queue for which a dynamically typesafe view is to be
   *             returned
   * @param type the type of element that `queue` is permitted to hold
   * @return a dynamically typesafe view of the specified queue
   * @since 1.8
  */
  static checkedQueue<E>(queue: Queue<E>, type: Class<E>): Queue<E>;
  /**
   * Returns a dynamically typesafe view of the specified set.
   * Any attempt to insert an element of the wrong type will result in
   * an immediate {@link ClassCastException}.  Assuming a set contains
   * no incorrectly typed elements prior to the time a dynamically typesafe
   * view is generated, and that all subsequent access to the set
   * takes place through the view, it is guaranteed that the
   * set cannot contain an incorrectly typed element.
   *
   * A discussion of the use of dynamically typesafe views may be
   * found in the documentation for the {@link #checkedCollection
   * checkedCollection} method.
   *
   * The returned set will be serializable if the specified set is
   * serializable.
   *
   * Since `null` is considered to be a value of any reference
   * type, the returned set permits insertion of null elements whenever
   * the backing set does.
   *
   * @param  the class of the objects in the set
   * @param s the set for which a dynamically typesafe view is to be
   *          returned
   * @param type the type of element that `s` is permitted to hold
   * @return a dynamically typesafe view of the specified set
   * @since 1.5
  */
  static checkedSet<E>(s: Set<E>, type: Class<E>): Set<E>;
  /**
   * Returns a dynamically typesafe view of the specified sorted set.
   * Any attempt to insert an element of the wrong type will result in an
   * immediate {@link ClassCastException}.  Assuming a sorted set
   * contains no incorrectly typed elements prior to the time a
   * dynamically typesafe view is generated, and that all subsequent
   * access to the sorted set takes place through the view, it is
   * guaranteed that the sorted set cannot contain an incorrectly
   * typed element.
   *
   * A discussion of the use of dynamically typesafe views may be
   * found in the documentation for the {@link #checkedCollection
   * checkedCollection} method.
   *
   * The returned sorted set will be serializable if the specified sorted
   * set is serializable.
   *
   * Since `null` is considered to be a value of any reference
   * type, the returned sorted set permits insertion of null elements
   * whenever the backing sorted set does.
   *
   * @param  the class of the objects in the set
   * @param s the sorted set for which a dynamically typesafe view is to be
   *          returned
   * @param type the type of element that `s` is permitted to hold
   * @return a dynamically typesafe view of the specified sorted set
   * @since 1.5
  */
  static checkedSortedSet<E>(s: SortedSet<E>, type: Class<E>): SortedSet<E>;
  /**
   * Returns a dynamically typesafe view of the specified navigable set.
   * Any attempt to insert an element of the wrong type will result in an
   * immediate {@link ClassCastException}.  Assuming a navigable set
   * contains no incorrectly typed elements prior to the time a
   * dynamically typesafe view is generated, and that all subsequent
   * access to the navigable set takes place through the view, it is
   * guaranteed that the navigable set cannot contain an incorrectly
   * typed element.
   *
   * A discussion of the use of dynamically typesafe views may be
   * found in the documentation for the {@link #checkedCollection
   * checkedCollection} method.
   *
   * The returned navigable set will be serializable if the specified
   * navigable set is serializable.
   *
   * Since `null` is considered to be a value of any reference
   * type, the returned navigable set permits insertion of null elements
   * whenever the backing sorted set does.
   *
   * @param  the class of the objects in the set
   * @param s the navigable set for which a dynamically typesafe view is to be
   *          returned
   * @param type the type of element that `s` is permitted to hold
   * @return a dynamically typesafe view of the specified navigable set
   * @since 1.8
  */
  static checkedNavigableSet<E>(s: NavigableSet<E>, type: Class<E>): NavigableSet<E>;
  /**
   * Returns a dynamically typesafe view of the specified list.
   * Any attempt to insert an element of the wrong type will result in
   * an immediate {@link ClassCastException}.  Assuming a list contains
   * no incorrectly typed elements prior to the time a dynamically typesafe
   * view is generated, and that all subsequent access to the list
   * takes place through the view, it is guaranteed that the
   * list cannot contain an incorrectly typed element.
   *
   * A discussion of the use of dynamically typesafe views may be
   * found in the documentation for the {@link #checkedCollection
   * checkedCollection} method.
   *
   * The returned list will be serializable if the specified list
   * is serializable.
   *
   * Since `null` is considered to be a value of any reference
   * type, the returned list permits insertion of null elements whenever
   * the backing list does.
   *
   * @param  the class of the objects in the list
   * @param list the list for which a dynamically typesafe view is to be
   *             returned
   * @param type the type of element that `list` is permitted to hold
   * @return a dynamically typesafe view of the specified list
   * @since 1.5
  */
  static checkedList<E>(list: E[], type: Class<E>): E[];
  /**
   * Returns a dynamically typesafe view of the specified map.
   * Any attempt to insert a mapping whose key or value have the wrong
   * type will result in an immediate {@link ClassCastException}.
   * Similarly, any attempt to modify the value currently associated with
   * a key will result in an immediate {@link ClassCastException},
   * whether the modification is attempted directly through the map
   * itself, or through a {@link Map.Entry} instance obtained from the
   * map's {@link Map#entrySet() entry set} view.
   *
   * Assuming a map contains no incorrectly typed keys or values
   * prior to the time a dynamically typesafe view is generated, and
   * that all subsequent access to the map takes place through the view
   * (or one of its collection views), it is guaranteed that the
   * map cannot contain an incorrectly typed key or value.
   *
   * A discussion of the use of dynamically typesafe views may be
   * found in the documentation for the {@link #checkedCollection
   * checkedCollection} method.
   *
   * The returned map will be serializable if the specified map is
   * serializable.
   *
   * Since `null` is considered to be a value of any reference
   * type, the returned map permits insertion of null keys or values
   * whenever the backing map does.
   *
   * @param  the class of the map keys
   * @param  the class of the map values
   * @param m the map for which a dynamically typesafe view is to be
   *          returned
   * @param keyType the type of key that `m` is permitted to hold
   * @param valueType the type of value that `m` is permitted to hold
   * @return a dynamically typesafe view of the specified map
   * @since 1.5
  */
  static checkedMap<K, V>(m: Map<K, V>, keyType: Class<K>, valueType: Class<V>): Map<K, V>;
  /**
   * Returns a dynamically typesafe view of the specified sorted map.
   * Any attempt to insert a mapping whose key or value have the wrong
   * type will result in an immediate {@link ClassCastException}.
   * Similarly, any attempt to modify the value currently associated with
   * a key will result in an immediate {@link ClassCastException},
   * whether the modification is attempted directly through the map
   * itself, or through a {@link Map.Entry} instance obtained from the
   * map's {@link Map#entrySet() entry set} view.
   *
   * Assuming a map contains no incorrectly typed keys or values
   * prior to the time a dynamically typesafe view is generated, and
   * that all subsequent access to the map takes place through the view
   * (or one of its collection views), it is guaranteed that the
   * map cannot contain an incorrectly typed key or value.
   *
   * A discussion of the use of dynamically typesafe views may be
   * found in the documentation for the {@link #checkedCollection
   * checkedCollection} method.
   *
   * The returned map will be serializable if the specified map is
   * serializable.
   *
   * Since `null` is considered to be a value of any reference
   * type, the returned map permits insertion of null keys or values
   * whenever the backing map does.
   *
   * @param  the class of the map keys
   * @param  the class of the map values
   * @param m the map for which a dynamically typesafe view is to be
   *          returned
   * @param keyType the type of key that `m` is permitted to hold
   * @param valueType the type of value that `m` is permitted to hold
   * @return a dynamically typesafe view of the specified map
   * @since 1.5
  */
  static checkedSortedMap<K, V>(m: SortedMap<K, V>, keyType: Class<K>, valueType: Class<V>): SortedMap<K, V>;
  /**
   * Returns a dynamically typesafe view of the specified navigable map.
   * Any attempt to insert a mapping whose key or value have the wrong
   * type will result in an immediate {@link ClassCastException}.
   * Similarly, any attempt to modify the value currently associated with
   * a key will result in an immediate {@link ClassCastException},
   * whether the modification is attempted directly through the map
   * itself, or through a {@link Map.Entry} instance obtained from the
   * map's {@link Map#entrySet() entry set} view.
   *
   * Assuming a map contains no incorrectly typed keys or values
   * prior to the time a dynamically typesafe view is generated, and
   * that all subsequent access to the map takes place through the view
   * (or one of its collection views), it is guaranteed that the
   * map cannot contain an incorrectly typed key or value.
   *
   * A discussion of the use of dynamically typesafe views may be
   * found in the documentation for the {@link #checkedCollection
   * checkedCollection} method.
   *
   * The returned map will be serializable if the specified map is
   * serializable.
   *
   * Since `null` is considered to be a value of any reference
   * type, the returned map permits insertion of null keys or values
   * whenever the backing map does.
   *
   * @param  type of map keys
   * @param  type of map values
   * @param m the map for which a dynamically typesafe view is to be
   *          returned
   * @param keyType the type of key that `m` is permitted to hold
   * @param valueType the type of value that `m` is permitted to hold
   * @return a dynamically typesafe view of the specified map
   * @since 1.8
  */
  static checkedNavigableMap<K, V>(m: NavigableMap<K, V>, keyType: Class<K>, valueType: Class<V>): NavigableMap<K, V>;
  /**
   * Returns an iterator that has no elements.  More precisely,
   *
   * 
   * {@link Iterator#hasNext hasNext} always returns `     * false`.
   * {@link Iterator#next next} always throws {@link
   * NoSuchElementException}.
   * {@link Iterator#remove remove} always throws {@link
   * IllegalStateException}.
   * 
   *
   * Implementations of this method are permitted, but not
   * required, to return the same object from multiple invocations.
   *
   * @param  type of elements, if there were any, in the iterator
   * @return an empty iterator
   * @since 1.7
  */
  static emptyIterator<T>(): Iterator<T>;
  /**
   * Returns a list iterator that has no elements.  More precisely,
   *
   * 
   * {@link Iterator#hasNext hasNext} and {@link
   * ListIterator#hasPrevious hasPrevious} always return `     * false`.
   * {@link Iterator#next next} and {@link ListIterator#previous
   * previous} always throw {@link NoSuchElementException}.
   * {@link Iterator#remove remove} and {@link ListIterator#set
   * set} always throw {@link IllegalStateException}.
   * {@link ListIterator#add add} always throws {@link
   * UnsupportedOperationException}.
   * {@link ListIterator#nextIndex nextIndex} always returns
   * `0`.
   * {@link ListIterator#previousIndex previousIndex} always
   * returns `-1`.
   * 
   *
   * Implementations of this method are permitted, but not
   * required, to return the same object from multiple invocations.
   *
   * @param  type of elements, if there were any, in the iterator
   * @return an empty list iterator
   * @since 1.7
  */
  static emptyListIterator<T>(): ListIterator<T>;
  /**
   * Returns an enumeration that has no elements.  More precisely,
   *
   * 
   * {@link Enumeration#hasMoreElements hasMoreElements} always
   * returns `false`.
   *  {@link Enumeration#nextElement nextElement} always throws
   * {@link NoSuchElementException}.
   * 
   *
   * Implementations of this method are permitted, but not
   * required, to return the same object from multiple invocations.
   *
   * @param   the class of the objects in the enumeration
   * @return an empty enumeration
   * @since 1.7
  */
  static emptyEnumeration<T>(): Enumeration<T>;
  /**
   * The empty set (immutable).  This set is serializable.
   *
   * @see #emptySet()
  */
  static readonly EMPTY_SET: Set;
  /**
   * Returns an empty set (immutable).  This set is serializable.
   * Unlike the like-named field, this method is parameterized.
   *
   * This example illustrates the type-safe way to obtain an empty set:
   *      *     Set<String> s = Collections.emptySet();
   * 
   * @implNote Implementations of this method need not create a separate
   * `Set` object for each call.  Using this method is likely to have
   * comparable cost to using the like-named field.  (Unlike this method, the
   * field does not provide type safety.)
   *
   * @param   the class of the objects in the set
   * @return the empty set
   *
   * @see #EMPTY_SET
   * @since 1.5
  */
  static emptySet<T>(): Set<T>;
  /**
   * Returns an empty sorted set (immutable).  This set is serializable.
   *
   * This example illustrates the type-safe way to obtain an empty
   * sorted set:
   *  {@code
   *     SortedSet s = Collections.emptySortedSet();
   * }
   *
   * @implNote Implementations of this method need not create a separate
   * `SortedSet` object for each call.
   *
   * @param  type of elements, if there were any, in the set
   * @return the empty sorted set
   * @since 1.8
  */
  static emptySortedSet<E>(): SortedSet<E>;
  /**
   * Returns an empty navigable set (immutable).  This set is serializable.
   *
   * This example illustrates the type-safe way to obtain an empty
   * navigable set:
   *  {@code
   *     NavigableSet s = Collections.emptyNavigableSet();
   * }
   *
   * @implNote Implementations of this method need not
   * create a separate `NavigableSet` object for each call.
   *
   * @param  type of elements, if there were any, in the set
   * @return the empty navigable set
   * @since 1.8
  */
  static emptyNavigableSet<E>(): NavigableSet<E>;
  /**
   * The empty list (immutable).  This list is serializable.
   *
   * @see #emptyList()
  */
  static readonly EMPTY_LIST: List;
  /**
   * Returns an empty list (immutable).  This list is serializable.
   *
   * This example illustrates the type-safe way to obtain an empty list:
   *      *     List<String> s = Collections.emptyList();
   * 
   *
   * @implNote
   * Implementations of this method need not create a separate `List`
   * object for each call.   Using this method is likely to have comparable
   * cost to using the like-named field.  (Unlike this method, the field does
   * not provide type safety.)
   *
   * @param  type of elements, if there were any, in the list
   * @return an empty immutable list
   *
   * @see #EMPTY_LIST
   * @since 1.5
  */
  static emptyList<T>(): T[];
  /**
   * The empty map (immutable).  This map is serializable.
   *
   * @see #emptyMap()
   * @since 1.3
  */
  static readonly EMPTY_MAP: Map;
  /**
   * Returns an empty map (immutable).  This map is serializable.
   *
   * This example illustrates the type-safe way to obtain an empty map:
   *      *     Map<String, Date> s = Collections.emptyMap();
   * 
   * @implNote Implementations of this method need not create a separate
   * `Map` object for each call.  Using this method is likely to have
   * comparable cost to using the like-named field.  (Unlike this method, the
   * field does not provide type safety.)
   *
   * @param  the class of the map keys
   * @param  the class of the map values
   * @return an empty map
   * @see #EMPTY_MAP
   * @since 1.5
  */
  static emptyMap<K, V>(): Map<K, V>;
  /**
   * Returns an empty sorted map (immutable).  This map is serializable.
   *
   * This example illustrates the type-safe way to obtain an empty map:
   *  {@code
   *     SortedMap s = Collections.emptySortedMap();
   * }
   *
   * @implNote Implementations of this method need not create a separate
   * `SortedMap` object for each call.
   *
   * @param  the class of the map keys
   * @param  the class of the map values
   * @return an empty sorted map
   * @since 1.8
  */
  static emptySortedMap<K, V>(): SortedMap<K, V>;
  /**
   * Returns an empty navigable map (immutable).  This map is serializable.
   *
   * This example illustrates the type-safe way to obtain an empty map:
   *  {@code
   *     NavigableMap s = Collections.emptyNavigableMap();
   * }
   *
   * @implNote Implementations of this method need not create a separate
   * `NavigableMap` object for each call.
   *
   * @param  the class of the map keys
   * @param  the class of the map values
   * @return an empty navigable map
   * @since 1.8
  */
  static emptyNavigableMap<K, V>(): NavigableMap<K, V>;
  /**
   * Returns an immutable set containing only the specified object.
   * The returned set is serializable.
   *
   * @param   the class of the objects in the set
   * @param o the sole object to be stored in the returned set.
   * @return an immutable set containing only the specified object.
  */
  static singleton<T>(o: T): Set<T>;
  /**
   * Returns an immutable list containing only the specified object.
   * The returned list is serializable.
   *
   * @param   the class of the objects in the list
   * @param o the sole object to be stored in the returned list.
   * @return an immutable list containing only the specified object.
   * @since 1.3
  */
  static singletonList<T>(o: T): T[];
  /**
   * Returns an immutable map, mapping only the specified key to the
   * specified value.  The returned map is serializable.
   *
   * @param  the class of the map keys
   * @param  the class of the map values
   * @param key the sole key to be stored in the returned map.
   * @param value the value to which the returned map maps `key`.
   * @return an immutable map containing only the specified key-value
   *         mapping.
   * @since 1.3
  */
  static singletonMap<K, V>(key: K, value: V): Map<K, V>;
  /**
   * Returns an immutable list consisting of `n` copies of the
   * specified object.  The newly allocated data object is tiny (it contains
   * a single reference to the data object).  This method is useful in
   * combination with the `List.addAll` method to grow lists.
   * The returned list is serializable.
   *
   * @param   the class of the object to copy and of the objects
   *         in the returned list.
   * @param  n the number of elements in the returned list.
   * @param  o the element to appear repeatedly in the returned list.
   * @return an immutable list consisting of `n` copies of the
   *         specified object.
   * @throws IllegalArgumentException if `n < 0`
   * @see    List#addAll(Collection)
   * @see    List#addAll(int, Collection)
  */
  static nCopies<T>(n: number, o: T): T[];
  /**
   * Returns a comparator that imposes the reverse of the natural
   * ordering on a collection of objects that implement the
   * `Comparable` interface.  (The natural ordering is the ordering
   * imposed by the objects' own `compareTo` method.)  This enables a
   * simple idiom for sorting (or maintaining) collections (or arrays) of
   * objects that implement the `Comparable` interface in
   * reverse-natural-order.  For example, suppose `a` is an array of
   * strings. Then:      *          Arrays.sort(a, Collections.reverseOrder());
   *  sorts the array in reverse-lexicographic (alphabetical) order.
   *
   * The returned comparator is serializable.
   *
   * @param   the class of the objects compared by the comparator
   * @return A comparator that imposes the reverse of the natural
   *         ordering on a collection of objects that implement
   *         the `Comparable` interface.
   * @see Comparable
  */
  static reverseOrder<T>(): Comparator<T>;
  /**
   * Returns a comparator that imposes the reverse ordering of the specified
   * comparator.  If the specified comparator is `null`, this method is
   * equivalent to {@link #reverseOrder()} (in other words, it returns a
   * comparator that imposes the reverse of the natural ordering on
   * a collection of objects that implement the Comparable interface).
   *
   * The returned comparator is serializable (assuming the specified
   * comparator is also serializable or `null`).
   *
   * @param  the class of the objects compared by the comparator
   * @param cmp a comparator who's ordering is to be reversed by the returned
   * comparator or `null`
   * @return A comparator that imposes the reverse ordering of the
   *         specified comparator.
   * @since 1.5
  */
  static reverseOrder<T>(cmp: Comparator<T>): Comparator<T>;
  /**
   * Returns an enumeration over the specified collection.  This provides
   * interoperability with legacy APIs that require an enumeration
   * as input.
   *
   * The iterator returned from a call to {@link Enumeration#asIterator()}
   * does not support removal of elements from the specified collection.  This
   * is necessary to avoid unintentionally increasing the capabilities of the
   * returned enumeration.
   *
   * @param   the class of the objects in the collection
   * @param c the collection for which an enumeration is to be returned.
   * @return an enumeration over the specified collection.
   * @see Enumeration
  */
  static enumeration<T>(c: Collection<T>): Enumeration<T>;
  /**
   * Returns an array list containing the elements returned by the
   * specified enumeration in the order they are returned by the
   * enumeration.  This method provides interoperability between
   * legacy APIs that return enumerations and new APIs that require
   * collections.
   *
   * @param  the class of the objects returned by the enumeration
   * @param e enumeration providing elements for the returned
   *          array list
   * @return an array list containing the elements returned
   *         by the specified enumeration.
   * @since 1.4
   * @see Enumeration
   * @see ArrayList
  */
  static list<T>(e: Enumeration<T>): ArrayList<T>;
  /**
   * Returns the number of elements in the specified collection equal to the
   * specified object.  More formally, returns the number of elements
   * `e` in the collection such that
   * `Objects.equals(o, e)`.
   *
   * @param c the collection in which to determine the frequency
   *     of `o`
   * @param o the object whose frequency is to be determined
   * @return the number of elements in `c` equal to `o`
   * @throws NullPointerException if `c` is null
   * @since 1.5
  */
  static frequency(c: Collection<any>, o: any): number;
  /**
   * Returns `true` if the two specified collections have no
   * elements in common.
   *
   * Care must be exercised if this method is used on collections that
   * do not comply with the general contract for `Collection`.
   * Implementations may elect to iterate over either collection and test
   * for containment in the other collection (or to perform any equivalent
   * computation).  If either collection uses a nonstandard equality test
   * (as does a {@link SortedSet} whose ordering is not compatible with
   * equals, or the key set of an {@link IdentityHashMap}), both
   * collections must use the same nonstandard equality test, or the
   * result of this method is undefined.
   *
   * Care must also be exercised when using collections that have
   * restrictions on the elements that they may contain. Collection
   * implementations are allowed to throw exceptions for any operation
   * involving elements they deem ineligible. For absolute safety the
   * specified collections should contain only elements which are
   * eligible elements for both collections.
   *
   * Note that it is permissible to pass the same collection in both
   * parameters, in which case the method will return `true` if and
   * only if the collection is empty.
   *
   * @param c1 a collection
   * @param c2 a collection
   * @return `true` if the two specified collections have no
   * elements in common.
   * @throws NullPointerException if either collection is `null`.
   * @throws NullPointerException if one collection contains a `null`
   * element and `null` is not an eligible element for the other collection.
   * (optional)
   * @throws ClassCastException if one collection contains an element that is
   * of a type which is ineligible for the other collection.
   * (optional)
   * @since 1.5
  */
  static disjoint(c1: Collection<any>, c2: Collection<any>): boolean;
  /**
   * Adds all of the specified elements to the specified collection.
   * Elements to be added may be specified individually or as an array.
   * The behavior of this convenience method is identical to that of
   * `c.addAll(Arrays.asList(elements))`, but this method is likely
   * to run significantly faster under most implementations.
   *
   * When elements are specified individually, this method provides a
   * convenient way to add a few elements to an existing collection:
   *      *     Collections.addAll(flavors, "Peaches 'n Plutonium", "Rocky Racoon");
   * 
   *
   * @param   the class of the elements to add and of the collection
   * @param c the collection into which `elements` are to be inserted
   * @param elements the elements to insert into `c`
   * @return `true` if the collection changed as a result of the call
   * @throws UnsupportedOperationException if `c` does not support
   *         the `add` operation
   * @throws NullPointerException if `elements` contains one or more
   *         null values and `c` does not permit null elements, or
   *         if `c` or `elements` are `null`
   * @throws IllegalArgumentException if some property of a value in
   *         `elements` prevents it from being added to `c`
   * @see Collection#addAll(Collection)
   * @since 1.5
  */
  static addAll<T>(c: Collection<any>, ...elements: T[]): boolean;
  /**
   * Returns a set backed by the specified map.  The resulting set displays
   * the same ordering, concurrency, and performance characteristics as the
   * backing map.  In essence, this factory method provides a {@link Set}
   * implementation corresponding to any {@link Map} implementation.  There
   * is no need to use this method on a {@link Map} implementation that
   * already has a corresponding {@link Set} implementation (such as {@link
   * HashMap} or {@link TreeMap}).
   *
   * Each method invocation on the set returned by this method results in
   * exactly one method invocation on the backing map or its `keySet`
   * view, with one exception.  The `addAll` method is implemented
   * as a sequence of `put` invocations on the backing map.
   *
   * The specified map must be empty at the time this method is invoked,
   * and should not be accessed directly after this method returns.  These
   * conditions are ensured if the map is created empty, passed directly
   * to this method, and no reference to the map is retained, as illustrated
   * in the following code fragment:
   *      *    Set<Object> weakHashSet = Collections.newSetFromMap(
   *        new WeakHashMap<Object, Boolean>());
   * 
   *
   * @param  the class of the map keys and of the objects in the
   *        returned set
   * @param map the backing map
   * @return the set backed by the map
   * @throws IllegalArgumentException if `map` is not empty
   * @since 1.6
  */
  static newSetFromMap<E>(map: Map<E, boolean>): Set<E>;
  /**
   * Returns a view of a {@link Deque} as a Last-in-first-out (Lifo)
   * {@link Queue}. Method `add` is mapped to `push`,
   * `remove` is mapped to `pop` and so on. This
   * view can be useful when you would like to use a method
   * requiring a `Queue` but you need Lifo ordering.
   *
   * Each method invocation on the queue returned by this method
   * results in exactly one method invocation on the backing deque, with
   * one exception.  The {@link Queue#addAll addAll} method is
   * implemented as a sequence of {@link Deque#addFirst addFirst}
   * invocations on the backing deque.
   *
   * @param   the class of the objects in the deque
   * @param deque the deque
   * @return the queue
   * @since  1.6
  */
  static asLifoQueue<T>(deque: Deque<T>): Queue<T>;
}

}
declare module 'java.util.stream' {
import { OfInt, OfLong, OfDouble } from 'java.util.PrimitiveIterator';
import { Builder as java_util_stream_IntStream_Builder, IntMapMultiConsumer } from 'java.util.stream.IntStream';
import { AutoCloseable, Runnable, CharSequence } from 'java.lang';
import { Set, Optional, OptionalInt, DoubleSummaryStatistics, IntSummaryStatistics, OptionalDouble, Comparator, LongSummaryStatistics, Iterator, OptionalLong, List, Map, Spliterator } from 'java.util';
import { LongMapMultiConsumer, Builder as java_util_stream_LongStream_Builder } from 'java.util.stream.LongStream';
import { Builder as java_util_stream_Stream_Builder } from 'java.util.stream.Stream';
import { ConcurrentMap } from 'java.util.concurrent';
import { Characteristics } from 'java.util.stream.Collector';
import { IntSupplier, DoubleToLongFunction, IntUnaryOperator, IntToDoubleFunction, Predicate, ObjDoubleConsumer, Function, ToLongFunction, Consumer, LongToIntFunction, ObjLongConsumer, Supplier, UnaryOperator, BinaryOperator, ObjIntConsumer, ToDoubleFunction, DoubleUnaryOperator, LongBinaryOperator, IntPredicate, DoublePredicate, LongPredicate, IntConsumer, LongToDoubleFunction, DoubleFunction, LongConsumer, DoubleConsumer, DoubleBinaryOperator, LongFunction, BiFunction, DoubleSupplier, IntFunction, IntBinaryOperator, LongUnaryOperator, IntToLongFunction, ToIntFunction, LongSupplier, BiConsumer, DoubleToIntFunction } from 'java.util.function';
import { OfInt as java_util_Spliterator_OfInt, OfLong as java_util_Spliterator_OfLong, OfDouble as java_util_Spliterator_OfDouble } from 'java.util.Spliterator';
import { DoubleMapMultiConsumer, Builder } from 'java.util.stream.DoubleStream';
/**
 * A mutable reduction operation that
 * accumulates input elements into a mutable result container, optionally transforming
 * the accumulated result into a final representation after all input elements
 * have been processed.  Reduction operations can be performed either sequentially
 * or in parallel.
 *
 * Examples of mutable reduction operations include:
 * accumulating elements into a `Collection`; concatenating
 * strings using a `StringBuilder`; computing summary information about
 * elements such as sum, min, max, or average; computing "pivot table" summaries
 * such as "maximum valued transaction by seller", etc.  The class {@link Collectors}
 * provides implementations of many common mutable reductions.
 *
 * A `Collector` is specified by four functions that work together to
 * accumulate entries into a mutable result container, and optionally perform
 * a final transform on the result.  They are: 
 *     creation of a new result container ({@link #supplier()})
 *     incorporating a new data element into a result container ({@link #accumulator()})
 *     combining two result containers into one ({@link #combiner()})
 *     performing an optional final transform on the container ({@link #finisher()})
 * 
 *
 * Collectors also have a set of characteristics, such as
 * {@link Characteristics#CONCURRENT}, that provide hints that can be used by a
 * reduction implementation to provide better performance.
 *
 * A sequential implementation of a reduction using a collector would
 * create a single result container using the supplier function, and invoke the
 * accumulator function once for each input element.  A parallel implementation
 * would partition the input, create a result container for each partition,
 * accumulate the contents of each partition into a subresult for that partition,
 * and then use the combiner function to merge the subresults into a combined
 * result.
 *
 * To ensure that sequential and parallel executions produce equivalent
 * results, the collector functions must satisfy an identity and an
 * associativity constraints.
 *
 * The identity constraint says that for any partially accumulated result,
 * combining it with an empty result container must produce an equivalent
 * result.  That is, for a partially accumulated result `a` that is the
 * result of any series of accumulator and combiner invocations, `a` must
 * be equivalent to `combiner.apply(a, supplier.get())`.
 *
 * The associativity constraint says that splitting the computation must
 * produce an equivalent result.  That is, for any input elements `t1`
 * and `t2`, the results `r1` and `r2` in the computation
 * below must be equivalent:
 * {@code
 *     A a1 = supplier.get();
 *     accumulator.accept(a1, t1);
 *     accumulator.accept(a1, t2);
 *     R r1 = finisher.apply(a1);  // result without splitting
 *
 *     A a2 = supplier.get();
 *     accumulator.accept(a2, t1);
 *     A a3 = supplier.get();
 *     accumulator.accept(a3, t2);
 *     R r2 = finisher.apply(combiner.apply(a2, a3));  // result with splitting
 * } 
 *
 * For collectors that do not have the `UNORDERED` characteristic,
 * two accumulated results `a1` and `a2` are equivalent if
 * `finisher.apply(a1).equals(finisher.apply(a2))`.  For unordered
 * collectors, equivalence is relaxed to allow for non-equality related to
 * differences in order.  (For example, an unordered collector that accumulated
 * elements to a `List` would consider two lists equivalent if they
 * contained the same elements, ignoring order.)
 *
 * Libraries that implement reduction based on `Collector`, such as
 * {@link Stream#collect(Collector)}, must adhere to the following constraints:
 * 
 *     The first argument passed to the accumulator function, both
 *     arguments passed to the combiner function, and the argument passed to the
 *     finisher function must be the result of a previous invocation of the
 *     result supplier, accumulator, or combiner functions.
 *     The implementation should not do anything with the result of any of
 *     the result supplier, accumulator, or combiner functions other than to
 *     pass them again to the accumulator, combiner, or finisher functions,
 *     or return them to the caller of the reduction operation.
 *     If a result is passed to the combiner or finisher
 *     function, and the same object is not returned from that function, it is
 *     never used again.
 *     Once a result is passed to the combiner or finisher function, it
 *     is never passed to the accumulator function again.
 *     For non-concurrent collectors, any result returned from the result
 *     supplier, accumulator, or combiner functions must be serially
 *     thread-confined.  This enables collection to occur in parallel without
 *     the `Collector` needing to implement any additional synchronization.
 *     The reduction implementation must manage that the input is properly
 *     partitioned, that partitions are processed in isolation, and combining
 *     happens only after accumulation is complete.
 *     For concurrent collectors, an implementation is free to (but not
 *     required to) implement reduction concurrently.  A concurrent reduction
 *     is one where the accumulator function is called concurrently from
 *     multiple threads, using the same concurrently-modifiable result container,
 *     rather than keeping the result isolated during accumulation.
 *     A concurrent reduction should only be applied if the collector has the
 *     {@link Characteristics#UNORDERED} characteristics or if the
 *     originating data is unordered.
 * 
 *
 * In addition to the predefined implementations in {@link Collectors}, the
 * static factory methods {@link #of(Supplier, BiConsumer, BinaryOperator, Characteristics...)}
 * can be used to construct collectors.  For example, you could create a collector
 * that accumulates widgets into a `TreeSet` with:
 *
 * {@code
 *     Collector> intoSet =
 *         Collector.of(TreeSet::new, TreeSet::add,
 *                      (left, right) -> { left.addAll(right); return left; });
 * }
 *
 * (This behavior is also implemented by the predefined collector
 * {@link Collectors#toCollection(Supplier)}).
 *
 * @apiNote
 * Performing a reduction operation with a `Collector` should produce a
 * result equivalent to:
 * {@code
 *     A container = collector.supplier().get();
 *     for (T t : data)
 *         collector.accumulator().accept(container, t);
 *     return collector.finisher().apply(container);
 * }
 *
 * However, the library is free to partition the input, perform the reduction
 * on the partitions, and then use the combiner function to combine the partial
 * results to achieve a parallel reduction.  (Depending on the specific reduction
 * operation, this may perform better or worse, depending on the relative cost
 * of the accumulator and combiner functions.)
 *
 * Collectors are designed to be composed; many of the methods
 * in {@link Collectors} are functions that take a collector and produce
 * a new collector.  For example, given the following collector that computes
 * the sum of the salaries of a stream of employees:
 *
 * {@code
 *     Collector summingSalaries
 *         = Collectors.summingInt(Employee::getSalary))
 * }
 *
 * If we wanted to create a collector to tabulate the sum of salaries by
 * department, we could reuse the "sum of salaries" logic using
 * {@link Collectors#groupingBy(Function, Collector)}:
 *
 * {@code
 *     Collector> summingSalariesByDept
 *         = Collectors.groupingBy(Employee::getDepartment, summingSalaries);
 * }
 *
 * @see Stream#collect(Collector)
 * @see Collectors
 *
 * @param  the type of input elements to the reduction operation
 * @param  the mutable accumulation type of the reduction operation (often
 *            hidden as an implementation detail)
 * @param  the result type of the reduction operation
 * @since 1.8
*/
export class Collector<T, A, R> {
  /**
   * A function that creates and returns a new mutable result container.
   *
   * @return a function which returns a new, mutable result container
  */
  supplier(): Supplier<A>;
  /**
   * A function that folds a value into a mutable result container.
   *
   * @return a function which folds a value into a mutable result container
  */
  accumulator(): BiConsumer<A, T>;
  /**
   * A function that accepts two partial results and merges them.  The
   * combiner function may fold state from one argument into the other and
   * return that, or may return a new result container.
   *
   * @return a function which combines two partial results into a combined
   * result
  */
  combiner(): BinaryOperator<A>;
  /**
   * Perform the final transformation from the intermediate accumulation type
   * `A` to the final result type `R`.
   *
   * If the characteristic `IDENTITY_FINISH` is
   * set, this function may be presumed to be an identity transform with an
   * unchecked cast from `A` to `R`.
   *
   * @return a function which transforms the intermediate result to the final
   * result
  */
  finisher(): Function<A, R>;
  /**
   * Returns a `Set` of `Collector.Characteristics` indicating
   * the characteristics of this Collector.  This set should be immutable.
   *
   * @return an immutable set of collector characteristics
  */
  characteristics(): Set<Characteristics>;
  /**
   * Returns a new `Collector` described by the given `supplier`,
   * `accumulator`, and `combiner` functions.  The resulting
   * `Collector` has the `Collector.Characteristics.IDENTITY_FINISH`
   * characteristic.
   *
   * @param supplier The supplier function for the new collector
   * @param accumulator The accumulator function for the new collector
   * @param combiner The combiner function for the new collector
   * @param characteristics The collector characteristics for the new
   *                        collector
   * @param  The type of input elements for the new collector
   * @param  The type of intermediate accumulation result, and final result,
   *           for the new collector
   * @throws NullPointerException if any argument is null
   * @return the new `Collector`
  */
  static of<T, R>(supplier: Supplier<R>, accumulator: BiConsumer<R, T>, combiner: BinaryOperator<R>, ...characteristics: Characteristics[]): Collector<T, R, R>;
  /**
   * Returns a new `Collector` described by the given `supplier`,
   * `accumulator`, `combiner`, and `finisher` functions.
   *
   * @param supplier The supplier function for the new collector
   * @param accumulator The accumulator function for the new collector
   * @param combiner The combiner function for the new collector
   * @param finisher The finisher function for the new collector
   * @param characteristics The collector characteristics for the new
   *                        collector
   * @param  The type of input elements for the new collector
   * @param  The intermediate accumulation type of the new collector
   * @param  The final result type of the new collector
   * @throws NullPointerException if any argument is null
   * @return the new `Collector`
  */
  static of<T, A, R>(supplier: Supplier<A>, accumulator: BiConsumer<A, T>, combiner: BinaryOperator<A>, finisher: Function<A, R>, ...characteristics: Characteristics[]): Collector<T, A, R>;
}
/**
 * Implementations of {@link Collector} that implement various useful reduction
 * operations, such as accumulating elements into collections, summarizing
 * elements according to various criteria, etc.
 *
 * The following are examples of using the predefined collectors to perform
 * common mutable reduction tasks:
 *
 * {@code
 * // Accumulate names into a List
 * List list = people.stream()
 *   .map(Person::getName)
 *   .collect(Collectors.toList());
 *
 * // Accumulate names into a TreeSet
 * Set set = people.stream()
 *   .map(Person::getName)
 *   .collect(Collectors.toCollection(TreeSet::new));
 *
 * // Convert elements to strings and concatenate them, separated by commas
 * String joined = things.stream()
 *   .map(Object::toString)
 *   .collect(Collectors.joining(", "));
 *
 * // Compute sum of salaries of employee
 * int total = employees.stream()
 *   .collect(Collectors.summingInt(Employee::getSalary));
 *
 * // Group employees by department
 * Map> byDept = employees.stream()
 *   .collect(Collectors.groupingBy(Employee::getDepartment));
 *
 * // Compute sum of salaries by department
 * Map totalByDept = employees.stream()
 *   .collect(Collectors.groupingBy(Employee::getDepartment,
 *                                  Collectors.summingInt(Employee::getSalary)));
 *
 * // Partition students into passing and failing
 * Map> passingFailing = students.stream()
 *   .collect(Collectors.partitioningBy(s -> s.getGrade() >= PASS_THRESHOLD));
 *
 * }
 *
 * @since 1.8
*/
export class Collectors {
  /**
   * Returns a `Collector` that accumulates the input elements into a
   * new `Collection`, in encounter order.  The `Collection` is
   * created by the provided factory.
   *
   * @param  the type of the input elements
   * @param  the type of the resulting `Collection`
   * @param collectionFactory a supplier providing a new empty `Collection`
   *                          into which the results will be inserted
   * @return a `Collector` which collects all the input elements into a
   * `Collection`, in encounter order
  */
  static toCollection<T, C>(collectionFactory: Supplier<C>): Collector<T, any, C>;
  /**
   * Returns a `Collector` that accumulates the input elements into a
   * new `List`. There are no guarantees on the type, mutability,
   * serializability, or thread-safety of the `List` returned; if more
   * control over the returned `List` is required, use {@link #toCollection(Supplier)}.
   *
   * @param  the type of the input elements
   * @return a `Collector` which collects all the input elements into a
   * `List`, in encounter order
  */
  static toList<T>(): Collector<T, any, T[]>;
  /**
   * Returns a `Collector` that accumulates the input elements into an
   * unmodifiable List in encounter
   * order. The returned Collector disallows null values and will throw
   * `NullPointerException` if it is presented with a null value.
   *
   * @param  the type of the input elements
   * @return a `Collector` that accumulates the input elements into an
   * unmodifiable List in encounter order
   * @since 10
  */
  static toUnmodifiableList<T>(): Collector<T, any, T[]>;
  /**
   * Returns a `Collector` that accumulates the input elements into a
   * new `Set`. There are no guarantees on the type, mutability,
   * serializability, or thread-safety of the `Set` returned; if more
   * control over the returned `Set` is required, use
   * {@link #toCollection(Supplier)}.
   *
   * This is an {@link Collector.Characteristics#UNORDERED unordered}
   * Collector.
   *
   * @param  the type of the input elements
   * @return a `Collector` which collects all the input elements into a
   * `Set`
  */
  static toSet<T>(): Collector<T, any, Set<T>>;
  /**
   * Returns a `Collector` that accumulates the input elements into an
   * unmodifiable Set. The returned
   * Collector disallows null values and will throw `NullPointerException`
   * if it is presented with a null value. If the input contains duplicate elements,
   * an arbitrary element of the duplicates is preserved.
   *
   * This is an {@link Collector.Characteristics#UNORDERED unordered}
   * Collector.
   *
   * @param  the type of the input elements
   * @return a `Collector` that accumulates the input elements into an
   * unmodifiable Set
   * @since 10
  */
  static toUnmodifiableSet<T>(): Collector<T, any, Set<T>>;
  /**
   * Returns a `Collector` that concatenates the input elements into a
   * `String`, in encounter order.
   *
   * @return a `Collector` that concatenates the input elements into a
   * `String`, in encounter order
  */
  static joining(): Collector<CharSequence, any, string>;
  /**
   * Returns a `Collector` that concatenates the input elements,
   * separated by the specified delimiter, in encounter order.
   *
   * @param delimiter the delimiter to be used between each element
   * @return A `Collector` which concatenates CharSequence elements,
   * separated by the specified delimiter, in encounter order
  */
  static joining(delimiter: CharSequence): Collector<CharSequence, any, string>;
  /**
   * Returns a `Collector` that concatenates the input elements,
   * separated by the specified delimiter, with the specified prefix and
   * suffix, in encounter order.
   *
   * @param delimiter the delimiter to be used between each element
   * @param  prefix the sequence of characters to be used at the beginning
   *                of the joined result
   * @param  suffix the sequence of characters to be used at the end
   *                of the joined result
   * @return A `Collector` which concatenates CharSequence elements,
   * separated by the specified delimiter, in encounter order
  */
  static joining(delimiter: CharSequence, prefix: CharSequence, suffix: CharSequence): Collector<CharSequence, any, string>;
  /**
   * Adapts a `Collector` accepting elements of type `U` to one
   * accepting elements of type `T` by applying a mapping function to
   * each input element before accumulation.
   *
   * @apiNote
   * The `mapping()` collectors are most useful when used in a
   * multi-level reduction, such as downstream of a `groupingBy` or
   * `partitioningBy`.  For example, given a stream of
   * `Person`, to accumulate the set of last names in each city:
   * {@code
   * Map> lastNamesByCity
   *   = people.stream().collect(
   *     groupingBy(Person::getCity,
   *                mapping(Person::getLastName,
   *                        toSet())));
   * }
   *
   * @param  the type of the input elements
   * @param  type of elements accepted by downstream collector
   * @param  intermediate accumulation type of the downstream collector
   * @param  result type of collector
   * @param mapper a function to be applied to the input elements
   * @param downstream a collector which will accept mapped values
   * @return a collector which applies the mapping function to the input
   * elements and provides the mapped results to the downstream collector
  */
  static mapping<T, U, A, R>(mapper: Function<any, U>, downstream: Collector<any, A, R>): Collector<T, any, R>;
  /**
   * Adapts a `Collector` accepting elements of type `U` to one
   * accepting elements of type `T` by applying a flat mapping function
   * to each input element before accumulation.  The flat mapping function
   * maps an input element to a {@link Stream stream} covering zero or more
   * output elements that are then accumulated downstream.  Each mapped stream
   * is {@link java.util.stream.BaseStream#close() closed} after its contents
   * have been placed downstream.  (If a mapped stream is `null`
   * an empty stream is used, instead.)
   *
   * @apiNote
   * The `flatMapping()` collectors are most useful when used in a
   * multi-level reduction, such as downstream of a `groupingBy` or
   * `partitioningBy`.  For example, given a stream of
   * `Order`, to accumulate the set of line items for each customer:
   * {@code
   * Map> itemsByCustomerName
   *   = orders.stream().collect(
   *     groupingBy(Order::getCustomerName,
   *                flatMapping(order -> order.getLineItems().stream(),
   *                            toSet())));
   * }
   *
   * @param  the type of the input elements
   * @param  type of elements accepted by downstream collector
   * @param  intermediate accumulation type of the downstream collector
   * @param  result type of collector
   * @param mapper a function to be applied to the input elements, which
   * returns a stream of results
   * @param downstream a collector which will receive the elements of the
   * stream returned by mapper
   * @return a collector which applies the mapping function to the input
   * elements and provides the flat mapped results to the downstream collector
   * @since 9
  */
  static flatMapping<T, U, A, R>(mapper: Function<any, Stream<U>>, downstream: Collector<any, A, R>): Collector<T, any, R>;
  /**
   * Adapts a `Collector` to one accepting elements of the same type
   * `T` by applying the predicate to each input element and only
   * accumulating if the predicate returns `true`.
   *
   * @apiNote
   * The `filtering()` collectors are most useful when used in a
   * multi-level reduction, such as downstream of a `groupingBy` or
   * `partitioningBy`.  For example, given a stream of
   * `Employee`, to accumulate the employees in each department that have a
   * salary above a certain threshold:
   * {@code
   * Map> wellPaidEmployeesByDepartment
   *   = employees.stream().collect(
   *     groupingBy(Employee::getDepartment,
   *                filtering(e -> e.getSalary() > 2000,
   *                          toSet())));
   * }
   * A filtering collector differs from a stream's `filter()` operation.
   * In this example, suppose there are no employees whose salary is above the
   * threshold in some department.  Using a filtering collector as shown above
   * would result in a mapping from that department to an empty `Set`.
   * If a stream `filter()` operation were done instead, there would be
   * no mapping for that department at all.
   *
   * @param  the type of the input elements
   * @param  intermediate accumulation type of the downstream collector
   * @param  result type of collector
   * @param predicate a predicate to be applied to the input elements
   * @param downstream a collector which will accept values that match the
   * predicate
   * @return a collector which applies the predicate to the input elements
   * and provides matching elements to the downstream collector
   * @since 9
  */
  static filtering<T, A, R>(predicate: Predicate<any>, downstream: Collector<any, A, R>): Collector<T, any, R>;
  /**
   * Adapts a `Collector` to perform an additional finishing
   * transformation.  For example, one could adapt the {@link #toList()}
   * collector to always produce an immutable list with:
   * {@code
   * List list = people.stream().collect(
   *   collectingAndThen(toList(),
   *                     Collections::unmodifiableList));
   * }
   *
   * @param  the type of the input elements
   * @param  intermediate accumulation type of the downstream collector
   * @param  result type of the downstream collector
   * @param  result type of the resulting collector
   * @param downstream a collector
   * @param finisher a function to be applied to the final result of the downstream collector
   * @return a collector which performs the action of the downstream collector,
   * followed by an additional finishing step
  */
  static collectingAndThen<T, A, R, RR>(downstream: Collector<T, A, R>, finisher: Function<R, RR>): Collector<T, A, RR>;
  /**
   * Returns a `Collector` accepting elements of type `T` that
   * counts the number of input elements.  If no elements are present, the
   * result is 0.
   *
   * @implSpec
   * This produces a result equivalent to:
   * {@code
   *     reducing(0L, e -> 1L, Long::sum)
   * }
   *
   * @param  the type of the input elements
   * @return a `Collector` that counts the input elements
  */
  static counting<T>(): Collector<T, any, number>;
  /**
   * Returns a `Collector` that produces the minimal element according
   * to a given `Comparator`, described as an `Optional`.
   *
   * @implSpec
   * This produces a result equivalent to:
   * {@code
   *     reducing(BinaryOperator.minBy(comparator))
   * }
   *
   * @param  the type of the input elements
   * @param comparator a `Comparator` for comparing elements
   * @return a `Collector` that produces the minimal value
  */
  static minBy<T>(comparator: Comparator<any>): Collector<T, any, Optional<T>>;
  /**
   * Returns a `Collector` that produces the maximal element according
   * to a given `Comparator`, described as an `Optional`.
   *
   * @implSpec
   * This produces a result equivalent to:
   * {@code
   *     reducing(BinaryOperator.maxBy(comparator))
   * }
   *
   * @param  the type of the input elements
   * @param comparator a `Comparator` for comparing elements
   * @return a `Collector` that produces the maximal value
  */
  static maxBy<T>(comparator: Comparator<any>): Collector<T, any, Optional<T>>;
  /**
   * Returns a `Collector` that produces the sum of a integer-valued
   * function applied to the input elements.  If no elements are present,
   * the result is 0.
   *
   * @param  the type of the input elements
   * @param mapper a function extracting the property to be summed
   * @return a `Collector` that produces the sum of a derived property
  */
  static summingInt<T>(mapper: ToIntFunction<any>): Collector<T, any, number>;
  /**
   * Returns a `Collector` that produces the sum of a long-valued
   * function applied to the input elements.  If no elements are present,
   * the result is 0.
   *
   * @param  the type of the input elements
   * @param mapper a function extracting the property to be summed
   * @return a `Collector` that produces the sum of a derived property
  */
  static summingLong<T>(mapper: ToLongFunction<any>): Collector<T, any, number>;
  /**
   * Returns a `Collector` that produces the sum of a double-valued
   * function applied to the input elements.  If no elements are present,
   * the result is 0.
   *
   * The sum returned can vary depending upon the order in which
   * values are recorded, due to accumulated rounding error in
   * addition of values of differing magnitudes. Values sorted by increasing
   * absolute magnitude tend to yield more accurate results.  If any recorded
   * value is a `NaN` or the sum is at any point a `NaN` then the
   * sum will be `NaN`.
   *
   * @param  the type of the input elements
   * @param mapper a function extracting the property to be summed
   * @return a `Collector` that produces the sum of a derived property
  */
  static summingDouble<T>(mapper: ToDoubleFunction<any>): Collector<T, any, number>;
  /**
   * Returns a `Collector` that produces the arithmetic mean of an integer-valued
   * function applied to the input elements.  If no elements are present,
   * the result is 0.
   *
   * @param  the type of the input elements
   * @param mapper a function extracting the property to be averaged
   * @return a `Collector` that produces the arithmetic mean of a
   * derived property
  */
  static averagingInt<T>(mapper: ToIntFunction<any>): Collector<T, any, number>;
  /**
   * Returns a `Collector` that produces the arithmetic mean of a long-valued
   * function applied to the input elements.  If no elements are present,
   * the result is 0.
   *
   * @param  the type of the input elements
   * @param mapper a function extracting the property to be averaged
   * @return a `Collector` that produces the arithmetic mean of a
   * derived property
  */
  static averagingLong<T>(mapper: ToLongFunction<any>): Collector<T, any, number>;
  /**
   * Returns a `Collector` that produces the arithmetic mean of a double-valued
   * function applied to the input elements.  If no elements are present,
   * the result is 0.
   *
   * The average returned can vary depending upon the order in which
   * values are recorded, due to accumulated rounding error in
   * addition of values of differing magnitudes. Values sorted by increasing
   * absolute magnitude tend to yield more accurate results.  If any recorded
   * value is a `NaN` or the sum is at any point a `NaN` then the
   * average will be `NaN`.
   *
   * @implNote The `double` format can represent all
   * consecutive integers in the range -253 to
   * 253. If the pipeline has more than 253
   * values, the divisor in the average computation will saturate at
   * 253, leading to additional numerical errors.
   *
   * @param  the type of the input elements
   * @param mapper a function extracting the property to be averaged
   * @return a `Collector` that produces the arithmetic mean of a
   * derived property
  */
  static averagingDouble<T>(mapper: ToDoubleFunction<any>): Collector<T, any, number>;
  /**
   * Returns a `Collector` which performs a reduction of its
   * input elements under a specified `BinaryOperator` using the
   * provided identity.
   *
   * @apiNote
   * The `reducing()` collectors are most useful when used in a
   * multi-level reduction, downstream of `groupingBy` or
   * `partitioningBy`.  To perform a simple reduction on a stream,
   * use {@link Stream#reduce(Object, BinaryOperator)}} instead.
   *
   * @param  element type for the input and output of the reduction
   * @param identity the identity value for the reduction (also, the value
   *                 that is returned when there are no input elements)
   * @param op a `BinaryOperator` used to reduce the input elements
   * @return a `Collector` which implements the reduction operation
   *
   * @see #reducing(BinaryOperator)
   * @see #reducing(Object, Function, BinaryOperator)
  */
  static reducing<T>(identity: T, op: BinaryOperator<T>): Collector<T, any, T>;
  /**
   * Returns a `Collector` which performs a reduction of its
   * input elements under a specified `BinaryOperator`.  The result
   * is described as an `Optional`.
   *
   * @apiNote
   * The `reducing()` collectors are most useful when used in a
   * multi-level reduction, downstream of `groupingBy` or
   * `partitioningBy`.  To perform a simple reduction on a stream,
   * use {@link Stream#reduce(BinaryOperator)} instead.
   *
   * For example, given a stream of `Person`, to calculate tallest
   * person in each city:
   * {@code
   * Comparator byHeight = Comparator.comparing(Person::getHeight);
   * Map> tallestByCity
   *   = people.stream().collect(
   *     groupingBy(Person::getCity,
   *                reducing(BinaryOperator.maxBy(byHeight))));
   * }
   *
   * @param  element type for the input and output of the reduction
   * @param op a `BinaryOperator` used to reduce the input elements
   * @return a `Collector` which implements the reduction operation
   *
   * @see #reducing(Object, BinaryOperator)
   * @see #reducing(Object, Function, BinaryOperator)
  */
  static reducing<T>(op: BinaryOperator<T>): Collector<T, any, Optional<T>>;
  /**
   * Returns a `Collector` which performs a reduction of its
   * input elements under a specified mapping function and
   * `BinaryOperator`. This is a generalization of
   * {@link #reducing(Object, BinaryOperator)} which allows a transformation
   * of the elements before reduction.
   *
   * @apiNote
   * The `reducing()` collectors are most useful when used in a
   * multi-level reduction, downstream of `groupingBy` or
   * `partitioningBy`.  To perform a simple map-reduce on a stream,
   * use {@link Stream#map(Function)} and {@link Stream#reduce(Object, BinaryOperator)}
   * instead.
   *
   * For example, given a stream of `Person`, to calculate the longest
   * last name of residents in each city:
   * {@code
   * Comparator byLength = Comparator.comparing(String::length);
   * Map longestLastNameByCity
   *   = people.stream().collect(
   *     groupingBy(Person::getCity,
   *                reducing("",
   *                         Person::getLastName,
   *                         BinaryOperator.maxBy(byLength))));
   * }
   *
   * @param  the type of the input elements
   * @param  the type of the mapped values
   * @param identity the identity value for the reduction (also, the value
   *                 that is returned when there are no input elements)
   * @param mapper a mapping function to apply to each input value
   * @param op a `BinaryOperator` used to reduce the mapped values
   * @return a `Collector` implementing the map-reduce operation
   *
   * @see #reducing(Object, BinaryOperator)
   * @see #reducing(BinaryOperator)
  */
  static reducing<T, U>(identity: U, mapper: Function<any, U>, op: BinaryOperator<U>): Collector<T, any, U>;
  /**
   * Returns a `Collector` implementing a "group by" operation on
   * input elements of type `T`, grouping elements according to a
   * classification function, and returning the results in a `Map`.
   *
   * The classification function maps elements to some key type `K`.
   * The collector produces a `Map>` whose keys are the
   * values resulting from applying the classification function to the input
   * elements, and whose corresponding values are `List`s containing the
   * input elements which map to the associated key under the classification
   * function.
   *
   * There are no guarantees on the type, mutability, serializability, or
   * thread-safety of the `Map` or `List` objects returned.
   * @implSpec
   * This produces a result similar to:
   * {@code
   *     groupingBy(classifier, toList());
   * }
   *
   * @implNote
   * The returned `Collector` is not concurrent.  For parallel stream
   * pipelines, the `combiner` function operates by merging the keys
   * from one map into another, which can be an expensive operation.  If
   * preservation of the order in which elements appear in the resulting `Map`
   * collector is not required, using {@link #groupingByConcurrent(Function)}
   * may offer better parallel performance.
   *
   * @param  the type of the input elements
   * @param  the type of the keys
   * @param classifier the classifier function mapping input elements to keys
   * @return a `Collector` implementing the group-by operation
   *
   * @see #groupingBy(Function, Collector)
   * @see #groupingBy(Function, Supplier, Collector)
   * @see #groupingByConcurrent(Function)
  */
  static groupingBy<T, K>(classifier: Function<any, K>): Collector<T, any, Map<K, T[]>>;
  /**
   * Returns a `Collector` implementing a cascaded "group by" operation
   * on input elements of type `T`, grouping elements according to a
   * classification function, and then performing a reduction operation on
   * the values associated with a given key using the specified downstream
   * `Collector`.
   *
   * The classification function maps elements to some key type `K`.
   * The downstream collector operates on elements of type `T` and
   * produces a result of type `D`. The resulting collector produces a
   * `Map`.
   *
   * There are no guarantees on the type, mutability,
   * serializability, or thread-safety of the `Map` returned.
   *
   * For example, to compute the set of last names of people in each city:
   * {@code
   * Map> namesByCity
   *   = people.stream().collect(
   *     groupingBy(Person::getCity,
   *                mapping(Person::getLastName,
   *                        toSet())));
   * }
   *
   * @implNote
   * The returned `Collector` is not concurrent.  For parallel stream
   * pipelines, the `combiner` function operates by merging the keys
   * from one map into another, which can be an expensive operation.  If
   * preservation of the order in which elements are presented to the downstream
   * collector is not required, using {@link #groupingByConcurrent(Function, Collector)}
   * may offer better parallel performance.
   *
   * @param  the type of the input elements
   * @param  the type of the keys
   * @param  the intermediate accumulation type of the downstream collector
   * @param  the result type of the downstream reduction
   * @param classifier a classifier function mapping input elements to keys
   * @param downstream a `Collector` implementing the downstream reduction
   * @return a `Collector` implementing the cascaded group-by operation
   * @see #groupingBy(Function)
   *
   * @see #groupingBy(Function, Supplier, Collector)
   * @see #groupingByConcurrent(Function, Collector)
  */
  static groupingBy<T, K, A, D>(classifier: Function<any, K>, downstream: Collector<any, A, D>): Collector<T, any, Map<K, D>>;
  /**
   * Returns a `Collector` implementing a cascaded "group by" operation
   * on input elements of type `T`, grouping elements according to a
   * classification function, and then performing a reduction operation on
   * the values associated with a given key using the specified downstream
   * `Collector`.  The `Map` produced by the Collector is created
   * with the supplied factory function.
   *
   * The classification function maps elements to some key type `K`.
   * The downstream collector operates on elements of type `T` and
   * produces a result of type `D`. The resulting collector produces a
   * `Map`.
   *
   * For example, to compute the set of last names of people in each city,
   * where the city names are sorted:
   * {@code
   * Map> namesByCity
   *   = people.stream().collect(
   *     groupingBy(Person::getCity,
   *                TreeMap::new,
   *                mapping(Person::getLastName,
   *                        toSet())));
   * }
   *
   * @implNote
   * The returned `Collector` is not concurrent.  For parallel stream
   * pipelines, the `combiner` function operates by merging the keys
   * from one map into another, which can be an expensive operation.  If
   * preservation of the order in which elements are presented to the downstream
   * collector is not required, using {@link #groupingByConcurrent(Function, Supplier, Collector)}
   * may offer better parallel performance.
   *
   * @param  the type of the input elements
   * @param  the type of the keys
   * @param  the intermediate accumulation type of the downstream collector
   * @param  the result type of the downstream reduction
   * @param  the type of the resulting `Map`
   * @param classifier a classifier function mapping input elements to keys
   * @param downstream a `Collector` implementing the downstream reduction
   * @param mapFactory a supplier providing a new empty `Map`
   *                   into which the results will be inserted
   * @return a `Collector` implementing the cascaded group-by operation
   *
   * @see #groupingBy(Function, Collector)
   * @see #groupingBy(Function)
   * @see #groupingByConcurrent(Function, Supplier, Collector)
  */
  static groupingBy<T, K, D, A, M>(classifier: Function<any, K>, mapFactory: Supplier<M>, downstream: Collector<any, A, D>): Collector<T, any, M>;
  /**
   * Returns a concurrent `Collector` implementing a "group by"
   * operation on input elements of type `T`, grouping elements
   * according to a classification function.
   *
   * This is a {@link Collector.Characteristics#CONCURRENT concurrent} and
   * {@link Collector.Characteristics#UNORDERED unordered} Collector.
   *
   * The classification function maps elements to some key type `K`.
   * The collector produces a `ConcurrentMap>` whose keys are the
   * values resulting from applying the classification function to the input
   * elements, and whose corresponding values are `List`s containing the
   * input elements which map to the associated key under the classification
   * function.
   *
   * There are no guarantees on the type, mutability, or serializability
   * of the `ConcurrentMap` or `List` objects returned, or of the
   * thread-safety of the `List` objects returned.
   * @implSpec
   * This produces a result similar to:
   * {@code
   *     groupingByConcurrent(classifier, toList());
   * }
   *
   * @param  the type of the input elements
   * @param  the type of the keys
   * @param classifier a classifier function mapping input elements to keys
   * @return a concurrent, unordered `Collector` implementing the group-by operation
   *
   * @see #groupingBy(Function)
   * @see #groupingByConcurrent(Function, Collector)
   * @see #groupingByConcurrent(Function, Supplier, Collector)
  */
  static groupingByConcurrent<T, K>(classifier: Function<any, K>): Collector<T, any, ConcurrentMap<K, T[]>>;
  /**
   * Returns a concurrent `Collector` implementing a cascaded "group by"
   * operation on input elements of type `T`, grouping elements
   * according to a classification function, and then performing a reduction
   * operation on the values associated with a given key using the specified
   * downstream `Collector`.
   *
   * This is a {@link Collector.Characteristics#CONCURRENT concurrent} and
   * {@link Collector.Characteristics#UNORDERED unordered} Collector.
   *
   * The classification function maps elements to some key type `K`.
   * The downstream collector operates on elements of type `T` and
   * produces a result of type `D`. The resulting collector produces a
   * `ConcurrentMap`.
   *
   * There are no guarantees on the type, mutability, or serializability
   * of the `ConcurrentMap` returned.
   *
   * For example, to compute the set of last names of people in each city,
   * where the city names are sorted:
   * {@code
   * ConcurrentMap> namesByCity
   *   = people.stream().collect(
   *     groupingByConcurrent(Person::getCity,
   *                          mapping(Person::getLastName,
   *                                  toSet())));
   * }
   *
   * @param  the type of the input elements
   * @param  the type of the keys
   * @param  the intermediate accumulation type of the downstream collector
   * @param  the result type of the downstream reduction
   * @param classifier a classifier function mapping input elements to keys
   * @param downstream a `Collector` implementing the downstream reduction
   * @return a concurrent, unordered `Collector` implementing the cascaded group-by operation
   *
   * @see #groupingBy(Function, Collector)
   * @see #groupingByConcurrent(Function)
   * @see #groupingByConcurrent(Function, Supplier, Collector)
  */
  static groupingByConcurrent<T, K, A, D>(classifier: Function<any, K>, downstream: Collector<any, A, D>): Collector<T, any, ConcurrentMap<K, D>>;
  /**
   * Returns a concurrent `Collector` implementing a cascaded "group by"
   * operation on input elements of type `T`, grouping elements
   * according to a classification function, and then performing a reduction
   * operation on the values associated with a given key using the specified
   * downstream `Collector`.  The `ConcurrentMap` produced by the
   * Collector is created with the supplied factory function.
   *
   * This is a {@link Collector.Characteristics#CONCURRENT concurrent} and
   * {@link Collector.Characteristics#UNORDERED unordered} Collector.
   *
   * The classification function maps elements to some key type `K`.
   * The downstream collector operates on elements of type `T` and
   * produces a result of type `D`. The resulting collector produces a
   * `ConcurrentMap`.
   *
   * For example, to compute the set of last names of people in each city,
   * where the city names are sorted:
   * {@code
   * ConcurrentMap> namesByCity
   *   = people.stream().collect(
   *     groupingByConcurrent(Person::getCity,
   *                          ConcurrentSkipListMap::new,
   *                          mapping(Person::getLastName,
   *                                  toSet())));
   * }
   *
   * @param  the type of the input elements
   * @param  the type of the keys
   * @param  the intermediate accumulation type of the downstream collector
   * @param  the result type of the downstream reduction
   * @param  the type of the resulting `ConcurrentMap`
   * @param classifier a classifier function mapping input elements to keys
   * @param downstream a `Collector` implementing the downstream reduction
   * @param mapFactory a supplier providing a new empty `ConcurrentMap`
   *                   into which the results will be inserted
   * @return a concurrent, unordered `Collector` implementing the cascaded group-by operation
   *
   * @see #groupingByConcurrent(Function)
   * @see #groupingByConcurrent(Function, Collector)
   * @see #groupingBy(Function, Supplier, Collector)
  */
  static groupingByConcurrent<T, K, A, D, M>(classifier: Function<any, K>, mapFactory: Supplier<M>, downstream: Collector<any, A, D>): Collector<T, any, M>;
  /**
   * Returns a `Collector` which partitions the input elements according
   * to a `Predicate`, and organizes them into a
   * `Map>`.
   *
   * The returned `Map` always contains mappings for both
   * `false` and `true` keys.
   * There are no guarantees on the type, mutability,
   * serializability, or thread-safety of the `Map` or `List`
   * returned.
   *
   * @apiNote
   * If a partition has no elements, its value in the result Map will be
   * an empty List.
   *
   * @param  the type of the input elements
   * @param predicate a predicate used for classifying input elements
   * @return a `Collector` implementing the partitioning operation
   *
   * @see #partitioningBy(Predicate, Collector)
  */
  static partitioningBy<T>(predicate: Predicate<any>): Collector<T, any, Map<boolean, T[]>>;
  /**
   * Returns a `Collector` which partitions the input elements according
   * to a `Predicate`, reduces the values in each partition according to
   * another `Collector`, and organizes them into a
   * `Map` whose values are the result of the downstream
   * reduction.
   *
   * 
   * The returned `Map` always contains mappings for both
   * `false` and `true` keys.
   * There are no guarantees on the type, mutability,
   * serializability, or thread-safety of the `Map` returned.
   *
   * @apiNote
   * If a partition has no elements, its value in the result Map will be
   * obtained by calling the downstream collector's supplier function and then
   * applying the finisher function.
   *
   * @param  the type of the input elements
   * @param  the intermediate accumulation type of the downstream collector
   * @param  the result type of the downstream reduction
   * @param predicate a predicate used for classifying input elements
   * @param downstream a `Collector` implementing the downstream
   *                   reduction
   * @return a `Collector` implementing the cascaded partitioning
   *         operation
   *
   * @see #partitioningBy(Predicate)
  */
  static partitioningBy<T, D, A>(predicate: Predicate<any>, downstream: Collector<any, A, D>): Collector<T, any, Map<boolean, D>>;
  /**
   * Returns a `Collector` that accumulates elements into a
   * `Map` whose keys and values are the result of applying the provided
   * mapping functions to the input elements.
   *
   * If the mapped keys contain duplicates (according to
   * {@link Object#equals(Object)}), an `IllegalStateException` is
   * thrown when the collection operation is performed.  If the mapped keys
   * might have duplicates, use {@link #toMap(Function, Function, BinaryOperator)}
   * instead.
   *
   * There are no guarantees on the type, mutability, serializability,
   * or thread-safety of the `Map` returned.
   *
   * @apiNote
   * It is common for either the key or the value to be the input elements.
   * In this case, the utility method
   * {@link java.util.function.Function#identity()} may be helpful.
   * For example, the following produces a `Map` mapping
   * students to their grade point average:
   * {@code
   * Map studentToGPA
   *   = students.stream().collect(
   *     toMap(Function.identity(),
   *           student -> computeGPA(student)));
   * }
   * And the following produces a `Map` mapping a unique identifier to
   * students:
   * {@code
   * Map studentIdToStudent
   *   = students.stream().collect(
   *     toMap(Student::getId,
   *           Function.identity()));
   * }
   *
   * @implNote
   * The returned `Collector` is not concurrent.  For parallel stream
   * pipelines, the `combiner` function operates by merging the keys
   * from one map into another, which can be an expensive operation.  If it is
   * not required that results are inserted into the `Map` in encounter
   * order, using {@link #toConcurrentMap(Function, Function)}
   * may offer better parallel performance.
   *
   * @param  the type of the input elements
   * @param  the output type of the key mapping function
   * @param  the output type of the value mapping function
   * @param keyMapper a mapping function to produce keys
   * @param valueMapper a mapping function to produce values
   * @return a `Collector` which collects elements into a `Map`
   * whose keys and values are the result of applying mapping functions to
   * the input elements
   *
   * @see #toMap(Function, Function, BinaryOperator)
   * @see #toMap(Function, Function, BinaryOperator, Supplier)
   * @see #toConcurrentMap(Function, Function)
  */
  static toMap<T, K, U>(keyMapper: Function<any, K>, valueMapper: Function<any, U>): Collector<T, any, Map<K, U>>;
  /**
   * Returns a `Collector` that accumulates the input elements into an
   * unmodifiable Map,
   * whose keys and values are the result of applying the provided
   * mapping functions to the input elements.
   *
   * If the mapped keys contain duplicates (according to
   * {@link Object#equals(Object)}), an `IllegalStateException` is
   * thrown when the collection operation is performed.  If the mapped keys
   * might have duplicates, use {@link #toUnmodifiableMap(Function, Function, BinaryOperator)}
   * to handle merging of the values.
   *
   * The returned Collector disallows null keys and values. If either mapping function
   * returns null, `NullPointerException` will be thrown.
   *
   * @param  the type of the input elements
   * @param  the output type of the key mapping function
   * @param  the output type of the value mapping function
   * @param keyMapper a mapping function to produce keys, must be non-null
   * @param valueMapper a mapping function to produce values, must be non-null
   * @return a `Collector` that accumulates the input elements into an
   * unmodifiable Map, whose keys and values
   * are the result of applying the provided mapping functions to the input elements
   * @throws NullPointerException if either keyMapper or valueMapper is null
   *
   * @see #toUnmodifiableMap(Function, Function, BinaryOperator)
   * @since 10
  */
  static toUnmodifiableMap<T, K, U>(keyMapper: Function<any, K>, valueMapper: Function<any, U>): Collector<T, any, Map<K, U>>;
  /**
   * Returns a `Collector` that accumulates elements into a
   * `Map` whose keys and values are the result of applying the provided
   * mapping functions to the input elements.
   *
   * If the mapped
   * keys contain duplicates (according to {@link Object#equals(Object)}),
   * the value mapping function is applied to each equal element, and the
   * results are merged using the provided merging function.
   *
   * There are no guarantees on the type, mutability, serializability,
   * or thread-safety of the `Map` returned.
   *
   * @apiNote
   * There are multiple ways to deal with collisions between multiple elements
   * mapping to the same key.  The other forms of `toMap` simply use
   * a merge function that throws unconditionally, but you can easily write
   * more flexible merge policies.  For example, if you have a stream
   * of `Person`, and you want to produce a "phone book" mapping name to
   * address, but it is possible that two persons have the same name, you can
   * do as follows to gracefully deal with these collisions, and produce a
   * `Map` mapping names to a concatenated list of addresses:
   * {@code
   * Map phoneBook
   *   = people.stream().collect(
   *     toMap(Person::getName,
   *           Person::getAddress,
   *           (s, a) -> s + ", " + a));
   * }
   *
   * @implNote
   * The returned `Collector` is not concurrent.  For parallel stream
   * pipelines, the `combiner` function operates by merging the keys
   * from one map into another, which can be an expensive operation.  If it is
   * not required that results are merged into the `Map` in encounter
   * order, using {@link #toConcurrentMap(Function, Function, BinaryOperator)}
   * may offer better parallel performance.
   *
   * @param  the type of the input elements
   * @param  the output type of the key mapping function
   * @param  the output type of the value mapping function
   * @param keyMapper a mapping function to produce keys
   * @param valueMapper a mapping function to produce values
   * @param mergeFunction a merge function, used to resolve collisions between
   *                      values associated with the same key, as supplied
   *                      to {@link Map#merge(Object, Object, BiFunction)}
   * @return a `Collector` which collects elements into a `Map`
   * whose keys are the result of applying a key mapping function to the input
   * elements, and whose values are the result of applying a value mapping
   * function to all input elements equal to the key and combining them
   * using the merge function
   *
   * @see #toMap(Function, Function)
   * @see #toMap(Function, Function, BinaryOperator, Supplier)
   * @see #toConcurrentMap(Function, Function, BinaryOperator)
  */
  static toMap<T, K, U>(keyMapper: Function<any, K>, valueMapper: Function<any, U>, mergeFunction: BinaryOperator<U>): Collector<T, any, Map<K, U>>;
  /**
   * Returns a `Collector` that accumulates the input elements into an
   * unmodifiable Map,
   * whose keys and values are the result of applying the provided
   * mapping functions to the input elements.
   *
   * If the mapped
   * keys contain duplicates (according to {@link Object#equals(Object)}),
   * the value mapping function is applied to each equal element, and the
   * results are merged using the provided merging function.
   *
   * The returned Collector disallows null keys and values. If either mapping function
   * returns null, `NullPointerException` will be thrown.
   *
   * @param  the type of the input elements
   * @param  the output type of the key mapping function
   * @param  the output type of the value mapping function
   * @param keyMapper a mapping function to produce keys, must be non-null
   * @param valueMapper a mapping function to produce values, must be non-null
   * @param mergeFunction a merge function, used to resolve collisions between
   *                      values associated with the same key, as supplied
   *                      to {@link Map#merge(Object, Object, BiFunction)},
   *                      must be non-null
   * @return a `Collector` that accumulates the input elements into an
   * unmodifiable Map, whose keys and values
   * are the result of applying the provided mapping functions to the input elements
   * @throws NullPointerException if the keyMapper, valueMapper, or mergeFunction is null
   *
   * @see #toUnmodifiableMap(Function, Function)
   * @since 10
  */
  static toUnmodifiableMap<T, K, U>(keyMapper: Function<any, K>, valueMapper: Function<any, U>, mergeFunction: BinaryOperator<U>): Collector<T, any, Map<K, U>>;
  /**
   * Returns a `Collector` that accumulates elements into a
   * `Map` whose keys and values are the result of applying the provided
   * mapping functions to the input elements.
   *
   * If the mapped
   * keys contain duplicates (according to {@link Object#equals(Object)}),
   * the value mapping function is applied to each equal element, and the
   * results are merged using the provided merging function.  The `Map`
   * is created by a provided supplier function.
   *
   * @implNote
   * The returned `Collector` is not concurrent.  For parallel stream
   * pipelines, the `combiner` function operates by merging the keys
   * from one map into another, which can be an expensive operation.  If it is
   * not required that results are merged into the `Map` in encounter
   * order, using {@link #toConcurrentMap(Function, Function, BinaryOperator, Supplier)}
   * may offer better parallel performance.
   *
   * @param  the type of the input elements
   * @param  the output type of the key mapping function
   * @param  the output type of the value mapping function
   * @param  the type of the resulting `Map`
   * @param keyMapper a mapping function to produce keys
   * @param valueMapper a mapping function to produce values
   * @param mergeFunction a merge function, used to resolve collisions between
   *                      values associated with the same key, as supplied
   *                      to {@link Map#merge(Object, Object, BiFunction)}
   * @param mapFactory a supplier providing a new empty `Map`
   *                   into which the results will be inserted
   * @return a `Collector` which collects elements into a `Map`
   * whose keys are the result of applying a key mapping function to the input
   * elements, and whose values are the result of applying a value mapping
   * function to all input elements equal to the key and combining them
   * using the merge function
   *
   * @see #toMap(Function, Function)
   * @see #toMap(Function, Function, BinaryOperator)
   * @see #toConcurrentMap(Function, Function, BinaryOperator, Supplier)
  */
  static toMap<T, K, U, M>(keyMapper: Function<any, K>, valueMapper: Function<any, U>, mergeFunction: BinaryOperator<U>, mapFactory: Supplier<M>): Collector<T, any, M>;
  /**
   * Returns a concurrent `Collector` that accumulates elements into a
   * `ConcurrentMap` whose keys and values are the result of applying
   * the provided mapping functions to the input elements.
   *
   * If the mapped keys contain duplicates (according to
   * {@link Object#equals(Object)}), an `IllegalStateException` is
   * thrown when the collection operation is performed.  If the mapped keys
   * may have duplicates, use
   * {@link #toConcurrentMap(Function, Function, BinaryOperator)} instead.
   *
   * There are no guarantees on the type, mutability, or serializability
   * of the `ConcurrentMap` returned.
   *
   * @apiNote
   * It is common for either the key or the value to be the input elements.
   * In this case, the utility method
   * {@link java.util.function.Function#identity()} may be helpful.
   * For example, the following produces a `ConcurrentMap` mapping
   * students to their grade point average:
   * {@code
   * ConcurrentMap studentToGPA
   *   = students.stream().collect(
   *     toConcurrentMap(Function.identity(),
   *                     student -> computeGPA(student)));
   * }
   * And the following produces a `ConcurrentMap` mapping a
   * unique identifier to students:
   * {@code
   * ConcurrentMap studentIdToStudent
   *   = students.stream().collect(
   *     toConcurrentMap(Student::getId,
   *                     Function.identity()));
   * }
   *
   * This is a {@link Collector.Characteristics#CONCURRENT concurrent} and
   * {@link Collector.Characteristics#UNORDERED unordered} Collector.
   *
   * @param  the type of the input elements
   * @param  the output type of the key mapping function
   * @param  the output type of the value mapping function
   * @param keyMapper the mapping function to produce keys
   * @param valueMapper the mapping function to produce values
   * @return a concurrent, unordered `Collector` which collects elements into a
   * `ConcurrentMap` whose keys are the result of applying a key mapping
   * function to the input elements, and whose values are the result of
   * applying a value mapping function to the input elements
   *
   * @see #toMap(Function, Function)
   * @see #toConcurrentMap(Function, Function, BinaryOperator)
   * @see #toConcurrentMap(Function, Function, BinaryOperator, Supplier)
  */
  static toConcurrentMap<T, K, U>(keyMapper: Function<any, K>, valueMapper: Function<any, U>): Collector<T, any, ConcurrentMap<K, U>>;
  /**
   * Returns a concurrent `Collector` that accumulates elements into a
   * `ConcurrentMap` whose keys and values are the result of applying
   * the provided mapping functions to the input elements.
   *
   * If the mapped keys contain duplicates (according to {@link Object#equals(Object)}),
   * the value mapping function is applied to each equal element, and the
   * results are merged using the provided merging function.
   *
   * There are no guarantees on the type, mutability, or serializability
   * of the `ConcurrentMap` returned.
   *
   * @apiNote
   * There are multiple ways to deal with collisions between multiple elements
   * mapping to the same key.  The other forms of `toConcurrentMap` simply use
   * a merge function that throws unconditionally, but you can easily write
   * more flexible merge policies.  For example, if you have a stream
   * of `Person`, and you want to produce a "phone book" mapping name to
   * address, but it is possible that two persons have the same name, you can
   * do as follows to gracefully deal with these collisions, and produce a
   * `ConcurrentMap` mapping names to a concatenated list of addresses:
   * {@code
   * ConcurrentMap phoneBook
   *   = people.stream().collect(
   *     toConcurrentMap(Person::getName,
   *                     Person::getAddress,
   *                     (s, a) -> s + ", " + a));
   * }
   *
   * This is a {@link Collector.Characteristics#CONCURRENT concurrent} and
   * {@link Collector.Characteristics#UNORDERED unordered} Collector.
   *
   * @param  the type of the input elements
   * @param  the output type of the key mapping function
   * @param  the output type of the value mapping function
   * @param keyMapper a mapping function to produce keys
   * @param valueMapper a mapping function to produce values
   * @param mergeFunction a merge function, used to resolve collisions between
   *                      values associated with the same key, as supplied
   *                      to {@link Map#merge(Object, Object, BiFunction)}
   * @return a concurrent, unordered `Collector` which collects elements into a
   * `ConcurrentMap` whose keys are the result of applying a key mapping
   * function to the input elements, and whose values are the result of
   * applying a value mapping function to all input elements equal to the key
   * and combining them using the merge function
   *
   * @see #toConcurrentMap(Function, Function)
   * @see #toConcurrentMap(Function, Function, BinaryOperator, Supplier)
   * @see #toMap(Function, Function, BinaryOperator)
  */
  static toConcurrentMap<T, K, U>(keyMapper: Function<any, K>, valueMapper: Function<any, U>, mergeFunction: BinaryOperator<U>): Collector<T, any, ConcurrentMap<K, U>>;
  /**
   * Returns a concurrent `Collector` that accumulates elements into a
   * `ConcurrentMap` whose keys and values are the result of applying
   * the provided mapping functions to the input elements.
   *
   * If the mapped keys contain duplicates (according to {@link Object#equals(Object)}),
   * the value mapping function is applied to each equal element, and the
   * results are merged using the provided merging function.  The
   * `ConcurrentMap` is created by a provided supplier function.
   *
   * This is a {@link Collector.Characteristics#CONCURRENT concurrent} and
   * {@link Collector.Characteristics#UNORDERED unordered} Collector.
   *
   * @param  the type of the input elements
   * @param  the output type of the key mapping function
   * @param  the output type of the value mapping function
   * @param  the type of the resulting `ConcurrentMap`
   * @param keyMapper a mapping function to produce keys
   * @param valueMapper a mapping function to produce values
   * @param mergeFunction a merge function, used to resolve collisions between
   *                      values associated with the same key, as supplied
   *                      to {@link Map#merge(Object, Object, BiFunction)}
   * @param mapFactory a supplier providing a new empty `ConcurrentMap`
   *                   into which the results will be inserted
   * @return a concurrent, unordered `Collector` which collects elements into a
   * `ConcurrentMap` whose keys are the result of applying a key mapping
   * function to the input elements, and whose values are the result of
   * applying a value mapping function to all input elements equal to the key
   * and combining them using the merge function
   *
   * @see #toConcurrentMap(Function, Function)
   * @see #toConcurrentMap(Function, Function, BinaryOperator)
   * @see #toMap(Function, Function, BinaryOperator, Supplier)
  */
  static toConcurrentMap<T, K, U, M>(keyMapper: Function<any, K>, valueMapper: Function<any, U>, mergeFunction: BinaryOperator<U>, mapFactory: Supplier<M>): Collector<T, any, M>;
  /**
   * Returns a `Collector` which applies an `int`-producing
   * mapping function to each input element, and returns summary statistics
   * for the resulting values.
   *
   * @param  the type of the input elements
   * @param mapper a mapping function to apply to each element
   * @return a `Collector` implementing the summary-statistics reduction
   *
   * @see #summarizingDouble(ToDoubleFunction)
   * @see #summarizingLong(ToLongFunction)
  */
  static summarizingInt<T>(mapper: ToIntFunction<any>): Collector<T, any, IntSummaryStatistics>;
  /**
   * Returns a `Collector` which applies an `long`-producing
   * mapping function to each input element, and returns summary statistics
   * for the resulting values.
   *
   * @param  the type of the input elements
   * @param mapper the mapping function to apply to each element
   * @return a `Collector` implementing the summary-statistics reduction
   *
   * @see #summarizingDouble(ToDoubleFunction)
   * @see #summarizingInt(ToIntFunction)
  */
  static summarizingLong<T>(mapper: ToLongFunction<any>): Collector<T, any, LongSummaryStatistics>;
  /**
   * Returns a `Collector` which applies an `double`-producing
   * mapping function to each input element, and returns summary statistics
   * for the resulting values.
   *
   * @param  the type of the input elements
   * @param mapper a mapping function to apply to each element
   * @return a `Collector` implementing the summary-statistics reduction
   *
   * @see #summarizingLong(ToLongFunction)
   * @see #summarizingInt(ToIntFunction)
  */
  static summarizingDouble<T>(mapper: ToDoubleFunction<any>): Collector<T, any, DoubleSummaryStatistics>;
  /**
   * Returns a `Collector` that is a composite of two downstream collectors.
   * Every element passed to the resulting collector is processed by both downstream
   * collectors, then their results are merged using the specified merge function
   * into the final result.
   *
   * The resulting collector functions do the following:
   *
   * 
   * supplier: creates a result container that contains result containers
   * obtained by calling each collector's supplier
   * accumulator: calls each collector's accumulator with its result container
   * and the input element
   * combiner: calls each collector's combiner with two result containers
   * finisher: calls each collector's finisher with its result container,
   * then calls the supplied merger and returns its result.
   * 
   *
   * The resulting collector is {@link Collector.Characteristics#UNORDERED} if both downstream
   * collectors are unordered and {@link Collector.Characteristics#CONCURRENT} if both downstream
   * collectors are concurrent.
   *
   * @param          the type of the input elements
   * @param         the result type of the first collector
   * @param         the result type of the second collector
   * @param          the final result type
   * @param downstream1 the first downstream collector
   * @param downstream2 the second downstream collector
   * @param merger      the function which merges two results into the single one
   * @return a `Collector` which aggregates the results of two supplied collectors.
   * @since 12
  */
  static teeing<T, R1, R2, R>(downstream1: Collector<any, any, R1>, downstream2: Collector<any, any, R2>, merger: BiFunction<any, any, R>): Collector<T, any, R>;
}
/**
 * A sequence of primitive double-valued elements supporting sequential and parallel
 * aggregate operations.  This is the `double` primitive specialization of
 * {@link Stream}.
 *
 * The following example illustrates an aggregate operation using
 * {@link Stream} and {@link DoubleStream}, computing the sum of the weights of the
 * red widgets:
 *
 * {@code
 *     double sum = widgets.stream()
 *                         .filter(w -> w.getColor() == RED)
 *                         .mapToDouble(w -> w.getWeight())
 *                         .sum();
 * }
 *
 * See the class documentation for {@link Stream} and the package documentation
 * for java.util.stream for additional
 * specification of streams, stream operations, stream pipelines, and
 * parallelism.
 *
 * @since 1.8
 * @see Stream
 * @see java.util.stream
*/
export class DoubleStream extends BaseStream<number, DoubleStream> {
  /**
   * Returns a stream consisting of the elements of this stream that match
   * the given predicate.
   *
   * This is an intermediate
   * operation.
   *
   * @param predicate a non-interfering,
   *                  stateless
   *                  predicate to apply to each element to determine if it
   *                  should be included
   * @return the new stream
  */
  filter(predicate: DoublePredicate): DoubleStream;
  /**
   * Returns a stream consisting of the results of applying the given
   * function to the elements of this stream.
   *
   * This is an intermediate
   * operation.
   *
   * @param mapper a non-interfering,
   *               stateless
   *               function to apply to each element
   * @return the new stream
  */
  map(mapper: DoubleUnaryOperator): DoubleStream;
  /**
   * Returns an object-valued `Stream` consisting of the results of
   * applying the given function to the elements of this stream.
   *
   * This is an 
   *     intermediate operation.
   *
   * @param  the element type of the new stream
   * @param mapper a non-interfering,
   *               stateless
   *               function to apply to each element
   * @return the new stream
  */
  mapToObj<U>(mapper: DoubleFunction<U>): Stream<U>;
  /**
   * Returns an `IntStream` consisting of the results of applying the
   * given function to the elements of this stream.
   *
   * This is an intermediate
   * operation.
   *
   * @param mapper a non-interfering,
   *               stateless
   *               function to apply to each element
   * @return the new stream
  */
  mapToInt(mapper: DoubleToIntFunction): IntStream;
  /**
   * Returns a `LongStream` consisting of the results of applying the
   * given function to the elements of this stream.
   *
   * This is an intermediate
   * operation.
   *
   * @param mapper a non-interfering,
   *               stateless
   *               function to apply to each element
   * @return the new stream
  */
  mapToLong(mapper: DoubleToLongFunction): LongStream;
  /**
   * Returns a stream consisting of the results of replacing each element of
   * this stream with the contents of a mapped stream produced by applying
   * the provided mapping function to each element.  Each mapped stream is
   * {@link java.util.stream.BaseStream#close() closed} after its contents
   * have been placed into this stream.  (If a mapped stream is `null`
   * an empty stream is used, instead.)
   *
   * This is an intermediate
   * operation.
   *
   * @param mapper a non-interfering,
   *               stateless
   *               function to apply to each element which produces a
   *               `DoubleStream` of new values
   * @return the new stream
   * @see Stream#flatMap(Function)
  */
  flatMap(mapper: DoubleFunction<DoubleStream>): DoubleStream;
  /**
   * Returns a stream consisting of the results of replacing each element of
   * this stream with multiple elements, specifically zero or more elements.
   * Replacement is performed by applying the provided mapping function to each
   * element in conjunction with a {@linkplain DoubleConsumer consumer} argument
   * that accepts replacement elements. The mapping function calls the consumer
   * zero or more times to provide the replacement elements.
   *
   * This is an intermediate
   * operation.
   *
   * If the {@linkplain DoubleConsumer consumer} argument is used outside the scope of
   * its application to the mapping function, the results are undefined.
   *
   * @implSpec
   * The default implementation invokes {@link #flatMap flatMap} on this stream,
   * passing a function that behaves as follows. First, it calls the mapper function
   * with a `DoubleConsumer` that accumulates replacement elements into a newly created
   * internal buffer. When the mapper function returns, it creates a `DoubleStream` from the
   * internal buffer. Finally, it returns this stream to `flatMap`.
   *
   * @param mapper a non-interfering,
   *               stateless
   *               function that generates replacement elements
   * @return the new stream
   * @see Stream#mapMulti Stream.mapMulti
   * @since 16
  */
  mapMulti(mapper: DoubleMapMultiConsumer): DoubleStream;
  /**
   * Returns a stream consisting of the distinct elements of this stream. The
   * elements are compared for equality according to
   * {@link java.lang.Double#compare(double, double)}.
   *
   * This is a stateful
   * intermediate operation.
   *
   * @return the result stream
  */
  distinct(): DoubleStream;
  /**
   * Returns a stream consisting of the elements of this stream in sorted
   * order. The elements are compared for equality according to
   * {@link java.lang.Double#compare(double, double)}.
   *
   * This is a stateful
   * intermediate operation.
   *
   * @return the result stream
  */
  sorted(): DoubleStream;
  /**
   * Returns a stream consisting of the elements of this stream, additionally
   * performing the provided action on each element as elements are consumed
   * from the resulting stream.
   *
   * This is an intermediate
   * operation.
   *
   * For parallel stream pipelines, the action may be called at
   * whatever time and in whatever thread the element is made available by the
   * upstream operation.  If the action modifies shared state,
   * it is responsible for providing the required synchronization.
   *
   * @apiNote This method exists mainly to support debugging, where you want
   * to see the elements as they flow past a certain point in a pipeline:
   * {@code
   *     DoubleStream.of(1, 2, 3, 4)
   *         .filter(e -> e > 2)
   *         .peek(e -> System.out.println("Filtered value: " + e))
   *         .map(e -> e * e)
   *         .peek(e -> System.out.println("Mapped value: " + e))
   *         .sum();
   * }
   *
   * In cases where the stream implementation is able to optimize away the
   * production of some or all the elements (such as with short-circuiting
   * operations like `findFirst`, or in the example described in
   * {@link #count}), the action will not be invoked for those elements.
   *
   * @param action a 
   *               non-interfering action to perform on the elements as
   *               they are consumed from the stream
   * @return the new stream
  */
  peek(action: DoubleConsumer): DoubleStream;
  /**
   * Returns a stream consisting of the elements of this stream, truncated
   * to be no longer than `maxSize` in length.
   *
   * This is a short-circuiting
   * stateful intermediate operation.
   *
   * @apiNote
   * While `limit()` is generally a cheap operation on sequential
   * stream pipelines, it can be quite expensive on ordered parallel pipelines,
   * especially for large values of `maxSize`, since `limit(n)`
   * is constrained to return not just any n elements, but the
   * first n elements in the encounter order.  Using an unordered
   * stream source (such as {@link #generate(DoubleSupplier)}) or removing the
   * ordering constraint with {@link #unordered()} may result in significant
   * speedups of `limit()` in parallel pipelines, if the semantics of
   * your situation permit.  If consistency with encounter order is required,
   * and you are experiencing poor performance or memory utilization with
   * `limit()` in parallel pipelines, switching to sequential execution
   * with {@link #sequential()} may improve performance.
   *
   * @param maxSize the number of elements the stream should be limited to
   * @return the new stream
   * @throws IllegalArgumentException if `maxSize` is negative
  */
  limit(maxSize: number): DoubleStream;
  /**
   * Returns a stream consisting of the remaining elements of this stream
   * after discarding the first `n` elements of the stream.
   * If this stream contains fewer than `n` elements then an
   * empty stream will be returned.
   *
   * This is a stateful
   * intermediate operation.
   *
   * @apiNote
   * While `skip()` is generally a cheap operation on sequential
   * stream pipelines, it can be quite expensive on ordered parallel pipelines,
   * especially for large values of `n`, since `skip(n)`
   * is constrained to skip not just any n elements, but the
   * first n elements in the encounter order.  Using an unordered
   * stream source (such as {@link #generate(DoubleSupplier)}) or removing the
   * ordering constraint with {@link #unordered()} may result in significant
   * speedups of `skip()` in parallel pipelines, if the semantics of
   * your situation permit.  If consistency with encounter order is required,
   * and you are experiencing poor performance or memory utilization with
   * `skip()` in parallel pipelines, switching to sequential execution
   * with {@link #sequential()} may improve performance.
   *
   * @param n the number of leading elements to skip
   * @return the new stream
   * @throws IllegalArgumentException if `n` is negative
  */
  skip(n: number): DoubleStream;
  /**
   * Returns, if this stream is ordered, a stream consisting of the longest
   * prefix of elements taken from this stream that match the given predicate.
   * Otherwise returns, if this stream is unordered, a stream consisting of a
   * subset of elements taken from this stream that match the given predicate.
   *
   * If this stream is ordered then the longest prefix is a contiguous
   * sequence of elements of this stream that match the given predicate.  The
   * first element of the sequence is the first element of this stream, and
   * the element immediately following the last element of the sequence does
   * not match the given predicate.
   *
   * If this stream is unordered, and some (but not all) elements of this
   * stream match the given predicate, then the behavior of this operation is
   * nondeterministic; it is free to take any subset of matching elements
   * (which includes the empty set).
   *
   * Independent of whether this stream is ordered or unordered if all
   * elements of this stream match the given predicate then this operation
   * takes all elements (the result is the same as the input), or if no
   * elements of the stream match the given predicate then no elements are
   * taken (the result is an empty stream).
   *
   * This is a short-circuiting
   * stateful intermediate operation.
   *
   * @implSpec
   * The default implementation obtains the {@link #spliterator() spliterator}
   * of this stream, wraps that spliterator so as to support the semantics
   * of this operation on traversal, and returns a new stream associated with
   * the wrapped spliterator.  The returned stream preserves the execution
   * characteristics of this stream (namely parallel or sequential execution
   * as per {@link #isParallel()}) but the wrapped spliterator may choose to
   * not support splitting.  When the returned stream is closed, the close
   * handlers for both the returned and this stream are invoked.
   *
   * @apiNote
   * While `takeWhile()` is generally a cheap operation on sequential
   * stream pipelines, it can be quite expensive on ordered parallel
   * pipelines, since the operation is constrained to return not just any
   * valid prefix, but the longest prefix of elements in the encounter order.
   * Using an unordered stream source (such as
   * {@link #generate(DoubleSupplier)}) or removing the ordering constraint
   * with {@link #unordered()} may result in significant speedups of
   * `takeWhile()` in parallel pipelines, if the semantics of your
   * situation permit.  If consistency with encounter order is required, and
   * you are experiencing poor performance or memory utilization with
   * `takeWhile()` in parallel pipelines, switching to sequential
   * execution with {@link #sequential()} may improve performance.
   *
   * @param predicate a non-interfering,
   *                  stateless
   *                  predicate to apply to elements to determine the longest
   *                  prefix of elements.
   * @return the new stream
   * @since 9
  */
  takeWhile(predicate: DoublePredicate): DoubleStream;
  /**
   * Returns, if this stream is ordered, a stream consisting of the remaining
   * elements of this stream after dropping the longest prefix of elements
   * that match the given predicate.  Otherwise returns, if this stream is
   * unordered, a stream consisting of the remaining elements of this stream
   * after dropping a subset of elements that match the given predicate.
   *
   * If this stream is ordered then the longest prefix is a contiguous
   * sequence of elements of this stream that match the given predicate.  The
   * first element of the sequence is the first element of this stream, and
   * the element immediately following the last element of the sequence does
   * not match the given predicate.
   *
   * If this stream is unordered, and some (but not all) elements of this
   * stream match the given predicate, then the behavior of this operation is
   * nondeterministic; it is free to drop any subset of matching elements
   * (which includes the empty set).
   *
   * Independent of whether this stream is ordered or unordered if all
   * elements of this stream match the given predicate then this operation
   * drops all elements (the result is an empty stream), or if no elements of
   * the stream match the given predicate then no elements are dropped (the
   * result is the same as the input).
   *
   * This is a stateful
   * intermediate operation.
   *
   * @implSpec
   * The default implementation obtains the {@link #spliterator() spliterator}
   * of this stream, wraps that spliterator so as to support the semantics
   * of this operation on traversal, and returns a new stream associated with
   * the wrapped spliterator.  The returned stream preserves the execution
   * characteristics of this stream (namely parallel or sequential execution
   * as per {@link #isParallel()}) but the wrapped spliterator may choose to
   * not support splitting.  When the returned stream is closed, the close
   * handlers for both the returned and this stream are invoked.
   *
   * @apiNote
   * While `dropWhile()` is generally a cheap operation on sequential
   * stream pipelines, it can be quite expensive on ordered parallel
   * pipelines, since the operation is constrained to return not just any
   * valid prefix, but the longest prefix of elements in the encounter order.
   * Using an unordered stream source (such as
   * {@link #generate(DoubleSupplier)}) or removing the ordering constraint
   * with {@link #unordered()} may result in significant speedups of
   * `dropWhile()` in parallel pipelines, if the semantics of your
   * situation permit.  If consistency with encounter order is required, and
   * you are experiencing poor performance or memory utilization with
   * `dropWhile()` in parallel pipelines, switching to sequential
   * execution with {@link #sequential()} may improve performance.
   *
   * @param predicate a non-interfering,
   *                  stateless
   *                  predicate to apply to elements to determine the longest
   *                  prefix of elements.
   * @return the new stream
   * @since 9
  */
  dropWhile(predicate: DoublePredicate): DoubleStream;
  /**
   * Performs an action for each element of this stream.
   *
   * This is a terminal
   * operation.
   *
   * For parallel stream pipelines, this operation does not
   * guarantee to respect the encounter order of the stream, as doing so
   * would sacrifice the benefit of parallelism.  For any given element, the
   * action may be performed at whatever time and in whatever thread the
   * library chooses.  If the action accesses shared state, it is
   * responsible for providing the required synchronization.
   *
   * @param action a 
   *               non-interfering action to perform on the elements
  */
  forEach(action: DoubleConsumer): void;
  /**
   * Performs an action for each element of this stream, guaranteeing that
   * each element is processed in encounter order for streams that have a
   * defined encounter order.
   *
   * This is a terminal
   * operation.
   *
   * @param action a 
   *               non-interfering action to perform on the elements
   * @see #forEach(DoubleConsumer)
  */
  forEachOrdered(action: DoubleConsumer): void;
  /**
   * Returns an array containing the elements of this stream.
   *
   * This is a terminal
   * operation.
   *
   * @return an array containing the elements of this stream
  */
  toArray(): number[];
  /**
   * Performs a reduction on the
   * elements of this stream, using the provided identity value and an
   * associative
   * accumulation function, and returns the reduced value.  This is equivalent
   * to:
   * {@code
   *     double result = identity;
   *     for (double element : this stream)
   *         result = accumulator.applyAsDouble(result, element)
   *     return result;
   * }
   *
   * but is not constrained to execute sequentially.
   *
   * The `identity` value must be an identity for the accumulator
   * function. This means that for all `x`,
   * `accumulator.apply(identity, x)` is equal to `x`.
   * The `accumulator` function must be an
   * associative function.
   *
   * This is a terminal
   * operation.
   *
   * @apiNote Sum, min, max, and average are all special cases of reduction.
   * Summing a stream of numbers can be expressed as:
   *
   * {@code
   *     double sum = numbers.reduce(0, (a, b) -> a+b);
   * }
   *
   * or more compactly:
   *
   * {@code
   *     double sum = numbers.reduce(0, Double::sum);
   * }
   *
   * While this may seem a more roundabout way to perform an aggregation
   * compared to simply mutating a running total in a loop, reduction
   * operations parallelize more gracefully, without needing additional
   * synchronization and with greatly reduced risk of data races.
   *
   * @param identity the identity value for the accumulating function
   * @param op an associative,
   *           non-interfering,
   *           stateless
   *           function for combining two values
   * @return the result of the reduction
   * @see #sum()
   * @see #min()
   * @see #max()
   * @see #average()
  */
  reduce(identity: number, op: DoubleBinaryOperator): number;
  /**
   * Performs a reduction on the
   * elements of this stream, using an
   * associative accumulation
   * function, and returns an `OptionalDouble` describing the reduced
   * value, if any. This is equivalent to:
   * {@code
   *     boolean foundAny = false;
   *     double result = null;
   *     for (double element : this stream) {
   *         if (!foundAny) {
   *             foundAny = true;
   *             result = element;
   *         }
   *         else
   *             result = accumulator.applyAsDouble(result, element);
   *     }
   *     return foundAny ? OptionalDouble.of(result) : OptionalDouble.empty();
   * }
   *
   * but is not constrained to execute sequentially.
   *
   * The `accumulator` function must be an
   * associative function.
   *
   * This is a terminal
   * operation.
   *
   * @param op an associative,
   *           non-interfering,
   *           stateless
   *           function for combining two values
   * @return the result of the reduction
   * @see #reduce(double, DoubleBinaryOperator)
  */
  reduce(op: DoubleBinaryOperator): OptionalDouble;
  /**
   * Performs a mutable
   * reduction operation on the elements of this stream.  A mutable
   * reduction is one in which the reduced value is a mutable result container,
   * such as an `ArrayList`, and elements are incorporated by updating
   * the state of the result rather than by replacing the result.  This
   * produces a result equivalent to:
   * {@code
   *     R result = supplier.get();
   *     for (double element : this stream)
   *         accumulator.accept(result, element);
   *     return result;
   * }
   *
   * Like {@link #reduce(double, DoubleBinaryOperator)}, `collect`
   * operations can be parallelized without requiring additional
   * synchronization.
   *
   * This is a terminal
   * operation.
   *
   * @param  the type of the mutable result container
   * @param supplier a function that creates a new mutable result container.
   *                 For a parallel execution, this function may be called
   *                 multiple times and must return a fresh value each time.
   * @param accumulator an associative,
   *                    non-interfering,
   *                    stateless
   *                    function that must fold an element into a result
   *                    container.
   * @param combiner an associative,
   *                    non-interfering,
   *                    stateless
   *                    function that accepts two partial result containers
   *                    and merges them, which must be compatible with the
   *                    accumulator function.  The combiner function must fold
   *                    the elements from the second result container into the
   *                    first result container.
   * @return the result of the reduction
   * @see Stream#collect(Supplier, BiConsumer, BiConsumer)
  */
  collect<R>(supplier: Supplier<R>, accumulator: ObjDoubleConsumer<R>, combiner: BiConsumer<R, R>): R;
  /**
   * Returns the sum of elements in this stream.
   *
   * Summation is a special case of a reduction. If
   * floating-point summation were exact, this method would be
   * equivalent to:
   *
   * {@code
   *     return reduce(0, Double::sum);
   * }
   *
   * However, since floating-point summation is not exact, the above
   * code is not necessarily equivalent to the summation computation
   * done by this method.
   *
   * The value of a floating-point sum is a function both
   * of the input values as well as the order of addition
   * operations. The order of addition operations of this method is
   * intentionally not defined to allow for implementation
   * flexibility to improve the speed and accuracy of the computed
   * result.
   *
   * In particular, this method may be implemented using compensated
   * summation or other technique to reduce the error bound in the
   * numerical sum compared to a simple summation of `double`
   * values.
   *
   * Because of the unspecified order of operations and the
   * possibility of using differing summation schemes, the output of
   * this method may vary on the same input elements.
   *
   * Various conditions can result in a non-finite sum being
   * computed. This can occur even if the all the elements
   * being summed are finite. If any element is non-finite,
   * the sum will be non-finite:
   *
   * 
   *
   * If any element is a NaN, then the final sum will be
   * NaN.
   *
   * If the elements contain one or more infinities, the
   * sum will be infinite or NaN.
   *
   * 
   *
   * If the elements contain infinities of opposite sign,
   * the sum will be NaN.
   *
   * If the elements contain infinities of one sign and
   * an intermediate sum overflows to an infinity of the opposite
   * sign, the sum may be NaN.
   *
   * 
   *
   * 
   *
   * It is possible for intermediate sums of finite values to
   * overflow into opposite-signed infinities; if that occurs, the
   * final sum will be NaN even if the elements are all
   * finite.
   *
   * If all the elements are zero, the sign of zero is
   * not guaranteed to be preserved in the final sum.
   *
   * This is a terminal
   * operation.
   *
   * @apiNote Elements sorted by increasing absolute magnitude tend
   * to yield more accurate results.
   *
   * @return the sum of elements in this stream
  */
  sum(): number;
  /**
   * Returns an `OptionalDouble` describing the minimum element of this
   * stream, or an empty OptionalDouble if this stream is empty.  The minimum
   * element will be `Double.NaN` if any stream element was NaN. Unlike
   * the numerical comparison operators, this method considers negative zero
   * to be strictly smaller than positive zero. This is a special case of a
   * reduction and is
   * equivalent to:
   * {@code
   *     return reduce(Double::min);
   * }
   *
   * This is a terminal
   * operation.
   *
   * @return an `OptionalDouble` containing the minimum element of this
   * stream, or an empty optional if the stream is empty
  */
  min(): OptionalDouble;
  /**
   * Returns an `OptionalDouble` describing the maximum element of this
   * stream, or an empty OptionalDouble if this stream is empty.  The maximum
   * element will be `Double.NaN` if any stream element was NaN. Unlike
   * the numerical comparison operators, this method considers negative zero
   * to be strictly smaller than positive zero. This is a
   * special case of a
   * reduction and is
   * equivalent to:
   * {@code
   *     return reduce(Double::max);
   * }
   *
   * This is a terminal
   * operation.
   *
   * @return an `OptionalDouble` containing the maximum element of this
   * stream, or an empty optional if the stream is empty
  */
  max(): OptionalDouble;
  /**
   * Returns the count of elements in this stream.  This is a special case of
   * a reduction and is
   * equivalent to:
   * {@code
   *     return mapToLong(e -> 1L).sum();
   * }
   *
   * This is a terminal operation.
   *
   * @apiNote
   * An implementation may choose to not execute the stream pipeline (either
   * sequentially or in parallel) if it is capable of computing the count
   * directly from the stream source.  In such cases no source elements will
   * be traversed and no intermediate operations will be evaluated.
   * Behavioral parameters with side-effects, which are strongly discouraged
   * except for harmless cases such as debugging, may be affected.  For
   * example, consider the following stream:
   * {@code
   *     DoubleStream s = DoubleStream.of(1, 2, 3, 4);
   *     long count = s.peek(System.out::println).count();
   * }
   * The number of elements covered by the stream source is known and the
   * intermediate operation, `peek`, does not inject into or remove
   * elements from the stream (as may be the case for `flatMap` or
   * `filter` operations).  Thus the count is 4 and there is no need to
   * execute the pipeline and, as a side-effect, print out the elements.
   *
   * @return the count of elements in this stream
  */
  count(): number;
  /**
   * Returns an `OptionalDouble` describing the arithmetic
   * mean of elements of this stream, or an empty optional if this
   * stream is empty.
   *
   * The computed average can vary numerically and have the
   * special case behavior as computing the sum; see {@link #sum}
   * for details.
   *
   *  The average is a special case of a reduction.
   *
   * This is a terminal
   * operation.
   *
   * @apiNote Elements sorted by increasing absolute magnitude tend
   * to yield more accurate results.
   *
   * @return an `OptionalDouble` containing the average element of this
   * stream, or an empty optional if the stream is empty
  */
  average(): OptionalDouble;
  /**
   * Returns a `DoubleSummaryStatistics` describing various summary data
   * about the elements of this stream.  This is a special
   * case of a reduction.
   *
   * This is a terminal
   * operation.
   *
   * @return a `DoubleSummaryStatistics` describing various summary data
   * about the elements of this stream
  */
  summaryStatistics(): DoubleSummaryStatistics;
  /**
   * Returns whether any elements of this stream match the provided
   * predicate.  May not evaluate the predicate on all elements if not
   * necessary for determining the result.  If the stream is empty then
   * `false` is returned and the predicate is not evaluated.
   *
   * This is a short-circuiting
   * terminal operation.
   *
   * @apiNote
   * This method evaluates the existential quantification of the
   * predicate over the elements of the stream (for some x P(x)).
   *
   * @param predicate a non-interfering,
   *                  stateless
   *                  predicate to apply to elements of this stream
   * @return `true` if any elements of the stream match the provided
   * predicate, otherwise `false`
  */
  anyMatch(predicate: DoublePredicate): boolean;
  /**
   * Returns whether all elements of this stream match the provided predicate.
   * May not evaluate the predicate on all elements if not necessary for
   * determining the result.  If the stream is empty then `true` is
   * returned and the predicate is not evaluated.
   *
   * This is a short-circuiting
   * terminal operation.
   *
   * @apiNote
   * This method evaluates the universal quantification of the
   * predicate over the elements of the stream (for all x P(x)).  If the
   * stream is empty, the quantification is said to be vacuously
   * satisfied and is always `true` (regardless of P(x)).
   *
   * @param predicate a non-interfering,
   *                  stateless
   *                  predicate to apply to elements of this stream
   * @return `true` if either all elements of the stream match the
   * provided predicate or the stream is empty, otherwise `false`
  */
  allMatch(predicate: DoublePredicate): boolean;
  /**
   * Returns whether no elements of this stream match the provided predicate.
   * May not evaluate the predicate on all elements if not necessary for
   * determining the result.  If the stream is empty then `true` is
   * returned and the predicate is not evaluated.
   *
   * This is a short-circuiting
   * terminal operation.
   *
   * @apiNote
   * This method evaluates the universal quantification of the
   * negated predicate over the elements of the stream (for all x ~P(x)).  If
   * the stream is empty, the quantification is said to be vacuously satisfied
   * and is always `true`, regardless of P(x).
   *
   * @param predicate a non-interfering,
   *                  stateless
   *                  predicate to apply to elements of this stream
   * @return `true` if either no elements of the stream match the
   * provided predicate or the stream is empty, otherwise `false`
  */
  noneMatch(predicate: DoublePredicate): boolean;
  /**
   * Returns an {@link OptionalDouble} describing the first element of this
   * stream, or an empty `OptionalDouble` if the stream is empty.  If
   * the stream has no encounter order, then any element may be returned.
   *
   * This is a short-circuiting
   * terminal operation.
   *
   * @return an `OptionalDouble` describing the first element of this
   * stream, or an empty `OptionalDouble` if the stream is empty
  */
  findFirst(): OptionalDouble;
  /**
   * Returns an {@link OptionalDouble} describing some element of the stream,
   * or an empty `OptionalDouble` if the stream is empty.
   *
   * This is a short-circuiting
   * terminal operation.
   *
   * The behavior of this operation is explicitly nondeterministic; it is
   * free to select any element in the stream.  This is to allow for maximal
   * performance in parallel operations; the cost is that multiple invocations
   * on the same source may not return the same result.  (If a stable result
   * is desired, use {@link #findFirst()} instead.)
   *
   * @return an `OptionalDouble` describing some element of this stream,
   * or an empty `OptionalDouble` if the stream is empty
   * @see #findFirst()
  */
  findAny(): OptionalDouble;
  /**
   * Returns a `Stream` consisting of the elements of this stream,
   * boxed to `Double`.
   *
   * This is an intermediate
   * operation.
   *
   * @return a `Stream` consistent of the elements of this stream,
   * each boxed to a `Double`
  */
  boxed(): Stream<number>;
  sequential(): DoubleStream;
  parallel(): DoubleStream;
  iterator(): OfDouble;
  spliterator(): java_util_Spliterator_OfDouble;
  /**
   * Returns a builder for a `DoubleStream`.
   *
   * @return a stream builder
  */
  static builder(): Builder;
  /**
   * Returns an empty sequential `DoubleStream`.
   *
   * @return an empty sequential stream
  */
  static empty(): DoubleStream;
  /**
   * Returns a sequential `DoubleStream` containing a single element.
   *
   * @param t the single element
   * @return a singleton sequential stream
  */
  static of(t: number): DoubleStream;
  /**
   * Returns a sequential ordered stream whose elements are the specified values.
   *
   * @param values the elements of the new stream
   * @return the new stream
  */
  static of(...values: number[]): DoubleStream;
  /**
   * Returns an infinite sequential ordered `DoubleStream` produced by iterative
   * application of a function `f` to an initial element `seed`,
   * producing a `Stream` consisting of `seed`, `f(seed)`,
   * `f(f(seed))`, etc.
   *
   * The first element (position `0`) in the `DoubleStream`
   * will be the provided `seed`.  For `n > 0`, the element at
   * position `n`, will be the result of applying the function `f`
   *  to the element at position `n - 1`.
   *
   * The action of applying `f` for one element
   * happens-before
   * the action of applying `f` for subsequent elements.  For any given
   * element the action may be performed in whatever thread the library
   * chooses.
   *
   * @param seed the initial element
   * @param f a function to be applied to the previous element to produce
   *          a new element
   * @return a new sequential `DoubleStream`
  */
  static iterate(seed: number, f: DoubleUnaryOperator): DoubleStream;
  /**
   * Returns a sequential ordered `DoubleStream` produced by iterative
   * application of the given `next` function to an initial element,
   * conditioned on satisfying the given `hasNext` predicate.  The
   * stream terminates as soon as the `hasNext` predicate returns false.
   *
   * `DoubleStream.iterate` should produce the same sequence of elements as
   * produced by the corresponding for-loop:
   * {@code
   *     for (double index=seed; hasNext.test(index); index = next.applyAsDouble(index)) {
   *         ...
   *     }
   * }
   *
   * The resulting sequence may be empty if the `hasNext` predicate
   * does not hold on the seed value.  Otherwise the first element will be the
   * supplied `seed` value, the next element (if present) will be the
   * result of applying the `next` function to the `seed` value,
   * and so on iteratively until the `hasNext` predicate indicates that
   * the stream should terminate.
   *
   * The action of applying the `hasNext` predicate to an element
   * happens-before
   * the action of applying the `next` function to that element.  The
   * action of applying the `next` function for one element
   * happens-before the action of applying the `hasNext`
   * predicate for subsequent elements.  For any given element an action may
   * be performed in whatever thread the library chooses.
   *
   * @param seed the initial element
   * @param hasNext a predicate to apply to elements to determine when the
   *                stream must terminate.
   * @param next a function to be applied to the previous element to produce
   *             a new element
   * @return a new sequential `DoubleStream`
   * @since 9
  */
  static iterate(seed: number, hasNext: DoublePredicate, next: DoubleUnaryOperator): DoubleStream;
  /**
   * Returns an infinite sequential unordered stream where each element is
   * generated by the provided `DoubleSupplier`.  This is suitable for
   * generating constant streams, streams of random elements, etc.
   *
   * @param s the `DoubleSupplier` for generated elements
   * @return a new infinite sequential unordered `DoubleStream`
  */
  static generate(s: DoubleSupplier): DoubleStream;
  /**
   * Creates a lazily concatenated stream whose elements are all the
   * elements of the first stream followed by all the elements of the
   * second stream.  The resulting stream is ordered if both
   * of the input streams are ordered, and parallel if either of the input
   * streams is parallel.  When the resulting stream is closed, the close
   * handlers for both input streams are invoked.
   *
   * This method operates on the two input streams and binds each stream
   * to its source.  As a result subsequent modifications to an input stream
   * source may not be reflected in the concatenated stream result.
   *
   * @implNote
   * Use caution when constructing streams from repeated concatenation.
   * Accessing an element of a deeply concatenated stream can result in deep
   * call chains, or even `StackOverflowError`.
   *
   * @apiNote
   * To preserve optimization opportunities this method binds each stream to
   * its source and accepts only two streams as parameters.  For example, the
   * exact size of the concatenated stream source can be computed if the exact
   * size of each input stream source is known.
   * To concatenate more streams without binding, or without nested calls to
   * this method, try creating a stream of streams and flat-mapping with the
   * identity function, for example:
   * {@code
   *     DoubleStream concat = Stream.of(s1, s2, s3, s4).flatMapToDouble(s -> s);
   * }
   *
   * @param a the first stream
   * @param b the second stream
   * @return the concatenation of the two input streams
  */
  static concat(a: DoubleStream, b: DoubleStream): DoubleStream;
}
/**
 * A sequence of primitive int-valued elements supporting sequential and parallel
 * aggregate operations.  This is the `int` primitive specialization of
 * {@link Stream}.
 *
 * The following example illustrates an aggregate operation using
 * {@link Stream} and {@link IntStream}, computing the sum of the weights of the
 * red widgets:
 *
 * {@code
 *     int sum = widgets.stream()
 *                      .filter(w -> w.getColor() == RED)
 *                      .mapToInt(w -> w.getWeight())
 *                      .sum();
 * }
 *
 * See the class documentation for {@link Stream} and the package documentation
 * for java.util.stream for additional
 * specification of streams, stream operations, stream pipelines, and
 * parallelism.
 *
 * @since 1.8
 * @see Stream
 * @see java.util.stream
*/
export class IntStream extends BaseStream<number, IntStream> {
  /**
   * Returns a stream consisting of the elements of this stream that match
   * the given predicate.
   *
   * This is an intermediate
   * operation.
   *
   * @param predicate a non-interfering,
   *                  stateless
   *                  predicate to apply to each element to determine if it
   *                  should be included
   * @return the new stream
  */
  filter(predicate: IntPredicate): IntStream;
  /**
   * Returns a stream consisting of the results of applying the given
   * function to the elements of this stream.
   *
   * This is an intermediate
   * operation.
   *
   * @param mapper a non-interfering,
   *               stateless
   *               function to apply to each element
   * @return the new stream
  */
  map(mapper: IntUnaryOperator): IntStream;
  /**
   * Returns an object-valued `Stream` consisting of the results of
   * applying the given function to the elements of this stream.
   *
   * This is an 
   *     intermediate operation.
   *
   * @param  the element type of the new stream
   * @param mapper a non-interfering,
   *               stateless
   *               function to apply to each element
   * @return the new stream
  */
  mapToObj<U>(mapper: IntFunction<U>): Stream<U>;
  /**
   * Returns a `LongStream` consisting of the results of applying the
   * given function to the elements of this stream.
   *
   * This is an intermediate
   * operation.
   *
   * @param mapper a non-interfering,
   *               stateless
   *               function to apply to each element
   * @return the new stream
  */
  mapToLong(mapper: IntToLongFunction): LongStream;
  /**
   * Returns a `DoubleStream` consisting of the results of applying the
   * given function to the elements of this stream.
   *
   * This is an intermediate
   * operation.
   *
   * @param mapper a non-interfering,
   *               stateless
   *               function to apply to each element
   * @return the new stream
  */
  mapToDouble(mapper: IntToDoubleFunction): DoubleStream;
  /**
   * Returns a stream consisting of the results of replacing each element of
   * this stream with the contents of a mapped stream produced by applying
   * the provided mapping function to each element.  Each mapped stream is
   * {@link java.util.stream.BaseStream#close() closed} after its contents
   * have been placed into this stream.  (If a mapped stream is `null`
   * an empty stream is used, instead.)
   *
   * This is an intermediate
   * operation.
   *
   * @param mapper a non-interfering,
   *               stateless
   *               function to apply to each element which produces an
   *               `IntStream` of new values
   * @return the new stream
   * @see Stream#flatMap(Function)
  */
  flatMap(mapper: IntFunction<IntStream>): IntStream;
  /**
   * Returns a stream consisting of the results of replacing each element of
   * this stream with multiple elements, specifically zero or more elements.
   * Replacement is performed by applying the provided mapping function to each
   * element in conjunction with a {@linkplain IntConsumer consumer} argument
   * that accepts replacement elements. The mapping function calls the consumer
   * zero or more times to provide the replacement elements.
   *
   * This is an intermediate
   * operation.
   *
   * If the {@linkplain IntConsumer consumer} argument is used outside the scope of
   * its application to the mapping function, the results are undefined.
   *
   * @implSpec
   * The default implementation invokes {@link #flatMap flatMap} on this stream,
   * passing a function that behaves as follows. First, it calls the mapper function
   * with an `IntConsumer` that accumulates replacement elements into a newly created
   * internal buffer. When the mapper function returns, it creates an `IntStream` from the
   * internal buffer. Finally, it returns this stream to `flatMap`.
   *
   * @param mapper a non-interfering,
   *               stateless
   *               function that generates replacement elements
   * @return the new stream
   * @see Stream#mapMulti Stream.mapMulti
   * @since 16
  */
  mapMulti(mapper: IntMapMultiConsumer): IntStream;
  /**
   * Returns a stream consisting of the distinct elements of this stream.
   *
   * This is a stateful
   * intermediate operation.
   *
   * @return the new stream
  */
  distinct(): IntStream;
  /**
   * Returns a stream consisting of the elements of this stream in sorted
   * order.
   *
   * This is a stateful
   * intermediate operation.
   *
   * @return the new stream
  */
  sorted(): IntStream;
  /**
   * Returns a stream consisting of the elements of this stream, additionally
   * performing the provided action on each element as elements are consumed
   * from the resulting stream.
   *
   * This is an intermediate
   * operation.
   *
   * For parallel stream pipelines, the action may be called at
   * whatever time and in whatever thread the element is made available by the
   * upstream operation.  If the action modifies shared state,
   * it is responsible for providing the required synchronization.
   *
   * @apiNote This method exists mainly to support debugging, where you want
   * to see the elements as they flow past a certain point in a pipeline:
   * {@code
   *     IntStream.of(1, 2, 3, 4)
   *         .filter(e -> e > 2)
   *         .peek(e -> System.out.println("Filtered value: " + e))
   *         .map(e -> e * e)
   *         .peek(e -> System.out.println("Mapped value: " + e))
   *         .sum();
   * }
   *
   * In cases where the stream implementation is able to optimize away the
   * production of some or all the elements (such as with short-circuiting
   * operations like `findFirst`, or in the example described in
   * {@link #count}), the action will not be invoked for those elements.
   *
   * @param action a 
   *               non-interfering action to perform on the elements as
   *               they are consumed from the stream
   * @return the new stream
  */
  peek(action: IntConsumer): IntStream;
  /**
   * Returns a stream consisting of the elements of this stream, truncated
   * to be no longer than `maxSize` in length.
   *
   * This is a short-circuiting
   * stateful intermediate operation.
   *
   * @apiNote
   * While `limit()` is generally a cheap operation on sequential
   * stream pipelines, it can be quite expensive on ordered parallel pipelines,
   * especially for large values of `maxSize`, since `limit(n)`
   * is constrained to return not just any n elements, but the
   * first n elements in the encounter order.  Using an unordered
   * stream source (such as {@link #generate(IntSupplier)}) or removing the
   * ordering constraint with {@link #unordered()} may result in significant
   * speedups of `limit()` in parallel pipelines, if the semantics of
   * your situation permit.  If consistency with encounter order is required,
   * and you are experiencing poor performance or memory utilization with
   * `limit()` in parallel pipelines, switching to sequential execution
   * with {@link #sequential()} may improve performance.
   *
   * @param maxSize the number of elements the stream should be limited to
   * @return the new stream
   * @throws IllegalArgumentException if `maxSize` is negative
  */
  limit(maxSize: number): IntStream;
  /**
   * Returns a stream consisting of the remaining elements of this stream
   * after discarding the first `n` elements of the stream.
   * If this stream contains fewer than `n` elements then an
   * empty stream will be returned.
   *
   * This is a stateful
   * intermediate operation.
   *
   * @apiNote
   * While `skip()` is generally a cheap operation on sequential
   * stream pipelines, it can be quite expensive on ordered parallel pipelines,
   * especially for large values of `n`, since `skip(n)`
   * is constrained to skip not just any n elements, but the
   * first n elements in the encounter order.  Using an unordered
   * stream source (such as {@link #generate(IntSupplier)}) or removing the
   * ordering constraint with {@link #unordered()} may result in significant
   * speedups of `skip()` in parallel pipelines, if the semantics of
   * your situation permit.  If consistency with encounter order is required,
   * and you are experiencing poor performance or memory utilization with
   * `skip()` in parallel pipelines, switching to sequential execution
   * with {@link #sequential()} may improve performance.
   *
   * @param n the number of leading elements to skip
   * @return the new stream
   * @throws IllegalArgumentException if `n` is negative
  */
  skip(n: number): IntStream;
  /**
   * Returns, if this stream is ordered, a stream consisting of the longest
   * prefix of elements taken from this stream that match the given predicate.
   * Otherwise returns, if this stream is unordered, a stream consisting of a
   * subset of elements taken from this stream that match the given predicate.
   *
   * If this stream is ordered then the longest prefix is a contiguous
   * sequence of elements of this stream that match the given predicate.  The
   * first element of the sequence is the first element of this stream, and
   * the element immediately following the last element of the sequence does
   * not match the given predicate.
   *
   * If this stream is unordered, and some (but not all) elements of this
   * stream match the given predicate, then the behavior of this operation is
   * nondeterministic; it is free to take any subset of matching elements
   * (which includes the empty set).
   *
   * Independent of whether this stream is ordered or unordered if all
   * elements of this stream match the given predicate then this operation
   * takes all elements (the result is the same as the input), or if no
   * elements of the stream match the given predicate then no elements are
   * taken (the result is an empty stream).
   *
   * This is a short-circuiting
   * stateful intermediate operation.
   *
   * @implSpec
   * The default implementation obtains the {@link #spliterator() spliterator}
   * of this stream, wraps that spliterator so as to support the semantics
   * of this operation on traversal, and returns a new stream associated with
   * the wrapped spliterator.  The returned stream preserves the execution
   * characteristics of this stream (namely parallel or sequential execution
   * as per {@link #isParallel()}) but the wrapped spliterator may choose to
   * not support splitting.  When the returned stream is closed, the close
   * handlers for both the returned and this stream are invoked.
   *
   * @apiNote
   * While `takeWhile()` is generally a cheap operation on sequential
   * stream pipelines, it can be quite expensive on ordered parallel
   * pipelines, since the operation is constrained to return not just any
   * valid prefix, but the longest prefix of elements in the encounter order.
   * Using an unordered stream source (such as {@link #generate(IntSupplier)})
   * or removing the ordering constraint with {@link #unordered()} may result
   * in significant speedups of `takeWhile()` in parallel pipelines, if
   * the semantics of your situation permit.  If consistency with encounter
   * order is required, and you are experiencing poor performance or memory
   * utilization with `takeWhile()` in parallel pipelines, switching to
   * sequential execution with {@link #sequential()} may improve performance.
   *
   * @param predicate a non-interfering,
   *                  stateless
   *                  predicate to apply to elements to determine the longest
   *                  prefix of elements.
   * @return the new stream
   * @since 9
  */
  takeWhile(predicate: IntPredicate): IntStream;
  /**
   * Returns, if this stream is ordered, a stream consisting of the remaining
   * elements of this stream after dropping the longest prefix of elements
   * that match the given predicate.  Otherwise returns, if this stream is
   * unordered, a stream consisting of the remaining elements of this stream
   * after dropping a subset of elements that match the given predicate.
   *
   * If this stream is ordered then the longest prefix is a contiguous
   * sequence of elements of this stream that match the given predicate.  The
   * first element of the sequence is the first element of this stream, and
   * the element immediately following the last element of the sequence does
   * not match the given predicate.
   *
   * If this stream is unordered, and some (but not all) elements of this
   * stream match the given predicate, then the behavior of this operation is
   * nondeterministic; it is free to drop any subset of matching elements
   * (which includes the empty set).
   *
   * Independent of whether this stream is ordered or unordered if all
   * elements of this stream match the given predicate then this operation
   * drops all elements (the result is an empty stream), or if no elements of
   * the stream match the given predicate then no elements are dropped (the
   * result is the same as the input).
   *
   * This is a stateful
   * intermediate operation.
   *
   * @implSpec
   * The default implementation obtains the {@link #spliterator() spliterator}
   * of this stream, wraps that spliterator so as to support the semantics
   * of this operation on traversal, and returns a new stream associated with
   * the wrapped spliterator.  The returned stream preserves the execution
   * characteristics of this stream (namely parallel or sequential execution
   * as per {@link #isParallel()}) but the wrapped spliterator may choose to
   * not support splitting.  When the returned stream is closed, the close
   * handlers for both the returned and this stream are invoked.
   *
   * @apiNote
   * While `dropWhile()` is generally a cheap operation on sequential
   * stream pipelines, it can be quite expensive on ordered parallel
   * pipelines, since the operation is constrained to return not just any
   * valid prefix, but the longest prefix of elements in the encounter order.
   * Using an unordered stream source (such as {@link #generate(IntSupplier)})
   * or removing the ordering constraint with {@link #unordered()} may result
   * in significant speedups of `dropWhile()` in parallel pipelines, if
   * the semantics of your situation permit.  If consistency with encounter
   * order is required, and you are experiencing poor performance or memory
   * utilization with `dropWhile()` in parallel pipelines, switching to
   * sequential execution with {@link #sequential()} may improve performance.
   *
   * @param predicate a non-interfering,
   *                  stateless
   *                  predicate to apply to elements to determine the longest
   *                  prefix of elements.
   * @return the new stream
   * @since 9
  */
  dropWhile(predicate: IntPredicate): IntStream;
  /**
   * Performs an action for each element of this stream.
   *
   * This is a terminal
   * operation.
   *
   * For parallel stream pipelines, this operation does not
   * guarantee to respect the encounter order of the stream, as doing so
   * would sacrifice the benefit of parallelism.  For any given element, the
   * action may be performed at whatever time and in whatever thread the
   * library chooses.  If the action accesses shared state, it is
   * responsible for providing the required synchronization.
   *
   * @param action a 
   *               non-interfering action to perform on the elements
  */
  forEach(action: IntConsumer): void;
  /**
   * Performs an action for each element of this stream, guaranteeing that
   * each element is processed in encounter order for streams that have a
   * defined encounter order.
   *
   * This is a terminal
   * operation.
   *
   * @param action a 
   *               non-interfering action to perform on the elements
   * @see #forEach(IntConsumer)
  */
  forEachOrdered(action: IntConsumer): void;
  /**
   * Returns an array containing the elements of this stream.
   *
   * This is a terminal
   * operation.
   *
   * @return an array containing the elements of this stream
  */
  toArray(): number[];
  /**
   * Performs a reduction on the
   * elements of this stream, using the provided identity value and an
   * associative
   * accumulation function, and returns the reduced value.  This is equivalent
   * to:
   * {@code
   *     int result = identity;
   *     for (int element : this stream)
   *         result = accumulator.applyAsInt(result, element)
   *     return result;
   * }
   *
   * but is not constrained to execute sequentially.
   *
   * The `identity` value must be an identity for the accumulator
   * function. This means that for all `x`,
   * `accumulator.apply(identity, x)` is equal to `x`.
   * The `accumulator` function must be an
   * associative function.
   *
   * This is a terminal
   * operation.
   *
   * @apiNote Sum, min and max are all special cases of reduction that can be
   * expressed using this method.
   * For example, summing a stream can be expressed as:
   *
   * {@code
   *     int sum = integers.reduce(0, (a, b) -> a+b);
   * }
   *
   * or more compactly:
   *
   * {@code
   *     int sum = integers.reduce(0, Integer::sum);
   * }
   *
   * While this may seem a more roundabout way to perform an aggregation
   * compared to simply mutating a running total in a loop, reduction
   * operations parallelize more gracefully, without needing additional
   * synchronization and with greatly reduced risk of data races.
   *
   * @param identity the identity value for the accumulating function
   * @param op an associative,
   *           non-interfering,
   *           stateless
   *           function for combining two values
   * @return the result of the reduction
   * @see #sum()
   * @see #min()
   * @see #max()
   * @see #average()
  */
  reduce(identity: number, op: IntBinaryOperator): number;
  /**
   * Performs a reduction on the
   * elements of this stream, using an
   * associative accumulation
   * function, and returns an `OptionalInt` describing the reduced value,
   * if any. This is equivalent to:
   * {@code
   *     boolean foundAny = false;
   *     int result = null;
   *     for (int element : this stream) {
   *         if (!foundAny) {
   *             foundAny = true;
   *             result = element;
   *         }
   *         else
   *             result = accumulator.applyAsInt(result, element);
   *     }
   *     return foundAny ? OptionalInt.of(result) : OptionalInt.empty();
   * }
   *
   * but is not constrained to execute sequentially.
   *
   * The `accumulator` function must be an
   * associative function.
   *
   * This is a terminal
   * operation.
   *
   * @param op an associative,
   *           non-interfering,
   *           stateless
   *           function for combining two values
   * @return the result of the reduction
   * @see #reduce(int, IntBinaryOperator)
  */
  reduce(op: IntBinaryOperator): OptionalInt;
  /**
   * Performs a mutable
   * reduction operation on the elements of this stream.  A mutable
   * reduction is one in which the reduced value is a mutable result container,
   * such as an `ArrayList`, and elements are incorporated by updating
   * the state of the result rather than by replacing the result.  This
   * produces a result equivalent to:
   * {@code
   *     R result = supplier.get();
   *     for (int element : this stream)
   *         accumulator.accept(result, element);
   *     return result;
   * }
   *
   * Like {@link #reduce(int, IntBinaryOperator)}, `collect` operations
   * can be parallelized without requiring additional synchronization.
   *
   * This is a terminal
   * operation.
   *
   * @param  the type of the mutable result container
   * @param supplier a function that creates a new mutable result container.
   *                 For a parallel execution, this function may be called
   *                 multiple times and must return a fresh value each time.
   * @param accumulator an associative,
   *                    non-interfering,
   *                    stateless
   *                    function that must fold an element into a result
   *                    container.
   * @param combiner an associative,
   *                    non-interfering,
   *                    stateless
   *                    function that accepts two partial result containers
   *                    and merges them, which must be compatible with the
   *                    accumulator function.  The combiner function must fold
   *                    the elements from the second result container into the
   *                    first result container.
   * @return the result of the reduction
   * @see Stream#collect(Supplier, BiConsumer, BiConsumer)
  */
  collect<R>(supplier: Supplier<R>, accumulator: ObjIntConsumer<R>, combiner: BiConsumer<R, R>): R;
  /**
   * Returns the sum of elements in this stream.  This is a special case
   * of a reduction
   * and is equivalent to:
   * {@code
   *     return reduce(0, Integer::sum);
   * }
   *
   * This is a terminal
   * operation.
   *
   * @return the sum of elements in this stream
  */
  sum(): number;
  /**
   * Returns an `OptionalInt` describing the minimum element of this
   * stream, or an empty optional if this stream is empty.  This is a special
   * case of a reduction
   * and is equivalent to:
   * {@code
   *     return reduce(Integer::min);
   * }
   *
   * This is a terminal operation.
   *
   * @return an `OptionalInt` containing the minimum element of this
   * stream, or an empty `OptionalInt` if the stream is empty
  */
  min(): OptionalInt;
  /**
   * Returns an `OptionalInt` describing the maximum element of this
   * stream, or an empty optional if this stream is empty.  This is a special
   * case of a reduction
   * and is equivalent to:
   * {@code
   *     return reduce(Integer::max);
   * }
   *
   * This is a terminal
   * operation.
   *
   * @return an `OptionalInt` containing the maximum element of this
   * stream, or an empty `OptionalInt` if the stream is empty
  */
  max(): OptionalInt;
  /**
   * Returns the count of elements in this stream.  This is a special case of
   * a reduction and is
   * equivalent to:
   * {@code
   *     return mapToLong(e -> 1L).sum();
   * }
   *
   * This is a terminal operation.
   *
   * @apiNote
   * An implementation may choose to not execute the stream pipeline (either
   * sequentially or in parallel) if it is capable of computing the count
   * directly from the stream source.  In such cases no source elements will
   * be traversed and no intermediate operations will be evaluated.
   * Behavioral parameters with side-effects, which are strongly discouraged
   * except for harmless cases such as debugging, may be affected.  For
   * example, consider the following stream:
   * {@code
   *     IntStream s = IntStream.of(1, 2, 3, 4);
   *     long count = s.peek(System.out::println).count();
   * }
   * The number of elements covered by the stream source is known and the
   * intermediate operation, `peek`, does not inject into or remove
   * elements from the stream (as may be the case for `flatMap` or
   * `filter` operations).  Thus the count is 4 and there is no need to
   * execute the pipeline and, as a side-effect, print out the elements.
   *
   * @return the count of elements in this stream
  */
  count(): number;
  /**
   * Returns an `OptionalDouble` describing the arithmetic mean of elements of
   * this stream, or an empty optional if this stream is empty.  This is a
   * special case of a
   * reduction.
   *
   * This is a terminal
   * operation.
   *
   * @return an `OptionalDouble` containing the average element of this
   * stream, or an empty optional if the stream is empty
  */
  average(): OptionalDouble;
  /**
   * Returns an `IntSummaryStatistics` describing various
   * summary data about the elements of this stream.  This is a special
   * case of a reduction.
   *
   * This is a terminal
   * operation.
   *
   * @return an `IntSummaryStatistics` describing various summary data
   * about the elements of this stream
  */
  summaryStatistics(): IntSummaryStatistics;
  /**
   * Returns whether any elements of this stream match the provided
   * predicate.  May not evaluate the predicate on all elements if not
   * necessary for determining the result.  If the stream is empty then
   * `false` is returned and the predicate is not evaluated.
   *
   * This is a short-circuiting
   * terminal operation.
   *
   * @apiNote
   * This method evaluates the existential quantification of the
   * predicate over the elements of the stream (for some x P(x)).
   *
   * @param predicate a non-interfering,
   *                  stateless
   *                  predicate to apply to elements of this stream
   * @return `true` if any elements of the stream match the provided
   * predicate, otherwise `false`
  */
  anyMatch(predicate: IntPredicate): boolean;
  /**
   * Returns whether all elements of this stream match the provided predicate.
   * May not evaluate the predicate on all elements if not necessary for
   * determining the result.  If the stream is empty then `true` is
   * returned and the predicate is not evaluated.
   *
   * This is a short-circuiting
   * terminal operation.
   *
   * @apiNote
   * This method evaluates the universal quantification of the
   * predicate over the elements of the stream (for all x P(x)).  If the
   * stream is empty, the quantification is said to be vacuously
   * satisfied and is always `true` (regardless of P(x)).
   *
   * @param predicate a non-interfering,
   *                  stateless
   *                  predicate to apply to elements of this stream
   * @return `true` if either all elements of the stream match the
   * provided predicate or the stream is empty, otherwise `false`
  */
  allMatch(predicate: IntPredicate): boolean;
  /**
   * Returns whether no elements of this stream match the provided predicate.
   * May not evaluate the predicate on all elements if not necessary for
   * determining the result.  If the stream is empty then `true` is
   * returned and the predicate is not evaluated.
   *
   * This is a short-circuiting
   * terminal operation.
   *
   * @apiNote
   * This method evaluates the universal quantification of the
   * negated predicate over the elements of the stream (for all x ~P(x)).  If
   * the stream is empty, the quantification is said to be vacuously satisfied
   * and is always `true`, regardless of P(x).
   *
   * @param predicate a non-interfering,
   *                  stateless
   *                  predicate to apply to elements of this stream
   * @return `true` if either no elements of the stream match the
   * provided predicate or the stream is empty, otherwise `false`
  */
  noneMatch(predicate: IntPredicate): boolean;
  /**
   * Returns an {@link OptionalInt} describing the first element of this
   * stream, or an empty `OptionalInt` if the stream is empty.  If the
   * stream has no encounter order, then any element may be returned.
   *
   * This is a short-circuiting
   * terminal operation.
   *
   * @return an `OptionalInt` describing the first element of this stream,
   * or an empty `OptionalInt` if the stream is empty
  */
  findFirst(): OptionalInt;
  /**
   * Returns an {@link OptionalInt} describing some element of the stream, or
   * an empty `OptionalInt` if the stream is empty.
   *
   * This is a short-circuiting
   * terminal operation.
   *
   * The behavior of this operation is explicitly nondeterministic; it is
   * free to select any element in the stream.  This is to allow for maximal
   * performance in parallel operations; the cost is that multiple invocations
   * on the same source may not return the same result.  (If a stable result
   * is desired, use {@link #findFirst()} instead.)
   *
   * @return an `OptionalInt` describing some element of this stream, or
   * an empty `OptionalInt` if the stream is empty
   * @see #findFirst()
  */
  findAny(): OptionalInt;
  /**
   * Returns a `LongStream` consisting of the elements of this stream,
   * converted to `long`.
   *
   * This is an intermediate
   * operation.
   *
   * @return a `LongStream` consisting of the elements of this stream,
   * converted to `long`
  */
  asLongStream(): LongStream;
  /**
   * Returns a `DoubleStream` consisting of the elements of this stream,
   * converted to `double`.
   *
   * This is an intermediate
   * operation.
   *
   * @return a `DoubleStream` consisting of the elements of this stream,
   * converted to `double`
  */
  asDoubleStream(): DoubleStream;
  /**
   * Returns a `Stream` consisting of the elements of this stream,
   * each boxed to an `Integer`.
   *
   * This is an intermediate
   * operation.
   *
   * @return a `Stream` consistent of the elements of this stream,
   * each boxed to an `Integer`
  */
  boxed(): Stream<number>;
  sequential(): IntStream;
  parallel(): IntStream;
  iterator(): OfInt;
  spliterator(): java_util_Spliterator_OfInt;
  /**
   * Returns a builder for an `IntStream`.
   *
   * @return a stream builder
  */
  static builder(): java_util_stream_IntStream_Builder;
  /**
   * Returns an empty sequential `IntStream`.
   *
   * @return an empty sequential stream
  */
  static empty(): IntStream;
  /**
   * Returns a sequential `IntStream` containing a single element.
   *
   * @param t the single element
   * @return a singleton sequential stream
  */
  static of(t: number): IntStream;
  /**
   * Returns a sequential ordered stream whose elements are the specified values.
   *
   * @param values the elements of the new stream
   * @return the new stream
  */
  static of(...values: number[]): IntStream;
  /**
   * Returns an infinite sequential ordered `IntStream` produced by iterative
   * application of a function `f` to an initial element `seed`,
   * producing a `Stream` consisting of `seed`, `f(seed)`,
   * `f(f(seed))`, etc.
   *
   * The first element (position `0`) in the `IntStream` will be
   * the provided `seed`.  For `n > 0`, the element at position
   * `n`, will be the result of applying the function `f` to the
   * element at position `n - 1`.
   *
   * The action of applying `f` for one element
   * happens-before
   * the action of applying `f` for subsequent elements.  For any given
   * element the action may be performed in whatever thread the library
   * chooses.
   *
   * @param seed the initial element
   * @param f a function to be applied to the previous element to produce
   *          a new element
   * @return a new sequential `IntStream`
  */
  static iterate(seed: number, f: IntUnaryOperator): IntStream;
  /**
   * Returns a sequential ordered `IntStream` produced by iterative
   * application of the given `next` function to an initial element,
   * conditioned on satisfying the given `hasNext` predicate.  The
   * stream terminates as soon as the `hasNext` predicate returns false.
   *
   * `IntStream.iterate` should produce the same sequence of elements as
   * produced by the corresponding for-loop:
   * {@code
   *     for (int index=seed; hasNext.test(index); index = next.applyAsInt(index)) {
   *         ...
   *     }
   * }
   *
   * The resulting sequence may be empty if the `hasNext` predicate
   * does not hold on the seed value.  Otherwise the first element will be the
   * supplied `seed` value, the next element (if present) will be the
   * result of applying the `next` function to the `seed` value,
   * and so on iteratively until the `hasNext` predicate indicates that
   * the stream should terminate.
   *
   * The action of applying the `hasNext` predicate to an element
   * happens-before
   * the action of applying the `next` function to that element.  The
   * action of applying the `next` function for one element
   * happens-before the action of applying the `hasNext`
   * predicate for subsequent elements.  For any given element an action may
   * be performed in whatever thread the library chooses.
   *
   * @param seed the initial element
   * @param hasNext a predicate to apply to elements to determine when the
   *                stream must terminate.
   * @param next a function to be applied to the previous element to produce
   *             a new element
   * @return a new sequential `IntStream`
   * @since 9
  */
  static iterate(seed: number, hasNext: IntPredicate, next: IntUnaryOperator): IntStream;
  /**
   * Returns an infinite sequential unordered stream where each element is
   * generated by the provided `IntSupplier`.  This is suitable for
   * generating constant streams, streams of random elements, etc.
   *
   * @param s the `IntSupplier` for generated elements
   * @return a new infinite sequential unordered `IntStream`
  */
  static generate(s: IntSupplier): IntStream;
  /**
   * Returns a sequential ordered `IntStream` from `startInclusive`
   * (inclusive) to `endExclusive` (exclusive) by an incremental step of
   * `1`.
   *
   * @apiNote
   * An equivalent sequence of increasing values can be produced
   * sequentially using a `for` loop as follows:
   * `     *     for (int i = startInclusive; i < endExclusive ; i++) { ... `
   * }
   *
   * @param startInclusive the (inclusive) initial value
   * @param endExclusive the exclusive upper bound
   * @return a sequential `IntStream` for the range of `int`
   *         elements
  */
  static range(startInclusive: number, endExclusive: number): IntStream;
  /**
   * Returns a sequential ordered `IntStream` from `startInclusive`
   * (inclusive) to `endInclusive` (inclusive) by an incremental step of
   * `1`.
   *
   * @apiNote
   * An equivalent sequence of increasing values can be produced
   * sequentially using a `for` loop as follows:
   * `     *     for (int i = startInclusive; i <= endInclusive ; i++) { ... `
   * }
   *
   * @param startInclusive the (inclusive) initial value
   * @param endInclusive the inclusive upper bound
   * @return a sequential `IntStream` for the range of `int`
   *         elements
  */
  static rangeClosed(startInclusive: number, endInclusive: number): IntStream;
  /**
   * Creates a lazily concatenated stream whose elements are all the
   * elements of the first stream followed by all the elements of the
   * second stream.  The resulting stream is ordered if both
   * of the input streams are ordered, and parallel if either of the input
   * streams is parallel.  When the resulting stream is closed, the close
   * handlers for both input streams are invoked.
   *
   * This method operates on the two input streams and binds each stream
   * to its source.  As a result subsequent modifications to an input stream
   * source may not be reflected in the concatenated stream result.
   *
   * @implNote
   * Use caution when constructing streams from repeated concatenation.
   * Accessing an element of a deeply concatenated stream can result in deep
   * call chains, or even `StackOverflowError`.
   *
   * @apiNote
   * To preserve optimization opportunities this method binds each stream to
   * its source and accepts only two streams as parameters.  For example, the
   * exact size of the concatenated stream source can be computed if the exact
   * size of each input stream source is known.
   * To concatenate more streams without binding, or without nested calls to
   * this method, try creating a stream of streams and flat-mapping with the
   * identity function, for example:
   * {@code
   *     IntStream concat = Stream.of(s1, s2, s3, s4).flatMapToInt(s -> s);
   * }
   *
   * @param a the first stream
   * @param b the second stream
   * @return the concatenation of the two input streams
  */
  static concat(a: IntStream, b: IntStream): IntStream;
}
/**
 * A sequence of primitive long-valued elements supporting sequential and parallel
 * aggregate operations.  This is the `long` primitive specialization of
 * {@link Stream}.
 *
 * The following example illustrates an aggregate operation using
 * {@link Stream} and {@link LongStream}, computing the sum of the weights of the
 * red widgets:
 *
 * {@code
 *     long sum = widgets.stream()
 *                       .filter(w -> w.getColor() == RED)
 *                       .mapToLong(w -> w.getWeight())
 *                       .sum();
 * }
 *
 * See the class documentation for {@link Stream} and the package documentation
 * for java.util.stream for additional
 * specification of streams, stream operations, stream pipelines, and
 * parallelism.
 *
 * @since 1.8
 * @see Stream
 * @see java.util.stream
*/
export class LongStream extends BaseStream<number, LongStream> {
  /**
   * Returns a stream consisting of the elements of this stream that match
   * the given predicate.
   *
   * This is an intermediate
   * operation.
   *
   * @param predicate a non-interfering,
   *                  stateless
   *                  predicate to apply to each element to determine if it
   *                  should be included
   * @return the new stream
  */
  filter(predicate: LongPredicate): LongStream;
  /**
   * Returns a stream consisting of the results of applying the given
   * function to the elements of this stream.
   *
   * This is an intermediate
   * operation.
   *
   * @param mapper a non-interfering,
   *               stateless
   *               function to apply to each element
   * @return the new stream
  */
  map(mapper: LongUnaryOperator): LongStream;
  /**
   * Returns an object-valued `Stream` consisting of the results of
   * applying the given function to the elements of this stream.
   *
   * This is an 
   *     intermediate operation.
   *
   * @param  the element type of the new stream
   * @param mapper a non-interfering,
   *               stateless
   *               function to apply to each element
   * @return the new stream
  */
  mapToObj<U>(mapper: LongFunction<U>): Stream<U>;
  /**
   * Returns an `IntStream` consisting of the results of applying the
   * given function to the elements of this stream.
   *
   * This is an intermediate
   * operation.
   *
   * @param mapper a non-interfering,
   *               stateless
   *               function to apply to each element
   * @return the new stream
  */
  mapToInt(mapper: LongToIntFunction): IntStream;
  /**
   * Returns a `DoubleStream` consisting of the results of applying the
   * given function to the elements of this stream.
   *
   * This is an intermediate
   * operation.
   *
   * @param mapper a non-interfering,
   *               stateless
   *               function to apply to each element
   * @return the new stream
  */
  mapToDouble(mapper: LongToDoubleFunction): DoubleStream;
  /**
   * Returns a stream consisting of the results of replacing each element of
   * this stream with the contents of a mapped stream produced by applying
   * the provided mapping function to each element.  Each mapped stream is
   * {@link java.util.stream.BaseStream#close() closed} after its contents
   * have been placed into this stream.  (If a mapped stream is `null`
   * an empty stream is used, instead.)
   *
   * This is an intermediate
   * operation.
   *
   * @param mapper a non-interfering,
   *               stateless
   *               function to apply to each element which produces a
   *               `LongStream` of new values
   * @return the new stream
   * @see Stream#flatMap(Function)
  */
  flatMap(mapper: LongFunction<LongStream>): LongStream;
  /**
   * Returns a stream consisting of the results of replacing each element of
   * this stream with multiple elements, specifically zero or more elements.
   * Replacement is performed by applying the provided mapping function to each
   * element in conjunction with a {@linkplain LongConsumer consumer} argument
   * that accepts replacement elements. The mapping function calls the consumer
   * zero or more times to provide the replacement elements.
   *
   * This is an intermediate
   * operation.
   *
   * If the {@linkplain LongConsumer consumer} argument is used outside the scope of
   * its application to the mapping function, the results are undefined.
   *
   * @implSpec
   * The default implementation invokes {@link #flatMap flatMap} on this stream,
   * passing a function that behaves as follows. First, it calls the mapper function
   * with a `LongConsumer` that accumulates replacement elements into a newly created
   * internal buffer. When the mapper function returns, it creates a `LongStream` from the
   * internal buffer. Finally, it returns this stream to `flatMap`.
   *
   * @param mapper a non-interfering,
   *               stateless
   *               function that generates replacement elements
   * @return the new stream
   * @see Stream#mapMulti Stream.mapMulti
   * @since 16
  */
  mapMulti(mapper: LongMapMultiConsumer): LongStream;
  /**
   * Returns a stream consisting of the distinct elements of this stream.
   *
   * This is a stateful
   * intermediate operation.
   *
   * @return the new stream
  */
  distinct(): LongStream;
  /**
   * Returns a stream consisting of the elements of this stream in sorted
   * order.
   *
   * This is a stateful
   * intermediate operation.
   *
   * @return the new stream
  */
  sorted(): LongStream;
  /**
   * Returns a stream consisting of the elements of this stream, additionally
   * performing the provided action on each element as elements are consumed
   * from the resulting stream.
   *
   * This is an intermediate
   * operation.
   *
   * For parallel stream pipelines, the action may be called at
   * whatever time and in whatever thread the element is made available by the
   * upstream operation.  If the action modifies shared state,
   * it is responsible for providing the required synchronization.
   *
   * @apiNote This method exists mainly to support debugging, where you want
   * to see the elements as they flow past a certain point in a pipeline:
   * {@code
   *     LongStream.of(1, 2, 3, 4)
   *         .filter(e -> e > 2)
   *         .peek(e -> System.out.println("Filtered value: " + e))
   *         .map(e -> e * e)
   *         .peek(e -> System.out.println("Mapped value: " + e))
   *         .sum();
   * }
   *
   * In cases where the stream implementation is able to optimize away the
   * production of some or all the elements (such as with short-circuiting
   * operations like `findFirst`, or in the example described in
   * {@link #count}), the action will not be invoked for those elements.
   *
   * @param action a 
   *               non-interfering action to perform on the elements as
   *               they are consumed from the stream
   * @return the new stream
  */
  peek(action: LongConsumer): LongStream;
  /**
   * Returns a stream consisting of the elements of this stream, truncated
   * to be no longer than `maxSize` in length.
   *
   * This is a short-circuiting
   * stateful intermediate operation.
   *
   * @apiNote
   * While `limit()` is generally a cheap operation on sequential
   * stream pipelines, it can be quite expensive on ordered parallel pipelines,
   * especially for large values of `maxSize`, since `limit(n)`
   * is constrained to return not just any n elements, but the
   * first n elements in the encounter order.  Using an unordered
   * stream source (such as {@link #generate(LongSupplier)}) or removing the
   * ordering constraint with {@link #unordered()} may result in significant
   * speedups of `limit()` in parallel pipelines, if the semantics of
   * your situation permit.  If consistency with encounter order is required,
   * and you are experiencing poor performance or memory utilization with
   * `limit()` in parallel pipelines, switching to sequential execution
   * with {@link #sequential()} may improve performance.
   *
   * @param maxSize the number of elements the stream should be limited to
   * @return the new stream
   * @throws IllegalArgumentException if `maxSize` is negative
  */
  limit(maxSize: number): LongStream;
  /**
   * Returns a stream consisting of the remaining elements of this stream
   * after discarding the first `n` elements of the stream.
   * If this stream contains fewer than `n` elements then an
   * empty stream will be returned.
   *
   * This is a stateful
   * intermediate operation.
   *
   * @apiNote
   * While `skip()` is generally a cheap operation on sequential
   * stream pipelines, it can be quite expensive on ordered parallel pipelines,
   * especially for large values of `n`, since `skip(n)`
   * is constrained to skip not just any n elements, but the
   * first n elements in the encounter order.  Using an unordered
   * stream source (such as {@link #generate(LongSupplier)}) or removing the
   * ordering constraint with {@link #unordered()} may result in significant
   * speedups of `skip()` in parallel pipelines, if the semantics of
   * your situation permit.  If consistency with encounter order is required,
   * and you are experiencing poor performance or memory utilization with
   * `skip()` in parallel pipelines, switching to sequential execution
   * with {@link #sequential()} may improve performance.
   *
   * @param n the number of leading elements to skip
   * @return the new stream
   * @throws IllegalArgumentException if `n` is negative
  */
  skip(n: number): LongStream;
  /**
   * Returns, if this stream is ordered, a stream consisting of the longest
   * prefix of elements taken from this stream that match the given predicate.
   * Otherwise returns, if this stream is unordered, a stream consisting of a
   * subset of elements taken from this stream that match the given predicate.
   *
   * If this stream is ordered then the longest prefix is a contiguous
   * sequence of elements of this stream that match the given predicate.  The
   * first element of the sequence is the first element of this stream, and
   * the element immediately following the last element of the sequence does
   * not match the given predicate.
   *
   * If this stream is unordered, and some (but not all) elements of this
   * stream match the given predicate, then the behavior of this operation is
   * nondeterministic; it is free to take any subset of matching elements
   * (which includes the empty set).
   *
   * Independent of whether this stream is ordered or unordered if all
   * elements of this stream match the given predicate then this operation
   * takes all elements (the result is the same as the input), or if no
   * elements of the stream match the given predicate then no elements are
   * taken (the result is an empty stream).
   *
   * This is a short-circuiting
   * stateful intermediate operation.
   *
   * @implSpec
   * The default implementation obtains the {@link #spliterator() spliterator}
   * of this stream, wraps that spliterator so as to support the semantics
   * of this operation on traversal, and returns a new stream associated with
   * the wrapped spliterator.  The returned stream preserves the execution
   * characteristics of this stream (namely parallel or sequential execution
   * as per {@link #isParallel()}) but the wrapped spliterator may choose to
   * not support splitting.  When the returned stream is closed, the close
   * handlers for both the returned and this stream are invoked.
   *
   * @apiNote
   * While `takeWhile()` is generally a cheap operation on sequential
   * stream pipelines, it can be quite expensive on ordered parallel
   * pipelines, since the operation is constrained to return not just any
   * valid prefix, but the longest prefix of elements in the encounter order.
   * Using an unordered stream source (such as
   * {@link #generate(LongSupplier)}) or removing the ordering constraint with
   * {@link #unordered()} may result in significant speedups of
   * `takeWhile()` in parallel pipelines, if the semantics of your
   * situation permit.  If consistency with encounter order is required, and
   * you are experiencing poor performance or memory utilization with
   * `takeWhile()` in parallel pipelines, switching to sequential
   * execution with {@link #sequential()} may improve performance.
   *
   * @param predicate a non-interfering,
   *                  stateless
   *                  predicate to apply to elements to determine the longest
   *                  prefix of elements.
   * @return the new stream
   * @since 9
  */
  takeWhile(predicate: LongPredicate): LongStream;
  /**
   * Returns, if this stream is ordered, a stream consisting of the remaining
   * elements of this stream after dropping the longest prefix of elements
   * that match the given predicate.  Otherwise returns, if this stream is
   * unordered, a stream consisting of the remaining elements of this stream
   * after dropping a subset of elements that match the given predicate.
   *
   * If this stream is ordered then the longest prefix is a contiguous
   * sequence of elements of this stream that match the given predicate.  The
   * first element of the sequence is the first element of this stream, and
   * the element immediately following the last element of the sequence does
   * not match the given predicate.
   *
   * If this stream is unordered, and some (but not all) elements of this
   * stream match the given predicate, then the behavior of this operation is
   * nondeterministic; it is free to drop any subset of matching elements
   * (which includes the empty set).
   *
   * Independent of whether this stream is ordered or unordered if all
   * elements of this stream match the given predicate then this operation
   * drops all elements (the result is an empty stream), or if no elements of
   * the stream match the given predicate then no elements are dropped (the
   * result is the same as the input).
   *
   * This is a stateful
   * intermediate operation.
   *
   * @implSpec
   * The default implementation obtains the {@link #spliterator() spliterator}
   * of this stream, wraps that spliterator so as to support the semantics
   * of this operation on traversal, and returns a new stream associated with
   * the wrapped spliterator.  The returned stream preserves the execution
   * characteristics of this stream (namely parallel or sequential execution
   * as per {@link #isParallel()}) but the wrapped spliterator may choose to
   * not support splitting.  When the returned stream is closed, the close
   * handlers for both the returned and this stream are invoked.
   *
   * @apiNote
   * While `dropWhile()` is generally a cheap operation on sequential
   * stream pipelines, it can be quite expensive on ordered parallel
   * pipelines, since the operation is constrained to return not just any
   * valid prefix, but the longest prefix of elements in the encounter order.
   * Using an unordered stream source (such as
   * {@link #generate(LongSupplier)}) or removing the ordering constraint with
   * {@link #unordered()} may result in significant speedups of
   * `dropWhile()` in parallel pipelines, if the semantics of your
   * situation permit.  If consistency with encounter order is required, and
   * you are experiencing poor performance or memory utilization with
   * `dropWhile()` in parallel pipelines, switching to sequential
   * execution with {@link #sequential()} may improve performance.
   *
   * @param predicate a non-interfering,
   *                  stateless
   *                  predicate to apply to elements to determine the longest
   *                  prefix of elements.
   * @return the new stream
   * @since 9
  */
  dropWhile(predicate: LongPredicate): LongStream;
  /**
   * Performs an action for each element of this stream.
   *
   * This is a terminal
   * operation.
   *
   * For parallel stream pipelines, this operation does not
   * guarantee to respect the encounter order of the stream, as doing so
   * would sacrifice the benefit of parallelism.  For any given element, the
   * action may be performed at whatever time and in whatever thread the
   * library chooses.  If the action accesses shared state, it is
   * responsible for providing the required synchronization.
   *
   * @param action a 
   *               non-interfering action to perform on the elements
  */
  forEach(action: LongConsumer): void;
  /**
   * Performs an action for each element of this stream, guaranteeing that
   * each element is processed in encounter order for streams that have a
   * defined encounter order.
   *
   * This is a terminal
   * operation.
   *
   * @param action a 
   *               non-interfering action to perform on the elements
   * @see #forEach(LongConsumer)
  */
  forEachOrdered(action: LongConsumer): void;
  /**
   * Returns an array containing the elements of this stream.
   *
   * This is a terminal
   * operation.
   *
   * @return an array containing the elements of this stream
  */
  toArray(): number[];
  /**
   * Performs a reduction on the
   * elements of this stream, using the provided identity value and an
   * associative
   * accumulation function, and returns the reduced value.  This is equivalent
   * to:
   * {@code
   *     long result = identity;
   *     for (long element : this stream)
   *         result = accumulator.applyAsLong(result, element)
   *     return result;
   * }
   *
   * but is not constrained to execute sequentially.
   *
   * The `identity` value must be an identity for the accumulator
   * function. This means that for all `x`,
   * `accumulator.apply(identity, x)` is equal to `x`.
   * The `accumulator` function must be an
   * associative function.
   *
   * This is a terminal
   * operation.
   *
   * @apiNote Sum, min, max, and average are all special cases of reduction.
   * Summing a stream of numbers can be expressed as:
   *
   * {@code
   *     long sum = integers.reduce(0, (a, b) -> a+b);
   * }
   *
   * or more compactly:
   *
   * {@code
   *     long sum = integers.reduce(0, Long::sum);
   * }
   *
   * While this may seem a more roundabout way to perform an aggregation
   * compared to simply mutating a running total in a loop, reduction
   * operations parallelize more gracefully, without needing additional
   * synchronization and with greatly reduced risk of data races.
   *
   * @param identity the identity value for the accumulating function
   * @param op an associative,
   *           non-interfering,
   *           stateless
   *           function for combining two values
   * @return the result of the reduction
   * @see #sum()
   * @see #min()
   * @see #max()
   * @see #average()
  */
  reduce(identity: number, op: LongBinaryOperator): number;
  /**
   * Performs a reduction on the
   * elements of this stream, using an
   * associative accumulation
   * function, and returns an `OptionalLong` describing the reduced value,
   * if any. This is equivalent to:
   * {@code
   *     boolean foundAny = false;
   *     long result = null;
   *     for (long element : this stream) {
   *         if (!foundAny) {
   *             foundAny = true;
   *             result = element;
   *         }
   *         else
   *             result = accumulator.applyAsLong(result, element);
   *     }
   *     return foundAny ? OptionalLong.of(result) : OptionalLong.empty();
   * }
   *
   * but is not constrained to execute sequentially.
   *
   * The `accumulator` function must be an
   * associative function.
   *
   * This is a terminal
   * operation.
   *
   * @param op an associative,
   *           non-interfering,
   *           stateless
   *           function for combining two values
   * @return the result of the reduction
   * @see #reduce(long, LongBinaryOperator)
  */
  reduce(op: LongBinaryOperator): OptionalLong;
  /**
   * Performs a mutable
   * reduction operation on the elements of this stream.  A mutable
   * reduction is one in which the reduced value is a mutable result container,
   * such as an `ArrayList`, and elements are incorporated by updating
   * the state of the result rather than by replacing the result.  This
   * produces a result equivalent to:
   * {@code
   *     R result = supplier.get();
   *     for (long element : this stream)
   *         accumulator.accept(result, element);
   *     return result;
   * }
   *
   * Like {@link #reduce(long, LongBinaryOperator)}, `collect` operations
   * can be parallelized without requiring additional synchronization.
   *
   * This is a terminal
   * operation.
   *
   * @param  the type of the mutable result container
   * @param supplier a function that creates a new mutable result container.
   *                 For a parallel execution, this function may be called
   *                 multiple times and must return a fresh value each time.
   * @param accumulator an associative,
   *                    non-interfering,
   *                    stateless
   *                    function that must fold an element into a result
   *                    container.
   * @param combiner an associative,
   *                    non-interfering,
   *                    stateless
   *                    function that accepts two partial result containers
   *                    and merges them, which must be compatible with the
   *                    accumulator function.  The combiner function must fold
   *                    the elements from the second result container into the
   *                    first result container.
   * @return the result of the reduction
   * @see Stream#collect(Supplier, BiConsumer, BiConsumer)
  */
  collect<R>(supplier: Supplier<R>, accumulator: ObjLongConsumer<R>, combiner: BiConsumer<R, R>): R;
  /**
   * Returns the sum of elements in this stream.  This is a special case
   * of a reduction
   * and is equivalent to:
   * {@code
   *     return reduce(0, Long::sum);
   * }
   *
   * This is a terminal
   * operation.
   *
   * @return the sum of elements in this stream
  */
  sum(): number;
  /**
   * Returns an `OptionalLong` describing the minimum element of this
   * stream, or an empty optional if this stream is empty.  This is a special
   * case of a reduction
   * and is equivalent to:
   * {@code
   *     return reduce(Long::min);
   * }
   *
   * This is a terminal operation.
   *
   * @return an `OptionalLong` containing the minimum element of this
   * stream, or an empty `OptionalLong` if the stream is empty
  */
  min(): OptionalLong;
  /**
   * Returns an `OptionalLong` describing the maximum element of this
   * stream, or an empty optional if this stream is empty.  This is a special
   * case of a reduction
   * and is equivalent to:
   * {@code
   *     return reduce(Long::max);
   * }
   *
   * This is a terminal
   * operation.
   *
   * @return an `OptionalLong` containing the maximum element of this
   * stream, or an empty `OptionalLong` if the stream is empty
  */
  max(): OptionalLong;
  /**
   * Returns the count of elements in this stream.  This is a special case of
   * a reduction and is
   * equivalent to:
   * {@code
   *     return map(e -> 1L).sum();
   * }
   *
   * This is a terminal operation.
   *
   * @apiNote
   * An implementation may choose to not execute the stream pipeline (either
   * sequentially or in parallel) if it is capable of computing the count
   * directly from the stream source.  In such cases no source elements will
   * be traversed and no intermediate operations will be evaluated.
   * Behavioral parameters with side-effects, which are strongly discouraged
   * except for harmless cases such as debugging, may be affected.  For
   * example, consider the following stream:
   * {@code
   *     LongStream s = LongStream.of(1, 2, 3, 4);
   *     long count = s.peek(System.out::println).count();
   * }
   * The number of elements covered by the stream source is known and the
   * intermediate operation, `peek`, does not inject into or remove
   * elements from the stream (as may be the case for `flatMap` or
   * `filter` operations).  Thus the count is 4 and there is no need to
   * execute the pipeline and, as a side-effect, print out the elements.
   *
   * @return the count of elements in this stream
  */
  count(): number;
  /**
   * Returns an `OptionalDouble` describing the arithmetic mean of elements of
   * this stream, or an empty optional if this stream is empty.  This is a
   * special case of a
   * reduction.
   *
   * This is a terminal
   * operation.
   *
   * @return an `OptionalDouble` containing the average element of this
   * stream, or an empty optional if the stream is empty
  */
  average(): OptionalDouble;
  /**
   * Returns a `LongSummaryStatistics` describing various summary data
   * about the elements of this stream.  This is a special case of a
   * reduction.
   *
   * This is a terminal
   * operation.
   *
   * @return a `LongSummaryStatistics` describing various summary data
   * about the elements of this stream
  */
  summaryStatistics(): LongSummaryStatistics;
  /**
   * Returns whether any elements of this stream match the provided
   * predicate.  May not evaluate the predicate on all elements if not
   * necessary for determining the result.  If the stream is empty then
   * `false` is returned and the predicate is not evaluated.
   *
   * This is a short-circuiting
   * terminal operation.
   *
   * @apiNote
   * This method evaluates the existential quantification of the
   * predicate over the elements of the stream (for some x P(x)).
   *
   * @param predicate a non-interfering,
   *                  stateless
   *                  predicate to apply to elements of this stream
   * @return `true` if any elements of the stream match the provided
   * predicate, otherwise `false`
  */
  anyMatch(predicate: LongPredicate): boolean;
  /**
   * Returns whether all elements of this stream match the provided predicate.
   * May not evaluate the predicate on all elements if not necessary for
   * determining the result.  If the stream is empty then `true` is
   * returned and the predicate is not evaluated.
   *
   * This is a short-circuiting
   * terminal operation.
   *
   * @apiNote
   * This method evaluates the universal quantification of the
   * predicate over the elements of the stream (for all x P(x)).  If the
   * stream is empty, the quantification is said to be vacuously
   * satisfied and is always `true` (regardless of P(x)).
   *
   * @param predicate a non-interfering,
   *                  stateless
   *                  predicate to apply to elements of this stream
   * @return `true` if either all elements of the stream match the
   * provided predicate or the stream is empty, otherwise `false`
  */
  allMatch(predicate: LongPredicate): boolean;
  /**
   * Returns whether no elements of this stream match the provided predicate.
   * May not evaluate the predicate on all elements if not necessary for
   * determining the result.  If the stream is empty then `true` is
   * returned and the predicate is not evaluated.
   *
   * This is a short-circuiting
   * terminal operation.
   *
   * @apiNote
   * This method evaluates the universal quantification of the
   * negated predicate over the elements of the stream (for all x ~P(x)).  If
   * the stream is empty, the quantification is said to be vacuously satisfied
   * and is always `true`, regardless of P(x).
   *
   * @param predicate a non-interfering,
   *                  stateless
   *                  predicate to apply to elements of this stream
   * @return `true` if either no elements of the stream match the
   * provided predicate or the stream is empty, otherwise `false`
  */
  noneMatch(predicate: LongPredicate): boolean;
  /**
   * Returns an {@link OptionalLong} describing the first element of this
   * stream, or an empty `OptionalLong` if the stream is empty.  If the
   * stream has no encounter order, then any element may be returned.
   *
   * This is a short-circuiting
   * terminal operation.
   *
   * @return an `OptionalLong` describing the first element of this
   * stream, or an empty `OptionalLong` if the stream is empty
  */
  findFirst(): OptionalLong;
  /**
   * Returns an {@link OptionalLong} describing some element of the stream, or
   * an empty `OptionalLong` if the stream is empty.
   *
   * This is a short-circuiting
   * terminal operation.
   *
   * The behavior of this operation is explicitly nondeterministic; it is
   * free to select any element in the stream.  This is to allow for maximal
   * performance in parallel operations; the cost is that multiple invocations
   * on the same source may not return the same result.  (If a stable result
   * is desired, use {@link #findFirst()} instead.)
   *
   * @return an `OptionalLong` describing some element of this stream,
   * or an empty `OptionalLong` if the stream is empty
   * @see #findFirst()
  */
  findAny(): OptionalLong;
  /**
   * Returns a `DoubleStream` consisting of the elements of this stream,
   * converted to `double`.
   *
   * This is an intermediate
   * operation.
   *
   * @return a `DoubleStream` consisting of the elements of this stream,
   * converted to `double`
  */
  asDoubleStream(): DoubleStream;
  /**
   * Returns a `Stream` consisting of the elements of this stream,
   * each boxed to a `Long`.
   *
   * This is an intermediate
   * operation.
   *
   * @return a `Stream` consistent of the elements of this stream,
   * each boxed to `Long`
  */
  boxed(): Stream<number>;
  sequential(): LongStream;
  parallel(): LongStream;
  iterator(): OfLong;
  spliterator(): java_util_Spliterator_OfLong;
  /**
   * Returns a builder for a `LongStream`.
   *
   * @return a stream builder
  */
  static builder(): java_util_stream_LongStream_Builder;
  /**
   * Returns an empty sequential `LongStream`.
   *
   * @return an empty sequential stream
  */
  static empty(): LongStream;
  /**
   * Returns a sequential `LongStream` containing a single element.
   *
   * @param t the single element
   * @return a singleton sequential stream
  */
  static of(t: number): LongStream;
  /**
   * Returns a sequential ordered stream whose elements are the specified values.
   *
   * @param values the elements of the new stream
   * @return the new stream
  */
  static of(...values: number[]): LongStream;
  /**
   * Returns an infinite sequential ordered `LongStream` produced by iterative
   * application of a function `f` to an initial element `seed`,
   * producing a `Stream` consisting of `seed`, `f(seed)`,
   * `f(f(seed))`, etc.
   *
   * The first element (position `0`) in the `LongStream` will
   * be the provided `seed`.  For `n > 0`, the element at position
   * `n`, will be the result of applying the function `f` to the
   * element at position `n - 1`.
   *
   * The action of applying `f` for one element
   * happens-before
   * the action of applying `f` for subsequent elements.  For any given
   * element the action may be performed in whatever thread the library
   * chooses.
   *
   * @param seed the initial element
   * @param f a function to be applied to the previous element to produce
   *          a new element
   * @return a new sequential `LongStream`
  */
  static iterate(seed: number, f: LongUnaryOperator): LongStream;
  /**
   * Returns a sequential ordered `LongStream` produced by iterative
   * application of the given `next` function to an initial element,
   * conditioned on satisfying the given `hasNext` predicate.  The
   * stream terminates as soon as the `hasNext` predicate returns false.
   *
   * `LongStream.iterate` should produce the same sequence of elements as
   * produced by the corresponding for-loop:
   * {@code
   *     for (long index=seed; hasNext.test(index); index = next.applyAsLong(index)) {
   *         ...
   *     }
   * }
   *
   * The resulting sequence may be empty if the `hasNext` predicate
   * does not hold on the seed value.  Otherwise the first element will be the
   * supplied `seed` value, the next element (if present) will be the
   * result of applying the `next` function to the `seed` value,
   * and so on iteratively until the `hasNext` predicate indicates that
   * the stream should terminate.
   *
   * The action of applying the `hasNext` predicate to an element
   * happens-before
   * the action of applying the `next` function to that element.  The
   * action of applying the `next` function for one element
   * happens-before the action of applying the `hasNext`
   * predicate for subsequent elements.  For any given element an action may
   * be performed in whatever thread the library chooses.
   *
   * @param seed the initial element
   * @param hasNext a predicate to apply to elements to determine when the
   *                stream must terminate.
   * @param next a function to be applied to the previous element to produce
   *             a new element
   * @return a new sequential `LongStream`
   * @since 9
  */
  static iterate(seed: number, hasNext: LongPredicate, next: LongUnaryOperator): LongStream;
  /**
   * Returns an infinite sequential unordered stream where each element is
   * generated by the provided `LongSupplier`.  This is suitable for
   * generating constant streams, streams of random elements, etc.
   *
   * @param s the `LongSupplier` for generated elements
   * @return a new infinite sequential unordered `LongStream`
  */
  static generate(s: LongSupplier): LongStream;
  /**
   * Returns a sequential ordered `LongStream` from `startInclusive`
   * (inclusive) to `endExclusive` (exclusive) by an incremental step of
   * `1`.
   *
   * @apiNote
   * An equivalent sequence of increasing values can be produced
   * sequentially using a `for` loop as follows:
   * `     *     for (long i = startInclusive; i < endExclusive ; i++) { ... `
   * }
   *
   * @param startInclusive the (inclusive) initial value
   * @param endExclusive the exclusive upper bound
   * @return a sequential `LongStream` for the range of `long`
   *         elements
  */
  static range(startInclusive: number, endExclusive: number): LongStream;
  /**
   * Returns a sequential ordered `LongStream` from `startInclusive`
   * (inclusive) to `endInclusive` (inclusive) by an incremental step of
   * `1`.
   *
   * @apiNote
   * An equivalent sequence of increasing values can be produced
   * sequentially using a `for` loop as follows:
   * `     *     for (long i = startInclusive; i <= endInclusive ; i++) { ... `
   * }
   *
   * @param startInclusive the (inclusive) initial value
   * @param endInclusive the inclusive upper bound
   * @return a sequential `LongStream` for the range of `long`
   *         elements
  */
  static rangeClosed(startInclusive: number, endInclusive: number): LongStream;
  /**
   * Creates a lazily concatenated stream whose elements are all the
   * elements of the first stream followed by all the elements of the
   * second stream.  The resulting stream is ordered if both
   * of the input streams are ordered, and parallel if either of the input
   * streams is parallel.  When the resulting stream is closed, the close
   * handlers for both input streams are invoked.
   *
   * This method operates on the two input streams and binds each stream
   * to its source.  As a result subsequent modifications to an input stream
   * source may not be reflected in the concatenated stream result.
   *
   * @implNote
   * Use caution when constructing streams from repeated concatenation.
   * Accessing an element of a deeply concatenated stream can result in deep
   * call chains, or even `StackOverflowError`.
   *
   * @apiNote
   * To preserve optimization opportunities this method binds each stream to
   * its source and accepts only two streams as parameters.  For example, the
   * exact size of the concatenated stream source can be computed if the exact
   * size of each input stream source is known.
   * To concatenate more streams without binding, or without nested calls to
   * this method, try creating a stream of streams and flat-mapping with the
   * identity function, for example:
   * {@code
   *     LongStream concat = Stream.of(s1, s2, s3, s4).flatMapToLong(s -> s);
   * }
   *
   * @param a the first stream
   * @param b the second stream
   * @return the concatenation of the two input streams
  */
  static concat(a: LongStream, b: LongStream): LongStream;
}
/**
 * Base interface for streams, which are sequences of elements supporting
 * sequential and parallel aggregate operations.  The following example
 * illustrates an aggregate operation using the stream types {@link Stream}
 * and {@link IntStream}, computing the sum of the weights of the red widgets:
 *
 * {@code
 *     int sum = widgets.stream()
 *                      .filter(w -> w.getColor() == RED)
 *                      .mapToInt(w -> w.getWeight())
 *                      .sum();
 * }
 *
 * See the class documentation for {@link Stream} and the package documentation
 * for java.util.stream for additional
 * specification of streams, stream operations, stream pipelines, and
 * parallelism, which governs the behavior of all stream types.
 *
 * @param  the type of the stream elements
 * @param  the type of the stream implementing `BaseStream`
 * @since 1.8
 * @see Stream
 * @see IntStream
 * @see LongStream
 * @see DoubleStream
 * @see java.util.stream
*/
export class BaseStream<T, S> extends AutoCloseable {
  /**
   * Returns an iterator for the elements of this stream.
   *
   * This is a terminal
   * operation.
   *
   * @return the element iterator for this stream
  */
  iterator(): Iterator<T>;
  /**
   * Returns a spliterator for the elements of this stream.
   *
   * This is a terminal
   * operation.
   *
   * 
   * The returned spliterator should report the set of characteristics derived
   * from the stream pipeline (namely the characteristics derived from the
   * stream source spliterator and the intermediate operations).
   * Implementations may report a sub-set of those characteristics.  For
   * example, it may be too expensive to compute the entire set for some or
   * all possible stream pipelines.
   *
   * @return the element spliterator for this stream
  */
  spliterator(): Spliterator<T>;
  /**
   * Returns whether this stream, if a terminal operation were to be executed,
   * would execute in parallel.  Calling this method after invoking an
   * terminal stream operation method may yield unpredictable results.
   *
   * @return `true` if this stream would execute in parallel if executed
  */
  isParallel(): boolean;
  /**
   * Returns an equivalent stream that is sequential.  May return
   * itself, either because the stream was already sequential, or because
   * the underlying stream state was modified to be sequential.
   *
   * This is an intermediate
   * operation.
   *
   * @return a sequential stream
  */
  sequential(): S;
  /**
   * Returns an equivalent stream that is parallel.  May return
   * itself, either because the stream was already parallel, or because
   * the underlying stream state was modified to be parallel.
   *
   * This is an intermediate
   * operation.
   *
   * @return a parallel stream
  */
  parallel(): S;
  /**
   * Returns an equivalent stream that is
   * unordered.  May return
   * itself, either because the stream was already unordered, or because
   * the underlying stream state was modified to be unordered.
   *
   * This is an intermediate
   * operation.
   *
   * @return an unordered stream
  */
  unordered(): S;
  /**
   * Returns an equivalent stream with an additional close handler.  Close
   * handlers are run when the {@link #close()} method
   * is called on the stream, and are executed in the order they were
   * added.  All close handlers are run, even if earlier close handlers throw
   * exceptions.  If any close handler throws an exception, the first
   * exception thrown will be relayed to the caller of `close()`, with
   * any remaining exceptions added to that exception as suppressed exceptions
   * (unless one of the remaining exceptions is the same exception as the
   * first exception, since an exception cannot suppress itself.)  May
   * return itself.
   *
   * This is an intermediate
   * operation.
   *
   * @param closeHandler A task to execute when the stream is closed
   * @return a stream with a handler that is run if the stream is closed
  */
  onClose(closeHandler: Runnable): S;
  /**
   * Closes this stream, causing all close handlers for this stream pipeline
   * to be called.
   *
   * @see AutoCloseable#close()
  */
  close(): void;
}
/**
 * A sequence of elements supporting sequential and parallel aggregate
 * operations.  The following example illustrates an aggregate operation using
 * {@link Stream} and {@link IntStream}:
 *
 * {@code
 *     int sum = widgets.stream()
 *                      .filter(w -> w.getColor() == RED)
 *                      .mapToInt(w -> w.getWeight())
 *                      .sum();
 * }
 *
 * In this example, `widgets` is a `Collection`.  We create
 * a stream of `Widget` objects via {@link Collection#stream Collection.stream()},
 * filter it to produce a stream containing only the red widgets, and then
 * transform it into a stream of `int` values representing the weight of
 * each red widget. Then this stream is summed to produce a total weight.
 *
 * In addition to `Stream`, which is a stream of object references,
 * there are primitive specializations for {@link IntStream}, {@link LongStream},
 * and {@link DoubleStream}, all of which are referred to as "streams" and
 * conform to the characteristics and restrictions described here.
 *
 * To perform a computation, stream
 * operations are composed into a
 * stream pipeline.  A stream pipeline consists of a source (which
 * might be an array, a collection, a generator function, an I/O channel,
 * etc), zero or more intermediate operations (which transform a
 * stream into another stream, such as {@link Stream#filter(Predicate)}), and a
 * terminal operation (which produces a result or side-effect, such
 * as {@link Stream#count()} or {@link Stream#forEach(Consumer)}).
 * Streams are lazy; computation on the source data is only performed when the
 * terminal operation is initiated, and source elements are consumed only
 * as needed.
 *
 * A stream implementation is permitted significant latitude in optimizing
 * the computation of the result.  For example, a stream implementation is free
 * to elide operations (or entire stages) from a stream pipeline -- and
 * therefore elide invocation of behavioral parameters -- if it can prove that
 * it would not affect the result of the computation.  This means that
 * side-effects of behavioral parameters may not always be executed and should
 * not be relied upon, unless otherwise specified (such as by the terminal
 * operations `forEach` and `forEachOrdered`). (For a specific
 * example of such an optimization, see the API note documented on the
 * {@link #count} operation.  For more detail, see the
 * side-effects section of the
 * stream package documentation.)
 *
 * Collections and streams, while bearing some superficial similarities,
 * have different goals.  Collections are primarily concerned with the efficient
 * management of, and access to, their elements.  By contrast, streams do not
 * provide a means to directly access or manipulate their elements, and are
 * instead concerned with declaratively describing their source and the
 * computational operations which will be performed in aggregate on that source.
 * However, if the provided stream operations do not offer the desired
 * functionality, the {@link #iterator()} and {@link #spliterator()} operations
 * can be used to perform a controlled traversal.
 *
 * A stream pipeline, like the "widgets" example above, can be viewed as
 * a query on the stream source.  Unless the source was explicitly
 * designed for concurrent modification (such as a {@link ConcurrentHashMap}),
 * unpredictable or erroneous behavior may result from modifying the stream
 * source while it is being queried.
 *
 * Most stream operations accept parameters that describe user-specified
 * behavior, such as the lambda expression `w -> w.getWeight()` passed to
 * `mapToInt` in the example above.  To preserve correct behavior,
 * these behavioral parameters:
 * 
 * must be non-interfering
 * (they do not modify the stream source); and
 * in most cases must be stateless
 * (their result should not depend on any state that might change during execution
 * of the stream pipeline).
 * 
 *
 * Such parameters are always instances of a
 * functional interface such
 * as {@link java.util.function.Function}, and are often lambda expressions or
 * method references.  Unless otherwise specified these parameters must be
 * non-null.
 *
 * A stream should be operated on (invoking an intermediate or terminal stream
 * operation) only once.  This rules out, for example, "forked" streams, where
 * the same source feeds two or more pipelines, or multiple traversals of the
 * same stream.  A stream implementation may throw {@link IllegalStateException}
 * if it detects that the stream is being reused. However, since some stream
 * operations may return their receiver rather than a new stream object, it may
 * not be possible to detect reuse in all cases.
 *
 * Streams have a {@link #close()} method and implement {@link AutoCloseable}.
 * Operating on a stream after it has been closed will throw {@link IllegalStateException}.
 * Most stream instances do not actually need to be closed after use, as they
 * are backed by collections, arrays, or generating functions, which require no
 * special resource management. Generally, only streams whose source is an IO channel,
 * such as those returned by {@link Files#lines(Path)}, will require closing. If a
 * stream does require closing, it must be opened as a resource within a try-with-resources
 * statement or similar control structure to ensure that it is closed promptly after its
 * operations have completed.
 *
 * Stream pipelines may execute either sequentially or in
 * parallel.  This
 * execution mode is a property of the stream.  Streams are created
 * with an initial choice of sequential or parallel execution.  (For example,
 * {@link Collection#stream() Collection.stream()} creates a sequential stream,
 * and {@link Collection#parallelStream() Collection.parallelStream()} creates
 * a parallel one.)  This choice of execution mode may be modified by the
 * {@link #sequential()} or {@link #parallel()} methods, and may be queried with
 * the {@link #isParallel()} method.
 *
 * @param  the type of the stream elements
 * @since 1.8
 * @see IntStream
 * @see LongStream
 * @see DoubleStream
 * @see java.util.stream
*/
export class Stream<T> extends BaseStream<T, Stream<T>> {
  /**
   * Returns a stream consisting of the elements of this stream that match
   * the given predicate.
   *
   * This is an intermediate
   * operation.
   *
   * @param predicate a non-interfering,
   *                  stateless
   *                  predicate to apply to each element to determine if it
   *                  should be included
   * @return the new stream
  */
  filter(predicate: Predicate<any>): Stream<T>;
  /**
   * Returns a stream consisting of the results of applying the given
   * function to the elements of this stream.
   *
   * This is an intermediate
   * operation.
   *
   * @param  The element type of the new stream
   * @param mapper a non-interfering,
   *               stateless
   *               function to apply to each element
   * @return the new stream
  */
  map<R>(mapper: Function<any, R>): Stream<R>;
  /**
   * Returns an `IntStream` consisting of the results of applying the
   * given function to the elements of this stream.
   *
   * This is an 
   *     intermediate operation.
   *
   * @param mapper a non-interfering,
   *               stateless
   *               function to apply to each element
   * @return the new stream
  */
  mapToInt(mapper: ToIntFunction<any>): IntStream;
  /**
   * Returns a `LongStream` consisting of the results of applying the
   * given function to the elements of this stream.
   *
   * This is an intermediate
   * operation.
   *
   * @param mapper a non-interfering,
   *               stateless
   *               function to apply to each element
   * @return the new stream
  */
  mapToLong(mapper: ToLongFunction<any>): LongStream;
  /**
   * Returns a `DoubleStream` consisting of the results of applying the
   * given function to the elements of this stream.
   *
   * This is an intermediate
   * operation.
   *
   * @param mapper a non-interfering,
   *               stateless
   *               function to apply to each element
   * @return the new stream
  */
  mapToDouble(mapper: ToDoubleFunction<any>): DoubleStream;
  /**
   * Returns a stream consisting of the results of replacing each element of
   * this stream with the contents of a mapped stream produced by applying
   * the provided mapping function to each element.  Each mapped stream is
   * {@link java.util.stream.BaseStream#close() closed} after its contents
   * have been placed into this stream.  (If a mapped stream is `null`
   * an empty stream is used, instead.)
   *
   * This is an intermediate
   * operation.
   *
   * @apiNote
   * The `flatMap()` operation has the effect of applying a one-to-many
   * transformation to the elements of the stream, and then flattening the
   * resulting elements into a new stream.
   *
   * Examples.
   *
   * If `orders` is a stream of purchase orders, and each purchase
   * order contains a collection of line items, then the following produces a
   * stream containing all the line items in all the orders:
   * {@code
   *     orders.flatMap(order -> order.getLineItems().stream())...
   * }
   *
   * If `path` is the path to a file, then the following produces a
   * stream of the `words` contained in that file:
   * {@code
   *     Stream lines = Files.lines(path, StandardCharsets.UTF_8);
   *     Stream words = lines.flatMap(line -> Stream.of(line.split(" +")));
   * }
   * The `mapper` function passed to `flatMap` splits a line,
   * using a simple regular expression, into an array of words, and then
   * creates a stream of words from that array.
   *
   * @param  The element type of the new stream
   * @param mapper a non-interfering,
   *               stateless
   *               function to apply to each element which produces a stream
   *               of new values
   * @return the new stream
   * @see #mapMulti
  */
  flatMap<R>(mapper: Function<any, Stream<R>>): Stream<R>;
  /**
   * Returns an `IntStream` consisting of the results of replacing each
   * element of this stream with the contents of a mapped stream produced by
   * applying the provided mapping function to each element.  Each mapped
   * stream is {@link java.util.stream.BaseStream#close() closed} after its
   * contents have been placed into this stream.  (If a mapped stream is
   * `null` an empty stream is used, instead.)
   *
   * This is an intermediate
   * operation.
   *
   * @param mapper a non-interfering,
   *               stateless
   *               function to apply to each element which produces a stream
   *               of new values
   * @return the new stream
   * @see #flatMap(Function)
  */
  flatMapToInt(mapper: Function<any, IntStream>): IntStream;
  /**
   * Returns an `LongStream` consisting of the results of replacing each
   * element of this stream with the contents of a mapped stream produced by
   * applying the provided mapping function to each element.  Each mapped
   * stream is {@link java.util.stream.BaseStream#close() closed} after its
   * contents have been placed into this stream.  (If a mapped stream is
   * `null` an empty stream is used, instead.)
   *
   * This is an intermediate
   * operation.
   *
   * @param mapper a non-interfering,
   *               stateless
   *               function to apply to each element which produces a stream
   *               of new values
   * @return the new stream
   * @see #flatMap(Function)
  */
  flatMapToLong(mapper: Function<any, LongStream>): LongStream;
  /**
   * Returns an `DoubleStream` consisting of the results of replacing
   * each element of this stream with the contents of a mapped stream produced
   * by applying the provided mapping function to each element.  Each mapped
   * stream is {@link java.util.stream.BaseStream#close() closed} after its
   * contents have placed been into this stream.  (If a mapped stream is
   * `null` an empty stream is used, instead.)
   *
   * This is an intermediate
   * operation.
   *
   * @param mapper a non-interfering,
   *               stateless
   *               function to apply to each element which produces a stream
   *               of new values
   * @return the new stream
   * @see #flatMap(Function)
  */
  flatMapToDouble(mapper: Function<any, DoubleStream>): DoubleStream;
  /**
   * Returns a stream consisting of the results of replacing each element of
   * this stream with multiple elements, specifically zero or more elements.
   * Replacement is performed by applying the provided mapping function to each
   * element in conjunction with a {@linkplain Consumer consumer} argument
   * that accepts replacement elements. The mapping function calls the consumer
   * zero or more times to provide the replacement elements.
   *
   * This is an intermediate
   * operation.
   *
   * If the {@linkplain Consumer consumer} argument is used outside the scope of
   * its application to the mapping function, the results are undefined.
   *
   * @implSpec
   * The default implementation invokes {@link #flatMap flatMap} on this stream,
   * passing a function that behaves as follows. First, it calls the mapper function
   * with a `Consumer` that accumulates replacement elements into a newly created
   * internal buffer. When the mapper function returns, it creates a stream from the
   * internal buffer. Finally, it returns this stream to `flatMap`.
   *
   * @apiNote
   * This method is similar to {@link #flatMap flatMap} in that it applies a one-to-many
   * transformation to the elements of the stream and flattens the result elements
   * into a new stream. This method is preferable to `flatMap` in the following
   * circumstances:
   * 
   * When replacing each stream element with a small (possibly zero) number of
   * elements. Using this method avoids the overhead of creating a new Stream instance
   * for every group of result elements, as required by `flatMap`.
   * When it is easier to use an imperative approach for generating result
   * elements than it is to return them in the form of a Stream.
   * 
   *
   * If a lambda expression is provided as the mapper function argument, additional type
   * information may be necessary for proper inference of the element type `` of
   * the returned stream. This can be provided in the form of explicit type declarations for
   * the lambda parameters or as an explicit type argument to the `mapMulti` call.
   *
   * Examples
   *
   * Given a stream of `Number` objects, the following
   * produces a list containing only the `Integer` objects:
   * {@code
   *     Stream numbers = ... ;
   *     List integers = numbers.mapMulti((number, consumer) -> {
   *             if (number instanceof Integer)
   *                 consumer.accept((Integer) number);
   *         })
   *         .collect(Collectors.toList());
   * }
   *
   * If we have an `Iterable` and need to recursively expand its elements
   * that are themselves of type `Iterable`, we can use `mapMulti` as follows:
   * {@code
   * class C {
   *     static void expandIterable(Object e, Consumer c) {
   *         if (e instanceof Iterable) {
   *             for (Object ie: (Iterable) e) {
   *                 expandIterable(ie, c);
   *             }
   *         } else if (e != null) {
   *             c.accept(e);
   *         }
   *     }
   *
   *     public static void main(String[] args) {
   *         Stream stream = ...;
   *         Stream expandedStream = stream.mapMulti(C::expandIterable);
   *     }
   * }
   * }
   *
   * @param  The element type of the new stream
   * @param mapper a non-interfering,
   *               stateless
   *               function that generates replacement elements
   * @return the new stream
   * @see #flatMap flatMap
   * @since 16
  */
  mapMulti<R>(mapper: BiConsumer<any, any>): Stream<R>;
  /**
   * Returns an `IntStream` consisting of the results of replacing each
   * element of this stream with multiple elements, specifically zero or more
   * elements.
   * Replacement is performed by applying the provided mapping function to each
   * element in conjunction with a {@linkplain IntConsumer consumer} argument
   * that accepts replacement elements. The mapping function calls the consumer
   * zero or more times to provide the replacement elements.
   *
   * This is an intermediate
   * operation.
   *
   * If the {@linkplain IntConsumer consumer} argument is used outside the scope of
   * its application to the mapping function, the results are undefined.
   *
   * @implSpec
   * The default implementation invokes {@link #flatMapToInt flatMapToInt} on this stream,
   * passing a function that behaves as follows. First, it calls the mapper function
   * with an `IntConsumer` that accumulates replacement elements into a newly created
   * internal buffer. When the mapper function returns, it creates an `IntStream` from
   * the internal buffer. Finally, it returns this stream to `flatMapToInt`.
   *
   * @param mapper a non-interfering,
   *               stateless
   *               function that generates replacement elements
   * @return the new stream
   * @see #mapMulti mapMulti
   * @since 16
  */
  mapMultiToInt(mapper: BiConsumer<any, any>): IntStream;
  /**
   * Returns a `LongStream` consisting of the results of replacing each
   * element of this stream with multiple elements, specifically zero or more
   * elements.
   * Replacement is performed by applying the provided mapping function to each
   * element in conjunction with a {@linkplain LongConsumer consumer} argument
   * that accepts replacement elements. The mapping function calls the consumer
   * zero or more times to provide the replacement elements.
   *
   * This is an intermediate
   * operation.
   *
   * If the {@linkplain LongConsumer consumer} argument is used outside the scope of
   * its application to the mapping function, the results are undefined.
   *
   * @implSpec
   * The default implementation invokes {@link #flatMapToLong flatMapToLong} on this stream,
   * passing a function that behaves as follows. First, it calls the mapper function
   * with a `LongConsumer` that accumulates replacement elements into a newly created
   * internal buffer. When the mapper function returns, it creates a `LongStream` from
   * the internal buffer. Finally, it returns this stream to `flatMapToLong`.
   *
   * @param mapper a non-interfering,
   *               stateless
   *               function that generates replacement elements
   * @return the new stream
   * @see #mapMulti mapMulti
   * @since 16
  */
  mapMultiToLong(mapper: BiConsumer<any, any>): LongStream;
  /**
   * Returns a `DoubleStream` consisting of the results of replacing each
   * element of this stream with multiple elements, specifically zero or more
   * elements.
   * Replacement is performed by applying the provided mapping function to each
   * element in conjunction with a {@linkplain DoubleConsumer consumer} argument
   * that accepts replacement elements. The mapping function calls the consumer
   * zero or more times to provide the replacement elements.
   *
   * This is an intermediate
   * operation.
   *
   * If the {@linkplain DoubleConsumer consumer} argument is used outside the scope of
   * its application to the mapping function, the results are undefined.
   *
   * @implSpec
   * The default implementation invokes {@link #flatMapToDouble flatMapToDouble} on this stream,
   * passing a function that behaves as follows. First, it calls the mapper function
   * with an `DoubleConsumer` that accumulates replacement elements into a newly created
   * internal buffer. When the mapper function returns, it creates a `DoubleStream` from
   * the internal buffer. Finally, it returns this stream to `flatMapToDouble`.
   *
   * @param mapper a non-interfering,
   *               stateless
   *               function that generates replacement elements
   * @return the new stream
   * @see #mapMulti mapMulti
   * @since 16
  */
  mapMultiToDouble(mapper: BiConsumer<any, any>): DoubleStream;
  /**
   * Returns a stream consisting of the distinct elements (according to
   * {@link Object#equals(Object)}) of this stream.
   *
   * For ordered streams, the selection of distinct elements is stable
   * (for duplicated elements, the element appearing first in the encounter
   * order is preserved.)  For unordered streams, no stability guarantees
   * are made.
   *
   * This is a stateful
   * intermediate operation.
   *
   * @apiNote
   * Preserving stability for `distinct()` in parallel pipelines is
   * relatively expensive (requires that the operation act as a full barrier,
   * with substantial buffering overhead), and stability is often not needed.
   * Using an unordered stream source (such as {@link #generate(Supplier)})
   * or removing the ordering constraint with {@link #unordered()} may result
   * in significantly more efficient execution for `distinct()` in parallel
   * pipelines, if the semantics of your situation permit.  If consistency
   * with encounter order is required, and you are experiencing poor performance
   * or memory utilization with `distinct()` in parallel pipelines,
   * switching to sequential execution with {@link #sequential()} may improve
   * performance.
   *
   * @return the new stream
  */
  distinct(): Stream<T>;
  /**
   * Returns a stream consisting of the elements of this stream, sorted
   * according to natural order.  If the elements of this stream are not
   * `Comparable`, a `java.lang.ClassCastException` may be thrown
   * when the terminal operation is executed.
   *
   * For ordered streams, the sort is stable.  For unordered streams, no
   * stability guarantees are made.
   *
   * This is a stateful
   * intermediate operation.
   *
   * @return the new stream
  */
  sorted(): Stream<T>;
  /**
   * Returns a stream consisting of the elements of this stream, sorted
   * according to the provided `Comparator`.
   *
   * For ordered streams, the sort is stable.  For unordered streams, no
   * stability guarantees are made.
   *
   * This is a stateful
   * intermediate operation.
   *
   * @param comparator a non-interfering,
   *                   stateless
   *                   `Comparator` to be used to compare stream elements
   * @return the new stream
  */
  sorted(comparator: Comparator<any>): Stream<T>;
  /**
   * Returns a stream consisting of the elements of this stream, additionally
   * performing the provided action on each element as elements are consumed
   * from the resulting stream.
   *
   * This is an intermediate
   * operation.
   *
   * For parallel stream pipelines, the action may be called at
   * whatever time and in whatever thread the element is made available by the
   * upstream operation.  If the action modifies shared state,
   * it is responsible for providing the required synchronization.
   *
   * @apiNote This method exists mainly to support debugging, where you want
   * to see the elements as they flow past a certain point in a pipeline:
   * {@code
   *     Stream.of("one", "two", "three", "four")
   *         .filter(e -> e.length() > 3)
   *         .peek(e -> System.out.println("Filtered value: " + e))
   *         .map(String::toUpperCase)
   *         .peek(e -> System.out.println("Mapped value: " + e))
   *         .collect(Collectors.toList());
   * }
   *
   * In cases where the stream implementation is able to optimize away the
   * production of some or all the elements (such as with short-circuiting
   * operations like `findFirst`, or in the example described in
   * {@link #count}), the action will not be invoked for those elements.
   *
   * @param action a 
   *                 non-interfering action to perform on the elements as
   *                 they are consumed from the stream
   * @return the new stream
  */
  peek(action: Consumer<any>): Stream<T>;
  /**
   * Returns a stream consisting of the elements of this stream, truncated
   * to be no longer than `maxSize` in length.
   *
   * This is a short-circuiting
   * stateful intermediate operation.
   *
   * @apiNote
   * While `limit()` is generally a cheap operation on sequential
   * stream pipelines, it can be quite expensive on ordered parallel pipelines,
   * especially for large values of `maxSize`, since `limit(n)`
   * is constrained to return not just any n elements, but the
   * first n elements in the encounter order.  Using an unordered
   * stream source (such as {@link #generate(Supplier)}) or removing the
   * ordering constraint with {@link #unordered()} may result in significant
   * speedups of `limit()` in parallel pipelines, if the semantics of
   * your situation permit.  If consistency with encounter order is required,
   * and you are experiencing poor performance or memory utilization with
   * `limit()` in parallel pipelines, switching to sequential execution
   * with {@link #sequential()} may improve performance.
   *
   * @param maxSize the number of elements the stream should be limited to
   * @return the new stream
   * @throws IllegalArgumentException if `maxSize` is negative
  */
  limit(maxSize: number): Stream<T>;
  /**
   * Returns a stream consisting of the remaining elements of this stream
   * after discarding the first `n` elements of the stream.
   * If this stream contains fewer than `n` elements then an
   * empty stream will be returned.
   *
   * This is a stateful
   * intermediate operation.
   *
   * @apiNote
   * While `skip()` is generally a cheap operation on sequential
   * stream pipelines, it can be quite expensive on ordered parallel pipelines,
   * especially for large values of `n`, since `skip(n)`
   * is constrained to skip not just any n elements, but the
   * first n elements in the encounter order.  Using an unordered
   * stream source (such as {@link #generate(Supplier)}) or removing the
   * ordering constraint with {@link #unordered()} may result in significant
   * speedups of `skip()` in parallel pipelines, if the semantics of
   * your situation permit.  If consistency with encounter order is required,
   * and you are experiencing poor performance or memory utilization with
   * `skip()` in parallel pipelines, switching to sequential execution
   * with {@link #sequential()} may improve performance.
   *
   * @param n the number of leading elements to skip
   * @return the new stream
   * @throws IllegalArgumentException if `n` is negative
  */
  skip(n: number): Stream<T>;
  /**
   * Returns, if this stream is ordered, a stream consisting of the longest
   * prefix of elements taken from this stream that match the given predicate.
   * Otherwise returns, if this stream is unordered, a stream consisting of a
   * subset of elements taken from this stream that match the given predicate.
   *
   * If this stream is ordered then the longest prefix is a contiguous
   * sequence of elements of this stream that match the given predicate.  The
   * first element of the sequence is the first element of this stream, and
   * the element immediately following the last element of the sequence does
   * not match the given predicate.
   *
   * If this stream is unordered, and some (but not all) elements of this
   * stream match the given predicate, then the behavior of this operation is
   * nondeterministic; it is free to take any subset of matching elements
   * (which includes the empty set).
   *
   * Independent of whether this stream is ordered or unordered if all
   * elements of this stream match the given predicate then this operation
   * takes all elements (the result is the same as the input), or if no
   * elements of the stream match the given predicate then no elements are
   * taken (the result is an empty stream).
   *
   * This is a short-circuiting
   * stateful intermediate operation.
   *
   * @implSpec
   * The default implementation obtains the {@link #spliterator() spliterator}
   * of this stream, wraps that spliterator so as to support the semantics
   * of this operation on traversal, and returns a new stream associated with
   * the wrapped spliterator.  The returned stream preserves the execution
   * characteristics of this stream (namely parallel or sequential execution
   * as per {@link #isParallel()}) but the wrapped spliterator may choose to
   * not support splitting.  When the returned stream is closed, the close
   * handlers for both the returned and this stream are invoked.
   *
   * @apiNote
   * While `takeWhile()` is generally a cheap operation on sequential
   * stream pipelines, it can be quite expensive on ordered parallel
   * pipelines, since the operation is constrained to return not just any
   * valid prefix, but the longest prefix of elements in the encounter order.
   * Using an unordered stream source (such as {@link #generate(Supplier)}) or
   * removing the ordering constraint with {@link #unordered()} may result in
   * significant speedups of `takeWhile()` in parallel pipelines, if the
   * semantics of your situation permit.  If consistency with encounter order
   * is required, and you are experiencing poor performance or memory
   * utilization with `takeWhile()` in parallel pipelines, switching to
   * sequential execution with {@link #sequential()} may improve performance.
   *
   * @param predicate a non-interfering,
   *                  stateless
   *                  predicate to apply to elements to determine the longest
   *                  prefix of elements.
   * @return the new stream
   * @since 9
  */
  takeWhile(predicate: Predicate<any>): Stream<T>;
  /**
   * Returns, if this stream is ordered, a stream consisting of the remaining
   * elements of this stream after dropping the longest prefix of elements
   * that match the given predicate.  Otherwise returns, if this stream is
   * unordered, a stream consisting of the remaining elements of this stream
   * after dropping a subset of elements that match the given predicate.
   *
   * If this stream is ordered then the longest prefix is a contiguous
   * sequence of elements of this stream that match the given predicate.  The
   * first element of the sequence is the first element of this stream, and
   * the element immediately following the last element of the sequence does
   * not match the given predicate.
   *
   * If this stream is unordered, and some (but not all) elements of this
   * stream match the given predicate, then the behavior of this operation is
   * nondeterministic; it is free to drop any subset of matching elements
   * (which includes the empty set).
   *
   * Independent of whether this stream is ordered or unordered if all
   * elements of this stream match the given predicate then this operation
   * drops all elements (the result is an empty stream), or if no elements of
   * the stream match the given predicate then no elements are dropped (the
   * result is the same as the input).
   *
   * This is a stateful
   * intermediate operation.
   *
   * @implSpec
   * The default implementation obtains the {@link #spliterator() spliterator}
   * of this stream, wraps that spliterator so as to support the semantics
   * of this operation on traversal, and returns a new stream associated with
   * the wrapped spliterator.  The returned stream preserves the execution
   * characteristics of this stream (namely parallel or sequential execution
   * as per {@link #isParallel()}) but the wrapped spliterator may choose to
   * not support splitting.  When the returned stream is closed, the close
   * handlers for both the returned and this stream are invoked.
   *
   * @apiNote
   * While `dropWhile()` is generally a cheap operation on sequential
   * stream pipelines, it can be quite expensive on ordered parallel
   * pipelines, since the operation is constrained to return not just any
   * valid prefix, but the longest prefix of elements in the encounter order.
   * Using an unordered stream source (such as {@link #generate(Supplier)}) or
   * removing the ordering constraint with {@link #unordered()} may result in
   * significant speedups of `dropWhile()` in parallel pipelines, if the
   * semantics of your situation permit.  If consistency with encounter order
   * is required, and you are experiencing poor performance or memory
   * utilization with `dropWhile()` in parallel pipelines, switching to
   * sequential execution with {@link #sequential()} may improve performance.
   *
   * @param predicate a non-interfering,
   *                  stateless
   *                  predicate to apply to elements to determine the longest
   *                  prefix of elements.
   * @return the new stream
   * @since 9
  */
  dropWhile(predicate: Predicate<any>): Stream<T>;
  /**
   * Performs an action for each element of this stream.
   *
   * This is a terminal
   * operation.
   *
   * The behavior of this operation is explicitly nondeterministic.
   * For parallel stream pipelines, this operation does not
   * guarantee to respect the encounter order of the stream, as doing so
   * would sacrifice the benefit of parallelism.  For any given element, the
   * action may be performed at whatever time and in whatever thread the
   * library chooses.  If the action accesses shared state, it is
   * responsible for providing the required synchronization.
   *
   * @param action a 
   *               non-interfering action to perform on the elements
  */
  forEach(action: Consumer<any>): void;
  /**
   * Performs an action for each element of this stream, in the encounter
   * order of the stream if the stream has a defined encounter order.
   *
   * This is a terminal
   * operation.
   *
   * This operation processes the elements one at a time, in encounter
   * order if one exists.  Performing the action for one element
   * happens-before
   * performing the action for subsequent elements, but for any given element,
   * the action may be performed in whatever thread the library chooses.
   *
   * @param action a 
   *               non-interfering action to perform on the elements
   * @see #forEach(Consumer)
  */
  forEachOrdered(action: Consumer<any>): void;
  /**
   * Returns an array containing the elements of this stream.
   *
   * This is a terminal
   * operation.
   *
   * @return an array, whose {@linkplain Class#getComponentType runtime component
   * type} is `Object`, containing the elements of this stream
  */
  toArray(): any[];
  /**
   * Returns an array containing the elements of this stream, using the
   * provided `generator` function to allocate the returned array, as
   * well as any additional arrays that might be required for a partitioned
   * execution or for resizing.
   *
   * This is a terminal
   * operation.
   *
   * @apiNote
   * The generator function takes an integer, which is the size of the
   * desired array, and produces an array of the desired size.  This can be
   * concisely expressed with an array constructor reference:
   * {@code
   *     Person[] men = people.stream()
   *                          .filter(p -> p.getGender() == MALE)
   *                          .toArray(Person[]::new);
   * }
   *
   * @param  the component type of the resulting array
   * @param generator a function which produces a new array of the desired
   *                  type and the provided length
   * @return an array containing the elements in this stream
   * @throws ArrayStoreException if the runtime type of any element of this
   *         stream is not assignable to the {@linkplain Class#getComponentType
   *         runtime component type} of the generated array
  */
  toArray<A>(generator: IntFunction<A[]>): A[];
  /**
   * Performs a reduction on the
   * elements of this stream, using the provided identity value and an
   * associative
   * accumulation function, and returns the reduced value.  This is equivalent
   * to:
   * {@code
   *     T result = identity;
   *     for (T element : this stream)
   *         result = accumulator.apply(result, element)
   *     return result;
   * }
   *
   * but is not constrained to execute sequentially.
   *
   * The `identity` value must be an identity for the accumulator
   * function. This means that for all `t`,
   * `accumulator.apply(identity, t)` is equal to `t`.
   * The `accumulator` function must be an
   * associative function.
   *
   * This is a terminal
   * operation.
   *
   * @apiNote Sum, min, max, average, and string concatenation are all special
   * cases of reduction. Summing a stream of numbers can be expressed as:
   *
   * {@code
   *     Integer sum = integers.reduce(0, (a, b) -> a+b);
   * }
   *
   * or:
   *
   * {@code
   *     Integer sum = integers.reduce(0, Integer::sum);
   * }
   *
   * While this may seem a more roundabout way to perform an aggregation
   * compared to simply mutating a running total in a loop, reduction
   * operations parallelize more gracefully, without needing additional
   * synchronization and with greatly reduced risk of data races.
   *
   * @param identity the identity value for the accumulating function
   * @param accumulator an associative,
   *                    non-interfering,
   *                    stateless
   *                    function for combining two values
   * @return the result of the reduction
  */
  reduce(identity: T, accumulator: BinaryOperator<T>): T;
  /**
   * Performs a reduction on the
   * elements of this stream, using an
   * associative accumulation
   * function, and returns an `Optional` describing the reduced value,
   * if any. This is equivalent to:
   * {@code
   *     boolean foundAny = false;
   *     T result = null;
   *     for (T element : this stream) {
   *         if (!foundAny) {
   *             foundAny = true;
   *             result = element;
   *         }
   *         else
   *             result = accumulator.apply(result, element);
   *     }
   *     return foundAny ? Optional.of(result) : Optional.empty();
   * }
   *
   * but is not constrained to execute sequentially.
   *
   * The `accumulator` function must be an
   * associative function.
   *
   * This is a terminal
   * operation.
   *
   * @param accumulator an associative,
   *                    non-interfering,
   *                    stateless
   *                    function for combining two values
   * @return an {@link Optional} describing the result of the reduction
   * @throws NullPointerException if the result of the reduction is null
   * @see #reduce(Object, BinaryOperator)
   * @see #min(Comparator)
   * @see #max(Comparator)
  */
  reduce(accumulator: BinaryOperator<T>): Optional<T>;
  /**
   * Performs a reduction on the
   * elements of this stream, using the provided identity, accumulation and
   * combining functions.  This is equivalent to:
   * {@code
   *     U result = identity;
   *     for (T element : this stream)
   *         result = accumulator.apply(result, element)
   *     return result;
   * }
   *
   * but is not constrained to execute sequentially.
   *
   * The `identity` value must be an identity for the combiner
   * function.  This means that for all `u`, `combiner(identity, u)`
   * is equal to `u`.  Additionally, the `combiner` function
   * must be compatible with the `accumulator` function; for all
   * `u` and `t`, the following must hold:
   * {@code
   *     combiner.apply(u, accumulator.apply(identity, t)) == accumulator.apply(u, t)
   * }
   *
   * This is a terminal
   * operation.
   *
   * @apiNote Many reductions using this form can be represented more simply
   * by an explicit combination of `map` and `reduce` operations.
   * The `accumulator` function acts as a fused mapper and accumulator,
   * which can sometimes be more efficient than separate mapping and reduction,
   * such as when knowing the previously reduced value allows you to avoid
   * some computation.
   *
   * @param  The type of the result
   * @param identity the identity value for the combiner function
   * @param accumulator an associative,
   *                    non-interfering,
   *                    stateless
   *                    function for incorporating an additional element into a result
   * @param combiner an associative,
   *                    non-interfering,
   *                    stateless
   *                    function for combining two values, which must be
   *                    compatible with the accumulator function
   * @return the result of the reduction
   * @see #reduce(BinaryOperator)
   * @see #reduce(Object, BinaryOperator)
  */
  reduce<U>(identity: U, accumulator: BiFunction<U, any, U>, combiner: BinaryOperator<U>): U;
  /**
   * Performs a mutable
   * reduction operation on the elements of this stream.  A mutable
   * reduction is one in which the reduced value is a mutable result container,
   * such as an `ArrayList`, and elements are incorporated by updating
   * the state of the result rather than by replacing the result.  This
   * produces a result equivalent to:
   * {@code
   *     R result = supplier.get();
   *     for (T element : this stream)
   *         accumulator.accept(result, element);
   *     return result;
   * }
   *
   * Like {@link #reduce(Object, BinaryOperator)}, `collect` operations
   * can be parallelized without requiring additional synchronization.
   *
   * This is a terminal
   * operation.
   *
   * @apiNote There are many existing classes in the JDK whose signatures are
   * well-suited for use with method references as arguments to `collect()`.
   * For example, the following will accumulate strings into an `ArrayList`:
   * {@code
   *     List asList = stringStream.collect(ArrayList::new, ArrayList::add,
   *                                                ArrayList::addAll);
   * }
   *
   * The following will take a stream of strings and concatenates them into a
   * single string:
   * {@code
   *     String concat = stringStream.collect(StringBuilder::new, StringBuilder::append,
   *                                          StringBuilder::append)
   *                                 .toString();
   * }
   *
   * @param  the type of the mutable result container
   * @param supplier a function that creates a new mutable result container.
   *                 For a parallel execution, this function may be called
   *                 multiple times and must return a fresh value each time.
   * @param accumulator an associative,
   *                    non-interfering,
   *                    stateless
   *                    function that must fold an element into a result
   *                    container.
   * @param combiner an associative,
   *                    non-interfering,
   *                    stateless
   *                    function that accepts two partial result containers
   *                    and merges them, which must be compatible with the
   *                    accumulator function.  The combiner function must fold
   *                    the elements from the second result container into the
   *                    first result container.
   * @return the result of the reduction
  */
  collect<R>(supplier: Supplier<R>, accumulator: BiConsumer<R, any>, combiner: BiConsumer<R, R>): R;
  /**
   * Performs a mutable
   * reduction operation on the elements of this stream using a
   * `Collector`.  A `Collector`
   * encapsulates the functions used as arguments to
   * {@link #collect(Supplier, BiConsumer, BiConsumer)}, allowing for reuse of
   * collection strategies and composition of collect operations such as
   * multiple-level grouping or partitioning.
   *
   * If the stream is parallel, and the `Collector`
   * is {@link Collector.Characteristics#CONCURRENT concurrent}, and
   * either the stream is unordered or the collector is
   * {@link Collector.Characteristics#UNORDERED unordered},
   * then a concurrent reduction will be performed (see {@link Collector} for
   * details on concurrent reduction.)
   *
   * This is a terminal
   * operation.
   *
   * When executed in parallel, multiple intermediate results may be
   * instantiated, populated, and merged so as to maintain isolation of
   * mutable data structures.  Therefore, even when executed in parallel
   * with non-thread-safe data structures (such as `ArrayList`), no
   * additional synchronization is needed for a parallel reduction.
   *
   * @apiNote
   * The following will accumulate strings into a List:
   * {@code
   *     List asList = stringStream.collect(Collectors.toList());
   * }
   *
   * The following will classify `Person` objects by city:
   * {@code
   *     Map> peopleByCity
   *         = personStream.collect(Collectors.groupingBy(Person::getCity));
   * }
   *
   * The following will classify `Person` objects by state and city,
   * cascading two `Collector`s together:
   * {@code
   *     Map>> peopleByStateAndCity
   *         = personStream.collect(Collectors.groupingBy(Person::getState,
   *                                                      Collectors.groupingBy(Person::getCity)));
   * }
   *
   * @param  the type of the result
   * @param  the intermediate accumulation type of the `Collector`
   * @param collector the `Collector` describing the reduction
   * @return the result of the reduction
   * @see #collect(Supplier, BiConsumer, BiConsumer)
   * @see Collectors
  */
  collect<R, A>(collector: Collector<any, A, R>): R;
  /**
   * Accumulates the elements of this stream into a `List`. The elements in
   * the list will be in this stream's encounter order, if one exists. The returned List
   * is unmodifiable; calls to any mutator method will always cause
   * `UnsupportedOperationException` to be thrown. There are no
   * guarantees on the implementation type or serializability of the returned List.
   *
   * The returned instance may be value-based.
   * Callers should make no assumptions about the identity of the returned instances.
   * Identity-sensitive operations on these instances (reference equality (`==`),
   * identity hash code, and synchronization) are unreliable and should be avoided.
   *
   * This is a terminal operation.
   *
   * @apiNote If more control over the returned object is required, use
   * {@link Collectors#toCollection(Supplier)}.
   *
   * @implSpec The implementation in this interface returns a List produced as if by the following:
   * {@code
   * Collections.unmodifiableList(new ArrayList<>(Arrays.asList(this.toArray())))
   * }
   *
   * @implNote Most instances of Stream will override this method and provide an implementation
   * that is highly optimized compared to the implementation in this interface.
   *
   * @return a List containing the stream elements
   *
   * @since 16
  */
  toList(): T[];
  /**
   * Returns the minimum element of this stream according to the provided
   * `Comparator`.  This is a special case of a
   * reduction.
   *
   * This is a terminal operation.
   *
   * @param comparator a non-interfering,
   *                   stateless
   *                   `Comparator` to compare elements of this stream
   * @return an `Optional` describing the minimum element of this stream,
   * or an empty `Optional` if the stream is empty
   * @throws NullPointerException if the minimum element is null
  */
  min(comparator: Comparator<any>): Optional<T>;
  /**
   * Returns the maximum element of this stream according to the provided
   * `Comparator`.  This is a special case of a
   * reduction.
   *
   * This is a terminal
   * operation.
   *
   * @param comparator a non-interfering,
   *                   stateless
   *                   `Comparator` to compare elements of this stream
   * @return an `Optional` describing the maximum element of this stream,
   * or an empty `Optional` if the stream is empty
   * @throws NullPointerException if the maximum element is null
  */
  max(comparator: Comparator<any>): Optional<T>;
  /**
   * Returns the count of elements in this stream.  This is a special case of
   * a reduction and is
   * equivalent to:
   * {@code
   *     return mapToLong(e -> 1L).sum();
   * }
   *
   * This is a terminal operation.
   *
   * @apiNote
   * An implementation may choose to not execute the stream pipeline (either
   * sequentially or in parallel) if it is capable of computing the count
   * directly from the stream source.  In such cases no source elements will
   * be traversed and no intermediate operations will be evaluated.
   * Behavioral parameters with side-effects, which are strongly discouraged
   * except for harmless cases such as debugging, may be affected.  For
   * example, consider the following stream:
   * {@code
   *     List l = Arrays.asList("A", "B", "C", "D");
   *     long count = l.stream().peek(System.out::println).count();
   * }
   * The number of elements covered by the stream source, a `List`, is
   * known and the intermediate operation, `peek`, does not inject into
   * or remove elements from the stream (as may be the case for
   * `flatMap` or `filter` operations).  Thus the count is the
   * size of the `List` and there is no need to execute the pipeline
   * and, as a side-effect, print out the list elements.
   *
   * @return the count of elements in this stream
  */
  count(): number;
  /**
   * Returns whether any elements of this stream match the provided
   * predicate.  May not evaluate the predicate on all elements if not
   * necessary for determining the result.  If the stream is empty then
   * `false` is returned and the predicate is not evaluated.
   *
   * This is a short-circuiting
   * terminal operation.
   *
   * @apiNote
   * This method evaluates the existential quantification of the
   * predicate over the elements of the stream (for some x P(x)).
   *
   * @param predicate a non-interfering,
   *                  stateless
   *                  predicate to apply to elements of this stream
   * @return `true` if any elements of the stream match the provided
   * predicate, otherwise `false`
  */
  anyMatch(predicate: Predicate<any>): boolean;
  /**
   * Returns whether all elements of this stream match the provided predicate.
   * May not evaluate the predicate on all elements if not necessary for
   * determining the result.  If the stream is empty then `true` is
   * returned and the predicate is not evaluated.
   *
   * This is a short-circuiting
   * terminal operation.
   *
   * @apiNote
   * This method evaluates the universal quantification of the
   * predicate over the elements of the stream (for all x P(x)).  If the
   * stream is empty, the quantification is said to be vacuously
   * satisfied and is always `true` (regardless of P(x)).
   *
   * @param predicate a non-interfering,
   *                  stateless
   *                  predicate to apply to elements of this stream
   * @return `true` if either all elements of the stream match the
   * provided predicate or the stream is empty, otherwise `false`
  */
  allMatch(predicate: Predicate<any>): boolean;
  /**
   * Returns whether no elements of this stream match the provided predicate.
   * May not evaluate the predicate on all elements if not necessary for
   * determining the result.  If the stream is empty then `true` is
   * returned and the predicate is not evaluated.
   *
   * This is a short-circuiting
   * terminal operation.
   *
   * @apiNote
   * This method evaluates the universal quantification of the
   * negated predicate over the elements of the stream (for all x ~P(x)).  If
   * the stream is empty, the quantification is said to be vacuously satisfied
   * and is always `true`, regardless of P(x).
   *
   * @param predicate a non-interfering,
   *                  stateless
   *                  predicate to apply to elements of this stream
   * @return `true` if either no elements of the stream match the
   * provided predicate or the stream is empty, otherwise `false`
  */
  noneMatch(predicate: Predicate<any>): boolean;
  /**
   * Returns an {@link Optional} describing the first element of this stream,
   * or an empty `Optional` if the stream is empty.  If the stream has
   * no encounter order, then any element may be returned.
   *
   * This is a short-circuiting
   * terminal operation.
   *
   * @return an `Optional` describing the first element of this stream,
   * or an empty `Optional` if the stream is empty
   * @throws NullPointerException if the element selected is null
  */
  findFirst(): Optional<T>;
  /**
   * Returns an {@link Optional} describing some element of the stream, or an
   * empty `Optional` if the stream is empty.
   *
   * This is a short-circuiting
   * terminal operation.
   *
   * The behavior of this operation is explicitly nondeterministic; it is
   * free to select any element in the stream.  This is to allow for maximal
   * performance in parallel operations; the cost is that multiple invocations
   * on the same source may not return the same result.  (If a stable result
   * is desired, use {@link #findFirst()} instead.)
   *
   * @return an `Optional` describing some element of this stream, or an
   * empty `Optional` if the stream is empty
   * @throws NullPointerException if the element selected is null
   * @see #findFirst()
  */
  findAny(): Optional<T>;
  /**
   * Returns a builder for a `Stream`.
   *
   * @param  type of elements
   * @return a stream builder
  */
  static builder<T>(): java_util_stream_Stream_Builder<T>;
  /**
   * Returns an empty sequential `Stream`.
   *
   * @param  the type of stream elements
   * @return an empty sequential stream
  */
  static empty<T>(): Stream<T>;
  /**
   * Returns a sequential `Stream` containing a single element.
   *
   * @param t the single element
   * @param  the type of stream elements
   * @return a singleton sequential stream
  */
  static of<T>(t: T): Stream<T>;
  /**
   * Returns a sequential `Stream` containing a single element, if
   * non-null, otherwise returns an empty `Stream`.
   *
   * @param t the single element
   * @param  the type of stream elements
   * @return a stream with a single element if the specified element
   *         is non-null, otherwise an empty stream
   * @since 9
  */
  static ofNullable<T>(t: T): Stream<T>;
  /**
   * Returns a sequential ordered stream whose elements are the specified values.
   *
   * @param  the type of stream elements
   * @param values the elements of the new stream
   * @return the new stream
  */
  static of<T>(...values: T[]): Stream<T>;
  /**
   * Returns an infinite sequential ordered `Stream` produced by iterative
   * application of a function `f` to an initial element `seed`,
   * producing a `Stream` consisting of `seed`, `f(seed)`,
   * `f(f(seed))`, etc.
   *
   * The first element (position `0`) in the `Stream` will be
   * the provided `seed`.  For `n > 0`, the element at position
   * `n`, will be the result of applying the function `f` to the
   * element at position `n - 1`.
   *
   * The action of applying `f` for one element
   * happens-before
   * the action of applying `f` for subsequent elements.  For any given
   * element the action may be performed in whatever thread the library
   * chooses.
   *
   * @param  the type of stream elements
   * @param seed the initial element
   * @param f a function to be applied to the previous element to produce
   *          a new element
   * @return a new sequential `Stream`
  */
  static iterate<T>(seed: T, f: UnaryOperator<T>): Stream<T>;
  /**
   * Returns a sequential ordered `Stream` produced by iterative
   * application of the given `next` function to an initial element,
   * conditioned on satisfying the given `hasNext` predicate.  The
   * stream terminates as soon as the `hasNext` predicate returns false.
   *
   * `Stream.iterate` should produce the same sequence of elements as
   * produced by the corresponding for-loop:
   * {@code
   *     for (T index=seed; hasNext.test(index); index = next.apply(index)) {
   *         ...
   *     }
   * }
   *
   * The resulting sequence may be empty if the `hasNext` predicate
   * does not hold on the seed value.  Otherwise the first element will be the
   * supplied `seed` value, the next element (if present) will be the
   * result of applying the `next` function to the `seed` value,
   * and so on iteratively until the `hasNext` predicate indicates that
   * the stream should terminate.
   *
   * The action of applying the `hasNext` predicate to an element
   * happens-before
   * the action of applying the `next` function to that element.  The
   * action of applying the `next` function for one element
   * happens-before the action of applying the `hasNext`
   * predicate for subsequent elements.  For any given element an action may
   * be performed in whatever thread the library chooses.
   *
   * @param  the type of stream elements
   * @param seed the initial element
   * @param hasNext a predicate to apply to elements to determine when the
   *                stream must terminate.
   * @param next a function to be applied to the previous element to produce
   *             a new element
   * @return a new sequential `Stream`
   * @since 9
  */
  static iterate<T>(seed: T, hasNext: Predicate<any>, next: UnaryOperator<T>): Stream<T>;
  /**
   * Returns an infinite sequential unordered stream where each element is
   * generated by the provided `Supplier`.  This is suitable for
   * generating constant streams, streams of random elements, etc.
   *
   * @param  the type of stream elements
   * @param s the `Supplier` of generated elements
   * @return a new infinite sequential unordered `Stream`
  */
  static generate<T>(s: Supplier<T>): Stream<T>;
  /**
   * Creates a lazily concatenated stream whose elements are all the
   * elements of the first stream followed by all the elements of the
   * second stream.  The resulting stream is ordered if both
   * of the input streams are ordered, and parallel if either of the input
   * streams is parallel.  When the resulting stream is closed, the close
   * handlers for both input streams are invoked.
   *
   * This method operates on the two input streams and binds each stream
   * to its source.  As a result subsequent modifications to an input stream
   * source may not be reflected in the concatenated stream result.
   *
   * @implNote
   * Use caution when constructing streams from repeated concatenation.
   * Accessing an element of a deeply concatenated stream can result in deep
   * call chains, or even `StackOverflowError`.
   *
   * Subsequent changes to the sequential/parallel execution mode of the
   * returned stream are not guaranteed to be propagated to the input streams.
   *
   * @apiNote
   * To preserve optimization opportunities this method binds each stream to
   * its source and accepts only two streams as parameters.  For example, the
   * exact size of the concatenated stream source can be computed if the exact
   * size of each input stream source is known.
   * To concatenate more streams without binding, or without nested calls to
   * this method, try creating a stream of streams and flat-mapping with the
   * identity function, for example:
   * {@code
   *     Stream concat = Stream.of(s1, s2, s3, s4).flatMap(s -> s);
   * }
   *
   * @param  The type of stream elements
   * @param a the first stream
   * @param b the second stream
   * @return the concatenation of the two input streams
  */
  static concat<T>(a: Stream<T>, b: Stream<T>): Stream<T>;
}
/**
 * Low-level utility methods for creating and manipulating streams.
 *
 * This class is mostly for library writers presenting stream views
 * of data structures; most static stream methods intended for end users are in
 * the various `Stream` classes.
 *
 * @since 1.8
*/
export class StreamSupport {
  /**
   * Creates a new sequential or parallel `Stream` from a
   * `Spliterator`.
   *
   * The spliterator is only traversed, split, or queried for estimated
   * size after the terminal operation of the stream pipeline commences.
   *
   * It is strongly recommended the spliterator report a characteristic of
   * `IMMUTABLE` or `CONCURRENT`, or be
   * late-binding.  Otherwise,
   * {@link #stream(java.util.function.Supplier, int, boolean)} should be used
   * to reduce the scope of potential interference with the source.  See
   * Non-Interference for
   * more details.
   *
   * @param  the type of stream elements
   * @param spliterator a `Spliterator` describing the stream elements
   * @param parallel if `true` then the returned stream is a parallel
   *        stream; if `false` the returned stream is a sequential
   *        stream.
   * @return a new sequential or parallel `Stream`
  */
  static stream<T>(spliterator: Spliterator<T>, parallel: boolean): Stream<T>;
  /**
   * Creates a new sequential or parallel `Stream` from a
   * `Supplier` of `Spliterator`.
   *
   * The {@link Supplier#get()} method will be invoked on the supplier no
   * more than once, and only after the terminal operation of the stream pipeline
   * commences.
   *
   * For spliterators that report a characteristic of `IMMUTABLE`
   * or `CONCURRENT`, or that are
   * late-binding, it is likely
   * more efficient to use {@link #stream(java.util.Spliterator, boolean)}
   * instead.
   * The use of a `Supplier` in this form provides a level of
   * indirection that reduces the scope of potential interference with the
   * source.  Since the supplier is only invoked after the terminal operation
   * commences, any modifications to the source up to the start of the
   * terminal operation are reflected in the stream result.  See
   * Non-Interference for
   * more details.
   *
   * @param  the type of stream elements
   * @param supplier a `Supplier` of a `Spliterator`
   * @param characteristics Spliterator characteristics of the supplied
   *        `Spliterator`.  The characteristics must be equal to
   *        `supplier.get().characteristics()`, otherwise undefined
   *        behavior may occur when terminal operation commences.
   * @param parallel if `true` then the returned stream is a parallel
   *        stream; if `false` the returned stream is a sequential
   *        stream.
   * @return a new sequential or parallel `Stream`
   * @see #stream(java.util.Spliterator, boolean)
  */
  static stream<T>(supplier: Supplier<Spliterator<T>>, characteristics: number, parallel: boolean): Stream<T>;
  /**
   * Creates a new sequential or parallel `IntStream` from a
   * `Spliterator.OfInt`.
   *
   * The spliterator is only traversed, split, or queried for estimated size
   * after the terminal operation of the stream pipeline commences.
   *
   * It is strongly recommended the spliterator report a characteristic of
   * `IMMUTABLE` or `CONCURRENT`, or be
   * late-binding.  Otherwise,
   * {@link #intStream(java.util.function.Supplier, int, boolean)} should be
   * used to reduce the scope of potential interference with the source.  See
   * Non-Interference for
   * more details.
   *
   * @param spliterator a `Spliterator.OfInt` describing the stream elements
   * @param parallel if `true` then the returned stream is a parallel
   *        stream; if `false` the returned stream is a sequential
   *        stream.
   * @return a new sequential or parallel `IntStream`
  */
  static intStream(spliterator: java_util_Spliterator_OfInt, parallel: boolean): IntStream;
  /**
   * Creates a new sequential or parallel `IntStream` from a
   * `Supplier` of `Spliterator.OfInt`.
   *
   * The {@link Supplier#get()} method will be invoked on the supplier no
   * more than once, and only after the terminal operation of the stream pipeline
   * commences.
   *
   * For spliterators that report a characteristic of `IMMUTABLE`
   * or `CONCURRENT`, or that are
   * late-binding, it is likely
   * more efficient to use {@link #intStream(java.util.Spliterator.OfInt, boolean)}
   * instead.
   * The use of a `Supplier` in this form provides a level of
   * indirection that reduces the scope of potential interference with the
   * source.  Since the supplier is only invoked after the terminal operation
   * commences, any modifications to the source up to the start of the
   * terminal operation are reflected in the stream result.  See
   * Non-Interference for
   * more details.
   *
   * @param supplier a `Supplier` of a `Spliterator.OfInt`
   * @param characteristics Spliterator characteristics of the supplied
   *        `Spliterator.OfInt`.  The characteristics must be equal to
   *        `supplier.get().characteristics()`, otherwise undefined
   *        behavior may occur when terminal operation commences.
   * @param parallel if `true` then the returned stream is a parallel
   *        stream; if `false` the returned stream is a sequential
   *        stream.
   * @return a new sequential or parallel `IntStream`
   * @see #intStream(java.util.Spliterator.OfInt, boolean)
  */
  static intStream(supplier: Supplier<java_util_Spliterator_OfInt>, characteristics: number, parallel: boolean): IntStream;
  /**
   * Creates a new sequential or parallel `LongStream` from a
   * `Spliterator.OfLong`.
   *
   * The spliterator is only traversed, split, or queried for estimated
   * size after the terminal operation of the stream pipeline commences.
   *
   * It is strongly recommended the spliterator report a characteristic of
   * `IMMUTABLE` or `CONCURRENT`, or be
   * late-binding.  Otherwise,
   * {@link #longStream(java.util.function.Supplier, int, boolean)} should be
   * used to reduce the scope of potential interference with the source.  See
   * Non-Interference for
   * more details.
   *
   * @param spliterator a `Spliterator.OfLong` describing the stream elements
   * @param parallel if `true` then the returned stream is a parallel
   *        stream; if `false` the returned stream is a sequential
   *        stream.
   * @return a new sequential or parallel `LongStream`
  */
  static longStream(spliterator: java_util_Spliterator_OfLong, parallel: boolean): LongStream;
  /**
   * Creates a new sequential or parallel `LongStream` from a
   * `Supplier` of `Spliterator.OfLong`.
   *
   * The {@link Supplier#get()} method will be invoked on the supplier no
   * more than once, and only after the terminal operation of the stream pipeline
   * commences.
   *
   * For spliterators that report a characteristic of `IMMUTABLE`
   * or `CONCURRENT`, or that are
   * late-binding, it is likely
   * more efficient to use {@link #longStream(java.util.Spliterator.OfLong, boolean)}
   * instead.
   * The use of a `Supplier` in this form provides a level of
   * indirection that reduces the scope of potential interference with the
   * source.  Since the supplier is only invoked after the terminal operation
   * commences, any modifications to the source up to the start of the
   * terminal operation are reflected in the stream result.  See
   * Non-Interference for
   * more details.
   *
   * @param supplier a `Supplier` of a `Spliterator.OfLong`
   * @param characteristics Spliterator characteristics of the supplied
   *        `Spliterator.OfLong`.  The characteristics must be equal to
   *        `supplier.get().characteristics()`, otherwise undefined
   *        behavior may occur when terminal operation commences.
   * @param parallel if `true` then the returned stream is a parallel
   *        stream; if `false` the returned stream is a sequential
   *        stream.
   * @return a new sequential or parallel `LongStream`
   * @see #longStream(java.util.Spliterator.OfLong, boolean)
  */
  static longStream(supplier: Supplier<java_util_Spliterator_OfLong>, characteristics: number, parallel: boolean): LongStream;
  /**
   * Creates a new sequential or parallel `DoubleStream` from a
   * `Spliterator.OfDouble`.
   *
   * The spliterator is only traversed, split, or queried for estimated size
   * after the terminal operation of the stream pipeline commences.
   *
   * It is strongly recommended the spliterator report a characteristic of
   * `IMMUTABLE` or `CONCURRENT`, or be
   * late-binding.  Otherwise,
   * {@link #doubleStream(java.util.function.Supplier, int, boolean)} should
   * be used to reduce the scope of potential interference with the source.  See
   * Non-Interference for
   * more details.
   *
   * @param spliterator A `Spliterator.OfDouble` describing the stream elements
   * @param parallel if `true` then the returned stream is a parallel
   *        stream; if `false` the returned stream is a sequential
   *        stream.
   * @return a new sequential or parallel `DoubleStream`
  */
  static doubleStream(spliterator: java_util_Spliterator_OfDouble, parallel: boolean): DoubleStream;
  /**
   * Creates a new sequential or parallel `DoubleStream` from a
   * `Supplier` of `Spliterator.OfDouble`.
   *
   * The {@link Supplier#get()} method will be invoked on the supplier no
   * more than once, and only after the terminal operation of the stream pipeline
   * commences.
   *
   * For spliterators that report a characteristic of `IMMUTABLE`
   * or `CONCURRENT`, or that are
   * late-binding, it is likely
   * more efficient to use {@link #doubleStream(java.util.Spliterator.OfDouble, boolean)}
   * instead.
   * The use of a `Supplier` in this form provides a level of
   * indirection that reduces the scope of potential interference with the
   * source.  Since the supplier is only invoked after the terminal operation
   * commences, any modifications to the source up to the start of the
   * terminal operation are reflected in the stream result.  See
   * Non-Interference for
   * more details.
   *
   * @param supplier A `Supplier` of a `Spliterator.OfDouble`
   * @param characteristics Spliterator characteristics of the supplied
   *        `Spliterator.OfDouble`.  The characteristics must be equal to
   *        `supplier.get().characteristics()`, otherwise undefined
   *        behavior may occur when terminal operation commences.
   * @param parallel if `true` then the returned stream is a parallel
   *        stream; if `false` the returned stream is a sequential
   *        stream.
   * @return a new sequential or parallel `DoubleStream`
   * @see #doubleStream(java.util.Spliterator.OfDouble, boolean)
  */
  static doubleStream(supplier: Supplier<java_util_Spliterator_OfDouble>, characteristics: number, parallel: boolean): DoubleStream;
}

}
declare module 'java.util.Calendar' {
import { Locale, TimeZone, Calendar, Date } from 'java.util';
/**
 * `Calendar.Builder` is used for creating a `Calendar` from
 * various date-time parameters.
 *
 * There are two ways to set a `Calendar` to a date-time value. One
 * is to set the instant parameter to a millisecond offset from the Epoch. The other is to set individual
 * field parameters, such as {@link Calendar#YEAR YEAR}, to their desired
 * values. These two ways can't be mixed. Trying to set both the instant and
 * individual fields will cause an {@link IllegalStateException} to be
 * thrown. However, it is permitted to override previous values of the
 * instant or field parameters.
 *
 * If no enough field parameters are given for determining date and/or
 * time, calendar specific default values are used when building a
 * `Calendar`. For example, if the {@link Calendar#YEAR YEAR} value
 * isn't given for the Gregorian calendar, 1970 will be used. If there are
 * any conflicts among field parameters, the  resolution rules are applied.
 * Therefore, the order of field setting matters.
 *
 * In addition to the date-time parameters,
 * the {@linkplain #setLocale(Locale) locale},
 * {@linkplain #setTimeZone(TimeZone) time zone},
 * {@linkplain #setWeekDefinition(int, int) week definition}, and
 * {@linkplain #setLenient(boolean) leniency mode} parameters can be set.
 *
 * Examples
 * The following are sample usages. Sample code assumes that the
 * `Calendar` constants are statically imported.
 *
 * The following code produces a `Calendar` with date 2012-12-31
 * (Gregorian) because Monday is the first day of a week with the  ISO 8601
 * compatible week parameters.
 *      *   Calendar cal = new Calendar.Builder().setCalendarType("iso8601")
 *                        .setWeekDate(2013, 1, MONDAY).build();
 * The following code produces a Japanese `Calendar` with date
 * 1989-01-08 (Gregorian), assuming that the default {@link Calendar#ERA ERA}
 * is Heisei that started on that day.
 *      *   Calendar cal = new Calendar.Builder().setCalendarType("japanese")
 *                        .setFields(YEAR, 1, DAY_OF_YEAR, 1).build();
 *
 * @since 1.8
 * @see Calendar#getInstance(TimeZone, Locale)
 * @see Calendar#fields
*/
export class Builder {
  /**
   * Constructs a `Calendar.Builder`.
  */
  constructor();
  /**
   * Sets the instant parameter to the given `instant` value that is
   * a millisecond offset from the
   * Epoch.
   *
   * @param instant a millisecond offset from the Epoch
   * @return this `Calendar.Builder`
   * @throws IllegalStateException if any of the field parameters have
   *                               already been set
   * @see Calendar#setTime(Date)
   * @see Calendar#setTimeInMillis(long)
   * @see Calendar#time
  */
  setInstant(instant: number): void;
  /**
   * Sets the instant parameter to the `instant` value given by a
   * {@link Date}. This method is equivalent to a call to
   * {@link #setInstant(long) setInstant(instant.getTime())}.
   *
   * @param instant a `Date` representing a millisecond offset from
   *                the Epoch
   * @return this `Calendar.Builder`
   * @throws NullPointerException  if `instant` is `null`
   * @throws IllegalStateException if any of the field parameters have
   *                               already been set
   * @see Calendar#setTime(Date)
   * @see Calendar#setTimeInMillis(long)
   * @see Calendar#time
  */
  setInstant(instant: Date): void;
  /**
   * Sets the `field` parameter to the given `value`.
   * `field` is an index to the {@link Calendar#fields}, such as
   * {@link Calendar#DAY_OF_MONTH DAY_OF_MONTH}. Field value validation is
   * not performed in this method. Any out of range values are either
   * normalized in lenient mode or detected as an invalid value in
   * non-lenient mode when building a `Calendar`.
   *
   * @param field an index to the `Calendar` fields
   * @param value the field value
   * @return this `Calendar.Builder`
   * @throws IllegalArgumentException if `field` is invalid
   * @throws IllegalStateException if the instant value has already been set,
   *                      or if fields have been set too many
   *                      (approximately {@link Integer#MAX_VALUE}) times.
   * @see Calendar#set(int, int)
  */
  set(field: number, value: number): Builder;
  /**
   * Sets field parameters to their values given by
   * `fieldValuePairs` that are pairs of a field and its value.
   * For example,
   *          *   setFields(Calendar.YEAR, 2013,
   *             Calendar.MONTH, Calendar.DECEMBER,
   *             Calendar.DAY_OF_MONTH, 23);
   * is equivalent to the sequence of the following
   * {@link #set(int, int) set} calls:
   *          *   set(Calendar.YEAR, 2013)
   *   .set(Calendar.MONTH, Calendar.DECEMBER)
   *   .set(Calendar.DAY_OF_MONTH, 23);
   *
   * @param fieldValuePairs field-value pairs
   * @return this `Calendar.Builder`
   * @throws NullPointerException if `fieldValuePairs` is `null`
   * @throws IllegalArgumentException if any of fields are invalid,
   *             or if `fieldValuePairs.length` is an odd number.
   * @throws IllegalStateException    if the instant value has been set,
   *             or if fields have been set too many (approximately
   *             {@link Integer#MAX_VALUE}) times.
  */
  setFields(fields: number[]);
  /**
   * Sets the date field parameters to the values given by `year`,
   * `month`, and `dayOfMonth`. This method is equivalent to
   * a call to:
   *          *   setFields(Calendar.YEAR, year,
   *             Calendar.MONTH, month,
   *             Calendar.DAY_OF_MONTH, dayOfMonth);
   *
   * @param year       the {@link Calendar#YEAR YEAR} value
   * @param month      the {@link Calendar#MONTH MONTH} value
   *                   (the month numbering is 0-based).
   * @param dayOfMonth the {@link Calendar#DAY_OF_MONTH DAY_OF_MONTH} value
   * @return this `Calendar.Builder`
  */
  setDate(year: number, month: number, dayOfMonth: number): Builder;
  /**
   * Sets the time of day field parameters to the values given by
   * `hourOfDay`, `minute`, and `second`. This method is
   * equivalent to a call to:
   *          *   setTimeOfDay(hourOfDay, minute, second, 0);
   *
   * @param hourOfDay the {@link Calendar#HOUR_OF_DAY HOUR_OF_DAY} value
   *                  (24-hour clock)
   * @param minute    the {@link Calendar#MINUTE MINUTE} value
   * @param second    the {@link Calendar#SECOND SECOND} value
   * @return this `Calendar.Builder`
  */
  setTimeOfDay(hourOfDay: number, minute: number, second: number): Builder;
  /**
   * Sets the time of day field parameters to the values given by
   * `hourOfDay`, `minute`, `second`, and
   * `millis`. This method is equivalent to a call to:
   *          *   setFields(Calendar.HOUR_OF_DAY, hourOfDay,
   *             Calendar.MINUTE, minute,
   *             Calendar.SECOND, second,
   *             Calendar.MILLISECOND, millis);
   *
   * @param hourOfDay the {@link Calendar#HOUR_OF_DAY HOUR_OF_DAY} value
   *                  (24-hour clock)
   * @param minute    the {@link Calendar#MINUTE MINUTE} value
   * @param second    the {@link Calendar#SECOND SECOND} value
   * @param millis    the {@link Calendar#MILLISECOND MILLISECOND} value
   * @return this `Calendar.Builder`
  */
  setTimeOfDay(hourOfDay: number, minute: number, second: number, millis: number): Builder;
  /**
   * Sets the week-based date parameters to the values with the given
   * date specifiers - week year, week of year, and day of week.
   *
   * If the specified calendar doesn't support week dates, the
   * {@link #build() build} method will throw an {@link IllegalArgumentException}.
   *
   * @param weekYear   the week year
   * @param weekOfYear the week number based on `weekYear`
   * @param dayOfWeek  the day of week value: one of the constants
   *     for the {@link Calendar#DAY_OF_WEEK DAY_OF_WEEK} field:
   *     {@link Calendar#SUNDAY SUNDAY}, ..., {@link Calendar#SATURDAY SATURDAY}.
   * @return this `Calendar.Builder`
   * @see Calendar#setWeekDate(int, int, int)
   * @see Calendar#isWeekDateSupported()
  */
  setWeekDate(weekYear: number, weekOfYear: number, dayOfWeek: number): Builder;
  /**
   * Sets the time zone parameter to the given `zone`. If no time
   * zone parameter is given to this `Calendar.Builder`, the
   * {@linkplain TimeZone#getDefault() default
   * `TimeZone`} will be used in the {@link #build() build}
   * method.
   *
   * @param zone the {@link TimeZone}
   * @return this `Calendar.Builder`
   * @throws NullPointerException if `zone` is `null`
   * @see Calendar#setTimeZone(TimeZone)
  */
  setTimeZone(timeZone: TimeZone);
  /**
   * Sets the lenient mode parameter to the value given by `lenient`.
   * If no lenient parameter is given to this `Calendar.Builder`,
   * lenient mode will be used in the {@link #build() build} method.
   *
   * @param lenient `true` for lenient mode;
   *                `false` for non-lenient mode
   * @return this `Calendar.Builder`
   * @see Calendar#setLenient(boolean)
  */
  setLenient(lenient: boolean): Builder;
  /**
   * Sets the calendar type parameter to the given `type`. The
   * calendar type given by this method has precedence over any explicit
   * or implicit calendar type given by the
   * {@linkplain #setLocale(Locale) locale}.
   *
   * In addition to the available calendar types returned by the
   * {@link Calendar#getAvailableCalendarTypes() Calendar.getAvailableCalendarTypes}
   * method, `"gregorian"` and `"iso8601"` as aliases of
   * `"gregory"` can be used with this method.
   *
   * @param type the calendar type
   * @return this `Calendar.Builder`
   * @throws NullPointerException if `type` is `null`
   * @throws IllegalArgumentException if `type` is unknown
   * @throws IllegalStateException if another calendar type has already been set
   * @see Calendar#getCalendarType()
   * @see Calendar#getAvailableCalendarTypes()
  */
  setCalendarType(calendarType: string);
  /**
   * Sets the locale parameter to the given `locale`. If no locale
   * is given to this `Calendar.Builder`, the {@linkplain
   * Locale#getDefault(Locale.Category) default `Locale`}
   * for {@link Locale.Category#FORMAT} will be used.
   *
   * If no calendar type is explicitly given by a call to the
   * {@link #setCalendarType(String) setCalendarType} method,
   * the `Locale` value is used to determine what type of
   * `Calendar` to be built.
   *
   * If no week definition parameters are explicitly given by a call to
   * the {@link #setWeekDefinition(int,int) setWeekDefinition} method, the
   * `Locale`'s default values are used.
   *
   * @param locale the {@link Locale}
   * @throws NullPointerException if `locale` is `null`
   * @return this `Calendar.Builder`
   * @see Calendar#getInstance(Locale)
  */
  setLocale(locale: Locale);
  /**
   * Sets the week definition parameters to the values given by
   * `firstDayOfWeek` and `minimalDaysInFirstWeek` that are
   * used to determine the first
   * week of a year. The parameters given by this method have
   * precedence over the default values given by the
   * {@linkplain #setLocale(Locale) locale}.
   *
   * @param firstDayOfWeek the first day of a week; one of
   *                       {@link Calendar#SUNDAY} to {@link Calendar#SATURDAY}
   * @param minimalDaysInFirstWeek the minimal number of days in the first
   *                               week (1..7)
   * @return this `Calendar.Builder`
   * @throws IllegalArgumentException if `firstDayOfWeek` or
   *                                  `minimalDaysInFirstWeek` is invalid
   * @see Calendar#getFirstDayOfWeek()
   * @see Calendar#getMinimalDaysInFirstWeek()
  */
  setWeekDefinition(firstDayOfWeek: number, minimalDaysInFirstWeek: number): Builder;
  /**
   * Returns a `Calendar` built from the parameters set by the
   * setter methods. The calendar type given by the {@link #setCalendarType(String)
   * setCalendarType} method or the {@linkplain #setLocale(Locale) locale} is
   * used to determine what `Calendar` to be created. If no explicit
   * calendar type is given, the locale's default calendar is created.
   *
   * If the calendar type is `"iso8601"`, the
   * {@linkplain GregorianCalendar#setGregorianChange(Date) Gregorian change date}
   * of a {@link GregorianCalendar} is set to `Date(Long.MIN_VALUE)`
   * to be the proleptic Gregorian calendar. Its week definition
   * parameters are also set to be compatible
   * with the ISO 8601 standard. Note that the
   * {@link GregorianCalendar#getCalendarType() getCalendarType} method of
   * a `GregorianCalendar` created with `"iso8601"` returns
   * `"gregory"`.
   *
   * The default values are used for locale and time zone if these
   * parameters haven't been given explicitly.
   * 
   * If the locale contains the time zone with "tz"
   * Unicode extension,
   * and time zone hasn't been given explicitly, time zone in the locale
   * is used.
   *
   * Any out of range field values are either normalized in lenient
   * mode or detected as an invalid value in non-lenient mode.
   *
   * @return a `Calendar` built with parameters of this `         *         Calendar.Builder`
   * @throws IllegalArgumentException if the calendar type is unknown, or
   *             if any invalid field values are given in non-lenient mode, or
   *             if a week date is given for the calendar type that doesn't
   *             support week dates.
   * @see Calendar#getInstance(TimeZone, Locale)
   * @see Locale#getDefault(Locale.Category)
   * @see TimeZone#getDefault()
  */
  build(): Calendar;
}

}
declare module 'java.util.ResourceBundle' {
import { ClassLoader } from 'java.lang';
import { Locale, List, ResourceBundle } from 'java.util';
import { CandidateListCache } from 'java.util.ResourceBundle.Control';
/**
 * `ResourceBundle.Control` defines a set of callback methods
 * that are invoked by the {@link ResourceBundle#getBundle(String,
 * Locale, ClassLoader, Control) ResourceBundle.getBundle} factory
 * methods during the bundle loading process. In other words, a
 * `ResourceBundle.Control` collaborates with the factory
 * methods for loading resource bundles. The default implementation of
 * the callback methods provides the information necessary for the
 * factory methods to perform the default behavior.
 *
 *  {@link ResourceBundle.Control} is designed for an application deployed
 * in an unnamed module, for example to support resource bundles in
 * non-standard formats or package localized resources in a non-traditional
 * convention. {@link ResourceBundleProvider} is the replacement for
 * `ResourceBundle.Control` when migrating to modules.
 * `UnsupportedOperationException` will be thrown when a factory
 * method that takes the `ResourceBundle.Control` parameter is called.
 *
 * In addition to the callback methods, the {@link
 * #toBundleName(String, Locale) toBundleName} and {@link
 * #toResourceName(String, String) toResourceName} methods are defined
 * primarily for convenience in implementing the callback
 * methods. However, the `toBundleName` method could be
 * overridden to provide different conventions in the organization and
 * packaging of localized resources.  The `toResourceName`
 * method is `final` to avoid use of wrong resource and class
 * name separators.
 *
 * Two factory methods, {@link #getControl(List)} and {@link
 * #getNoFallbackControl(List)}, provide
 * `ResourceBundle.Control` instances that implement common
 * variations of the default bundle loading process.
 *
 * The formats returned by the {@link Control#getFormats(String)
 * getFormats} method and candidate locales returned by the {@link
 * ResourceBundle.Control#getCandidateLocales(String, Locale)
 * getCandidateLocales} method must be consistent in all
 * `ResourceBundle.getBundle` invocations for the same base
 * bundle. Otherwise, the `ResourceBundle.getBundle` methods
 * may return unintended bundles. For example, if only
 * `"java.class"` is returned by the `getFormats`
 * method for the first call to `ResourceBundle.getBundle`
 * and only `"java.properties"` for the second call, then the
 * second call will return the class-based one that has been cached
 * during the first call.
 *
 * A `ResourceBundle.Control` instance must be thread-safe
 * if it's simultaneously used by multiple threads.
 * `ResourceBundle.getBundle` does not synchronize to call
 * the `ResourceBundle.Control` methods. The default
 * implementations of the methods are thread-safe.
 *
 * Applications can specify `ResourceBundle.Control`
 * instances returned by the `getControl` factory methods or
 * created from a subclass of `ResourceBundle.Control` to
 * customize the bundle loading process. The following are examples of
 * changing the default bundle loading process.
 *
 * Example 1
 *
 * The following code lets `ResourceBundle.getBundle` look
 * up only properties-based resources.
 *
 *      * import java.util.*;
 * import static java.util.ResourceBundle.Control.*;
 * ...
 * ResourceBundle bundle =
 *   ResourceBundle.getBundle("MyResources", new Locale("fr", "CH"),
 *                            ResourceBundle.Control.getControl(FORMAT_PROPERTIES));
 * 
 *
 * Given the resource bundles in the example in
 * the `ResourceBundle.getBundle` description, this
 * `ResourceBundle.getBundle` call loads
 * `MyResources_fr_CH.properties` whose parent is
 * `MyResources_fr.properties` whose parent is
 * `MyResources.properties`. (`MyResources_fr_CH.properties`
 * is not hidden, but `MyResources_fr_CH.class` is.)
 *
 * Example 2
 *
 * The following is an example of loading XML-based bundles
 * using {@link Properties#loadFromXML(java.io.InputStream)
 * Properties.loadFromXML}.
 *
 *      * ResourceBundle rb = ResourceBundle.getBundle("Messages",
 *     new ResourceBundle.Control() {
 *         public List<String> getFormats(String baseName) {
 *             if (baseName == null)
 *                 throw new NullPointerException();
 *             return Arrays.asList("xml");
 *         }
 *         public ResourceBundle newBundle(String baseName,
 *                                         Locale locale,
 *                                         String format,
 *                                         ClassLoader loader,
 *                                         boolean reload)
 *                          throws IllegalAccessException,
 *                                 InstantiationException,
 *                                 IOException {
 *             if (baseName == null || locale == null
 *                   || format == null || loader == null)
 *                 throw new NullPointerException();
 *             ResourceBundle bundle = null;
 *             if (format.equals("xml")) {
 *                 String bundleName = toBundleName(baseName, locale);
 *                 String resourceName = toResourceName(bundleName, format);
 *                 InputStream stream = null;
 *                 if (reload) {
 *                     URL url = loader.getResource(resourceName);
 *                     if (url != null) {
 *                         URLConnection connection = url.openConnection();
 *                         if (connection != null) {
 *                             // Disable caches to get fresh data for
 *                             // reloading.
 *                             connection.setUseCaches(false);
 *                             stream = connection.getInputStream();
 *                         }
 *                     }
 *                 } else {
 *                     stream = loader.getResourceAsStream(resourceName);
 *                 }
 *                 if (stream != null) {
 *                     BufferedInputStream bis = new BufferedInputStream(stream);
 *                     bundle = new XMLResourceBundle(bis);
 *                     bis.close();
 *                 }
 *             }
 *             return bundle;
 *         }
 *     });
 *
 * ...
 *
 * private static class XMLResourceBundle extends ResourceBundle {
 *     private Properties props;
 *     XMLResourceBundle(InputStream stream) throws IOException {
 *         props = new Properties();
 *         props.loadFromXML(stream);
 *     }
 *     protected Object handleGetObject(String key) {
 *         return props.getProperty(key);
 *     }
 *     public Enumeration<String> getKeys() {
 *         ...
 *     }
 * }
 * 
 *
 * @apiNote `ResourceBundle.Control` is not supported
 * in named modules. If the `ResourceBundle.getBundle` method with
 * a `ResourceBundle.Control` is called in a named module, the method
 * will throw an {@link UnsupportedOperationException}. Any service providers
 * of {@link ResourceBundleControlProvider} are ignored in named modules.
 *
 * @since 1.6
 * @revised 9
 * @see java.util.spi.ResourceBundleProvider
*/
export class Control {
  /**
   * The default format `List`, which contains the strings
   * `"java.class"` and `"java.properties"`, in
   * this order. This `List` is unmodifiable.
   *
   * @see #getFormats(String)
  */
  static readonly FORMAT_DEFAULT: string[];
  /**
   * The class-only format `List` containing
   * `"java.class"`. This `List` is unmodifiable.
   *
   * @see #getFormats(String)
  */
  static readonly FORMAT_CLASS: string[];
  /**
   * The properties-only format `List` containing
   * `"java.properties"`. This `List` is unmodifiable.
   *
   * @see #getFormats(String)
  */
  static readonly FORMAT_PROPERTIES: string[];
  /**
   * The time-to-live constant for not caching loaded resource bundle
   * instances.
   *
   * @see #getTimeToLive(String, Locale)
  */
  static readonly TTL_DONT_CACHE: number;
  /**
   * The time-to-live constant for disabling the expiration control
   * for loaded resource bundle instances in the cache.
   *
   * @see #getTimeToLive(String, Locale)
  */
  static readonly TTL_NO_EXPIRATION_CONTROL: number;
  /**
   * Returns a `ResourceBundle.Control` in which the {@link
   * #getFormats(String) getFormats} method returns the specified
   * `formats`. The `formats` must be equal to
   * one of {@link Control#FORMAT_PROPERTIES}, {@link
   * Control#FORMAT_CLASS} or {@link
   * Control#FORMAT_DEFAULT}. `ResourceBundle.Control`
   * instances returned by this method are singletons and thread-safe.
   *
   * Specifying {@link Control#FORMAT_DEFAULT} is equivalent to
   * instantiating the `ResourceBundle.Control` class,
   * except that this method returns a singleton.
   *
   * @param formats
   *        the formats to be returned by the
   *        `ResourceBundle.Control.getFormats` method
   * @return a `ResourceBundle.Control` supporting the
   *        specified `formats`
   * @throws    NullPointerException
   *        if `formats` is `null`
   * @throws    IllegalArgumentException
   *        if `formats` is unknown
  */
  static getControl(formats: string[]): Control;
  /**
   * Returns a `ResourceBundle.Control` in which the {@link
   * #getFormats(String) getFormats} method returns the specified
   * `formats` and the {@link
   * Control#getFallbackLocale(String, Locale) getFallbackLocale}
   * method returns `null`. The `formats` must
   * be equal to one of {@link Control#FORMAT_PROPERTIES}, {@link
   * Control#FORMAT_CLASS} or {@link Control#FORMAT_DEFAULT}.
   * `ResourceBundle.Control` instances returned by this
   * method are singletons and thread-safe.
   *
   * @param formats
   *        the formats to be returned by the
   *        `ResourceBundle.Control.getFormats` method
   * @return a `ResourceBundle.Control` supporting the
   *        specified `formats` with no fallback
   *        `Locale` support
   * @throws    NullPointerException
   *        if `formats` is `null`
   * @throws    IllegalArgumentException
   *        if `formats` is unknown
  */
  static getNoFallbackControl(formats: string[]): Control;
  /**
   * Returns a `List` of `String`s containing
   * formats to be used to load resource bundles for the given
   * `baseName`. The `ResourceBundle.getBundle`
   * factory method tries to load resource bundles with formats in the
   * order specified by the list. The list returned by this method
   * must have at least one `String`. The predefined
   * formats are `"java.class"` for class-based resource
   * bundles and `"java.properties"` for {@linkplain
   * PropertyResourceBundle properties-based} ones. Strings starting
   * with `"java."` are reserved for future extensions and
   * must not be used by application-defined formats.
   *
   * It is not a requirement to return an immutable (unmodifiable)
   * `List`.  However, the returned `List` must
   * not be mutated after it has been returned by
   * `getFormats`.
   *
   * The default implementation returns {@link #FORMAT_DEFAULT} so
   * that the `ResourceBundle.getBundle` factory method
   * looks up first class-based resource bundles, then
   * properties-based ones.
   *
   * @param baseName
   *        the base name of the resource bundle, a fully qualified class
   *        name
   * @return a `List` of `String`s containing
   *        formats for loading resource bundles.
   * @throws    NullPointerException
   *        if `baseName` is null
   * @see #FORMAT_DEFAULT
   * @see #FORMAT_CLASS
   * @see #FORMAT_PROPERTIES
  */
  getFormats(baseName: string): string[];
  /**
   * Returns a `List` of `Locale`s as candidate
   * locales for `baseName` and `locale`. This
   * method is called by the `ResourceBundle.getBundle`
   * factory method each time the factory method tries finding a
   * resource bundle for a target `Locale`.
   *
   * The sequence of the candidate locales also corresponds to the
   * runtime resource lookup path (also known as the parent
   * chain), if the corresponding resource bundles for the
   * candidate locales exist and their parents are not defined by
   * loaded resource bundles themselves.  The last element of the list
   * must be a {@linkplain Locale#ROOT root locale} if it is desired to
   * have the base bundle as the terminal of the parent chain.
   *
   * If the given locale is equal to `Locale.ROOT` (the
   * root locale), a `List` containing only the root
   * `Locale` must be returned. In this case, the
   * `ResourceBundle.getBundle` factory method loads only
   * the base bundle as the resulting resource bundle.
   *
   * It is not a requirement to return an immutable (unmodifiable)
   * `List`. However, the returned `List` must not
   * be mutated after it has been returned by
   * `getCandidateLocales`.
   *
   * The default implementation returns a `List` containing
   * `Locale`s using the rules described below.  In the
   * description below, L, S, C and V
   * respectively represent non-empty language, script, country, and
   * variant.  For example, [L, C] represents a
   * `Locale` that has non-empty values only for language and
   * country.  The form L("xx") represents the (non-empty)
   * language value is "xx".  For all cases, `Locale`s whose
   * final component values are empty strings are omitted.
   *
   * For an input `Locale` with an empty script value,
   * append candidate `Locale`s by omitting the final component
   * one by one as below:
   *
   * 
   *  [L, C, V] 
   *  [L, C] 
   *  [L] 
   *  `Locale.ROOT` 
   * 
   *
   * For an input `Locale` with a non-empty script value,
   * append candidate `Locale`s by omitting the final component
   * up to language, then append candidates generated from the
   * `Locale` with country and variant restored:
   *
   * 
   *  [L, S, C, V]
   *  [L, S, C]
   *  [L, S]
   *  [L, C, V]
   *  [L, C]
   *  [L]
   *  `Locale.ROOT`
   * 
   *
   * For an input `Locale` with a variant value consisting
   * of multiple subtags separated by underscore, generate candidate
   * `Locale`s by omitting the variant subtags one by one, then
   * insert them after every occurrence of ` Locale`s with the
   * full variant value in the original list.  For example, if
   * the variant consists of two subtags V1 and V2:
   *
   * 
   *  [L, S, C, V1, V2]
   *  [L, S, C, V1]
   *  [L, S, C]
   *  [L, S]
   *  [L, C, V1, V2]
   *  [L, C, V1]
   *  [L, C]
   *  [L]
   *  `Locale.ROOT`
   * 
   *
   * Special cases for Chinese.  When an input `Locale` has the
   * language "zh" (Chinese) and an empty script value, either "Hans" (Simplified) or
   * "Hant" (Traditional) might be supplied, depending on the country.
   * When the country is "CN" (China) or "SG" (Singapore), "Hans" is supplied.
   * When the country is "HK" (Hong Kong SAR China), "MO" (Macau SAR China),
   * or "TW" (Taiwan), "Hant" is supplied.  For all other countries or when the country
   * is empty, no script is supplied.  For example, for Locale("zh", "CN")
   * , the candidate list will be:
   * 
   *  [L("zh"), S("Hans"), C("CN")]
   *  [L("zh"), S("Hans")]
   *  [L("zh"), C("CN")]
   *  [L("zh")]
   *  `Locale.ROOT`
   * 
   *
   * For `Locale("zh", "TW")`, the candidate list will be:
   * 
   *  [L("zh"), S("Hant"), C("TW")]
   *  [L("zh"), S("Hant")]
   *  [L("zh"), C("TW")]
   *  [L("zh")]
   *  `Locale.ROOT`
   * 
   *
   * Special cases for Norwegian.  Both {@code Locale("no", "NO",
   * "NY")} and `Locale("nn", "NO")` represent Norwegian
   * Nynorsk.  When a locale's language is "nn", the standard candidate
   * list is generated up to [L("nn")], and then the following
   * candidates are added:
   *
   *  [L("no"), C("NO"), V("NY")]
   *  [L("no"), C("NO")]
   *  [L("no")]
   *  `Locale.ROOT`
   * 
   *
   * If the locale is exactly `Locale("no", "NO", "NY")`, it is first
   * converted to `Locale("nn", "NO")` and then the above procedure is
   * followed.
   *
   * Also, Java treats the language "no" as a synonym of Norwegian
   * Bokmål "nb".  Except for the single case {@code Locale("no",
   * "NO", "NY")} (handled above), when an input `Locale`
   * has language "no" or "nb", candidate `Locale`s with
   * language code "no" and "nb" are interleaved, first using the
   * requested language, then using its synonym. For example,
   * `Locale("nb", "NO", "POSIX")` generates the following
   * candidate list:
   *
   * 
   *  [L("nb"), C("NO"), V("POSIX")]
   *  [L("no"), C("NO"), V("POSIX")]
   *  [L("nb"), C("NO")]
   *  [L("no"), C("NO")]
   *  [L("nb")]
   *  [L("no")]
   *  `Locale.ROOT`
   * 
   *
   * `Locale("no", "NO", "POSIX")` would generate the same list
   * except that locales with "no" would appear before the corresponding
   * locales with "nb".
   * 
   *
   * The default implementation uses an {@link ArrayList} that
   * overriding implementations may modify before returning it to the
   * caller. However, a subclass must not modify it after it has
   * been returned by `getCandidateLocales`.
   *
   * For example, if the given `baseName` is "Messages"
   * and the given `locale` is
   * Locale("ja", "", "XX"), then a
   * `List` of `Locale`s:
   *          *     Locale("ja", "", "XX")
   *     Locale("ja")
   *     Locale.ROOT
   * 
   * is returned. And if the resource bundles for the "ja" and
   * "" `Locale`s are found, then the runtime resource
   * lookup path (parent chain) is:
   * {@code
   *     Messages_ja -> Messages
   * }
   *
   * @param baseName
   *        the base name of the resource bundle, a fully
   *        qualified class name
   * @param locale
   *        the locale for which a resource bundle is desired
   * @return a `List` of candidate
   *        `Locale`s for the given `locale`
   * @throws    NullPointerException
   *        if `baseName` or `locale` is
   *        `null`
  */
  getCandidateLocales(baseName: string, locale: Locale): Locale[];
  /**
   * Returns a `Locale` to be used as a fallback locale for
   * further resource bundle searches by the
   * `ResourceBundle.getBundle` factory method. This method
   * is called from the factory method every time when no resulting
   * resource bundle has been found for `baseName` and
   * `locale`, where locale is either the parameter for
   * `ResourceBundle.getBundle` or the previous fallback
   * locale returned by this method.
   *
   * The method returns `null` if no further fallback
   * search is desired.
   *
   * The default implementation returns the {@linkplain
   * Locale#getDefault() default `Locale`} if the given
   * `locale` isn't the default one.  Otherwise,
   * `null` is returned.
   *
   * @param baseName
   *        the base name of the resource bundle, a fully
   *        qualified class name for which
   *        `ResourceBundle.getBundle` has been
   *        unable to find any resource bundles (except for the
   *        base bundle)
   * @param locale
   *        the `Locale` for which
   *        `ResourceBundle.getBundle` has been
   *        unable to find any resource bundles (except for the
   *        base bundle)
   * @return a `Locale` for the fallback search,
   *        or `null` if no further fallback search
   *        is desired.
   * @throws    NullPointerException
   *        if `baseName` or `locale`
   *        is `null`
  */
  getFallbackLocale(baseName: string, locale: Locale): Locale;
  /**
   * Instantiates a resource bundle for the given bundle name of the
   * given format and locale, using the given class loader if
   * necessary. This method returns `null` if there is no
   * resource bundle available for the given parameters. If a resource
   * bundle can't be instantiated due to an unexpected error, the
   * error must be reported by throwing an `Error` or
   * `Exception` rather than simply returning
   * `null`.
   *
   * If the `reload` flag is `true`, it
   * indicates that this method is being called because the previously
   * loaded resource bundle has expired.
   *
   * @implSpec
   *
   * Resource bundles in named modules are subject to the encapsulation
   * rules specified by {@link Module#getResourceAsStream Module.getResourceAsStream}.
   * A resource bundle in a named module visible to the given class loader
   * is accessible when the package of the resource file corresponding
   * to the resource bundle is open unconditionally.
   *
   * The default implementation instantiates a
   * `ResourceBundle` as follows.
   *
   * 
   *
   * The bundle name is obtained by calling {@link
   * #toBundleName(String, Locale) toBundleName(baseName,
   * locale)}.
   *
   * If `format` is `"java.class"`, the
   * {@link Class} specified by the bundle name is loaded with the
   * given class loader. If the `Class` is found and accessible
   * then the `ResourceBundle` is instantiated.  The
   * resource bundle is accessible if the package of the bundle class file
   * is open unconditionally; otherwise, `IllegalAccessException`
   * will be thrown.
   * Note that the `reload` flag is ignored for loading
   * class-based resource bundles in this default implementation.
   * 
   *
   * If `format` is `"java.properties"`,
   * {@link #toResourceName(String, String) toResourceName(bundlename,
   * "properties")} is called to get the resource name.
   * If `reload` is `true`, {@link
   * ClassLoader#getResource(String) load.getResource} is called
   * to get a {@link URL} for creating a {@link
   * URLConnection}. This `URLConnection` is used to
   * {@linkplain URLConnection#setUseCaches(boolean) disable the
   * caches} of the underlying resource loading layers,
   * and to {@linkplain URLConnection#getInputStream() get an
   * `InputStream`}.
   * Otherwise, {@link ClassLoader#getResourceAsStream(String)
   * loader.getResourceAsStream} is called to get an {@link
   * InputStream}. Then, a {@link
   * PropertyResourceBundle} is constructed with the
   * `InputStream`.
   *
   * If `format` is neither `"java.class"`
   * nor `"java.properties"`, an
   * `IllegalArgumentException` is thrown.
   *
   * 
   *
   * @param baseName
   *        the base bundle name of the resource bundle, a fully
   *        qualified class name
   * @param locale
   *        the locale for which the resource bundle should be
   *        instantiated
   * @param format
   *        the resource bundle format to be loaded
   * @param loader
   *        the `ClassLoader` to use to load the bundle
   * @param reload
   *        the flag to indicate bundle reloading; `true`
   *        if reloading an expired resource bundle,
   *        `false` otherwise
   * @return the resource bundle instance,
   *        or `null` if none could be found.
   * @throws    NullPointerException
   *        if `bundleName`, `locale`,
   *        `format`, or `loader` is
   *        `null`, or if `null` is returned by
   *        {@link #toBundleName(String, Locale) toBundleName}
   * @throws    IllegalArgumentException
   *        if `format` is unknown, or if the resource
   *        found for the given parameters contains malformed data.
   * @throws    ClassCastException
   *        if the loaded class cannot be cast to `ResourceBundle`
   * @throws    IllegalAccessException
   *        if the class or its nullary constructor is not
   *        accessible.
   * @throws    InstantiationException
   *        if the instantiation of a class fails for some other
   *        reason.
   * @throws    ExceptionInInitializerError
   *        if the initialization provoked by this method fails.
   * @throws    SecurityException
   *        If a security manager is present and creation of new
   *        instances is denied. See {@link Class#newInstance()}
   *        for details.
   * @throws    IOException
   *        if an error occurred when reading resources using
   *        any I/O operations
   * @see java.util.spi.ResourceBundleProvider#getBundle(String, Locale)
   * @revised 9
  */
  newBundle(baseName: string, locale: Locale, format: string, loader: ClassLoader, reload: boolean): ResourceBundle;
  /**
   * Returns the time-to-live (TTL) value for resource bundles that
   * are loaded under this
   * `ResourceBundle.Control`. Positive time-to-live values
   * specify the number of milliseconds a bundle can remain in the
   * cache without being validated against the source data from which
   * it was constructed. The value 0 indicates that a bundle must be
   * validated each time it is retrieved from the cache. {@link
   * #TTL_DONT_CACHE} specifies that loaded resource bundles are not
   * put in the cache. {@link #TTL_NO_EXPIRATION_CONTROL} specifies
   * that loaded resource bundles are put in the cache with no
   * expiration control.
   *
   * The expiration affects only the bundle loading process by the
   * `ResourceBundle.getBundle` factory method.  That is,
   * if the factory method finds a resource bundle in the cache that
   * has expired, the factory method calls the {@link
   * #needsReload(String, Locale, String, ClassLoader, ResourceBundle,
   * long) needsReload} method to determine whether the resource
   * bundle needs to be reloaded. If `needsReload` returns
   * `true`, the cached resource bundle instance is removed
   * from the cache. Otherwise, the instance stays in the cache,
   * updated with the new TTL value returned by this method.
   *
   * All cached resource bundles are subject to removal from the
   * cache due to memory constraints of the runtime environment.
   * Returning a large positive value doesn't mean to lock loaded
   * resource bundles in the cache.
   *
   * The default implementation returns {@link #TTL_NO_EXPIRATION_CONTROL}.
   *
   * @param baseName
   *        the base name of the resource bundle for which the
   *        expiration value is specified.
   * @param locale
   *        the locale of the resource bundle for which the
   *        expiration value is specified.
   * @return the time (0 or a positive millisecond offset from the
   *        cached time) to get loaded bundles expired in the cache,
   *        {@link #TTL_NO_EXPIRATION_CONTROL} to disable the
   *        expiration control, or {@link #TTL_DONT_CACHE} to disable
   *        caching.
   * @throws    NullPointerException
   *        if `baseName` or `locale` is
   *        `null`
  */
  getTimeToLive(baseName: string, locale: Locale): number;
  /**
   * Determines if the expired `bundle` in the cache needs
   * to be reloaded based on the loading time given by
   * `loadTime` or some other criteria. The method returns
   * `true` if reloading is required; `false`
   * otherwise. `loadTime` is a millisecond offset since
   * the  `Calendar`
   * Epoch.
   *
   * 
   * The calling `ResourceBundle.getBundle` factory method
   * calls this method on the `ResourceBundle.Control`
   * instance used for its current invocation, not on the instance
   * used in the invocation that originally loaded the resource
   * bundle.
   *
   * The default implementation compares `loadTime` and
   * the last modified time of the source data of the resource
   * bundle. If it's determined that the source data has been modified
   * since `loadTime`, `true` is
   * returned. Otherwise, `false` is returned. This
   * implementation assumes that the given `format` is the
   * same string as its file suffix if it's not one of the default
   * formats, `"java.class"` or
   * `"java.properties"`.
   *
   * @param baseName
   *        the base bundle name of the resource bundle, a
   *        fully qualified class name
   * @param locale
   *        the locale for which the resource bundle
   *        should be instantiated
   * @param format
   *        the resource bundle format to be loaded
   * @param loader
   *        the `ClassLoader` to use to load the bundle
   * @param bundle
   *        the resource bundle instance that has been expired
   *        in the cache
   * @param loadTime
   *        the time when `bundle` was loaded and put
   *        in the cache
   * @return `true` if the expired bundle needs to be
   *        reloaded; `false` otherwise.
   * @throws    NullPointerException
   *        if `baseName`, `locale`,
   *        `format`, `loader`, or
   *        `bundle` is `null`
  */
  needsReload(baseName: string, locale: Locale, format: string, loader: ClassLoader, bundle: ResourceBundle, loadTime: number): boolean;
  /**
   * Converts the given `baseName` and `locale`
   * to the bundle name. This method is called from the default
   * implementation of the {@link #newBundle(String, Locale, String,
   * ClassLoader, boolean) newBundle} and {@link #needsReload(String,
   * Locale, String, ClassLoader, ResourceBundle, long) needsReload}
   * methods.
   *
   * This implementation returns the following value:
   *          *     baseName + "_" + language + "_" + script + "_" + country + "_" + variant
   * 
   * where `language`, `script`, `country`,
   * and `variant` are the language, script, country, and variant
   * values of `locale`, respectively. Final component values that
   * are empty Strings are omitted along with the preceding '_'.  When the
   * script is empty, the script value is omitted along with the preceding '_'.
   * If all of the values are empty strings, then `baseName`
   * is returned.
   *
   * For example, if `baseName` is
   * `"baseName"` and `locale` is
   * Locale("ja", "", "XX"), then
   * "baseName_ja_ _XX" is returned. If the given
   * locale is `Locale("en")`, then
   * `"baseName_en"` is returned.
   *
   * Overriding this method allows applications to use different
   * conventions in the organization and packaging of localized
   * resources.
   *
   * @param baseName
   *        the base name of the resource bundle, a fully
   *        qualified class name
   * @param locale
   *        the locale for which a resource bundle should be
   *        loaded
   * @return the bundle name for the resource bundle
   * @throws    NullPointerException
   *        if `baseName` or `locale`
   *        is `null`
   * @see java.util.spi.AbstractResourceBundleProvider#toBundleName(String, Locale)
  */
  toBundleName(baseName: string, locale: Locale): string;
  /**
   * Converts the given `bundleName` to the form required
   * by the {@link ClassLoader#getResource ClassLoader.getResource}
   * method by replacing all occurrences of `'.'` in
   * `bundleName` with `'/'` and appending a
   * `'.'` and the given file `suffix`. For
   * example, if `bundleName` is
   * `"foo.bar.MyResources_ja_JP"` and `suffix`
   * is `"properties"`, then
   * `"foo/bar/MyResources_ja_JP.properties"` is returned.
   *
   * @param bundleName
   *        the bundle name
   * @param suffix
   *        the file type suffix
   * @return the converted resource name
   * @throws    NullPointerException
   *         if `bundleName` or `suffix`
   *         is `null`
  */
  toResourceName(bundleName: string, suffix: string): string;
}

}
declare module 'java.util.stream.LongStream' {
import { LongStream } from 'java.util.stream';
import { LongConsumer } from 'java.util.function';
/**
 * A mutable builder for a `LongStream`.
 *
 * A stream builder has a lifecycle, which starts in a building
 * phase, during which elements can be added, and then transitions to a built
 * phase, after which elements may not be added.  The built phase begins
 * begins when the {@link #build()} method is called, which creates an
 * ordered stream whose elements are the elements that were added to the
 * stream builder, in the order they were added.
 *
 * @see LongStream#builder()
 * @since 1.8
*/
export class Builder extends LongConsumer {
  /**
   * Adds an element to the stream being built.
   *
   * @throws IllegalStateException if the builder has already transitioned
   * to the built state
  */
  accept(t: number): void;
  /**
   * Adds an element to the stream being built.
   *
   * @implSpec
   * The default implementation behaves as if:
   * {@code
   *     accept(t)
   *     return this;
   * }
   *
   * @param t the element to add
   * @return `this` builder
   * @throws IllegalStateException if the builder has already transitioned
   * to the built state
  */
  add(t: number): Builder;
  /**
   * Builds the stream, transitioning this builder to the built state.
   * An `IllegalStateException` is thrown if there are further
   * attempts to operate on the builder after it has entered the built
   * state.
   *
   * @return the built stream
   * @throws IllegalStateException if the builder has already transitioned
   * to the built state
  */
  build(): LongStream;
}
/**
 * Represents an operation that accepts a `long`-valued argument
 * and a LongConsumer, and returns no result. This functional interface is
 * used by {@link LongStream#mapMulti(LongStream.LongMapMultiConsumer) LongStream.mapMulti}
 * to replace a long value with zero or more long values.
 *
 * This is a functional interface
 * whose functional method is {@link #accept(long, LongConsumer)}.
 *
 * @see LongStream#mapMulti(LongStream.LongMapMultiConsumer)
 *
 * @since 16
*/
export class LongMapMultiConsumer {
  /**
   * Replaces the given `value` with zero or more values by feeding the mapped
   * values to the `lc` consumer.
   *
   * @param value the long value coming from upstream
   * @param lc a `LongConsumer` accepting the mapped values
  */
  accept(value: number, lc: LongConsumer): void;
}

}
declare module 'java.util.PrimitiveIterator' {
import { PrimitiveIterator } from 'java.util';
import { LongConsumer, DoubleConsumer, Consumer, IntConsumer } from 'java.util.function';
/**
 * An Iterator specialized for `int` values.
 * @since 1.8
*/
export class OfInt extends PrimitiveIterator<number, IntConsumer> {
  /**
   * Returns the next `int` element in the iteration.
   *
   * @return the next `int` element in the iteration
   * @throws NoSuchElementException if the iteration has no more elements
  */
  nextInt(): number;
  /**
   * Performs the given action for each remaining element until all elements
   * have been processed or the action throws an exception.  Actions are
   * performed in the order of iteration, if that order is specified.
   * Exceptions thrown by the action are relayed to the caller.
   *
   * @implSpec
   * The default implementation behaves as if:
   * {@code
   *     while (hasNext())
   *         action.accept(nextInt());
   * }
   *
   * @param action The action to be performed for each element
   * @throws NullPointerException if the specified action is null
  */
  forEachRemaining(action: IntConsumer): void;
  /**
   * {@inheritDoc}
   * @implSpec
   * The default implementation boxes the result of calling
   * {@link #nextInt()}, and returns that boxed result.
  */
  next(): number;
  /**
   * {@inheritDoc}
   * @implSpec
   * If the action is an instance of `IntConsumer` then it is cast
   * to `IntConsumer` and passed to {@link #forEachRemaining};
   * otherwise the action is adapted to an instance of
   * `IntConsumer`, by boxing the argument of `IntConsumer`,
   * and then passed to {@link #forEachRemaining}.
  */
  forEachRemaining(action: Consumer<any>): void;
}
/**
 * An Iterator specialized for `long` values.
 * @since 1.8
*/
export class OfLong extends PrimitiveIterator<number, LongConsumer> {
  /**
   * Returns the next `long` element in the iteration.
   *
   * @return the next `long` element in the iteration
   * @throws NoSuchElementException if the iteration has no more elements
  */
  nextLong(): number;
  /**
   * Performs the given action for each remaining element until all elements
   * have been processed or the action throws an exception.  Actions are
   * performed in the order of iteration, if that order is specified.
   * Exceptions thrown by the action are relayed to the caller.
   *
   * @implSpec
   * The default implementation behaves as if:
   * {@code
   *     while (hasNext())
   *         action.accept(nextLong());
   * }
   *
   * @param action The action to be performed for each element
   * @throws NullPointerException if the specified action is null
  */
  forEachRemaining(action: LongConsumer): void;
  /**
   * {@inheritDoc}
   * @implSpec
   * The default implementation boxes the result of calling
   * {@link #nextLong()}, and returns that boxed result.
  */
  next(): number;
  /**
   * {@inheritDoc}
   * @implSpec
   * If the action is an instance of `LongConsumer` then it is cast
   * to `LongConsumer` and passed to {@link #forEachRemaining};
   * otherwise the action is adapted to an instance of
   * `LongConsumer`, by boxing the argument of `LongConsumer`,
   * and then passed to {@link #forEachRemaining}.
  */
  forEachRemaining(action: Consumer<any>): void;
}
/**
 * An Iterator specialized for `double` values.
 * @since 1.8
*/
export class OfDouble extends PrimitiveIterator<number, DoubleConsumer> {
  /**
   * Returns the next `double` element in the iteration.
   *
   * @return the next `double` element in the iteration
   * @throws NoSuchElementException if the iteration has no more elements
  */
  nextDouble(): number;
  /**
   * Performs the given action for each remaining element until all elements
   * have been processed or the action throws an exception.  Actions are
   * performed in the order of iteration, if that order is specified.
   * Exceptions thrown by the action are relayed to the caller.
   *
   * @implSpec
   * The default implementation behaves as if:
   * {@code
   *     while (hasNext())
   *         action.accept(nextDouble());
   * }
   *
   * @param action The action to be performed for each element
   * @throws NullPointerException if the specified action is null
  */
  forEachRemaining(action: DoubleConsumer): void;
  /**
   * {@inheritDoc}
   * @implSpec
   * The default implementation boxes the result of calling
   * {@link #nextDouble()}, and returns that boxed result.
  */
  next(): number;
  /**
   * {@inheritDoc}
   * @implSpec
   * If the action is an instance of `DoubleConsumer` then it is
   * cast to `DoubleConsumer` and passed to
   * {@link #forEachRemaining}; otherwise the action is adapted to
   * an instance of `DoubleConsumer`, by boxing the argument of
   * `DoubleConsumer`, and then passed to
   * {@link #forEachRemaining}.
  */
  forEachRemaining(action: Consumer<any>): void;
}

}
declare module 'java.util.AbstractMap' {
import { Serializable } from 'java.io';
import { Entry } from 'java.util.Map';
/**
 * An Entry maintaining a key and a value.  The value may be
 * changed using the `setValue` method.  This class
 * facilitates the process of building custom map
 * implementations. For example, it may be convenient to return
 * arrays of `SimpleEntry` instances in method
 * `Map.entrySet().toArray`.
 *
 * @since 1.6
*/
export class SimpleEntry<K, V> extends Entry<K, V> {
  /**
   * Creates an entry representing a mapping from the specified
   * key to the specified value.
   *
   * @param key the key represented by this entry
   * @param value the value represented by this entry
  */
  constructor(key: K, value: V);
  /**
   * Creates an entry representing the same mapping as the
   * specified entry.
   *
   * @param entry the entry to copy
  */
  constructor(entry: Entry<K, V>);
  /**
   * Returns the key corresponding to this entry.
   *
   * @return the key corresponding to this entry
  */
  getKey(): K;
  /**
   * Returns the value corresponding to this entry.
   *
   * @return the value corresponding to this entry
  */
  getValue(): V;
  /**
   * Replaces the value corresponding to this entry with the specified
   * value.
   *
   * @param value new value to be stored in this entry
   * @return the old value corresponding to the entry
  */
  setValue(value: V);
  /**
   * Compares the specified object with this entry for equality.
   * Returns `true` if the given object is also a map entry and
   * the two entries represent the same mapping.  More formally, two
   * entries `e1` and `e2` represent the same mapping
   * if         *   (e1.getKey()==null ?
   *    e2.getKey()==null :
   *    e1.getKey().equals(e2.getKey()))
   *   &&
   *   (e1.getValue()==null ?
   *    e2.getValue()==null :
   *    e1.getValue().equals(e2.getValue()))
   * This ensures that the `equals` method works properly across
   * different implementations of the `Map.Entry` interface.
   *
   * @param o object to be compared for equality with this map entry
   * @return `true` if the specified object is equal to this map
   *         entry
   * @see    #hashCode
  */
  equals(o: any): boolean;
  /**
   * Returns the hash code value for this map entry.  The hash code
   * of a map entry `e` is defined to be:          *   (e.getKey()==null   ? 0 : e.getKey().hashCode()) ^
   *   (e.getValue()==null ? 0 : e.getValue().hashCode())
   * This ensures that `e1.equals(e2)` implies that
   * `e1.hashCode()==e2.hashCode()` for any two Entries
   * `e1` and `e2`, as required by the general
   * contract of {@link Object#hashCode}.
   *
   * @return the hash code value for this map entry
   * @see    #equals
  */
  hashCode(): number;
  /**
   * Returns a String representation of this map entry.  This
   * implementation returns the string representation of this
   * entry's key followed by the equals character ("`=`")
   * followed by the string representation of this entry's value.
   *
   * @return a String representation of this map entry
  */
  toString(): string;
}
export interface SimpleEntry<K, V> extends Entry<K, V>, Serializable {}
/**
 * An Entry maintaining an immutable key and value.  This class
 * does not support method `setValue`.  This class may be
 * convenient in methods that return thread-safe snapshots of
 * key-value mappings.
 *
 * @since 1.6
*/
export class SimpleImmutableEntry<K, V> extends Entry<K, V> {
  /**
   * Creates an entry representing a mapping from the specified
   * key to the specified value.
   *
   * @param key the key represented by this entry
   * @param value the value represented by this entry
  */
  constructor(key: K, value: V);
  /**
   * Creates an entry representing the same mapping as the
   * specified entry.
   *
   * @param entry the entry to copy
  */
  constructor(entry: Entry<K, V>);
  /**
   * Returns the key corresponding to this entry.
   *
   * @return the key corresponding to this entry
  */
  getKey(): K;
  /**
   * Returns the value corresponding to this entry.
   *
   * @return the value corresponding to this entry
  */
  getValue(): V;
  /**
   * Replaces the value corresponding to this entry with the specified
   * value (optional operation).  This implementation simply throws
   * `UnsupportedOperationException`, as this class implements
   * an immutable map entry.
   *
   * @param value new value to be stored in this entry
   * @return (Does not return)
   * @throws UnsupportedOperationException always
  */
  setValue(value: V);
  /**
   * Compares the specified object with this entry for equality.
   * Returns `true` if the given object is also a map entry and
   * the two entries represent the same mapping.  More formally, two
   * entries `e1` and `e2` represent the same mapping
   * if         *   (e1.getKey()==null ?
   *    e2.getKey()==null :
   *    e1.getKey().equals(e2.getKey()))
   *   &&
   *   (e1.getValue()==null ?
   *    e2.getValue()==null :
   *    e1.getValue().equals(e2.getValue()))
   * This ensures that the `equals` method works properly across
   * different implementations of the `Map.Entry` interface.
   *
   * @param o object to be compared for equality with this map entry
   * @return `true` if the specified object is equal to this map
   *         entry
   * @see    #hashCode
  */
  equals(o: any): boolean;
  /**
   * Returns the hash code value for this map entry.  The hash code
   * of a map entry `e` is defined to be:          *   (e.getKey()==null   ? 0 : e.getKey().hashCode()) ^
   *   (e.getValue()==null ? 0 : e.getValue().hashCode())
   * This ensures that `e1.equals(e2)` implies that
   * `e1.hashCode()==e2.hashCode()` for any two Entries
   * `e1` and `e2`, as required by the general
   * contract of {@link Object#hashCode}.
   *
   * @return the hash code value for this map entry
   * @see    #equals
  */
  hashCode(): number;
  /**
   * Returns a String representation of this map entry.  This
   * implementation returns the string representation of this
   * entry's key followed by the equals character ("`=`")
   * followed by the string representation of this entry's value.
   *
   * @return a String representation of this map entry
  */
  toString(): string;
}
export interface SimpleImmutableEntry<K, V> extends Entry<K, V>, Serializable {}

}
declare module 'java.util.jar' {
import { CodeSigner } from 'java.security';
import { ThreadLocal, Cloneable } from 'java.lang';
import { SoftReference } from 'java.lang.ref';
import { Enumeration, Set, Collection, Map } from 'java.util';
import { InputStream, OutputStream, File } from 'java.io';
import { Stream } from 'java.util.stream';
import { Entry } from 'java.util.Map';
import { Version } from 'java.lang.Runtime';
import { Certificate } from 'java.security.cert';
import { Name } from 'java.util.jar.Attributes';
import { ZipInputStream, ZipFile, ZipOutputStream, ZipEntry, ZipException } from 'java.util.zip';
/**
 * The Attributes class maps Manifest attribute names to associated string
 * values. Valid attribute names are case-insensitive, are restricted to
 * the ASCII characters in the set [0-9a-zA-Z_-], and cannot exceed 70
 * characters in length. There must be a colon and a SPACE after the name;
 * the combined length will not exceed 72 characters.
 * Attribute values can contain any characters and
 * will be UTF8-encoded when written to the output stream.  See the
 * JAR File Specification
 * for more information about valid attribute names and values.
 *
 * This map and its views have a predictable iteration order, namely the
 * order that keys were inserted into the map, as with {@link LinkedHashMap}.
 *
 * @author  David Connelly
 * @see     Manifest
 * @since   1.2
*/
export class Attributes extends Map<any, any> {
  /**
   * Constructs a new, empty Attributes object with default size.
  */
  constructor();
  /**
   * Constructs a new, empty Attributes object with the specified
   * initial size.
   *
   * @param size the initial number of attributes
  */
  constructor(size: number);
  /**
   * Constructs a new Attributes object with the same attribute name-value
   * mappings as in the specified Attributes.
   *
   * @param attr the specified Attributes
  */
  constructor(attr: Attributes);
  /**
   * Returns the value of the specified attribute name, or null if the
   * attribute name was not found.
   *
   * @param name the attribute name
   * @return the value of the specified attribute name, or null if
   *         not found.
  */
  get(name: any): any;
  /**
   * Returns the value of the specified attribute name, specified as
   * a string, or null if the attribute was not found. The attribute
   * name is case-insensitive.
   * 
   * This method is defined as:
   *      *      return (String)get(new Attributes.Name((String)name));
   * 
   *
   * @param name the attribute name as a string
   * @return the String value of the specified attribute name, or null if
   *         not found.
   * @throws IllegalArgumentException if the attribute name is invalid
  */
  getValue(name: string): string;
  /**
   * Returns the value of the specified Attributes.Name, or null if the
   * attribute was not found.
   * 
   * This method is defined as:
   *      *     return (String)get(name);
   * 
   *
   * @param name the Attributes.Name object
   * @return the String value of the specified Attribute.Name, or null if
   *         not found.
  */
  getValue(name: Name): string;
  /**
   * Associates the specified value with the specified attribute name
   * (key) in this Map. If the Map previously contained a mapping for
   * the attribute name, the old value is replaced.
   *
   * @param name the attribute name
   * @param value the attribute value
   * @return the previous value of the attribute, or null if none
   * @throws    ClassCastException if the name is not a Attributes.Name
   *            or the value is not a String
  */
  put(name: any, value: any): any;
  /**
   * Associates the specified value with the specified attribute name,
   * specified as a String. The attributes name is case-insensitive.
   * If the Map previously contained a mapping for the attribute name,
   * the old value is replaced.
   * 
   * This method is defined as:
   *      *      return (String)put(new Attributes.Name(name), value);
   * 
   *
   * @param name the attribute name as a string
   * @param value the attribute value
   * @return the previous value of the attribute, or null if none
   * @throws    IllegalArgumentException if the attribute name is invalid
  */
  putValue(name: string, value: string): string;
  /**
   * Removes the attribute with the specified name (key) from this Map.
   * Returns the previous attribute value, or null if none.
   *
   * @param name attribute name
   * @return the previous value of the attribute, or null if none
  */
  remove(name: any): any;
  /**
   * Returns true if this Map maps one or more attribute names (keys)
   * to the specified value.
   *
   * @param value the attribute value
   * @return true if this Map maps one or more attribute names to
   *         the specified value
  */
  containsValue(value: any): boolean;
  /**
   * Returns true if this Map contains the specified attribute name (key).
   *
   * @param name the attribute name
   * @return true if this Map contains the specified attribute name
  */
  containsKey(name: any): boolean;
  /**
   * Copies all of the attribute name-value mappings from the specified
   * Attributes to this Map. Duplicate mappings will be replaced.
   *
   * @param attr the Attributes to be stored in this map
   * @throws    ClassCastException if attr is not an Attributes
  */
  putAll(attr: Map<any, any>): void;
  /**
   * Removes all attributes from this Map.
  */
  clear(): void;
  /**
   * Returns the number of attributes in this Map.
  */
  size(): number;
  /**
   * Returns true if this Map contains no attributes.
  */
  isEmpty(): boolean;
  /**
   * Returns a Set view of the attribute names (keys) contained in this Map.
  */
  keySet(): Set<any>;
  /**
   * Returns a Collection view of the attribute values contained in this Map.
  */
  values(): Collection<any>;
  /**
   * Returns a Collection view of the attribute name-value mappings
   * contained in this Map.
  */
  entrySet(): Set<Entry<any, any>>;
  /**
   * Compares the specified object to the underlying
   * {@linkplain Attributes#map map} for equality.
   * Returns true if the given object is also a Map
   * and the two maps represent the same mappings.
   *
   * @param o the Object to be compared
   * @return true if the specified Object is equal to this Map
  */
  equals(o: any): boolean;
  /**
   * Returns the hash code value for this Map.
  */
  hashCode(): number;
  /**
   * Returns a copy of the Attributes, implemented as follows:
   *      *     public Object clone() { return new Attributes(this); }
   * 
   * Since the attribute names and values are themselves immutable,
   * the Attributes returned can be safely modified without affecting
   * the original.
  */
  clone(): any;
  /**
   * Associates the specified value with the specified key in this map
   * (optional operation).  If the map previously contained a mapping for
   * the key, the old value is replaced by the specified value.  (A map
   * `m` is said to contain a mapping for a key `k` if and only
   * if {@link #containsKey(Object) m.containsKey(k)} would return
   * `true`.)
   *
   * @param key key with which the specified value is to be associated
   * @param value value to be associated with the specified key
   * @return the previous value associated with `key`, or
   *         `null` if there was no mapping for `key`.
   *         (A `null` return can also indicate that the map
   *         previously associated `null` with `key`,
   *         if the implementation supports `null` values.)
   * @throws UnsupportedOperationException if the `put` operation
   *         is not supported by this map
   * @throws ClassCastException if the class of the specified key or value
   *         prevents it from being stored in this map
   * @throws NullPointerException if the specified key or value is null
   *         and this map does not permit null keys or values
   * @throws IllegalArgumentException if some property of the specified key
   *         or value prevents it from being stored in this map
  */
  put(key: K, value: V): V;
  /**
   * Removes the entry for the specified key only if it is currently
   * mapped to the specified value.
   *
   * @implSpec
   * The default implementation is equivalent to, for this `map`:
   *
   *  {@code
   * if (map.containsKey(key) && Objects.equals(map.get(key), value)) {
   *     map.remove(key);
   *     return true;
   * } else
   *     return false;
   * }
   *
   * The default implementation makes no guarantees about synchronization
   * or atomicity properties of this method. Any implementation providing
   * atomicity guarantees must override this method and document its
   * concurrency properties.
   *
   * @param key key with which the specified value is associated
   * @param value value expected to be associated with the specified key
   * @return `true` if the value was removed
   * @throws UnsupportedOperationException if the `remove` operation
   *         is not supported by this map
   *         (optional)
   * @throws ClassCastException if the key or value is of an inappropriate
   *         type for this map
   *         (optional)
   * @throws NullPointerException if the specified key or value is null,
   *         and this map does not permit null keys or values
   *         (optional)
   * @since 1.8
  */
  remove(key: any, value: any): boolean;
}
export interface Attributes extends Map<any, any>, Cloneable {}
/**
 * The `JarInputStream` class is used to read the contents of
 * a JAR file from any input stream. It extends the class
 * `java.util.zip.ZipInputStream` with support for reading
 * an optional `Manifest` entry. The `Manifest`
 * can be used to store meta-information about the JAR file and its entries.
 *
 * @author  David Connelly
 * @see     Manifest
 * @see     java.util.zip.ZipInputStream
 * @since   1.2
*/
export class JarInputStream extends ZipInputStream {
  /**
   * Creates a new `JarInputStream` and reads the optional
   * manifest. If a manifest is present, also attempts to verify
   * the signatures if the JarInputStream is signed.
   * @param in the actual input stream
   * @throws    IOException if an I/O error has occurred
  */
  constructor(in_: InputStream);
  /**
   * Creates a new `JarInputStream` and reads the optional
   * manifest. If a manifest is present and verify is true, also attempts
   * to verify the signatures if the JarInputStream is signed.
   *
   * @param in the actual input stream
   * @param verify whether or not to verify the JarInputStream if
   * it is signed.
   * @throws    IOException if an I/O error has occurred
  */
  constructor(in_: InputStream, verify: boolean);
  /**
   * Returns the `Manifest` for this JAR file, or
   * `null` if none.
   *
   * @return the `Manifest` for this JAR file, or
   *         `null` if none.
  */
  getManifest(): Manifest;
  /**
   * Reads the next ZIP file entry and positions the stream at the
   * beginning of the entry data. If verification has been enabled,
   * any invalid signature detected while positioning the stream for
   * the next entry will result in an exception.
   * @throws    ZipException if a ZIP file error has occurred
   * @throws    IOException if an I/O error has occurred
   * @throws    SecurityException if any of the jar file entries
   *         are incorrectly signed.
  */
  getNextEntry(): ZipEntry;
  /**
   * Reads the next JAR file entry and positions the stream at the
   * beginning of the entry data. If verification has been enabled,
   * any invalid signature detected while positioning the stream for
   * the next entry will result in an exception.
   * @return the next JAR file entry, or null if there are no more entries
   * @throws    ZipException if a ZIP file error has occurred
   * @throws    IOException if an I/O error has occurred
   * @throws    SecurityException if any of the jar file entries
   *         are incorrectly signed.
  */
  getNextJarEntry(): JarEntry;
  /**
   * Reads from the current JAR file entry into an array of bytes.
   * If `len` is not zero, the method
   * blocks until some input is available; otherwise, no
   * bytes are read and `0` is returned.
   * If verification has been enabled, any invalid signature
   * on the current entry will be reported at some point before the
   * end of the entry is reached.
   * @param b the buffer into which the data is read
   * @param off the start offset in the destination array `b`
   * @param len the maximum number of bytes to read
   * @return the actual number of bytes read, or -1 if the end of the
   *         entry is reached
   * @throws     NullPointerException If `b` is `null`.
   * @throws     IndexOutOfBoundsException If `off` is negative,
   * `len` is negative, or `len` is greater than
   * `b.length - off`
   * @throws    ZipException if a ZIP file error has occurred
   * @throws    IOException if an I/O error has occurred
   * @throws    SecurityException if any of the jar file entries
   *         are incorrectly signed.
  */
  read(b: number[], off: number, len: number): number;
  /**
   * Reads a byte of uncompressed data. This method will block until
   * enough input is available for decompression.
   * @return the byte read, or -1 if end of compressed input is reached
   * @throws    IOException if an I/O error has occurred
  */
  read(): number;
  /**
   * Reads up to `b.length` bytes of data from this
   * input stream into an array of bytes. This method blocks until some
   * input is available.
   * 
   * This method simply performs the call
   * `read(b, 0, b.length)` and returns
   * the  result. It is important that it does
   * not do `in.read(b)` instead;
   * certain subclasses of  `FilterInputStream`
   * depend on the implementation strategy actually
   * used.
   *
   * @param      b   the buffer into which the data is read.
   * @return     the total number of bytes read into the buffer, or
   *             `-1` if there is no more data because the end of
   *             the stream has been reached.
   * @throws     IOException  if an I/O error occurs.
   * @see        java.io.FilterInputStream#read(byte[], int, int)
  */
  read(b: number[]): number;
}
/**
 * The `JarOutputStream` class is used to write the contents
 * of a JAR file to any output stream. It extends the class
 * `java.util.zip.ZipOutputStream` with support
 * for writing an optional `Manifest` entry. The
 * `Manifest` can be used to specify meta-information about
 * the JAR file and its entries.
 *
 * @author  David Connelly
 * @see     Manifest
 * @see     java.util.zip.ZipOutputStream
 * @since   1.2
*/
export class JarOutputStream extends ZipOutputStream {
  /**
   * Creates a new `JarOutputStream` with the specified
   * `Manifest`. The manifest is written as the first
   * entry to the output stream.
   *
   * @param out the actual output stream
   * @param man the optional `Manifest`
   * @throws    IOException if an I/O error has occurred
  */
  constructor(out: OutputStream, man: Manifest);
  /**
   * Creates a new `JarOutputStream` with no manifest.
   * @param out the actual output stream
   * @throws    IOException if an I/O error has occurred
  */
  constructor(out: OutputStream);
  /**
   * Begins writing a new JAR file entry and positions the stream
   * to the start of the entry data. This method will also close
   * any previous entry.
   * 
   * The default compression method will be used if no compression
   * method was specified for the entry. When writing a compressed
   * (DEFLATED) entry, and the compressed size has not been explicitly
   * set with the {@link ZipEntry#setCompressedSize(long)} method,
   * then the compressed size will be set to the actual compressed
   * size after deflation.
   * 
   * The current time will be used if the entry has no set modification
   * time.
   *
   * @param ze the ZIP/JAR entry to be written
   * @throws    ZipException if a ZIP error has occurred
   * @throws    IOException if an I/O error has occurred
  */
  putNextEntry(ze: ZipEntry): void;
}
/**
 * The Manifest class is used to maintain Manifest entry names and their
 * associated Attributes. There are main Manifest Attributes as well as
 * per-entry Attributes. For information on the Manifest format, please
 * see the
 * 
 * Manifest format specification.
 *
 * @author  David Connelly
 * @see     Attributes
 * @since   1.2
*/
export class Manifest extends Cloneable {
  /**
   * Constructs a new, empty Manifest.
  */
  constructor();
  /**
   * Constructs a new Manifest from the specified input stream.
   *
   * @param is the input stream containing manifest data
   * @throws IOException if an I/O error has occurred
  */
  constructor(is: InputStream);
  /**
   * Constructs a new Manifest that is a copy of the specified Manifest.
   *
   * @param man the Manifest to copy
  */
  constructor(man: Manifest);
  /**
   * Returns the main Attributes for the Manifest.
   * @return the main Attributes for the Manifest
  */
  getMainAttributes(): Attributes;
  /**
   * Returns a Map of the entries contained in this Manifest. Each entry
   * is represented by a String name (key) and associated Attributes (value).
   * The Map permits the `null` key, but no entry with a null key is
   * created by {@link #read}, nor is such an entry written by using {@link
   * #write}.
   *
   * @return a Map of the entries contained in this Manifest
  */
  getEntries(): Map<string, Attributes>;
  /**
   * Returns the Attributes for the specified entry name.
   * This method is defined as:
   *      *      return (Attributes)getEntries().get(name)
   * 
   * Though `null` is a valid `name`, when
   * `getAttributes(null)` is invoked on a `Manifest`
   * obtained from a jar file, `null` will be returned.  While jar
   * files themselves do not allow `null`-named attributes, it is
   * possible to invoke {@link #getEntries} on a `Manifest`, and
   * on that result, invoke `put` with a null key and an
   * arbitrary value.  Subsequent invocations of
   * `getAttributes(null)` will return the just-`put`
   * value.
   * 
   * Note that this method does not return the manifest's main attributes;
   * see {@link #getMainAttributes}.
   *
   * @param name entry name
   * @return the Attributes for the specified entry name
  */
  getAttributes(name: string): Attributes;
  /**
   * Clears the main Attributes as well as the entries in this Manifest.
  */
  clear(): void;
  /**
   * Writes the Manifest to the specified OutputStream.
   * Attributes.Name.MANIFEST_VERSION must be set in
   * MainAttributes prior to invoking this method.
   *
   * @param out the output stream
   * @throws    IOException if an I/O error has occurred
   * @see #getMainAttributes
  */
  write(out: OutputStream): void;
  /**
   * Reads the Manifest from the specified InputStream. The entry
   * names and attributes read will be merged in with the current
   * manifest entries.
   *
   * @param is the input stream
   * @throws    IOException if an I/O error has occurred
  */
  read(is: InputStream): void;
  /**
   * Returns true if the specified Object is also a Manifest and has
   * the same main Attributes and entries.
   *
   * @param o the object to be compared
   * @return true if the specified Object is also a Manifest and has
   * the same main Attributes and entries
  */
  equals(o: any): boolean;
  /**
   * Returns the hash code for this Manifest.
  */
  hashCode(): number;
  /**
   * Returns a shallow copy of this Manifest.  The shallow copy is
   * implemented as follows:
   *      *     public Object clone() { return new Manifest(this); }
   * 
   * @return a shallow copy of this Manifest
  */
  clone(): any;
}
/**
 * Signals that an error of some sort has occurred while reading from
 * or writing to a JAR file.
 *
 * @author  David Connelly
 * @since   1.2
*/
export class JarException extends ZipException {
  /**
   * Constructs a JarException with no detail message.
  */
  constructor();
  /**
   * Constructs a JarException with the specified detail message.
   * @param s the detail message
  */
  constructor(s: string);
}
/**
 * This class is used to represent a JAR file entry.
 *
 * @since 1.2
*/
export class JarEntry extends ZipEntry {
  /**
   * Creates a new `JarEntry` for the specified JAR file
   * entry name.
   *
   * @param name the JAR file entry name
   * @throws    NullPointerException if the entry name is `null`
   * @throws    IllegalArgumentException if the entry name is longer than
   *            0xFFFF bytes.
  */
  constructor(name: string);
  /**
   * Creates a new `JarEntry` with fields taken from the
   * specified `ZipEntry` object.
   * @param ze the `ZipEntry` object to create the
   *           `JarEntry` from
  */
  constructor(ze: ZipEntry);
  /**
   * Creates a new `JarEntry` with fields taken from the
   * specified `JarEntry` object.
   *
   * @param je the `JarEntry` to copy
  */
  constructor(je: JarEntry);
  /**
   * Returns the `Manifest` `Attributes` for this
   * entry, or `null` if none.
   *
   * @return the `Manifest` `Attributes` for this
   * entry, or `null` if none
   * @throws IOException  if an I/O error has occurred
  */
  getAttributes(): Attributes;
  /**
   * Returns the `Certificate` objects for this entry, or
   * `null` if none. This method can only be called once
   * the `JarEntry` has been completely verified by reading
   * from the entry input stream until the end of the stream has been
   * reached. Otherwise, this method will return `null`.
   *
   * The returned certificate array comprises all the signer certificates
   * that were used to verify this entry. Each signer certificate is
   * followed by its supporting certificate chain (which may be empty).
   * Each signer certificate and its supporting certificate chain are ordered
   * bottom-to-top (i.e., with the signer certificate first and the (root)
   * certificate authority last).
   *
   * @return the `Certificate` objects for this entry, or
   * `null` if none.
  */
  getCertificates(): Certificate[];
  /**
   * Returns the `CodeSigner` objects for this entry, or
   * `null` if none. This method can only be called once
   * the `JarEntry` has been completely verified by reading
   * from the entry input stream until the end of the stream has been
   * reached. Otherwise, this method will return `null`.
   *
   * The returned array comprises all the code signers that have signed
   * this entry.
   *
   * @return the `CodeSigner` objects for this entry, or
   * `null` if none.
   *
   * @since 1.5
  */
  getCodeSigners(): CodeSigner[];
  /**
   * Returns the real name of this `JarEntry`.
   *
   * If this `JarEntry` is an entry of a
   * multi-release jar file and the
   * `JarFile` is configured to be processed as such, the name returned
   * by this method is the path name of the versioned entry that the
   * `JarEntry` represents, rather than the path name of the base entry
   * that {@link #getName()} returns. If the `JarEntry` does not represent
   * a versioned entry of a multi-release `JarFile` or the `JarFile`
   * is not configured for processing a multi-release jar file, this method
   * returns the same name that {@link #getName()} returns.
   *
   * @return the real name of the JarEntry
   *
   * @since 10
  */
  getRealName(): string;
}
/**
 * The `JarFile` class is used to read the contents of a jar file
 * from any file that can be opened with `java.io.RandomAccessFile`.
 * It extends the class `java.util.zip.ZipFile` with support
 * for reading an optional `Manifest` entry, and support for
 * processing multi-release jar files.  The `Manifest` can be used
 * to specify meta-information about the jar file and its entries.
 *
 * A multi-release jar file is a jar file that
 * contains a manifest with a main attribute named "Multi-Release",
 * a set of "base" entries, some of which are public classes with public
 * or protected methods that comprise the public interface of the jar file,
 * and a set of "versioned" entries contained in subdirectories of the
 * "META-INF/versions" directory.  The versioned entries are partitioned by the
 * major version of the Java platform.  A versioned entry, with a version
 * `n`, `8 < n`, in the "META-INF/versions/{n}" directory overrides
 * the base entry as well as any entry with a version number `i` where
 * `8 < i < n`.
 *
 * By default, a `JarFile` for a multi-release jar file is configured
 * to process the multi-release jar file as if it were a plain (unversioned) jar
 * file, and as such an entry name is associated with at most one base entry.
 * The `JarFile` may be configured to process a multi-release jar file by
 * creating the `JarFile` with the
 * {@link JarFile#JarFile(File, boolean, int, Runtime.Version)} constructor.  The
 * `Runtime.Version` object sets a maximum version used when searching for
 * versioned entries.  When so configured, an entry name
 * can correspond with at most one base entry and zero or more versioned
 * entries. A search is required to associate the entry name with the latest
 * versioned entry whose version is less than or equal to the maximum version
 * (see {@link #getEntry(String)}).
 *
 * Class loaders that utilize `JarFile` to load classes from the
 * contents of `JarFile` entries should construct the `JarFile`
 * by invoking the {@link JarFile#JarFile(File, boolean, int, Runtime.Version)}
 * constructor with the value `Runtime.version()` assigned to the last
 * argument.  This assures that classes compatible with the major
 * version of the running JVM are loaded from multi-release jar files.
 *
 *  If the `verify` flag is on when opening a signed jar file, the content
 * of the jar entry is verified against the signature embedded inside the manifest
 * that is associated with its {@link JarEntry#getRealName() path name}. For a
 * multi-release jar file, the content of a versioned entry is verfieid against
 * its own signature and {@link JarEntry#getCodeSigners()} returns its own signers.
 *
 * Please note that the verification process does not include validating the
 * signer's certificate. A caller should inspect the return value of
 * {@link JarEntry#getCodeSigners()} to further determine if the signature
 * can be trusted.
 *
 *  Unless otherwise noted, passing a `null` argument to a constructor
 * or method in this class will cause a {@link NullPointerException} to be
 * thrown.
 *
 * @implNote
 * 
 * If the API can not be used to configure a `JarFile` (e.g. to override
 * the configuration of a compiled application or library), two `System`
 * properties are available.
 * 
 * 
 * `jdk.util.jar.version` can be assigned a value that is the
 * `String` representation of a non-negative integer
 * `<= Runtime.version().feature()`.  The value is used to set the effective
 * runtime version to something other than the default value obtained by
 * evaluating `Runtime.version().feature()`. The effective runtime version
 * is the version that the {@link JarFile#JarFile(File, boolean, int, Runtime.Version)}
 * constructor uses when the value of the last argument is
 * `JarFile.runtimeVersion()`.
 * 
 * 
 * `jdk.util.jar.enableMultiRelease` can be assigned one of the three
 * `String` values true, false, or force.  The
 * value true, the default value, enables multi-release jar file
 * processing.  The value false disables multi-release jar processing,
 * ignoring the "Multi-Release" manifest attribute, and the versioned
 * directories in a multi-release jar file if they exist.  Furthermore,
 * the method {@link JarFile#isMultiRelease()} returns false. The value
 * force causes the `JarFile` to be initialized to runtime
 * versioning after construction.  It effectively does the same as this code:
 * `(new JarFile(File, boolean, int, JarFile.runtimeVersion())`.
 * 
 * 
 * 
 *
 * @author  David Connelly
 * @see     Manifest
 * @see     java.util.zip.ZipFile
 * @see     java.util.jar.JarEntry
 * @since   1.2
*/
export class JarFile extends ZipFile {
  /**
   * The JAR manifest file name.
  */
  static readonly MANIFEST_NAME: string;
  /**
   * Returns the version that represents the unversioned configuration of a
   * multi-release jar file.
   *
   * @return the version that represents the unversioned configuration
   *
   * @since 9
  */
  static baseVersion(): Version;
  /**
   * Returns the version that represents the effective runtime versioned
   * configuration of a multi-release jar file.
   * 
   * By default the feature version number of the returned `Version` will
   * be equal to the feature version number of `Runtime.version()`.
   * However, if the `jdk.util.jar.version` property is set, the
   * returned `Version` is derived from that property and feature version
   * numbers may not be equal.
   *
   * @return the version that represents the runtime versioned configuration
   *
   * @since 9
  */
  static runtimeVersion(): Version;
  /**
   * Creates a new `JarFile` to read from the specified
   * file `name`. The `JarFile` will be verified if
   * it is signed.
   * @param name the name of the jar file to be opened for reading
   * @throws IOException if an I/O error has occurred
   * @throws SecurityException if access to the file is denied
   *         by the SecurityManager
  */
  constructor(name: string);
  /**
   * Creates a new `JarFile` to read from the specified
   * file `name`.
   * @param name the name of the jar file to be opened for reading
   * @param verify whether or not to verify the jar file if
   * it is signed.
   * @throws IOException if an I/O error has occurred
   * @throws SecurityException if access to the file is denied
   *         by the SecurityManager
  */
  constructor(name: string, verify: boolean);
  /**
   * Creates a new `JarFile` to read from the specified
   * `File` object. The `JarFile` will be verified if
   * it is signed.
   * @param file the jar file to be opened for reading
   * @throws IOException if an I/O error has occurred
   * @throws SecurityException if access to the file is denied
   *         by the SecurityManager
  */
  constructor(file: File);
  /**
   * Creates a new `JarFile` to read from the specified
   * `File` object.
   * @param file the jar file to be opened for reading
   * @param verify whether or not to verify the jar file if
   * it is signed.
   * @throws IOException if an I/O error has occurred
   * @throws SecurityException if access to the file is denied
   *         by the SecurityManager.
  */
  constructor(file: File, verify: boolean);
  /**
   * Creates a new `JarFile` to read from the specified
   * `File` object in the specified mode.  The mode argument
   * must be either `OPEN_READ` or `OPEN_READ | OPEN_DELETE`.
   *
   * @param file the jar file to be opened for reading
   * @param verify whether or not to verify the jar file if
   * it is signed.
   * @param mode the mode in which the file is to be opened
   * @throws IOException if an I/O error has occurred
   * @throws IllegalArgumentException
   *         if the `mode` argument is invalid
   * @throws SecurityException if access to the file is denied
   *         by the SecurityManager
   * @since 1.3
  */
  constructor(file: File, verify: boolean, mode: number);
  /**
   * Creates a new `JarFile` to read from the specified
   * `File` object in the specified mode.  The mode argument
   * must be either `OPEN_READ` or `OPEN_READ | OPEN_DELETE`.
   * The version argument, after being converted to a canonical form, is
   * used to configure the `JarFile` for processing
   * multi-release jar files.
   * 
   * The canonical form derived from the version parameter is
   * `Runtime.Version.parse(Integer.toString(n))` where `n` is
   * `Math.max(version.feature(), JarFile.baseVersion().feature())`.
   *
   * @param file the jar file to be opened for reading
   * @param verify whether or not to verify the jar file if
   * it is signed.
   * @param mode the mode in which the file is to be opened
   * @param version specifies the release version for a multi-release jar file
   * @throws IOException if an I/O error has occurred
   * @throws IllegalArgumentException
   *         if the `mode` argument is invalid
   * @throws SecurityException if access to the file is denied
   *         by the SecurityManager
   * @throws NullPointerException if `version` is `null`
   * @since 9
  */
  constructor(file: File, verify: boolean, mode: number, version: Version);
  /**
   * Returns the maximum version used when searching for versioned entries.
   * 
   * If this `JarFile` is not a multi-release jar file or is not
   * configured to be processed as such, then the version returned will be the
   * same as that returned from {@link #baseVersion()}.
   *
   * @return the maximum version
   * @since 9
  */
  getVersion(): Version;
  /**
   * Indicates whether or not this jar file is a multi-release jar file.
   *
   * @return true if this JarFile is a multi-release jar file
   * @since 9
  */
  isMultiRelease(): boolean;
  /**
   * Returns the jar file manifest, or `null` if none.
   *
   * @return the jar file manifest, or `null` if none
   *
   * @throws IllegalStateException
   *         may be thrown if the jar file has been closed
   * @throws IOException  if an I/O error has occurred
  */
  getManifest(): Manifest;
  /**
   * Returns the `JarEntry` for the given base entry name or
   * `null` if not found.
   *
   * If this `JarFile` is a multi-release jar file and is configured
   * to be processed as such, then a search is performed to find and return
   * a `JarEntry` that is the latest versioned entry associated with the
   * given entry name.  The returned `JarEntry` is the versioned entry
   * corresponding to the given base entry name prefixed with the string
   * `"META-INF/versions/{n`/"}, for the largest value of `n` for
   * which an entry exists.  If such a versioned entry does not exist, then
   * the `JarEntry` for the base entry is returned, otherwise
   * `null` is returned if no entries are found.  The initial value for
   * the version `n` is the maximum version as returned by the method
   * {@link JarFile#getVersion()}.
   *
   * @param name the jar file entry name
   * @return the `JarEntry` for the given entry name, or
   *         the versioned entry name, or `null` if not found
   *
   * @throws IllegalStateException
   *         may be thrown if the jar file has been closed
   *
   * @see java.util.jar.JarEntry
   *
   * @implSpec
   * 
   * This implementation invokes {@link JarFile#getEntry(String)}.
   * 
  */
  getJarEntry(name: string): JarEntry;
  /**
   * Returns the `ZipEntry` for the given base entry name or
   * `null` if not found.
   *
   * If this `JarFile` is a multi-release jar file and is configured
   * to be processed as such, then a search is performed to find and return
   * a `ZipEntry` that is the latest versioned entry associated with the
   * given entry name.  The returned `ZipEntry` is the versioned entry
   * corresponding to the given base entry name prefixed with the string
   * `"META-INF/versions/{n`/"}, for the largest value of `n` for
   * which an entry exists.  If such a versioned entry does not exist, then
   * the `ZipEntry` for the base entry is returned, otherwise
   * `null` is returned if no entries are found.  The initial value for
   * the version `n` is the maximum version as returned by the method
   * {@link JarFile#getVersion()}.
   *
   * @param name the jar file entry name
   * @return the `ZipEntry` for the given entry name or
   *         the versioned entry name or `null` if not found
   *
   * @throws IllegalStateException
   *         may be thrown if the jar file has been closed
   *
   * @see java.util.zip.ZipEntry
   *
   * @implSpec
   * 
   * This implementation may return a versioned entry for the requested name
   * even if there is not a corresponding base entry.  This can occur
   * if there is a private or package-private versioned entry that matches.
   * If a subclass overrides this method, assure that the override method
   * invokes `super.getEntry(name)` to obtain all versioned entries.
   * 
  */
  getEntry(name: string): ZipEntry;
  /**
   * Returns an enumeration of the jar file entries.
   *
   * @return an enumeration of the jar file entries
   * @throws IllegalStateException
   *         may be thrown if the jar file has been closed
  */
  entries(): Enumeration<JarEntry>;
  /**
   * Returns an ordered `Stream` over the jar file entries.
   * Entries appear in the `Stream` in the order they appear in
   * the central directory of the jar file.
   *
   * @return an ordered `Stream` of entries in this jar file
   * @throws IllegalStateException if the jar file has been closed
   * @since 1.8
  */
  stream(): Stream<JarEntry>;
  /**
   * Returns a `Stream` of the versioned jar file entries.
   *
   * If this `JarFile` is a multi-release jar file and is configured to
   * be processed as such, then an entry in the stream is the latest versioned entry
   * associated with the corresponding base entry name. The maximum version of the
   * latest versioned entry is the version returned by {@link #getVersion()}.
   * The returned stream may include an entry that only exists as a versioned entry.
   *
   * If the jar file is not a multi-release jar file or the `JarFile` is not
   * configured for processing a multi-release jar file, this method returns the
   * same stream that {@link #stream()} returns.
   *
   * @return stream of versioned entries
   * @since 10
  */
  versionedStream(): Stream<JarEntry>;
  /**
   * Returns an input stream for reading the contents of the specified
   * zip file entry.
   * @param ze the zip file entry
   * @return an input stream for reading the contents of the specified
   *         zip file entry
   * @throws ZipException if a zip file format error has occurred
   * @throws IOException if an I/O error has occurred
   * @throws SecurityException if any of the jar file entries
   *         are incorrectly signed.
   * @throws IllegalStateException
   *         may be thrown if the jar file has been closed
  */
  getInputStream(ze: ZipEntry): InputStream;
}

}
